<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes" xml:space="preserve">
          <source>Compile a project given a valid configuration file.</source>
          <target state="translated">Скомпилируйте проект,получив действительный конфигурационный файл.</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes" xml:space="preserve">
          <source>Compiled with:</source>
          <target state="translated">Составлено с:</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes" xml:space="preserve">
          <source>Compiler Option</source>
          <target state="translated">Опция компилятора</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
          <target state="translated">Опции компилятора</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild</source>
          <target state="translated">Опции компилятора в MSBuild</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="translated">Опции компилятора в MSBuild:Картинки</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="translated">Опции компилятора в MSBuild:ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="translated">Опции компилятора в MSBuild:TypeScriptCompileBlocked .</target>
        </trans-unit>
        <trans-unit id="83eca665c1a302a482766697ff41e3f51468ae7d" translate="yes" xml:space="preserve">
          <source>Compiler configuration reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes" xml:space="preserve">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="translated">Опции компилятора могут быть заданы с помощью свойств MSBuild в рамках проекта MSBuild.</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes" xml:space="preserve">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; компилятора, указанные в командной строке, имеют приоритет над параметрами, указанными в файле tsconfig.json .</target>
        </trans-unit>
        <trans-unit id="7c791e1a441b19fea45de958fa56f9b5653c4878" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using compiler flags in TypeScript 3.8+, and environment variables before that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="translated">Компилятор поддерживает настройку просмотра файлов и каталогов с помощью переменных окружения.</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes" xml:space="preserve">
          <source>Compiles to exactly:</source>
          <target state="translated">Собирается точно:</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="translated">Компиляция &lt;code&gt;app.ts&lt;/code&gt; с использованием &lt;code&gt;--noResolve&lt;/code&gt; должна привести к:</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes" xml:space="preserve">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="translated">Компиляция и запуск выходных данных должны привести к правильному поведению на двигателе ES3/ES5.</target>
        </trans-unit>
        <trans-unit id="fc95d4c78f2f929f78993906b2bc165b4228618b" translate="yes" xml:space="preserve">
          <source>Compiling with &lt;code&gt;sourceMap&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; creates the following JavaScript file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes" xml:space="preserve">
          <source>Compiling your code</source>
          <target state="translated">Компиляция вашего кода</target>
        </trans-unit>
        <trans-unit id="521f1850ff33993c5964d68a9803ec6e468bad0b" translate="yes" xml:space="preserve">
          <source>Composing Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523183c97b725cfd5eba763765cb7911d0754153" translate="yes" xml:space="preserve">
          <source>Composite - &lt;code&gt;composite&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">Композитные проекты</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">Предполагаемые и постоянные члены</target>
        </trans-unit>
        <trans-unit id="ca1724f8382a9edb4d244befe1a458fd2670cf7c" translate="yes" xml:space="preserve">
          <source>Computed from the list of input files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">Расчетные свойства</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">Объедините &lt;code&gt;AMD&lt;/code&gt; и &lt;code&gt;System&lt;/code&gt; модули с помощью &lt;code&gt;--outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60da387f3f2a8e412f962b386bbaf111b07be7fc" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Объединить и передать вывод в один файл. Порядок конкатенации определяется списком файлов, переданных компилятору в командной строке вместе со ссылками на тройную косую черту и импортом. Дополнительную информацию см. В &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;документации&lt;/a&gt; по порядку выходных файлов .</target>
        </trans-unit>
        <trans-unit id="00c20ea179f46b34657af7c3ca762e28ca33f1eb" translate="yes" xml:space="preserve">
          <source>Concepts not in Haskell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e542d345cbe531aa5f8452be22d9352fd6b119c" translate="yes" xml:space="preserve">
          <source>Concepts similar to Haskell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">По идее, вы можете рассматривать тип &lt;code&gt;[number, string]&lt;/code&gt; как эквивалент следующего объявления &lt;code&gt;NumStrTuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">Условные типы</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">Условные типы особенно полезны в комбинации с нанесенными на карту типами:</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">Условные типы могут быть вложены,чтобы сформировать последовательность совпадений образцов,которые оцениваются по порядку:</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">Условные типы, в которых проверяемый тип является параметром голого типа, называются &lt;em&gt;распределительными условными типами&lt;/em&gt; . Распределительные условные типы автоматически распределяются по типам объединения во время создания экземпляра. Например, экземпляр &lt;code&gt;T extends U ? X : Y&lt;/code&gt; с аргументом типа &lt;code&gt;A | B | C&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; разрешается как &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">Наследование конфигурации</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">Наследование конфигурации с &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1901418fbdfe5d2c8f43a50daa474bda691aa7e5" translate="yes" xml:space="preserve">
          <source>Configuring JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">Настройка часов</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">Настройка часов:Справочная информация</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">Настройка просмотра каталогов с помощью переменной среды &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="154dfa8a6af04f2d727ad938b2a0b29854531465" translate="yes" xml:space="preserve">
          <source>Configuring file watching using a &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">Настройка просмотра файлов с помощью переменной окружения &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">Как ни странно, двоеточие здесь &lt;em&gt;не&lt;/em&gt; указывает на тип. Тип, если вы его укажете, еще нужно написать после всей деструктуризации:</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">Поздравляем, вы создали собственный проект .NET Core с интерфейсом TypeScript.</target>
        </trans-unit>
        <trans-unit id="9e5193ad94fca6c20c365f83052b979e6e703a9c" translate="yes" xml:space="preserve">
          <source>Congratulations on choosing TypeScript as one of your first languages &amp;mdash; you&amp;rsquo;re already making good decisions!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155316928dc20330bb4f13299267e694e6babaed" translate="yes" xml:space="preserve">
          <source>Consequences of Structural Typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">Рассмотрим функцию, которая создает новый &lt;code&gt;HTMLElement&lt;/code&gt; , вызывая его без аргументов, и генерирует &lt;code&gt;Div&lt;/code&gt; ; при желании вы также можете передать список детей. Раньше вам нужно было определить это как:</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">Рассмотрим простую реализацию калькулятора, определенную в модуле &lt;code&gt;Calculator.ts&lt;/code&gt; . Модуль также экспортирует вспомогательную функцию для проверки работоспособности калькулятора, передавая список входных строк и записывая результат в конце.</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">Рассмотрим сценарий интернационализации, в котором инструмент сборки автоматически генерирует пакеты для конкретной локали, интерполируя специальный токен пути, например &lt;code&gt;#{locale}&lt;/code&gt; , как часть относительного пути к модулю, например &lt;code&gt;./#{locale}/messages&lt;/code&gt; . В этой гипотетической настройке инструмент перечисляет поддерживаемые локали, сопоставляя абстрагированный путь с &lt;code&gt;./zh/messages&lt;/code&gt; , &lt;code&gt;./de/messages&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">Рассмотрим следующий пример, в котором &lt;code&gt;Animal&lt;/code&gt; - это супертип &lt;code&gt;Dog&lt;/code&gt; и &lt;code&gt;Cat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Константные перечисления могут использовать только постоянные выражения перечисления и в отличие от регулярных перечислений,они полностью удаляются при компиляции.Участники Const перечислений отсеиваются на используемых сайтах.Это возможно,так как константные перечисления не могут иметь вычисленных членов.</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">Постоянно называемые свойства</target>
        </trans-unit>
        <trans-unit id="49d53b0e2ba12586322d0eec2518e118c2445b29" translate="yes" xml:space="preserve">
          <source>Constrained Mixins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">Конструкторские функции</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">Функции конструктора эквивалентны классам</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ca826ddb7dbf23aebcf75ed24ec5bc07d856c905" translate="yes" xml:space="preserve">
          <source>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;Type&lt;/code&gt; is not a function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b322cc323263a5f94064b1dd22d65f4128610" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type from the types used in the parameters of a function type &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Создает тип кортежа из типов параметров типа функции &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Создаст типа пути исключения &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; из &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b40d6ba8fbb32a11e5ef0ea59f2a6613cdd70b" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Создаёт типа путем исключения из &lt;code&gt;T&lt;/code&gt; все свойства, которые назначаются на &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8caddbb3ddee9f5ae43f3e24c9baf74c9d40a4b9" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;ExcludedUnion&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Создает тип пути извлечения из &lt;code&gt;T&lt;/code&gt; всех свойств, которые назначаются на &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b9d1c1c29172750935e9c25ec87d393c9cbc4e" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;Union&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">Создает тип, выбирая все свойства от &lt;code&gt;T&lt;/code&gt; , а затем удаление &lt;code&gt;K&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09cc5c4b6a37c1bdbee9dd0d7660c6620a24b5a9" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;Type&lt;/code&gt; and then removing &lt;code&gt;Keys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Создает тип, выбирая набор свойств &lt;code&gt;K&lt;/code&gt; от &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c0c0b3c69f4491f5b7e112f6aa41891acb587a" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;Keys&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">Создает тип, состоящий из всех свойств &lt;code&gt;T&lt;/code&gt; , установленных как required.</target>
        </trans-unit>
        <trans-unit id="932e1b16b3a2393ed1e71294aedc0172a3c58d7f" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required. The opposite of &lt;a href=&quot;#partialtype&quot;&gt;&lt;code&gt;Partial&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c1c0d42f3f9b45ba741d27ccace4ca4dc2f4a" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;Type&lt;/code&gt; set to required. The opposite of &lt;a href=&quot;#partialtype&quot;&gt;&lt;code&gt;Partial&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f68e6fde23a08ff88d024111ed166b6b258e4fd" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function in &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Создает тип , состоящий из типа экземпляра типа конструктора функции &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Создает тип , состоящий из возвращаемого типа функции &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6248af074741172f00aa42821fdc5ca624e3bfe0" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">Создает тип с набором свойств &lt;code&gt;K&lt;/code&gt; типу &lt;code&gt;T&lt;/code&gt; . Эту утилиту можно использовать для сопоставления свойств одного типа с другим типом.</target>
        </trans-unit>
        <trans-unit id="302b3ef8a60040355be3458fc77a6c0e18ea642f" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;Keys&lt;/code&gt; of type &lt;code&gt;Type&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">Создает тип со всеми свойствами &lt;code&gt;T&lt;/code&gt; , установленными только для &lt;code&gt;readonly&lt;/code&gt; , что означает, что свойства сконструированного типа нельзя переназначить.</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">Создает тип со всеми свойствами &lt;code&gt;T&lt;/code&gt; , установленными как optional. Эта утилита вернет тип, представляющий все подмножества данного типа.</target>
        </trans-unit>
        <trans-unit id="f31c4d16e9ff4bfb1cded19332727ccef1b3be41" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f4cbe62efb06cc53e3a14039a9db23ac8c8cda" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e391e66e7da9572e0f52c477c9819541262c63aa" translate="yes" xml:space="preserve">
          <source>Constructs an object type whose property keys are &lt;code&gt;Keys&lt;/code&gt; and whose property values are &lt;code&gt;Type&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">Потребители вашего модуля должны иметь как можно меньше трения при использовании экспортируемых вещей.Добавление слишком большого количества уровней вложенности,как правило,трудоёмко,поэтому тщательно продумайте,как вы хотите структурировать вещи.</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">Потребительские зависимости</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">Потребление:Потребляющий</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">Потребление:Скачать</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">Потребление:Поиск</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">Контекстный ввод</target>
        </trans-unit>
        <trans-unit id="603feab4fc9b8d65cd86c21a0640771b620b3af7" translate="yes" xml:space="preserve">
          <source>Contextual typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffb5489166008419359898740eeed46cbeb1671" translate="yes" xml:space="preserve">
          <source>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;. And it can infer return types from context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">Контекстный ввод применяется во многих случаях.Частыми случаями являются аргументы для вызова функций,правосторонние присваивания,утверждения типов,члены литералов объектов и массивов,а также выражения возврата.Контекстный тип также выступает в качестве типа-кандидата на лучший распространённый тип.Например:</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">Ошибки анализа управляющего потока</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">Анализ типа управляющего потока</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">Анализ типов на основе потока управления особенно актуален в режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; , поскольку типы, допускающие значение NULL, представлены с использованием типов объединения:</target>
        </trans-unit>
        <trans-unit id="ac60e4fabc9d2458046e40ecaa2efebb0c647716" translate="yes" xml:space="preserve">
          <source>Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372e1a5c72020e79bfc4592c655c28b0c15b1125" translate="yes" xml:space="preserve">
          <source>Controls whether TypeScript will emit a &lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;byte order mark (BOM)&lt;/a&gt; when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of &lt;code&gt;false&lt;/code&gt; is generally best unless you have a reason to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">И наоборот,при импорте:</target>
        </trans-unit>
        <trans-unit id="f31b6614a525392ec0858195de4c10be17398d28" translate="yes" xml:space="preserve">
          <source>Converts to this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9701bf4f89400101efb5b5908d4ea6d132c91f0" translate="yes" xml:space="preserve">
          <source>Core definitions for all ES3 and ES5 functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">Правильный поиск &lt;code&gt;moduleA&lt;/code&gt; в том виде, в каком он был передан в командной строке.</target>
        </trans-unit>
        <trans-unit id="ae18f0902f48e8ccca9ad33f1e24aa69738ce04c" translate="yes" xml:space="preserve">
          <source>Correctly predict type system behavior in most cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">Соответствующие изменения , чтобы добавить &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; определение к &lt;code&gt;JSX&lt;/code&gt; имен в &lt;code&gt;@types/React&lt;/code&gt; по - прежнему необходимы. Имейте в виду, что есть некоторые ограничения.</target>
        </trans-unit>
        <trans-unit id="5ba6a73c0093201ece582d1fb4d7bbc3d859ef7a" translate="yes" xml:space="preserve">
          <source>Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">Создайте &lt;code&gt;gulpfile.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">Создайте файл &lt;code&gt;webpack.config.js&lt;/code&gt; в корне каталога проекта.</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">Создайте файл с именем &lt;code&gt;src/greet.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">Создайте файл в &lt;code&gt;src&lt;/code&gt; с именем &lt;code&gt;index.html&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72c972c59f1f27b703d41ea9aa9823f618a2d30a" translate="yes" xml:space="preserve">
          <source>Create a new file in the root of your source tree: &lt;code&gt;[libname].d.ts&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d670257b5f8858306ee09e6f9274710bd7a4022" translate="yes" xml:space="preserve">
          <source>Create a new folder in &lt;code&gt;node_modules/@types/[libname]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">Создать новый проект</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">Создать страницу</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">Создать файл конфигурации веб-пакета</target>
        </trans-unit>
        <trans-unit id="78a14b786be544c7e444994e89b63a1bab9e7ec1" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;index.d.ts&lt;/code&gt; in that folder, and copy the example in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80520c836bad8ac980c6af04074db460cf2a83d" translate="yes" xml:space="preserve">
          <source>Creating .d.ts Files from .js files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">В настоящее время &lt;code&gt;useDefineForClassFields&lt;/code&gt; доступен только при ориентации на ES5 и выше, поскольку &lt;code&gt;Object.defineProperty&lt;/code&gt; не существует в ES3. Чтобы добиться аналогичной проверки на наличие проблем, вы можете создать отдельный проект, ориентированный на ES5 и использующий &lt;code&gt;--noEmit&lt;/code&gt; , чтобы избежать полной сборки.</target>
        </trans-unit>
        <trans-unit id="96526436a6307d6465c867047c87cca576ddfe01" translate="yes" xml:space="preserve">
          <source>Currently, the only top-level property that is excluded from inheritance is &lt;a href=&quot;#references&quot;&gt;&lt;code&gt;references&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">Пользовательские фабрики JSX с использованием &lt;code&gt;--reactNamespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts (упрощенная выдержка)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">УСТАРЕЛО. &lt;code&gt;--jsxFactory&lt;/code&gt; этого используйте --jsxFactory .</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">УСТАРЕЛО. &lt;code&gt;--outFile&lt;/code&gt; этого используйте --outFile .</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">УСТАРЕЛО. &lt;code&gt;--skipLibCheck&lt;/code&gt; этого используйте --skipLibCheck .</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">Изменения DOM</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="d4a6e25daaa79e164346a5df8f97d22e51c38251" translate="yes" xml:space="preserve">
          <source>Declaration - &lt;code&gt;declaration&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a6e664769b464317ab5bac295d9c6ac3c0507f" translate="yes" xml:space="preserve">
          <source>Declaration Dir - &lt;code&gt;declarationDir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad92a8160441d1375fed7cf194406ee120a09e46" translate="yes" xml:space="preserve">
          <source>Declaration File Theory: A Deep Dive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">Файлы декларации</target>
        </trans-unit>
        <trans-unit id="b50be50c5afb7e54332d8b1bf30d309b0eae0711" translate="yes" xml:space="preserve">
          <source>Declaration Map - &lt;code&gt;declarationMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">Объединение деклараций</target>
        </trans-unit>
        <trans-unit id="851f4d7f22e2bf61aa3d231bae99e9eaaf320d8e" translate="yes" xml:space="preserve">
          <source>Declaration Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">Тип декларации</target>
        </trans-unit>
        <trans-unit id="2411670cd38002dcd5a4989aaf25d65b85643783" translate="yes" xml:space="preserve">
          <source>Declaration initialisers are contextually typed by the declaration&amp;rsquo;s type: &lt;code&gt;{ inference: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">Объявления &lt;em&gt;всегда&lt;/em&gt; инициализируются значением &lt;code&gt;undefined&lt;/code&gt; , даже если у них нет инициализатора.</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">Объявления инициализируются с помощью &lt;code&gt;Object.defineProperty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">Объявления типа &lt;code&gt;import * as a from 'b';&lt;/code&gt; или &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">Объявите свойства,если они действительно существуют.</target>
        </trans-unit>
        <trans-unit id="378818e31f6df21ace4ff334a5f33be4e8cb393e" translate="yes" xml:space="preserve">
          <source>Declares the module specifier to be used for importing the &lt;code&gt;jsx&lt;/code&gt; and &lt;code&gt;jsxs&lt;/code&gt; factory functions when using &lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; which were introduced in TypeScript 4.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">Объявление переменной в JavaScript всегда традиционно выполнялось с помощью ключевого слова &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e978b48c2e7ee378c2b0140f7507fecee38d99" translate="yes" xml:space="preserve">
          <source>Declaring generic classes or types is unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">Объявление переменных типа &lt;code&gt;void&lt;/code&gt; бесполезно, потому что вы можете присвоить им только значение &lt;code&gt;null&lt;/code&gt; (только если &lt;code&gt;--strictNullChecks&lt;/code&gt; не указано, см. Следующий раздел) или &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">Состав декоратора</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">Оценка декоратора</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">Декорационные фабрики</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">Декораторы &lt;code&gt;readonly&lt;/code&gt; и &lt;code&gt;enumerable(false)&lt;/code&gt; будет применяться к свойству &lt;code&gt;method&lt;/code&gt; , прежде чем он установлен на класс &lt;code&gt;C&lt;/code&gt; . Это позволяет декоратору изменять реализацию и в этом случае расширять дескриптор, чтобы он был доступен для записи: false и enumerable: false.</target>
        </trans-unit>
        <trans-unit id="9956dce12bd8a076975367fb2d5e9353aca43d48" translate="yes" xml:space="preserve">
          <source>Decorators and Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt;&lt;code&gt;#4881&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6522aedcbf21b215104c1f4c00a269d73f7737d0" translate="yes" xml:space="preserve">
          <source>Decorators are a language feature which hasn&amp;rsquo;t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">Теперь декораторы разрешены при настройке на ES3. TypeScript 1.7 удаляет специфичное для &lt;code&gt;reduceRight&lt;/code&gt; использование reduceRight из помощника &lt;code&gt;__decorate&lt;/code&gt; . Изменения также &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; вызовы Object.getOwnPropertyDescriptor и &lt;code&gt;Object.defineProperty&lt;/code&gt; с обратной совместимостью, что позволяет очистить излучение для ES5 и более поздних версий, удалив различные повторяющиеся вызовы вышеупомянутых методов &lt;code&gt;Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">Дублированные и перенаправленные пакеты</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">Глубокое погружение</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">Глубокое погружение:Расширенные комбинации</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">Глубокое погружение:Теория Определения Файла:Глубокое погружение</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">Глубокое погружение:Использование с экспортом=или импортом</target>
        </trans-unit>
        <trans-unit id="7924171a48438d5b2e1b6937ed62b292cb09fd2a" translate="yes" xml:space="preserve">
          <source>Deep dive reference materials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">Экспорт по умолчанию</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">Экспорт по умолчанию</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">Экспорт по умолчанию также не может быть расширен, только именованный экспорт (поскольку вам нужно увеличить экспорт по его экспортированному имени, а по &lt;code&gt;default&lt;/code&gt; это зарезервированное слово - см. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;# 14080&lt;/a&gt; для подробностей)</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">Импорт по умолчанию в CommonJS / AMD / UMD теперь разрешен (например, &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ) и должен работать должным образом.</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">Типы по умолчанию для типового параметра должны удовлетворять ограничению для типового параметра,если он существует.</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">Значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">Значения по умолчанию позволяют указать значение по умолчанию в случае,если свойство не определено:</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">Параметры по умолчанию,которые приходят после того,как все необходимые параметры рассматриваются как необязательные,и,как и необязательные параметры,могут быть опущены при вызове соответствующей функции.Это означает,что опциональные параметры и отслеживаемые по умолчанию параметры будут иметь общую схожесть в своих типах,так что и те и другие</target>
        </trans-unit>
        <trans-unit id="317bbd656753a9dd8ea52dce97e89a2822b25653" translate="yes" xml:space="preserve">
          <source>Default:</source>
          <target state="translated">Default:</target>
        </trans-unit>
        <trans-unit id="74041b7807a7d4e7910b8959338951cb903fa127" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;react&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">Дефолтные декларации</target>
        </trans-unit>
        <trans-unit id="990fdad3673f0e5fcfe37a06c68fc3e568969839" translate="yes" xml:space="preserve">
          <source>Defining Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">Определенные задания</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">Теория определения файла:Глубокое погружение</target>
        </trans-unit>
        <trans-unit id="3760ef166e35af012373e12d01c8cf9b2e33236e" translate="yes" xml:space="preserve">
          <source>Deno</source>
          <target state="translated">Deno</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">Зависимость от глобальных библиотек</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">Зависимость от модулей</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">Зависимость от библиотек UMD</target>
        </trans-unit>
        <trans-unit id="918fe5bb958d61b9b61fe33be50330ae07bd5a2b" translate="yes" xml:space="preserve">
          <source>Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at &lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com/tsconfig/bases&lt;/a&gt;. These are &lt;code&gt;tsconfig.json&lt;/code&gt; files which your project extends from which simplifies your &lt;code&gt;tsconfig.json&lt;/code&gt; by handling the runtime support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">В зависимости от цели модуля, указанной во время компиляции, компилятор сгенерирует соответствующий код для систем загрузки &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;модулей&lt;/a&gt; Node.js ( &lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; ), require.js ( &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt; ), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; , &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; или ECMAScript 2015 (ES6). Для получения дополнительной информации о том, что делают вызовы &lt;code&gt;define&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; и &lt;code&gt;register&lt;/code&gt; в сгенерированном коде, обратитесь к документации для каждого загрузчика модуля.</target>
        </trans-unit>
        <trans-unit id="18a900ef15ba76652dc77d44a19b9f726ade7509" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">Несмотря на свой внешний вид, модификатор типа &lt;code&gt;readonly&lt;/code&gt; может использоваться только для синтаксиса типов массивов и типов кортежей. Это не универсальный оператор типа.</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">Деструктуризация также работает в функциональных декларациях.Для простых случаев это просто:</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">Деструктуризация деклараций также работает для извлечения значений из массивов:</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">Деструктуризация в декларациях и назначениях</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">Деструктуризация шаблонов также может быть использована в регулярных выражениях присваивания.Например,замена двух переменных может быть записана как одно деструктирующее присваивание:</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">Деструктуризация работает и с уже объявленными переменными:</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">Узнайте,актуальны ли они</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Определите, как модули решаются. Либо &lt;code&gt;&quot;Node&quot;&lt;/code&gt; для разрешения стиля Node.js / io.js, либо &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; . См. &lt;a href=&quot;module-resolution&quot;&gt;Документацию Module Resolution&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="3c1b1483372c227a508b8463543c7a9308b81a78" translate="yes" xml:space="preserve">
          <source>Diagnostics - &lt;code&gt;diagnostics&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5a55f6f2e4530ea94d346bb5232949c83852a7" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;childNodes&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">Различие между статической и инстанционной сторонами классов</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">В разных местах языка используется один из двух механизмов совместимости, в зависимости от ситуации. Для практических целей, совместимость типа диктуется совместимостью назначения, даже в случаях с &lt;code&gt;implements&lt;/code&gt; и &lt;code&gt;extends&lt;/code&gt; положения.</target>
        </trans-unit>
        <trans-unit id="95bcb1c49cad60f2d25122fcd19b63040c889429" translate="yes" xml:space="preserve">
          <source>Disable Size Limit - &lt;code&gt;disableSizeLimit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a32974e72060c10cc1f472534786de4686092d" translate="yes" xml:space="preserve">
          <source>Disable Solution Searching - &lt;code&gt;disableSolutionSearching&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c23df2605c409c3157537bdcacc045f0801eb0" translate="yes" xml:space="preserve">
          <source>Disable Source Project Reference Redirect - &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">Отключите проверку параметров бивариантов для типов функций.</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">Отключить ограничение на размер JavaScript-проекта.</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">Отключить строгую проверку родовых подписей в типах функций.</target>
        </trans-unit>
        <trans-unit id="e5a053c8b9e96a66ffa4c28b3bd57ff2472f950d" translate="yes" xml:space="preserve">
          <source>Disables the automatic inclusion of any library files. If this option is set, &lt;code&gt;lib&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">Запретить несогласованные ссылки на один и тот же файл.</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">Запрещенные слияния</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">Дискриминированные союзы</target>
        </trans-unit>
        <trans-unit id="4f995145bd06a1e9b5d7514449a82f5503e6e06f" translate="yes" xml:space="preserve">
          <source>Discriminating Unions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">Дистрибутивные условные типы</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">Вы &lt;em&gt;не&lt;/em&gt; использовать &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; директиву объявить зависимость в библиотеку UMD!</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">Не добавляйте в список скомпилированных файлов ссылки с тройной косой чертой или цели импорта модулей.</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">Не &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; директивы use strict в выводе модуля.</target>
        </trans-unit>
        <trans-unit id="1ce6e36e455f554889b5d6bc9e169d6efc81747f" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eae0aff266e745600e62273aeb329a274d44532" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb6ba65f5d19029d630e79f609d97ba6b1be452" translate="yes" xml:space="preserve">
          <source>Do not emit declarations for code that has an &lt;code&gt;@internal&lt;/code&gt; annotation in it&amp;rsquo;s JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your &lt;code&gt;d.ts&lt;/code&gt; files, look at &lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">Не излучайте выходы,если сообщалось об ошибках.</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">Не излучайте выходы.</target>
        </trans-unit>
        <trans-unit id="75e54c4e6371e16cfe8d5e2477971052228922b4" translate="yes" xml:space="preserve">
          <source>Do not erase &lt;code&gt;const enum&lt;/code&gt; declarations in generated code. &lt;code&gt;const enum&lt;/code&gt;s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110fa485165295f6412f7a19e4cf78d89958e5a1" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;enums#const-enums&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Не стирайте объявления константного перечисления в сгенерированном коде. См. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;Документацию&lt;/a&gt; по константным перечислениям для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">Не &lt;code&gt;__extends&lt;/code&gt; пользовательские вспомогательные функции, такие как __extends, в скомпилированном выводе.</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">Не включайте файл библиотеки по умолчанию ( &lt;code&gt;lib.d.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">Не сообщайте об ошибках на недоступном коде.</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">Не сообщайте об ошибках на неиспользуемых этикетках.</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">Не разрешайте сим-ссылки на их реальный путь;относитесь к файлу с сим-ссылками как к реальному.</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">Не усекайте сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">Не использовать пространства имен в модулях</target>
        </trans-unit>
        <trans-unit id="4bcbf5a1fc2c5b15cdcbd417c596ae653a2554d0" translate="yes" xml:space="preserve">
          <source>Do you need a build pipeline with multiple potential outputs? Use &lt;code&gt;babel&lt;/code&gt; for transpiling and &lt;code&gt;tsc&lt;/code&gt; for type checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">Что можно и что нельзя делать</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">Что можно и нельзя: дженерики</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">Что можно и чего нельзя делать: необязательные параметры в обратных вызовах</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">Что можно и что нельзя делать: заказ</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">Что и нельзя делать: перегрузки и обратные вызовы</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">Что можно и чего нельзя: возвращаемые типы обратных вызовов</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">Что можно и чего нельзя делать: используйте дополнительные параметры</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">Что можно и чего нельзя делать: используйте типы союза</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">Делать и не делать</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">Документация, описывающая, как &lt;code&gt;require&lt;/code&gt; или импортировать библиотеку</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">Документация по библиотекам UMD также часто демонстрирует пример &amp;laquo;Использование в Node.js&amp;raquo;, показывающий &lt;code&gt;require&lt;/code&gt; , и пример &amp;laquo;Использование в браузере&amp;raquo;, показывающий использование &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; для загрузки скрипта.</target>
        </trans-unit>
        <trans-unit id="a885ffddfd2d0e82b05e37f87bbdf798e4f9f6d4" translate="yes" xml:space="preserve">
          <source>Does it add a global object? Does it use &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt; statements?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">Не пугайтесь количества шагов здесь - TypeScript по-прежнему только дважды прыгает по каталогам на шагах (9) и (17). На самом деле это не сложнее, чем то, что делает сам Node.js.</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">Не беспокойтесь об упорядочивании файлов, которые вы передаете в командной строке - &lt;code&gt;tsc&lt;/code&gt; при необходимости изменит их порядок, чтобы зависимости всегда создавались первыми.</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">Пунктирные имена в шрифтовых щитках</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">Пунктирное свойство для типов со строковыми сигнатурами индекса</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">Функции синхронизации нижнего уровня</target>
        </trans-unit>
        <trans-unit id="183506505f400de899633b4af1eabf4c89a43b4a" translate="yes" xml:space="preserve">
          <source>Downlevel Iteration - &lt;code&gt;downlevelIteration&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294cb786a27af75c6b7bfcf3924fee299a4870ec" translate="yes" xml:space="preserve">
          <source>Downleveling is TypeScript&amp;rsquo;s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">Загрузите сценарий &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">Из-за ошибки в TypeScript ранее была разрешена следующая конструкция:</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="db11c375055a24f360ae47b840505b64422c9a27" translate="yes" xml:space="preserve">
          <source>During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in &lt;em&gt;function&lt;/em&gt; syntax, not to those in &lt;em&gt;method&lt;/em&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">Во время вывода аргумента типа в TypeScript 3.4 для вызова универсальной функции, которая возвращает тип функции, TypeScript &lt;em&gt;будет&lt;/em&gt; , при необходимости, распространять параметры типа из аргументов универсальной функции на результирующий тип функции.</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">Выражения динамического &lt;code&gt;import&lt;/code&gt; - это новая функция и часть ECMAScript, которая позволяет пользователям асинхронно запрашивать модуль в любой произвольной точке вашей программы.</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">Динамические импортные экспрессии</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Загрузка динамического модуля в Node.js</target>
        </trans-unit>
        <trans-unit id="e67a2edba452a5455e675d6f3d31c528be815de5" translate="yes" xml:space="preserve">
          <source>ECMA-262 Standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript , 2015 (также известный как ES2015, ECMAScript 6 и ES6), CommonJS и RequireJS имеют схожие понятия &lt;em&gt;импорта&lt;/em&gt; в &lt;em&gt;модуль&lt;/em&gt; . В JavaScript CommonJS (Node.js), например, вы должны написать</target>
        </trans-unit>
        <trans-unit id="0fa32652049aa2b5542973c2441565a7dd912fa2" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 added several new iteration primitives: the &lt;code&gt;for / of&lt;/code&gt; loop (&lt;code&gt;for (el of arr)&lt;/code&gt;), Array spread (&lt;code&gt;[a, ...b]&lt;/code&gt;), argument spread (&lt;code&gt;fn(...args)&lt;/code&gt;), and &lt;code&gt;Symbol.iterator&lt;/code&gt;. &lt;code&gt;--downlevelIteration&lt;/code&gt; allows for these iteration primitives to be used more accurately in ES5 environments if a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66e029ab9fd3fb22e4e3981b8b4649135674638a" translate="yes" xml:space="preserve">
          <source>ECMAScript Private Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e52a38a1db2363571bfdfdb94baa4cbfd95e124" translate="yes" xml:space="preserve">
          <source>ES Module Interop - &lt;code&gt;esModuleInterop&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015 не имеет средств для декларирования свойств классов.Свойства динамически присваиваются,так же как и литералы объектов.</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">Объявления &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; в ES6 теперь поддерживаются при нацеливании на ES3 и ES5.</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6 Модули</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">генераторы ES6</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6 вводит экранирования,которые позволяют пользователям представлять кодовую точку Юникода с помощью всего одного экранирования.</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">оператор экспонирования ES7</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">Каждый член перечисления имеет связанное с ним значение, которое может быть либо &lt;em&gt;постоянным,&lt;/em&gt; либо &lt;em&gt;вычисленным&lt;/em&gt; . Член перечисления считается постоянным, если:</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">Каждый модуль может дополнительно экспортировать экспорт по &lt;code&gt;default&lt;/code&gt; . Экспорт по умолчанию отмечен ключевым словом &lt;code&gt;default&lt;/code&gt; ; и для каждого модуля может быть только один экспорт по &lt;code&gt;default&lt;/code&gt; . экспорт по &lt;code&gt;default&lt;/code&gt; импортируется с использованием другой формы импорта.</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">Каждая из этих деклараций создает новое имя типа.</target>
        </trans-unit>
        <trans-unit id="e60fbc5aa90c5637a80cca5bb6a944053a0e909a" translate="yes" xml:space="preserve">
          <source>Each step represents a move towards a safer type-system, but not every project needs that level of verification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">Каждый тип шаблона структурирования основной библиотеки имеет соответствующий файл в разделе &quot; &lt;a href=&quot;templates&quot;&gt;Шаблоны&quot;&lt;/a&gt; . Вы можете начать с этих шаблонов, чтобы ускорить работу.</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">Ранние льготы</target>
        </trans-unit>
        <trans-unit id="b122bd4aba545fcb88070e3be4ef84508e72d3b0" translate="yes" xml:space="preserve">
          <source>Editing the package.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">Такие редакторы, как Visual Studio и Visual Studio Code, могут автоматически применять быстрые исправления, рефакторинги и другие преобразования, такие как автоматический импорт значений из других модулей. Эти преобразования выполняются с помощью TypeScript, а более старые версии TypeScript безоговорочно добавляли точки с запятой в конец каждого оператора; К сожалению, это не соответствовало многим правилам стиля, и многие пользователи были недовольны тем, что редактор вставлял точки с запятой.</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">Или функция конструктора класса для статического члена,или прототип класса для экземпляра члена.</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">Элементы в шаблоне привязки массива,не имеющие совпадения с литералом массива,должны иметь значение по умолчанию в шаблоне привязки массива и автоматически добавляются к типу массива literal.</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">Выражения в встраивания</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">Создайте помощники &lt;code&gt;__importStar&lt;/code&gt; и &lt;code&gt;__importDefault&lt;/code&gt; для совместимости с экосистемой babel во время выполнения и включите &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; для совместимости с системами типов.</target>
        </trans-unit>
        <trans-unit id="123d5430b7726bc1ca6fdb384bc205c8fa112251" translate="yes" xml:space="preserve">
          <source>Emit BOM - &lt;code&gt;emitBOM&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82eac2f5a8d4b5a64f3e121a2d0286cb7295a10" translate="yes" xml:space="preserve">
          <source>Emit Declaration Only - &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ca9b8f663272a641132bd7279ee178b83d3fa3" translate="yes" xml:space="preserve">
          <source>Emit Decorator Metadata - &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">В начале выходных файлов следует отправить UTF-8-байтовую метку заказа (BOM).</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">Вместо того,чтобы иметь отдельный файл с исходными картами,создайте один файл.</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">Выпустить все выходные файлы во &lt;code&gt;built&lt;/code&gt; (с &lt;code&gt;outDir&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">Использовать поля классов с семантикой ECMAScript-стандарта.</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">Выдавать метаданные типа дизайна для декорированных объявлений в источнике. Подробности см. В &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;выпуске № 2577&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">Отправьте источник вместе с исходными картами в одном файле; требует установки &lt;code&gt;--inlineSourceMap&lt;/code&gt; или &lt;code&gt;--sourceMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b327d3b6deafdd67337cc0d9e334080a73b07f46" translate="yes" xml:space="preserve">
          <source>Empty Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">Включите все строгие опции проверки типа.</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">Включите инкрементную компиляцию путем чтения / записи информации из предыдущих компиляций в файл на диске. Этот файл контролируется флагом &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">Включите более строгую проверку методов &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; для функций.</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">Включите опцию &lt;code&gt;jsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4a3eed1cf65a963ddf3f9b30f57ca9cb73fcaa1" translate="yes" xml:space="preserve">
          <source>Enables &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;experimental support for decorators&lt;/a&gt;, which is in stage 2 of the TC39 standardization process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">Обеспечивает экспериментальную поддержку для декораторов ES.</target>
        </trans-unit>
        <trans-unit id="e1b4a6f5d796dc27b38b366249d014d055262aaf" translate="yes" xml:space="preserve">
          <source>Enables experimental support for emitting type metadata for decorators which works with the module &lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt;&lt;code&gt;reflect-metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d931513b0509143ecae93fe072c8701ba3bef1a" translate="yes" xml:space="preserve">
          <source>Enables the generation of &lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;sourcemap files&lt;/a&gt;. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as &lt;code&gt;.js.map&lt;/code&gt; (or &lt;code&gt;.jsx.map&lt;/code&gt;) files next to the corresponding &lt;code&gt;.js&lt;/code&gt; output file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">Включение &lt;code&gt;--declarationMap&lt;/code&gt; вместе с &lt;code&gt;--declaration&lt;/code&gt; заставляет компилятор &lt;code&gt;.d.ts.map&lt;/code&gt; файлы .d.ts.map вместе с выходными файлами &lt;code&gt;.d.ts&lt;/code&gt; . Языковые службы теперь также могут понимать эти файлы карт и использовать их для сопоставления местоположений определений на основе файлов объявлений с их исходным источником, если они доступны.</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">Включение &lt;code&gt;--strict&lt;/code&gt; включает &lt;code&gt;--noImplicitAny&lt;/code&gt; , &lt;code&gt;--noImplicitThis&lt;/code&gt; , &lt;code&gt;--alwaysStrict&lt;/code&gt; , &lt;code&gt;--strictBindCallApply&lt;/code&gt; , &lt;code&gt;--strictNullChecks&lt;/code&gt; , &lt;code&gt;--strictFunctionTypes&lt;/code&gt; и &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e34ed7ff6f716b586d5cdcceccbaca058f72fc3" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;esModuleInterop&lt;/code&gt; will also enable &lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt;&lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b00df6ae9f4549f7d57c88d20b001737628bc763" translate="yes" xml:space="preserve">
          <source>Enabling the option allows importing JSON, and validating the types in that JSON file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">Расширенный вывод &lt;code&gt;--init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">Убедитесь,что TypeScript может определить,где найти выходные данные ссылочного проекта для компиляции проекта.</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">Убедитесь, что в конструкторе инициализированы не неопределенные свойства класса. Эта опция требует &lt;code&gt;--strictNullChecks&lt;/code&gt; чтобы она вступила в силу.</target>
        </trans-unit>
        <trans-unit id="9a3144235c8641b90eb9884c83f0c03e49fe7f2e" translate="yes" xml:space="preserve">
          <source>Ensures that your files are parsed in the ECMAScript strict mode, and emit &amp;ldquo;use strict&amp;rdquo; for each source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Введите запрос типа индекса или &lt;code&gt;keyof&lt;/code&gt; ; Индексированный типа запрос &lt;code&gt;keyof T&lt;/code&gt; дает тип разрешенных имен свойств для &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;keyof T&lt;/code&gt; типа считается подтипом &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">Типы участников переписи</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="988d8f6199e4b6350a2137c1e9bd419a30312b8e" translate="yes" xml:space="preserve">
          <source>Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">Перечисления позволяют нам определить набор именованных констант.Использование перечислений может облегчить документирование намерений или создать набор отдельных случаев.TypeScript предоставляет перечисления как в числовом,так и в строковом выражении.</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">Перечисления совместимы с номерами,а номера совместимы с перечислениями.Значения перечислений различных типов считаются несовместимыми.Например,</target>
        </trans-unit>
        <trans-unit id="5829a150f7ef6409938f989938645fcde15588e4" translate="yes" xml:space="preserve">
          <source>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">Перечисления-это реальные объекты,которые существуют во время выполнения.Например,следующее перечисление</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">Перечисления очень полезны, но некоторым программам на самом деле не нужен сгенерированный код, и им было бы полезно просто встраивать все экземпляры членов перечисления с их числовыми эквивалентами. Новое объявление &lt;code&gt;const enum&lt;/code&gt; работает так же, как обычное &lt;code&gt;enum&lt;/code&gt; для обеспечения безопасности типов, но полностью стирается во время компиляции.</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">Перечисления на момент компиляции</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">Записи в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="a995ff457a717bdb048c8c9232b3366e472f2af1" translate="yes" xml:space="preserve">
          <source>Erased Structural Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14aa42c384f51c886a258b319db2b853b34f4b0" translate="yes" xml:space="preserve">
          <source>Erased Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">Ошибка из-за того, что &lt;code&gt;moduleB&lt;/code&gt; не найден, поскольку он не был принят.</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">Сообщения об ошибках на русском языке:</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">Ошибки в файлах .js с &lt;code&gt;--checkJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ceaa96be69ab42f127926b9976ca00d796f12ac" translate="yes" xml:space="preserve">
          <source>Errors which already exist in your codebase, which TypeScript has uncovered because the language has refined its understanding of JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">Даже на этом этапе вы можете получить большие преимущества от понимания вашего проекта TypeScript. Если вы откроете редактор, такой как &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; или &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt; , вы увидите, что часто можете получить некоторую поддержку инструментов, такую ​​как завершение. Вы также можете отловить определенные ошибки с помощью таких опций, как:</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Более того, TypeScript предупредит вас, если вы сделаете эту ошибку, если вы передадите &lt;code&gt;--noImplicitThis&lt;/code&gt; флаг --noImplicitThis . Будет &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; , что &lt;code&gt;this&lt;/code&gt; в this.suits [PickSuit] относится к типу &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">Несмотря на то, что перечисления являются реальными объектами, существующими во время выполнения, ключевое слово &lt;code&gt;keyof&lt;/code&gt; работает иначе, чем вы могли бы ожидать для типичных объектов. Вместо этого используйте &lt;code&gt;keyof typeof&lt;/code&gt; , чтобы получить Type, который представляет все ключи Enum в виде строк.</target>
        </trans-unit>
        <trans-unit id="351b0bfe6af01cc3af80d3c225ca18f3413c36bf" translate="yes" xml:space="preserve">
          <source>Every option is fully explained in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">Каждый раз, когда компилятор видит относительный импорт модуля в &lt;code&gt;rootDirs&lt;/code&gt; одного из rootDirs , он будет пытаться найти этот импорт в каждой из записей &lt;code&gt;rootDirs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a95cb3eaeb836cfc786e3694e94cec3a8b9a84" translate="yes" xml:space="preserve">
          <source>Everyday Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f356257d68607fd9bb714d9b9bf46eae09ecda" translate="yes" xml:space="preserve">
          <source>Everything is assignable to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">Примеры файлов &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="678e0ce800d6be194877dbcb671642b8653408c3" translate="yes" xml:space="preserve">
          <source>Example: Effects on &lt;code&gt;for / of&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1e2321887c3e9bb33ef80db139e7686530c71b" translate="yes" xml:space="preserve">
          <source>Example: Effects on Array Spreads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">Примеры глобальных библиотек</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">Примеры модульных библиотек</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">Примеры UMD библиотек</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">Проверки избыточного имущества</target>
        </trans-unit>
        <trans-unit id="8f00aff99521b0b67d7cf2a6f99b9b1382e2bec8" translate="yes" xml:space="preserve">
          <source>Exclude - &lt;code&gt;exclude&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">Казнить Вавилона из командной строки</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">проверка эксплуатационной эффективности</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">Расширение параметров покоя с типами кортежей на дискретные параметры.</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">Расширение выражений спредов с типами кортежей в дискретные аргументы.</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="e63f550a4c8e9f47ff813f81f98e044c934b5e77" translate="yes" xml:space="preserve">
          <source>Experimental Decorators - &lt;code&gt;experimentalDecorators&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">Экспериментальная поддержка &lt;code&gt;async&lt;/code&gt; функций</target>
        </trans-unit>
        <trans-unit id="7f86b7832ad902539ef49647ed1b68f24295f259" translate="yes" xml:space="preserve">
          <source>Explain the effects of important compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">Явные типы в &lt;code&gt;defaultProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">Явный список импортируемых имен</target>
        </trans-unit>
        <trans-unit id="b4d49c128ea27c0b476f0c2a2de93b85b8758f3c" translate="yes" xml:space="preserve">
          <source>Explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">Экспортные декларации</target>
        </trans-unit>
        <trans-unit id="0d00dcedcb60c65ca444794366f3702bd2f190a2" translate="yes" xml:space="preserve">
          <source>Export all as x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">Экспорт как можно ближе к верхнему уровню</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">Заявления на экспорт</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">Экспортные ведомости удобны в тех случаях,когда экспорт необходимо переименовать для потребителей,поэтому вышеприведенный пример можно написать как:</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">Экспорт декларации</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">Экспорт пространства имён из вашего модуля-пример добавления слишком большого количества слоев вложенности.В то время как пространства имён иногда используются,они добавляют дополнительный уровень вложенности при использовании модулей.Это может быстро стать болезненной точкой для пользователей,и,как правило,в этом нет необходимости.</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">Экспорт из модулей</target>
        </trans-unit>
        <trans-unit id="3f1c3ff321429d2eb6717b5d648a871fa208dfe3" translate="yes" xml:space="preserve">
          <source>Exports of Non-Value Identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">Операторы экспрессии</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">Операторы выражений позволяют типам операндов включать &lt;code&gt;null&lt;/code&gt; и / или &lt;code&gt;undefined&lt;/code&gt; , но всегда производят значения ненулевых и ненулевых типов.</target>
        </trans-unit>
        <trans-unit id="7764ab55f19ed7e0cf007e50b5bc8b2938b82904" translate="yes" xml:space="preserve">
          <source>Extended Diagnostics - &lt;code&gt;extendedDiagnostics&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">Расширяющиеся классы</target>
        </trans-unit>
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">Расширяющие интерфейсы</target>
        </trans-unit>
        <trans-unit id="375df0f41528acadecbb25ba2ba1c7a3fb7ba51c" translate="yes" xml:space="preserve">
          <source>Extending a type via intersections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0184e831bfb3d0f17bb14cf78557f4879766c11" translate="yes" xml:space="preserve">
          <source>Extending an interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">Расширяющиеся выражения</target>
        </trans-unit>
        <trans-unit id="2c62365e86a53d80330c0805ef1f6ee2b629a938" translate="yes" xml:space="preserve">
          <source>Extends - &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9ec862d01090b18ed0a5b1f9fab74b9212f3809" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;a href=&quot;functions#this-parameters&quot;&gt;this&lt;/a&gt; parameter for a function type, or &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;unknown&lt;/a&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">Извлекает тип параметра &lt;code&gt;this&lt;/code&gt; из типа функции или &lt;code&gt;unknown&lt;/code&gt; , если тип функции не имеет &lt;code&gt;this&lt;/code&gt; параметра.</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">Функции завода</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">Быстрее &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">Более быстрые последующие сборки с флагом &lt;code&gt;--incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">Отзывы нашего сообщества, а также наш собственный опыт показали нам, что использование новейших функций TypeScript при одновременном использовании пользователей более старых версий является сложной задачей. TypeScript представляет новую функцию под названием &lt;code&gt;typesVersions&lt;/code&gt; , которая помогает приспособиться к этим сценариям.</target>
        </trans-unit>
        <trans-unit id="812fb4ba4e595ba2544dd885ed6718d2c6cdeed2" translate="yes" xml:space="preserve">
          <source>File Inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">Файл не существует,перейдите ко второй замене.</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">Файл существует.Готово.</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">Путь к файлам</target>
        </trans-unit>
        <trans-unit id="0086a262afcd9e4f6a1dcc9082579481ec576eaf" translate="yes" xml:space="preserve">
          <source>Files - &lt;code&gt;files&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">Файлы в &lt;code&gt;src/views&lt;/code&gt; представляют собой пользовательский код для некоторых элементов управления пользовательского интерфейса. Файлы в &lt;code&gt;generated/templates&lt;/code&gt; представляют собой код привязки шаблонов пользовательского интерфейса, автоматически сгенерированный генератором шаблонов как часть сборки. На этапе сборки файлы из &lt;code&gt;/src/views&lt;/code&gt; и &lt;code&gt;/generated/templates/views&lt;/code&gt; будут скопированы в тот же каталог на выходе. Во время выполнения представление может ожидать, что его шаблон будет существовать рядом с ним, и поэтому должно импортировать его, используя относительное имя как &lt;code&gt;&quot;./template&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">Файлы, включенные с помощью &lt;code&gt;&quot;include&quot;&lt;/code&gt; , можно отфильтровать с помощью свойства &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . Однако файлы, включенные явно с использованием свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt; , всегда включаются независимо от &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . По умолчанию свойство &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; , &lt;code&gt;jspm_packages&lt;/code&gt; и &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; , если они не указаны.</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">Файлы, включенные с помощью &lt;code&gt;&quot;include&quot;&lt;/code&gt; , можно отфильтровать с помощью свойства &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . Однако файлы, включенные явно с использованием свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt; , всегда включаются независимо от &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . По умолчанию свойство &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; и &lt;code&gt;jspm_packages&lt;/code&gt; , если они не указаны.</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">Окончательный результат</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">Наконец, ES2015 представил оператор &lt;code&gt;for..of&lt;/code&gt; как средство перебора итерации. Точно так же предложение Async Iteration вводит оператор &lt;code&gt;for..await..of&lt;/code&gt; для итерации по асинхронному итерируемому объекту:</target>
        </trans-unit>
        <trans-unit id="05320552d7f5f92b22b211023dcc2e57253aede5" translate="yes" xml:space="preserve">
          <source>Finally, TypeScript doesn&amp;rsquo;t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there&amp;rsquo;s no additional TypeScript-specific framework to learn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Наконец, добавьте &lt;code&gt;src/greet.ts&lt;/code&gt; в &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">Наконец, если компилятор не может разрешить модуль, он регистрирует ошибку. В этом случае ошибка будет чем-то вроде &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">Наконец, если ваша цель - ES5 или ES3, вам также необходимо установить флаг &lt;code&gt;--downlevelIterators&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">Наконец, давайте в последний раз расширим этот пример классами. TypeScript поддерживает новые функции JavaScript, такие как поддержка объектно-ориентированного программирования на основе классов.</target>
        </trans-unit>
        <trans-unit id="8e6a9c2de74efedbcef22e11a709230e67b2b36f" translate="yes" xml:space="preserve">
          <source>Finally, the Handbook won&amp;rsquo;t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">Наконец, мы можем выполнять множество различных слияний, используя объявления &lt;code&gt;namespace&lt;/code&gt; . Это не очень реалистичный пример, но демонстрирует множество интересных вещей:</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">Наконец,мы смешиваем наши смеси с реализацией класса.</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">Наконец, вы можете сделать подписи индексов только для &lt;code&gt;readonly&lt;/code&gt; , чтобы предотвратить присвоение их индексам:</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">Найти все упомянутые проекты</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">Поиск и установка файлов декларации</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">Закончили с этим шагом? Большой! Вы успешно перенесли файл с JavaScript на TypeScript!</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">Сначала убедитесь,что Webpack установлен.</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">Сначала установите Babelify и предустановку Babel для ES2015. Как и Uglify, Babelify искажает код, поэтому нам понадобятся виниловый буфер и исходные карты gulp. По умолчанию Babelify будет обрабатывать только файлы с расширениями &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.es&lt;/code&gt; , &lt;code&gt;.es6&lt;/code&gt; и &lt;code&gt;.jsx&lt;/code&gt; , поэтому нам нужно добавить расширение &lt;code&gt;.ts&lt;/code&gt; в качестве опции в Babelify.</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">Сначала установите Uglify.Так как суть Uglify заключается в том,чтобы управлять вашим кодом,нам также нужно установить vinyl-буфер и gulp-карты исходных текстов,чтобы сохранить исходные тексты работоспособными.</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">Прежде всего, они важны, потому что они позволяют TypeScript проверять типы на соответствие другим проектам без повторной проверки исходного исходного кода. Они также важны, потому что позволяют TypeScript взаимодействовать с существующими библиотеками JavaScript, которые не были созданы с учетом TypeScript. Наконец, преимущество, которое часто недооценивают: пользователи как TypeScript, так &lt;em&gt;и&lt;/em&gt; JavaScript могут извлечь выгоду из этих файлов при использовании редакторов на основе TypeScript для улучшения таких вещей, как автоматическое завершение.</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">Сначала некоторые термины</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">Первые шаги</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">Сначала мы объявляем интерфейсы, которые мы объединим. У каждого интерфейса есть свойство &lt;code&gt;kind&lt;/code&gt; с различным типом строкового литерала. Свойство &lt;code&gt;kind&lt;/code&gt; называется &lt;em&gt;дискриминантом&lt;/em&gt; или &lt;em&gt;тегом&lt;/em&gt; . Остальные свойства специфичны для каждого интерфейса. Обратите внимание, что интерфейсы в настоящее время не связаны. Объединим их в союз:</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Сначала нам нужно указать TypeScript, как строить. Щелкните &lt;code&gt;scripts&lt;/code&gt; правой кнопкой мыши и выберите &amp;laquo; &lt;strong&gt;Новый элемент&amp;raquo;&lt;/strong&gt; . Затем выберите &lt;strong&gt;файл конфигурации TypeScript&lt;/strong&gt; и используйте имя по умолчанию &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">Во-первых, средства доступа требуют, чтобы вы установили компилятор для вывода ECMAScript 5 или выше. Понижение уровня до ECMAScript 3 не поддерживается. Во-вторых, методы доступа с &lt;code&gt;get&lt;/code&gt; и no &lt;code&gt;set&lt;/code&gt; автоматически считаются доступными только для &lt;code&gt;readonly&lt;/code&gt; . Это полезно при &lt;code&gt;.d.ts&lt;/code&gt; файла .d.ts из вашего кода, поскольку пользователи вашего ресурса видят, что они не могут его изменить.</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">Во- первых, данные типы &lt;code&gt;T'&lt;/code&gt; и &lt;code&gt;U'&lt;/code&gt; , которые являются инстанциацию &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; , где все вхождения параметров типа заменяются &lt;code&gt;any&lt;/code&gt; , если &lt;code&gt;T'&lt;/code&gt; не может быть назначен на &lt;code&gt;U'&lt;/code&gt; , условный тип разрешен к &lt;code&gt;Y&lt;/code&gt; . Наглядно, если наиболее разрешающая конкретизация &lt;code&gt;T&lt;/code&gt; не отнесена к наиболее разрешительному конкретизации &lt;code&gt;U&lt;/code&gt; , мы знаем , что нет конкретизации не будет , и мы можем только решимость &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">Сначала установите &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core,&lt;/a&gt; если он вам нужен. Для этого краткого руководства требуется Visual Studio 2015 или 2017.</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">Сначала установите browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt; и vinyl-source-stream. tsify - это плагин Browserify, который, как и gulp-typescript, предоставляет доступ к компилятору TypeScript. Vinyl-source-stream позволяет нам адаптировать вывод файла Browserify обратно в формат, который понимает gulp, который называется &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;винилом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">Сначала установите служебную библиотеку &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">Сначала компилятор попытается найти файл, представляющий импортированный модуль. Для этого компилятор следует одной из двух разных стратегий: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; или &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; . Эти стратегии сообщают компилятору, &lt;em&gt;где&lt;/em&gt; искать &lt;code&gt;moduleA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">Во-первых, мы можем использовать объединенный вывод с &lt;code&gt;--outFile&lt;/code&gt; флага --outFile, чтобы скомпилировать все входные файлы в один выходной файл JavaScript:</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">Сначала мы рассмотрим виды библиотек, которые могут представлять файлы объявлений TypeScript. Мы кратко показать , как каждый вид библиотеки &lt;em&gt;используется&lt;/em&gt; , как она &lt;em&gt;написана&lt;/em&gt; , и список некоторых примеров библиотеки из реального мира.</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">Во-первых, вам нужно включить некоторую модульную систему, установив флаг &lt;code&gt;module&lt;/code&gt; TypeScript . Допустимые варианты: &lt;code&gt;commonjs&lt;/code&gt; , &lt;code&gt;amd&lt;/code&gt; , &lt;code&gt;system&lt;/code&gt; и &lt;code&gt;umd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">Кортежи с фиксированной длиной</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--noUnusedParameters&lt;/code&gt; неиспользуемые объявления с помощью --noUnusedParameters и &lt;code&gt;--noUnusedLocals&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd3ca27f2fe942c2bbe6da7b0df5ec8ca268ccce" translate="yes" xml:space="preserve">
          <source>Flags which help with debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">Следуя этой логике,компилятор попытается разрешить оба импорта как таковые:</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">После указания типа &lt;code&gt;this&lt;/code&gt; в классе или интерфейсе функции и методы теперь могут объявлять ожидаемый тип &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">Следуя нашему примеру выше, &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; не использовал ли /root/src/moduleA.js вместо этого не относительный путь и имел ли импорт &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; . Затем Node будет пытаться разрешить &lt;code&gt;moduleB&lt;/code&gt; в каждое из мест, пока одно из них не сработает .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">Для пользователей библиотеки JavaScript раздел &amp;laquo; &lt;a href=&quot;consumption&quot;&gt;Потребление&lt;/a&gt; &amp;raquo; предлагает несколько простых шагов для поиска и установки соответствующих файлов объявлений.</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">Для пользователей НПМ:</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">Для React внутренние элементы передаются в виде строк ( &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; ), а созданный вами компонент - нет ( &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">Для VS 2013:</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">Для VS 2015:</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Для выражения &lt;code&gt;n in x&lt;/code&gt; , где &lt;code&gt;n&lt;/code&gt; - строковый литерал или тип строкового литерала, а &lt;code&gt;x&lt;/code&gt; - тип объединения, &amp;laquo;истинная&amp;raquo; ветвь сужается до типов, которые имеют необязательное или обязательное свойство &lt;code&gt;n&lt;/code&gt; , а &amp;laquo;ложная&amp;raquo; ветвь сужается до типов. которые имеют необязательное или отсутствующее свойство &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75b6d27cd5a1c972beb5c2e01a0a9c58217f3d2c" translate="yes" xml:space="preserve">
          <source>For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">Для создания &lt;code&gt;--incremental&lt;/code&gt; сборок пользователи могут использовать API &lt;code&gt;createIncrementalProgram&lt;/code&gt; и &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; . Пользователи также могут повторно гидратировать старые экземпляры программ из файлов &lt;code&gt;.tsbuildinfo&lt;/code&gt; , сгенерированных этим API, используя недавно открытую функцию &lt;code&gt;readBuilderProgram&lt;/code&gt; , которая предназначена только для использования для создания новых программ (т.е. вы не можете изменять возвращенный экземпляр - это только означает для использования в &lt;code&gt;oldProgram&lt;/code&gt; параметра oldProgram в других функциях &lt;code&gt;create*Program&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">Для авторов файлов объявлений, которые используют встроенные типы, например, DOM API или встроенные конструкторы времени выполнения JS, такие как &lt;code&gt;Symbol&lt;/code&gt; или &lt;code&gt;Iterable&lt;/code&gt; , рекомендуются директивы lib с тройной косой чертой. Раньше в эти файлы .d.ts приходилось добавлять прямые / повторяющиеся объявления таких типов.</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">Для авторов файлов объявлений, которые полагаются на встроенные типы, например, API-интерфейсы DOM или встроенные конструкторы времени выполнения JS, такие как &lt;code&gt;Symbol&lt;/code&gt; или &lt;code&gt;Iterable&lt;/code&gt; , рекомендуются директивы lib с тройной косой чертой. Раньше в эти файлы .d.ts приходилось добавлять прямые / повторяющиеся объявления таких типов.</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">Для файлов объявлений, созданных во время компиляции, компилятор автоматически добавит &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; для вас; &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; в сгенерированный файл декларации добавляется , &lt;em&gt;если и только если&lt;/em&gt; полученный файл использует любые объявления из ссылочного пакета.</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">Для объявить зависимость на &lt;code&gt;@types&lt;/code&gt; пакета в &lt;code&gt;.ts&lt;/code&gt; файл, используйте &lt;code&gt;--types&lt;/code&gt; в командной строке или в &lt;code&gt;tsconfig.json&lt;/code&gt; вместо этого. См. Дополнительные сведения об &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;использовании &lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; и &lt;code&gt;types&lt;/code&gt; в файлах &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc0c74f5013de3695703ff3f7978efc260f1a6e9" translate="yes" xml:space="preserve">
          <source>For developer platforms like Node will have a certain baselines for the their target depending on their version. You can find a set of community organized TSConfigs at &lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig/bases&lt;/a&gt; for common platforms and their versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed40c6f0c1780add8b6c27390450ea1294c1186" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;document.createElement('xyz')&lt;/code&gt; returns a &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; element, clearly not an element that is specified by the HTML specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">Рассмотрим,например,структуру этого проекта:</target>
        </trans-unit>
        <trans-unit id="e330faf79858eff15ab1fa16b480f9af8a75e723" translate="yes" xml:space="preserve">
          <source>For example if you wanted to use &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt;, you need a tsconfig like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8da11b0efd47b16f48058eb8799a7168124fbd1" translate="yes" xml:space="preserve">
          <source>For example with this TSConfig:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eea9d386cac8ef8110732486a228ddec7a04971" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript code, &lt;code&gt;users.find&lt;/code&gt; has no guarantee that it will actually find a user, but you can write code as though it will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa37fb2b6671c00d8d1e61a2de6e276f5b9d8e6" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf9c1c74c2f780a51e1fe18b7af85788137a273" translate="yes" xml:space="preserve">
          <source>For example with this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="9589441950a7ba70ac32a866e7cbc78c60f18f3b" translate="yes" xml:space="preserve">
          <source>For example, JavaScript provides language primitives like &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt;, but it doesn&amp;rsquo;t check that you&amp;rsquo;ve consistently assigned these. TypeScript does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">Например, добавление &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; к одному из файлов в компиляции эквивалентно компиляции с &lt;code&gt;--lib es2017.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">Например, оператор импорта, такой как &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; в &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; , приведет к попытке найти &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; в следующих местах :</target>
        </trans-unit>
        <trans-unit id="fb0268932a575e89ddaf5adf469f05cd6fb3e89a" translate="yes" xml:space="preserve">
          <source>For example, can you &lt;em&gt;only&lt;/em&gt; get it through npm or only from a CDN?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">Например, для декоратора &lt;code&gt;@sealed&lt;/code&gt; мы могли бы написать &lt;code&gt;sealed&lt;/code&gt; функцию следующим образом:</target>
        </trans-unit>
        <trans-unit id="d0e1f04886e8aa232b1f5ca87afb79f3e9db1b4b" translate="yes" xml:space="preserve">
          <source>For example, here is the JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379a411593e5b86332a2083bee7043e6f9882715" translate="yes" xml:space="preserve">
          <source>For example, if you had networking requests with consistent error handling then you could separate out the error handling into its own type which is merged with types which correspond to a single response type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23596f0dc1eff87037eef75f96316f4284f9ed16" translate="yes" xml:space="preserve">
          <source>For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module &lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt;&lt;code&gt;@tsconfig/node12&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">Например, включение &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; в файл объявления означает, что этот файл использует имена, объявленные в &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; ; и, следовательно, этот пакет необходимо включить в компиляцию вместе с файлом объявления.</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">Например, часто очень часто забывают &lt;code&gt;.then()&lt;/code&gt; или &lt;code&gt;await&lt;/code&gt; содержимого &lt;code&gt;Promise&lt;/code&gt; перед передачей его другой функции. Сообщения об ошибках TypeScript теперь специализированы и информируют пользователя о том, что, возможно, им следует рассмотреть возможность использования ключевого слова &lt;code&gt;await&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad31453ee6f39d96c1afdaaf6077d0e43f26289" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you had this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6fd2fe67c6fb7f9ef03666af8aa720461e76ff" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have some input files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">Например, после того, как вы &lt;code&gt;npm install&lt;/code&gt; объявления ваших типов, вы можете использовать импорт и написать</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">Например, некоторые библиотеки добавляют новые функции в &lt;code&gt;Array.prototype&lt;/code&gt; или &lt;code&gt;String.prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8be4ce18dfa625c450ddd4bc1142e60f3523955d" translate="yes" xml:space="preserve">
          <source>For example, the class below returns a function which tries to access &lt;code&gt;this.width&lt;/code&gt; and &lt;code&gt;this.height&lt;/code&gt; &amp;ndash; but the context for &lt;code&gt;this&lt;/code&gt; inside the function inside &lt;code&gt;getAreaFunction&lt;/code&gt; is not the instance of the Rectangle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">Например,ниже приводится извлечение типа возвращаемой функции:</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">Например, следующий пример объявляет переменные &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; и инициализирует их для &lt;code&gt;getSomeObject().x&lt;/code&gt; , &lt;code&gt;getSomeObject().y&lt;/code&gt; и &lt;code&gt;getSomeObject().z&lt;/code&gt; соответственно:</target>
        </trans-unit>
        <trans-unit id="db47b423be9c6dadb503643273e40da05e66f4c4" translate="yes" xml:space="preserve">
          <source>For example, this TSX file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f64ae55bad6947723cb4c39980b51075ca559f5" translate="yes" xml:space="preserve">
          <source>For example, this is a TypeScript file which has a JSDoc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c40d41ae5f1e7ca8179e936e44a9e441a4508b8" translate="yes" xml:space="preserve">
          <source>For example, this is incorrect JavaScript according to the &lt;code&gt;parseFloat&lt;/code&gt; type definition which comes with TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c291950276ec5991b5d85beb6f5e3667694b8" translate="yes" xml:space="preserve">
          <source>For example, to create an object with an inferred type which includes &lt;code&gt;name: string&lt;/code&gt; and &lt;code&gt;id: number&lt;/code&gt;, you can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac02d1dd1384ae853294c750a143c0f2d98423a5" translate="yes" xml:space="preserve">
          <source>For example, using this &lt;code&gt;async&lt;/code&gt; function in ES5 requires a &lt;code&gt;await&lt;/code&gt;-like function and &lt;code&gt;generator&lt;/code&gt;-like function to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">Например,можно добавить в класс статический член:</target>
        </trans-unit>
        <trans-unit id="0a9664482ad4cfe889b90b76aeb2032d715f790d" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which extends another library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e00ba77940c0426f8b1134fd175e919b0cb5147" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba51f2462f3773f1dc6da5083642677ae6d1eee2" translate="yes" xml:space="preserve">
          <source>For example, with this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d653b51bb0e0547080f67ea8f6a6550bedbb94df" translate="yes" xml:space="preserve">
          <source>For example, with this project of just a single &lt;code&gt;index.ts&lt;/code&gt; file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1959c8518d6114cd18bf03e5cd677c322abf43" translate="yes" xml:space="preserve">
          <source>For example, without &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; as true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057ce67e6843578753929fc21dae6a5768fef84b" translate="yes" xml:space="preserve">
          <source>For example, you can make a function return different values depending on whether it is passed a string or an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5f12f7c7d4059c89ae626ee915d1d0eb216e44" translate="yes" xml:space="preserve">
          <source>For example, you may have complex enough types to describe that you choose to namespace them inside your &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">Для функциональных компонентов (ранее известных как SFC)используйте инициализаторы по умолчанию ES2015:</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">Для функциональных членов каждый функциональный член с тем же именем рассматривается как описывающий перегрузку одной и той же функции. Следует также отметить, что в случае слияния интерфейса &lt;code&gt;A&lt;/code&gt; с более поздним интерфейсом &lt;code&gt;A&lt;/code&gt; второй интерфейс будет иметь более высокий приоритет, чем первый.</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">Для проверки типов функций на правильность их ввода не требуется совпадения названий параметров.Можно было бы,например,написать такой пример:</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">Для универсальных типов, для которых не указаны аргументы типа, совместимость проверяется путем указания &lt;code&gt;any&lt;/code&gt; вместо всех неуказанных аргументов типа. Затем полученные типы проверяются на совместимость, как и в неуниверсальном случае.</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">Например, &lt;code&gt;React.Component&lt;/code&gt; определен с двумя параметрами типа: &lt;code&gt;Props&lt;/code&gt; и &lt;code&gt;State&lt;/code&gt; . В файле &lt;code&gt;.js&lt;/code&gt; нет законного способа указать их в предложении extends. По умолчанию аргументы типа будут &lt;code&gt;any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">Например, импорт в модуль &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; будет преобразован во время выполнения в &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">Например, если у вас есть что-то, напечатанное как &lt;code&gt;Object&lt;/code&gt; , вы не сможете вызывать для него такие методы, как &lt;code&gt;toLowerCase()&lt;/code&gt; . Более общий тип обычно означает, что вы можете сделать меньше с типом, но &lt;code&gt;any&lt;/code&gt; является особенным, поскольку он является наиболее общим типом, но при этом позволяет вам делать с ним что угодно. Это означает, что вы можете вызвать его, сконструировать, получить доступ к его свойствам и т. Д. Имейте в виду, однако, что всякий раз, когда вы используете что- &lt;code&gt;any&lt;/code&gt; , вы теряете большую часть проверки ошибок и поддержки редактора, предоставляемой TypeScript.</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">Например,следующие интерфейсы будут слиты вместе:</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">Для внутренних элементов это тип свойства на &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">Для использования ссылок на &lt;code&gt;createSolutionBuilder&lt;/code&gt; была предоставлена новая функция createSolutionBuilder , которая возвращает экземпляр нового типа &lt;code&gt;SolutionBuilder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения об изменении &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;см. В запросе на перенос здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительных сведений о реализации см &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;. Запрос на включение функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения об этих API-интерфейсах можно &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;найти в исходном запросе на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;см. В запросе на добавление на GitHub для добавления &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt; , а также &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;об изменении использования &lt;code&gt;Omit&lt;/code&gt; для отдыха объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;см. В запросе на перенос на GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">Для получения дополнительных сведений &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;см. Исходную проблему&lt;/a&gt; , а также запросы на вытягивание, которые ссылаются на нее.</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;см. В соответствующем запросе на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">Подробнее &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;см. Оригинальный PR на GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации вы можете &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;ознакомиться с соответствующим запросом на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">Подробнее &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;читайте в исходном изменении&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;увидеть исходный запрос на перенос на GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;ознакомиться с исходным запросом на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">Для получения более подробной информации,вы можете посмотреть запросы на</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о модулях и пространствах имен см. &lt;a href=&quot;namespaces-and-modules&quot;&gt;Пространства имен и модули&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о модуле см. В &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;спецификации поддержки модуля ES6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d6421ff56f450a4d8627e4516ee9a9c34657258" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">Дополнительную информацию о временных мертвых зонах см. В соответствующем контенте в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;сети разработчиков Mozilla&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab5ee6f96a4e7a69065dcddd9a55b08eb5aae39" translate="yes" xml:space="preserve">
          <source>For more information on these flags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">Дополнительные сведения см. В сообщении блога об &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;асинхронных функциях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;см. Соответствующий запрос на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">Для получения дополнительной информации см. Предложение &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;декораторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации см. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;Спецификацию TypeScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;прочитать исходный запрос на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;взглянуть на исходный запрос на включение этих изменений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">Однако при нереляционном импорте модулей компилятор проходит по дереву каталогов,начиная с каталога,содержащего файл импорта,пытаясь найти соответствующий файл определения.</target>
        </trans-unit>
        <trans-unit id="d23566da87d8229f77380a239e48562a8a823cce" translate="yes" xml:space="preserve">
          <source>For npm users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">Например,теперь TypeScript может делать умозаключения для типа возврата вызова.Это может улучшить ваш опыт и поймать ошибки.То,что теперь работает:</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">Для того чтобы программы были полезны,мы должны уметь работать с самыми простыми единицами данных:числами,строками,структурами,булевыми значениями и тому подобным.В TypeScript мы поддерживаем практически те же типы,что и в JavaScript,с удобным типом перечисления,вброшенным для помощи в работе.</target>
        </trans-unit>
        <trans-unit id="15f0842c032b4d0063a3b23f1886d7cbeefa49c8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">Для опытных авторов, интересующихся лежащими в основе механизмами работы файлов деклараций, раздел &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; объясняет многие сложные концепции написания деклараций и показывает, как использовать эти концепции для создания более чистых и интуитивно понятных файлов деклараций.</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">По этой причине у нас нет ближайших планов по оказанию поддержки по понижению уровня. С другой стороны, Node 11 и более новые версии Chrome уже поддерживают эту функцию, поэтому вы сможете использовать BigInts там при таргетинге на &lt;code&gt;esnext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="496e704960f5aa1a3e087ed13654d88d3dfbb5fa" translate="yes" xml:space="preserve">
          <source>For the first definition of &lt;code&gt;createElement&lt;/code&gt;, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt;. This expression defines a generic parameter &lt;code&gt;K&lt;/code&gt; that is &lt;em&gt;constrained&lt;/em&gt; to the keys of the interface &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt;. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">По большей части, пакеты объявления типов всегда должны иметь то же имя, что и имя пакета в &lt;code&gt;npm&lt;/code&gt; , но с префиксом &lt;code&gt;@types/&lt;/code&gt; , но при необходимости вы можете проверить &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types,&lt;/a&gt; чтобы найти пакет для вашей любимой библиотеки.</target>
        </trans-unit>
        <trans-unit id="bf75b06c8fc661aa3a2f64f5da3a4e9c2051e897" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;this Type Search&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">Для целей этой статьи &amp;laquo;объединение деклараций&amp;raquo; означает, что компилятор объединяет два отдельных объявления, объявленных с одним и тем же именем, в одно определение. Это объединенное определение имеет черты обоих исходных объявлений. Можно объединить любое количество объявлений; это не ограничивается двумя объявлениями.</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">Для написания файла объявления вы напишете один и тот же код независимо от того, является ли изменяемый модуль простым модулем или модулем UMD.</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">Для этой функции и упрощенных &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;свойств&lt;/a&gt; обязательно используйте последнюю версию react.d.ts .</target>
        </trans-unit>
        <trans-unit id="c1668e641a54e156c170e61580f6a7e55c2d3f64" translate="yes" xml:space="preserve">
          <source>For those interested, you can interact with custom tag elements using the &lt;code&gt;document.getElementsByTagName&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">Для тех, кто не знаком, &lt;code&gt;setTimeout&lt;/code&gt; попытается выполнить функцию через определенное количество миллисекунд (хотя и ждет, пока что-нибудь еще не остановится).</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">Для элементов, основанных на значениях, это немного сложнее. Он определяется типом свойства в &lt;em&gt;типе экземпляра элемента,&lt;/em&gt; который был определен ранее. Какое свойство использовать определяется &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; . Он должен быть объявлен с одним свойством. Затем используется имя этого свойства. Начиная с TypeScript 2.8, если &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; не указан, вместо него будет использоваться тип первого параметра конструктора элемента класса или вызова функционального компонента.</target>
        </trans-unit>
        <trans-unit id="ec762285a1b4a4ed67329132319bc54b9b6e3580" translate="yes" xml:space="preserve">
          <source>Force Consistent Casing In File Names - &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5aa86e5ed9112fe776d6f8c8f31ff44490232e" translate="yes" xml:space="preserve">
          <source>Free Functions and Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5600addb2b77d2558fa7ff723f4b60ade1a0397" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">Начиная с TypeScript 3.7 и новее, вы можете использовать &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;необязательную цепочку,&lt;/a&gt; чтобы упростить работу с типами, допускающими значение NULL.</target>
        </trans-unit>
        <trans-unit id="978d60f8509ec4db7ded456faee49383919753b1" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.8 onwards, you can use JSDoc to modify the properties in a class. First are the accessibility modifiers: &lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, and &lt;code&gt;@protected&lt;/code&gt;. These tags work exactly like &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, and &lt;code&gt;protected&lt;/code&gt; respectively work in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">Из глобальной библиотеки</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">Из модуля или библиотеки UMD</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">Из командного окна PowerShell,запустите:</target>
        </trans-unit>
        <trans-unit id="b107342b8b3dda22c1b15ba7f4fbcc3adcc5a2ea" translate="yes" xml:space="preserve">
          <source>From here, we&amp;rsquo;d recommend learning some of the JavaScript fundamentals (the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;JavaScript guide at the Mozilla Web Docs&lt;/a&gt; is a good starting point.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">Оттуда вы сможете без проблем использовать lodash в своем коде TypeScript. Это работает как для модулей, так и для глобального кода.</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">С этого момента мы будем предполагать, что ваш каталог настроен примерно так:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">Функциональный компонент</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">Функциональный компонент (ФК)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">Функциональные компоненты в реакции</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">Перегрузки функции</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">Бивариантность параметров функции</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">Функция проверки достоверности</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">Типы функций</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">Функциональные декларации</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">Параметры функции проверяются по одному, при этом типы в каждой соответствующей позиции параметра проверяются относительно друг друга. Если вы вообще не хотите указывать типы, контекстная типизация TypeScript может определять типы аргументов, поскольку значение функции присваивается непосредственно переменной типа &lt;code&gt;SearchFunc&lt;/code&gt; . Здесь также тип возвращаемого значения нашего функционального выражения подразумевается значениями, которые оно возвращает (здесь &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">Параметры функции по умолчанию являются необязательными</target>
        </trans-unit>
        <trans-unit id="ed95afc615d05f6e5368c71005cf262d6343db73" translate="yes" xml:space="preserve">
          <source>Function syntax includes parameter names. This is pretty hard to get used to!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">Функции - это фундаментальный строительный блок любого приложения на JavaScript. Это то, как вы создаете уровни абстракции, имитируя классы, скрытие информации и модули. В TypeScript, несмотря на наличие классов, пространств имен и модулей, функции по-прежнему играют ключевую роль в описании того, как &lt;em&gt;что-&lt;/em&gt; то &lt;em&gt;делать&lt;/em&gt; . TypeScript также добавляет некоторые новые возможности к стандартным функциям JavaScript, чтобы упростить работу с ними.</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">Функции с путями кода, которые не возвращают значение в JS, неявно возвращают &lt;code&gt;undefined&lt;/code&gt; . Теперь они могут быть помечены компилятором как неявные возвраты. По умолчанию проверка &lt;em&gt;отключена&lt;/em&gt; ; используйте &lt;code&gt;--noImplicitReturns&lt;/code&gt; , чтобы включить его.</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">Функции с перегрузками</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">Функции:это</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">Кроме того, TypeScript также имеет понятие &lt;em&gt;глобальных&lt;/em&gt; дополнений к форме &lt;code&gt;declare global { }&lt;/code&gt; . Это позволяет модулям при необходимости расширять глобальные типы, такие как &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Кроме того, в режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; анализ типов на основе потока управления включает анализ &lt;em&gt;определенного присваивания&lt;/em&gt; для локальных переменных типов, которые не допускают значение &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">Кроме того, при &lt;code&gt;keyof&lt;/code&gt; поддержке оператора по &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;symbol&lt;/code&gt; имени ключей, теперь можно абстрагировать за доступ к свойствам объектов, проиндексированных числовых литералов (таких как числовые типы перечислений) и уникальных символов.</target>
        </trans-unit>
        <trans-unit id="33a55d7b2a4c629fc605606fd7d8bd91685e04a3" translate="yes" xml:space="preserve">
          <source>Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">Общие Типы</target>
        </trans-unit>
        <trans-unit id="31aa08b13ef05b660d703277cd9eaf4495dd69d5" translate="yes" xml:space="preserve">
          <source>Generally, you won&amp;rsquo;t need to use this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b96ccfadf72cdc8e8186c38b80b976cc57f7091" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.d.ts&lt;/code&gt; files for every TypeScript or JavaScript file inside your project. These &lt;code&gt;.d.ts&lt;/code&gt; files are type definition files which describe the external API of your module. With &lt;code&gt;.d.ts&lt;/code&gt; files, tools like TypeScript can provide intellisense and accurate types for un-typed code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437f20984d6e132889941d988b14b86cfa9f9862" translate="yes" xml:space="preserve">
          <source>Generate CPU Profile - &lt;code&gt;generateCpuProfile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">Сгенерированный JS-код:</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">Генерирует профиль процессора по заданному пути.Передача имени существующего каталога вместо пути к файлу приведет к тому,что профиль с временными метками будет сгенерирован в этом каталоге.</target>
        </trans-unit>
        <trans-unit id="dfdc500a2df569ef69f2127f8241641852a3dbd0" translate="yes" xml:space="preserve">
          <source>Generates a source map for &lt;code&gt;.d.ts&lt;/code&gt; files which map back to the original &lt;code&gt;.ts&lt;/code&gt; source file. This will allow editors such as VS Code to go to the original &lt;code&gt;.ts&lt;/code&gt; file when using features like &lt;em&gt;Go to Definition&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">Создает карту источников для каждого соответствующего файла .d.ts.</target>
        </trans-unit>
        <trans-unit id="0ba70dfbfb3ac05d2ef01a114d8d061e0873111b" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">Создает соответствующий файл &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">Создает соответствующий файл &lt;code&gt;.map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">Генераторы и итерация для ES5/ES3</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">Общие классы</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">Общие ограничения</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">Общие типы</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">Общие переменные и параметры покоя объекта</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">Общие настройки параметров по умолчанию</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">Общие параметры покоя</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">Общие параметры покоя и соответствующий вывод о типах кортежей.</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">Общие выражения распространения в объектных литералах</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">Общие псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">Общие аргументы типа в JSX-элементах</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">Общие аргументы типов в общих теговых шаблонах</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="db53d33f081c24d027b3c7e1e7024838559d94b2" translate="yes" xml:space="preserve">
          <source>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">Дженерики:Типы</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">Начните с простого приложения TypeScript.</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">Получение файлов декларации</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">Более строгие проверки</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">На самом деле,обойти эти чеки очень просто.Самый простой метод-просто использовать утверждение типа:</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">Доступ к объявлениям встроенных API ES6 / ES2015 был ограничен только &lt;code&gt;target: ES6&lt;/code&gt; . Введите &lt;code&gt;--lib&lt;/code&gt; ; с помощью &lt;code&gt;--lib&lt;/code&gt; вы можете указать список встроенных групп объявлений API, которые вы можете включить в свой проект. Например, если вы ожидаете, что ваша среда выполнения будет поддерживать &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;Promise&lt;/code&gt; (например, большинство современных браузеров сегодня), просто &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; . Точно так же вы можете исключить объявления, которые не хотите включать в свой проект, например, DOM, если вы работаете над проектом узла с использованием &lt;code&gt;--lib es5,es6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">Получение объявлений типов в TypeScript 2.0 и выше не требует никаких инструментов,кроме npm.</target>
        </trans-unit>
        <trans-unit id="8ad931cf8eb2acc56be9415f5e0a4f34de91ca82" translate="yes" xml:space="preserve">
          <source>Getting type declarations requires no tools apart from npm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">Учитывая &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; , то &lt;em&gt;тип класса элемента&lt;/em&gt; является типом &lt;code&gt;Expr&lt;/code&gt; . Итак, в приведенном выше примере, если &lt;code&gt;MyComponent&lt;/code&gt; был классом ES6, тип класса был бы конструктором и статикой этого класса. Если бы &lt;code&gt;MyComponent&lt;/code&gt; был фабричной функцией, то эта функция была бы типом класса.</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">Учитывая объявление класса &lt;code&gt;Pet&lt;/code&gt; в файле модуля:</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">Учитывая имя &lt;code&gt;A&lt;/code&gt; , мы можем найти до трех различных значений для &lt;code&gt;A&lt;/code&gt; : тип, значение или пространство имен. Как это имя интерпретируется, зависит от контекста, в котором оно используется. Например, &lt;code&gt;let m: A.A = A;&lt;/code&gt; в объявлении m: AA = A; , &lt;code&gt;A&lt;/code&gt; используется сначала как пространство имен, затем как имя типа, а затем как значение. Эти значения могут в конечном итоге относиться к совершенно другим объявлениям!</target>
        </trans-unit>
        <trans-unit id="368b78c1924bb611f6364ba9c26348188f7788e5" translate="yes" xml:space="preserve">
          <source>Given a simplified &lt;em&gt;index.html&lt;/em&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">С учетом экспрессии &lt;code&gt;Base&lt;/code&gt; параметрического типа &lt;code&gt;T&lt;/code&gt; с ограничением &lt;code&gt;X&lt;/code&gt; , класс Mixin &lt;code&gt;class C extends Base {...}&lt;/code&gt; обрабатывается , как если бы &lt;code&gt;Base&lt;/code&gt; имела тип &lt;code&gt;X&lt;/code&gt; и полученный тип является пересечением &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; . Другими словами, класс миксина представлен как пересечение между типом конструктора класса миксина и типом конструктора параметрического базового класса.</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">Учитывая тип объекта &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;keyof X&lt;/code&gt; решается следующим образом :</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">Учитывая, что у нас есть два типа объявлений с похожей семантикой области видимости, естественно спросить, какой из них использовать. Как и на большинство общих вопросов, ответ таков: все зависит от обстоятельств.</target>
        </trans-unit>
        <trans-unit id="c71bdff34c04312e874f58b0595438841c748916" translate="yes" xml:space="preserve">
          <source>Given the &lt;code&gt;state&lt;/code&gt; field is common in every type inside &lt;code&gt;NetworkState&lt;/code&gt; - it is safe for your code to access without an existence check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">Учитывая структуру этого проекта:</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;tsconfig.json&lt;/code&gt; в tsconfig.json</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">Поддержка Glob уже здесь !! Поддержка Glob была &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;одной из самых востребованных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">Шаблоны файлов, похожие на глобус, поддерживаются двумя свойствами: &lt;code&gt;&quot;include&quot;&lt;/code&gt; и &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cc9c6744751ed4cf4a2b29e9b22ac831592172b" translate="yes" xml:space="preserve">
          <source>Global .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">Глобальные функции</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">Глобальные библиотеки</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">Глобальный шаблон библиотеки</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">Глобальные переменные</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">Глобальный рост</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">Глобальные аугментации имеют те же характеристики и ограничения,что и модульные аугментации.</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">Код глобальной библиотеки обычно чрезвычайно прост. Глобальная библиотека &amp;laquo;Hello, world&amp;raquo; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">Глобальные плагины,как правило,легко определить по их документации.</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">Модули, изменяющие глобальные параметры, обычно легко определить по их документации. В целом они похожи на глобальные плагины, но &lt;code&gt;require&lt;/code&gt; вызова для активации их эффектов.</target>
        </trans-unit>
        <trans-unit id="985e370903f557eb77f2957da19dbd086883f48f" translate="yes" xml:space="preserve">
          <source>Global: Modifying Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6922ba498ce785a869200f44c3ccbf5a4f68f2" translate="yes" xml:space="preserve">
          <source>Global: Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">Перейдите в &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">Перейдите в &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86d8b5a249b3cc55d73040fe87c867b93ac1ecb6" translate="yes" xml:space="preserve">
          <source>Going back to the idea of &lt;em&gt;types as sets&lt;/em&gt;, we can think of &lt;code&gt;obj&lt;/code&gt; as being a member of both the &lt;code&gt;Pointlike&lt;/code&gt; set of values and the &lt;code&gt;Named&lt;/code&gt; set of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05780e3cac998950011571da3d75ed12a7e2108" translate="yes" xml:space="preserve">
          <source>Gradual typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">Руководство по структурированию модулей</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">Глотание:Добавить модули в код</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">Глотание:Вавилон</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">Глотание:Просмотреть</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Глотание:Создать gulpfile.js</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">Глотание:Создать страницу</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Глотание:Инициализировать проект</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Глотание:Установить наши зависимости</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">Глотание:Минимальный проект</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Глотание:Тестирование результирующего приложения</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">Глотание:Глицины</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">Глотание:Смотреть</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">Глотание:Напишите простой пример</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">Если бы выражение функции возвратило числа или строки, средство проверки типов выдало бы ошибку, указывающую, что тип возвращаемого значения не соответствует типу возвращаемого значения, описанному в интерфейсе &lt;code&gt;SearchFunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048279b51d66beecd8037dba2d0ea88f2006f017" translate="yes" xml:space="preserve">
          <source>Handbook</source>
          <target state="translated">Handbook</target>
        </trans-unit>
        <trans-unit id="60e7f26d0bfbb76e605b8559ae9629c763bda244" translate="yes" xml:space="preserve">
          <source>Handbook Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025c00357defd4539f61638601fbe4d91d8be15e" translate="yes" xml:space="preserve">
          <source>Handbook v2: Beta</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47336902c998cc0d39cea91a005587dbb3655556" translate="yes" xml:space="preserve">
          <source>Handling Many Consuming Import</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3f9ca937ff27ba265d41da2558bebb545acf05" translate="yes" xml:space="preserve">
          <source>Have recompiles in &lt;code&gt;--incremental&lt;/code&gt; and &lt;code&gt;--watch&lt;/code&gt; assume that changes within a file will only affect files directly depending on it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">Здравствуйте,мир дженериков</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;asserts val is string&lt;/code&gt; гарантирует, что после любого вызова &lt;code&gt;assertIsString&lt;/code&gt; любая переданная переменная будет известна как &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">Здесь &lt;code&gt;map.ts&lt;/code&gt; может объявить, что он внутренне исправит тип &lt;code&gt;Observable&lt;/code&gt; из &lt;code&gt;observable.ts&lt;/code&gt; и добавит к нему метод &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7da085e82459c85f19fe707c9181a9e46b7b5cc" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">Вот некоторые заметные различия в том, как работает проверка в файлах &lt;code&gt;.js&lt;/code&gt; по сравнению с файлами &lt;code&gt;.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">Вот список доступных групп API:</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">Вот список известных символов:</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">Вот простой тест для калькулятора с использованием открытой &lt;code&gt;test&lt;/code&gt; функции.</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">Вот пример,демонстрирующий это различие:</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">Здесь синтаксис начинает сбивать с толку. Вы можете прочитать &lt;code&gt;a: newName1&lt;/code&gt; как &amp;laquo; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &amp;raquo;. Направление слева направо, как если бы вы написали:</target>
        </trans-unit>
        <trans-unit id="38b470aca3704e2927b6fc439cdffa46d4653713" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;rdquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Здесь мы явно устанавливаем &lt;code&gt;T&lt;/code&gt; как &lt;code&gt;string&lt;/code&gt; качестве одного из аргументов вызова функции, обозначаемых с помощью &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вокруг аргументов, а не &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">Здесь нам нужно создать переменную для удержания карты-соседки,чтобы мы могли ее инициализировать.С помощью TypeScript 1.5 мы можем позволить компилятору сделать тяжелый подъем:</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">Здесь мы смогли скопировать все свойства &lt;code&gt;Person&lt;/code&gt; , кроме &lt;code&gt;location&lt;/code&gt; с помощью помощника &lt;code&gt;Omit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">Здесь мы собираемся создать класс &lt;code&gt;Student&lt;/code&gt; с конструктором и несколькими общедоступными полями. Обратите внимание, что классы и интерфейсы хорошо взаимодействуют друг с другом, позволяя программисту выбрать правильный уровень абстракции.</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">Здесь мы указываем несколько вещей на TypeScript:</target>
        </trans-unit>
        <trans-unit id="cb80aa21b4ae837ee53363a494d841d8934317d2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a basic example with &lt;code&gt;strictFunctionTypes&lt;/code&gt; off:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">Вот исправленный пример:</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">Вот простой пример недостижимой ошибки кода:</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">Вот пример этого паттерна:</target>
        </trans-unit>
        <trans-unit id="213ae2c641322b822eadac21eb578a78502cdaed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how the error happens:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">Вот как вы могли бы написать и использовать эту функцию в TypeScript, используя &lt;strong&gt;запрос типа индекса&lt;/strong&gt; и &lt;strong&gt;индексированные&lt;/strong&gt; операторы &lt;strong&gt;доступа&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">Вот еще один пример, в котором &lt;code&gt;T[P]&lt;/code&gt; обернут в класс &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a63587f4e1d9560ec04fcfe839944b3ae506477b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some example output for this file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">Здесь &lt;code&gt;SomeType&lt;/code&gt; ,по- видимому, происходит как из объявления &lt;code&gt;import&lt;/code&gt; и из объявления локального &lt;code&gt;interface&lt;/code&gt; . Возможно, удивительно, что внутри модуля &lt;code&gt;SomeType&lt;/code&gt; ссылается исключительно на определение &lt;code&gt;import&lt;/code&gt; ed, а локальное объявление &lt;code&gt;SomeType&lt;/code&gt; можно использовать только при импорте из другого файла. Это очень сбивает с толку, и наш обзор очень небольшого количества примеров такого кода в дикой природе показал, что разработчики обычно думали, что происходит что-то другое.</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">Здесь &lt;code&gt;Up&lt;/code&gt; будет иметь значение &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;Down&lt;/code&gt; будет иметь &lt;code&gt;1&lt;/code&gt; и т. Д. Такое поведение с автоматическим приращением полезно в случаях, когда мы можем не заботиться о самих значениях элементов, но заботимся о том, чтобы каждое значение отличалось от других значений в том же перечисление.</target>
        </trans-unit>
        <trans-unit id="7add7dc4368781c75bdc4173ec3100b108107d32" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it because the error message includes the missing type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">Здесь &lt;code&gt;assertNever&lt;/code&gt; проверяет, что &lt;code&gt;s&lt;/code&gt; имеет тип &lt;code&gt;never&lt;/code&gt; - тип, оставшийся после удаления всех остальных случаев. Если вы забудете регистр, тогда &lt;code&gt;s&lt;/code&gt; будет иметь реальный тип, и вы получите ошибку типа. Этот метод требует, чтобы вы определили дополнительную функцию, но когда вы ее забудете, это станет более очевидным.</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">Здесь &lt;code&gt;let Greeter&lt;/code&gt; будет назначена функция конструктора. Когда мы вызываем &lt;code&gt;new&lt;/code&gt; и запускаем эту функцию, мы получаем экземпляр класса. Функция-конструктор также содержит все статические члены класса. Другой способ думать о каждом классе - это то, что есть сторона &lt;em&gt;экземпляра и&lt;/em&gt; сторона &lt;em&gt;статики&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a0aeea38a3dd24023c3fa8431f6367d7d758da1c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;n: number&lt;/code&gt; in this example also, despite the fact that &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have not been inferred before the call. In fact, after &lt;code&gt;[1,2,3]&lt;/code&gt; has been used to infer &lt;code&gt;T=number&lt;/code&gt;, the return type of &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; is used to infer &lt;code&gt;U=string&lt;/code&gt;, causing &lt;code&gt;sns&lt;/code&gt; to have the type &lt;code&gt;string[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">Здесь TypeScript будет подниматься по папкам &lt;code&gt;node_modules&lt;/code&gt; в поисках пакета &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; . Для каждого из этих пакетов TypeScript сначала проверяет, содержит ли &lt;code&gt;package.json&lt;/code&gt; поле &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; , и если оно есть, TypeScript попытается загрузить файл конфигурации из этого поля. Если ни один из них не существует, TypeScript попытается прочитать &lt;code&gt;tsconfig.json&lt;/code&gt; в корне. Это похоже на процесс поиска файлов &lt;code&gt;.js&lt;/code&gt; в пакетах, которые использует Node, и на &lt;code&gt;.d.ts&lt;/code&gt; поиска .d.ts, который уже использует TypeScript.</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">Здесь наш пакет зависит от пакетов &lt;code&gt;browserify&lt;/code&gt; и &lt;code&gt;typescript&lt;/code&gt; . &lt;code&gt;browserify&lt;/code&gt; не связывает свои файлы объявлений со своими пакетами npm, поэтому нам нужно было полагаться на &lt;code&gt;@types/browserify&lt;/code&gt; для его объявлений. &lt;code&gt;typescript&lt;/code&gt; , с другой стороны, упаковывает свои файлы объявлений, поэтому не было необходимости в каких-либо дополнительных зависимостях.</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">Здесь функция &lt;code&gt;pickCard&lt;/code&gt; вернет две разные вещи в зависимости от того, что передал пользователь. Если пользователи передают объект, представляющий колоду, функция выберет карту. Если пользователь выбирает карту, мы сообщаем ему, какую карту он выбрал. Но как описать это в системе типов?</target>
        </trans-unit>
        <trans-unit id="eaeffdb6112e2f8dae638c67608f6ba2778d3117" translate="yes" xml:space="preserve">
          <source>Here, the TypeScript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">Здесь средство проверки типов &lt;code&gt;Window.onmousedown&lt;/code&gt; использовало тип функции Window.onmousedown, чтобы определить тип выражения функции в правой части присваивания. Когда он сделал это, он был в состоянии вывести &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;тип&lt;/a&gt; из &lt;code&gt;mouseEvent&lt;/code&gt; параметра, который действительно содержит &lt;code&gt;button&lt;/code&gt; свойства, но не &lt;code&gt;kangaroo&lt;/code&gt; собственности.</target>
        </trans-unit>
        <trans-unit id="5c595f669d2beb3aaae563a230a33b04db9bfa77" translate="yes" xml:space="preserve">
          <source>Here, the object literal &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; has a matching literal type &lt;code&gt;{ x: string, extra: number }&lt;/code&gt;. That type is assignable to &lt;code&gt;{ x: string }&lt;/code&gt; since it has all the required properties and those properties have assignable types. The extra property doesn&amp;rsquo;t prevent assignment, it just makes it a subtype of &lt;code&gt;{ x: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">Здесь мы забыли вызвать &lt;code&gt;isAdministrator&lt;/code&gt; , и код некорректно позволяет пользователям без прав администратора редактировать конфигурацию!</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">Здесь у нас есть функция &lt;code&gt;readImage&lt;/code&gt; , которая считывает изображение неблокирующим асинхронным способом. В дополнение к &lt;code&gt;readImage&lt;/code&gt; мы предоставили удобную функцию &lt;code&gt;readImage&lt;/code&gt; самого readImage, которая называется &lt;code&gt;readImage.sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">Здесь у нас есть две локальные переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; . Область действия &lt;code&gt;a&lt;/code&gt; ограничена телом &lt;code&gt;f&lt;/code&gt; , а область действия &lt;code&gt;b&lt;/code&gt; ограничена блоком оператора &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">Здесь мы &lt;code&gt;Validation&lt;/code&gt; пространство имен Validation на множество файлов. Несмотря на то, что файлы являются отдельными, каждый из них может участвовать в одном пространстве имен и использоваться, как если бы все они были определены в одном месте. Поскольку между файлами существуют зависимости, мы добавим ссылочные теги, чтобы сообщить компилятору о взаимосвязях между файлами. В остальном наш тестовый код не изменился.</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">Здесь, когда мы говорим &lt;code&gt;let greeter: Greeter&lt;/code&gt; , мы используем &lt;code&gt;Greeter&lt;/code&gt; как тип экземпляров класса &lt;code&gt;Greeter&lt;/code&gt; . Это почти вторая натура программистов, использующих другие объектно-ориентированные языки.</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">Гетерогенные перепонки</target>
        </trans-unit>
        <trans-unit id="fc6421364e8a88466f0b8a656c2d54672e0df2a5" translate="yes" xml:space="preserve">
          <source>High Level libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">Выводы типа вышестоящего порядка от генерических конструкторов</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">Выводы типа вышестоящего порядка из общих функций</target>
        </trans-unit>
        <trans-unit id="836a8611eb0ab70ee1d218e7f51d504c7581df05" translate="yes" xml:space="preserve">
          <source>Higher-kinded types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">Хит &lt;code&gt;Install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347baca49873f29800c610e216fe9cd584b6b62d" translate="yes" xml:space="preserve">
          <source>How Does A Mixin Work?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Как Node.js решает модули</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">Как TypeScript решает модули</target>
        </trans-unit>
        <trans-unit id="54183e0fc7898d58bfb00430e9606ee2944f7524" translate="yes" xml:space="preserve">
          <source>How do you obtain the library?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0752a189682fd73c97a85ecfb50c84d4af385645" translate="yes" xml:space="preserve">
          <source>How does TypeScript relate to JavaScript, though?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd674995e2b8b711665e2c0340b40adea0356b1" translate="yes" xml:space="preserve">
          <source>How is this Handbook Structured</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e505420e927902bf517a25b3ee02c1df4f205b0d" translate="yes" xml:space="preserve">
          <source>How to program in JavaScript, the good parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a165cba49bf6f53be535d3bada5e871711caec2e" translate="yes" xml:space="preserve">
          <source>How to use TypeScript-powered JavaScript tooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bab0a4785a544d72f7174abbe7378f0e4c5e6b" translate="yes" xml:space="preserve">
          <source>How would you import it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e32177f5bf0ee0e14e3a31c7e50429ce2039cd" translate="yes" xml:space="preserve">
          <source>However, TypeScript is a &lt;em&gt;typed&lt;/em&gt; superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about &lt;code&gt;obj.heigth&lt;/code&gt; was not a &lt;em&gt;syntax&lt;/em&gt; error: it is an error of using some kind of value (a &lt;em&gt;type&lt;/em&gt;) in an incorrect way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">Однако TypeScript придерживается позиции, что, вероятно, в этом коде есть ошибка. Объектные литералы подвергаются особой обработке и подвергаются &lt;em&gt;избыточной проверке свойств&lt;/em&gt; при присвоении их другим переменным или передаче их в качестве аргументов. Если литерал объекта имеет какие-либо свойства, которых нет у &amp;laquo;целевого типа&amp;raquo;, вы получите сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">Однако вместо этого TypeScript преобразовал бы в этот код исходный код:</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">Однако лучшим подходом может быть добавление подписи индекса строки, если вы уверены, что объект может иметь некоторые дополнительные свойства, которые используются каким-то особым образом. Если &lt;code&gt;SquareConfig&lt;/code&gt; может иметь свойства &lt;code&gt;color&lt;/code&gt; и &lt;code&gt;width&lt;/code&gt; с указанными выше типами, но &lt;em&gt;также&lt;/em&gt; может иметь любое количество других свойств, мы могли бы определить его следующим образом:</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">Однако в &lt;code&gt;.d.ts&lt;/code&gt; вы можете просто импортировать существующий модуль, у которого может не быть собственного файла .d.ts . Раньше это было ошибкой. Начиная с TypeScript 2.1 это стало намного проще.</target>
        </trans-unit>
        <trans-unit id="f0b057c2f8bc22925ee5d37f69c394f9bb4475bc" translate="yes" xml:space="preserve">
          <source>However, a useful heuristic could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">Тем не менее, &lt;code&gt;createSquare&lt;/code&gt; объединение этих двух элементов позволило бы подкрасться к ошибке. Например, в нашем последнем примере с использованием createSquare :</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">Однако необходимость определять функцию, чтобы выяснить, является ли тип примитивом, является своего рода болью. К счастью, вам не нужно абстрагировать &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; в свою собственную функцию, потому что TypeScript сам по себе распознает его как защиту типа. Это означает, что мы могли бы просто написать эти чеки в строке.</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Однако в приведенном выше примере и &lt;code&gt;FruitEater&lt;/code&gt; , и &lt;code&gt;ColorConsumer&lt;/code&gt; должны иметь возможность принимать строку &lt;code&gt;&quot;orange&quot;&lt;/code&gt; и возвращать либо &lt;code&gt;number&lt;/code&gt; либо &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">Однако в следующем примере не будет сообщено об ошибке,так как случай падения пуст:</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">Однако псевдоним типа не может отображаться где-либо еще в правой части объявления:</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">Однако во многом тот же эффект можно получить,стерев переменные типа в ограничении и указав вместо этого условный тип:</target>
        </trans-unit>
        <trans-unit id="876ffd4a2dccce5f7851ed0c26a166758d84a1c1" translate="yes" xml:space="preserve">
          <source>However, none of these options are the default, so they are not consistently used in TypeScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">Однако,свойства различных типов допустимы,если индексная подпись является объединением типов свойств:</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">Однако разрешение для &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;не относительного имени модуля&lt;/a&gt; выполняется иначе. Node будет искать ваши модули в специальных папках с именем &lt;code&gt;node_modules&lt;/code&gt; . А &lt;code&gt;node_modules&lt;/code&gt; папка может находиться на том же уровне, что и текущий файл, или выше в цепочке каталогов. Node будет проходить по цепочке каталогов, просматривая каждый &lt;code&gt;node_modules&lt;/code&gt; , пока не найдет модуль, который вы пытались загрузить.</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">Однако есть два ограничения,о которых следует помнить:</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">Однако этот код будет регистрировать &lt;code&gt;undefined&lt;/code&gt; , поскольку &lt;code&gt;uiEvent&lt;/code&gt; не имеет свойства с именем &lt;code&gt;button&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">Однако это чревато ошибками-ничто не мешает пользователю случайно неправильно написать одно из допустимых значений упрощения:</target>
        </trans-unit>
        <trans-unit id="5a8176fb9274a3dbc59832e6bbcd686e944cd704" translate="yes" xml:space="preserve">
          <source>However, this is observably different in certain rare cases. For example, if an array has a &amp;ldquo;hole&amp;rdquo; in it, the missing index will create an &lt;em&gt;own&lt;/em&gt; property if spreaded, but will not if built using &lt;code&gt;concat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">Однако для исходного примера это было слишком строго. Если выяснить точный тип любого возможного значения &lt;code&gt;S&lt;/code&gt; , вы можете увидеть , что он совпадает с типами в &lt;code&gt;T&lt;/code&gt; точно.</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">Однако при сравнении типов, которые имеют &lt;code&gt;private&lt;/code&gt; и &lt;code&gt;protected&lt;/code&gt; члены, мы рассматриваем эти типы по-разному. Чтобы два типа считались совместимыми, если один из них имеет &lt;code&gt;private&lt;/code&gt; член, тогда другой должен иметь &lt;code&gt;private&lt;/code&gt; член, который возник в одном объявлении. То же самое относится к &lt;code&gt;protected&lt;/code&gt; членам.</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">Однако при использовании флага &lt;code&gt;--strictNullChecks&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; могут быть присвоены только &lt;code&gt;any&lt;/code&gt; и их соответствующим типам (единственным исключением является то, что &lt;code&gt;undefined&lt;/code&gt; также можно присвоить &lt;code&gt;void&lt;/code&gt; ). Это помогает избежать &lt;em&gt;многих&lt;/em&gt; распространенных ошибок. В случаях, когда вы хотите передать либо &lt;code&gt;string&lt;/code&gt; либо &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , вы можете использовать &lt;code&gt;string | null | undefined&lt;/code&gt; типа объединения | null | неопределенный .</target>
        </trans-unit>
        <trans-unit id="047dbc98484657ac4d0055ecd2b94304fd075dce" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac716fe1287c18ff224c30b0e3ef28c757beb2fe" translate="yes" xml:space="preserve">
          <source>However, you may have intended for &lt;code&gt;core&lt;/code&gt; to be part of the output directory structure. By setting &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">гибридные типы</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">IIFE как декларации пространства имён</target>
        </trans-unit>
        <trans-unit id="b0e5d24c6bc89831f1e2de048c03becf6f8a2dab" translate="yes" xml:space="preserve">
          <source>Ideally this should stay at 0 (the default), and &lt;code&gt;d.ts&lt;/code&gt; files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">В идеале мы можем захотеть, чтобы &lt;code&gt;zoo&lt;/code&gt; выводился как &lt;code&gt;Animal[]&lt;/code&gt; , но поскольку в массиве нет объекта строго типа &lt;code&gt;Animal&lt;/code&gt; , мы не делаем вывод о типе элемента массива. Чтобы исправить это, вместо этого явно укажите тип, когда ни один тип не является супертипом всех других кандидатов:</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">В идеале мы бы просто импортировали модуль React из браузера, но большинство браузеров еще не полностью поддерживают модули. Вместо этого библиотеки традиционно становятся доступными с помощью одной глобальной переменной, такой как &lt;code&gt;jQuery&lt;/code&gt; или &lt;code&gt;_&lt;/code&gt; . Это называется &amp;laquo;шаблоном пространства имен&amp;raquo;, и webpack позволяет нам продолжать использовать библиотеки, написанные таким образом. С нашей записью для &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; react &amp;raquo;: &amp;laquo;React&amp;raquo; webpack будет творить чудеса, чтобы сделать любой импорт &lt;code&gt;&quot;react&quot;&lt;/code&gt; нагрузки из переменной &lt;code&gt;React&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f435dc0d9d21e95947646e4a4aa314593787165" translate="yes" xml:space="preserve">
          <source>Identical Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">Определение видов библиотек</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">Идентификация глобальной библиотеки по Кодексу</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">Идентификация библиотеки модулей по коду</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">Определение библиотеки UMD</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">Определение глобальных плагинов</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">Выявление модулей глобальной модификации</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">Определение структуры библиотеки - это первый шаг в написании файла декларации. Мы дадим подсказки, как идентифицировать структуру как на основе ее &lt;em&gt;использования, так&lt;/em&gt; и ее &lt;em&gt;кода&lt;/em&gt; . В зависимости от документации и организации библиотеки одно может быть проще другого. Мы рекомендуем использовать то, что вам удобнее.</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">Если задачи &amp;laquo;по умолчанию&amp;raquo; и &amp;laquo;чистые&amp;raquo; не отображаются, обновите проводник:</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">Если &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; не указан, для сборки будет использоваться последняя версия компилятора, установленная на машине.</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">Если &lt;code&gt;X&lt;/code&gt; содержит подпись числового индекса, &lt;code&gt;keyof X&lt;/code&gt; является объединением &lt;code&gt;number&lt;/code&gt; и литеральных типов, представляющих строковые и символьные свойства, в противном случае</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">Если &lt;code&gt;X&lt;/code&gt; содержит подпись индекса строки, &lt;code&gt;keyof X&lt;/code&gt; представляет собой объединение типов &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; и литералов, представляющих свойства, подобные символам, в противном случае</target>
        </trans-unit>
        <trans-unit id="f0343e4e3ae4fdd7375e56cd9c4d11af9cc6df5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isolatedModules&lt;/code&gt; is set, all implementation files must be &lt;em&gt;modules&lt;/em&gt; (which means it has some form of &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;). An error occurs if any file isn&amp;rsquo;t a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c3593112427fc1b30c2239c25266a482dc1c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;amd&lt;/code&gt;, all module files will also be concatenated into this file after all global content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67882abab18e10cbd606e356f6ed753bf2457955" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noResolve&lt;/code&gt; is set, this process doesn&amp;rsquo;t happen. However, &lt;code&gt;import&lt;/code&gt; statements are still checked to see if they resolve to a valid module, so you&amp;rsquo;ll need to make sure this is satisfied by some other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">Если &lt;code&gt;typeRoots&lt;/code&gt; указано, &lt;em&gt;только&lt;/em&gt; пакеты под &lt;code&gt;typeRoots&lt;/code&gt; будут включены. Например:</target>
        </trans-unit>
        <trans-unit id="76e7b062f347c8ed5beb7e6e8b7549983806fc75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included in the global scope. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">Если указаны &lt;code&gt;types&lt;/code&gt; , будут включены только перечисленные пакеты. Например:</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">Если решение когда-либо сводится к &lt;code&gt;Object&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt; , вы должны предпочесть &lt;code&gt;{}&lt;/code&gt; . Хотя они в основном одинаковы, технически &lt;code&gt;{}&lt;/code&gt; является более общим типом, чем &lt;code&gt;Object&lt;/code&gt; в некоторых эзотерических случаях.</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">Если указан тип по умолчанию и вывод не может выбрать кандидата,то выводится тип по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c71457b71cd95a1cb2a171eb57463a371dcaec7c" translate="yes" xml:space="preserve">
          <source>If a glob pattern doesn&amp;rsquo;t include a file extension, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default, with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f219ce45668d5a735796fec9609c181f98317e" translate="yes" xml:space="preserve">
          <source>If a module should not be automatically acquired, for example if the library is available in your &lt;code&gt;node_modules&lt;/code&gt; but your team has agreed to not use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">Если сегмент шаблона glob включает только &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;.*&lt;/code&gt; , Тогда включаются только файлы с поддерживаемыми расширениями (например, &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; и &lt;code&gt;.d.ts&lt;/code&gt; по умолчанию с &lt;code&gt;.js&lt;/code&gt; и &lt;code&gt;.jsx&lt;/code&gt; , если для &lt;code&gt;allowJs&lt;/code&gt; установлено значение true) .</target>
        </trans-unit>
        <trans-unit id="bec2b2f64a8b9ad3998bf7f229a2fbb020be7798" translate="yes" xml:space="preserve">
          <source>If absent, then &amp;ldquo;main&amp;rdquo; is used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">Если любой из операндов оператора &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; или &lt;code&gt;in&lt;/code&gt; допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Если любой из операндов оператора &lt;code&gt;+&lt;/code&gt; допускает значение NULL, и ни один из операндов не имеет типа &lt;code&gt;any&lt;/code&gt; или &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">Если любой из операндов &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , или оператор &lt;code&gt;^&lt;/code&gt; допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">Если для переменной среды &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; установлено значение true, отслеживает родительский каталог файлов (как и &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; ). В противном случае смотрите файлы, используя &lt;code&gt;fs.watchFile&lt;/code&gt; с &lt;code&gt;250ms&lt;/code&gt; 250 мс для любого файла.</target>
        </trans-unit>
        <trans-unit id="d06262f17b6e967b3001fc6098e3202e17df154f" translate="yes" xml:space="preserve">
          <source>If not specified, &lt;code&gt;.js&lt;/code&gt; files will be emitted in the same directory as the &lt;code&gt;.ts&lt;/code&gt; files they were generated from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">Если свойства никогда не устанавливаются в теле класса, они считаются неизвестными. Если у вашего класса есть свойства, которые только читаются, добавьте, а затем аннотируйте объявление в конструкторе с помощью JSDoc, чтобы указать тип. Вам даже не нужно указывать значение, если оно будет инициализировано позже:</target>
        </trans-unit>
        <trans-unit id="5a4ad169ba84bf7c2bddecab5b752919e9c60ee2" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;.js&lt;/code&gt; (as well as &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.js.map&lt;/code&gt;, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see &lt;a href=&quot;#rootDir&quot;&gt;rootDir&lt;/a&gt; if the computed root is not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c82e3245bf395bde8ad50d56147266b35e02cbd" translate="yes" xml:space="preserve">
          <source>If specified, all &lt;em&gt;global&lt;/em&gt; (non-module) files will be concatenated into the single output file specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">Если это не сработало и если имя модуля не является относительным (а в случае &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; оно и есть), то компилятор попытается найти объявление &lt;a href=&quot;modules#ambient-modules&quot;&gt;внешнего модуля&lt;/a&gt; . Далее мы рассмотрим неродственный импорт.</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">Если для вас это звучит слишком слабо, вы можете ужесточить такое поведение. Если, например, вы &lt;em&gt;не&lt;/em&gt; хотите, чтобы TypeScript компилировался в JavaScript перед лицом ошибок, вы можете использовать параметр &lt;code&gt;noEmitOnError&lt;/code&gt; . В этом смысле у TypeScript есть циферблат строгости, и вы можете повернуть эту ручку настолько высоко, насколько захотите.</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">В этом случае файлы, которые вы написали, будут использоваться в качестве входных данных для TypeScript, и вы запустите полученные выходные данные. Во время миграции с JS на TS нам нужно разделить наши входные файлы, чтобы TypeScript не перезаписал их. Если ваши выходные файлы должны находиться в определенном каталоге, тогда это будет ваш выходной каталог.</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">Если &lt;code&gt;&quot;files&quot;&lt;/code&gt; и &lt;code&gt;&quot;include&quot;&lt;/code&gt; указаны, компилятор по умолчанию включает все &lt;code&gt;.ts&lt;/code&gt; TypeScript ( .ts , &lt;code&gt;.d.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; ) в содержащий каталог и подкаталоги, кроме тех, которые исключены с помощью свойства &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . Файлы &lt;code&gt;.js&lt;/code&gt; ( .js и &lt;code&gt;.jsx&lt;/code&gt; ) также включаются, если для параметра &lt;code&gt;allowJs&lt;/code&gt; установлено значение true.</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">Если &lt;code&gt;&quot;files&quot;&lt;/code&gt; и &lt;code&gt;&quot;include&quot;&lt;/code&gt; указаны, компилятор по умолчанию включает все &lt;code&gt;.ts&lt;/code&gt; TypeScript ( .ts , &lt;code&gt;.d.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; ) в содержащий каталог и подкаталоги, кроме тех, которые исключены с помощью свойства &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; . Файлы &lt;code&gt;.js&lt;/code&gt; ( .js и &lt;code&gt;.jsx&lt;/code&gt; ) также включаются, если для параметра &lt;code&gt;allowJs&lt;/code&gt; установлено значение true. Если &lt;code&gt;&quot;include&quot;&lt;/code&gt; свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt; или &amp;laquo;include&amp;raquo; , компилятор вместо этого включит объединение файлов, включенных этими двумя свойствами. Файлы в каталоге, указанном с помощью &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; параметр компилятора &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; пока не указано свойство &amp;laquo;exclude&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">Если &lt;code&gt;&quot;include&quot;&lt;/code&gt; свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt; или &amp;laquo;include&amp;raquo; , компилятор вместо этого включит объединение файлов, включенных этими двумя свойствами. Файлы в каталоге, указанном с помощью &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; компилятора &amp;laquo;outDir&amp;raquo; , всегда исключаются, если явно не включены через свойство &lt;code&gt;&quot;files&quot;&lt;/code&gt; (даже если указано свойство &amp;laquo; &lt;code&gt;exclude&lt;/code&gt; &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="d9d1e0016c3b073e477b87823fb48c212a972f04" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;importHelpers&lt;/code&gt; flag is on, these helper functions are instead imported from the &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; module. You will need to ensure that the &lt;code&gt;tslib&lt;/code&gt; module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">Если декоратор средства доступа возвращает значение, оно будет использоваться как &lt;em&gt;дескриптор свойства&lt;/em&gt; для члена.</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">Если декоратор класса возвращает значение,то он заменит декларацию класса на предусмотренную функцию конструктора.</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">Если указан флаг компилятора &lt;code&gt;--noResolve&lt;/code&gt; , ссылки с тройной косой чертой игнорируются; они не приводят ни к добавлению новых файлов, ни к изменению порядка предоставленных файлов.</target>
        </trans-unit>
        <trans-unit id="6404fc019a0ea10b80a74ad6d4f189ca7a5e6cf0" translate="yes" xml:space="preserve">
          <source>If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">Если декоратор метода возвращает значение, оно будет использоваться как &lt;em&gt;дескриптор свойства&lt;/em&gt; для метода.</target>
        </trans-unit>
        <trans-unit id="5e2ec078a41809b3ea00769455fcd98c66227dc0" translate="yes" xml:space="preserve">
          <source>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">Если операнд унарного оператора &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; или &lt;code&gt;--&lt;/code&gt; допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">Если указанный проект создает &lt;code&gt;outFile&lt;/code&gt; , объявления файла &lt;code&gt;.d.ts&lt;/code&gt; выходного файла будут видны в этом проекте.</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">Если правый операнд оператора &lt;code&gt;instanceof&lt;/code&gt; допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">Если бы эта функция не была в контекстно типизированной позиции, аргумент функции неявно имел бы тип &lt;code&gt;any&lt;/code&gt; , и не было бы выдано никакой ошибки (если вы не используете параметр &lt;code&gt;--noImplicitAny&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">Если у нас есть значение,которое имеет тип профсоюза,мы можем получить доступ только к тем членам,которые являются общими для всех типов профсоюза.</target>
        </trans-unit>
        <trans-unit id="935377e4091dae4bb943432ee7eeb7b9ff3cef2c" translate="yes" xml:space="preserve">
          <source>If we have a value that is a union type, we can only access members that are common to all types in the union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">Если мы хотим настроить, как декоратор применяется к объявлению, мы можем написать фабрику декораторов. &lt;em&gt;Декоратор Factory&lt;/em&gt; это просто функция , которая возвращает выражение , которое будет вызываться декоратором во время выполнения.</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">Если бы мы хотели,мы могли бы полностью отказаться от инициализаторов:</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">Если бы мы использовали &lt;a href=&quot;#decorator-factories&quot;&gt;фабрики декораторов&lt;/a&gt; , мы могли бы наблюдать этот порядок оценки на следующем примере:</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">Если вы добавляете файл &lt;code&gt;tsconfig.json&lt;/code&gt; , файлы TypeScript, которые не считаются частью этого контекста, не компилируются.</target>
        </trans-unit>
        <trans-unit id="776111b439c21b6cb775099faee4d16246e9ab8d" translate="yes" xml:space="preserve">
          <source>If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;on JavaScript at the Mozilla Web Docs&lt;/a&gt;. If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085d3fb970c36076b70083b38db4b956effc131e" translate="yes" xml:space="preserve">
          <source>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">Если вы используете другой инструмент сборки для сборки вашего проекта (например, gulp, grunt и т. Д.) И VS для разработки и отладки, установите &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; в своем проекте. Это должно дать вам всю поддержку редактирования, но не сборку при нажатии F5.</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">Если вы проверяете какие-либо выходные данные сборки ( &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; , &lt;code&gt;.d.ts.map&lt;/code&gt; и т. Д.), Вам может потребоваться запустить сборку &lt;code&gt;--force&lt;/code&gt; после определенных операций управления версиями в зависимости от того, сохраняет ли ваш инструмент управления версиями метки времени между локальной копией и удаленной копией.</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">Если вы не хотите тратить время на выписывание объявлений перед использованием нового модуля, теперь вы можете просто использовать сокращенное объявление, чтобы быстро начать работу.</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">Если вы не хотите тратить время на выписывание объявлений перед использованием нового модуля, вы можете использовать сокращенное объявление, чтобы быстро начать работу.</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">Если у вас когда-либо было значение, которое, по мнению TypeScript, возможно, равно &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; , но вы знаете лучше, вы можете использовать постфикс &lt;code&gt;!&lt;/code&gt; оператор, чтобы сказать иначе.</target>
        </trans-unit>
        <trans-unit id="23d58bbe6abf7e68dae13856af53d691d0dfa849" translate="yes" xml:space="preserve">
          <source>If you find yourself searching for something like &amp;ldquo;how to sort a list in TypeScript&amp;rdquo;, remember: &lt;strong&gt;TypeScript is JavaScript&amp;rsquo;s runtime with a compile-time type checker&lt;/strong&gt;. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that&amp;rsquo;s great too, but don&amp;rsquo;t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33efe22b92b7f2005e7eb656f1a76dbf3fcbc9bb" translate="yes" xml:space="preserve">
          <source>If you get tired of imports always looking like &lt;code&gt;&quot;../&quot;&lt;/code&gt; or &lt;code&gt;&quot;./&quot;&lt;/code&gt;. Or needing to change as you move files, this is a great way to fix that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">Если бы у вас был следующий код Node/CommonJS:</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">Если у вас есть папка &lt;code&gt;tests&lt;/code&gt; за пределами вашего каталога &lt;code&gt;src&lt;/code&gt; , у вас может быть один &lt;code&gt;tsconfig.json&lt;/code&gt; в &lt;code&gt;src&lt;/code&gt; и еще один в &lt;code&gt;tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37eded98e17f199e9a0f317e547c4692b3b985a7" translate="yes" xml:space="preserve">
          <source>If you have a lot of JavaScript files you want to add errors to then you can switch to using a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;jsconfig.json&lt;/code&gt;&lt;/a&gt;. You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5daacb30eeb58b2f2dd8eeb43af27c13d0f6e359" translate="yes" xml:space="preserve">
          <source>If you have a module which when imported, makes changes to other modules use template &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25661d3416deb409f63475049ffc70db498f494" translate="yes" xml:space="preserve">
          <source>If you have a specific module which should be included (but isn&amp;rsquo;t in &lt;code&gt;node_modules&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Если у вас есть тип с &lt;code&gt;keyof T&lt;/code&gt; подписью индекса, ключ T будет просто &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="036ed4bc42cb6365f2fcac60d2ef2dafe759c7d5" translate="yes" xml:space="preserve">
          <source>If you have a variable with an unknown type, you can narrow it to something more specific by doing &lt;code&gt;typeof&lt;/code&gt; checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">Если у Вас есть проект msbuild,Вы можете включить режим сборки,добавив</target>
        </trans-unit>
        <trans-unit id="29f75b30082c5ae8c9dd501dc68ec9c17ab2e182" translate="yes" xml:space="preserve">
          <source>If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;--extendedDiagnostics&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958ebfa05a47b2e603ba5d2a6dfd282d81623dc" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">Если вы намеревались протестировать функцию без ее вызова, вы можете исправить ее определение, включив &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; , или использовать &lt;code&gt;!!&lt;/code&gt; написать что-то вроде &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; чтобы указать, что принуждение является преднамеренным.</target>
        </trans-unit>
        <trans-unit id="5a96d27a06b8980e6a4f2196b4ba66f129bc78de" translate="yes" xml:space="preserve">
          <source>If you move some code from a JavaScript file to a TypeScript file, you might see &lt;em&gt;type errors&lt;/em&gt; depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we&amp;rsquo;ll demonstrate how to add various TypeScript syntax to eliminate such errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba807eb4e0eaeb772cb84988d65f758637aa63a7" translate="yes" xml:space="preserve">
          <source>If you need to learn the good parts of JavaScript, read &lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. &lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R&lt;sup&gt;4&lt;/sup&gt;RS Scheme&lt;/a&gt; is a good example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">Если вы планируете использовать более строгие настройки, которые доступны, лучше включить их сейчас (см. &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Более строгие проверки&lt;/a&gt; ниже). Например, если вы никогда не хотите, чтобы TypeScript выводил &lt;code&gt;any&lt;/code&gt; для типа без вашего явного указания, вы можете использовать &lt;code&gt;noImplicitAny&lt;/code&gt; до того, как начнете изменять свои файлы. Хотя это может показаться несколько подавляющим, долгосрочные выгоды становятся очевидными гораздо быстрее.</target>
        </trans-unit>
        <trans-unit id="5184246af95057dfb4d9aaab56132b936756e920" translate="yes" xml:space="preserve">
          <source>If you provide an object that doesn&amp;rsquo;t match the interface you have provided, TypeScript will warn you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">Если вы помните из предыдущего примера, иногда вам может понадобиться написать универсальную функцию, которая работает с набором типов, если у вас есть некоторые знания о том, какие возможности будет иметь этот набор типов. В нашем примере &lt;code&gt;loggingIdentity&lt;/code&gt; мы хотели иметь доступ к свойству &lt;code&gt;.length&lt;/code&gt; &lt;code&gt;arg&lt;/code&gt; , но компилятор не смог доказать, что у каждого типа есть свойство &lt;code&gt;.length&lt;/code&gt; , поэтому он предупреждает нас, что мы не можем сделать это предположение.</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">Если вы видите тесты для &lt;code&gt;typeof define&lt;/code&gt; , &lt;code&gt;typeof window&lt;/code&gt; или &lt;code&gt;typeof module&lt;/code&gt; в коде библиотеки, особенно в верхней части файла, это почти всегда библиотека UMD.</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">Если вы начали переходить на импорт TypeScript, вы, вероятно, столкнетесь с ошибками, например, &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; . Проблема здесь в том, что у вас, скорее всего, нет &lt;em&gt;файлов объявлений&lt;/em&gt; для описания вашей библиотеки. К счастью, это довольно просто. Если TypeScript жалуется на такой пакет, как &lt;code&gt;lodash&lt;/code&gt; , вы можете просто написать</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">Если вы используете &lt;code&gt;y&lt;/code&gt; способом, который не поддерживает ограничение параметра типа, вы правильно получите ошибку. В этом случае ограничением &lt;code&gt;T&lt;/code&gt; было (неявно) &lt;code&gt;{}&lt;/code&gt; , поэтому последний пример соответствующим образом завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="5e5165e11849a0b5581c2dad31e4b0f7f73cb5bb" translate="yes" xml:space="preserve">
          <source>If you would like to disable or customize this feature, create a &lt;code&gt;jsconfig.json&lt;/code&gt; in the root of your project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb46c60d30559d817b085b18b7cb967b9fe7cd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to write tests for your .d.ts files, try &lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;tsd&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Если вы предпочитаете быть явным, вы также можете указать тип значений, которые могут быть возвращены, выданы и оценены из выражений &lt;code&gt;yield&lt;/code&gt; с использованием явного типа возвращаемого значения. Ниже &lt;code&gt;next()&lt;/code&gt; может быть вызван только с &lt;code&gt;boolean&lt;/code&gt; s, и в зависимости от значения &lt;code&gt;done&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; является либо &lt;code&gt;string&lt;/code&gt; либо &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342b7134b6ae686fafbfd59ad7d6e4b1867ceab4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript &lt;em&gt;without&lt;/em&gt; types first to understand JavaScript&amp;rsquo;s runtime behaviors. Because TypeScript doesn&amp;rsquo;t change how your code &lt;em&gt;runs&lt;/em&gt;, you&amp;rsquo;ll still have to learn how JavaScript works in order to write code that actually does something!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">Если вы конвертируете программу из пространств имен в модули, можно легко получить файл, который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">Если вы экспортируете несколько объектов, поместите их все на верхний уровень</target>
        </trans-unit>
        <trans-unit id="d824a46b68a6c563ea08418e176071b76786c629" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it&amp;rsquo;s important to keep these in mind when learning TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">Если вы хотите преобразовать проект React, мы рекомендуем сначала &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;ознакомиться с руководством по преобразованию React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">Если вы экспортируете только один &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;function&lt;/code&gt; , используйте &lt;code&gt;export default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">Если вы читаете это руководство, вы, вероятно, уже примерно знаете, что такое тип в TypeScript. Однако, чтобы быть более явным, &lt;em&gt;тип&lt;/em&gt; представлен с помощью:</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">Если вы начинаете новый проект, сначала &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;ознакомьтесь с руководством по быстрому запуску React&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">Если вы каким-то образом используете Gulp, у нас есть руководство по &lt;a href=&quot;gulp&quot;&gt;использованию Gulp&lt;/a&gt; с TypeScript и интеграции с распространенными инструментами сборки, такими как Browserify, Babelify и Uglify. Вы можете узнать больше здесь.</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">Если вы используете параметр модуля, отличный от &lt;code&gt;commonjs&lt;/code&gt; , вам необходимо установить для параметра &lt;code&gt;moduleResolution&lt;/code&gt; значение &lt;code&gt;node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">Если вы пишете на простом JavaScript, скорее всего, вы запускаете свой JavaScript напрямую, где ваши &lt;code&gt;.js&lt;/code&gt; - файлы находятся в каталоге &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;lib&lt;/code&gt; или &lt;code&gt;dist&lt;/code&gt; , а затем выполнялись по желанию.</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">Если вы читали о &lt;code&gt;typeof&lt;/code&gt; типов typeof и знакомы с оператором &lt;code&gt;instanceof&lt;/code&gt; в JavaScript, вы, вероятно, имеете некоторое представление о том, о чем этот раздел.</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">Если вы использовали JavaScript случайно, следующий раздел может стать хорошим способом освежить вашу память. Если вы хорошо знакомы со всеми особенностями объявлений &lt;code&gt;var&lt;/code&gt; в JavaScript, возможно, вам будет проще пропустить их.</target>
        </trans-unit>
        <trans-unit id="f2e114215a3320f3e8d3e8f7df80ee0813862362" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;outDir&lt;/code&gt; was &lt;code&gt;dist&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">Если ваши функции могут обрабатывать только строковые ключи свойств, используйте в объявлении &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">Если ваши функции открыты для работы со всеми ключами свойств,то изменения должны выполняться вниз по течению:</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">Если ваша глобальная библиотека зависит от модуля UMD, используйте директиву &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">Если ваша библиотека зависит от глобальной библиотеки, используйте директиву &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">Если ваша библиотека зависит от модуля, используйте оператор &lt;code&gt;import&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d7e714b624bcbe3efa868c9a33be75efd1d5cd0" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">Если ваш модуль нельзя вызвать или &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , используйте файл module.d.ts .</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">Если ваш модуль или библиотека UMD зависит от библиотеки UMD, используйте оператор &lt;code&gt;import&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">Если в вашем пакете есть основной файл &lt;code&gt;.js&lt;/code&gt; , вам также нужно будет указать основной файл декларации в файле &lt;code&gt;package.json&lt;/code&gt; . Задайте свойство &lt;code&gt;types&lt;/code&gt; , чтобы оно указывало на ваш связанный файл декларации. Например:</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">Если ваш пакет не написан на языке TypeScript,то предпочтительным является второй подход.</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">Если ваш пакет написан на TypeScript, предпочтение отдается первому подходу. Используйте флаг &lt;code&gt;--declaration&lt;/code&gt; для создания файлов объявлений. Таким образом, ваши объявления и JavaScript всегда будут синхронизированы.</target>
        </trans-unit>
        <trans-unit id="557fe20ea364d4b85526f359a785f2b91d2a48b9" translate="yes" xml:space="preserve">
          <source>If your project is large, you can use the flag &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">Если определения типа зависят от другого пакета:</target>
        </trans-unit>
        <trans-unit id="55d1f300034ec5a2f0ab70c4ab7606f20472a2c0" translate="yes" xml:space="preserve">
          <source>If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;--declaration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">Реализация интерфейса</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">Неявные ошибки</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">Неявные индексные подписи</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">Неявные возвраты</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="e388bb159f67517527bff80832c050cc9caf92f8" translate="yes" xml:space="preserve">
          <source>Import Helpers - &lt;code&gt;importHelpers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">Импорт модуля только для побочных эффектов</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">Импорт одного экспорта из модуля</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">В объявлениях импорта также можно опционально использовать предложения &lt;code&gt;as&lt;/code&gt; для указания различных локальных имен для импорта. Например:</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Импортировать эмитирующие помощники (например, &lt;code&gt;__extends&lt;/code&gt; , &lt;code&gt;__rest&lt;/code&gt; и т. Д.) Из &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">Импортируйте весь модуль в одну переменную и используйте его для доступа к экспортированным данным модуля.</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">Виды импорта</target>
        </trans-unit>
        <trans-unit id="104faef181cd8882668103e771e8eba923a2dcd8" translate="yes" xml:space="preserve">
          <source>Importantly, &lt;code&gt;rootDir&lt;/code&gt;&lt;strong&gt;does not affect which files become part of the compilation&lt;/strong&gt;. It has no interaction with the &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;exclude&lt;/code&gt;, or &lt;code&gt;files&lt;/code&gt;&lt;code&gt;tsconfig.json&lt;/code&gt; settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa34d39c6555134662f510867cd143b4479edd11" translate="yes" xml:space="preserve">
          <source>Importing Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">Импорт из модулей</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">Импорт почти так же прост, как экспорт из модуля. Импорт экспортированной декларации выполняется с помощью одной из следующих форм &lt;code&gt;import&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">При импорте модулей из проекта, на который имеется ссылка, вместо этого будет загружен его &lt;em&gt;выходной&lt;/em&gt; файл декларации ( &lt;code&gt;.d.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">Импорт ресурсов без кода с использованием расширения загрузчиков модулей (например, &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; или &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt; ) раньше не был простым; ранее для каждого ресурса нужно было определять объявление внешнего модуля.</target>
        </trans-unit>
        <trans-unit id="c444c4e966092782432f42e431dba46820d67082" translate="yes" xml:space="preserve">
          <source>Imports Not Used As Values - &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0a4c588d4f7e13fddfb1185a854f0eb29bd646" translate="yes" xml:space="preserve">
          <source>Imports fine with &lt;code&gt;allowJs&lt;/code&gt; enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">Улучшен &lt;code&gt;any&lt;/code&gt; вывод</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">Улучшенный &lt;code&gt;keyof&lt;/code&gt; с типами пересечения</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">Улучшенные UX вокруг обещаний</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">Улучшенное поведение для вызывающих типов профсоюзов</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">Улучшена проверка операторов &lt;code&gt;for..in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">Улучшена проверка на буквальность разрушаемого объекта</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">Улучшенный контроль над модификаторами отображаемого типа</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">Улучшенные проверки избыточного имущества в профсоюзных типах</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">Улучшенная обработка структурно идентичных классов и выражений &lt;code&gt;instanceof&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">Улучшенный вывод для дженериков</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">Улучшена поддержка &lt;code&gt;tsconfig.json&lt;/code&gt; в Visual Studio 2015.</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">Улучшенный тип вывода для объектных литералов</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">Улучшенный тип соединения/пересечения умозаключения</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">Усовершенствования для &lt;code&gt;ReadonlyArray&lt;/code&gt; и &lt;code&gt;readonly&lt;/code&gt; кортежей</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">В &lt;a href=&quot;templates&quot;&gt;шаблонах&lt;/a&gt; вы найдете несколько файлов объявлений, которые служат полезной отправной точкой при написании нового файла. Обратитесь к документации в &lt;a href=&quot;library-structures&quot;&gt;библиотечных структурах,&lt;/a&gt; чтобы выяснить, какой файл шаблона использовать.</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">В режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; модификатор автоматически включает &lt;code&gt;undefined&lt;/code&gt; в тип элемента, аналогично необязательным параметрам.</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">В &lt;code&gt;getProperty&lt;/code&gt; , &lt;code&gt;o: T&lt;/code&gt; и &lt;code&gt;propertyName: K&lt;/code&gt; , так что это означает &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; . Как только вы вернете результат &lt;code&gt;T[K]&lt;/code&gt; , компилятор создаст экземпляр фактического типа ключа, поэтому тип возврата &lt;code&gt;getProperty&lt;/code&gt; будет варьироваться в зависимости от того, какое свойство вы запрашиваете.</target>
        </trans-unit>
        <trans-unit id="0dd13518438c7329cf2fbf854c20974ad59ee4e1" translate="yes" xml:space="preserve">
          <source>In C# or Java, any given value or object has one exact type - either &lt;code&gt;null&lt;/code&gt;, a primitive, or a known class type. We can call methods like &lt;code&gt;value.GetType()&lt;/code&gt; or &lt;code&gt;value.getClass()&lt;/code&gt; to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can&amp;rsquo;t use two classes with similar shapes in lieu of each other unless there&amp;rsquo;s an explicit inheritance relationship or commonly-implemented interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6827479b1d6256b64a352469a1cd16d7c9ad22a" translate="yes" xml:space="preserve">
          <source>In C# or Java, it&amp;rsquo;s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c08d2e6fe05992c2156e08cd3c91dcc0de0788" translate="yes" xml:space="preserve">
          <source>In CommonJS you can export any value as the default export, for example here is a regular expression module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">В ES2015, конструкторы , которые возвращают объект неявно подставить значение &lt;code&gt;this&lt;/code&gt; для каких - либо вызывающих &lt;code&gt;super()&lt;/code&gt; . В результате необходимо захватить любое потенциальное возвращаемое значение &lt;code&gt;super()&lt;/code&gt; и заменить его &lt;code&gt;this&lt;/code&gt; . Это изменение позволяет работать с &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;настраиваемыми элементами&lt;/a&gt; , которые используют это преимущество для инициализации элементов, выделенных браузером, с помощью конструкторов, написанных пользователем.</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">В загрузчиках модулей ES6 объект верхнего уровня (здесь импортированный как &lt;code&gt;exp&lt;/code&gt; ) может иметь только свойства; объект модуля верхнего уровня &lt;em&gt;никогда не&lt;/em&gt; вызывается . Наиболее распространенным решением здесь является определение экспорта по &lt;code&gt;default&lt;/code&gt; для вызываемого / создаваемого объекта; некоторые прокладки загрузчика модулей автоматически обнаруживают эту ситуацию и заменяют объект верхнего уровня на экспорт по &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73164a9f408dbb559f1ff8a82aed1d6f3a2cf1a3" translate="yes" xml:space="preserve">
          <source>In ES6-compl module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object can &lt;em&gt;never&lt;/em&gt; be callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ded81fd300907288de9253ff02bb98d86a22764" translate="yes" xml:space="preserve">
          <source>In ES6-compliant module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object can &lt;em&gt;never&lt;/em&gt; be callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">В Edge нажмите F12 и перейдите на вкладку Debugger.</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">В JSDoc ссылки</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">В JavaScript довольно часто встречаются API-интерфейсы, которые ожидают имена свойств в качестве параметров, но до сих пор не было возможности выразить отношения типов, которые возникают в этих API.</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">В JavaScript &lt;code&gt;this&lt;/code&gt; переменная, которая устанавливается при вызове функции. Это делает его очень мощной и гибкой функцией, но за это приходится всегда знать о контексте, в котором выполняется функция. Это, как известно, сбивает с толку, особенно при возврате функции или передаче функции в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">В JavaScript объявления &lt;code&gt;var&lt;/code&gt; &amp;laquo;поднимаются&amp;raquo; наверх своей области видимости. Это может привести к сбивающим с толку ошибкам:</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">В JavaScript все параметры являются необязательными, и пользователи могут не указывать их по своему усмотрению. Когда они это сделают, их ценность не &lt;code&gt;undefined&lt;/code&gt; . Мы можем получить эту функциональность в TypeScript, добавив &lt;code&gt;?&lt;/code&gt; до конца параметров, которые мы хотим быть необязательными. Например, допустим, мы хотим, чтобы параметр фамилии сверху был необязательным:</target>
        </trans-unit>
        <trans-unit id="67651f3f892a0de5974b0da9cae101fc0f274b31" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;. This flexibility is extremely powerful. &amp;ldquo;Free&amp;rdquo; functions (those not associated with a class) working over data without an implied OOP hierarchy tends to be the preferred model for writing programs in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a818fdd28b569608ea92c5b8fbf2223393403d4" translate="yes" xml:space="preserve">
          <source>In JavaScript, mutability is the default, although it allows variable declarations with &lt;code&gt;const&lt;/code&gt; to declare that the &lt;em&gt;reference&lt;/em&gt; is immutable. The referent is still mutable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">В Node.js большинство задач выполняется путем загрузки одного или нескольких модулей. Мы могли бы определить каждый модуль в его собственном файле &lt;code&gt;.d.ts&lt;/code&gt; с объявлениями экспорта верхнего уровня, но удобнее записать их как один файл &lt;code&gt;.d.ts&lt;/code&gt; большего размера . Для этого мы используем конструкцию, аналогичную окружающим пространствам имен, но используем ключевое слово &lt;code&gt;module&lt;/code&gt; и цитируемое имя модуля, которое будет доступно для последующего импорта. Например:</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">В TypeScript 1.4 мы добавили поддержку шаблонных строк для всех целей и тегированные шаблоны только для ES6. Благодаря значительной работе, проделанной &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt; , мы восполнили пробел для тегированных шаблонов в ES3 и ES5.</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">В машинописном 1.8 с последней версией react.d.ts (смотри выше), мы также значительно упрощена декларацию &lt;code&gt;props&lt;/code&gt; типов.</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">В TypeScript 2.0 стало значительно проще использовать файлы деклараций,приобретать,использовать и находить их.На этой странице подробно описано,как это сделать во всех трех случаях.</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">В TypeScript 2.3 TS представила проверку типов &lt;em&gt;дочерних&lt;/em&gt; элементов . &lt;em&gt;children&lt;/em&gt; - это специальное свойство в &lt;em&gt;типе атрибутов элемента, в&lt;/em&gt; котором дочерние &lt;em&gt;выражения JSXExpression&lt;/em&gt; используются для вставки в атрибуты. Подобно тому, как TS использует &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; для определения имени &lt;em&gt;реквизита&lt;/em&gt; , TS использует &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; для определения имени &lt;em&gt;дочерних&lt;/em&gt; элементов в этих реквизитах. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; следует объявлять с одним свойством.</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">В TypeScript 2.4 теперь является ошибкой назначать что-либо слабому типу при отсутствии перекрытия свойств. Например:</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">В TypeScript 2.4 функция с правой стороны неявно &lt;em&gt;получает&lt;/em&gt; параметры типа, и предполагается , что &lt;code&gt;y&lt;/code&gt; имеет тип этого параметра типа.</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">В TypeScript 2.6 и ранее &lt;code&gt;[number, string, string]&lt;/code&gt; считалось подтипом &lt;code&gt;[number, string]&lt;/code&gt; . Это было мотивировано структурной природой TypeScript; первый и второй элементы &lt;code&gt;[number, string, string]&lt;/code&gt; являются соответственно подтипами первого и второго элементов &lt;code&gt;[number, string]&lt;/code&gt; . Однако, изучив использование кортежей в реальном мире, мы заметили, что большинство ситуаций, в которых это разрешено, обычно нежелательны.</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">В TypeScript 2.7 кортежи разных арностей больше не могут быть назначены друг другу. Благодаря запросу на вытягивание от &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt; типы кортежей теперь кодируют свою арность в тип соответствующего свойства &lt;code&gt;length&lt;/code&gt; . Это достигается за счет использования числовых литеральных типов, которые теперь позволяют отличать кортежи от кортежей разной арности.</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">В TypeScript 3.1 сопоставленные типы объектов &lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; кортежей и массивов теперь создают новые кортежи / массивы, а не создают новый тип, в котором преобразуются такие члены, как &lt;code&gt;push()&lt;/code&gt; , &lt;code&gt;pop()&lt;/code&gt; и &lt;code&gt;length&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">В TypeScript 3.2 объектные литералы теперь допускают универсальные выражения распространения, которые теперь создают типы пересечений, аналогично функции &lt;code&gt;Object.assign&lt;/code&gt; и литералам JSX. Например:</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">В машинописном 3.3 &lt;code&gt;--build&lt;/code&gt; Mode, &lt;code&gt;--watch&lt;/code&gt; флаг &lt;em&gt;делает&lt;/em&gt; файл рычаги инкрементного наблюдая , как хорошо. Это может означать значительно более быструю сборку с &lt;code&gt;--build --watch&lt;/code&gt; . В нашем тестировании эта функция привела &lt;strong&gt;к сокращению времени сборки&lt;/strong&gt; на &lt;code&gt;--build --watch&lt;/code&gt; &lt;strong&gt;% по сравнению&lt;/strong&gt; с исходным временем --build --watch . &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;Вы можете узнать больше об исходном запросе на внесение изменений,&lt;/a&gt; чтобы увидеть конкретные цифры, но мы считаем, что большинство пользователей составных проектов увидят здесь значительные преимущества.</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">В TypeScript 3.3 параметры этих подписей &lt;em&gt;пересекаются&lt;/em&gt; вместе, чтобы создать новую подпись.</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">В TypeScript 3.3 это больше не является ошибкой.</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">В TypeScript 3.4 и ранее некоторые лишние свойства были разрешены в ситуациях, когда они действительно не должны были быть. Например, TypeScript 3.4 допускает неправильное свойство &lt;code&gt;name&lt;/code&gt; в литерале объекта, даже если его типы не совпадают между &lt;code&gt;Point&lt;/code&gt; и &lt;code&gt;Label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">В TypeScript 3.4 и выше,следующий пример будет неудачным:</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">В TypeScript 3.4 модификатор &lt;code&gt;readonly&lt;/code&gt; в сопоставленном типе автоматически преобразует массивоподобные типы в их соответствующие аналоги, &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">В TypeScript 3.4 мы улучшили вывод о том,когда общие функции,которые возвращают такие функции:</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">В TypeScript 3.5 средство проверки типов по крайней мере проверяет, что все предоставленные свойства принадлежат &lt;em&gt;какому-либо&lt;/em&gt; члену объединения и имеют соответствующий тип, что означает, что приведенный выше пример правильно выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">В машинописном 3.5, при назначении типов с дискриминантными свойствами , как в &lt;code&gt;T&lt;/code&gt; , язык фактически &lt;em&gt;будет&lt;/em&gt; идти дальше и разлагаются типами , такие как &lt;code&gt;S&lt;/code&gt; в объединение все возможного обитатель типа. В этом случае, поскольку &lt;code&gt;boolean&lt;/code&gt; является объединением &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; будет рассматриваться как объединение &lt;code&gt;{ done: false, value: number }&lt;/code&gt; и &lt;code&gt;{ done: true, value: number }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">В TypeScript 3.5 вы можете теперь ссылаться на глобальные декларации UMD,такие как</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">В TypeScript 3.6 средство проверки теперь знает, что правильным типом для &lt;code&gt;curr.value&lt;/code&gt; должна быть &lt;code&gt;string&lt;/code&gt; в нашем первом примере, и корректно выдаст ошибку при нашем вызове &lt;code&gt;next()&lt;/code&gt; в нашем последнем примере. Это произошло благодаря некоторым изменениям в объявлениях типов &lt;code&gt;Iterator&lt;/code&gt; и &lt;code&gt;IteratorResult&lt;/code&gt; , которые включают несколько новых параметров типа, а также новому типу, который TypeScript использует для представления генераторов, который называется типом &lt;code&gt;Generator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">В TypeScript 3.7 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;это теперь правильно определяется как ошибка повторяющегося идентификатора&lt;/a&gt; . Правильное исправление зависит от первоначального намерения автора и требует решения в каждом конкретном случае. Обычно конфликт имен является непреднамеренным, и лучшее решение - переименовать импортированный тип. Если целью было расширение импортируемого типа, вместо этого следует написать правильное расширение модуля.</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">В TypeScript 3.7 компилятор сам воспользуется этой функцией, поэтому сгенерированные файлы &lt;code&gt;.d.ts&lt;/code&gt; также будут выдавать методы доступа &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">В TypeScript 3.7 компилятор воспользуется преимуществами этой функции, чтобы файлы &lt;code&gt;.d.ts&lt;/code&gt; , созданные из файлов &lt;code&gt;.js&lt;/code&gt; , могли надлежащим образом фиксировать как вызываемость, так и конструктивность функции, подобной классу.</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">В TypeScript 3.7 это идентифицируется как вероятная ошибка:</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">В TypeScript 3.7 при открытии проекта с зависимостями TypeScript автоматически использует исходные &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; . Это означает, что проекты, использующие ссылки на проекты, теперь будут видеть улучшенные возможности редактирования, в которых семантические операции актуальны и &amp;laquo;просто работают&amp;raquo;. Вы можете отключить это поведение с помощью параметра компилятора &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; , который может быть подходящим при работе в очень больших проектах, где это изменение может повлиять на производительность редактирования.</target>
        </trans-unit>
        <trans-unit id="f35647c7752475abd065982be5bc1b280eb87d72" translate="yes" xml:space="preserve">
          <source>In TypeScript 4.1, we added the ability to disable the special-casing where a filename would trigger type acquisition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">В TypeScript или ES6 ключевое слово &lt;code&gt;import&lt;/code&gt; служит той же цели:</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">В TypeScript декларация создает сущности как минимум в одной из трех групп:пространство имен,тип или значение.Объявления,создающие пространства имен,создают пространство имен,которое содержит имена,доступ к которым осуществляется с помощью точечной нотации.Объявления,создающие типы,делают именно это:они создают тип,который виден с объявленной формой и связан с заданным именем.Наконец,декларации,создающие значения,создают значения,которые видны в выходном JavaScript.</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">В TypeScript и &lt;code&gt;undefined&lt;/code&gt; , и &lt;code&gt;null&lt;/code&gt; фактически имеют свои собственные типы с именами &lt;code&gt;undefined&lt;/code&gt; и &lt;code&gt;null&lt;/code&gt; соответственно. Как и &lt;code&gt;void&lt;/code&gt; , сами по себе они не особо полезны:</target>
        </trans-unit>
        <trans-unit id="376a74b14286aaed0718f841b6819ef69ddf714d" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">В TypeScript предполагается, что каждый параметр требуется функции. Это не означает, что ей нельзя присвоить значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , скорее, когда функция вызывается, компилятор проверяет, предоставил ли пользователь значение для каждого параметра. Компилятор также предполагает, что эти параметры - единственные параметры, которые будут переданы функции. Короче говоря, количество аргументов, передаваемых функции, должно соответствовать количеству параметров, ожидаемых функцией.</target>
        </trans-unit>
        <trans-unit id="740a107698ee1408e32efe4710e0a388e20d2757" translate="yes" xml:space="preserve">
          <source>In TypeScript, it&amp;rsquo;s better to think of a type as a &lt;em&gt;set of values&lt;/em&gt; that share something in common. Because types are just sets, a particular value can belong to &lt;em&gt;many&lt;/em&gt; sets at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">В TypeScript, как и в ECMAScript 2015, любой файл, содержащий &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;export&lt;/code&gt; верхнего уровня, считается модулем. И наоборот, файл без каких- либо деклараций &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;export&lt;/code&gt; верхнего уровня рассматривается как сценарий, содержимое которого доступно в глобальной области (и, следовательно, также и для модулей).</target>
        </trans-unit>
        <trans-unit id="5a8756023ca1bc1f9c910f749b9c017f2449d68f" translate="yes" xml:space="preserve">
          <source>In TypeScript, objects are &lt;em&gt;not&lt;/em&gt; of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">В TypeScript есть несколько мест,где типовой вывод используется для предоставления информации о типе при отсутствии явной типовой аннотации.Например,в этом коде</target>
        </trans-unit>
        <trans-unit id="f94b6ab9fb3640d8233848ba38c368f3d8f60f94" translate="yes" xml:space="preserve">
          <source>In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the &lt;code&gt;string&lt;/code&gt; set or the &lt;code&gt;number&lt;/code&gt; set? It simply belongs to the &lt;em&gt;union&lt;/em&gt; of those sets: &lt;code&gt;string | number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01387e736054bef643d83587b4cbec5e0463e320" translate="yes" xml:space="preserve">
          <source>In TypeScript, union types are untagged. In other words, they are not discriminated unions like &lt;code&gt;data&lt;/code&gt; in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">В TypeScript мы также можем установить значение, которое будет присвоено параметру, если пользователь его не предоставит или если вместо него пользователь передаст значение &lt;code&gt;undefined&lt;/code&gt; . Они называются параметрами, инициализированными по умолчанию. Возьмем предыдущий пример и по умолчанию выберем фамилию &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">В TypeScript можно использовать общие объектно-ориентированные шаблоны.Одним из самых фундаментальных паттернов в классовом программировании является возможность расширения существующих классов для создания новых с использованием наследования.</target>
        </trans-unit>
        <trans-unit id="e8e346034f4b9c87e315e751122dc5fbf7c51de0" translate="yes" xml:space="preserve">
          <source>In TypeScript, when you reference a &lt;code&gt;const enum&lt;/code&gt; member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">В TypeScript эти аргументы можно собрать вместе в переменную:</target>
        </trans-unit>
        <trans-unit id="a2921849633d9d452ad28f4123936c20449f9b7e" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can import a &lt;em&gt;type&lt;/em&gt; and then subsequently export it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">В TypeScript вы можете смоделировать это с помощью конструкции &lt;code&gt;export =&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27303aa11138b00840e8f1322a88fdb13ab539ac" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, TypeScript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">В файле &lt;code&gt;.js&lt;/code&gt; Typescript понимает формат модуля CommonJS. Назначения для &lt;code&gt;exports&lt;/code&gt; и &lt;code&gt;module.exports&lt;/code&gt; распознаются как экспортные объявления. Точно так же вызовы функции &lt;code&gt;require&lt;/code&gt; распознаются как импорт модуля. Например:</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">В файле &lt;code&gt;.js&lt;/code&gt; компилятор определяет свойства на основе присвоений свойств внутри тела класса. Тип свойства - это тип, указанный в конструкторе, если он не определен там, или тип в конструкторе не определен или равен null. В этом случае тип представляет собой объединение типов всех правых значений в этих присвоениях. Всегда предполагается, что свойства, определенные в конструкторе, существуют, тогда как свойства, определенные только в методах, средствах получения или установки, считаются необязательными.</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">В файле &lt;code&gt;.js&lt;/code&gt; типы часто можно вывести так же, как в файлах &lt;code&gt;.ts&lt;/code&gt; . Аналогичным образом, когда типы не могут быть выведены, их можно указать с помощью JSDoc так же, как аннотации типов используются в файле &lt;code&gt;.ts&lt;/code&gt; . Как и &lt;code&gt;--noImplicitAny&lt;/code&gt; , --noImplicitAny выдает ошибки в тех местах, где компилятор не может определить тип. (За исключением открытых объектных литералов; подробности см. Ниже.)</target>
        </trans-unit>
        <trans-unit id="25a5bd4d9bac97fbf88351aa757a14e4470bc35e" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred. When types can&amp;rsquo;t be inferred, they can be specified using JSDoc syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">В файле &lt;code&gt;.ts&lt;/code&gt; литерал объекта, который инициализирует объявление переменной, передает свой тип объявлению. Не могут быть добавлены новые члены, не указанные в исходном литерале. Это правило ослаблено в файле &lt;code&gt;.js&lt;/code&gt; ; литералы объектов имеют открытый тип (подпись индекса), который позволяет добавлять и искать свойства, которые не были определены изначально. Например:</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">В операторе &lt;code&gt;for...in&lt;/code&gt; для объекта универсального типа &lt;code&gt;T&lt;/code&gt; предполагаемый тип переменной итерации ранее был &lt;code&gt;keyof T&lt;/code&gt; , но теперь - &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; . (Другими словами, подмножество &lt;code&gt;keyof T&lt;/code&gt; , которое включает только строковые значения.)</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">В выражении функции или стрелочной функции без аннотации возвращаемого типа, если функция не имеет операторов &lt;code&gt;return&lt;/code&gt; или только операторов &lt;code&gt;return&lt;/code&gt; с выражениями типа &lt;code&gt;never&lt;/code&gt; , и если конечная точка функции недостижима (как определено анализом потока управления) , предполагаемый тип возвращаемого значения для функции - &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">В функции с явной аннотацией типа &lt;code&gt;never&lt;/code&gt; return все операторы &lt;code&gt;return&lt;/code&gt; (если есть) должны иметь выражения типа &lt;code&gt;never&lt;/code&gt; , а конечная точка функции не должна быть достижимой.</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">В сопоставленном типе &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; каждый тип строкового литерала в &lt;code&gt;K&lt;/code&gt; представляет свойство с именем строки, каждый числовой тип литерала в &lt;code&gt;K&lt;/code&gt; представляет свойство с числовым именем, а каждый уникальный тип символа в &lt;code&gt;K&lt;/code&gt; представляет свойство с уникальным именем символа. Кроме того, если &lt;code&gt;K&lt;/code&gt; включает &lt;code&gt;string&lt;/code&gt; типа , вводится подпись индекса строки, а если &lt;code&gt;K&lt;/code&gt; включает &lt;code&gt;number&lt;/code&gt; типа , вводится подпись числового индекса.</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">В некотором смысле оператор утверждения с определенным присваиванием является двойником ненулевого оператора утверждения (в котором &lt;em&gt;выражения&lt;/em&gt; после фиксируются с помощью &lt;code&gt;!&lt;/code&gt; ), Который мы также могли бы использовать в примере.</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">В аналогичном примере мы можем захотеть переместить общий параметр в качестве параметра всего интерфейса. Это позволяет нам увидеть, какой тип (ы) мы являемся общим (например, &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; а не только &lt;code&gt;Dictionary&lt;/code&gt; ). Это делает параметр типа видимым для всех остальных членов интерфейса.</target>
        </trans-unit>
        <trans-unit id="f73ef161e383c012e8b216e70c23095705c0088c" translate="yes" xml:space="preserve">
          <source>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">Помимо загрузчиков модулей &lt;code&gt;AMD&lt;/code&gt; и &lt;code&gt;CommonJS&lt;/code&gt; , TypeScript теперь поддерживает порождающие модули &lt;code&gt;UMD&lt;/code&gt; ( &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt; ) и форматы &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; модулей.</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">Помимо &lt;code&gt;Partial&lt;/code&gt; , сопоставленные типы могут выражать множество полезных преобразований типов:</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">В дополнение к шаблонам композиции,подобным выше,этот новый вывод об общих конструкторах означает,что функции,которые работают с компонентами классов в некоторых библиотеках UI,таких как React,могут более корректно работать с общими компонентами классов.</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">Помимо создания объекта с именами свойств для членов, члены числовых перечислений также получают &lt;em&gt;обратное сопоставление&lt;/em&gt; значений перечисления с именами перечислений. Например, в этом примере:</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">В дополнение к общим интерфейсам,мы также можем создавать общие классы.Обратите внимание,что невозможно создать общие перечисления и пространства имен.</target>
        </trans-unit>
        <trans-unit id="ca19e30943988803be9117e262453a87e81dfc67" translate="yes" xml:space="preserve">
          <source>In addition to that, Babel cannot create &lt;code&gt;.d.ts&lt;/code&gt; files for your TypeScript which can make it harder to work with your project if it is a library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">В дополнение к существующей поддержке TypeScript для украшения деклараций &lt;code&gt;export&lt;/code&gt; , члены модуля также могут быть экспортированы с использованием отдельных экспортных деклараций, при необходимости указывая разные имена для экспорта с помощью предложений &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">В дополнение к шаблону внутренних классов,вы также можете быть знакомы с JavaScript практикой создания функции,а затем расширения функции путем добавления свойств в функцию.TypeScript использует слияние деклараций для построения таких определений безопасным для типов способом.</target>
        </trans-unit>
        <trans-unit id="87ddb0a5f5f96059703ab579dd4aebc339c8a186" translate="yes" xml:space="preserve">
          <source>In addition to unions, TypeScript also has intersections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">В дополнение к определяемым пользователем символам,существуют известные встроенные символы.Встроенные символы используются для представления внутреннего поведения языка.</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">Кроме того, в некоторых случаях сущности &lt;em&gt;неявно&lt;/em&gt; доступны только для чтения:</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">Во всех остальных случаях член переписи считается вычисленным.</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">В случаях, когда компилятор не может исключить &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , вы можете использовать оператор утверждения типа, чтобы вручную удалить их. Синтаксис постфиксный &lt;code&gt;!&lt;/code&gt; : &lt;code&gt;identifier!&lt;/code&gt; удаляет &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; из типа &lt;code&gt;identifier&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="772971872a07a06b821a02e99558860d312742f3" translate="yes" xml:space="preserve">
          <source>In cases where you don&amp;rsquo;t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use &lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">В более ранних версиях TypeScript мы обобщали отображаемые типы, чтобы по-разному работать с типами, подобными массивам. Это означало, что сопоставленный тип, такой как &lt;code&gt;Boxify&lt;/code&gt; , мог работать как с массивами, так и с кортежами.</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">В точных терминах, то &lt;code&gt;--strict&lt;/code&gt; опция устанавливает по &lt;em&gt;умолчанию&lt;/em&gt; значения параметров компилятора , перечисленных выше. Это означает, что все еще можно индивидуально контролировать параметры. Например,</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">В расширенной оговорке</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">Вызовы функций</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">В общем, для перехода репо с использованием относительных модулей требуется не так уж много. Просто поместите файл &lt;code&gt;tsconfig.json&lt;/code&gt; в каждый подкаталог данной родительской папки и добавьте &lt;code&gt;reference&lt;/code&gt; на эти файлы конфигурации, чтобы они соответствовали предполагаемому распределению уровней программы. Вам нужно будет либо установить &lt;code&gt;outDir&lt;/code&gt; в явную подпапку выходной папки, либо установить &lt;code&gt;rootDir&lt;/code&gt; в общий корень всех папок проекта.</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">В экземплярах дистрибутивного условного типа &lt;code&gt;T extends U ? X : Y&lt;/code&gt; , ссылки на &lt;code&gt;T&lt;/code&gt; в условном типе разрешаются к отдельным компонентам типа объединения (т. Е. &lt;code&gt;T&lt;/code&gt; относится к отдельным компонентам &lt;em&gt;после того,&lt;/em&gt; как условный тип распределяется по типу объединения). Кроме того, ссылки на &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;X&lt;/code&gt; имеют дополнительное ограничение параметра типа &lt;code&gt;U&lt;/code&gt; (т. Е. &lt;code&gt;T&lt;/code&gt; считается присваиваемым &lt;code&gt;U&lt;/code&gt; в &lt;code&gt;X&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">В таких языках, как C # и Java, одним из основных инструментов в наборе инструментов для создания повторно используемых компонентов являются &lt;em&gt;обобщения&lt;/em&gt; , то есть возможность создавать компонент, который может работать с множеством типов, а не с одним. Это позволяет пользователям использовать эти компоненты и использовать свои собственные типы.</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">В большинстве случаев перечисления - вполне допустимое решение. Однако иногда требования более жесткие. Чтобы избежать затрат на дополнительный сгенерированный код и дополнительное косвенное обращение при доступе к значениям перечисления, можно использовать перечисления &lt;code&gt;const&lt;/code&gt; . Перечисления const определяются с помощью модификатора &lt;code&gt;const&lt;/code&gt; в наших перечислениях:</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">В большинстве случаев вывод типа прост. В следующих разделах мы исследуем некоторые нюансы того, как выводятся типы.</target>
        </trans-unit>
        <trans-unit id="8275babe4b4f5b3a44f6ddcca26a506ab31a4496" translate="yes" xml:space="preserve">
          <source>In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like &amp;lsquo;Find All References&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4fbd345bfdf906a9f48090d5a75c3c53095ff7" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Dog&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Pet&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">В языках с номинальной типизацией, таких как C # или Java, эквивалентный код будет ошибкой, поскольку класс &lt;code&gt;Person&lt;/code&gt; явно не описывает себя как реализующий интерфейс &lt;code&gt;Named&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">В более старых версиях TypeScript псевдонимы типов не могли быть расширены или реализованы (а также не могли расширять / реализовывать другие типы). Начиная с версии 2.7, псевдонимы типов могут быть расширены путем создания нового типа пересечения, например &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">В более старых версиях, машинопись бы вывести пустой тип объекта ( &lt;code&gt;{}&lt;/code&gt; ) , когда выводя от других переменных типа , как &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">Чтобы компилятор мог выбрать правильный тип проверки, он следует процессу, аналогичному базовому JavaScript. Он просматривает список перегрузки и, продолжая первую перегрузку, пытается вызвать функцию с предоставленными параметрами. Если он находит совпадение, он выбирает эту перегрузку как правильную перегрузку. По этой причине принято упорядочивать перегрузки от наиболее конкретных до наименее конкретных.</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">Чтобы гарантировать, что функция никогда не может потенциально возвращать &lt;code&gt;undefined&lt;/code&gt; или эффективно возвращаться из всех путей кода, TypeScript требовался некоторый синтаксический сигнал - либо &lt;code&gt;return&lt;/code&gt; либо &lt;code&gt;throw&lt;/code&gt; в конце функции. Таким образом, пользователи обнаружили, что &lt;code&gt;return&lt;/code&gt; свои функции отказа.</target>
        </trans-unit>
        <trans-unit id="a5553c9db2df72c8e161b64c0bb7751b40bdbd3c" translate="yes" xml:space="preserve">
          <source>In order to provide rich debugging tools and crash reports which make sense to developers, TypeScript supports emitting additional files which conform to the JavaScript Source Map standards.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
