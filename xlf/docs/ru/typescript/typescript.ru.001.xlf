<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2019 Microsoft</target>
        </trans-unit>
        <trans-unit id="30e2637a4121a97d6d63991f19ff28a13222931e" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2020 Microsoft</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbdbcedb34093e56c430453aeba639196dc102e" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2021 Microsoft</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="translated">&amp;laquo;Декларации по умолчанию&amp;raquo; позволяют инициализаторам, которые ссылаются на объявленное имя в левой части логического или:</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="translated">&amp;laquo;Можно&amp;raquo; и &amp;laquo;Не делать&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0a462d0a363472f89aab32695c02164466ca6a9c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a7a19458753d64363353ed730635e775ee136020" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="77f022a953afe741cc802b7587833dd3652f325c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;./dist/main.js&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dbbfebc33b03e9a8e299b3392e1bc5e89f27da" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;main.d.ts&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="translated">'classic' - правила разрешения модуля, используемые компилятором TypeScript до 1.6</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="translated">'node' - разрешение узлового модуля</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="translated">'package.json' имеет &lt;strong&gt;'типов'&lt;/strong&gt; поле&amp;raquo;./lib/typescript.d.ts' , что ссылки на &quot; node_modules / машинопись / Библиотека / typescript.d.ts.</target>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-dependency /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-module /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;ссылка lib = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="translated">&amp;lt;ссылка no-default-lib = &quot;true&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference path = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference types = &quot;...&quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="translated">&amp;lt;reference&amp;gt; -ing модуль</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes" xml:space="preserve">
          <source>(More) Recursive Type Aliases</source>
          <target state="translated">(Подробнее) Рекурсивные псевдонимы типов</target>
        </trans-unit>
        <trans-unit id="9c306edcd7029e4d6802fe5b57d73e67c702ff8a" translate="yes" xml:space="preserve">
          <source>(optional) Edit your package.json to reference the types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes" xml:space="preserve">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="translated">* Примечание: вы можете указать фабричную функцию JSX для использования при нацеливании на реакцию JSX &lt;code&gt;--jsxFactory&lt;/code&gt; опцией --jsxFactory (по умолчанию &lt;code&gt;React.createElement&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fb61c992209f91996318a06868699d18ec06bb49" translate="yes" xml:space="preserve">
          <source>./dist/index.d.ts</source>
          <target state="translated">./dist/index.d.ts</target>
        </trans-unit>
        <trans-unit id="416b42ed62b541999eb78a0fd168b7c144ee65ce" translate="yes" xml:space="preserve">
          <source>./dist/main.d.ts</source>
          <target state="translated">./dist/main.d.ts</target>
        </trans-unit>
        <trans-unit id="7d54547932b925cb04c81035e7676fa6182e3b7e" translate="yes" xml:space="preserve">
          <source>./main/main.d.ts</source>
          <target state="translated">./main/main.d.ts</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes" xml:space="preserve">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes" xml:space="preserve">
          <source>1 - greeting: Mandatory string</source>
          <target state="translated">1-приветствие:Обязательная строка</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes" xml:space="preserve">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="translated">2-продолжительность Дополнительная продолжительность (в миллисекундах)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes" xml:space="preserve">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="translated">3 - цвет: необязательная строка, например, '# ff00ff'</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes" xml:space="preserve">
          <source>3.7 API Changes</source>
          <target state="translated">3.7 API Изменения</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes" xml:space="preserve">
          <source>3.7 Breaking Changes</source>
          <target state="translated">3,7 Изменения</target>
        </trans-unit>
        <trans-unit id="f93d8407b2959853084d09f0c851bf5d0e08f0b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8964ae98596ed53789c768e5ec7b3994c6c70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#alwaysStrict&quot;&gt;&lt;code&gt;alwaysStrict&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictNullChecks&quot;&gt;&lt;code&gt;strictNullChecks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictBindCallApply&quot;&gt;&lt;code&gt;strictBindCallApply&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictFunctionTypes&quot;&gt;&lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictPropertyInitialization&quot;&gt;&lt;code&gt;strictPropertyInitialization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitAny&quot;&gt;&lt;code&gt;noImplicitAny&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitThis&quot;&gt;&lt;code&gt;noImplicitThis&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eacc0bc20a210ca7f562d1dcc3f9914ec788f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badedc9fbd49fc64159ae3e3285103c2215b1231" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2bd83df453fbfdf0395a78cb8212339a6e9800" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#constructor&quot;&gt;&lt;code&gt;@class&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#constructor&quot;&gt;&lt;code&gt;@constructor&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5c6fc0beafcad83d2b6b97d85ab7a3f4ec9e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#declarationDir&quot;&gt;&lt;code&gt;declarationDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd74cd4c9f8f30ddea5b3296700cb66d526a7e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#extends&quot;&gt;&lt;code&gt;@extends&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#extends&quot;&gt;&lt;code&gt;@augments&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd29cc36234c4eac24bd08b0eb7f3d7d4f112ffb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddac993a02e1f8c405d537e647fcf6c8af40be8d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95311b8db4676f55e1e9cc9e97adb0d1405c5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bdfa25010df7871fccc20c32ead1f8e700ec6c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700909c3f1adfc70abc84a37875bd1c7e5f1ffab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12ed2ab3db736413d8125bf80d66ce2f131642f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsdoc-property-modifiers&quot;&gt;Property Modifiers&lt;/a&gt;&lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, &lt;code&gt;@protected&lt;/code&gt;, &lt;code&gt;@readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc6cd42c46b121f604de4e278b03e63d3fc187f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617124b58852d620746b0e2268ef8092a6b18811" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff88d2e32507d449d9725602353414158333ea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56648998908a0672096f6bf781cb50cdcab9a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f442113fa72aea1d2a309e3551e6bdb58d220c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40f8e7b81466e628cd1d26c0f4d604250df0117" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f38543a8c287d6b6c4baaf9485cbf9c6434afc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841ccc42e3622be2086b39b4485fddb5faa8b194" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9204a446187a483cf98a00946768c714f4a03c75" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#param-and-returns&quot;&gt;&lt;code&gt;@param&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#param-and-returns&quot;&gt;&lt;code&gt;@arg&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#param-and-returns&quot;&gt;&lt;code&gt;@argument&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e3591c948d832fb565ad2a3dca7f37ba524a2b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#param-and-returns&quot;&gt;&lt;code&gt;@returns&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#param-and-returns&quot;&gt;&lt;code&gt;@return&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="translated">&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;Как упоминалось выше&lt;/a&gt; , TypeScript 3.7 испускает &lt;code&gt;.d.ts&lt;/code&gt; &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; в файлах .d.ts, которые могут вызывать критические изменения для потребителей в более старых версиях TypeScript, таких как 3.5 и более ранние. Пользователи TypeScript 3.6 не пострадают, так как эта версия была рассчитана на будущее для этой функции.</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 также представил &amp;laquo;Генераторы&amp;raquo;&lt;/a&gt; , которые представляют собой функции, которые можно использовать для получения частичных результатов вычислений через интерфейс &lt;code&gt;Iterator&lt;/code&gt; и ключевое слово &lt;code&gt;yield&lt;/code&gt; . Генераторы также могут внутренне делегировать вызовы другому итерируемому объекту через &lt;code&gt;yield *&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 представил &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , который представляет собой объект, который предоставляет три метода: &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;throw&lt;/code&gt; в соответствии со следующим интерфейсом:</target>
        </trans-unit>
        <trans-unit id="b6333d998c229faa742c2259393328f8ce5717b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.stroustrup.com/4th.html&quot;&gt;The C++ Programming Language&lt;/a&gt; is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: &lt;code&gt;x: string&lt;/code&gt; instead of &lt;code&gt;string x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c522a5a7799016630add0cfdae778f7d5c18f87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/DOM&quot;&gt;DOM&lt;/a&gt; definitions - &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc45d0d18af813393a85ab4e94d2f14b2851e9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Data_structures&quot;&gt;See the MDN page for more detail&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4092c59537e7cf28a262cdff3ec1a8a7b377cf2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;ECMAScript strict&lt;/a&gt; mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; - это встраиваемый XML-подобный синтаксис. Он предназначен для преобразования в допустимый JavaScript, хотя семантика этого преобразования зависит от реализации. JSX приобрел популярность с фреймворком &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; , но с тех пор видел и другие реализации. TypeScript поддерживает встраивание, проверку типов и компиляцию JSX непосредственно в JavaScript.</target>
        </trans-unit>
        <trans-unit id="199e55c49a5efe4f7eea9b852e615fbd30d3d039" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Microsoft/typescript-styled-plugin&quot;&gt;typescript-styled-plugin&lt;/a&gt; &amp;mdash; Provides CSS linting inside template strings .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05658a1d8a717f441a947f4b3f5873629b2746f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/ts-graphql-plugin&quot;&gt;ts-graphql-plugin&lt;/a&gt; &amp;mdash; Provides validation and auto-completion inside GraphQL query template strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1d8571473f401bda993ef5f95107455716e497" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/typescript-eslint-language-service&quot;&gt;typescript-eslint-language-service&lt;/a&gt; &amp;mdash; Provides eslint error messaging and fix-its inside the compiler&amp;rsquo;s output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Типы в &lt;code&gt;lib.dom.d.ts&lt;/code&gt; были обновлены&lt;/a&gt; . Эти изменения в основном являются изменениями правильности, связанными с допустимостью значений NULL, но влияние в конечном итоге будет зависеть от вашей кодовой базы.</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Модули UMD&lt;/a&gt; проверяют наличие среды загрузчика модулей. Это легко различимый узор, который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="4501968243cb90a3d84dcd45006c29d533b0884d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xialvjun/ts-sql-plugin#readme&quot;&gt;ts-sql-plugin&lt;/a&gt; &amp;mdash; Adds SQL linting with a template strings SQL builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6483def0fc8c609e15c97336fa075e9de577db1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs&quot;&gt;With TypeScript 3.7&lt;/a&gt;, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279d25c3bce3f4af13a20f8e97e6c8096c2c8cff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;declaration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ вернуться наверх&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; : означает то же имя без изменений, поэтому map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; означает имя модуля с добавленным префиксом &quot;сгенерировано&quot;, поэтому map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="translated">&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; - хорошая идея всякий раз, когда вы пишете новый код - вы можете быть уверены, что не напишете по ошибке нетипизированный код. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; упрощает обновление кода в работающем веб-приложении.</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; определяет список &lt;em&gt;корней&lt;/em&gt; , содержимое которых, как ожидается, будет объединено во время выполнения. Итак, следуя нашему примеру, файл &lt;code&gt;tsconfig.json&lt;/code&gt; должен выглядеть так:</target>
        </trans-unit>
        <trans-unit id="60134d0ac283a5c3d28bf080abb92e5b19e8fb5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; matches any directory nested to any level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; рекурсивно соответствует любому подкаталогу</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; соответствует нулю или более символов (исключая разделители каталогов)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; бинарные операторы с постоянными выражениями перечисления в качестве операндов</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt; : удаляет выходные данные указанных проектов (можно комбинировать с &lt;code&gt;--dry&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; и &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="translated">&lt;code&gt;--declarationDir&lt;/code&gt; позволяет создавать файлы объявлений в другом месте, чем файлы JavaScript.</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="translated">&lt;code&gt;--dry&lt;/code&gt; : показывает, что будет сделано, но на самом деле ничего не строит</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="translated">&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; позволяет &lt;em&gt;только&lt;/em&gt; создавать файлы объявлений; &lt;code&gt;.jsx&lt;/code&gt; вывода &lt;code&gt;.js&lt;/code&gt; / .jsx будет пропущена с этим флагом. Флаг полезен, когда генерация вывода &lt;code&gt;.js&lt;/code&gt; обрабатывается другим транспилером, например Babel.</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; : действовать так, как будто все проекты устарели</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; улучшения</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--init&lt;/code&gt; параметр командной строки</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; и &lt;code&gt;inlineSources&lt;/code&gt; командной строки inlineSources</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; заставляет файлы исходной карты записываться в созданных файлах &lt;code&gt;.js&lt;/code&gt; , а не в независимый файл &lt;code&gt;.js.map&lt;/code&gt; . &lt;code&gt;--inlineSources&lt;/code&gt; позволяет дополнительно встраивать исходный файл &lt;code&gt;.ts&lt;/code&gt; в файл &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--newLine&lt;/code&gt; параметр командной строки</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; параметр командной строки</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; вывод по умолчанию</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; параметр командной строки</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; указывает входной каталог, который будет отражаться в выходных данных, а не вычислять его.</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; переключает в новый режим строгой нулевой проверки.</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--target ESNext&lt;/code&gt; нацелен на последние поддерживаемые &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;функции, предлагаемые ES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; предлагает удобный способ понять, как модули были разрешены компилятором.</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt; : выводит подробный журнал, чтобы объяснить, что происходит (может быть объединен с любым другим флагом)</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; реализация компилятор полагается на &lt;code&gt;fs.watch&lt;/code&gt; и &lt;code&gt;fs.watchFile&lt;/code&gt; обеспечивается узлом, оба из этих методов имеет преимущества и недостатки.</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; : режим наблюдения (не может сочетаться с любым флагом, кроме &lt;code&gt;--verbose&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="translated">&lt;code&gt;-noEmitOnError&lt;/code&gt; параметр командной строки</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; Файлы .js теперь разрешены в качестве входных данных для &lt;code&gt;tsc&lt;/code&gt; . Компилятор TypeScript проверяет входные файлы &lt;code&gt;.js&lt;/code&gt; на наличие синтаксических ошибок и выдает допустимый вывод на основе флагов &lt;code&gt;--target&lt;/code&gt; и &lt;code&gt;--module&lt;/code&gt; . Вывод также можно комбинировать с другими файлами &lt;code&gt;.ts&lt;/code&gt; . Исходные карты по-прежнему создаются для файлов &lt;code&gt;.js&lt;/code&gt; , как и &lt;code&gt;.ts&lt;/code&gt; файлов .ts .</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; Файлы .js по-прежнему проверяются, чтобы убедиться, что они включают только стандартные функции ECMAScript; аннотации типов разрешены только в файлах &lt;code&gt;.ts&lt;/code&gt; и помечаются как ошибки в файлах &lt;code&gt;.js&lt;/code&gt; . Комментарии JSDoc могут использоваться для добавления некоторой информации о типе в ваш код JavaScript. Дополнительные сведения о поддерживаемых конструкциях JSDoc см. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;В документации&lt;/a&gt; поддержки JSDoc.</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; в файлах TypeScript</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; информирует компилятор о зависимости модуля, отличного от TS, который необходимо ввести в вызове require результирующего модуля.</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; информирует компилятор о зависимости модуля, отличного от TS, который необходимо ввести в вызове require результирующего модуля; однако не было возможности использовать этот модуль в коде TS.</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; справочные директивы</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; загружаем модуль</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает &lt;code&gt;&quot;main&quot;&lt;/code&gt; свойство)</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает свойство &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает &lt;code&gt;&quot;main&quot;&lt;/code&gt; свойство)</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает свойство &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (если он указывает свойство &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает &lt;code&gt;&quot;main&quot;&lt;/code&gt; свойство)</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (если он указывает свойство &lt;code&gt;&quot;types&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; соответствует любому одному символу (исключая разделители каталогов)</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; похож на &lt;code&gt;@typedef&lt;/code&gt; , но указывает тип функции вместо типа объекта:</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@class&lt;/code&gt; (или &lt;code&gt;@constructor&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d9926a14ef97939b4b2a7dc3f406f497b651cfe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@const&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/19672&quot;&gt;issue #19672&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; (или &lt;code&gt;@augments&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7af159c170df9572411a5fc0ca1c714e2ddcfe48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@inheritdoc&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23215&quot;&gt;issue #23215&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e519c580e10173da9247b85e7b08d470854d616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@memberof&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/7237&quot;&gt;issue #7237&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; (или &lt;code&gt;@arg&lt;/code&gt; , или &lt;code&gt;@argument&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; допускает аналогичный синтаксис для одноразовых спецификаций типов. Обратите внимание, что имена вложенных свойств должны иметь префикс с именем параметра:</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; и &lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; использует тот же синтаксис типа, что и &lt;code&gt;@type&lt;/code&gt; , но добавляет имя параметра. Параметр также можно объявить необязательным, заключив имя в квадратные скобки:</target>
        </trans-unit>
        <trans-unit id="19809d43310d525637902c3117defc38e456422e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@private&lt;/code&gt; means that a property can only be used within the containing class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438ac9ff15896d350daae76a2cc4baf6653d6792" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@protected&lt;/code&gt; means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd4c7a40333b2bbb8dde7e82e8932abca84df9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@public&lt;/code&gt; is always implied and can be left off, but means that a property can be reached from anywhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@returns&lt;/code&gt; (или &lt;code&gt;@return&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; может указывать тип объединения - например, что-то может быть строковым или логическим.</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; может использоваться для определения сложных типов. Аналогичный синтаксис работает с &lt;code&gt;@param&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; , &lt;code&gt;@callback&lt;/code&gt; и &lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; и &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae124c1c173e712edc3d1ad0a19078f6a3f6f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@yields&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23857&quot;&gt;issue #23857&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced52b9dec509889f60aa7c87448b485409b7a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; , &lt;code&gt;CommonJs&lt;/code&gt; , &lt;code&gt;UMD&lt;/code&gt; , &lt;code&gt;System&lt;/code&gt; или &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ba9d9566bfec912aed9fbf81db9fbc3371b306b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;never&lt;/code&gt; assignability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRLF&lt;/code&gt; или &lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Classic&lt;/code&gt; или &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7c57db6dc6560c30e85fd334a8c39710cd2a1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Combined&lt;/code&gt; has two properties, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so &lt;code&gt;Conflicting.a: number &amp;amp; string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d793b8dd668dd2130ea7391dfeaa61bed9c3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommonJS&lt;/code&gt; (default if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES3&lt;/code&gt; or &lt;code&gt;ES5&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e28ff360e77827a000f56ca84a256c62cc3228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2017&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2017&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="e44dc9aa61a49ecca89f1df117b8525c59bdcc98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2018&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2018&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="88589d0dd64cb35a2eed37b1a8b40cce5f9a53e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2019&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2019&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="12f37540cdb9c3492ed986234931fa1515ec2629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2020&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2020&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="5458962d81dee50f969981ff115b63eb43196cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt; (default),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; , &lt;code&gt;ES5&lt;/code&gt; или &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ffafcef9deaae4f4691bacf9ca573ae6ca0ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="91cc99c38cb2d95e5ad8900b70fbd04f54089424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551adb5b78d1804a795f54cee1a99ae987b9a8ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous, default for &lt;code&gt;target&lt;/code&gt;&lt;code&gt;ES6&lt;/code&gt; and higher),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd82edcb863935c74f3c96030d44feb854613265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; - Исключить из &lt;code&gt;T&lt;/code&gt; тех типов, которые назначаются на &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; - Извлечение из &lt;code&gt;T&lt;/code&gt; тех типов, которые назначаются на &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="translated">&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; - получить тип экземпляра типа функции конструктора.</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MapToPromise&lt;/code&gt; принимает тип &lt;code&gt;T&lt;/code&gt; , и когда этот тип является кортежем, таким как &lt;code&gt;Coordinate&lt;/code&gt; , преобразуются только числовые свойства. В &lt;code&gt;[number, number]&lt;/code&gt; есть два свойства с числовыми именами: &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; . Получив такой кортеж, &lt;code&gt;MapToPromise&lt;/code&gt; создаст новый кортеж, в котором свойства &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; являются &lt;code&gt;Promise&lt;/code&gt; исходного типа. Таким образом, результирующий тип &lt;code&gt;PromiseCoordinate&lt;/code&gt; заканчивается типом &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt; : только инструменты ( &lt;code&gt;tsc.exe&lt;/code&gt; , &lt;code&gt;lib.d.ts&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; : инструменты, указанные выше, а также задачи и цели MSBuild ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; , &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; и т. Д.)</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; - Исключить &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; из &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a15a098fe35b271129107f57ff56b0b96a908f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; и &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; Объявления Object.defineProperty в JavaScript</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; и &lt;code&gt;Readonly&lt;/code&gt; , как описано ранее, являются очень полезными конструкциями. Вы можете использовать их для описания некоторых общих процедур JS, например:</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; , только для &lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Record&lt;/code&gt; и &lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="translated">&lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Partial&lt;/code&gt; и &lt;code&gt;Pick&lt;/code&gt; гомоморфны, а &lt;code&gt;Record&lt;/code&gt; - нет. Один из признаков того, что &lt;code&gt;Record&lt;/code&gt; не гомоморфен, заключается в том, что для копирования свойств не требуется тип ввода:</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="translated">&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; - получить тип возвращаемого значения типа функции.</target>
        </trans-unit>
        <trans-unit id="555e1ab04d96fee8e1f7fce44305f90f1e1a16a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;System&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="4b99ac4ec7cc9b1967c0464330db6c92bcd93e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f596f26b3a4a06ed8796e22604a1d5460910d96c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]&lt;/code&gt;, plus the value of &lt;code&gt;outDir&lt;/code&gt; if one is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4e295b21aab254df399f343e9636cc32c7a1ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[T, T]&lt;/code&gt; is a subtype of &lt;code&gt;T[]&lt;/code&gt;. This is different than Haskell, where tuples are not related to lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283c19901d75227a4d28c2d33fc35dbe35af5585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;files&lt;/code&gt; is specified, otherwise &lt;code&gt;[&quot;**/*&quot;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; классы и методы</target>
        </trans-unit>
        <trans-unit id="0c68e4ae3e82bf905fa0d1105b6508f144823832" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; and &lt;code&gt;unknown&lt;/code&gt; are the same in terms of what is assignable to them, different in that &lt;code&gt;unknown&lt;/code&gt; is not assignable to anything except &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb1110b2f29a5b22fea8c7402e9b9f0d9e30b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; is contagious, too &amp;mdash; if you initialise a variable with an expression of type &lt;code&gt;any&lt;/code&gt;, the variable has type &lt;code&gt;any&lt;/code&gt; too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;asserts condition&lt;/code&gt; говорит, что все, что передается в параметр &lt;code&gt;condition&lt;/code&gt; должно быть истинным, если &lt;code&gt;assert&lt;/code&gt; возвращается (потому что в противном случае это вызовет ошибку). Это означает, что для остальной области это условие должно быть истинным. В качестве примера, используя это утверждение означает функцию мы &lt;em&gt;действительно&lt;/em&gt; поймать наш оригинальный &lt;code&gt;yell&lt;/code&gt; пример.</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; в целях ES6 (Node v4 +)</target>
        </trans-unit>
        <trans-unit id="e0839c98cf0c1b0d32a7dad40585aa624f84509b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt; extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; выполняет две другие функции:</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; затем возвращает функцию, которая передает свой аргумент через &lt;code&gt;f&lt;/code&gt; , а затем через &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; (полностью встроенные перечисления)</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; утверждения</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; объявления const</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; Объявления const - это еще один способ объявления переменных.</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; перечисления</target>
        </trans-unit>
        <trans-unit id="8980d3e09baee4979420c9636f8b832f951f2861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; доступен только при нацеливании на ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5892822e96ef4ecfe925031773afe23c1bf575ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; должна быть включена</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; экспорт по умолчанию действительно удобен. Например, такая библиотека, как jQuery, может иметь экспорт по умолчанию &lt;code&gt;jQuery&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; , который мы, вероятно, также импортируем под именем &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;jQuery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; экспорт по умолчанию также может быть просто значениями:</target>
        </trans-unit>
        <trans-unit id="fe376a04dc77749dab7c4dbd979df3cf8e5dd405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified directories will be checked less often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c871853d0e750f1e6eeaefa64d36be33f6fd2e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified files will be checked less often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288c5ada225ba27cfc87c34049e5392aaba3891d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; поддержку свойств в tsconfig.json</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="translated">&lt;code&gt;export *&lt;/code&gt; можно использовать для реэкспорта всего экспорта другого модуля. Это полезно для создания модулей, которые объединяют экспорт нескольких других модулей.</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; и &lt;code&gt;import = require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; - это новое свойство верхнего уровня в &lt;code&gt;tsconfig.json&lt;/code&gt; (наряду с &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;exclude&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , который принимает некоторый аргумент (типа &lt;code&gt;A&lt;/code&gt; ) и возвращает значение типа &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f22e56762e33c4799141e66037e37470d49b81a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; raises compiler errors about unreachable code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b17f3db39a076d6901d31237e6962658b321a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, unless &lt;code&gt;strict&lt;/code&gt; is set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;exclude&lt;/code&gt; из наследуемого файла конфигурации &lt;em&gt;перезаписывать&lt;/em&gt; файлы из базового файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="f14095026c89d29eb77a2786e83750935d903d15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every directory for changes several times a second at a fixed interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2d807f774a8f4511fd40887b6aa11dff8fd264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every file for changes several times a second at a fixed interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; перебирает итерируемый объект, вызывая свойство &lt;code&gt;Symbol.iterator&lt;/code&gt; объекта. Вот простой цикл &lt;code&gt;for..of&lt;/code&gt; для массива:</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; заявлений</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; , элементы Array Destructuring и Spread в выражениях Array, Call и New поддерживают &lt;code&gt;Symbol.iterator&lt;/code&gt; в ES5 / E3, если они доступны при использовании &lt;code&gt;--downlevelIteration&lt;/code&gt; , но могут использоваться в массиве, даже если он не определяет &lt;code&gt;Symbol.iterator&lt;/code&gt; во время выполнения или разработки.</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; утверждения</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; использует события файловой системы для уведомления об изменениях в файле / каталоге. Но это зависит от ОС, а уведомление не является полностью надежным и не работает должным образом во многих ОС. Также может быть ограничение на количество часов, которые могут быть созданы, например. linux, и мы могли бы довольно быстро исчерпать его с помощью программ, включающих большое количество файлов. Но поскольку здесь используются события файловой системы, цикл процессора не требует большого времени. Компилятор обычно использует &lt;code&gt;fs.watch&lt;/code&gt; для просмотра каталогов (например, исходных каталогов, включенных в файл конфигурации, каталогов, в которых не удалось выполнить разрешение модуля и т. Д.). Они могут обрабатывать недостающую точность при уведомлении об изменениях. Но рекурсивное наблюдение поддерживается только в Windows и OSX. Это означает, что нам нужно что-то, чтобы заменить рекурсивную природу в других ОС.</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; использует опрос и, следовательно, задействует циклы ЦП. Но это самый надежный механизм для получения обновленной информации о статусе файла / каталога. Компилятор обычно использует &lt;code&gt;fs.watchFile&lt;/code&gt; для просмотра исходных файлов, файлов конфигурации и отсутствующих файлов (ссылок на отсутствующие файлы), что означает, что использование ЦП зависит от количества файлов в программе.</target>
        </trans-unit>
        <trans-unit id="cab0e85250415c9a21a791aa821a62b01eec2290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. However, &lt;code&gt;fs.watchFile&lt;/code&gt; is the most reliable mechanism to get the update on the status of file/directory. The compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references). This means the CPU usage when using &lt;code&gt;fs.watchFile&lt;/code&gt; depends on number of files in the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , который принимает аргумент типа &lt;code&gt;B&lt;/code&gt; ( возвращаемый тип &lt;code&gt;f&lt;/code&gt; ) и возвращает значение типа &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; аксессоры, разрешенные в окружающих контекстах</target>
        </trans-unit>
        <trans-unit id="3124d2af4a7b268f86acefe54dcc4bd3f7d01f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import type&lt;/code&gt; is always guaranteed to be removed from your JavaScript, and tools like Babel can make better assumptions about your code via the &lt;code&gt;isolatedModules&lt;/code&gt; compiler flag. You can read more in the &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports&quot;&gt;3.8 release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; Поддержка в SystemJS</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; разрешен только при нацеливании на модули &lt;code&gt;ESNext&lt;/code&gt; и цели ECMAScript.</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; типы импорта</target>
        </trans-unit>
        <trans-unit id="c20e5c61459139d6cecacbbae3c9ad3e255d665c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; support wildcard characters to make glob patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; типа охранников</target>
        </trans-unit>
        <trans-unit id="58f962df495c2ad38d952726f96435f0a9c82665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot;&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot; | &quot;ownersAddress&quot;&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; полностью взаимозаменяем с &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt; . Разница в том, что если вы добавите в &lt;code&gt;Car&lt;/code&gt; еще одно свойство , например, &lt;code&gt;ownersAddress: string&lt;/code&gt; , то &lt;code&gt;keyof Car&lt;/code&gt; автоматически обновится до &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt; . И вы можете использовать &lt;code&gt;keyof&lt;/code&gt; в общих контекстах, таких как &lt;code&gt;pluck&lt;/code&gt; , где вы не можете заранее знать имена свойств. Это означает, что компилятор проверит, что вы передали правильный набор имен свойств для &lt;code&gt;pluck&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="translated">&lt;code&gt;keyof X&lt;/code&gt; - это объединение типов литералов, представляющих строковые, числовые и символьные свойства.</target>
        </trans-unit>
        <trans-unit id="a66b6fc8661361e20ef87ae35fc31efb3fbba84e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object[&quot;42&quot;]&lt;/code&gt;) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; и &lt;code&gt;T[K]&lt;/code&gt; взаимодействуют с индексными подписями. Тип параметра сигнатуры индекса должен быть &amp;laquo;строка&amp;raquo; или &amp;laquo;число&amp;raquo;. Если у вас есть тип с подписью индекса строки, &lt;code&gt;keyof T&lt;/code&gt; будет &lt;code&gt;string | number&lt;/code&gt; (а не только &lt;code&gt;string&lt;/code&gt; , поскольку в JavaScript вы можете получить доступ к свойству объекта либо с помощью строк ( &lt;code&gt;object['42'&lt;/code&gt; ]), либо чисел ( &lt;code&gt;object[42]&lt;/code&gt; )). А &lt;code&gt;T[string]&lt;/code&gt; - это просто тип подписи индекса:</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; и типы поиска</target>
        </trans-unit>
        <trans-unit id="9157c1d1156017222354fdad58f5ebf6388c0fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new concepts for variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; - два относительно новых типа объявления переменных в JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;Как мы упоминали ранее&lt;/a&gt; , &lt;code&gt;let&lt;/code&gt; в некоторых отношениях похожа на &lt;code&gt;var&lt;/code&gt; , но позволяет пользователям избегать некоторых распространенных ошибок, с которыми пользователи сталкиваются в JavaScript. &lt;code&gt;const&lt;/code&gt; - это расширение &lt;code&gt;let&lt;/code&gt; , предотвращающее повторное присвоение переменной.</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; поддержка</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; декларации</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; Объявления let имеют совершенно другое поведение при объявлении как часть цикла. Вместо того, чтобы просто вводить новую среду в сам цикл, эти объявления как бы создают новую область видимости для &lt;em&gt;каждой итерации&lt;/em&gt; . Поскольку это то, что мы в любом случае делали с нашим IIFE, мы можем изменить наш старый пример &lt;code&gt;setTimeout&lt;/code&gt; , чтобы просто использовать объявление &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; доступен только при настройке на ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; Объявления let , &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;var&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; или &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ключевое слово пространства имен</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; является подтипом и присваивается каждому типу.</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; также пригодится для написания конструктивных функций, например:</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; пригодится, когда необходимо установить &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; или &lt;code&gt;__proto__&lt;/code&gt; в конструкторе класса. Один из таких вариантов использования наследуется от &lt;code&gt;Error&lt;/code&gt; в NodeJS v4 и выше.</target>
        </trans-unit>
        <trans-unit id="1131c7832f64ced185a09c516621bf98a64dcb90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; , что полезно, если вы никогда не хотите забывать оператор &lt;code&gt;break&lt;/code&gt; между &lt;code&gt;case&lt;/code&gt; s в блоке &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;noImplicitAny&lt;/code&gt; : вызывает ошибку в выражениях и объявлениях с подразумеваемым &lt;code&gt;any&lt;/code&gt; типом.</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="translated">&lt;code&gt;noImplicitReturns&lt;/code&gt; , который не дает вам забыть вернуться в конце функции.</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; - это тип, представляющий непримитивный тип, то есть все, что не является &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; тип объекта</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="translated">&lt;code&gt;onEmitOnError&lt;/code&gt; : не выдавать выходные данные, если были обнаружены какие-либо ошибки.</target>
        </trans-unit>
        <trans-unit id="962f6f62ca17f25220b1453a992b090209f2d675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt; lets you declare how TypeScript should resolve an import in your &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="translated">&lt;code&gt;pet is Fish&lt;/code&gt; - это предикат нашего типа в этом примере. Предикат принимает форму имя &lt;code&gt;parameterName is Type&lt;/code&gt; , где имя &lt;code&gt;parameterName&lt;/code&gt; должно быть именем параметра из текущей сигнатуры функции.</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; с помощью &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a72fb1d0e76667fcc523f6bd09ef4ab9fea3ee72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Emit &lt;code&gt;.jsx&lt;/code&gt; files with the JSX unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="759693d33e6545513f3137d1a8e8eb2237a7bdde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Preserves all &lt;code&gt;import&lt;/code&gt; statements whose values or types are never used. This can cause imports/side-effects to be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b17c7abd7c031db77146a2cd28f258bded77d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priorityPollingInterval&lt;/code&gt;: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45719cae5b4f1126bbe06a22e869a53683b4dee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsx&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="2ff9bfd36e263a205d08780f409bbe7aa167c0f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX changed to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356b8546c5e9f87d62546e14302d659e5aac0d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the changed to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928e6b291318f0359ffca77cbc70fbead8ac5c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsxdev&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="8d018e282aac52faf1a5bce4dc9a51f6270555f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df5feb5a033ea926607a96dcf9030ae5dd911ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="cbd42a4c20856fac2215f1c094cdf7e0fe7a49a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35412f7057086a24e3247bacc81f6623d22727f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; , &lt;code&gt;react-native&lt;/code&gt; , &lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf2cc92123c8f6b96a9b964e714c58ae52e0a976" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with JSX changed to the equivalent &lt;code&gt;React.createElement&lt;/code&gt; calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56520eb9a155723fc8f96c437620581627d43f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; отображаются модификаторы типа и &lt;code&gt;readonly&lt;/code&gt; массивов</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; кортежи только для чтения</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; против &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc067980e88b210a1f21f1cb123315b9bd2081ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&lt;/code&gt;: The default behavior of dropping &lt;code&gt;import&lt;/code&gt; statements which only reference types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f5264bdd8f0f7da8b8b991265caec63e1a9c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt; can be used to provide a separate &amp;ldquo;type layer&amp;rdquo; to files that are not TypeScript or JavaScript by providing a home for generated &lt;code&gt;.d.ts&lt;/code&gt; files in another folder. This is technique is useful for bundled applications where you use &lt;code&gt;import&lt;/code&gt; of files that aren&amp;rsquo;t necessarily code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="136678c68a61a393796c0532e6210ae786397708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s: string&lt;/code&gt; because &lt;code&gt;&quot;right&quot;&lt;/code&gt; widens to &lt;code&gt;string&lt;/code&gt; on assignment to a mutable variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; : создает соответствующий файл &lt;code&gt;.map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; отключен</target>
        </trans-unit>
        <trans-unit id="aea90566bfe67f9e0c36ee7bab295a897337741f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is not assignable to &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3d1a64f83a79b3e78e4bbbb23a87b2e76a6983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; have built-in type predicates, conveniently leaving the object type for the &lt;code&gt;else&lt;/code&gt; branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it&amp;rsquo;s best to build only discriminated unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;symbol&lt;/code&gt; Значения символа создаются путем вызова конструктора &lt;code&gt;Symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3993556c0c777190448aa36a736f8d0fb775eeae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronousWatchDirectory&lt;/code&gt;: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in &lt;code&gt;node_modules&lt;/code&gt; from running &lt;code&gt;npm install&lt;/code&gt;), but you might want to disable it with this flag for some less-common setups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; : укажите целевую версию ECMAScript.</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this is T&lt;/code&gt; - теперь допустимая аннотация типа возвращаемого значения для методов в классах и интерфейсах. При использовании в положении типа narowing (например , &lt;code&gt;if&lt;/code&gt; заявление), тип выражения вызова целевого объекта будет сужен до &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3e8615ef6ee0889b418ba23a22ff83460487dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.accountType&lt;/code&gt; is set by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd16ac9e7ad7a6244f1c16c39714b038a0f987" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.address&lt;/code&gt; is declared as potentially &lt;code&gt;undefined&lt;/code&gt; which means it does not have to be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7a1bd4a571b4f44bdc27ad1f004b76e910b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.email&lt;/code&gt; is not set and raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a16b01ee1873ea69988138f8f89512d7f866c8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.name&lt;/code&gt; is set specifically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; означает, что &lt;code&gt;addClickListener&lt;/code&gt; ожидает, что &lt;code&gt;onclick&lt;/code&gt; будет функцией, которая не требует &lt;code&gt;this&lt;/code&gt; типа.</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; означает, что &lt;code&gt;addClickListener&lt;/code&gt; ожидает, что &lt;code&gt;onclick&lt;/code&gt; будет функцией, которая не требует &lt;code&gt;this&lt;/code&gt; типа. Во-вторых, аннотируйте свой вызывающий код &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; и стрелочные функции</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; параметры</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; параметры в обратных вызовах</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; охранники этого типа</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="6d97a427e5231bc7e7013c2328603de6d9b7acd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; если &lt;code&gt;composite&lt;/code&gt; включен, &lt;code&gt;false&lt;/code&gt; иначе</target>
        </trans-unit>
        <trans-unit id="f8eb24a65272e3cc37e19daeaae9de19be9d06d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; если не выполняется переход к другой программе или перенаправление вывода в файл</target>
        </trans-unit>
        <trans-unit id="2f4d5cb6b37ecf15d042f077e1921ffa51b29618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unreachable code is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; Командная строка</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="translated">&lt;code&gt;tsc -w&lt;/code&gt; не может работать с несколькими файлами конфигурации одновременно</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; будет использовать только существующие файлы на диске для выполнения этого процесса, поэтому можно создать проект, в котором не может быть сгенерирован правильный выходной файл, потому что выходные данные какого-либо проекта будут присутствовать в конечном файле более одного раза. Например:</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; , компилятор TypeScript, поддерживает новый флаг &lt;code&gt;--showConfig&lt;/code&gt; . При запуске &lt;code&gt;tsc --showConfig&lt;/code&gt; TypeScript вычислит эффективный &lt;code&gt;tsconfig.json&lt;/code&gt; (после вычисления параметров, унаследованных от поля &lt;code&gt;extends&lt;/code&gt; ) и распечатает его. Это может быть полезно для диагностики проблем конфигурации в целом.</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; Файлы tsconfig.json имеют новое свойство верхнего уровня, &lt;code&gt;references&lt;/code&gt; . Это массив объектов, который определяет проекты, на которые нужно ссылаться:</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; через пакеты Node.js</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; превращает папку в &amp;laquo;проект&amp;raquo;. Без указания каких- либо записей &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; или &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; , все файлы в папке, содержащей &lt;code&gt;tsconfig.json&lt;/code&gt; и все его подкаталоги, будут включены в вашу компиляцию. Если вы хотите исключить некоторые файлы, используйте &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; , если вы предпочитаете указать все файлы, вместо того, чтобы позволить компилятору искать их, используйте &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; охранники типа</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; могут поддерживать несколько полей, где каждое имя поля определяется диапазоном для сопоставления.</target>
        </trans-unit>
        <trans-unit id="1b8b90af89196bf03c26d7dd07ee39139d34a210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (default) provide suggestions as warnings to editors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68531fcaf5174582367c56ac27089f4450bfdd16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unknown&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; are like inverses of each other. Everything is assignable to &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt; is assignable to everything. Nothing is assignable to &lt;code&gt;never&lt;/code&gt;, &lt;code&gt;unknown&lt;/code&gt; is not assignable to anything (except &lt;code&gt;any&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b705485b2b636af977359d61c65b14f8f84a2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for directory changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c594db4c6e1fb35a69bcfe903f083a12dd62b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for file changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34e428b0ba7d576912bfbed8dfbd6fd75f80e59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEventsOnParentDirectory&lt;/code&gt;: Attempt to use the operating system/file system&amp;rsquo;s native events to listen for changes on a file&amp;rsquo;s parent directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; объявления var</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; Объявления var имеют некоторые странные правила области видимости для тех, которые используются для других языков. Возьмем следующий пример:</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; чем-то похож на противоположность &lt;code&gt;any&lt;/code&gt; : отсутствие какого-либо типа вообще. Вы можете часто видеть это как возвращаемый тип функций, которые не возвращают значение:</target>
        </trans-unit>
        <trans-unit id="838c4dd8a313b6b8002b30c9f9e069642c64144f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is not assignable to or from anything, with the following exceptions: &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; (if &lt;code&gt;--strictNullChecks&lt;/code&gt; is off, see table for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; будет иметь тип &lt;code&gt;any&lt;/code&gt; . Это означало, что программа будет выполнять проверку типов, но технически с &lt;code&gt;y&lt;/code&gt; можно было делать что угодно , например следующее:</target>
        </trans-unit>
        <trans-unit id="7e0a0801dcb35d26012a58fcc2e418fc7f6f784d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{@link &amp;hellip;}&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/35524&quot;&gt;issue #35524&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(общий корневой каталог вычисляется из списка входных файлов)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(зависит от платформы)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6d59622e066b207853d896915edd6f8b0489e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial strength string-padder example from earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; типов instanceof&lt;/em&gt; - это способ сужения типов с помощью их функции-конструктора. Например, давайте позаимствуем наш промышленный пример струнного паддера из предыдущего:</target>
        </trans-unit>
        <trans-unit id="71df9cb200fe1b9d9980debd24153321fc6684ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;An exploration into the &lt;code&gt;HTMLElement&lt;/code&gt; type&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Любой вариант компилятора&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="translated">&lt;em&gt;К классу&lt;/em&gt; применяются &lt;em&gt;декораторы&lt;/em&gt; класса.</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Настроить компилятор TypeScript&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="translated">&lt;em&gt;Do&lt;/em&gt; зависит от декларации пакета типа НОГО , если это не пакета его декларация файлов.</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="translated">&lt;em&gt;У&lt;/em&gt; сортировать перегрузки, поставив более общие подписи после более конкретных подписей:</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;Есть ли&lt;/em&gt; использование &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="translated">&lt;em&gt;По&lt;/em&gt; возможности используйте необязательные параметры:</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;Есть&lt;/em&gt; ли использовать тип возвращаемого &lt;code&gt;void&lt;/code&gt; для обратных вызовов, стоимость которых будет проигнорирован:</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Есть&lt;/em&gt; ли использовать типы &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , и &lt;code&gt;symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="translated">&lt;em&gt;По возможности&lt;/em&gt; используйте типы объединения:</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="translated">&lt;em&gt;Есть&lt;/em&gt; записи одного перегрузки с использованием максимальной Арности:</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="translated">&lt;em&gt;Есть&lt;/em&gt; записи параметров обратного вызова не опциональный:</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; объединяйте его с вашим, храните каждый в отдельном файле.</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; копируйте декларации в свой пакет.</target>
        </trans-unit>
        <trans-unit id="6641e250515c31ff4c29c3458f5aa359e7992e5f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Никогда не&lt;/em&gt; создавайте универсального типа, который не использует свой параметр типа. См. Дополнительные сведения на &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;странице часто задаваемых вопросов о TypeScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="translated">&lt;em&gt;Никогда не&lt;/em&gt; используйте типы &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; или &lt;code&gt;Object&lt;/code&gt; . Эти типы относятся к непримитивным упакованным объектам, которые почти никогда не используются надлежащим образом в коде JavaScript.</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; помещайте более общие перегрузки перед более конкретными перегрузками:</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; используйте &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; в файлах объявлений.</target>
        </trans-unit>
        <trans-unit id="a55cf7c66dde349c496b594f4eb9369bf866bddb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;any&lt;/code&gt; as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler &lt;em&gt;effectively&lt;/em&gt; treats &lt;code&gt;any&lt;/code&gt; as &amp;ldquo;please turn off type checking for this thing&amp;rdquo;. It is similar to putting an &lt;code&gt;@ts-ignore&lt;/code&gt; comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven&amp;rsquo;t migrated yet as &lt;code&gt;any&lt;/code&gt;, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; используйте необязательные параметры в обратных вызовах, если вы действительно это не имеете в виду:</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; используйте возвращаемый тип &lt;code&gt;any&lt;/code&gt; для обратных вызовов, значение которых будет проигнорировано:</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; записывайте перегрузки, которые различаются по типу, только в одной позиции аргумента:</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; пишите отдельные перегрузки, которые отличаются только арностью обратного вызова:</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; пишите несколько перегрузок, которые отличаются только конечными параметрами:</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Сначала немного терминологии ES2016:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Глобальный плагин&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Модули глобального изменения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Только вариант MSBuild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Плагин модуля&lt;/em&gt; или &lt;em&gt;плагин UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Разрешение модуля&lt;/em&gt; - это процесс, который компилятор использует для определения того, к чему относится импорт. Рассмотрим такой оператор импорта, как &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt; ; чтобы проверить любое использование &lt;code&gt;a&lt;/code&gt; , компилятор должен точно знать, что он представляет, и должен будет проверить его определение &lt;code&gt;moduleA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Не поддерживается в MSBuild&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Примечание. В настоящее время поддержка TypeScript в jspm находится в версии 0.16beta.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d7fac5427486f2e613c21aa283c576a7b6e2602" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If you hover over &lt;code&gt;MyBool&lt;/code&gt; above, you&amp;rsquo;ll see that it is classed as &lt;code&gt;boolean&lt;/code&gt;. That&amp;rsquo;s a property of the Structural Type System. More on this below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7bb0c2f049bd85bb9a3c22454271e46a22ff54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; In order for this to work like you would expect, your &lt;code&gt;tsx&lt;/code&gt; file must include an &lt;code&gt;export&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; so that it is considered a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b251d8e6b2dce1d359821b61fd4a66441a0a312c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: You can make JS emit terser by enabling &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e44bb4e42ffe01dfa1f4d3898748e7a02d03761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Only&lt;/em&gt; emit &lt;code&gt;.d.ts&lt;/code&gt; files; do not emit &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;К конструктору применяются &lt;em&gt;декораторы параметров&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Для каждого члена экземпляра применяются &lt;em&gt;декораторы параметров&lt;/em&gt; , за которыми следуют &lt;em&gt;декораторы &lt;/em&gt;&lt;em&gt;методов&lt;/em&gt; , средств &lt;em&gt;доступа&lt;/em&gt; или &lt;em&gt;свойств&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="translated">&lt;em&gt;Декораторы параметров&lt;/em&gt; , за которыми следуют &lt;em&gt;декораторы &lt;/em&gt;&lt;em&gt;методов&lt;/em&gt; , средств &lt;em&gt;доступа&lt;/em&gt; или &lt;em&gt;свойств&lt;/em&gt; , применяются к каждому статическому члену.</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="translated">&lt;em&gt;Остальные параметры&lt;/em&gt; трактуются как неограниченное количество необязательных параметров. При передаче аргументов для параметра rest вы можете использовать их столько, сколько захотите; вы даже не можете пройти ни одного. Компилятор построит массив переданных аргументов с именем, указанным после многоточия ( &lt;code&gt;...&lt;/code&gt; ), что позволит вам использовать его в своей функции.</target>
        </trans-unit>
        <trans-unit id="feac7405587931819084625ba52e25fde237d326" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;Настроить NPM&lt;/em&gt; #</target>
        </trans-unit>
        <trans-unit id="bb153592255ec6892092e3704ed2728ce144e9c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;Настроить gulp&lt;/em&gt; #</target>
        </trans-unit>
        <trans-unit id="4f0a451725c04750b6fb4ecce8b55da356ae465a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data. It has no runtime impact and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;Утверждения типа&lt;/em&gt; - это способ сказать компилятору: &amp;laquo;Поверьте мне, я знаю, что делаю&amp;raquo;. Утверждение типа похоже на приведение типа в других языках, но не выполняет специальной проверки или реструктуризации данных. Он не влияет на время выполнения и используется исключительно компилятором. TypeScript предполагает, что вы, программист, выполнили любые необходимые вам специальные проверки.</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="translated">&lt;em&gt;Почему&lt;/em&gt; : для обратного вызова всегда разрешено игнорировать параметр, поэтому нет необходимости в более короткой перегрузке. Предоставление более короткого обратного вызова вначале позволяет передавать неправильно типизированные функции, поскольку они соответствуют первой перегрузке.</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="translated">&lt;em&gt;Зачем&lt;/em&gt; : Это важно для людей, которые &amp;laquo;передают&amp;raquo; ценность вашей функции:</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="translated">&lt;em&gt;Почему&lt;/em&gt; : это важно по двум причинам.</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="translated">&lt;em&gt;Почему&lt;/em&gt; : TypeScript выбирает &lt;em&gt;первую совпадающую перегрузку&lt;/em&gt; при разрешении вызовов функций. Когда более ранняя перегрузка является &amp;laquo;более общей&amp;raquo;, чем более поздняя, ​​более поздняя фактически скрыта и не может быть вызвана.</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="translated">&lt;em&gt;Почему&lt;/em&gt; : использование &lt;code&gt;void&lt;/code&gt; безопаснее, поскольку оно предотвращает случайное использование возвращаемого значения &lt;code&gt;x&lt;/code&gt; непроверенным способом:</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;Замечание о терминологии:&lt;/strong&gt; важно отметить, что в TypeScript 1.5 номенклатура изменилась. &amp;laquo;Внутренние модули&amp;raquo; теперь &amp;laquo;пространства имен&amp;raquo;. &amp;laquo;Внешние модули&amp;raquo; теперь являются просто &amp;laquo;модулями&amp;raquo; в соответствии с терминологией &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; (а именно, что &lt;code&gt;module X {&lt;/code&gt; эквивалентен теперь предпочитаемому &lt;code&gt;namespace X {&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="964ab9094378bc3c35ca8cb8469c3e96aa11ee06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Командная строка&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4a14a1385687f20b567e75759c59e54cfb6cc9ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default&lt;/strong&gt;: The longest common path of all non-declaration input files. If &lt;code&gt;composite&lt;/code&gt; is set, the default is instead the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979f72af53937fa00189a4108423e158a79f69c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re looking for more information about the compiler options in a tsconfig, check out the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e74e37bb8dd2fa2fd06958c252f8d1e1c0b9f1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: &lt;code&gt;exclude&lt;/code&gt;&lt;em&gt;only&lt;/em&gt; changes which files are included as a result of the &lt;code&gt;include&lt;/code&gt; setting. A file specified by &lt;code&gt;exclude&lt;/code&gt; can still become part of your codebase due to an &lt;code&gt;import&lt;/code&gt; statement in your code, a &lt;code&gt;types&lt;/code&gt; inclusion, a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive, or being specified in the &lt;code&gt;files&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6f93e3961e1411696baa4f771bbaaa46934b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support&quot;&gt;the playground to explore JSDoc support&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f1a236aca787e2d4cec9e772e0a3c360a7f918" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; enabling &lt;code&gt;downlevelIteration&lt;/code&gt; does not improve compliance if &lt;code&gt;Symbol.iterator&lt;/code&gt; is not present in the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : эта директива устарела. Используйте &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; заявления вместо этого.</target>
        </trans-unit>
        <trans-unit id="6484c47e8d54fd3ffe22f03b860853fbda06eb2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference Files&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5eef7e4ca0f22611baae36661abda073e29f1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook Reference&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90c86a6f498b3ff28fdbaa9255f915348f2c482" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes" xml:space="preserve">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="translated">&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; Более конкретно, гомоморфные отображаемые типы, как в приведенной выше форме.</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="translated">&lt;sup&gt;[1]&lt;/sup&gt; Эти варианты являются экспериментальными.</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="translated">&lt;sup&gt;[2]&lt;/sup&gt; Эти параметры разрешены только в &lt;code&gt;tsconfig.json&lt;/code&gt; , но не через параметры командной строки.</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes" xml:space="preserve">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="translated">======== Имя модуля &amp;laquo;typescript&amp;raquo; было &lt;strong&gt;успешно&lt;/strong&gt; преобразовано в &amp;laquo;node_modules / typescript / lib / typescript.d.ts&amp;raquo;. ========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes" xml:space="preserve">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="translated">======== Разрешение модуля &lt;strong&gt;'typescript'&lt;/strong&gt; из &lt;strong&gt;'src / app.ts'&lt;/strong&gt; . ========</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes" xml:space="preserve">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes" xml:space="preserve">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes" xml:space="preserve">
          <source>@param and @returns</source>
          <target state="translated">@param и @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes" xml:space="preserve">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="translated">&amp;laquo;Чистый импорт&amp;raquo; можно использовать для импорта модуля только из-за его побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="translated">A &lt;code&gt;// @ts-ignore&lt;/code&gt; комментарий подавляет все ошибки , которые происходят на следующей строке. Рекомендуется, чтобы оставшаяся часть комментария после &lt;code&gt;@ts-ignore&lt;/code&gt; объясняла, какая ошибка подавляется.</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; декларации</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; декларации</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="translated">Объявление &lt;code&gt;namespace&lt;/code&gt; может использоваться для добавления новых типов, значений и пространств имен любым способом, который не создает конфликта.</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="translated">Объявление &lt;code&gt;namespace&lt;/code&gt; или &lt;code&gt;module&lt;/code&gt; которое содержит значение</target>
        </trans-unit>
        <trans-unit id="0e1b65fe0101802b4d7f9ed8f568068bb52794bf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; файл может наследовать конфигурации из другого файла , используя &lt;code&gt;extends&lt;/code&gt; свойство.</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; файл разрешается быть полностью пустым, который собирает все файлы , включенные по умолчанию (как описано выше) с опциями компилятора по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;Класса декоратор&lt;/em&gt; объявляется непосредственно перед объявлением класса. Декоратор класса применяется к конструктору класса и может использоваться для наблюдения, изменения или замены определения класса. Декоратор класса нельзя использовать в файле объявления или в любом другом окружающем контексте (например, в классе &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="translated">&lt;em&gt;Декоратор&lt;/em&gt; представляет собой особый вид декларации , которая может быть присоединена к &lt;a href=&quot;#class-decorators&quot;&gt;объявлению класса&lt;/a&gt; , &lt;a href=&quot;#method-decorators&quot;&gt;методе&lt;/a&gt; , &lt;a href=&quot;#accessor-decorators&quot;&gt;аксессору&lt;/a&gt; , &lt;a href=&quot;#property-decorators&quot;&gt;имуществу&lt;/a&gt; или &lt;a href=&quot;#parameter-decorators&quot;&gt;параметру&lt;/a&gt; . Декораторы используют форму &lt;code&gt;@expression&lt;/code&gt; , где &lt;code&gt;expression&lt;/code&gt; должно оценивать функцию, которая будет вызываться во время выполнения с информацией о декорированном объявлении.</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;Метод декоратор&lt;/em&gt; объявляются непосредственно перед объявлением методы. Декоратор применяется к &lt;em&gt;дескриптору свойства&lt;/em&gt; для метода и может использоваться для наблюдения, изменения или замены определения метода. Декоратор метода нельзя использовать в файле объявления, при перегрузке или в любом другом окружающем контексте (например, в классе &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;Параметр декоратор&lt;/em&gt; объявляется непосредственно перед декларацией параметра. Декоратор параметров применяется к функции для объявления конструктора класса или метода. Декоратор параметров нельзя использовать в файле объявления, перегрузке или в любом другом внешнем контексте (например, в классе &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;Декоратор собственности&lt;/em&gt; объявляется только перед имущественной декларации. Декоратор свойств нельзя использовать в файле объявления или в любом другом окружающем контексте (например, в классе &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="translated">&lt;em&gt;УМД&lt;/em&gt; модуль является тот , который может &lt;em&gt;либо&lt;/em&gt; быть использован в качестве модуля (через импорт), или в качестве глобальной (при запуске в среде без модуля загрузчика). &lt;a href=&quot;http://momentjs.com/&quot;&gt;Так&lt;/a&gt; написаны многие популярные библиотеки, например Moment.js . Например, в Node.js или при использовании RequireJS вы должны написать:</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;Дискриминант тип недвижимости охранник&lt;/em&gt; является выражением вида &lt;code&gt;x.p == v&lt;/code&gt; , &lt;code&gt;x.p === v&lt;/code&gt; , &lt;code&gt;x.p != v&lt;/code&gt; , или &lt;code&gt;x.p !== v&lt;/code&gt; , где &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;v&lt;/code&gt; являются свойством и выражением строкового типа или буквального объединение строковых литералов. Защита типа дискриминантного свойства сужает тип &lt;code&gt;x&lt;/code&gt; до тех составляющих типов &lt;code&gt;x&lt;/code&gt; , которые имеют дискриминантное свойство &lt;code&gt;p&lt;/code&gt; с одним из возможных значений &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="translated">&lt;em&gt;Глобальный плагин&lt;/em&gt; глобальна код , который изменяет форму некоторых глобальные. Как и в случае с &lt;em&gt;модулями&lt;/em&gt; с &lt;em&gt;глобальным изменением&lt;/em&gt; , это повышает вероятность конфликта во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="translated">Модуль &lt;em&gt;глобальной модификации&lt;/em&gt; изменяет существующие значения в глобальной области при их импорте. Например, может существовать библиотека, которая добавляет новые члены в &lt;code&gt;String.prototype&lt;/code&gt; при импорте. Этот шаблон несколько опасен из-за возможности конфликтов во время выполнения, но мы все же можем написать для него файл объявления.</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="translated">&lt;em&gt;Глобальная&lt;/em&gt; библиотека является тот , который можно получить доступ из глобальной области (т.е. без использования какой - либо формы &lt;code&gt;import&lt;/code&gt; ). Многие библиотеки просто предоставляют одну или несколько глобальных переменных для использования. Например, если вы использовали &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , переменную &lt;code&gt;$&lt;/code&gt; можно использовать, просто сославшись на нее:</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="translated">&lt;em&gt;Модуль плагин&lt;/em&gt; изменяет форму другого модуля (либо UMD или модуль). Например, в Moment.js &lt;code&gt;moment-range&lt;/code&gt; добавляет новый метод &lt;code&gt;range&lt;/code&gt; к объекту &lt;code&gt;moment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="translated">&lt;em&gt;Относительно импорта&lt;/em&gt; является тот , который начинается с &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; или &lt;code&gt;../&lt;/code&gt; . Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="translated">&lt;strong&gt;Класс Mixin&lt;/strong&gt; является объявлением класса или выражение , которое &lt;code&gt;extends&lt;/code&gt; выражение типа параметра типа. К объявлениям классов миксинов применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;strong&gt;миксина-конструктора&lt;/strong&gt; относится к типу, который имеет одну сигнатуру конструкции с одним аргументом rest типа &lt;code&gt;any[]&lt;/code&gt; и объектно-подобным типом возвращаемого значения. Например, если объект типа типа &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; является Mixin конструктора типа с типом экземпляра &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes" xml:space="preserve">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="translated">Булевое значение,указывающее на то,что объект должен быть сплющен в элементы его массива по массиву Array.prototype.concat.</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes" xml:space="preserve">
          <source>A Note on Soundness</source>
          <target state="translated">Заметка о Звуке</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes" xml:space="preserve">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="translated">Строковое значение, используемое при создании строкового описания объекта по умолчанию. Вызывается встроенным методом &lt;code&gt;Object.prototype.toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a9182f58f65016d093319fe062109a9686adac2" translate="yes" xml:space="preserve">
          <source>A TSConfig file in a directory indicates that the directory is the root of a TypeScript or JavaScript project. The TSConfig file can be either a &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;, both have the same behavior and the same set of config variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855d73d13b972d2597c136c97ec4024c17beeaa2" translate="yes" xml:space="preserve">
          <source>A Typed Superset of JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes" xml:space="preserve">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">На этапе сборки файлы из &lt;code&gt;/src/views&lt;/code&gt; и &lt;code&gt;/generated/templates/views&lt;/code&gt; будут скопированы в тот же каталог на выходе. Во время выполнения представление может ожидать, что его шаблон будет существовать рядом с ним, и поэтому должно импортировать его, используя относительное имя как &lt;code&gt;&quot;./template&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes" xml:space="preserve">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="translated">Вызов универсальной функции использует аргументы для определения параметров типа. Иногда этот процесс не может вывести какие-либо типы, в основном из-за отсутствия источников вывода; в этих случаях параметры типа по умолчанию будут равны &lt;code&gt;any&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes" xml:space="preserve">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="translated">Конструктор класса может быть помечен как &lt;code&gt;private&lt;/code&gt; или &lt;code&gt;protected&lt;/code&gt; . Класс с частным конструктором не может быть создан за пределами тела класса и не может быть расширен. Класс с защищенным конструктором не может быть создан за пределами тела класса, но может быть расширен.</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes" xml:space="preserve">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="translated">Объявление класса ( &lt;code&gt;class C { }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="translated">Объявление класса или интерфейса,которое сливается с существующим классом или объявлением интерфейса,может ввести значение по умолчанию для существующего параметра типа.</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="translated">Объявление класса или интерфейса,которое сливается с существующим классом или объявлением интерфейса,может ввести новый параметр типа,если в нем указан параметр по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e2f827247ace6a9f06365439ae3c387f57673379" translate="yes" xml:space="preserve">
          <source>A collection of extra checks, which somewhat cross the boundaries of compiler vs linter. You may prefer to use a tool like &lt;a href=&quot;https://github.com/typescript-eslint/typescript-eslint#typescript-eslint&quot;&gt;eslint&lt;/a&gt; over these options if you are looking for more in-depth rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes" xml:space="preserve">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="translated">Обычная и опасная ошибка-забыть вызвать функцию,особенно если она имеет нулевые аргументы или имеет имя,подразумевающее,что это может быть свойство,а не функция.</target>
        </trans-unit>
        <trans-unit id="e559cf07cd2ab15a57eb14b846956299870d3251" translate="yes" xml:space="preserve">
          <source>A common case for their use is for describing config values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012e1680ac04035d05806ae768fbd8f7e9e4d64b" translate="yes" xml:space="preserve">
          <source>A common case where you might think to use &lt;code&gt;skipLibCheck&lt;/code&gt; is when there are two copies of a library&amp;rsquo;s types in your &lt;code&gt;node_modules&lt;/code&gt;. In these cases, you should consider using a feature like &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/selective-version-resolutions/&quot;&gt;yarn&amp;rsquo;s resolutions&lt;/a&gt; to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="translated">Распространенной ошибкой является попытка использовать синтаксис &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; для ссылки на файл модуля вместо использования оператора &lt;code&gt;import&lt;/code&gt; . Чтобы понять разницу, мы в первую очередь необходимо понять , как компилятор может найти информацию о типе модуля , основанной на пути к &lt;code&gt;import&lt;/code&gt; (например, &lt;code&gt;...&lt;/code&gt; в &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt; , &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt; и т. д.) путь.</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes" xml:space="preserve">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">Распространенным шаблоном в JavaScript является использование &lt;code&gt;typeof&lt;/code&gt; или &lt;code&gt;instanceof&lt;/code&gt; для проверки типа выражения во время выполнения. TypeScript теперь понимает эти условия и соответствующим образом изменит вывод типа при использовании в блоке &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes" xml:space="preserve">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="translated">Общая задача состоит в том,чтобы взять существующий тип и сделать каждое из его свойств необязательным:</target>
        </trans-unit>
        <trans-unit id="d835d6d7b039c2f6e80d9f60ed8e2cfe5e3e986f" translate="yes" xml:space="preserve">
          <source>A common technique for working with unions is to have a single field which uses literal types which you can use to let TypeScript narrow down the possible current type. For example, we&amp;rsquo;re going to create a union of three types which have a single shared field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes" xml:space="preserve">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="translated">Обычный обходной путь - использовать IIFE - выражение немедленного вызова функции - для захвата &lt;code&gt;i&lt;/code&gt; на каждой итерации:</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Условный тип &lt;code&gt;T extends U ? X : Y&lt;/code&gt; либо &lt;em&gt;разрешается&lt;/em&gt; в &lt;code&gt;X&lt;/code&gt; или &lt;code&gt;Y&lt;/code&gt; , либо &lt;em&gt;откладывается,&lt;/em&gt; потому что условие зависит от одной или нескольких переменных типа. Когда &lt;code&gt;T&lt;/code&gt; или &lt;code&gt;U&lt;/code&gt; содержит переменные типа, будь то постановить &lt;code&gt;X&lt;/code&gt; или &lt;code&gt;Y&lt;/code&gt; , или отложить, определяется , имеет ли тип системы достаточно информации , чтобы заключить , что &lt;code&gt;T&lt;/code&gt; всегда присваиваемые &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="translated">Условный тип &lt;code&gt;T extends U ? X : Y&lt;/code&gt; либо &lt;em&gt;разрешается&lt;/em&gt; в &lt;code&gt;X&lt;/code&gt; или &lt;code&gt;Y&lt;/code&gt; , либо &lt;em&gt;откладывается,&lt;/em&gt; потому что условие зависит от одной или нескольких переменных типа. Решение о разрешении или отложении определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="3632cf4e26292b0e76ecac870e4423c2cd5b98f7" translate="yes" xml:space="preserve">
          <source>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes" xml:space="preserve">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="translated">Конструктор также может быть отмечен как &lt;code&gt;protected&lt;/code&gt; . Это означает, что класс не может быть создан за пределами содержащего его класса, но может быть расширен. Например,</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes" xml:space="preserve">
          <source>A couple of limitations</source>
          <target state="translated">Пара ограничений</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes" xml:space="preserve">
          <source>A couple of things to note about accessors:</source>
          <target state="translated">Пару вещей о аксессуарах:</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes" xml:space="preserve">
          <source>A decorator is:</source>
          <target state="translated">Декоратор:</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes" xml:space="preserve">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="translated">Декларация разрушения вводит одну или несколько именованных переменных и инициализирует их значениями,извлеченными из свойств объекта или элементов массива.</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes" xml:space="preserve">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="translated">Файл, единственным объявлением верхнего уровня которого является &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (удалите &lt;code&gt;Foo&lt;/code&gt; и переместите все &quot;вверх&quot; на уровень)</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes" xml:space="preserve">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="translated">Значимое свойство функции,которое является функцией конструктора,используемой для создания производных объектов.</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes" xml:space="preserve">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="translated">Функция, в теле которой есть ссылка на ссылку на &lt;code&gt;arguments&lt;/code&gt; неявно считается имеющей параметр var-arg (т.е. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt; ). Используйте синтаксис JSDoc var-arg, чтобы указать тип аргументов.</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes" xml:space="preserve">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="translated">Тип функции состоит из двух частей: типа аргументов и возвращаемого типа. При записи всего типа функции требуются обе части. Мы записываем типы параметров точно так же, как список параметров, давая каждому параметру имя и тип. Это имя просто для удобства чтения. Вместо этого мы могли бы написать:</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes" xml:space="preserve">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="translated">Функция генератора может иметь аннотацию типа возврата,так же как и функция.Аннотация представляет тип генератора,возвращаемого функцией.Вот пример:</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes" xml:space="preserve">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="translated">Функция генератора без аннотации типа может иметь аннотацию типа.Таким образом,в следующем случае тип будет выведен из отчета о доходности:</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes" xml:space="preserve">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="translated">Универсальный класс имеет форму, аналогичную универсальному интерфейсу. Универсальные классы имеют список параметров универсального типа в угловых скобках ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) после имени класса.</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes" xml:space="preserve">
          <source>A generic parameter default follows the following rules:</source>
          <target state="translated">Общий параметр по умолчанию следует следующим правилам:</target>
        </trans-unit>
        <trans-unit id="58295366adbe5e286eb8eb3bd14ff3824be0727b" translate="yes" xml:space="preserve">
          <source>A good first read for your daily TS work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes" xml:space="preserve">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="translated">Удобной функцией перечислений является то, что вы также можете перейти от числового значения к имени этого значения в перечислении. Например, если бы у нас было значение &lt;code&gt;2&lt;/code&gt; , но мы не были уверены, что оно отображается в перечислении &lt;code&gt;Color&lt;/code&gt; выше, мы могли бы найти соответствующее имя:</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes" xml:space="preserve">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="translated">Полезным дополнением к стандартному набору типов данных из JavaScript является &lt;code&gt;enum&lt;/code&gt; . Как и в таких языках, как C #, перечисление - это способ дать более понятные имена наборам числовых значений.</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes" xml:space="preserve">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="translated">Ключевой особенностью модулей в TypeScript является то, что два разных модуля никогда не будут использовать имена в одной и той же области. Поскольку потребитель модуля решает, какое имя ему присвоить, нет необходимости активно заключать экспортируемые символы в пространство имен.</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes" xml:space="preserve">
          <source>A library can consist of multiple modules, such as</source>
          <target state="translated">Библиотека может состоять из нескольких модулей,таких как</target>
        </trans-unit>
        <trans-unit id="0e8770c272f2840fccfa97bc4c9d703b31f41107" translate="yes" xml:space="preserve">
          <source>A literal is a more concrete sub-type of a collective type. What this means is that &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, but a &lt;code&gt;string&lt;/code&gt; is not &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; inside the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes" xml:space="preserve">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="translated">Долгожданная функция - интеллектуальные инкрементальные сборки для проектов TypeScript. В &lt;code&gt;--build&lt;/code&gt; 3.0 вы можете использовать флаг &lt;code&gt;tsc&lt;/code&gt; с tsc . По сути, это новая точка входа для &lt;code&gt;tsc&lt;/code&gt; , которая больше похожа на оркестратор сборки, чем на простой компилятор.</target>
        </trans-unit>
        <trans-unit id="763f393de249964da063f318cee51c3e7602546a" translate="yes" xml:space="preserve">
          <source>A lot of the time the answer is &lt;em&gt;&amp;ldquo;it depends&amp;rdquo;&lt;/em&gt;, or &lt;em&gt;&amp;ldquo;someone may have decided for you&amp;rdquo;&lt;/em&gt; depending on the project. If you are building your project with an existing framework like &lt;a href=&quot;https://tsdx.io&quot;&gt;tsdx&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt; or any framework mentioned in the &lt;a href=&quot;https://www.typescriptlang.org/docs/home&quot;&gt;Getting Started&lt;/a&gt; then this decision is handled for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes" xml:space="preserve">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="translated">Большая часть программной инженерии-это создание компонентов,которые не только имеют четко определенные и согласованные API,но и могут быть использованы многократно.Компоненты,способные работать как с данными сегодняшнего дня,так и с данными завтрашнего дня,дадут вам наиболее гибкие возможности для построения больших программных систем.</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes" xml:space="preserve">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">Отображенный тип &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; разрешает любой &lt;code&gt;K&lt;/code&gt; , присваиваемый &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes" xml:space="preserve">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="translated">Метод, преобразующий объект в соответствующее примитивное значение. Вызывается абстрактной операцией &lt;code&gt;ToPrimitive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes" xml:space="preserve">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="translated">Метод, определяющий, распознает ли объект-конструктор объект как один из экземпляров конструктора. Вызывается семантикой оператора instanceof.</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes" xml:space="preserve">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="translated">Метод,возвращающий итератор по умолчанию для объекта.Вызывается семантикой фор-оператора.</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes" xml:space="preserve">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="translated">Модификатор без префикса &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; аналогичен модификатору с префиксом &lt;code&gt;+&lt;/code&gt; . Итак, &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; выше соответствует</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes" xml:space="preserve">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="translated">Имя модуля будет вычисляться для каждого модуля на основе его относительного местоположения относительно &lt;code&gt;rootDir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fc81a9321caa5212d8c955b9d7611a22e0e64b3" translate="yes" xml:space="preserve">
          <source>A module using CommonJS patterns uses &lt;code&gt;module.exports&lt;/code&gt; to describe the exported values. For example, here is a module which exports a function and a numerical constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes" xml:space="preserve">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="translated">Более продвинутый пример использует свойство prototype для вывода и ограничения связей между функцией конструктора и стороной экземпляра типов класса.</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes" xml:space="preserve">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">Более распространенная ошибка, которую фиксирует эта функция, - это добавление новой строки после оператора &lt;code&gt;return&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="translated">Пространство имен &lt;code&gt;X&lt;/code&gt; (поскольку объявление &lt;code&gt;namespace&lt;/code&gt; содержит тип &lt;code&gt;Y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">Пространство имен &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes" xml:space="preserve">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="translated">Импорт пространства имен (т.е. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ) теперь правильно помечен как не вызываемый. Вызов его приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="translated">Новый &lt;code&gt;!&lt;/code&gt; Оператор выражения после исправления может использоваться для подтверждения того, что его операнд не равен нулю и не определен в контекстах, где средство проверки типов не может сделать вывод об этом факте. В частности, операция &lt;code&gt;x!&lt;/code&gt; производит значение типа &lt;code&gt;x&lt;/code&gt; с исключенными &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; . Подобно утверждениям типа форм &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; и &lt;code&gt;x as T&lt;/code&gt; , символ &lt;code&gt;!&lt;/code&gt; ненулевой оператор утверждения просто удаляется в сгенерированном коде JavaScript.</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes" xml:space="preserve">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="translated">Новый флаг добавляется также в машинописном 2.0 для флага всех видов использования &lt;code&gt;this&lt;/code&gt; в функции без явного типа аннотаций.</target>
        </trans-unit>
        <trans-unit id="74e05c5f83ee7f74c16bbdd86c8307c4e68ce786" translate="yes" xml:space="preserve">
          <source>A new suite of errors which tackle a new problem domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes" xml:space="preserve">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="translated">Новый синтаксис для &lt;code&gt;ReadonlyArray&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="translated">Ночная сборка из &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt; &lt;code&gt;master&lt;/code&gt; &lt;/a&gt; ветки TypeScript публикуется в полночь по тихоокеанскому времени в NPM и NuGet. Вот как вы можете получить его и использовать со своими инструментами.</target>
        </trans-unit>
        <trans-unit id="26136197b0e619c7a477a0ede27ddf26c086e432" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes" xml:space="preserve">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; импорт может быть разрешен относительно baseUrl или через сопоставление путей, о чем мы расскажем ниже. Они также могут разрешаться в &lt;a href=&quot;modules#ambient-modules&quot;&gt;объявлениях внешних модулей&lt;/a&gt; . Используйте не относительные пути при импорте любых внешних зависимостей.</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes" xml:space="preserve">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">Не относительный импорт в &lt;code&gt;moduleB&lt;/code&gt; , такой как &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; в исходном файле &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; , приведет к попытке найти &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt; в следующих местах :</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes" xml:space="preserve">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="translated">Замечание о let</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes" xml:space="preserve">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Примечание о &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes" xml:space="preserve">
          <source>A partial version of it would be:</source>
          <target state="translated">Частичная версия была бы:</target>
        </trans-unit>
        <trans-unit id="43fa7e787c62527d93ae270a4c2aa47ce163ffcd" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism, a lot of people know it as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent API&lt;/a&gt; pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">Полиморфный &lt;code&gt;this&lt;/code&gt; тип представляет тип, который является &lt;em&gt;подтипом&lt;/em&gt; содержащего класса или интерфейса. Это называется &lt;em&gt;F&lt;/em&gt; -ограниченным полиморфизмом. Это, например, значительно упрощает выражение иерархических плавных интерфейсов. Возьмем простой калькулятор, который возвращает &lt;code&gt;this&lt;/code&gt; после каждой операции:</target>
        </trans-unit>
        <trans-unit id="2ed3773d514d4c4811918e29ff471fbec8ab9085" translate="yes" xml:space="preserve">
          <source>A popular use-case for union types is to describe the set of &lt;code&gt;string&lt;/code&gt;s or &lt;code&gt;number&lt;/code&gt;s &lt;a href=&quot;literal-types&quot;&gt;literal&lt;/a&gt; that a value is allowed to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365b081b2090ee2d0d1ba0c0f61def91ecb0e717" translate="yes" xml:space="preserve">
          <source>A project is compiled in one of the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes" xml:space="preserve">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="translated">Макет исходного кода проекта иногда не совпадает с макетом вывода. Обычно набор шагов сборки приводит к генерации окончательного результата. К ним относятся компиляция файлов &lt;code&gt;.ts&lt;/code&gt; в &lt;code&gt;.js&lt;/code&gt; и копирование зависимостей из разных исходных местоположений в одно выходное местоположение. В результате модули во время выполнения могут иметь другие имена, чем исходные файлы, содержащие их определения. Или пути модулей в окончательном выводе могут не совпадать с соответствующими путями к исходным файлам во время компиляции.</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes" xml:space="preserve">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="translated">Доступ к свойству или вызов функции вызывает ошибку времени компиляции, если объект или функция имеет тип, который включает значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Однако защита типов расширена для поддержки ненулевых и ненулевых проверок.</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes" xml:space="preserve">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="translated">Свойство, объявленное с помощью &lt;code&gt;get&lt;/code&gt; доступа get и без &lt;code&gt;set&lt;/code&gt; доступа set, считается доступным только для чтения.</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes" xml:space="preserve">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="translated">Свойство или подпись индекса теперь можно объявить с помощью модификатора &lt;code&gt;readonly&lt;/code&gt; , который считается доступным только для чтения.</target>
        </trans-unit>
        <trans-unit id="14c9c9574f47af69ee1d2d4201e7c958df2ed786" translate="yes" xml:space="preserve">
          <source>A reader who completes the walkthrough should be able to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes" xml:space="preserve">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="translated">Метод регулярного выражения, который сопоставляет регулярное выражение со строкой. Вызывается методом &lt;code&gt;String.prototype.match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes" xml:space="preserve">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="translated">Метод регулярного выражения, заменяющий совпадающие подстроки строки. Вызывается методом &lt;code&gt;String.prototype.replace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes" xml:space="preserve">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="translated">Метод регулярного выражения, который возвращает индекс в строке, соответствующей регулярному выражению. Вызывается методом &lt;code&gt;String.prototype.search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes" xml:space="preserve">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="translated">Метод регулярного выражения, который разбивает строку по индексам, соответствующим регулярному выражению. Вызывается методом &lt;code&gt;String.prototype.split&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes" xml:space="preserve">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="translated">Относительный импорт разрешается относительно импортируемого файла и &lt;em&gt;не может быть&lt;/em&gt; разрешен в объявление внешнего модуля. Вы должны использовать относительный импорт для ваших собственных модулей, которые гарантированно сохранят свое относительное расположение во время выполнения.</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes" xml:space="preserve">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">Относительный импорт будет разрешен относительно импортируемого файла. Таким образом, &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; в исходном файле &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; приведет к следующим поискам:</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes" xml:space="preserve">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="translated">Параметру покоя разрешено иметь общий тип,который ограничен типом массива,и вывод типа может выводить типы кортежей для таких общих параметров покоя.Это позволяет захватывать и распространять списки частичных параметров более высокого порядка:</target>
        </trans-unit>
        <trans-unit id="10834bc0f63c36734ac19d004f786a265bea8f0c" translate="yes" xml:space="preserve">
          <source>A series of entries which re-map imports to lookup locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;, there is a larger coverage of &lt;code&gt;paths&lt;/code&gt; in &lt;a href=&quot;docs/handbook/module-resolution#path-mapping&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes" xml:space="preserve">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="translated">Простое правило, которому следует следовать, - объявлять только типы, &lt;em&gt;пространство имен которых&lt;/em&gt; определяется любой глобальной переменной, определенной библиотекой. Например, если библиотека определяет глобальное значение &amp;laquo;коты&amp;raquo;, вы должны написать</target>
        </trans-unit>
        <trans-unit id="165f98ffc3810edb440d523a18c63520c86face3" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if a relative path is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="translated">Путь к ссылке с тройной косой чертой разрешается относительно содержащего файла,если он не имеет корней.</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes" xml:space="preserve">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="translated">Файл tsconfig.json, в котором не указано свойство файлов (и, следовательно, неявно ссылается на все файлы * .ts во всех подкаталогах), теперь может содержать свойство exclude, которое указывает список файлов и / или каталогов, которые необходимо исключить из компиляции. Свойство exclude должно быть массивом строк, каждая из которых указывает имя файла или папки относительно местоположения файла tsconfig.json. Например:</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes" xml:space="preserve">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="translated">Тип кортежа позволяет опускать элемент, если он имеет постфикс &lt;code&gt;?&lt;/code&gt; модификатор на его тип и все элементы справа от него также имеют &lt;code&gt;?&lt;/code&gt; модификаторы.</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="translated">Тип &lt;code&gt;C&lt;/code&gt; в пространстве имен &lt;code&gt;X.Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">Тип &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="translated">Тип &lt;code&gt;Y&lt;/code&gt; в пространстве имен &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="translated">Тип &lt;code&gt;Z&lt;/code&gt; в пространстве имен &lt;code&gt;X&lt;/code&gt; (форма экземпляра класса)</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes" xml:space="preserve">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="translated">Объявление псевдонима типа ( &lt;code&gt;type sn = number | string;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes" xml:space="preserve">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="translated">Псевдоним типа, который принимает объединение этих типов - &lt;em&gt;объединение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes" xml:space="preserve">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="translated">Тип может включать в себя индексную подпись,явно указывающую на то,что избыточные свойства допустимы:</target>
        </trans-unit>
        <trans-unit id="7923f87ba1b11ff5aadde3784a645b7bf0213b2d" translate="yes" xml:space="preserve">
          <source>A type cannot be changed after being created</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes" xml:space="preserve">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="translated">Защита типа для имени, разделенного точками, не действует после присвоения какой-либо части имени, разделенного точками. Например, защита типа для &lt;code&gt;x.y.z&lt;/code&gt; будет иметь никакого эффекта после присвоения &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.y&lt;/code&gt; или &lt;code&gt;x.y.z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes" xml:space="preserve">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="translated">Параметр типа считается необязательным,если он имеет значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cc781420c33da6107d9682c46a6f8b3ef934ac7b" translate="yes" xml:space="preserve">
          <source>A type-system based only on inference with JavaScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes" xml:space="preserve">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">Пакет типов - это папка с файлом с именем &lt;code&gt;index.d.ts&lt;/code&gt; или папка с файлом &lt;code&gt;package.json&lt;/code&gt; ,в котором есть поле &lt;code&gt;types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes" xml:space="preserve">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">Тип объединения описывает значение, которое может быть одним из нескольких типов. Мы используем вертикальную черту ( &lt;code&gt;|&lt;/code&gt; ) для разделения каждого типа, поэтому &lt;code&gt;number | string | boolean&lt;/code&gt; - это тип значения, которое может быть &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; или &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes" xml:space="preserve">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="translated">Пользователь мог выразить &lt;code&gt;2 * 5 + 1&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="translated">Значение &lt;code&gt;C&lt;/code&gt; , которое является свойством значения &lt;code&gt;X.Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="translated">Значение &lt;code&gt;X&lt;/code&gt; (поскольку объявление &lt;code&gt;namespace&lt;/code&gt; содержит значение &lt;code&gt;Z&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">Значение &lt;code&gt;Y&lt;/code&gt; (типа &lt;code&gt;number&lt;/code&gt; ), которое является свойством значения &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">Значение &lt;code&gt;Z&lt;/code&gt; , которое является свойством значения &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="translated">Значение &lt;code&gt;Z&lt;/code&gt; , которое является свойством значения &lt;code&gt;X&lt;/code&gt; (функция-конструктор класса)</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes" xml:space="preserve">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="translated">Переменная, объявленная без аннотации типа и начальное значение &lt;code&gt;[]&lt;/code&gt; , считается неявной переменной &lt;code&gt;any[]&lt;/code&gt; . Тем не менее, каждый последующий &lt;code&gt;x.push(value)&lt;/code&gt; , &lt;code&gt;x.unshift(value)&lt;/code&gt; или &lt;code&gt;x[n] = value&lt;/code&gt; операции &lt;em&gt;развивается&lt;/em&gt; тип переменной в соответствии с тем, что элементы добавляются к нему.</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes" xml:space="preserve">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="translated">AMD/ТребованиеJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes" xml:space="preserve">
          <source>AMD Module names</source>
          <target state="translated">Имена модулей AMD</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes" xml:space="preserve">
          <source>AMD-dependency optional names</source>
          <target state="translated">дополнительные имена в зависимости от AMD</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes" xml:space="preserve">
          <source>API Changes</source>
          <target state="translated">API Изменения</target>
        </trans-unit>
        <trans-unit id="4a2fd182a22546b9a5411efbef21d9ce9da6d56a" translate="yes" xml:space="preserve">
          <source>APIs available in &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;WebWorker&lt;/a&gt; contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514c168cf5e4e1365917faccfdc0926188272b5f" translate="yes" xml:space="preserve">
          <source>APIs for the &lt;a href=&quot;https://wikipedia.org/wiki/Windows_Script_Host&quot;&gt;Windows Script Hosting System&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes" xml:space="preserve">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="translated">API для поддержки &lt;code&gt;--build&lt;/code&gt; и &lt;code&gt;--incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">ASP.NET Core</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes" xml:space="preserve">
          <source>ASP.NET Core + TypeScript</source>
          <target state="translated">ASP.NET Core+TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="translated">ASP.NET Core:Добавить TypeScript</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Setup</source>
          <target state="translated">ASP.NET ядро:установка</target>
        </trans-unit>
        <trans-unit id="50eed69def791463bbdef9085e70b4aade82ea60" translate="yes" xml:space="preserve">
          <source>About &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b106ce4000d8d8c80eef39d6b34b6a0ccaab29" translate="yes" xml:space="preserve">
          <source>About this Handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes" xml:space="preserve">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="translated">Выше, все выводы для &lt;code&gt;T&lt;/code&gt; происходят в контравариантными позициях, и поэтому мы делаем вывод о &lt;em&gt;лучшем общем подтипе&lt;/em&gt; для &lt;code&gt;T&lt;/code&gt; . Это контрастирует с выводами из ковариантных позиций, где мы делаем вывод о &lt;em&gt;наилучшем общем супертипе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes" xml:space="preserve">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Выше у нас есть интерфейс &lt;code&gt;StringArray&lt;/code&gt; с индексной подписью. В этой сигнатуре индекса указано, что когда &lt;code&gt;StringArray&lt;/code&gt; индексируется &lt;code&gt;number&lt;/code&gt; , он возвращает &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes" xml:space="preserve">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Выше у нас есть числовое перечисление, в котором &lt;code&gt;Up&lt;/code&gt; инициализируется &lt;code&gt;1&lt;/code&gt; . С этого момента все следующие члены автоматически увеличиваются. Другими словами, &lt;code&gt;Direction.Up&lt;/code&gt; имеет значение &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;Down&lt;/code&gt; - &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;Left&lt;/code&gt; - &lt;code&gt;3&lt;/code&gt; и &lt;code&gt;Right&lt;/code&gt; - &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">Абстрактные классы</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes" xml:space="preserve">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="translated">Абстрактные классы - это базовые классы, от которых могут быть производными другие классы. Их нельзя создавать напрямую. В отличие от интерфейса абстрактный класс может содержать детали реализации своих членов. &lt;code&gt;abstract&lt;/code&gt; ключевое слово используется для определения абстрактных классов, а также абстрактные методы в абстрактном классе.</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes" xml:space="preserve">
          <source>Abstract properties and accessors</source>
          <target state="translated">Абстрактные свойства и аксессуары</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes" xml:space="preserve">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="translated">Принимайте файлы JavaScript в качестве входных данных (с помощью &lt;code&gt;allowJs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes" xml:space="preserve">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="translated">Доступ к элементу,не входящему в набор известных индексов,заканчивается ошибкой:</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes" xml:space="preserve">
          <source>Accessor Decorators</source>
          <target state="translated">Декораторы для аксессуаров</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="63486368539a5a919d2c26a960c13aeb3604f62b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;declare module &quot;[libname]&quot; { }&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes" xml:space="preserve">
          <source>Add TypeScript</source>
          <target state="translated">Добавить TypeScript</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes" xml:space="preserve">
          <source>Add TypeScript code</source>
          <target state="translated">Добавить код TypeScript</target>
        </trans-unit>
        <trans-unit id="46b617acf1ae2b67fe01caa83a0ba7b8ee5a4ac7" translate="yes" xml:space="preserve">
          <source>Add TypeScript to your dev dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3415f2a3b0ab2d336eb4c1382554b771158a6ea" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;tsconfig.json&lt;/code&gt; to configure TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes" xml:space="preserve">
          <source>Add a TypeScript configuration file</source>
          <target state="translated">Добавить файл конфигурации TypeScript</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes" xml:space="preserve">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="translated">Добавьте сигнатуру индекса к слабому типу (например, &lt;code&gt;[propName: string]: {}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes" xml:space="preserve">
          <source>Add example code</source>
          <target state="translated">Добавить пример кода</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes" xml:space="preserve">
          <source>Add modules to the code</source>
          <target state="translated">Добавить модули в код</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes" xml:space="preserve">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="translated">Добавьте следующий код в файл &lt;code&gt;app.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b990890227ea0e4c75e4a3fe72a5643f059cf0" translate="yes" xml:space="preserve">
          <source>Add the template inside the braces of the declare module, and see where your usage breaks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6d6723ea89a80d4cba5523c3c76499f133755b" translate="yes" xml:space="preserve">
          <source>Adding TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">Добавление файла &lt;code&gt;tsconfig.json&lt;/code&gt; в каталог указывает на то, что каталог является корнем проекта TypeScript. В файле tsconfig.json указаны корневые файлы и параметры компилятора, необходимые для компиляции проекта. Проект компилируется одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="8c611c8266b493d4250ab1994cb67dac5e5d7db4" translate="yes" xml:space="preserve">
          <source>Adding new fields to an existing interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes" xml:space="preserve">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="translated">Добавление с использованием &lt;code&gt;namespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes" xml:space="preserve">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">Добавление с помощью &lt;code&gt;interface&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd37b199ac0e5e434243b868db9e5bf59fc0b12" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2015 (also known as ES6) - &lt;code&gt;array.find&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Reflect&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee0d1e5c7cb32ad383fffbe67322822cc7ffc56" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2016 - &lt;code&gt;array.include&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e994571e74a140e2c02e5a1c020db032be8f18" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2017 - &lt;code&gt;Object.entries&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Atomics&lt;/code&gt;, &lt;code&gt;SharedArrayBuffer&lt;/code&gt;, &lt;code&gt;date.formatToParts&lt;/code&gt;, typed arrays, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbb8fc3866150fbae3eb7909abccd9056ff25fb" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2018 - &lt;code&gt;async&lt;/code&gt; iterables, &lt;code&gt;promise.finally&lt;/code&gt;, &lt;code&gt;Intl.PluralRules&lt;/code&gt;, &lt;code&gt;rexexp.groups&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c596730da78330f273d9f27482a3622097fc44" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2019 - &lt;code&gt;array.flat&lt;/code&gt;, &lt;code&gt;array.flatMap&lt;/code&gt;, &lt;code&gt;Object.fromEntries&lt;/code&gt;, &lt;code&gt;string.trimStart&lt;/code&gt;, &lt;code&gt;string.trimEnd&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f239d6c54edfc279434f6bfed958b9f60c0681c3" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2020 - &lt;code&gt;string.matchAll&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5945ef8d12f1d6daf29632bc72ac7f3e5760f6" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ESNext - This changes as the JavaScript specification evolves</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes" xml:space="preserve">
          <source>Additional module resolution flags</source>
          <target state="translated">Дополнительные флаги разрешения модуля</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="translated">Кроме того, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;еще одно предостережение&lt;/a&gt; относительно этой новой функциональности заключается в том, что из-за определенных ограничений функции &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; еще не могут полностью моделировать общие функции или функции, которые имеют перегрузки. При использовании этих методов в универсальной функции параметры типа будут заменены пустым типом объекта ( &lt;code&gt;{}&lt;/code&gt; ), а при использовании в функции с перегрузками будет моделироваться только последняя перегрузка.</target>
        </trans-unit>
        <trans-unit id="15ac4ccfaca700b5bb61ababb10985733b43516f" translate="yes" xml:space="preserve">
          <source>Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes" xml:space="preserve">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Вдобавок генераторы просто предполагали, что тип &lt;code&gt;yield&lt;/code&gt; всегда был &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="translated">Кроме того, интерфейс &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; может использоваться для указания дополнительных свойств, используемых платформой JSX, которые обычно не используются реквизитами или аргументами компонентов - например, &lt;code&gt;key&lt;/code&gt; в React. Более того, общий &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; может также использоваться для указания того же типа дополнительных атрибутов только для компонентов класса (а не для функциональных компонентов). В этом типе универсальный параметр соответствует типу экземпляра класса. В React это используется для разрешения атрибута &lt;code&gt;ref&lt;/code&gt; типа &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; . Вообще говоря, все свойства в этих интерфейсах должны быть необязательными, если только вы не предполагаете, что пользователям вашей JSX-платформы необходимо предоставить какой-либо атрибут для каждого тега.</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes" xml:space="preserve">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="translated">Кроме того, чтобы сохранить совместимость с существующими рабочими процессами сборки, &lt;code&gt;tsc&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; будет автоматически строить зависимости, если не вызывается с переключателем &lt;code&gt;--build&lt;/code&gt; . Давайте узнаем больше о &lt;code&gt;--build&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes" xml:space="preserve">
          <source>Adjustments in module resolution logic</source>
          <target state="translated">Корректировка логики разрешения модуля</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes" xml:space="preserve">
          <source>Advanced Combinations</source>
          <target state="translated">Расширенные комбинации</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes" xml:space="preserve">
          <source>Advanced Techniques</source>
          <target state="translated">Передовая техника</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">Продвинутые темы</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">Расширенные типы</target>
        </trans-unit>
        <trans-unit id="fb80c67075198375c2e70ac850bebb21868957d3" translate="yes" xml:space="preserve">
          <source>After all, remember that all the convenience of &lt;code&gt;any&lt;/code&gt; comes at the cost of losing type safety. Type safety is one of the main motivations for using TypeScript and you should try to avoid using &lt;code&gt;any&lt;/code&gt; when not necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="translated">После вызова &lt;code&gt;bundle&lt;/code&gt; мы используем &lt;code&gt;source&lt;/code&gt; (наш псевдоним для vinyl-source-stream), чтобы назвать наш выходной пакет &lt;code&gt;bundle.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="408851febc5890c19a84d2e33af34c246f1e0287" translate="yes" xml:space="preserve">
          <source>After capturing the &lt;code&gt;div&lt;/code&gt; element, the &lt;code&gt;children&lt;/code&gt; prop will return a &lt;code&gt;HTMLCollection&lt;/code&gt; list containing the &lt;code&gt;HTMLParagraphElements&lt;/code&gt;. The &lt;code&gt;childNodes&lt;/code&gt; property will return a similar &lt;code&gt;NodeList&lt;/code&gt; list of nodes. Each &lt;code&gt;p&lt;/code&gt; tag will still be of type &lt;code&gt;HTMLParagraphElements&lt;/code&gt;, but the &lt;code&gt;NodeList&lt;/code&gt; can contain additional &lt;em&gt;HTML nodes&lt;/em&gt; that the &lt;code&gt;HTMLCollection&lt;/code&gt; list cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a74c2ec05571930c83fcba6df212a860c81677b" translate="yes" xml:space="preserve">
          <source>After compiling and running the &lt;em&gt;index.html&lt;/em&gt; page, the resulting HTML will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="translated">После этого вы сможете без проблем импортировать lodash и получать точные завершения.</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes" xml:space="preserve">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="translated">После вы должны увидеть папку &lt;code&gt;npm&lt;/code&gt; в проводнике решений.</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes" xml:space="preserve">
          <source>Again, being explicit, the following things create values:</source>
          <target state="translated">Опять же,если быть точным,следующие вещи создают ценности:</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes" xml:space="preserve">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="translated">Опять же,вышеприведенный код эквивалентен следующему.</target>
        </trans-unit>
        <trans-unit id="57d29b61eba4579f79786a30e1c6e7ebb0cec52d" translate="yes" xml:space="preserve">
          <source>Again, this isn&amp;rsquo;t an error because the &lt;em&gt;structures&lt;/em&gt; of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn&amp;rsquo;t be related are not common.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfe030bc3f42b42dc5c919d01197fcd0004b2c5" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;mdash; they&amp;rsquo;re independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="translated">Опять же, здесь мы использовали &lt;code&gt;Bar&lt;/code&gt; как тип, так и значение. Обратите внимание, что нам не нужно было объявлять значение &lt;code&gt;Bar&lt;/code&gt; как имеющее тип &lt;code&gt;Bar&lt;/code&gt; - они независимы.</target>
        </trans-unit>
        <trans-unit id="f0dcad08135c25e6858c7a0bc8fc97fa602084c7" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2015&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bc045865e0b8f9a9b71594259251243e592051" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2016&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes" xml:space="preserve">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="translated">Псевдонимы на самом деле не создают новый тип - они создают новое &lt;em&gt;имя&lt;/em&gt; для ссылки на этот тип. Псевдоним примитива не очень полезен, хотя его можно использовать как форму документации.</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes" xml:space="preserve">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="translated">Все зависимости управляются npm. Убедитесь, что все пакеты объявлений, от которых вы зависите, отмечены соответствующим образом в разделе &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; вашего &lt;code&gt;package.json&lt;/code&gt; . Например, представьте, что мы создали пакет, использующий Browserify и TypeScript.</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="translated">Все файлы реализации должны соответствовать шаблону &lt;code&gt;include&lt;/code&gt; или перечислены в массиве &lt;code&gt;files&lt;/code&gt; . Если это ограничение нарушено, &lt;code&gt;tsc&lt;/code&gt; сообщит вам, какие файлы не были указаны</target>
        </trans-unit>
        <trans-unit id="4e5c880db21c996cec3fc4988c560583fa9982e1" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Все операции импорта из сокращенного модуля будут иметь &lt;code&gt;any&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="translated">Все импорты из короткосрочного модуля будут иметь любой тип.</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes" xml:space="preserve">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="translated">Любой импорт в любой модуль из &lt;code&gt;myLibrary&lt;/code&gt; будет рассматриваться компилятором как имеющий тип &lt;code&gt;any&lt;/code&gt; ; таким образом, прекращая любые проверки форм или типов этих модулей.</target>
        </trans-unit>
        <trans-unit id="711241f4a2d9733149f5b0fa0a9c433a6be2957f" translate="yes" xml:space="preserve">
          <source>All of the above types have a field named &lt;code&gt;state&lt;/code&gt;, and then they also have their own fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes" xml:space="preserve">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="translated">Все нижеприведенное - это красные флажки для структурирования модуля. Дважды убедитесь, что вы не пытаетесь создать пространство имен для внешних модулей, если что-либо из этого применимо к вашим файлам:</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes" xml:space="preserve">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">Все относительные пути,найденные в конфигурационном файле,будут разрешены относительно файла конфигурации,в котором они были созданы.</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes" xml:space="preserve">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="translated">Все флаги строгости (в том числе только &lt;code&gt;strict&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes" xml:space="preserve">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="fc58b8ed05bcec6a23ae0f9b780d0d812c7a4f62" translate="yes" xml:space="preserve">
          <source>Allow JS - &lt;code&gt;allowJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="translated">Позвольте скомпилировать JavaScript-файлы.</target>
        </trans-unit>
        <trans-unit id="4127f7dca17f65d3e9f2da7cd048b313c157835a" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be imported inside your project, instead of just &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files. For example, this JS file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5f4564c78948840747ee82f21c0e6f8232869a" translate="yes" xml:space="preserve">
          <source>Allow Synthetic Default Imports - &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03080da287c39d6533842b0d5b99bb15bf6a11b4" translate="yes" xml:space="preserve">
          <source>Allow Umd Global Access - &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f45a74002920f6a947fa3ad7930927614185e1d" translate="yes" xml:space="preserve">
          <source>Allow Unreachable Code - &lt;code&gt;allowUnreachableCode&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c098cda1fb5e0449f54b4fa69bd2ca68f4c38505" translate="yes" xml:space="preserve">
          <source>Allow Unused Labels - &lt;code&gt;allowUnusedLabels&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes" xml:space="preserve">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="translated">Разрешить доступ к глобусам UMD из модулей.</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes" xml:space="preserve">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="translated">Разрешить захваченные &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; в циклах</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes" xml:space="preserve">
          <source>Allow comments in tsconfig.json</source>
          <target state="translated">Разрешить комментарии в tsconfig.json</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes" xml:space="preserve">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="translated">Разрешить импорт по умолчанию из модулей без экспорта по умолчанию.Это не влияет на эмиссию кода,а только на набор текста.</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes" xml:space="preserve">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="translated">Разрешить дублирование идентификаторов в декларациях</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes" xml:space="preserve">
          <source>Allowed Values</source>
          <target state="translated">Допустимые значения</target>
        </trans-unit>
        <trans-unit id="51d3649666c81adc66e5aee277f0deb4bbad2747" translate="yes" xml:space="preserve">
          <source>Allowed:</source>
          <target state="translated">Allowed:</target>
        </trans-unit>
        <trans-unit id="e0a0783e9856d0e09d989d44bcf6f4ac7421085b" translate="yes" xml:space="preserve">
          <source>Allows importing modules with a &amp;lsquo;.json&amp;rsquo; extension, which is a common practice in node projects. This includes generating a type for the &lt;code&gt;import&lt;/code&gt; based on the static JSON shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc170000d6a67459bf8aeff3519c663382fe747" translate="yes" xml:space="preserve">
          <source>Almost all features of an &lt;code&gt;interface&lt;/code&gt; are available in &lt;code&gt;type&lt;/code&gt;, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7d1a9e4958d2fb8851168702553d5b6855aea3" translate="yes" xml:space="preserve">
          <source>Almost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes" xml:space="preserve">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="translated">Наряду с настройкой &lt;code&gt;--strict&lt;/code&gt; on по умолчанию, &lt;code&gt;tsc --init&lt;/code&gt; имеет расширенный вывод. Файлы &lt;code&gt;tsconfig.json&lt;/code&gt; по умолчанию, созданные командой &lt;code&gt;tsc --init&lt;/code&gt; , теперь включают набор общих параметров компилятора с закомментированными описаниями. Просто не комментируйте конфигурацию, которую вы хотите установить, чтобы получить желаемое поведение; мы надеемся, что новый вывод упростит настройку новых проектов и сохранит файлы конфигурации доступными для чтения по мере роста проектов.</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes" xml:space="preserve">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="translated">Наряду с традиционными иерархиями ОП,еще одним популярным способом построения классов из многократно используемых компонентов является их построение путем объединения более простых частичных классов.Вы можете быть знакомы с идеей смешивания или особенностей таких языков,как Scala,и этот шаблон также достиг некоторой популярности в сообществе JavaScript.</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes" xml:space="preserve">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="translated">Также неиспользуемыми считаются функции,вызываемые только внутри собственных тел.</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes" xml:space="preserve">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="translated">Также важно отметить, что &lt;code&gt;bigint&lt;/code&gt; создает новую строку при использовании оператора &lt;code&gt;typeof&lt;/code&gt; : строку &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; . Таким образом, TypeScript правильно сужает использование &lt;code&gt;typeof&lt;/code&gt; , как и следовало ожидать.</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes" xml:space="preserve">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="translated">Также обратите внимание, что если ваш основной файл объявлений называется &lt;code&gt;index.d.ts&lt;/code&gt; и находится в корне пакета (рядом с &lt;code&gt;index.js&lt;/code&gt; ), вам не нужно отмечать свойство &lt;code&gt;&quot;types&quot;&lt;/code&gt; , хотя это рекомендуется сделать.</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes" xml:space="preserve">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что при передаче &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt; компилятор пропустит проверку файлов только с &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes" xml:space="preserve">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="translated">Также следует отметить, что использование &lt;code&gt;public&lt;/code&gt; в аргументах конструктора является сокращением, которое позволяет нам автоматически создавать свойства с этим именем.</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes" xml:space="preserve">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="translated">Также см. Нашу вики-страницу об &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;использовании файла пользовательской языковой службы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes" xml:space="preserve">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="translated">Кроме того, на &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt; доступен ночной пакет NuGet, соответствующий &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;ночному пакету npm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc2ac39874f5d402cff8a6371fac18a2bf87ae7f" translate="yes" xml:space="preserve">
          <source>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc570dc40e9dd67a1355d20ed4669b96242c78db" translate="yes" xml:space="preserve">
          <source>Alternative Pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="translated">В качестве альтернативы мы можем использовать компиляцию для каждого файла (по умолчанию), чтобы создать один файл JavaScript для каждого входного файла. Если создается несколько файлов JS, нам нужно будет использовать теги &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; на нашей веб-странице для загрузки каждого отправляемого файла в соответствующем порядке, например:</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="translated">В качестве альтернативы вы можете просто сказать, что у &lt;code&gt;options&lt;/code&gt; есть тип &lt;code&gt;any&lt;/code&gt; , что проще всего сделать, но принесет вам наименьшую пользу.</target>
        </trans-unit>
        <trans-unit id="14390732b26f6b4f21409bfe475cf716ae549d14" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use a per-file pragma to set this option, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes" xml:space="preserve">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes" xml:space="preserve">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="translated">Хотя модули JavaScript не поддерживают слияние, вы можете исправить существующие объекты, импортировав и затем обновив их. Давайте посмотрим на игрушечный пример наблюдаемого:</target>
        </trans-unit>
        <trans-unit id="e5310a8c4e94d0ca71a8f44c68a436f3effe3b6a" translate="yes" xml:space="preserve">
          <source>Always Strict - &lt;code&gt;alwaysStrict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes" xml:space="preserve">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="translated">Окружающие классы и функции могут быть объединены</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes" xml:space="preserve">
          <source>Ambient Modules</source>
          <target state="translated">Модули окружения</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes" xml:space="preserve">
          <source>Ambient Namespaces</source>
          <target state="translated">Имена окружения</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes" xml:space="preserve">
          <source>Ambient enums</source>
          <target state="translated">Окружающие перечисления</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes" xml:space="preserve">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="translated">Окружающие перечисления используются для описания формы уже существующих типов перечислений.</target>
        </trans-unit>
        <trans-unit id="b111c707b73d7237aae28fc1288868f165c43e0a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;FString&lt;/code&gt; is just like a normal string, except that the compiler thinks it has a property named &lt;code&gt;__compileTimeOnly&lt;/code&gt; that doesn&amp;rsquo;t actually exist. This means that &lt;code&gt;FString&lt;/code&gt; can still be assigned to &lt;code&gt;string&lt;/code&gt;, but not the other way round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; декларации</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="translated">Объявление &lt;code&gt;import&lt;/code&gt; которое относится к типу</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; декларация , которая относится к значению</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;Accessor декоратор&lt;/em&gt; объявляется только перед декларацией аксессора. Декоратор средства доступа применяется к &lt;em&gt;дескриптору свойства&lt;/em&gt; для средства доступа и может использоваться для наблюдения, изменения или замены определений средства доступа. Декоратор средства доступа не может использоваться в файле объявления или в любом другом окружающем контексте (например, в классе &lt;code&gt;declare&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="translated">&lt;em&gt;Функции асинхронных&lt;/em&gt; является функцией или метода , который был приставка с &lt;code&gt;async&lt;/code&gt; модификатором. Этот модификатор сообщает компилятору, что требуется транспонирование тела функции и что ключевое слово &lt;code&gt;await&lt;/code&gt; следует рассматривать как унарное выражение вместо идентификатора. &lt;em&gt;Асинхронный Функция&lt;/em&gt; должна обеспечивать возврат аннотацию типа , что указывает на совместимом &lt;code&gt;Promise&lt;/code&gt; типа. Вывод типа возвращаемого значения можно использовать только в том случае, если существует глобально определенный совместимый тип &lt;code&gt;Promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes" xml:space="preserve">
          <source>An Example Project</source>
          <target state="translated">Примерный проект</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes" xml:space="preserve">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="translated">IIFE,возвращающий функцию,класс или литерал пустого объекта,также распознается как пространство имен:</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes" xml:space="preserve">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="translated">Объект, чьи собственные имена свойств являются именами свойств, которые исключены из привязок среды &amp;laquo;с&amp;raquo; для связанных объектов.</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes" xml:space="preserve">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="translated">Абстрактный класс может объявлять абстрактные свойства и/или аксессуары.Любой подкласс должен объявить абстрактные свойства или быть помечен как абстрактный.Свойства абстрактного класса не могут иметь инициализатор.Аксессоры абстрактных свойств не могут иметь тело.</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes" xml:space="preserve">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="translated">Сущность, доступ к которой осуществляется через импорт пространства имен ES2015, считается доступным только для чтения (например, &lt;code&gt;foo.x&lt;/code&gt; доступен только для чтения, когда &lt;code&gt;foo&lt;/code&gt; объявлен как &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes" xml:space="preserve">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="translated">Сущность, объявленная в операторе &lt;code&gt;import&lt;/code&gt; считается доступной только для чтения.</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes" xml:space="preserve">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="translated">Объявление перечисления ( &lt;code&gt;enum E { A, B, C }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0f0c7003bdcd58ff3b43d23382bd37a83d58b4a2" translate="yes" xml:space="preserve">
          <source>An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can&amp;rsquo;t access it with an import.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes" xml:space="preserve">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="translated">Декларация экспорта по умолчанию задает выражение,которое становится экспортом модуля по умолчанию:</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes" xml:space="preserve">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="translated">Импорт в модуль без файла декларации по-прежнему будет отмечен как ошибка в параметре &lt;code&gt;--noImplicitAny&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes" xml:space="preserve">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="translated">Важным правилом является то, что декларации &lt;code&gt;export&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; экспортируют или импортируют &lt;em&gt;все значения&lt;/em&gt; своих целей.</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes" xml:space="preserve">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;keyof T&lt;/code&gt; индексного типа T для некоторого типа &lt;code&gt;T&lt;/code&gt; является подтипом &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes" xml:space="preserve">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="translated">Интерфейс может расширять несколько интерфейсов,создавая комбинацию всех интерфейсов.</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes" xml:space="preserve">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="translated">Объявление интерфейса ( &lt;code&gt;interface I { x: number[]; }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes" xml:space="preserve">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">Тип пересечения объединяет несколько типов в один. Это позволяет вам складывать существующие типы, чтобы получить единый тип, обладающий всеми необходимыми функциями. Например, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; - это &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;и &lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; . Это означает, что объект этого типа будет иметь все члены всех трех типов.</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes" xml:space="preserve">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="translated">Объект считается итеративным, если он имеет реализацию для свойства &lt;a href=&quot;symbols#symboliterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; . Для некоторых встроенных типов, таких как &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Int32Array&lt;/code&gt; , &lt;code&gt;Uint32Array&lt;/code&gt; и т. &lt;code&gt;Symbol.iterator&lt;/code&gt; Уже реализовано свойство Symbol.iterator . Функция &lt;code&gt;Symbol.iterator&lt;/code&gt; объекта отвечает за возврат списка значений для итерации.</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes" xml:space="preserve">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="translated">Буквальный тип объекта теперь присваивается типу с индексной сигнатурой,если все известные свойства в буквальном объекте присваиваются этой индексной сигнатуре.Это позволяет передавать переменную,которая была инициализирована с помощью объектного литерала в качестве параметра,в функцию,которая ожидает карту или словарь:</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes" xml:space="preserve">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="translated">Объект, поддерживающий асинхронную итерацию, называется &amp;laquo;итеративным&amp;raquo;, если он имеет метод &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; , который возвращает объект &lt;code&gt;AsyncIterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes" xml:space="preserve">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="translated">Операнд считается допускающим значение NULL, если тип операнда имеет значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; или тип объединения, который включает &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Обратите внимание, что случай типа объединения встречается только в режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; , потому что &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; исчезают из объединений в классическом режиме проверки типов.</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes" xml:space="preserve">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="translated">Неопределенный тип аргумента в JSDoc по умолчанию равен любому:</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes" xml:space="preserve">
          <source>And help in Japanese:</source>
          <target state="translated">И помощь по-японски:</target>
        </trans-unit>
        <trans-unit id="dd197d67b41beb4bb9080f0bf626d0c8feceb7c4" translate="yes" xml:space="preserve">
          <source>And it does so while you are typing, so that after typing &lt;code&gt;o.&lt;/code&gt;, you get completions for the property &lt;code&gt;inference&lt;/code&gt;, along with any other properties you&amp;rsquo;d have in a real program. Altogether, this feature can make TypeScript&amp;rsquo;s inference look a bit like a unifying type inference engine, but it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d2481f5dabbff44ec8dc3190a715bb12f127f0" translate="yes" xml:space="preserve">
          <source>And it has a specific &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes" xml:space="preserve">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="translated">И точно так же,как и сигнатуры предикатов типов,эти сигнатуры утверждений невероятно выразительны.С их помощью мы можем выразить несколько довольно сложных идей.</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes" xml:space="preserve">
          <source>And results in</source>
          <target state="translated">И в результате</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes" xml:space="preserve">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">А другой - &lt;code&gt;as&lt;/code&gt; -синтаксис:</target>
        </trans-unit>
        <trans-unit id="cb4e175c07b2c59dcc273c9702501096dcd31801" translate="yes" xml:space="preserve">
          <source>And this also generates this json map:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes" xml:space="preserve">
          <source>And to use it:</source>
          <target state="translated">И использовать его:</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes" xml:space="preserve">
          <source>And usage would be:</source>
          <target state="translated">И использование было бы:</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes" xml:space="preserve">
          <source>And with parameters to a function:</source>
          <target state="translated">И с параметрами функции:</target>
        </trans-unit>
        <trans-unit id="35f50d63beef167dd9ca426c97e6076057b81ce3" translate="yes" xml:space="preserve">
          <source>And you can use an expression of type &lt;code&gt;any&lt;/code&gt; anywhere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes" xml:space="preserve">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="translated">А для кода preES2015 он может быть использован для симуляции статических методов:</target>
        </trans-unit>
        <trans-unit id="ec45c0ce446cf8fa2dd6d9617073a81b5ee50c12" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">Еще одна функция ECMAScript 2015, которую имеет TypeScript, - это деструктуризация. Полную справку см. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;В статье о сети разработчиков Mozilla&lt;/a&gt; . В этом разделе мы дадим краткий обзор.</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes" xml:space="preserve">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="translated">Еще одно отличие состоит в том, что &lt;code&gt;for..in&lt;/code&gt; работает с любым объектом; он служит способом проверки свойств этого объекта. &lt;code&gt;for..of&lt;/code&gt; , с другой стороны, в основном интересуют значения итерируемых объектов. Встроенные объекты, такие как &lt;code&gt;Map&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt; , реализуют свойство &lt;code&gt;Symbol.iterator&lt;/code&gt; , позволяющее получить доступ к сохраненным значениям.</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes" xml:space="preserve">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="translated">Другой пример - псевдоним типа &lt;code&gt;TypeName&lt;/code&gt; , который использует вложенные условные типы:</target>
        </trans-unit>
        <trans-unit id="08d5a0729b5af0f7633b6230c048cf4b29055065" translate="yes" xml:space="preserve">
          <source>Another frequent source of surprise comes with identical types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes" xml:space="preserve">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="translated">Другая фундаментальная часть создания программ на JavaScript для веб-страниц и серверов - это работа с текстовыми данными. Как и в других языках, мы используем &lt;code&gt;string&lt;/code&gt; типа для ссылки на эти текстовые типы данных. Как и JavaScript, TypeScript также использует двойные кавычки ( &lt;code&gt;&quot;&lt;/code&gt; ) или одинарные кавычки ( &lt;code&gt;'&lt;/code&gt; ) для окружения строковых данных.</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes" xml:space="preserve">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Еще одна хорошая практика - иметь файл &amp;laquo;решение&amp;raquo; &lt;code&gt;tsconfig.json&lt;/code&gt; , который просто содержит &lt;code&gt;references&lt;/code&gt; на все ваши проекты листовых узлов и устанавливает &lt;code&gt;files&lt;/code&gt; в пустой массив (в противном случае файл решения вызовет двойную компиляцию файлов). Обратите внимание, что начиная с версии 3.0 пустой массив &lt;code&gt;files&lt;/code&gt; больше не является ошибкой, если у вас есть хотя бы одна &lt;code&gt;reference&lt;/code&gt; в файле &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes" xml:space="preserve">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="translated">Еще одно свойство переменных с блочной областью видимости состоит в том, что их нельзя прочитать или записать до того, как они будут фактически объявлены. Хотя эти переменные &amp;laquo;присутствуют&amp;raquo; во всей их области видимости, все точки до их объявления являются частью их &lt;em&gt;временной мертвой зоны&lt;/em&gt; . Это просто изощренный способ сказать, что вы не можете получить к ним доступ до оператора &lt;code&gt;let&lt;/code&gt; , и, к счастью, TypeScript сообщит вам об этом.</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes" xml:space="preserve">
          <source>Another simple way is to use class expressions:</source>
          <target state="translated">Другой простой способ-использование выражений классов:</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes" xml:space="preserve">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="translated">Еще одна вещь, о которой следует помнить, - это то, что &lt;code&gt;const&lt;/code&gt; контексты не сразу преобразуют выражение в полностью неизменное.</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes" xml:space="preserve">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="translated">Другой способ упростить работу с пространствами имен - использовать &lt;code&gt;import q = x.y.z&lt;/code&gt; для создания более коротких имен для часто используемых объектов. Не путать с синтаксисом &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; используемым для загрузки модулей, этот синтаксис просто создает псевдоним для указанного символа. Вы можете использовать эти виды импорта (обычно называемые псевдонимами) для любого типа идентификатора, включая объекты, созданные из импорта модуля.</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes" xml:space="preserve">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="translated">Другой способ описать пример - это то, что тип &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; является &lt;em&gt;бивариантным&lt;/em&gt; (т. &lt;em&gt;Е.&lt;/em&gt; Ковариантным &lt;em&gt;или&lt;/em&gt; контравариантным) для &lt;code&gt;T&lt;/code&gt; в режиме проверки типа по умолчанию, но &lt;em&gt;контравариантным&lt;/em&gt; для &lt;code&gt;T&lt;/code&gt; в режиме строгих типов функций.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes" xml:space="preserve">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="translated">Любое объявление (например, переменная, функция, класс, псевдоним типа или интерфейс) можно экспортировать, добавив ключевое слово &lt;code&gt;export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes" xml:space="preserve">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="translated">Также включаются любые файлы, на которые ссылаются файлы, включенные через свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt; или &lt;code&gt;&quot;include&quot;&lt;/code&gt; . Точно так же, если на файл &lt;code&gt;B.ts&lt;/code&gt; ссылается другой файл &lt;code&gt;A.ts&lt;/code&gt; , то &lt;code&gt;B.ts&lt;/code&gt; не может быть исключен, если ссылающийся файл &lt;code&gt;A.ts&lt;/code&gt; также не указан в списке &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b984d3931194d80c596d87494a4cd0260323982" translate="yes" xml:space="preserve">
          <source>Any identifier or dotted identifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes" xml:space="preserve">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="translated">Любые дополнительные параметры должны соответствовать требуемым параметрам.Если бы мы хотели сделать опциональным имя,а не фамилию,нам бы пришлось изменить порядок следования параметров в функции,поместив фамилию в список.</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes" xml:space="preserve">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="translated">Любой другой импорт считается &lt;strong&gt;неродственным&lt;/strong&gt; . Вот некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes" xml:space="preserve">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;isFish&lt;/code&gt; вызывается с некоторой переменной, TypeScript &lt;em&gt;сужает&lt;/em&gt; эту переменную до этого конкретного типа, если исходный тип совместим.</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes" xml:space="preserve">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="translated">Любая переменная,параметр или свойство,инициализированное нулевым или неопределенным,будет иметь тип any,даже если включена строгая нулевая проверка.Любая переменная,параметр или свойство,которое инициализируется с помощью [],будет иметь тип any[],даже если включена строгая нулевая проверка.Единственным исключением являются свойства,которые имеют несколько инициализаторов,как описано выше.</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes" xml:space="preserve">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="translated">Везде, где ожидается приветствие, вы можете указать &lt;code&gt;string&lt;/code&gt; , функцию, возвращающую &lt;code&gt;string&lt;/code&gt; , или экземпляр &lt;code&gt;Greeter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes" xml:space="preserve">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="translated">Приложения Apache Cordova по-прежнему имеют ограничение в виде одного файла &lt;code&gt;tsconfig.json&lt;/code&gt; , который должен находиться либо в корневой папке, либо в папке &lt;code&gt;scripts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes" xml:space="preserve">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">Применяя &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;принцип наименьших привилегий&lt;/a&gt; , все объявления, кроме тех, которые вы планируете изменить, должны использовать &lt;code&gt;const&lt;/code&gt; . Обоснование состоит в том, что если переменная не нуждалась в записи, другие, работающие с той же кодовой базой, не должны автоматически иметь возможность писать в объект, и им нужно будет подумать, действительно ли им нужно переназначить переменную. Использование &lt;code&gt;const&lt;/code&gt; также делает код более предсказуемым при рассмотрении потока данных.</target>
        </trans-unit>
        <trans-unit id="feeba9502a1e0f85eacb0af7f74c1820da8711e4" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">Разрушение массивов</target>
        </trans-unit>
        <trans-unit id="e6ac01c9abf0d89c7b3cace9c5d3ec391bebfef5" translate="yes" xml:space="preserve">
          <source>Arrow functions use the contextual type to type their parameters, so the compiler gives &lt;code&gt;o: { inference: string }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes" xml:space="preserve">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; , что при использовании strictNullChecks вам может потребоваться обновить зависимости, чтобы также использовать &lt;code&gt;strictNullChecks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes" xml:space="preserve">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="translated">В качестве приятного бонуса это также может уменьшить объем памяти и время выполнения компилятора и языковой службы, избегая загрузки файлов &lt;code&gt;.d.ts&lt;/code&gt; из повторяющихся пакетов.</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes" xml:space="preserve">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="translated">В качестве примечания: мы поощряем использование &lt;code&gt;--strictNullChecks&lt;/code&gt; , когда это возможно, но для целей этого руководства мы предполагаем, что он отключен.</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes" xml:space="preserve">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="translated">В результате TypeScript 3.2 рассматривает свойство &lt;code&gt;error&lt;/code&gt; в следующем примере как дискриминант, тогда как раньше это было не так, поскольку &lt;code&gt;Error&lt;/code&gt; не является одноэлементным типом. Благодаря этому сужение правильно работает в теле функции &lt;code&gt;unwrap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes" xml:space="preserve">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="translated">В результате,пользователи могут писать геттеры и сеттеры в окружающих контекстах в TypeScript 3.6.</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes" xml:space="preserve">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="translated">В качестве альтернативы индивидуальному импорту можно использовать импорт пространства имен для импорта целого модуля:</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes" xml:space="preserve">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="translated">В результате вы можете заметить новые ошибки:</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes" xml:space="preserve">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="translated">В качестве примера некоторых типов,которые сразу же разрешаются,можно рассмотреть следующий пример:</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes" xml:space="preserve">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="translated">В качестве примера рассмотрим необходимость экранирования строки, содержащей символ &amp;laquo;𠮷&amp;raquo;. В UTF-16 / UCS2 символ &amp;laquo;&amp;raquo; представлен как суррогатная пара, что означает, что он закодирован с использованием пары 16-битных кодовых единиц значений, в частности &lt;code&gt;0xD842&lt;/code&gt; и &lt;code&gt;0xDFB7&lt;/code&gt; . Раньше это означало, что вам нужно было экранировать &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; как &amp;laquo;\ uD842 \ uDFB7&amp;raquo; . У этого есть главный недостаток - трудно отличить двух независимых персонажей от суррогатной пары.</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes" xml:space="preserve">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="translated">В качестве примера,получение деклараций для такой библиотеки,как lodash,занимает не более чем следующую команду</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes" xml:space="preserve">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="translated">Например, во многих Unix-подобных системах стандартный поток вывода доступен через файл &lt;code&gt;/dev/stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes" xml:space="preserve">
          <source>As an example, the following code snippet</source>
          <target state="translated">В качестве примера,следующий фрагмент кода</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes" xml:space="preserve">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="translated">В качестве примера мы можем передать наш сгенерированный JavaScript в симпатичный принтер, такой как &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8666bb34a3e7a42811e6cf8b7eec3430f6ecf39a" translate="yes" xml:space="preserve">
          <source>As another example, this is JavaScript code that you can run in your browser, and it &lt;em&gt;will&lt;/em&gt; log a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4eabd9999e1e12bdc9f231452f5d0852a3e159" translate="yes" xml:space="preserve">
          <source>As another example, this is JavaScript code that you can run in your browser, and it &lt;em&gt;will&lt;/em&gt; print a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes" xml:space="preserve">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="translated">Как обсуждалось ранее, компилятор может посещать файлы за пределами текущей папки при разрешении модуля. Это может быть сложно при диагностике, почему модуль не разрешен или разрешен до неправильного определения. Включение трассировки разрешения модуля компилятора с помощью &lt;code&gt;--traceResolution&lt;/code&gt; дает представление о том, что произошло в процессе разрешения модуля.</target>
        </trans-unit>
        <trans-unit id="2af5d0e8e829dfb3c74ed1966383405987ec7afa" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;, while BigIntegers get the type &lt;code&gt;bigint&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">Как и в JavaScript, все числа в TypeScript являются значениями с плавающей запятой. Эти числа с плавающей запятой получают &lt;code&gt;number&lt;/code&gt; типа . Помимо шестнадцатеричных и десятичных литералов, TypeScript также поддерживает двоичные и восьмеричные литералы, представленные в ECMAScript 2015.</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes" xml:space="preserve">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="translated">Пока типы параметров совпадают, он считается допустимым типом для функции, независимо от имен, которые вы даете параметрам в типе функции.</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes" xml:space="preserve">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="translated">Как упоминалось выше, TypeScript теперь выдает ошибку, когда кажется, что функции не вызываются в условиях оператора &lt;code&gt;if&lt;/code&gt; . Ошибка выдается, когда тип функции проверяется, &lt;code&gt;if&lt;/code&gt; условия, если не выполняется любое из следующих условий:</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="translated">Как упоминалось в &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;нашем разделе о перечислениях&lt;/a&gt; , члены перечисления имеют типы, когда каждый член инициализируется буквально.</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes" xml:space="preserve">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="translated">По мере роста нашего приложения мы захотим разделить код на несколько файлов, чтобы упростить его обслуживание.</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes" xml:space="preserve">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">В рамках работы над сигнатурами утверждения TypeScript необходимо было больше кодировать информацию о том, где и какие функции вызываются. Это дало нам возможность расширить поддержку другого класса функций: функций, которые &lt;code&gt;never&lt;/code&gt; возвращаются .</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes" xml:space="preserve">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">Как указано в ECMAScript, смешивание &lt;code&gt;number&lt;/code&gt; s и &lt;code&gt;bigint&lt;/code&gt; в арифметических операциях является ошибкой. Вам нужно будет явно преобразовать значения в &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes" xml:space="preserve">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="translated">Таким образом,при оценке нескольких декораторов на одной декларации в TypeScript выполняются следующие шаги:</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes" xml:space="preserve">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="translated">Как следует из названия, компонент определяется как функция JavaScript, первым аргументом которой является объект &lt;code&gt;props&lt;/code&gt; . TS требует, чтобы его возвращаемый тип мог быть назначен &lt;code&gt;JSX.Element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes" xml:space="preserve">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="translated">По мере того, как мы добавляем больше валидаторов, нам понадобится какая-то схема организации, чтобы мы могли отслеживать наши типы и не беспокоиться о конфликтах имен с другими объектами. Вместо того, чтобы помещать множество разных имен в глобальное пространство имен, давайте объединим наши объекты в пространство имен.</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes" xml:space="preserve">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="translated">Как мы уже говорили в &lt;a href=&quot;classes&quot;&gt;нашем разделе о классах&lt;/a&gt; , у класса есть две стороны своего типа: статическая сторона и сторона экземпляра. Универсальные классы являются универсальными только на их стороне экземпляра, а не на их статической стороне, поэтому при работе с классами статические члены не могут использовать параметр типа класса.</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes" xml:space="preserve">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="translated">По мере того, как мы улучшаем игровую площадку и веб-сайт, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;мы приветствуем отзывы и запросы на включение на GitHub&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="translated">Как мы упоминали ранее, интерфейсы могут описывать разнообразные типы, присутствующие в реальном JavaScript. Из-за динамического и гибкого характера JavaScript вы можете иногда встретить объект, который работает как комбинация некоторых из типов, описанных выше.</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes" xml:space="preserve">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="translated">Как мы уже упоминали, поддержка BigInt доступна только для цели &lt;code&gt;esnext&lt;/code&gt; . Это может быть неочевидно, но поскольку BigInts имеют разное поведение для математических операторов, таких как &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; и т. Д., Обеспечение функциональности для более старых целей, где такой функции не существует (например, &lt;code&gt;es2017&lt;/code&gt; и ниже), потребует переписывания каждой из этих операций. . TypeScript необходимо будет обеспечить правильное поведение в зависимости от типа, поэтому каждое добавление, конкатенация строк, умножение и т. Д. Будет включать вызов функции.</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes" xml:space="preserve">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="translated">Как мы уже упоминали,псевдонимы типов могут действовать вроде как интерфейсы;однако,есть некоторые тончайшие различия.</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="translated">Как мы уже говорили в предыдущей секции,объявление класса создает две вещи:тип,представляющий экземпляры класса,и функцию конструктора.Так как классы создают типы,вы можете использовать их в тех же местах,где вы могли бы использовать интерфейсы.</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes" xml:space="preserve">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="translated">Как и генераторы, асинхронные генераторы могут быть только объявлениями функций, функциональными выражениями или методами классов или объектных литералов. Стрелочные функции не могут быть асинхронными генераторами. Асинхронным генераторам требуется действующая глобальная реализация &lt;code&gt;Promise&lt;/code&gt; (либо собственная, либо совместимая с ES2015 полифилом) в дополнение к действительной ссылке на &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; (либо собственный символ, либо прокладка).</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes" xml:space="preserve">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="translated">Как и в случае с массивами, вы можете деструктурировать остальную часть кортежа с помощью &lt;code&gt;...&lt;/code&gt; , чтобы получить более короткий кортеж:</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes" xml:space="preserve">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="translated">Как и в случае с функциями утверждения, вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;прочитать больше в том же запросе на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13942b127f03a86eed04c8af9e4662496adae711" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of &lt;a href=&quot;#module&quot;&gt;a UMD&lt;/a&gt; module, so be sure to check the code or documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3372ff621e28f822343e068460ca63e4e82800" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of &lt;a href=&quot;#umd&quot;&gt;a UMD&lt;/a&gt; module, so be sure to check the code or documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="translated">Как и в случае с глобальными модулями,вы можете увидеть эти примеры в документации модуля UMD,поэтому обязательно ознакомьтесь с кодом или документацией.</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes" xml:space="preserve">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Как и в случае с типами, вы, вероятно, уже понимаете, что такое значение. Значения - это имена среды выполнения, на которые мы можем ссылаться в выражениях. Например, &lt;code&gt;let x = 5;&lt;/code&gt; создает значение, называемое &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes" xml:space="preserve">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">Как вы могли догадаться, мы только что объявили переменную с именем &lt;code&gt;a&lt;/code&gt; со значением &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes" xml:space="preserve">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="translated">При вводе текста в поле появляется/изменяется сообщение!</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes" xml:space="preserve">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="translated">Спросите файл с именем &lt;code&gt;/root/src/moduleB.js&lt;/code&gt; , если он существует.</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="translated">Спросите папку &lt;code&gt;/root/src/moduleB&lt;/code&gt; , содержит ли она файл с именем &lt;code&gt;index.js&lt;/code&gt; . Этот файл неявно считается &amp;laquo;основным&amp;raquo; модулем папки.</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="translated">Спросите папку &lt;code&gt;/root/src/moduleB&lt;/code&gt; , содержит ли она файл с именем &lt;code&gt;package.json&lt;/code&gt; , который определяет &lt;code&gt;&quot;main&quot;&lt;/code&gt; модуль. В нашем примере, если Node.js обнаружил файл &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; , содержащий &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt; , то Node.js будет ссылаться на &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes" xml:space="preserve">
          <source>Assertion Functions</source>
          <target state="translated">Функции утверждения</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes" xml:space="preserve">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="translated">Утверждения в JavaScript часто используются для защиты от неправильных типов передаваемых данных.Например,</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes" xml:space="preserve">
          <source>Assigned-before-use checking</source>
          <target state="translated">проверка по назначению</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes" xml:space="preserve">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="translated">Присваивание типам объединения работает очень интуитивно - все, что вы можете назначить одному из членов типа объединения, можно назначить объединению:</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes" xml:space="preserve">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="translated">Назначения на верхнем уровне должны вести себя так же; другими словами, объявление &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; не требуется.</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes" xml:space="preserve">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">Присвоения &lt;code&gt;exports&lt;/code&gt; или &lt;code&gt;module.exports&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes" xml:space="preserve">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">Присваивание свойствам &lt;code&gt;window&lt;/code&gt; или &lt;code&gt;global&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d5e5ece4fa70386a240680d096df0f39138ad3f" translate="yes" xml:space="preserve">
          <source>Assume Changes Only Affect Direct Dependencies - &lt;code&gt;assumeChangesOnlyAffectDirectDependencies&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes" xml:space="preserve">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="translated">Предположим, что каждый из этих модулей экспортирует массив строк. Например &lt;code&gt;./zh/messages&lt;/code&gt; может содержать:</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="translated">Предполагая, что &lt;code&gt;__dirname&lt;/code&gt; всегда доступен в &lt;code&gt;import.meta&lt;/code&gt; , объявление будет выполнено путем повторного &lt;code&gt;ImportMeta&lt;/code&gt; интерфейса ImportMeta :</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes" xml:space="preserve">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="translated">Предположения , что DOM примитивов , как &lt;code&gt;document&lt;/code&gt; или &lt;code&gt;window&lt;/code&gt; EXIST</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes" xml:space="preserve">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="translated">Проницательные читатели заметят, что, например, &lt;code&gt;class&lt;/code&gt; появился как в списках &lt;em&gt;типов, так&lt;/em&gt; и в списках &lt;em&gt;значений&lt;/em&gt; . Объявление &lt;code&gt;class C { }&lt;/code&gt; создает две вещи: &lt;em&gt;тип &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; , который относится к форме экземпляра класса, и &lt;em&gt;значение &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; , которое относится к функции-конструктору класса. Объявления перечисления ведут себя аналогично.</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes" xml:space="preserve">
          <source>Async Generators</source>
          <target state="translated">Генераторы Async</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes" xml:space="preserve">
          <source>Async Iteration</source>
          <target state="translated">Итерация Async</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes" xml:space="preserve">
          <source>Async iterators</source>
          <target state="translated">Async итераторы</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes" xml:space="preserve">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="translated">По сути, необязательная цепочка позволяет нам писать код, в котором TypeScript может немедленно прекратить выполнение некоторых выражений, если мы столкнемся с &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Звездой шоу в необязательной цепочке является новый &lt;code&gt;?.&lt;/code&gt; оператор для &lt;em&gt;необязательного доступа к свойствам&lt;/em&gt; . Когда мы пишем код вроде</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes" xml:space="preserve">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="translated">В командной строке запустите компилятор TypeScript:</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes" xml:space="preserve">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="translated">На данный момент, если вы попробуйте запустить &lt;code&gt;tsc&lt;/code&gt; в корневом каталоге вашего проекта, вы должны увидеть выходные файлы в &lt;code&gt;built&lt;/code&gt; каталоге. Макет &lt;code&gt;built&lt;/code&gt; файлов должен выглядеть идентично макету &lt;code&gt;src&lt;/code&gt; . Теперь у вас должен работать TypeScript с вашим проектом.</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes" xml:space="preserve">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="translated">На этом этапе компилятор спросит: &amp;laquo;Какая форма у &lt;code&gt;moduleA&lt;/code&gt; ?&amp;raquo; Хотя это звучит просто, &lt;code&gt;moduleA&lt;/code&gt; можно определить в одном из ваших собственных &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; или в &lt;code&gt;.d.ts&lt;/code&gt; , от которого зависит ваш код.</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="translated">На этом этапе вы, вероятно, готовы начать использовать файлы TypeScript. Первый шаг - переименовать один из ваших файлов &lt;code&gt;.js&lt;/code&gt; в &lt;code&gt;.ts&lt;/code&gt; . Если ваш файл использует JSX, вам нужно переименовать его в &lt;code&gt;.tsx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes" xml:space="preserve">
          <source>Attribute type checking</source>
          <target state="translated">Проверка типа атрибута</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes" xml:space="preserve">
          <source>Augmenting global/module scope from modules</source>
          <target state="translated">Расширение глобального/модульного диапазона от модулей</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes" xml:space="preserve">
          <source>Automatically set to PreferredUILang value</source>
          <target state="translated">Автоматически устанавливается на значение PreferredUILang</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="d20e2c01b6a2f58cc429d37f014c475da407fd6a" translate="yes" xml:space="preserve">
          <source>Babel for transpiling, &lt;code&gt;tsc&lt;/code&gt; for types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes" xml:space="preserve">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="translated">Babel - чрезвычайно гибкий компилятор, конвертирующий ES2015 и другие версии в ES5 и ES3. Это позволяет добавлять обширные и настраиваемые преобразования, которые TypeScript не поддерживает.</target>
        </trans-unit>
        <trans-unit id="e9d398ffcbadffa21d8b3f31a932766b42449e22" translate="yes" xml:space="preserve">
          <source>Babel vs &lt;code&gt;tsc&lt;/code&gt; for TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes" xml:space="preserve">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="translated">Вывод Babel ES5 должен быть очень похож на вывод TypeScript для такого простого скрипта.</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes" xml:space="preserve">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="translated">Тогда,когда TypeScript реализовывал открытые поля классов,мы в меру своих возможностей предполагали,что следующий код</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes" xml:space="preserve">
          <source>Bare Import</source>
          <target state="translated">Безвозмездный ввоз</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes" xml:space="preserve">
          <source>Base URL</source>
          <target state="translated">Базовый URL-адрес</target>
        </trans-unit>
        <trans-unit id="6f8087950b61f86d74cf472c3db8209a3e21e0bb" translate="yes" xml:space="preserve">
          <source>Base Url - &lt;code&gt;baseUrl&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes" xml:space="preserve">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Базовый каталог для разрешения не относительных имен модулей. См. &lt;a href=&quot;module-resolution#base-url&quot;&gt;Документацию Module Resolution&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="4833160c36b89ddb86e6b6fbca4d0e967b129ce3" translate="yes" xml:space="preserve">
          <source>Based on the description, it sounds easy to downlevel to ES5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356e91f1e0248e37e452abdcd998b2dddab60e58" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, TypeScript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so TypeScript will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="translated">Основываясь на том факте, что &lt;code&gt;Window.onscroll&lt;/code&gt; выше функция назначается Window.onscroll , Typescript знает, что &lt;code&gt;uiEvent&lt;/code&gt; является &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt; , а не &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent,&lt;/a&gt; как в предыдущем примере. Объекты &lt;code&gt;UIEvent&lt;/code&gt; не содержат свойства &lt;code&gt;button&lt;/code&gt; , поэтому Typescript выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">Основные концепции</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes" xml:space="preserve">
          <source>Basic Gruntfile.js</source>
          <target state="translated">Базовый Gruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">Основные типы</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes" xml:space="preserve">
          <source>Basic Types: Any</source>
          <target state="translated">Основные типы:Любой</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes" xml:space="preserve">
          <source>Basic Types: Array</source>
          <target state="translated">Основные типы:Массив</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes" xml:space="preserve">
          <source>Basic Types: Enum</source>
          <target state="translated">Основные типы:Enum</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes" xml:space="preserve">
          <source>Basic Types: Never</source>
          <target state="translated">Основные типы:Никогда</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes" xml:space="preserve">
          <source>Basic Types: Tuple</source>
          <target state="translated">Основные типы:Кортеж</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes" xml:space="preserve">
          <source>Basic Types: Void</source>
          <target state="translated">Основные типы:Пустота</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes" xml:space="preserve">
          <source>Basic gulpfile.js</source>
          <target state="translated">Основной gulpfile.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">Основное использование</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="translated">Базовый webpack.config.js при использовании Webpack 1</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="translated">Базовый webpack.config.js при использовании Webpack 2</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">Обязательно прочтите &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;сноску &amp;laquo;Влияние ES6 на подписи вызова модуля&amp;raquo;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="translated">Поскольку &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;идеальное свойство программного обеспечения - возможность расширения&lt;/a&gt; , вы всегда должны использовать интерфейс поверх псевдонима типа, если это возможно.</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;Dog&lt;/code&gt; расширяет функциональность от &lt;code&gt;Animal&lt;/code&gt; , мы смогли создать экземпляр &lt;code&gt;Dog&lt;/code&gt; , который мог одновременно &lt;code&gt;bark()&lt;/code&gt; и &lt;code&gt;move()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="translated">Поскольку &lt;code&gt;createClock&lt;/code&gt; первого параметра &amp;laquo;s имеет тип &lt;code&gt;ClockConstructor&lt;/code&gt; , в &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt; , он проверяет , что &lt;code&gt;AnalogClock&lt;/code&gt; имеет правильный конструктор подпись.</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="translated">Поскольку &lt;code&gt;haveMuscles&lt;/code&gt; не экспортируется, только функция &lt;code&gt;animalsHaveMuscles&lt;/code&gt; , которая использует одно и то же неслияние пространства имен, может видеть этот символ. Функция &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; , даже если она является частью объединенного пространства имен &lt;code&gt;Animal&lt;/code&gt; , не может видеть этот неэкспортированный член.</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="translated">Поскольку &lt;code&gt;never&lt;/code&gt; является подтипом каждого типа, он всегда опускается в типах объединения и игнорируется при выводе типа возвращаемого значения функции до тех пор, пока возвращаются другие типы.</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="translated">Поскольку &lt;code&gt;never&lt;/code&gt; присваивается каждому типу, функция, возвращающая &lt;code&gt;never&lt;/code&gt; , может использоваться, когда требуется обратный вызов, возвращающий более конкретный тип:</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="translated">Поскольку &lt;code&gt;onClickGood&lt;/code&gt; указывает свой тип &lt;code&gt;this&lt;/code&gt; как &lt;code&gt;void&lt;/code&gt; , его можно передать в &lt;code&gt;addClickListener&lt;/code&gt; . Конечно, это также означает, что он не может использовать &lt;code&gt;this.info&lt;/code&gt; . Если вам нужны оба варианта, вам придется использовать стрелочную функцию:</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes" xml:space="preserve">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="translated">Поскольку TypeScript является системой структурных типов,параметры типа влияют на результирующий тип только в том случае,если он потребляется как часть типа члена.Например,</target>
        </trans-unit>
        <trans-unit id="926c5ce8de1d04093ea0f5a3309faccac7464c9c" translate="yes" xml:space="preserve">
          <source>Because TypeScript is structural, it doesn&amp;rsquo;t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to &lt;em&gt;propagate&lt;/em&gt; type information, such as constraining parameters to be the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes" xml:space="preserve">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="translated">Поскольку машинопись используется для вывода типа &lt;code&gt;BasicCalculator&lt;/code&gt; для каждого метода в &lt;code&gt;BasicCalculator&lt;/code&gt; , вызвавшую &lt;code&gt;this&lt;/code&gt; система типа забыли бы , что он имел &lt;code&gt;ScientificCalculator&lt;/code&gt; всякий раз , когда с помощью &lt;code&gt;BasicCalculator&lt;/code&gt; метода.</target>
        </trans-unit>
        <trans-unit id="bedf22fdedc00ef56a14dec85f7bb3b3494d73cc" translate="yes" xml:space="preserve">
          <source>Because TypeScript&amp;rsquo;s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes" xml:space="preserve">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="translated">Поскольку функциональный компонент является просто JavaScript-функцией,здесь также может быть использована перегрузка функций:</target>
        </trans-unit>
        <trans-unit id="805d3d429e696b76e1abd7a4044863cf0873570b" translate="yes" xml:space="preserve">
          <source>Because an interface more closely maps how JavaScript objects work &lt;a href=&quot;https://wikipedia.org/wiki/Open/closed_principle&quot;&gt;by being open to extension&lt;/a&gt;, we recommend using an interface over a type alias when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes" xml:space="preserve">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="translated">Поскольку зависимые проекты используют файлы &lt;code&gt;.d.ts&lt;/code&gt; , построенные на основе их зависимостей, вам придется либо проверить определенные выходные данные сборки, &lt;em&gt;либо&lt;/em&gt; построить проект после его клонирования, прежде чем вы сможете перемещаться по проекту в редакторе, не видя ложных ошибок. Мы работаем над скрытым процессом генерации .d.ts, который должен иметь возможность смягчить это, но пока мы рекомендуем сообщить разработчикам, что они должны создавать после клонирования.</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="translated">Поскольку каждый &lt;code&gt;unique symbol&lt;/code&gt; имеет совершенно отдельную идентичность, никакие два &lt;code&gt;unique symbol&lt;/code&gt; типа символов не могут быть присвоены или сопоставимы друг с другом.</target>
        </trans-unit>
        <trans-unit id="bd9b4625ee3434502c77baac6fb3b4163197cdca" translate="yes" xml:space="preserve">
          <source>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new &lt;code&gt;watchOptions&lt;/code&gt; field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes" xml:space="preserve">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="translated">Поскольку интерфейсы (и другие типы объектов) вводят уровень косвенности, и их полная структура не требует активного построения, TypeScript не имеет проблем при работе с этой структурой.</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="translated">Поскольку обычно глобальную библиотеку легко превратить в библиотеку UMD, очень немногие популярные библиотеки по-прежнему написаны в глобальном стиле. Однако небольшие библиотеки, требующие DOM (или не &lt;em&gt;имеющие&lt;/em&gt; зависимостей), могут по-прежнему быть глобальными.</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes" xml:space="preserve">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="translated">Поэтому теперь они включены по умолчанию в стандартную библиотеку.</target>
        </trans-unit>
        <trans-unit id="21ce5edafa407b8340ea3cb9742b87949fcfb1fa" translate="yes" xml:space="preserve">
          <source>Because of the variety of supported JavaScript, upgrading to a new version of TypeScript can uncover two types of errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="translated">Поскольку &lt;code&gt;switch&lt;/code&gt; больше не является исчерпывающим, TypeScript знает, что функция иногда может возвращать &lt;code&gt;undefined&lt;/code&gt; . Если у вас есть явный &lt;code&gt;number&lt;/code&gt; типа возвращаемого значения , вы получите сообщение об ошибке, что тип возвращаемого значения на самом деле является &lt;code&gt;number | undefined&lt;/code&gt; . Однако этот метод довольно тонкий и, кроме того, &lt;code&gt;--strictNullChecks&lt;/code&gt; не всегда работает со старым кодом.</target>
        </trans-unit>
        <trans-unit id="a169ffc6d01ce9e9e1170f6d035a3b9d98c04e7e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;string&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;string | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; does not always work with old code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes" xml:space="preserve">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="translated">Так как лучший общий тип должен быть выбран из предоставленных типов кандидатов,есть некоторые случаи,когда типы имеют общую структуру,но ни один тип не является супер-типом всех типов кандидатов.Например:</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes" xml:space="preserve">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="translated">Поскольку общая функция теперь ограничена,она больше не будет работать над любыми и всеми типами:</target>
        </trans-unit>
        <trans-unit id="d1ed1478bf3076f9798d93562781e783237eee9e" translate="yes" xml:space="preserve">
          <source>Because there&amp;rsquo;s no value for &lt;code&gt;someType&lt;/code&gt;, the emitted &lt;code&gt;export&lt;/code&gt; will not try to export it (this would be a runtime error in JavaScript):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes" xml:space="preserve">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="translated">Поскольку эти два типа элементов,основанных на значении,неотличимы друг от друга в JSX выражении,первый TS пытается разрешить выражение как Функциональный Компонент,используя разрешение перегрузки.Если процесс проходит успешно,то TS завершает разрешение выражения до его объявления.Если значение не удается разрешить как функциональный компонент,TS пытается разрешить его как компонент класса.Если это не удастся,TS сообщит об ошибке.</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="translated">Поскольку мы захватили &lt;code&gt;city&lt;/code&gt; из его окружения, мы все еще можем получить к нему доступ, несмотря на то, что выполнение блока &lt;code&gt;if&lt;/code&gt; завершилось.</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes" xml:space="preserve">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="translated">До ES2015 в Javascript вместо классов использовались функции конструктора.Компилятор поддерживает этот шаблон и понимает функции конструктора как эквивалентные классам ES2015.Описанные выше правила вывода свойств работают точно так же.</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes" xml:space="preserve">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="translated">До TypeScript 2.0 идентификатор модуля всегда предполагался без расширения; например, учитывая импорт как &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt; , компилятор искал определение &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; в &lt;code&gt;./moduleA.js.ts&lt;/code&gt; или &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt; . Это затрудняло использование инструментов связывания / загрузки, таких как &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS,&lt;/a&gt; которые ожидают URI в своем идентификаторе модуля.</target>
        </trans-unit>
        <trans-unit id="67d8456dd67e313605647faf280117c02dfc9eeb" translate="yes" xml:space="preserve">
          <source>Before getting started with &lt;a href=&quot;basic-types&quot;&gt;Basic Types&lt;/a&gt;, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes" xml:space="preserve">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="translated">Прежде чем мы перейдем к Browserify, давайте создадим наш код и добавим в него модули. Это структура, которую вы, скорее всего, будете использовать в реальном приложении.</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes" xml:space="preserve">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="translated">Ниже и &lt;code&gt;n&lt;/code&gt; , и &lt;code&gt;m&lt;/code&gt; будут отмечены как неиспользуемые, потому что их значения никогда не &lt;em&gt;читаются&lt;/em&gt; . Раньше TypeScript проверял только наличие &lt;em&gt;ссылок на&lt;/em&gt; их значения .</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes" xml:space="preserve">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="translated">Ниже мы объединили реализации Validator, использованные в предыдущих примерах, чтобы экспортировать только один именованный экспорт из каждого модуля.</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes" xml:space="preserve">
          <source>Best common type</source>
          <target state="translated">Лучший распространенный тип</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes" xml:space="preserve">
          <source>Better Module Visibility Rules</source>
          <target state="translated">Правила улучшения видимости модулей</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes" xml:space="preserve">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="translated">Лучшая поддержка &lt;code&gt;never&lt;/code&gt; возвращающихся функций</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes" xml:space="preserve">
          <source>Better Type Inference</source>
          <target state="translated">Лучший типовой вывод</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes" xml:space="preserve">
          <source>Better Unicode Support for Identifiers</source>
          <target state="translated">Улучшенная поддержка Unicode для идентификаторов</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes" xml:space="preserve">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="translated">Лучшая проверка на &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; в операндах выражений</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes" xml:space="preserve">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="translated">Лучшая обработка шаблонов пространства имен в файлах &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes" xml:space="preserve">
          <source>Better inference for literal types</source>
          <target state="translated">Лучший вывод для буквальных типов</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes" xml:space="preserve">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="translated">Поддержка BigInt в TypeScript представляет новый примитивный тип, называемый &lt;code&gt;bigint&lt;/code&gt; (все строчные буквы). Вы можете получить &lt;code&gt;bigint&lt;/code&gt; , вызвав &lt;code&gt;BigInt()&lt;/code&gt; или записав литерал BigInt, добавив &lt;code&gt;n&lt;/code&gt; в конец любого целочисленного числового литерала:</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes" xml:space="preserve">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">BigInts являются частью предстоящего предложения в ECMAScript, которое позволяет нам моделировать теоретически произвольно большие целые числа. TypeScript 3.2 обеспечивает проверку типов для BigInts, а также поддержку создания литералов BigInt при нацеливании на &lt;code&gt;esnext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes" xml:space="preserve">
          <source>Block scoped</source>
          <target state="translated">Блок просмотрен</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes" xml:space="preserve">
          <source>Block-scoped variable capturing</source>
          <target state="translated">Захват переменных с блочным управлением</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes" xml:space="preserve">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="1e4200b2f583d0dc3a8f8c9ca192857c23373085" translate="yes" xml:space="preserve">
          <source>Boolean Literal Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="translated">Оба &lt;code&gt;for..of&lt;/code&gt; и &lt;code&gt;for..in&lt;/code&gt; заявления перебирать списки; значения, для которых &lt;code&gt;for..in&lt;/code&gt; различны, for..in возвращает список &lt;em&gt;ключей&lt;/em&gt; для повторяемого объекта, тогда как &lt;code&gt;for..of&lt;/code&gt; возвращает список &lt;em&gt;значений&lt;/em&gt; числовых свойств повторяемого объекта.</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes" xml:space="preserve">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="translated">И CommonJS, и AMD обычно используют концепцию объекта &lt;code&gt;exports&lt;/code&gt; который содержит все экспортные данные из модуля.</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes" xml:space="preserve">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="translated">Обе эти зависимости позволят TypeScript и webpack хорошо работать вместе. ts-loader помогает Webpack скомпилировать ваш код TypeScript, используя стандартный файл конфигурации TypeScript с именем &lt;code&gt;tsconfig.json&lt;/code&gt; . source-map-loader использует любые выходные данные исходной карты от TypeScript для информирования веб-пакета при создании &lt;em&gt;своих собственных&lt;/em&gt; исходных карт. Это позволит вам отлаживать окончательный выходной файл, как если бы вы отлаживали исходный код на TypeScript.</target>
        </trans-unit>
        <trans-unit id="1e8845429ecea7d81d05bd48bc682718054a7086" translate="yes" xml:space="preserve">
          <source>Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in &lt;em&gt;lib.dom.d.ts&lt;/em&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a3e07fa1f601ed37521339b8334bccb8a1dfdc" translate="yes" xml:space="preserve">
          <source>Boxed types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">Сокращение изменений</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes" xml:space="preserve">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="translated">Вообще говоря, способ &lt;em&gt;структурирования&lt;/em&gt; файла объявления зависит от того, как используется библиотека. Есть много способов предложить библиотеку для использования в JavaScript, и вам нужно будет написать свой файл декларации, чтобы он соответствовал ей. В этом руководстве рассказывается, как определить общие шаблоны библиотеки и как написать файлы объявлений, соответствующие этому шаблону.</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes" xml:space="preserve">
          <source>Build Mode for TypeScript</source>
          <target state="translated">Режим построения для TypeScript</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes" xml:space="preserve">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="translated">Режим сборки (см.ниже)при необходимости автоматически построит проект,на который есть ссылка.</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes" xml:space="preserve">
          <source>Build out-of-date projects in the correct order</source>
          <target state="translated">Постройте устаревшие проекты в правильном порядке</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes" xml:space="preserve">
          <source>Build tools</source>
          <target state="translated">Строить инструменты</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes" xml:space="preserve">
          <source>Build-Free Editing with Project References</source>
          <target state="translated">Редактирование без сборки со ссылками на проект</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes" xml:space="preserve">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="translated">Основываясь на этой работе, новый тип &lt;code&gt;Generator&lt;/code&gt; представляет собой &lt;code&gt;Iterator&lt;/code&gt; который всегда имеет методы &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;throw&lt;/code&gt; , а также является итеративным.</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes" xml:space="preserve">
          <source>Building your first TypeScript file</source>
          <target state="translated">Сборка вашего первого файла TypeScript</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes" xml:space="preserve">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Строит этот проект и все его зависимости, указанные в &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt; . Обратите внимание, что этот флаг несовместим с другими на этой странице. Подробнее &lt;a href=&quot;project-references&quot;&gt;здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes" xml:space="preserve">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="translated">На встроенные файлы &lt;em&gt;lib&lt;/em&gt; ссылаются так же, как на параметр компилятора &lt;code&gt;&quot;lib&quot;&lt;/code&gt; в &lt;em&gt;tsconfig.json&lt;/em&gt; (например, используйте &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; , а не &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes" xml:space="preserve">
          <source>Built-in Combinations</source>
          <target state="translated">Встроенные комбинации</target>
        </trans-unit>
        <trans-unit id="0f6bebd51ff8927e6e3679a7b2412429e9c60cb6" translate="yes" xml:space="preserve">
          <source>Built-in types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="translated">Но &lt;em&gt;не&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes" xml:space="preserve">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="translated">Но в качестве примера места,где отложены условные типы-где они остаются вместо того,чтобы пикировать ветку,-можно привести следующее:</target>
        </trans-unit>
        <trans-unit id="280120ab44ab2249440ce6b53b7137cb76018378" translate="yes" xml:space="preserve">
          <source>But it also infers types in a few other places that you may not expect if you&amp;rsquo;ve worked with other C-syntax languages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="translated">Но полезнее иметь общую версию.</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes" xml:space="preserve">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="translated">Но указание значений по умолчанию более распространено для параметров,и получение значений по умолчанию с деструкцией может быть непростым делом.Прежде всего,не забывайте ставить шаблон перед значением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes" xml:space="preserve">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="translated">Но обходной путь введения интерфейса не был интуитивно понятным для пользователей. И в принципе, в исходной версии &lt;code&gt;ValueOrArray&lt;/code&gt; , которая напрямую использовала &lt;code&gt;Array&lt;/code&gt; , действительно не было ничего плохого . Если бы компилятор был немного &amp;laquo;ленивее&amp;raquo; и вычислял аргументы типа для &lt;code&gt;Array&lt;/code&gt; только при необходимости, тогда TypeScript мог бы выразить их правильно.</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes" xml:space="preserve">
          <source>By Example</source>
          <target state="translated">На примере</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes" xml:space="preserve">
          <source>By Example: Classes</source>
          <target state="translated">На примере:Занятия</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes" xml:space="preserve">
          <source>By Example: Global Functions</source>
          <target state="translated">На примере:Глобальные функции</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes" xml:space="preserve">
          <source>By Example: Global Variables</source>
          <target state="translated">На примере:Глобальные переменные</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes" xml:space="preserve">
          <source>By Example: Objects with Properties</source>
          <target state="translated">На примере:Объекты со свойствами</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes" xml:space="preserve">
          <source>By Example: Organizing Types</source>
          <target state="translated">На примере:Типы организации</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes" xml:space="preserve">
          <source>By Example: Overloaded Functions</source>
          <target state="translated">На примере:Перегруженные функции</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="translated">На примере:Типы многоразового использования (интерфейсы)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="translated">На примере:Типы многоразового использования (псевдонимы типа)</target>
        </trans-unit>
        <trans-unit id="7bae2a3265a68393939ee4d97179b68dd46cb074" translate="yes" xml:space="preserve">
          <source>By default (with &lt;code&gt;esModuleInterop&lt;/code&gt; false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; являются подтипами всех других типов. Это означает, что вы можете присвоить &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; чему-то вроде &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">По умолчанию модули AMD генерируются анонимно. Это может привести к проблемам, когда для обработки полученных модулей используются другие инструменты, такие как сборщики (например, &lt;code&gt;r.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">По умолчанию модули AMD генерируются анонимно. Это может привести к проблемам при использовании других инструментов для обработки полученных модулей, таких как сборщики (например, &lt;code&gt;r.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">По умолчанию все &lt;em&gt;видимые&lt;/em&gt; пакеты &amp;laquo; &lt;code&gt;@types&lt;/code&gt; &amp;raquo; включены в вашу компиляцию. Пакеты в &lt;code&gt;node_modules/@types&lt;/code&gt; любой включающей папки считаются &lt;em&gt;видимыми&lt;/em&gt; ; в частности, это означает пакеты внутри &lt;code&gt;./node_modules/@types/&lt;/code&gt; , &lt;code&gt;../node_modules/@types/&lt;/code&gt; , &lt;code&gt;../../node_modules/@types/&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="e8d004cf1198829c9480cb66e1fa5db152e6f49b" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;rdquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;. For example, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe14b4afe246d0c7517495f8c1f6da852617e95" translate="yes" xml:space="preserve">
          <source>By default converts to this JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes" xml:space="preserve">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">По умолчанию компилятор TypeScript не сообщает об ошибках в файлах .js, включая использование &lt;code&gt;--allowJs&lt;/code&gt; . В TypeScript 2.3 об ошибках проверки типов также можно сообщать в файлах &lt;code&gt;.js&lt;/code&gt; с помощью &lt;code&gt;--checkJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes" xml:space="preserve">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="translated">По умолчанию выводимый символ новой строки - &lt;code&gt;\r\n&lt;/code&gt; в системах на базе Windows и &lt;code&gt;\n&lt;/code&gt; системах на базе * nix. &lt;code&gt;--newLine&lt;/code&gt; командной строки --newLine позволяет переопределить это поведение и указать символ новой строки, который будет использоваться в сгенерированных выходных файлах.</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes" xml:space="preserve">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="translated">По умолчанию результатом выражения JSX является &lt;code&gt;any&lt;/code&gt; . Вы можете настроить тип, указав интерфейс &lt;code&gt;JSX.Element&lt;/code&gt; . Однако получить информацию о типе элемента, атрибутов или потомков JSX из этого интерфейса невозможно. Это черный ящик.</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes" xml:space="preserve">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">По умолчанию типа &lt;code&gt;this&lt;/code&gt; внутри функции &lt;code&gt;any&lt;/code&gt; . Начиная с TypeScript 2.0, вы можете явно указать &lt;code&gt;this&lt;/code&gt; параметр. &lt;code&gt;this&lt;/code&gt; фальшивые параметры, которые идут первыми в списке параметров функции:</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes" xml:space="preserve">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="translated">По умолчанию с этими настройками, когда мы запускаем &lt;code&gt;tsc&lt;/code&gt; , TypeScript будет искать файл с именем &lt;code&gt;.tsbuildinfo&lt;/code&gt; в выходном каталоге ( &lt;code&gt;./lib&lt;/code&gt; ). Если &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; не существует, он будет создан. Но если это произойдет, &lt;code&gt;tsc&lt;/code&gt; попытается использовать этот файл для постепенной проверки типов и обновления наших выходных файлов.</target>
        </trans-unit>
        <trans-unit id="15490221bf616dc92de25b5e1a3de0bfd6534e2d" translate="yes" xml:space="preserve">
          <source>By default, MSBuild will attempt to only run the TypeScript compiler when the project&amp;rsquo;s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript&amp;rsquo;s &lt;code&gt;incremental&lt;/code&gt; option is enabled, set &lt;code&gt;&amp;lt;TypeScriptEnableIncrementalMSBuild&amp;gt;false&amp;lt;/TypeScriptEnableIncrementalMSBuild&amp;gt;&lt;/code&gt; to ensure the TypeScript compiler is invoked with every run of MSBuild.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes" xml:space="preserve">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="translated">По умолчанию TypeScript предполагает, что &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; входят в домен каждого типа. Это означает, что все, что объявлено с &lt;code&gt;number&lt;/code&gt; типа, может быть &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Поскольку &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; являются частым источником ошибок в JavaScript и TypeScript, в TypeScript есть опция &lt;code&gt;strictNullChecks&lt;/code&gt; , которая избавит вас от беспокойства по поводу этих проблем.</target>
        </trans-unit>
        <trans-unit id="81ae234f340bd85fd153e90ec1d2e0c01b304e39" translate="yes" xml:space="preserve">
          <source>By default, TypeScript will examine the initial set of files for &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;&amp;lt;reference&lt;/code&gt; directives and add these resolved files to your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes" xml:space="preserve">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">По умолчанию перечисления начинают нумерацию своих членов, начиная с &lt;code&gt;0&lt;/code&gt; . Вы можете изменить это, вручную установив значение одного из его членов. Например, мы можем начать предыдущий пример с &lt;code&gt;1&lt;/code&gt; вместо &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b2f3061b8b67ef271d84bdab07aa0d4586d6daa" translate="yes" xml:space="preserve">
          <source>By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes" xml:space="preserve">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="translated">Таким образом,вы можете значительно улучшить время сборки,усилить логическое разделение между компонентами,а также организовать свой код новыми и лучшими способами.</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes" xml:space="preserve">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="translated">Установив плагины TypeScript Visual Studio</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="translated">Вызовом tsc без входных файлов и опции командной строки -project (или просто -p),которая указывает путь к директории,содержащей файл tsconfig.json.</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="translated">Вызов tsc без входных файлов и &lt;code&gt;--project&lt;/code&gt; командной строки --project (или просто &lt;code&gt;-p&lt;/code&gt; ), который указывает путь к каталогу, содержащему файл &lt;code&gt;tsconfig.json&lt;/code&gt; , или путь к допустимому файлу &lt;code&gt;.json&lt;/code&gt; , содержащему конфигурации.</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">Вызов tsc без входных файлов, и в этом случае компилятор ищет файл &lt;code&gt;tsconfig.json&lt;/code&gt; , начиная с текущего каталога и продолжая вверх по цепочке родительских каталогов.</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">Вызовом tsc без входных файлов,в этом случае компилятор ищет файл tsconfig.json,начинающийся в текущем каталоге и продолжающийся вверх по цепочке родительских каталогов.</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes" xml:space="preserve">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="translated">Просто передав &lt;code&gt;--pretty&lt;/code&gt; командной строки --pretty , TypeScript дает более красочный вывод с контекстом о том, где что-то идет не так.</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes" xml:space="preserve">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Используя &lt;code&gt;rootDirs&lt;/code&gt; , мы можем сообщить компилятору об этом сопоставлении и тем самым позволить ему безопасно разрешить &lt;code&gt;./#{locale}/messages&lt;/code&gt; , даже если каталог никогда не будет существовать. Например, со следующим &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes" xml:space="preserve">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="translated">К настоящему времени вы выяснили, что у &lt;code&gt;var&lt;/code&gt; есть некоторые проблемы, и именно поэтому были введены операторы &lt;code&gt;let&lt;/code&gt; . За исключением используемого ключевого слова, операторы &lt;code&gt;let&lt;/code&gt; записываются так же, как операторы &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d522062326dbb5972e36c53a7116048922cfac7" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">Прочитав это руководство, вы получите инструменты для написания сложных файлов определений, предоставляющих удобный интерфейс API. В этом руководстве основное внимание уделяется библиотекам модулей (или UMD), потому что варианты здесь более разнообразны.</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes" xml:space="preserve">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="translated">Разбившись на несколько проектов,вы можете значительно повысить скорость набора и компиляции,уменьшить использование памяти при использовании редактора,а также улучшить соблюдение логических группировок вашей программы.</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes" xml:space="preserve">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="translated">Между прочим, обратите внимание, что в то время как некоторые языки (например, C # и Scala) требуют аннотаций отклонения ( &lt;code&gt;out&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; ), отклонение естественным образом возникает из фактического использования параметра типа в универсальном типе из-за системы структурных типов TypeScript.</target>
        </trans-unit>
        <trans-unit id="37a5bb86f5de627c75eefc01c9440b9728e21c0e" translate="yes" xml:space="preserve">
          <source>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That&amp;rsquo;s how TypeScript knows that &lt;code&gt;helloWorld&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt; in the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970dc4b5ed34cee139d022f1ef1a7253a84f38eb" translate="yes" xml:space="preserve">
          <source>By using babel&amp;rsquo;s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7e951244c6dc6091c5c81158c926700438ad75" translate="yes" xml:space="preserve">
          <source>C# and Java are what we might call &lt;em&gt;mandatory OOP&lt;/em&gt; languages. In these languages, the &lt;em&gt;class&lt;/em&gt; is the basic unit of code organization, and also the basic container of all data &lt;em&gt;and&lt;/em&gt; behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain &lt;em&gt;needs&lt;/em&gt; to be represented this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes" xml:space="preserve">
          <source>Cache tagged template objects in modules</source>
          <target state="translated">Кэшировать помеченные объекты шаблонов в модулях</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes" xml:space="preserve">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes" xml:space="preserve">
          <source>Callback Types</source>
          <target state="translated">Типы обратного вызова</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="translated">Вызов &lt;code&gt;showHello&lt;/code&gt; вызывает &lt;code&gt;sayHello&lt;/code&gt; для изменения текста абзаца. Теперь измените свой gulpfile на следующее:</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="translated">Призывы &lt;code&gt;define(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes" xml:space="preserve">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="translated">Может использоваться в &lt;code&gt;global-script.ts&lt;/code&gt; файле global-script.ts :</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes" xml:space="preserve">
          <source>Case clause fall-throughs</source>
          <target state="translated">Пропуски в судебных делах</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes" xml:space="preserve">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes" xml:space="preserve">
          <source>Caveats for Project References</source>
          <target state="translated">Пещеры для ссылок на проекты</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes" xml:space="preserve">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="translated">Некоторые цели могут включать в себя исполняемый объект, подобный полифилу или BigInt. Для этих целей вы можете добавить &lt;code&gt;esnext.bigint&lt;/code&gt; в параметр &lt;code&gt;lib&lt;/code&gt; в параметрах компилятора.</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes" xml:space="preserve">
          <source>Changes include:</source>
          <target state="translated">Изменения включают в себя:</target>
        </trans-unit>
        <trans-unit id="b2f9c51be50e36d425334b6ef56e24f1966fdfc5" translate="yes" xml:space="preserve">
          <source>Changes the function called in &lt;code&gt;.js&lt;/code&gt; files when compiling JSX Elements using the classic JSX runtime. The most common change is to use &lt;code&gt;&quot;h&quot;&lt;/code&gt; or &lt;code&gt;&quot;preact.h&quot;&lt;/code&gt; instead of the default &lt;code&gt;&quot;React.createElement&quot;&lt;/code&gt; if using &lt;code&gt;preact&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">Изменения в &lt;code&gt;@types/React&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de22ad0ca9b556e61bbb70c5ec83a398c3b619a4" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;module&lt;/code&gt; affects &lt;a href=&quot;#moduleResolution&quot;&gt;&lt;code&gt;moduleResolution&lt;/code&gt;&lt;/a&gt; which &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;also has a reference page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dba2ca91863c573a72dfc7f990cbc67e554c68" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;target&lt;/code&gt; also changes the default value of &lt;a href=&quot;#lib&quot;&gt;&lt;code&gt;lib&lt;/code&gt;&lt;/a&gt;. You may &amp;ldquo;mix and match&amp;rdquo; &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; settings as desired, but you could just set &lt;code&gt;target&lt;/code&gt; for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes" xml:space="preserve">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="translated">Изменение только &lt;em&gt;внутренних &lt;/em&gt;&lt;em&gt;компонентов&lt;/em&gt; в файлах реализации потребовало &lt;em&gt;повторной&lt;/em&gt; проверки &lt;em&gt;типов&lt;/em&gt; тестов, даже если это никогда не вызовет новых ошибок.</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes" xml:space="preserve">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="translated">Изменение только тестов потребовало повторной типовой проверки реализации,даже если ничего не изменилось.</target>
        </trans-unit>
        <trans-unit id="1dc59cc2161e54b7687bb52a2c3f693c96a5e443" translate="yes" xml:space="preserve">
          <source>Charset - &lt;code&gt;charset&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd93b75e5598d54991c74a1d1b0a5f56438c081" translate="yes" xml:space="preserve">
          <source>Check JS - &lt;code&gt;checkJs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes" xml:space="preserve">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">Проверяет наличие или использование загрузчиков модулей, таких как &lt;code&gt;require&lt;/code&gt; или &lt;code&gt;define&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes" xml:space="preserve">
          <source>Children Type Checking</source>
          <target state="translated">Проверка типа детей</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">Выбрать &lt;strong&gt;файл&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="translated">Выберите &lt;strong&gt;Новый проект&lt;/strong&gt; (Ctrl + Shift + N)</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes" xml:space="preserve">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="translated">Выбор значения &amp;laquo;вставить&amp;raquo; или &amp;laquo;удалить&amp;raquo; также влияет на формат автоматического импорта, извлеченных типов и другого сгенерированного кода, предоставляемого службами TypeScript. Если оставить для параметра значение по умолчанию &amp;laquo;игнорировать&amp;raquo;, сгенерированный код будет соответствовать предпочтению точки с запятой, обнаруженному в текущем файле.</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes" xml:space="preserve">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="translated">Циркулярность между конфигурационными файлами не допускается.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes" xml:space="preserve">
          <source>Class Component</source>
          <target state="translated">Классовый компонент</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes" xml:space="preserve">
          <source>Class Decorators</source>
          <target state="translated">Декораторы класса</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes" xml:space="preserve">
          <source>Class Field Mitigations</source>
          <target state="translated">Классовые полевые митигации</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">Типы классов</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">Классовые выражения</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes" xml:space="preserve">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="translated">Объявления классов и функций могут быть автоматически созданы непосредственно в качестве экспорта по умолчанию.Имена классов и деклараций функций экспорта по умолчанию являются необязательными.</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes" xml:space="preserve">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="translated">Классы - это пространства имен в файлах &lt;code&gt;.js&lt;/code&gt; . Это можно использовать для вложения классов, например:</target>
        </trans-unit>
        <trans-unit id="521ef0588bf6981159e4b30671900a891602e592" translate="yes" xml:space="preserve">
          <source>Classes can be declared as ES6 classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes" xml:space="preserve">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="translated">Классы работают аналогично объектно-литеральным типам и интерфейсам,за одним исключением:они имеют и статический тип,и тип экземпляра.При сравнении двух объектов типа класса сравниваются только члены экземпляра.Статические члены и конструкторы не влияют на совместимость.</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes" xml:space="preserve">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="translated">Классы,функции и литералы объектов-это пространства имен.</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes" xml:space="preserve">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes" xml:space="preserve">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; вывод в режиме --watch</target>
        </trans-unit>
        <trans-unit id="94996b319b013869345bb5ec0b653754bbab2bb2" translate="yes" xml:space="preserve">
          <source>Co-learning JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes" xml:space="preserve">
          <source>Code Generation for Modules</source>
          <target state="translated">Генерация кода для модулей</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">генерация кода</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes" xml:space="preserve">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="translated">Код, на который влияет изменение полей класса, может обойти проблему, преобразовав инициализаторы полей в назначения в телах конструкторов.</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes" xml:space="preserve">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="translated">Окраска JSX-кода в VS 2015</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes" xml:space="preserve">
          <source>Comma-separated list of strings</source>
          <target state="translated">Список строк с разделителями-запятыми</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a06fdc1de7c2a221587196452cc0c3db471910" translate="yes" xml:space="preserve">
          <source>Common CommonJS Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes" xml:space="preserve">
          <source>Common Questions</source>
          <target state="translated">Общие вопросы</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes" xml:space="preserve">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="translated">CommonJS/Node SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes" xml:space="preserve">
          <source>CommonJS modules are supported</source>
          <target state="translated">Поддерживаются модули CommonJS</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes" xml:space="preserve">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="translated">Импорт в стиле CommonJS / Node.js формы &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721f3299d51791dbb75d2bfe7f0acc090e15e4e0" translate="yes" xml:space="preserve">
          <source>Comparing JavaScript to an example DTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes" xml:space="preserve">
          <source>Comparing two functions</source>
          <target state="translated">Сравнение двух функций</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
