<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">Типы кортежей теперь разрешают &lt;code&gt;?&lt;/code&gt; постфикс для типов элементов, чтобы указать, что элемент является необязательным:</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">Кортежи в параметрах покоя и выражениях спреда</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">Кортежи могут быть разрушены как массивы,а деструктирующие переменные получают типы соответствующих элементов кортежа:</target>
        </trans-unit>
        <trans-unit id="13179f7189ca168af29df9bd58b2fd52c0614eb0" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6db2244dd129bbdb09e4163ada76293caa34a3" translate="yes" xml:space="preserve">
          <source>Turning on &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt; is still false:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0352b1bc1bd302b11a3202f8ca77b3b6a6074227" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;esModuleInterop&lt;/code&gt; will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler,the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f09cc50104b5125d833de6822dd696f449bdb66" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noImplicitAny&lt;/code&gt; however TypeScript will issue an error whenever it would have inferred &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dda13edded0b19f61e1d98b9a246afd41365ec8" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; will add &lt;code&gt;undefined&lt;/code&gt; to any un-declared field in the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3739330307393c6ce2638ad7c97d0bfaf15e1f19" translate="yes" xml:space="preserve">
          <source>Turning the flag on will raise an error because the unknown field uses dot syntax instead of indexed syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="0bdb148b80769233155853c95838bff4924234bc" translate="yes" xml:space="preserve">
          <source>Type Acquisition - &lt;code&gt;typeAcquisition&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">Тип псевдонима</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">Проверка типа</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">Введите Проверка файлов JavaScript</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">Введите Проверка файлов JavaScript:@enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">Введите Проверка файлов JavaScript:@это</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">Введите Проверка файлов JavaScript:@тип</target>
        </trans-unit>
        <trans-unit id="e19333b8380c7528aa2f3c6afed5b2505d7443bf" translate="yes" xml:space="preserve">
          <source>Type Checking and d.ts file generation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">Совместимость с типом</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">Совместимость с типом:Перечисления</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">Типовые гвардейцы</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">Тип охранников и дифференцирующие типы</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">Типовой вывод</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b024dbff803f7c06dae7d9c5ea0e61258a676b0c" translate="yes" xml:space="preserve">
          <source>Type Roots - &lt;code&gt;typeRoots&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">Псевдонимы типов в точности совпадают с их оригинальными типами;это просто альтернативные имена.</target>
        </trans-unit>
        <trans-unit id="0a723dcef74bc94a2959e3631f83bac96553dbc6" translate="yes" xml:space="preserve">
          <source>Type aliases are mere aliases, just like &lt;code&gt;type&lt;/code&gt; in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">Псевдонимы типа создают новое имя для типа. Псевдонимы типов иногда похожи на интерфейсы, но могут называть примитивы, объединения, кортежи и любые другие типы, которые в противном случае вам пришлось бы писать вручную.</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">Псевдонимы типов всегда имели ограничение в том, как на них можно ссылаться &amp;laquo;рекурсивно&amp;raquo;. Причина в том, что любое использование псевдонима типа должно иметь возможность заменять себя любым псевдонимом. В некоторых случаях это невозможно, поэтому компилятор отклоняет определенные рекурсивные псевдонимы, например следующие:</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">Введите аннотации</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">Аннотации типа в TypeScript-это легкий способ записи предполагаемого договора функции или переменной.В этом случае мы предполагаем,что функция greeter будет вызываться с одним строковым параметром.Вместо этого можно попробовать изменить вызов greeter на передачу массива:</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">Тип утверждение / приведение синтаксиса в &lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; режима</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">Типовые заявления</target>
        </trans-unit>
        <trans-unit id="e17ca89e78f9f5ce2baa8b85a25ab01c83ae36fb" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">Утверждения типа имеют две формы. Один из них - это синтаксис &amp;laquo;угловой скобки&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">Проверка типа оператора &lt;code&gt;instanceof&lt;/code&gt; теперь основана на том, является ли тип левого операнда &lt;em&gt;производным от&lt;/em&gt; типа, указанного правым операндом (в отличие от проверки структурного подтипа).</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">Совместимость типов в TypeScript основана на структурном подтипе.Структурное типирование-это способ соотношения типов,основанный исключительно на их членах.Это контрастирует с номинальным набором.Рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">Типовые ограждения и типовые утверждения</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">Защиты типов для имен, разделенных точками, также работают с пользовательскими функциями защиты типов и операторами &lt;code&gt;typeof&lt;/code&gt; и &lt;code&gt;instanceof&lt;/code&gt; и не зависят от &lt;code&gt;--strictNullChecks&lt;/code&gt; компилятора --strictNullChecks .</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">Тип охранники выведены из &lt;code&gt;in&lt;/code&gt; операторах</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">Тип охранников на общей территории.</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">Защитники типов ранее поддерживали только проверку локальных переменных и параметров. Защита типов теперь поддерживает проверку &amp;laquo;разделенных точками имен&amp;raquo;, состоящих из имени переменной или параметра, за которым следуют обращения к одному или нескольким свойствам.</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">Введите поля и убедитесь,что точка останова попадает в код TypeScript и что проверка работает корректно.</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">В TypeScript в некоторых случаях вывод типов также работает &amp;laquo;в обратном направлении&amp;raquo;. Это известно как &amp;laquo;контекстная типизация&amp;raquo;. Контекстная типизация происходит, когда тип выражения подразумевается его местоположением. Например:</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">Типовой вывод в условных типах</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">Введите параметр умозаключения из контекстных типов</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">Типовые параметры как ограничения</target>
        </trans-unit>
        <trans-unit id="638d8954b09678865ded4d60dc34a31605942b14" translate="yes" xml:space="preserve">
          <source>Type syntax of a C-descended language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">Расширение типа</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">Проверка типов для &lt;code&gt;globalThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">Ускорение проверки типа</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 добавляет поддержку деклараций и назначений деструкции ES6.</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">В TypeScript 1.5 добавлена поддержка ES6 для...циклов на массивах для ES3/ES5,а также полная поддержка интерфейсов Iterator при таргетировании ES6.</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5 поддерживает модули ECMAScript 6 (ES6). Модули ES6 по сути являются внешними модулями TypeScript с новым синтаксисом: модули ES6 - это отдельно загружаемые исходные файлы, которые, возможно, импортируют другие модули и предоставляют ряд доступных извне экспортов. В модулях ES6 есть несколько новых деклараций экспорта и импорта. Рекомендуется обновить библиотеки и приложения TypeScript для использования нового синтаксиса, но это не является обязательным требованием. Новый синтаксис модуля ES6 сосуществует с исходными внутренними и внешними конструкциями модулей TypeScript, и конструкции могут быть смешаны и сопоставлены по желанию.</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 добавляет новый способ сузить тип переменной внутри блока &lt;code&gt;if&lt;/code&gt; в дополнение к &lt;code&gt;typeof&lt;/code&gt; и &lt;code&gt;instanceof&lt;/code&gt; . Функции защиты определяемого пользователем типа - это функция с аннотацией возвращаемого типа в форме &lt;code&gt;x is T&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - объявленный параметр в подписи, а &lt;code&gt;T&lt;/code&gt; - любой тип. При определенной пользователем функции охранник типа вызывается переменной в , &lt;code&gt;if&lt;/code&gt; блок, тип переменной будет сужен до &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6 добавляет поддержку ключевого слова &lt;code&gt;abstract&lt;/code&gt; для классов и их методов. Абстрактный класс может иметь методы без реализации и не может быть построен.</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка выражений класса ES6.В выражении класса имя класса является необязательным и,если оно указано,находится только в области видимости в самом выражении класса.Это похоже на необязательное имя выражения функции.Невозможно ссылаться на тип экземпляра выражения класса вне выражения класса,но тип,конечно,может быть структурно подобран.Например:</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка классов,расширяющих произвольное выражение,которое вычисляет функцию конструктора.Это означает,что встроенные типы теперь могут быть расширены в объявлениях классов.</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка генераторов при нацеливании на ES6.</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6 применяет более строгие проверки назначения литералов объекта с целью выявления лишних или неправильно написанных свойств. В частности, когда новый литерал объекта присваивается переменной или передается в качестве аргумента для непустого целевого типа, для литерала объекта возникает ошибка указывать свойства, которые не существуют в целевом типе.</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6 представляет новое &lt;code&gt;.tsx&lt;/code&gt; файла .tsx . Это расширение выполняет две функции: оно включает JSX внутри файлов TypeScript и делает оператор new &lt;code&gt;as&lt;/code&gt; способом преобразования по умолчанию (устраняя любую двусмысленность между выражениями JSX и оператором преобразования префикса TypeScript). Например:</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6 представляет экспериментальную поддержку &lt;code&gt;async&lt;/code&gt; функций при ориентации на ES6. Ожидается, что асинхронные функции будут вызывать асинхронную операцию и ожидать ее результата, не блокируя нормальное выполнение программы. Это достигается за счет использования ES6-совместимой реализации &lt;code&gt;Promise&lt;/code&gt; и преобразования тела функции в совместимую форму для возобновления выполнения после завершения ожидаемой асинхронной операции.</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 представляет типы пересечений, логическое дополнение типов объединения. Тип объединения &lt;code&gt;A | B&lt;/code&gt; представляет собой объект , который является либо типа &lt;code&gt;A&lt;/code&gt; или типа &lt;code&gt;B&lt;/code&gt; , в то время как тип пересечения &lt;code&gt;A &amp;amp; B&lt;/code&gt; представляет собой объект , который является оба типа &lt;code&gt;A&lt;/code&gt; &lt;em&gt;и&lt;/em&gt; типа &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">TypeScript 1.7 добавляет &lt;code&gt;ES6&lt;/code&gt; в список опций, доступных для флага &lt;code&gt;--module&lt;/code&gt; , и позволяет вам указать вывод модуля при ориентации на &lt;code&gt;ES6&lt;/code&gt; . Это обеспечивает большую гибкость для нацеливания именно на те функции, которые вам нужны в определенных средах выполнения.</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 делает проверку шаблонов разрушения с помощью буквенных инициализаторов объектов или массивов менее жесткой и более интуитивной.</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7 поддерживает следующие &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;операторы возведения в степень ES7 / ES2016&lt;/a&gt; : &lt;code&gt;**&lt;/code&gt; и &lt;code&gt;**=&lt;/code&gt; . Операторы будут преобразованы в выводе в ES3 / ES5 с помощью &lt;code&gt;Math.pow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8 позволяет &lt;code&gt;tsconfig.json&lt;/code&gt; файлы tsconfig.json во всех типах проектов. Сюда входят проекты ASP.NET v4, &lt;em&gt;консольное приложение&lt;/em&gt; и &lt;em&gt;приложение Html с&lt;/em&gt; типами проектов &lt;em&gt;TypeScript&lt;/em&gt; . Кроме того, вы больше не ограничены одним файлом &lt;code&gt;tsconfig.json&lt;/code&gt; , но можете добавить несколько, и каждый из них будет создан как часть проекта. Это позволяет вам разделять конфигурацию для разных частей вашего приложения без необходимости использовать несколько разных проектов.</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8 позволяет пользователям использовать аргумент &lt;code&gt;--outFile&lt;/code&gt; со специальными объектами файловой системы, такими как именованные каналы, устройства и т. Д.</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8 расширяет &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;определяемые пользователем функции защиты типов&lt;/a&gt; до методов класса и интерфейса.</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8 улучшает вывод типов, включая исходную и целевую стороны, которые являются типами объединения или пересечения. Например, при выводе из &lt;code&gt;string | string[]&lt;/code&gt; в &lt;code&gt;string | T&lt;/code&gt; , мы уменьшаем типы для &lt;code&gt;string[]&lt;/code&gt; и &lt;code&gt;T&lt;/code&gt; , тем самым выводя &lt;code&gt;string[]&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 представляет анализ потока управления,чтобы помочь отловить распространенные ошибки,с которыми обычно сталкиваются пользователи.Читайте дальше,чтобы получить более подробную информацию,и проверьте эти ошибки в действии:</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">TypeScript 2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0 добавляет новый &lt;code&gt;--skipLibCheck&lt;/code&gt; компилятора &lt;code&gt;.d.ts&lt;/code&gt; позволяет пропускать проверку типов файлов объявлений (файлов с расширением .d.ts ). Когда программа включает большие файлы объявлений, компилятор тратит много времени на проверку типов объявлений, которые уже заведомо не содержат ошибок, и время компиляции может быть значительно сокращено за счет пропуска проверок типов файлов объявлений.</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">В TypeScript 2.0 есть два новых флага, которые помогут вам поддерживать чистую базу кода. &lt;code&gt;--noUnusedParameters&lt;/code&gt; отмечает любые неиспользуемые ошибки параметров функции или метода. &lt;code&gt;--noUnusedLocals&lt;/code&gt; помечает любые неиспользуемые локальные ( неэкспортированные ) объявления, такие как переменные, функции, классы, импорт и т. д. Кроме того, неиспользуемые частные члены класса будут помечены как ошибки в &lt;code&gt;--noUnusedLocals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0 реализует анализ типов на основе потока управления для локальных переменных и параметров. Раньше анализ типов, выполняемый для защиты типов, ограничивался операторами &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;?:&lt;/code&gt; Условными выражениями и не включал эффекты присваиваний и конструкций потока управления, такие как операторы &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;break&lt;/code&gt; . В TypeScript 2.0 средство проверки типов анализирует все возможные потоки управления в операторах и выражениях, чтобы создать наиболее конкретный возможный тип ( &lt;em&gt;суженный тип&lt;/em&gt; ) в любом заданном месте для локальной переменной или параметра, который объявлен как имеющий тип объединения.</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0 реализует поддержку помеченных (или размеченных) типов объединения. В частности, компилятор TS теперь поддерживает средства защиты типов, которые сужают типы объединения на основе тестов дискриминантного свойства и, кроме того, расширяют эту возможность для операторов &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0 &lt;code&gt;never&lt;/code&gt; вводит новый примитивный тип . Тип &lt;code&gt;never&lt;/code&gt; представляет собой тип значений, которые никогда не встречаются. В частности, &lt;code&gt;never&lt;/code&gt; является возвращаемым типом для функций, которые никогда не возвращаются, и &lt;code&gt;never&lt;/code&gt; является типом переменных в рамках защиты типов, которые никогда не являются истинными.</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0 предоставляет набор дополнительных кнопок разрешения модуля, чтобы &lt;em&gt;сообщить&lt;/em&gt; компилятору, где найти объявления для данного модуля.</target>
        </trans-unit>
        <trans-unit id="3f3705d152a2f1f40c51f05e54dd28f6cc6cc047" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have &lt;em&gt;identical&lt;/em&gt; types.</source>
          <target state="translated">TypeScript 2.0 ослабляет это ограничение и позволяет дублировать идентификаторы в блоках, если они имеют &lt;em&gt;одинаковые&lt;/em&gt; типы.</target>
        </trans-unit>
        <trans-unit id="1a29a22cd01cb9654bf025f544accb002ba6f777" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 supports the use of the wildcard character (&lt;code&gt;*&lt;/code&gt;) to declare a &amp;ldquo;family&amp;rdquo; of module names; this way, a declaration is only required once for an extension, and not for every resource.</source>
          <target state="translated">TypeScript 2.0 поддерживает использование подстановочного знака ( &lt;code&gt;*&lt;/code&gt; ) для объявления &amp;laquo;семейства&amp;raquo; имен модулей; таким образом, объявление требуется только один раз для расширения, а не для каждого ресурса.</target>
        </trans-unit>
        <trans-unit id="e87039bc208381c858aaf91b34ef9a99581764c4" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1</source>
          <target state="translated">TypeScript 2.1</target>
        </trans-unit>
        <trans-unit id="0eb31cb3569ffcba88f7cd6f2aa1426af6d2ca9f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.</source>
          <target state="translated">ТипScript 2.1 позволяет включить эти файлы в ваш проект один раз в отдельный модуль,и компилятор будет выдавать им импорты по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="4d20c0e4270450dc5df5d6df69b86f9a3084c753" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 brings support for &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.1 обеспечивает поддержку &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;ESnext Spread and Rest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a2602f6bc15b060152681aebb2deae22d1b7344" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports inheriting configuration using &lt;code&gt;extends&lt;/code&gt;, where:</source>
          <target state="translated">TypeScript 2.1 поддерживает наследование конфигурации с использованием &lt;code&gt;extends&lt;/code&gt; , где:</target>
        </trans-unit>
        <trans-unit id="e46023b88cb014edcb72d5fe91dd5e9bb7df4962" translate="yes" xml:space="preserve">
          <source>TypeScript 2.1 supports three new target values &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.1 поддерживает три новых целевых значения &lt;code&gt;--target ES2016&lt;/code&gt; , &lt;code&gt;--target ES2017&lt;/code&gt; и &lt;code&gt;--target ESNext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b933ffe70d107fc6bfc7a208af67d2175dec62d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2</source>
          <target state="translated">TypeScript 2.2</target>
        </trans-unit>
        <trans-unit id="af11383d0a489a01508b14d16cfebecdac9851f5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;MDN Mixin description&lt;/a&gt; and &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;&amp;ldquo;Real&amp;rdquo; Mixins with JavaScript Classes&lt;/a&gt; for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.</source>
          <target state="translated">В TypeScript 2.2 добавлена ​​поддержка шаблона класса миксина ECMAScript 2015 (подробности см. В &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Mix-ins&quot;&gt;описании миксина MDN&lt;/a&gt; и &lt;a href=&quot;http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;&amp;laquo;Реальные&amp;raquo; миксины с классами JavaScript&lt;/a&gt; ), а также правил комбинирования сигнатур миксинов с сигнатурами обычных конструкций в типах пересечений.</target>
        </trans-unit>
        <trans-unit id="0a2dbbdfdaba8d57c906119c6fac6d8266bfac36" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 adds support for using spread on a JSX element children. Please see &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook/jsx#57&lt;/a&gt; for more details.</source>
          <target state="translated">TypeScript 2.2 добавляет поддержку использования распространения для дочерних элементов JSX. Пожалуйста, смотрите &lt;a href=&quot;https://github.com/facebook/jsx/issues/57&quot;&gt;facebook / jsx # 57&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="4c48aa745cc516094ac80f0eaa3816fe06bddfbf" translate="yes" xml:space="preserve">
          <source>TypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:</source>
          <target state="translated">В TypeScript 2.2 улучшена проверка нулевых операндов в выражениях.В частности,теперь они помечены как ошибки:</target>
        </trans-unit>
        <trans-unit id="d38d07af3e985997222428fd513a69781f6cc8f7" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3</source>
          <target state="translated">TypeScript 2.3</target>
        </trans-unit>
        <trans-unit id="b61f4d2dcbfa7df846edf73961314986771cb44f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with &lt;code&gt;--downlevelIteration&lt;/code&gt; flag.</source>
          <target state="translated">TypeScript 2.3 добавляет полную поддержку генераторов и протокола Iterator для целей ES3 и ES5 с флагом &lt;code&gt;--downlevelIteration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7db822200563cfa58805541c7f52f40509bd7eb" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for declaring defaults for generic type parameters.</source>
          <target state="translated">В TypeScript 2.3 добавлена поддержка объявления параметров общего типа по умолчанию.</target>
        </trans-unit>
        <trans-unit id="576c3abf51df0a1e8501d6946731fd5b93e9a596" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 adds support for the async iterators and generators as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.3 добавляет поддержку асинхронных итераторов и генераторов, как описано в текущем &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;предложении TC39&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9905a786ea9066024ac4028d0fd104e321fa970" translate="yes" xml:space="preserve">
          <source>TypeScript 2.3 and later support type-checking and reporting errors in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.3 и более поздние &lt;code&gt;--checkJs&lt;/code&gt; поддерживают проверку типов и сообщения об ошибках в файлах &lt;code&gt;.js&lt;/code&gt; с помощью --checkJs .</target>
        </trans-unit>
        <trans-unit id="a711e374d74b34d98e80b0011ffc309914ec3f56" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4</source>
          <target state="translated">TypeScript 2.4</target>
        </trans-unit>
        <trans-unit id="63121e1a86e22e0c3bb62dbea7a515bd9e567278" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</source>
          <target state="translated">TypeScript 2.4 вносит несколько замечательных изменений в способ представления генериков.</target>
        </trans-unit>
        <trans-unit id="4047de971a7748310180f70bca2f83ce413444e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces the concept of &amp;ldquo;weak types&amp;rdquo;. Any type that contains nothing but a set of all-optional properties is considered to be &lt;em&gt;weak&lt;/em&gt;. For example, this &lt;code&gt;Options&lt;/code&gt; type is a weak type:</source>
          <target state="translated">TypeScript 2.4 вводит понятие &amp;laquo;слабых типов&amp;raquo;. Любой тип, который не содержит ничего, кроме набора необязательных свойств, считается &lt;em&gt;слабым&lt;/em&gt; . Например, этот тип &lt;code&gt;Options&lt;/code&gt; является слабым типом:</target>
        </trans-unit>
        <trans-unit id="86b2369322c0e2cb12bd30f7af1523fb15f271df" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</source>
          <target state="translated">ТипScript 2.4 вводит более строгий подход к двум типам обратного вызова.Например:</target>
        </trans-unit>
        <trans-unit id="76b70868a8ecce2623fa642627ea2865c40679ae" translate="yes" xml:space="preserve">
          <source>TypeScript 2.4 now allows enum members to contain string initializers.</source>
          <target state="translated">TypeScript 2.4 теперь позволяет членам перечисления содержать инициализаторы строк.</target>
        </trans-unit>
        <trans-unit id="c757b8632386bce7302d5253a3fe5a403ad48f5b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5</source>
          <target state="translated">TypeScript 2.5</target>
        </trans-unit>
        <trans-unit id="96d62a44f6ecea4f2d8ccb3d978b4697f85a8fe0" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 brings the &lt;code&gt;preserveSymlinks&lt;/code&gt; flag, which parallels the behavior of &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the &lt;code&gt;--preserve-symlinks&lt;/code&gt; flag in Node.js&lt;/a&gt;. This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and vice-versa).</source>
          <target state="translated">Машинописи 2.5 приносит &lt;code&gt;preserveSymlinks&lt;/code&gt; флаг, который параллелен поведение &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;в &lt;code&gt;--preserve-symlinks&lt;/code&gt; флага в Node.js&lt;/a&gt; . Этот флаг также демонстрирует поведение , противоположного WebPack в &lt;code&gt;resolve.symlinks&lt;/code&gt; вариант (т.е. установка машинописи в &lt;code&gt;preserveSymlinks&lt;/code&gt; к &lt;code&gt;true&lt;/code&gt; параллелям установка WebPack в &lt;code&gt;resolve.symlinks&lt;/code&gt; в &lt;code&gt;false&lt;/code&gt; , и наоборот).</target>
        </trans-unit>
        <trans-unit id="c8ad58c085604fcd7c2e1f3468a3e3e991a926ce" translate="yes" xml:space="preserve">
          <source>TypeScript 2.5 introduces the ability to &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;assert the type of expressions when using plain JavaScript in your projects&lt;/a&gt;. The syntax is an &lt;code&gt;/** @type {...} */&lt;/code&gt; annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:</source>
          <target state="translated">TypeScript 2.5 предоставляет возможность &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/5158&quot;&gt;утверждать тип выражений при использовании простого JavaScript в ваших проектах&lt;/a&gt; . Синтаксис представляет собой комментарий аннотации &lt;code&gt;/** @type {...} */&lt;/code&gt; за которым следует выражение в скобках, тип которого необходимо повторно оценить. Например:</target>
        </trans-unit>
        <trans-unit id="669d038e7cc1925c80d686495e192a922f14d7e5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6</source>
          <target state="translated">TypeScript 2.6</target>
        </trans-unit>
        <trans-unit id="f05ad28a2eccdd4292c999695e9643dff88f04a9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 adds revised implementation the &lt;code&gt;--noUnusedLocals&lt;/code&gt; and &lt;code&gt;--noUnusedParameters&lt;/code&gt;&lt;a href=&quot;../compiler-options&quot;&gt;compiler options&lt;/a&gt;. Declarations are only written to but never read from are now flagged as unused.</source>
          <target state="translated">TypeScript 2.6 добавляет обновленную реализацию &lt;code&gt;--noUnusedLocals&lt;/code&gt; &lt;a href=&quot;../compiler-options&quot;&gt;компилятора &lt;/a&gt;--noUnusedLocals и &lt;code&gt;--noUnusedParameters&lt;/code&gt; . Объявления только записываются, но никогда не читаются, теперь они помечаются как неиспользуемые.</target>
        </trans-unit>
        <trans-unit id="b3d5a37c18c460f27ef01973c59f69c2b7e4b6db" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 also improves type inference involving contravariant positions:</source>
          <target state="translated">TypeScript 2.6 также улучшает типовые умозаключения,связанные с позициями контрварианта:</target>
        </trans-unit>
        <trans-unit id="597afbba7d51bc72adeb8bdd4361ee8ee1244087" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 brings a faster &lt;code&gt;--watch&lt;/code&gt; implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in &lt;em&gt;only&lt;/em&gt; regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.</source>
          <target state="translated">TypeScript 2.6 обеспечивает более &lt;code&gt;--watch&lt;/code&gt; реализацию --watch . В новой версии оптимизируется генерация кода и проверка кодовых баз с помощью модулей ES. Изменения, обнаруженные в файле модуля, приведут к восстановлению &lt;em&gt;только&lt;/em&gt; измененного модуля и файлов, которые от него зависят, а не всего проекта. Это изменение принесет наибольшую пользу проектам с большим количеством файлов.</target>
        </trans-unit>
        <trans-unit id="bff2120308b7a70612c6347b0884825c125b9bb6" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;ECMAScript spec&lt;/a&gt;, every time a template tag is evaluated, the &lt;em&gt;same&lt;/em&gt; template strings object (the same &lt;code&gt;TemplateStringsArray&lt;/code&gt;) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.6 исправляет испускание шаблона строки с тегами, чтобы лучше согласоваться со спецификацией ECMAScript. Согласно &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-gettemplateobject&quot;&gt;спецификации ECMAScript&lt;/a&gt; , каждый раз, когда оценивается тег шаблона, в качестве первого аргумента должен передаваться тот &lt;em&gt;же&lt;/em&gt; объект строк шаблона (тот же &lt;code&gt;TemplateStringsArray&lt;/code&gt; ). До TypeScript 2.6 генерируемый результат каждый раз представлял собой совершенно новый объект шаблона. Хотя содержимое строки одинаково, это излучение влияет на библиотеки, которые используют идентификатор строки для целей аннулирования кеша, например &lt;a href=&quot;https://github.com/PolymerLabs/lit-html/issues/58&quot;&gt;lit-html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3332e1f0228da76e93e5e699b31c42f80f487ec2" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 introduces a new strict checking flag, &lt;code&gt;--strictFunctionTypes&lt;/code&gt;. The &lt;code&gt;--strictFunctionTypes&lt;/code&gt; switch is part of the &lt;code&gt;--strict&lt;/code&gt; family of switches, meaning that it defaults to on in &lt;code&gt;--strict&lt;/code&gt; mode. You can opt-out by setting &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; on your command line or in your tsconfig.json.</source>
          <target state="translated">TypeScript 2.6 представляет новый флаг строгой проверки &lt;code&gt;--strictFunctionTypes&lt;/code&gt; . Переключатель &lt;code&gt;--strictFunctionTypes&lt;/code&gt; является частью семейства переключателей &lt;code&gt;--strict&lt;/code&gt; , что означает, что он по умолчанию &lt;code&gt;--strict&lt;/code&gt; режиме --strict . Вы можете отказаться, установив &lt;code&gt;--strictFunctionTypes false&lt;/code&gt; в командной строке или в файле tsconfig.json.</target>
        </trans-unit>
        <trans-unit id="50b83579cf141ddf3a24a6600e359e207807258a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using &lt;code&gt;--locale&lt;/code&gt; flag on the command line.</source>
          <target state="translated">Пакет npm TypeScript 2.6 поставляется с локализованными версиями диагностических сообщений для 13 языков. Локализованные сообщения доступны при использовании флага &lt;code&gt;--locale&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="71107e6f11d3d9498db10524c3f3c164f19e9415" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 support suppressing errors in .js files using &lt;code&gt;// @ts-ignore&lt;/code&gt; comments placed above the offending lines.</source>
          <target state="translated">TypeScript 2.6 поддерживает подавление ошибок в файлах .js с помощью &lt;code&gt;// @ts-ignore&lt;/code&gt; комментариев, размещенных над ошибочными строками.</target>
        </trans-unit>
        <trans-unit id="bef45e6468d0c0a17f09c30d2b82dd8a05124a51" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7</source>
          <target state="translated">TypeScript 2.7</target>
        </trans-unit>
        <trans-unit id="79e7e447b60909166288dcf8cb72e27e89f7cec5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</source>
          <target state="translated">В TypeScript 2.7 добавлена поддержка объявления свойств const-named на типах,включающих символы ECMAScript.</target>
        </trans-unit>
        <trans-unit id="a51783c99c59b3257833940324affc2689b71a24" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 also introduced &lt;code&gt;--watch&lt;/code&gt; mode builds via a new incremental &amp;ldquo;builder&amp;rdquo; API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing &lt;em&gt;intra&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 2.7 также представил &lt;code&gt;--watch&lt;/code&gt; режиме --watch через новый инкрементный API-интерфейс &amp;laquo;построителя&amp;raquo;. В том же духе вся идея заключается в том, что этот режим только повторно проверяет и повторно генерирует измененные файлы или файлы, зависимости которых могут повлиять на проверку типов. Вы можете думать об этом как об оптимизации &lt;em&gt;внутрипроектных&lt;/em&gt; сборок.</target>
        </trans-unit>
        <trans-unit id="162b6515dd83712cce22c0f4cc8d254c9b33661b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 brings support for &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators&lt;/a&gt;. Numeric literals can now be separated into segments using &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.7 поддерживает &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;числовые разделители ES&lt;/a&gt; . Числовые литералы теперь можно разделить на сегменты с помощью &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af59c15c50945a988e8dab909a898e4259657c00" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves the handling of structurally identical classes in union types and &lt;code&gt;instanceof&lt;/code&gt; expressions:</source>
          <target state="translated">TypeScript 2.7 улучшает обработку структурно идентичных классов в типах union и выражениях &lt;code&gt;instanceof&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91f038aff687710c549846983751034fac966226" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now &lt;em&gt;normalize&lt;/em&gt; the object literal types such that all properties are present in each constituent of the union type.</source>
          <target state="translated">TypeScript 2.7 улучшает вывод типов для нескольких объектных литералов, встречающихся в одном контексте. Когда несколько типов литералов объектов вносят вклад в тип объединения, мы теперь &lt;em&gt;нормализуем&lt;/em&gt; типы литералов объекта так, чтобы все свойства присутствовали в каждой составляющей типа объединения.</target>
        </trans-unit>
        <trans-unit id="6ab94d5588595f01a47bea04f5db381bcbb5dba9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 introduces a new flag called &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example</source>
          <target state="translated">TypeScript 2.7 представляет новый флаг &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; . Этот флаг выполняет проверки, чтобы гарантировать, что каждое свойство экземпляра класса инициализируется в теле конструктора или инициализатором свойства. Например</target>
        </trans-unit>
        <trans-unit id="50a1f4f6bc66299bafe27e7f60a3413972205937" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an &lt;code&gt;__esModule&lt;/code&gt; indicator under &lt;code&gt;--esModuleInterop&lt;/code&gt;. The change brings the generated output from TypeScript closer to that generated by Babel.</source>
          <target state="translated">Машинописи 2.7 обновление CommonJS / AMD / УМД модуль Испустите синтезировать пространство имен записи , основанные на присутствии &lt;code&gt;__esModule&lt;/code&gt; индикатора под &lt;code&gt;--esModuleInterop&lt;/code&gt; . Это изменение приближает сгенерированный вывод TypeScript к генерируемому Babel.</target>
        </trans-unit>
        <trans-unit id="4e42d10f15cd2510b82037d64e9dbecd5c11e732" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8</source>
          <target state="translated">TypeScript 2.8</target>
        </trans-unit>
        <trans-unit id="3b84208a266962375c246ada5aa0bd123c9cfe9e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds several predefined conditional types to &lt;code&gt;lib.d.ts&lt;/code&gt;:</source>
          <target state="translated">TypeScript 2.8 добавляет в &lt;code&gt;lib.d.ts&lt;/code&gt; несколько предопределенных условных типов :</target>
        </trans-unit>
        <trans-unit id="c5e0ed8e368b2f12d192ed317481ad4102d428b8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for a per-file configurable JSX factory name using &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory can be configured for a compilation using &lt;code&gt;--jsxFactory&lt;/code&gt; (default is &lt;code&gt;React.createElement&lt;/code&gt;). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</source>
          <target state="translated">TypeScript 2.8 добавляет поддержку настраиваемого имени фабрики JSX для каждого файла с помощью &lt;code&gt;@jsx dom&lt;/code&gt; . Фабрику JSX можно настроить для компиляции с помощью &lt;code&gt;--jsxFactory&lt;/code&gt; (по умолчанию &lt;code&gt;React.createElement&lt;/code&gt; ). В TypeScript 2.8 вы можете переопределить это для каждого файла, добавив комментарий в начало файла.</target>
        </trans-unit>
        <trans-unit id="4f6ad1955b40525b81ee6b350e3efda1dca7803e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for understanding more namespace patterns in &lt;code&gt;.js&lt;/code&gt; files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</source>
          <target state="translated">TypeScript 2.8 добавляет поддержку для понимания большего количества шаблонов пространств имен в файлах &lt;code&gt;.js&lt;/code&gt; . Объявления пустых объектных литералов на верхнем уровне, как и функции и классы, теперь распознаются как объявления пространств имен в JavaScript.</target>
        </trans-unit>
        <trans-unit id="f9e15ad123318d14a1567d61a8eb9b88ec3f14c9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; property modifier in a mapped type can now be prefixed with either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to indicate that the modifier should be added or removed.</source>
          <target state="translated">TypeScript 2.8 добавляет возможность сопоставленного типа добавлять или удалять определенный модификатор. В частности, только для &lt;code&gt;readonly&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; Модификатор свойства в сопоставленном типе теперь может иметь префикс &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , чтобы указать, что модификатор должен быть добавлен или удален.</target>
        </trans-unit>
        <trans-unit id="ccbc7d666b3ba41052f2f21dcaf1e812e9bac36a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 introduces &lt;em&gt;conditional types&lt;/em&gt; which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="translated">TypeScript 2.8 представляет &lt;em&gt;условные типы,&lt;/em&gt; которые добавляют возможность выражать неоднородные сопоставления типов. Условный тип выбирает один из двух возможных типов на основе условия, выраженного как проверка отношения типов:</target>
        </trans-unit>
        <trans-unit id="38d22337c31f40538f05a1b3be32d35d5d040ad3" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9</source>
          <target state="translated">TypeScript 2.9</target>
        </trans-unit>
        <trans-unit id="79a8a3cdfaf2e7ea5b694163b786814a57e8ccbe" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 adds support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties in index types and mapped types. Previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties.</source>
          <target state="translated">TypeScript 2.9 добавляет поддержку свойств с именами &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;symbol&lt;/code&gt; в типах индексов и сопоставленных типах. Ранее оператор &lt;code&gt;keyof&lt;/code&gt; и сопоставленные типы поддерживали только &lt;code&gt;string&lt;/code&gt; именованные свойства.</target>
        </trans-unit>
        <trans-unit id="f3af31e687b53bc6028a7656648578f8526d1535" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 allows passing generic type arguments to tagged template strings.</source>
          <target state="translated">TypeScript 2.9 позволяет передавать общие аргументы типов в теги строк шаблона.</target>
        </trans-unit>
        <trans-unit id="c576ebab33996a3a7642529b1b3cf098557fad0c" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 and earlier didn&amp;rsquo;t leverage &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt; declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of &lt;code&gt;render&lt;/code&gt;, or they&amp;rsquo;d use type-assertions to fix up the type of the component before exporting it.</source>
          <target state="translated">TypeScript 2.9 и более ранние версии не использовали объявления &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt; &lt;/a&gt; внутри компонентов JSX. Пользователям часто приходилось объявлять свойства необязательными и использовать ненулевые утверждения внутри &lt;code&gt;render&lt;/code&gt; , либо они использовали утверждения типа, чтобы исправить тип компонента перед его экспортом.</target>
        </trans-unit>
        <trans-unit id="54d0224b3f561c10aa0b8f9cc4af3cf6fc0acd70" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 introduces support for &lt;code&gt;import.meta&lt;/code&gt;, a new meta-property as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.9 представляет поддержку &lt;code&gt;import.meta&lt;/code&gt; , нового метасвойства , как описано в текущем &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;предложении TC39&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff47669d6e3d77ab534a2150af62bcea4228ce7e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0</source>
          <target state="translated">TypeScript 3.0</target>
        </trans-unit>
        <trans-unit id="1b5495b8f8bb8ada5fe9aabb083f17ca19955412" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support for a new type alias in the &lt;code&gt;JSX&lt;/code&gt; namespace called &lt;code&gt;LibraryManagedAttributes&lt;/code&gt;. This helper type defines a transformation on the component&amp;rsquo;s &lt;code&gt;Props&lt;/code&gt; type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</source>
          <target state="translated">TypeScript 3.0 добавляет поддержку нового псевдонима типа в пространстве имен &lt;code&gt;JSX&lt;/code&gt; , называемого &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; . Этот вспомогательный тип определяет преобразование типа &lt;code&gt;Props&lt;/code&gt; компонента перед использованием для проверки нацеленного на него выражения JSX; таким образом, позволяя настраивать такие параметры, как: как обрабатываются конфликты между предоставленными и предполагаемыми реквизитами, как отображаются выводы, как обрабатываются возможности и как следует комбинировать выводы из разных мест.</target>
        </trans-unit>
        <trans-unit id="898331749799c0ae0af6a27a2c4a2bf1b9107b53" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:</source>
          <target state="translated">В TypeScript 3.0 добавлена поддержка множества новых возможностей взаимодействия со списками параметров функций в качестве типов кортежей.В TypeScript 3.0 добавлена поддержка:</target>
        </trans-unit>
        <trans-unit id="24d0fe89da15fd3c400693e525d5250f550dd57a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 also introduces a new mode for tsc, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand-in-hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">TypeScript 3.0 также представляет новый режим для tsc, флаг &lt;code&gt;--build&lt;/code&gt; , который работает рука об руку со ссылками на проекты, чтобы обеспечить более быструю сборку TypeScript.</target>
        </trans-unit>
        <trans-unit id="76ebacc06303039a717759a1bc81f839c55d819c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced a new feature for structuring builds called &amp;ldquo;composite projects&amp;rdquo;. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use &lt;code&gt;--build&lt;/code&gt; mode to recompile only the set of projects and dependencies. You can think of this as optimizing &lt;em&gt;inter&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 3.0 представил новую функцию для структурирования сборок, называемую &amp;laquo;составными проектами&amp;raquo;. Частично цель здесь заключалась в том, чтобы пользователи могли разбивать большие проекты на более мелкие части, которые быстро строятся и сохраняют структуру проекта, без ущерба для существующего опыта TypeScript. Благодаря составным проектам TypeScript может использовать режим &lt;code&gt;--build&lt;/code&gt; для перекомпиляции только набора проектов и зависимостей. Вы можете думать об этом как об оптимизации &lt;em&gt;межпроектных&lt;/em&gt; сборок.</target>
        </trans-unit>
        <trans-unit id="12be550f3be8a1f6da19a996860414de543a9312" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced support for referencing other and building them incrementally using the &lt;code&gt;--build&lt;/code&gt; flag. Additionally, TypeScript 3.4 introduced the &lt;code&gt;--incremental&lt;/code&gt; flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn&amp;rsquo;t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</source>
          <target state="translated">В TypeScript 3.0 появилась поддержка ссылок на другие и их постепенного построения с использованием флага &lt;code&gt;--build&lt;/code&gt; . Кроме того, TypeScript 3.4 представил флаг &lt;code&gt;--incremental&lt;/code&gt; для сохранения информации о предыдущих компиляциях только для восстановления определенных файлов. Эти флаги были невероятно полезны для более гибкого структурирования проектов и ускорения создания. К сожалению, использование этих флагов не работает со сторонними инструментами сборки, такими как Gulp и Webpack. TypeScript 3.6 теперь предоставляет два набора API для работы со ссылками на проекты и инкрементного построения программы.</target>
        </trans-unit>
        <trans-unit id="ef2e2b53b736d1c6d2b067c0b85011c12a528c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing &lt;code&gt;tsconfig.json&lt;/code&gt; files to reference other &lt;code&gt;tsconfig.json&lt;/code&gt; files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.</source>
          <target state="translated">TypeScript 3.0 представляет новую концепцию ссылок на проекты. Ссылки на проекты позволяют проектам TypeScript зависеть от других проектов TypeScript, в частности, разрешая файлам &lt;code&gt;tsconfig.json&lt;/code&gt; ссылаться на другие файлы &lt;code&gt;tsconfig.json&lt;/code&gt; . Указание этих зависимостей упрощает разделение вашего кода на более мелкие проекты, поскольку дает TypeScript (и инструментам, связанным с ним) способ понять порядок сборки и структуру вывода.</target>
        </trans-unit>
        <trans-unit id="303ce39af16c9af3efeedd99c02704afd6f021df" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new top type &lt;code&gt;unknown&lt;/code&gt;. &lt;code&gt;unknown&lt;/code&gt; is the type-safe counterpart of &lt;code&gt;any&lt;/code&gt;. Anything is assignable to &lt;code&gt;unknown&lt;/code&gt;, but &lt;code&gt;unknown&lt;/code&gt; isn&amp;rsquo;t assignable to anything but itself and &lt;code&gt;any&lt;/code&gt; without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an &lt;code&gt;unknown&lt;/code&gt; without first asserting or narrowing to a more specific type.</source>
          <target state="translated">TypeScript 3.0 представляет новый топ-тип &lt;code&gt;unknown&lt;/code&gt; . &lt;code&gt;unknown&lt;/code&gt; является типобезопасным аналогом &lt;code&gt;any&lt;/code&gt; . Все может быть присвоено &lt;code&gt;unknown&lt;/code&gt; , но &lt;code&gt;unknown&lt;/code&gt; не может быть назначено никому , кроме самого себя и &lt;code&gt;any&lt;/code&gt; без утверждения типа или сужения на основе потока управления. Точно так же нельзя выполнять операции с &lt;code&gt;unknown&lt;/code&gt; без предварительного утверждения или сужения до более конкретного типа.</target>
        </trans-unit>
        <trans-unit id="7978444d69de42e59647fdd6e697c61c835aefcc" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1</source>
          <target state="translated">TypeScript 3.1</target>
        </trans-unit>
        <trans-unit id="277efbe36e840571109f3bbb5578c95d9d3c2d0f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1 brings the ability to define properties on function declarations and &lt;code&gt;const&lt;/code&gt;-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to &lt;code&gt;namespace&lt;/code&gt; hacks. For example:</source>
          <target state="translated">TypeScript 3.1 предоставляет возможность определять свойства в объявлениях функций и функциях, объявленных &lt;code&gt;const&lt;/code&gt; , просто путем присвоения свойств этим функциям в той же области. Это позволяет нам писать канонический код JavaScript, не прибегая к взломам &lt;code&gt;namespace&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b9f00fd1052d436127e4de48e371112ca1399051" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2</source>
          <target state="translated">TypeScript 3.2</target>
        </trans-unit>
        <trans-unit id="1bd9c97a859cbb3246a80b48f6fdb33c3666de34" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; helper types from &lt;code&gt;lib.d.ts&lt;/code&gt;, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</source>
          <target state="translated">TypeScript 3.2 также позволяет деструктурировать привязку отдыха из общей переменной. Это достигается за счет использования предопределенных вспомогательных типов &lt;code&gt;Pick&lt;/code&gt; и &lt;code&gt;Exclude&lt;/code&gt; из &lt;code&gt;lib.d.ts&lt;/code&gt; , а также использования рассматриваемого универсального типа, а также имен других привязок в шаблоне деструктуризации.</target>
        </trans-unit>
        <trans-unit id="32739636ab98224be8b965eab8472c294e08c8bd" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 introduces a new &lt;code&gt;--strictBindCallApply&lt;/code&gt; compiler option (in the &lt;code&gt;--strict&lt;/code&gt; family of options) with which the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on function objects are strongly typed and strictly checked.</source>
          <target state="translated">TypeScript 3.2 представляет новый &lt;code&gt;--strictBindCallApply&lt;/code&gt; компилятора --strictBindCallApply (в семействе параметров &lt;code&gt;--strict&lt;/code&gt; ), с помощью которого методы &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; к объектам функций строго типизированы и строго проверяются.</target>
        </trans-unit>
        <trans-unit id="b0c6e2bed7992d15f04fd899cadd250b20a960e6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain &lt;em&gt;some&lt;/em&gt; singleton type (e.g. a string literal, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;), and they contain no generics.</source>
          <target state="translated">TypeScript 3.2 упрощает сужение, ослабляя правила того, что он считает дискриминантным свойством. Общие свойства объединений теперь считаются дискриминантами, если они содержат &lt;em&gt;какой-либо&lt;/em&gt; одноэлементный тип (например, строковый литерал, &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; ) и не содержат универсальных типов .</target>
        </trans-unit>
        <trans-unit id="7a26700dbb32ecd2b75ac980f07316d21f373a07" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 now resolves &lt;code&gt;tsconfig.json&lt;/code&gt;s from &lt;code&gt;node_modules&lt;/code&gt;. When using a bare path for the &lt;code&gt;&quot;extends&quot;&lt;/code&gt; field in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript will dive into &lt;code&gt;node_modules&lt;/code&gt; packages for us.</source>
          <target state="translated">TypeScript 3.2 теперь разрешает &lt;code&gt;tsconfig.json&lt;/code&gt; из &lt;code&gt;node_modules&lt;/code&gt; . При использовании &lt;code&gt;tsconfig.json&lt;/code&gt; пути для поля &lt;code&gt;&quot;extends&quot;&lt;/code&gt; в tsconfig.json TypeScript будет за нас погружаться в пакеты &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfd2b961db2e8cd46070f763e5c724b34d770631" translate="yes" xml:space="preserve">
          <source>TypeScript 3.3</source>
          <target state="translated">TypeScript 3.3</target>
        </trans-unit>
        <trans-unit id="151f809570316cd705748f077714354101e09c3c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4</source>
          <target state="translated">TypeScript 3.4</target>
        </trans-unit>
        <trans-unit id="289b2ef5b5dba27b6f9d27a73f1f934655330ac2" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 also introduces new support for &lt;code&gt;readonly&lt;/code&gt; tuples. We can prefix any tuple type with the &lt;code&gt;readonly&lt;/code&gt; keyword to make it a &lt;code&gt;readonly&lt;/code&gt; tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, &lt;code&gt;readonly&lt;/code&gt; tuples only permit reading from those positions.</source>
          <target state="translated">TypeScript 3.4 также представляет новую поддержку кортежей только для &lt;code&gt;readonly&lt;/code&gt; . Мы можем префикс любого типа кортежа с помощью ключевого слова &lt;code&gt;readonly&lt;/code&gt; , чтобы сделать его кортежем только для &lt;code&gt;readonly&lt;/code&gt; , так же, как мы теперь можем с сокращенным синтаксисом массива. Как и следовало ожидать, в отличие от обычных кортежи , чьи Слоты могут быть записаны, &lt;code&gt;readonly&lt;/code&gt; кортежи только позволяют чтение с этих позиций.</target>
        </trans-unit>
        <trans-unit id="d5ae4e4e2dd524eb742ca067c90d1124fa510b9b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.</source>
          <target state="translated">TypeScript 3.4 теперь может производить общие типы функций,когда вывод из других общих функций производит свободные переменные типа для умозаключений.Это означает,что многие образцы состава функций теперь работают лучше в 3.4.</target>
        </trans-unit>
        <trans-unit id="bf09bd81476b0409b652aa37d69d0d04e6689320" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new construct for literal values called &lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt; assertions. Its syntax is a type assertion with &lt;code&gt;const&lt;/code&gt; in place of the type name (e.g. &lt;code&gt;123 as const&lt;/code&gt;). When we construct new literal expressions with &lt;code&gt;const&lt;/code&gt; assertions, we can signal to the language that</source>
          <target state="translated">TypeScript 3.4 представляет новую конструкцию для литеральных значений, называемую &lt;em&gt; &lt;code&gt;const&lt;/code&gt; &lt;/em&gt; утверждениями. Его синтаксис - это утверждение типа с &lt;code&gt;const&lt;/code&gt; вместо имени типа (например, &lt;code&gt;123 as const&lt;/code&gt; ). Когда мы создаем новые литеральные выражения с утверждениями &lt;code&gt;const&lt;/code&gt; , мы можем сигнализировать языку, что</target>
        </trans-unit>
        <trans-unit id="1d6b24572a67a82fae359fdfff1468ec35fb0de9" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new flag called &lt;code&gt;--incremental&lt;/code&gt; which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with &lt;code&gt;--incremental&lt;/code&gt;, it will use that information to detect the least costly way to type-check and emit changes to your project.</source>
          <target state="translated">TypeScript 3.4 представляет новый флаг &lt;code&gt;--incremental&lt;/code&gt; , который сообщает TypeScript о необходимости сохранения информации о графе проекта из последней компиляции. В следующий раз, когда TypeScript будет вызван с параметром &lt;code&gt;--incremental&lt;/code&gt; , он будет использовать эту информацию для обнаружения наименее затратного способа проверки типов и внесения изменений в ваш проект.</target>
        </trans-unit>
        <trans-unit id="ac5af210d9695056d6101c62263f01f5967d4e08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt; using a new &lt;code&gt;readonly&lt;/code&gt; modifier for array types.</source>
          <target state="translated">TypeScript 3.4 представляет новый синтаксис для &lt;code&gt;ReadonlyArray&lt;/code&gt; с использованием нового модификатора &lt;code&gt;readonly&lt;/code&gt; для типов массивов.</target>
        </trans-unit>
        <trans-unit id="12a10c24cba59cb68af585f1698de8ae3445244e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces support for type-checking ECMAScript&amp;rsquo;s new &lt;code&gt;globalThis&lt;/code&gt; - a global variable that, well, refers to the global scope. Unlike the above solutions, &lt;code&gt;globalThis&lt;/code&gt; provides a standard way for accessing the global scope which can be used across different environments.</source>
          <target state="translated">TypeScript 3.4 представляет поддержку проверки типов в ECMAScript new &lt;code&gt;globalThis&lt;/code&gt; - глобальной переменной, которая, в общем, относится к глобальной области видимости. В отличие от вышеупомянутых решений, &lt;code&gt;globalThis&lt;/code&gt; предоставляет стандартный способ доступа к глобальной области видимости, который можно использовать в различных средах.</target>
        </trans-unit>
        <trans-unit id="f91b4dd92032cff1d431b2484ffb02c538b2840a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</source>
          <target state="translated">TypeScript 3.4 немного упрощает использование массивов типа &quot;только для чтения&quot;.</target>
        </trans-unit>
        <trans-unit id="9ab9e17f2ce04fc3d04ccc515b149cf9aa3aa203" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 produces the type</source>
          <target state="translated">TypeScript 3.4 производит тип</target>
        </trans-unit>
        <trans-unit id="10f518faa467d8e0e2925a31d9b4b672b9c2e19b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5</source>
          <target state="translated">TypeScript 3.5</target>
        </trans-unit>
        <trans-unit id="359b79f7544026e6404a7f5dc527aa3cfdbf0be7" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</source>
          <target state="translated">TypeScript 3.5 содержит некоторые оптимизации по сравнению с TypeScript 3.4 для более эффективной проверки типов.Эти улучшения значительно более заметны в сценариях редакторов,где проверка типов приводит к таким операциям,как списки завершения кода.</target>
        </trans-unit>
        <trans-unit id="a6938b07665eedd653729021d3cce39e74883c08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</source>
          <target state="translated">TypeScript 3.5 обобщает это поведение и для работы с функциями конструктора.</target>
        </trans-unit>
        <trans-unit id="a73d70bff8d5fc727c0bd14cb107e1c1b473750e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 improves on 3.4&amp;rsquo;s &lt;code&gt;--incremental&lt;/code&gt; build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript&amp;rsquo;s project references in &lt;code&gt;--build&lt;/code&gt; mode, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;we&amp;rsquo;ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4&lt;/a&gt;!</source>
          <target state="translated">TypeScript 3.5 улучшает режим &lt;code&gt;--incremental&lt;/code&gt; сборки 3.4 , сохраняя информацию о том, как было вычислено состояние мира - настройки компилятора, почему файлы были найдены, где были найдены файлы и т. Д. В сценариях, включающих сотни проектов, использующих TypeScript ссылки на &lt;code&gt;--build&lt;/code&gt; режиме --build , &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;мы обнаружили, что время восстановления может быть сокращено на 68% по сравнению с TypeScript 3.4&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="8870d39de72c9538f7b989e9c665dcecc3f792f4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</source>
          <target state="translated">В TypeScript 3.5 введено несколько оптимизаций,связанных с проверкой типов и инкрементальными сборками.</target>
        </trans-unit>
        <trans-unit id="a67354830dc88bba666b8a01f15200fc520abe67" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces the new &lt;code&gt;Omit&lt;/code&gt; helper type, which creates a new type with some properties dropped from the original.</source>
          <target state="translated">TypeScript 3.5 представляет новый вспомогательный тип &lt;code&gt;Omit&lt;/code&gt; , который создает новый тип с некоторыми свойствами, удаленными из оригинала.</target>
        </trans-unit>
        <trans-unit id="860169965c68715ea7e25ddf2b4ae280a663fdd6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6</source>
          <target state="translated">TypeScript 3.6</target>
        </trans-unit>
        <trans-unit id="43040204a5b205b20ce117e9abeba80afa37f954" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</source>
          <target state="translated">TypeScript 3.6 содержит лучшую поддержку символов Юникода в идентификаторах при эмиссии в ES2015 и более поздние цели.</target>
        </trans-unit>
        <trans-unit id="bd36d48e4d1462dffb6c3c392323087bb23fcc1d" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces a new &lt;code&gt;__spreadArrays&lt;/code&gt; helper to accurately model what happens in ECMAScript 2015 in older targets outside of &lt;code&gt;--downlevelIteration&lt;/code&gt;. &lt;code&gt;__spreadArrays&lt;/code&gt; is also available in &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6 представляет новый помощник &lt;code&gt;__spreadArrays&lt;/code&gt; для точного моделирования того, что происходит в ECMAScript 2015 в более старых целях за пределами &lt;code&gt;--downlevelIteration&lt;/code&gt; . &lt;code&gt;__spreadArrays&lt;/code&gt; также доступен в &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33cd49dc97acf9b88dbc38ffefb886129306a9c4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces some improvements for when &lt;code&gt;Promise&lt;/code&gt;s are mis-handled.</source>
          <target state="translated">TypeScript 3.6 содержит некоторые улучшения для &lt;code&gt;Promise&lt;/code&gt; неправильной обработки Promise .</target>
        </trans-unit>
        <trans-unit id="74c9e7c03722726e70a2ffe1f76f8a558869d112" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</source>
          <target state="translated">В TypeScript 3.6 введена более строгая проверка итераторов и функций генератора.В более ранних версиях пользователи генераторов не имели возможности отличить,было ли значение получено или возвращено из генератора.</target>
        </trans-unit>
        <trans-unit id="81aa3de148cf46d845b3cd5b3e434a89e256c4c6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;see more details in the original pull request here&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6 теперь немного умнее смотрит на ваш существующий импорт, прежде чем решать, как автоматически импортировать другие модули. Вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;увидеть более подробную информацию в исходном запросе на перенос здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="314b10ba05a1161535cb19963756c6c11ff953ee" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 supports transforming &lt;code&gt;import.meta&lt;/code&gt; to &lt;code&gt;context.meta&lt;/code&gt; when your &lt;code&gt;module&lt;/code&gt; target is set to &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.6 поддерживает преобразование &lt;code&gt;import.meta&lt;/code&gt; в &lt;code&gt;context.meta&lt;/code&gt; , когда ваш целевой &lt;code&gt;module&lt;/code&gt; установлен в &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f7ed4364cfc54d058bc3677d8dbecd5e3827aa5" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7</source>
          <target state="translated">TypeScript 3.7</target>
        </trans-unit>
        <trans-unit id="27083dbf128c773c5403938ac6b066e57d56ab6a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7 allows us to add &lt;code&gt;// @ts-nocheck&lt;/code&gt; comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of &lt;code&gt;checkJs&lt;/code&gt;, but we&amp;rsquo;ve expanded support to TypeScript files to make migrations easier for all users.</source>
          <target state="translated">TypeScript 3.7 позволяет нам добавлять комментарии &lt;code&gt;// @ts-nocheck&lt;/code&gt; в начало файлов TypeScript, чтобы отключить семантические проверки. Исторически этот комментарий соблюдался только в исходных файлах JavaScript при наличии &lt;code&gt;checkJs&lt;/code&gt; , но мы расширили поддержку файлов TypeScript, чтобы облегчить миграцию для всех пользователей.</target>
        </trans-unit>
        <trans-unit id="3948f56aa0a7c4b97a01b6021dd36790f3c27f3b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.8 shipped a new strategy for watching directories, which is crucial for efficiently picking up changes to &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e6c0e6d51157bb20e26a7e863eb63b56787312" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation</source>
          <target state="translated">Документация TypeScript</target>
        </trans-unit>
        <trans-unit id="5d719aff063d96145b68e6a617af89b4002a79f6" translate="yes" xml:space="preserve">
          <source>TypeScript Tooling in 5 minutes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403fb75c6290c33e1ee26eea036308b48aa46bfe" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</source>
          <target state="translated">Версия TypeScript: если вы установили с помощью npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9bf97b3981273152e80b422491273038dfba6f7" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</source>
          <target state="translated">Версия TypeScript: если вы установили с помощью npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92158f74ec4a49fce0c3bbd7e4df145bfac809dd" translate="yes" xml:space="preserve">
          <source>TypeScript additionally has a &lt;code&gt;readonly&lt;/code&gt; modifier for properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9786e84531c7e9e6709c98099bfd87c8dde49dc4" translate="yes" xml:space="preserve">
          <source>TypeScript adds a new triple-slash-reference directive (&lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt;), allowing a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">TypeScript добавляет новую директиву с тройной косой чертой ( &lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt; ), позволяющую файлу явно включать существующий встроенный файл &lt;em&gt;lib&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ab30849b28c84e739618b723a20cd7f3bd9f8230" translate="yes" xml:space="preserve">
          <source>TypeScript adds several predefined conditional types, you can find the full list and examples in &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933684eac8c53f3d3b595b291f7f85a2962ff42b" translate="yes" xml:space="preserve">
          <source>TypeScript also has boolean literal types. You might use these to constrain object values whose properties are interrelated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cb184abb97e12b74ad8254592410b6fab20413" translate="yes" xml:space="preserve">
          <source>TypeScript also has its own way to declare a member as being marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b23712d0cd1521663db4c571af695acc5fe01d" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types, which act the same as the string literals above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627afeb35305a2b7b628a49f47ad27ec0e7523cd" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types.</source>
          <target state="translated">TypeScript также имеет буквенно-цифровые типы.</target>
        </trans-unit>
        <trans-unit id="cd15608e954ae2e54d306fd4af46560be232f740" translate="yes" xml:space="preserve">
          <source>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript&amp;rsquo;s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d421259d60dd75e6cc38c009347d8fbd16eecddf" translate="yes" xml:space="preserve">
          <source>TypeScript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f845ee328e4da8982a9cb87a1d1fe60de76cba85" translate="yes" xml:space="preserve">
          <source>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned &lt;em&gt;off&lt;/em&gt; by default, and can be enabled using &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;.</source>
          <target state="translated">TypeScript может сообщать об ошибках в случае провала в операторе switch, где предложение case не пусто. По умолчанию эта проверка &lt;em&gt;отключена&lt;/em&gt; , и ее можно включить с помощью &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86267f4e18cd09316cea7bbab141853557982d64" translate="yes" xml:space="preserve">
          <source>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="051064120a5cd70ddad4ed87c1bc2af64d3d9e4b" translate="yes" xml:space="preserve">
          <source>TypeScript checks a program for errors before execution, and does so based on the &lt;em&gt;kinds of values&lt;/em&gt;, it&amp;rsquo;s a &lt;em&gt;static type checker&lt;/em&gt;. For example, the last example above has an error because of the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;obj&lt;/code&gt;. Here&amp;rsquo;s the error TypeScript found:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b9849713d9bf4417e9c5210a0c528aff29dc06" translate="yes" xml:space="preserve">
          <source>TypeScript code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3883e486fe04d1f7d13e0ad9f1b9eb0d552664b9" translate="yes" xml:space="preserve">
          <source>TypeScript comes with a &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that is the same as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; with all mutating methods removed, so you can make sure you don&amp;rsquo;t change your arrays after creation:</source>
          <target state="translated">TypeScript поставляется с &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; который совпадает с типом &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; со всеми удаленными методами изменения, поэтому вы можете быть уверены, что не измените свои массивы после создания:</target>
        </trans-unit>
        <trans-unit id="c46782ad571ccfa1375c328c08d6d8a52aae9f4e" translate="yes" xml:space="preserve">
          <source>TypeScript comes with certain checks to give you more safety and analysis of your program. Once you&amp;rsquo;ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.</source>
          <target state="translated">TypeScript поставляется с определенными проверками, которые повышают безопасность и анализ вашей программы. После того, как вы преобразовали свою кодовую базу в TypeScript, вы можете включить эти проверки для большей безопасности.</target>
        </trans-unit>
        <trans-unit id="ccbb64b768c9b80a0141d5b0cacdf027e032576b" translate="yes" xml:space="preserve">
          <source>TypeScript compiles this down to the following JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982bd44a5cc8b5512117571aef28b0ebcb320b22" translate="yes" xml:space="preserve">
          <source>TypeScript decorators are based on the &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7 decorator proposal&lt;/a&gt;.</source>
          <target state="translated">Декораторы TypeScript основаны на &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;предложении декоратора ES7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c49eb75318af39272125eec481e10dad28c42573" translate="yes" xml:space="preserve">
          <source>TypeScript determines if the call to &lt;code&gt;fn&lt;/code&gt; here is valid by seeing if the provided argument is a valid &lt;code&gt;Empty&lt;/code&gt;. It does so by examining the &lt;em&gt;structure&lt;/em&gt; of &lt;code&gt;{ k: 10 }&lt;/code&gt; and &lt;code&gt;class Empty { }&lt;/code&gt;. We can see that &lt;code&gt;{ k: 10 }&lt;/code&gt; has &lt;em&gt;all&lt;/em&gt; of the properties that &lt;code&gt;Empty&lt;/code&gt; does, because &lt;code&gt;Empty&lt;/code&gt; has no properties. Therefore, this is a valid call!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250cd79d3d3268a25a6551d40fbaae96eebab0e3" translate="yes" xml:space="preserve">
          <source>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;. Enter the new &lt;code&gt;object&lt;/code&gt; type.</source>
          <target state="translated">В TypeScript не было типа, который представлял бы непримитивный тип, то есть все, что не является &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Введите новый тип &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5ef0d0e7c127dd5aa5d2057bcc3b018aa657ae1" translate="yes" xml:space="preserve">
          <source>TypeScript does not have higher kinded types, so the following is not legal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecbedd4aac4c783dc5087f561c9c49681b205cd" translate="yes" xml:space="preserve">
          <source>TypeScript does not support resolving JSON files by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99706e78c25c70ab97b91669035d38e90b305ea6" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fada45685495c730f9a9cc2a93bbb49026908546" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we&amp;rsquo;re going to look at how you might start out. We assume you&amp;rsquo;ve read enough of the handbook to write new TypeScript code.</source>
          <target state="translated">TypeScript не существует в вакууме. Он был построен с учетом экосистемы JavaScript, и сегодня существует множество JavaScript. Преобразование кодовой базы JavaScript в TypeScript хотя и несколько утомительно, но обычно не вызывает затруднений. В этом уроке мы рассмотрим, с чего можно начать. Мы предполагаем, что вы прочитали достаточно руководства, чтобы написать новый код TypeScript.</target>
        </trans-unit>
        <trans-unit id="1c8cdf286fbbcc4e7b49af3039a27393efcafa25" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler and end up in &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">Файлы TypeScript начнутся в вашей папке &lt;code&gt;src&lt;/code&gt; , пройдут через компилятор TypeScript и окажутся в &lt;code&gt;dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59c18fee8487cdeda3b2f34b4ca8e8a543f5cab1" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler, then webpack, and end up in a &lt;code&gt;main.js&lt;/code&gt; file in &lt;code&gt;dist&lt;/code&gt;. Any components that we write will go in the &lt;code&gt;src/components&lt;/code&gt; folder.</source>
          <target state="translated">Файлы TypeScript начнутся в вашей папке &lt;code&gt;src&lt;/code&gt; , пройдут через компилятор TypeScript, затем через webpack и &lt;code&gt;main.js&lt;/code&gt; файлом main.js в &lt;code&gt;dist&lt;/code&gt; . Все компоненты, которые мы напишем, будут помещены в папку &lt;code&gt;src/components&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e928664e9ba3db7f949861f05d81f86d70adeb" translate="yes" xml:space="preserve">
          <source>TypeScript follows the case sensitivity rules of the file system it&amp;rsquo;s running on. This can be problematic if some developers are working in a case-sensitive file system and others aren&amp;rsquo;t. If a file attempts to import &lt;code&gt;fileManager.ts&lt;/code&gt; by specifying &lt;code&gt;./FileManager.ts&lt;/code&gt; the file will be found in a case-insensitive file system, but not on a case-sensitive file system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc050e207c38920097293143b10d59b473dbcff4" translate="yes" xml:space="preserve">
          <source>TypeScript for Functional Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc592d6d7ce7d2bc3c3f49068e5d4fff5338e8e" translate="yes" xml:space="preserve">
          <source>TypeScript for JS Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad7cb0c6b7a5eb829a0cd66ebdfe0d11d25b842" translate="yes" xml:space="preserve">
          <source>TypeScript for Java/C# Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d15563ab88aa0acbcf181a27f272f5268b418d" translate="yes" xml:space="preserve">
          <source>TypeScript for JavaScript Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf59fb1a4572acf6d6413101225073873cc311" translate="yes" xml:space="preserve">
          <source>TypeScript for New Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871854b83287d4786ba7236204173f606ee249bb" translate="yes" xml:space="preserve">
          <source>TypeScript for OOP Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6afc05f4efdee6736a14797a9429ba616e9f7d" translate="yes" xml:space="preserve">
          <source>TypeScript for the New Programmer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e275a1ab2aa2f59571ca8cefeaf8a68b8704838b" translate="yes" xml:space="preserve">
          <source>TypeScript has a way to describe objects which have unknown keys but known values on an object, via index signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a367ff679df04f05c3c34e6560229bdc2557a732" translate="yes" xml:space="preserve">
          <source>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with &lt;code&gt;Promise&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s.</source>
          <target state="translated">TypeScript всегда сравнивал параметры двумерным способом. Для этого есть ряд причин, но в целом это не было большой проблемой для наших пользователей, пока мы не увидели некоторые из побочных эффектов, которые она имела с &lt;code&gt;Promise&lt;/code&gt; s и &lt;code&gt;Observable&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="2cc6486a45098c6f81cc098930195dc52786060c" translate="yes" xml:space="preserve">
          <source>TypeScript has corresponding primitive types for the built-in types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994258a317498ea30e98974b2dd26c0832e6c8f6" translate="yes" xml:space="preserve">
          <source>TypeScript has some obvious places where it can infer types, like variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db02a42b5c74e823760580106f119d33d32acab0" translate="yes" xml:space="preserve">
          <source>TypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.</source>
          <target state="translated">TypeScript традиционно слишком строг в отношении того,как можно импортировать модули.Это было сделано для того,чтобы избежать опечаток и предотвратить неправильное использование модулей пользователями.</target>
        </trans-unit>
        <trans-unit id="6506fa415538aa5ce5fe042526c3ba02ac3c0356" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b5002b156ed20abcb2373b3f1a34e30ef133d5" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;. By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">TypeScript имеет два специальных типа, &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; , которые имеют значения null и undefined соответственно. Мы кратко упомянули об этом в &lt;a href=&quot;basic-types&quot;&gt;разделе &amp;laquo;Основные типы&amp;raquo;&lt;/a&gt; . По умолчанию средство проверки типов считает, что &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; присваиваются чему-либо. Фактически, &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; являются допустимыми значениями каждого типа. Это означает, что невозможно &lt;em&gt;предотвратить&lt;/em&gt; их присвоение какому-либо типу, даже если вы хотите предотвратить это. Изобретатель &lt;code&gt;null&lt;/code&gt; Тони Хоар назвал это своей &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;laquo;ошибкой на миллиард долларов&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75fc1f90351ac73e35a5f3f576d18314c46dc6c2" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, Null and Undefined, that have the values &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Previously it was not possible to explicitly name these types, but &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; may now be used as type names regardless of type checking mode.</source>
          <target state="translated">TypeScript имеет два специальных типа, Null и Undefined, которые имеют значения &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; соответственно. Раньше было невозможно явно назвать эти типы, но теперь &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; могут использоваться в качестве имен типов независимо от режима проверки типов.</target>
        </trans-unit>
        <trans-unit id="76257f3717800dcd967d87bc9d2ef1e67b788bfb" translate="yes" xml:space="preserve">
          <source>TypeScript ignores any unsupported JSDoc tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669ae0c383f0ebc9a1b71a33795f2fba316ff636" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes</source>
          <target state="translated">TypeScript за 5 минут</target>
        </trans-unit>
        <trans-unit id="452bd92ef7047873dae5fa9a26760186598678c6" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Building your first TypeScript file</source>
          <target state="translated">TypeScript через 5 минут:Создание вашего первого файла TypeScript</target>
        </trans-unit>
        <trans-unit id="cfe56778efe914c509395d743856f638e0b2dc80" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Classes</source>
          <target state="translated">TypeScript через 5 минут:Занятия</target>
        </trans-unit>
        <trans-unit id="66f6d1b030c2c31817cfd629aeaf4e9f8e001440" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Compiling your code</source>
          <target state="translated">TypeScript через 5 минут:Компиляция вашего кода</target>
        </trans-unit>
        <trans-unit id="64b3883005157157bc3e05fd1909ad05a7782093" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Installing TypeScript</source>
          <target state="translated">TypeScript через 5 минут:Установка TypeScript</target>
        </trans-unit>
        <trans-unit id="679437aa54596d7921f489403e44c2b30fef5aed" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Interfaces</source>
          <target state="translated">TypeScript через 5 минут:Интерфейсы</target>
        </trans-unit>
        <trans-unit id="520fec1d849d26fa3641ec76d5fda0df2e56b07e" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Running your TypeScript web app</source>
          <target state="translated">TypeScript через 5 минут:Запуск вашего веб-приложения TypeScript</target>
        </trans-unit>
        <trans-unit id="6a574132fb48839d07c1e73530345fd9189655e2" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Type annotations</source>
          <target state="translated">TypeScript через 5 минут:Введите аннотации</target>
        </trans-unit>
        <trans-unit id="49f01d7597e304266b95072fc59979cc8fe48d0a" translate="yes" xml:space="preserve">
          <source>TypeScript includes a default set of type definitions for built-in JS APIs (like &lt;code&gt;Math&lt;/code&gt;), as well as type definitions for things found in browser environments (like &lt;code&gt;document&lt;/code&gt;). TypeScript also includes APIs for newer JS features matching the &lt;code&gt;target&lt;/code&gt; you specify; for example the definition for &lt;code&gt;Map&lt;/code&gt; is available if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES6&lt;/code&gt; or newer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa27fdf7da61b594edc2419147ebeb6293bab089" translate="yes" xml:space="preserve">
          <source>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">TypeScript включает экспериментальную поддержку для создания определенных типов метаданных для объявлений с декораторами. Чтобы включить эту экспериментальную поддержку, вы должны установить &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; компилятора emitDecoratorMetadata либо в командной строке, либо в вашем &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65097970997af32f38424bf7e3969825b3d282b6" translate="yes" xml:space="preserve">
          <source>TypeScript injects a handful of helper functions such as &lt;code&gt;__extends&lt;/code&gt; for inheritance, &lt;code&gt;__assign&lt;/code&gt; for spread operator in object literals and JSX elements, and &lt;code&gt;__awaiter&lt;/code&gt; for async functions.</source>
          <target state="translated">TypeScript внедряет несколько вспомогательных функций, таких как &lt;code&gt;__extends&lt;/code&gt; для наследования, &lt;code&gt;__assign&lt;/code&gt; для оператора распространения в объектных литералах и элементах JSX и &lt;code&gt;__awaiter&lt;/code&gt; для асинхронных функций.</target>
        </trans-unit>
        <trans-unit id="1676238ce5402b50fb854510e52fc28497e635a6" translate="yes" xml:space="preserve">
          <source>TypeScript is a language that is a &lt;em&gt;superset&lt;/em&gt; of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a &lt;em&gt;syntax&lt;/em&gt; error because it&amp;rsquo;s missing a &lt;code&gt;)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a40df62f3fab8b8861efc1fdf68a3995194acce" translate="yes" xml:space="preserve">
          <source>TypeScript is a popular choice for programmers accustomed to other languages with static typing, such as C# and Java.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4865203c87f3f94d8f8566ed718390d0119234fb" translate="yes" xml:space="preserve">
          <source>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</source>
          <target state="translated">TypeScript-это система структурных типов.Когда мы сравниваем два разных типа,независимо от того,откуда они пришли,если типы всех членов совместимы,то мы говорим,что сами типы совместимы.</target>
        </trans-unit>
        <trans-unit id="03aae380405163f427174ac0826d59a0323fbdd4" translate="yes" xml:space="preserve">
          <source>TypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in &lt;em&gt;lib.dom.d.ts&lt;/em&gt;, one stands out among the rest: &lt;code&gt;HTMLElement&lt;/code&gt; . This type is the backbone for DOM manipulation with TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a4f8e7040f4dce8be2768117a4691b14f816d0" translate="yes" xml:space="preserve">
          <source>TypeScript is also a programming language that preserves the &lt;em&gt;runtime behavior&lt;/em&gt; of JavaScript. For example, dividing by zero in JavaScript produces &lt;code&gt;Infinity&lt;/code&gt; instead of throwing a runtime exception. As a principle, TypeScript &lt;strong&gt;never&lt;/strong&gt; changes the runtime behavior of JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5933fe400768d081ab73894e4f792a102e8c04" translate="yes" xml:space="preserve">
          <source>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won&amp;rsquo;t add one.</source>
          <target state="translated">TypeScript теперь достаточно умен, чтобы определять, используются ли в вашем файле точки с запятой при применении такого рода изменений. Если в вашем файле обычно отсутствуют точки с запятой, TypeScript не добавит их.</target>
        </trans-unit>
        <trans-unit id="f8e7896660208a1071901f88668396a6aa40f6ae" translate="yes" xml:space="preserve">
          <source>TypeScript is smart enough to infer types in other contexts as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5a722ba8718780ca30a3749f2e85938a171a6e" translate="yes" xml:space="preserve">
          <source>TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b561cb58276a15cfc408ce85335f9d608e3f0d7" translate="yes" xml:space="preserve">
          <source>TypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; or &lt;code&gt;// @ts-expect-error&lt;/code&gt; on the preceding line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0716da88bf8553ba341ae10829c8d80565f07b2" translate="yes" xml:space="preserve">
          <source>TypeScript might compile this down to something like the the following JavaScript:</source>
          <target state="translated">TypeScript может скомпилировать это до чего-то вроде следующего JavaScript:</target>
        </trans-unit>
        <trans-unit id="32fed70cd34feef29d0649f498d61da78cbda0ab" translate="yes" xml:space="preserve">
          <source>TypeScript now only strictly enforces the visibility of types in modules if the &lt;code&gt;--declaration&lt;/code&gt; flag is provided. This is very useful for Angular scenarios, for example:</source>
          <target state="translated">TypeScript теперь строго обеспечивает видимость типов в модулях, только если &lt;code&gt;--declaration&lt;/code&gt; флаг --declaration . Это очень полезно для сценариев Angular, например:</target>
        </trans-unit>
        <trans-unit id="bf627cab04633b795ac087dea296a4bdb609bc4d" translate="yes" xml:space="preserve">
          <source>TypeScript now supports &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;Function components&lt;/a&gt;. These are lightweight components that easily compose other components:</source>
          <target state="translated">TypeScript теперь поддерживает &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;функциональные компоненты&lt;/a&gt; . Это легкие компоненты, которые легко составляют другие компоненты:</target>
        </trans-unit>
        <trans-unit id="52d1c2115b1983ad21a42bf4d3fb47956062ab0c" translate="yes" xml:space="preserve">
          <source>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</source>
          <target state="translated">TypeScript теперь поддерживает строки шаблонов ES6.Это простой способ встраивания произвольных выражений в строки:</target>
        </trans-unit>
        <trans-unit id="dca2d3b95767ef524c8d3421355c36053ab3819a" translate="yes" xml:space="preserve">
          <source>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the &lt;code&gt;async&lt;/code&gt; keyword; &lt;code&gt;await&lt;/code&gt; suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the &lt;code&gt;Promise&lt;/code&gt; returned.</source>
          <target state="translated">TypeScript теперь поддерживает асинхронные функции для движков, которые имеют встроенную поддержку генераторов ES6, например, Node v4 и выше. Асинхронные функции начинаются с ключевого слова &lt;code&gt;async&lt;/code&gt; ; &lt;code&gt;await&lt;/code&gt; приостанавливает выполнение до тех пор, пока не будет выполнено обещание возврата асинхронной функции, и разворачивает значение из возвращенного &lt;code&gt;Promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7958ec88d9f0faef067488c643d885da64e7bf" translate="yes" xml:space="preserve">
          <source>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you&amp;rsquo;ll get stricter checks when relating two generic signatures, and may catch some bugs.</source>
          <target state="translated">TypeScript теперь пытается унифицировать параметры типа при сравнении двух типов с одной подписью. В результате вы получите более строгие проверки при связывании двух общих подписей и можете обнаружить некоторые ошибки.</target>
        </trans-unit>
        <trans-unit id="a1e4e94f6714f3b9449e43db5907067b8f68b98e" translate="yes" xml:space="preserve">
          <source>TypeScript provides a number of mechanisms to work with types in a set-theoretic way, and you&amp;rsquo;ll find them more intuitive if you think of types as sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62273ee78dee44c5da22f4945f26ce4659fc27f" translate="yes" xml:space="preserve">
          <source>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</source>
          <target state="translated">TypeScript предоставляет несколько утилит для облегчения общего преобразования типов.Эти утилиты доступны по всему миру.</target>
        </trans-unit>
        <trans-unit id="4ef0844b7f909249d5a9f9e273a4f9a6ba63eb30" translate="yes" xml:space="preserve">
          <source>TypeScript replicates the node resolution for modules in a &lt;code&gt;package.json&lt;/code&gt;, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional &lt;code&gt;&quot;types&quot;&lt;/code&gt; field, then the &lt;code&gt;&quot;main&quot;&lt;/code&gt; field, and finally will try &lt;code&gt;index.d.ts&lt;/code&gt; in the root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988860fc02a853b3a27d2af5425c58bd62c2eceb" translate="yes" xml:space="preserve">
          <source>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, &lt;em&gt;and extraneous arguments are allowed&lt;/em&gt;. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</source>
          <target state="translated">TypeScript разрешает совместимость подписи, проверяя, может ли какая-либо подпись цели быть вызвана с аргументами источника, &lt;em&gt;и разрешены ли посторонние аргументы&lt;/em&gt; . Этот код, например, выявляет ошибку только в том случае, если подпись правильно написана с использованием дополнительных параметров:</target>
        </trans-unit>
        <trans-unit id="8a0c2fdfc90997d639e7e23066198c7742ba74d7" translate="yes" xml:space="preserve">
          <source>TypeScript ships with three JSX modes: &lt;code&gt;preserve&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt;, and &lt;code&gt;react-native&lt;/code&gt;. These modes only affect the emit stage - type checking is unaffected. The &lt;code&gt;preserve&lt;/code&gt; mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;). Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension. The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension. The &lt;code&gt;react-native&lt;/code&gt; mode is the equivalent of &lt;code&gt;preserve&lt;/code&gt; in that it keeps all JSX, but the output will instead have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">TypeScript поставляется с тремя режимами JSX: &lt;code&gt;preserve&lt;/code&gt; , &lt;code&gt;react&lt;/code&gt; и &lt;code&gt;react-native&lt;/code&gt; . Эти режимы влияют только на этап испускания - проверка типов не затрагивается. Режим &lt;code&gt;preserve&lt;/code&gt; сохранит JSX как часть вывода для дальнейшего использования на другом этапе преобразования (например, &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ). Кроме того, файл будет иметь расширение &lt;code&gt;.jsx&lt;/code&gt; . В режиме &lt;code&gt;react&lt;/code&gt; будет &lt;code&gt;React.createElement&lt;/code&gt; , не нужно выполнять преобразование JSX перед использованием, а выходные данные будут иметь расширение файла &lt;code&gt;.js&lt;/code&gt; . &lt;code&gt;react-native&lt;/code&gt; режим является эквивалентом &lt;code&gt;preserve&lt;/code&gt; в том, что он сохраняет весь JSX, но вместо этого вывод будет иметь расширение файла &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2cd47e8e27537ecdbea6c76c0813851141bdf88" translate="yes" xml:space="preserve">
          <source>TypeScript ships with two JSX modes: &lt;code&gt;preserve&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt;.</source>
          <target state="translated">TypeScript поставляется с двумя режимами JSX: &lt;code&gt;preserve&lt;/code&gt; и &lt;code&gt;react&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00a935a3f7579d721385691d1b84e679d883dff3" translate="yes" xml:space="preserve">
          <source>TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript&amp;rsquo;s features, and an additional layer on top of these: TypeScript&amp;rsquo;s type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bbddad2b4d434df60aaa882de571170d946407" translate="yes" xml:space="preserve">
          <source>TypeScript strives to only include features which are confirmed to be added into the JavaScript language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e350ae43b9a5687315f9cb51fc6866456b882a7f" translate="yes" xml:space="preserve">
          <source>TypeScript supports a wide spectrum of JavaScript patterns and defaults to allowing for quite a lot of flexibility in accommodating these styles. Often the safety and potential scalability of a codebase can be at odds with some of these techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68cb065a26c6d898de1ad77c499a5380c7336c0" translate="yes" xml:space="preserve">
          <source>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</source>
          <target state="translated">TypeScript поддерживает геттеры/сеттеры как способ перехвата доступа к члену объекта.Это дает возможность более тонкого контроля над тем,как доступ к члену объекта осуществляется на каждом объекте.</target>
        </trans-unit>
        <trans-unit id="b66debd096de5790d32615c82aeae20dd89c1b00" translate="yes" xml:space="preserve">
          <source>TypeScript treats a namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt;.Things are simple here, but they don&amp;rsquo;t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (&lt;code&gt;foo&lt;/code&gt; in the example above) is not callable, though allowed by TypeScript</source>
          <target state="translated">TypeScript рассматривает импорт пространства имен (т.е. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ) для модуля CommonJS / AMD / UMD как эквивалент &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt; Здесь все просто, но они не работают, если основной импортируемый объект является примитивом, классом или функцией. Спецификация ECMAScript предусматривает, что запись пространства имен является простым объектом и что импорт пространства имен ( &lt;code&gt;foo&lt;/code&gt; в приведенном выше примере) не вызывается, хотя разрешен TypeScript.</target>
        </trans-unit>
        <trans-unit id="190d779979c1c225024b4faf8c71539ad6be2768" translate="yes" xml:space="preserve">
          <source>TypeScript used the &lt;code&gt;module&lt;/code&gt; keyword to define both &amp;ldquo;internal modules&amp;rdquo; and &amp;ldquo;external modules&amp;rdquo;; this has been a bit of confusion for developers new to TypeScript. &amp;ldquo;Internal modules&amp;rdquo; are closer to what most people would call a namespace; likewise, &amp;ldquo;external modules&amp;rdquo; in JS speak really just are modules now.</source>
          <target state="translated">TypeScript использовал ключевое слово &lt;code&gt;module&lt;/code&gt; для определения как &amp;laquo;внутренних модулей&amp;raquo;, так и &amp;laquo;внешних модулей&amp;raquo;; это немного смутило разработчиков, плохо знакомых с TypeScript. &amp;laquo;Внутренние модули&amp;raquo; ближе к тому, что большинство людей назвали бы пространством имен; аналогично, &amp;laquo;внешние модули&amp;raquo; в JS теперь действительно просто модули.</target>
        </trans-unit>
        <trans-unit id="1b58b6b726ed6ef37d5ab19f3e08450acedef197" translate="yes" xml:space="preserve">
          <source>TypeScript uses a file called &lt;code&gt;tsconfig.json&lt;/code&gt; for managing your project&amp;rsquo;s options, such as which files you want to include, and what sorts of checking you want to perform. Let&amp;rsquo;s create a bare-bones one for our project:</source>
          <target state="translated">TypeScript использует файл &lt;code&gt;tsconfig.json&lt;/code&gt; для управления параметрами вашего проекта, например, какие файлы вы хотите включить и какие проверки вы хотите выполнить. Давайте создадим скелет для нашего проекта:</target>
        </trans-unit>
        <trans-unit id="f56d1e973d936e7e25808ece950aef4bac63d378" translate="yes" xml:space="preserve">
          <source>TypeScript uses the &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target state="translated">TypeScript использует то &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;же соглашение, что и React,&lt;/a&gt; для их различения. Внутренний элемент всегда начинается со строчной буквы, а элемент на основе значений всегда начинается с прописной буквы.</target>
        </trans-unit>
        <trans-unit id="8aa9f62e356ae2ae9934ec0c3a8f5ba6030c73a9" translate="yes" xml:space="preserve">
          <source>TypeScript uses the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fed99366cf22869561ff0cde11374db19d9f07b" translate="yes" xml:space="preserve">
          <source>TypeScript uses the type &lt;code&gt;any&lt;/code&gt; whenever it can&amp;rsquo;t tell what the type of an expression should be. Compared to &lt;code&gt;Dynamic&lt;/code&gt;, calling &lt;code&gt;any&lt;/code&gt; a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an &lt;code&gt;any[]&lt;/code&gt; without marking the value in any way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94cd2357ef6caf93ae4025491d6f6435c0dfc38" translate="yes" xml:space="preserve">
          <source>TypeScript will also now compute enum values when possible:</source>
          <target state="translated">TypeScript теперь также будет вычислять значения перечислений,когда это возможно:</target>
        </trans-unit>
        <trans-unit id="363493eaf871474aebe9c026f44b9b57be878dd1" translate="yes" xml:space="preserve">
          <source>TypeScript will also warn about unreachable code and labels, which you can disable with &lt;code&gt;allowUnreachableCode&lt;/code&gt; and &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectively.</source>
          <target state="translated">TypeScript также предупредит о недостижимом коде и метках, которые вы можете отключить с помощью &lt;code&gt;allowUnreachableCode&lt;/code&gt; и &lt;code&gt;allowUnusedLabels&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="e8a61643ec3271fd661861cae15f39927b074e83" translate="yes" xml:space="preserve">
          <source>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt;) over Node&amp;rsquo;s resolution logic. TypeScript will also use a field in &lt;code&gt;package.json&lt;/code&gt; named &lt;code&gt;&quot;types&quot;&lt;/code&gt; to mirror the purpose of &lt;code&gt;&quot;main&quot;&lt;/code&gt; - the compiler will use it to find the &amp;ldquo;main&amp;rdquo; definition file to consult.</source>
          <target state="translated">TypeScript будет имитировать стратегию разрешения времени выполнения Node.js, чтобы найти файлы определений для модулей во время компиляции. Для этого TypeScript накладывает расширения исходного файла TypeScript ( &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; и &lt;code&gt;.d.ts&lt;/code&gt; ) поверх логики разрешения Node. TypeScript также будет использовать поле в &lt;code&gt;package.json&lt;/code&gt; с именем &lt;code&gt;&quot;types&quot;&lt;/code&gt; чтобы отразить цель &lt;code&gt;&quot;main&quot;&lt;/code&gt; - компилятор будет использовать его для поиска &amp;laquo;основного&amp;raquo; файла определения для просмотра.</target>
        </trans-unit>
        <trans-unit id="d20fd8b3bcedf7d11d40c55cf087585df77e7708" translate="yes" xml:space="preserve">
          <source>TypeScript will say that you can&amp;rsquo;t assign to &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;volume&lt;/code&gt; because it first figured out the type of &lt;code&gt;options&lt;/code&gt; as &lt;code&gt;{}&lt;/code&gt; which doesn&amp;rsquo;t have any properties. If you instead moved the declarations into the object literal themselves, you&amp;rsquo;d get no errors:</source>
          <target state="translated">TypeScript скажет, что вы не можете назначить &lt;code&gt;color&lt;/code&gt; и &lt;code&gt;volume&lt;/code&gt; потому что он сначала определил тип &lt;code&gt;options&lt;/code&gt; как &lt;code&gt;{}&lt;/code&gt; , который не имеет никаких свойств. Если вместо этого вы переместите объявления в литерал объекта, вы не получите ошибок:</target>
        </trans-unit>
        <trans-unit id="b835b008208b64fdab50a54358ce702512ec0e47" translate="yes" xml:space="preserve">
          <source>TypeScript will unify type parameters when comparing two generic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0ca513c7dc163be9ae8d550d8e42ef8b211838" translate="yes" xml:space="preserve">
          <source>TypeScript will usually add a compiler flag for the latter set of errors, and by default these are not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bf0c53ba4aa0ec1095c2375e35e8a2ae0dd7f7" translate="yes" xml:space="preserve">
          <source>TypeScript with &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e22e69ba01fd253f8ca30b84167b834c8db6f0" translate="yes" xml:space="preserve">
          <source>TypeScript with JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd367b77df54efafc687e3d2bce712bf9f604879" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--pretty&lt;/code&gt; flag can make error messages easier to read and manage. &lt;code&gt;--pretty&lt;/code&gt; now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</source>
          <target state="translated">Флаг TypeScript &lt;code&gt;--pretty&lt;/code&gt; может упростить чтение сообщений об ошибках и управление ими. &lt;code&gt;--pretty&lt;/code&gt; теперь использует цвета для имен файлов, диагностических кодов и номеров строк. Имена и позиции файлов теперь также отформатированы, чтобы обеспечить навигацию в общих терминалах (например, терминале Visual Studio Code).</target>
        </trans-unit>
        <trans-unit id="82367d5505123220713eb9aa76910332cb1314fc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; mode now clears the screen after a re-compilation is requested.</source>
          <target state="translated">Режим TypeScript &lt;code&gt;--watch&lt;/code&gt; теперь очищает экран после запроса повторной компиляции.</target>
        </trans-unit>
        <trans-unit id="e240610ed534bc76d20bc7bebb7e8fd4ee492fe3" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript&amp;rsquo;s automatic semicolon insertion (ASI) rules. The setting is available now in &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</source>
          <target state="translated">Встроенное средство форматирования TypeScript теперь поддерживает вставку и удаление точки с запятой в тех местах, где конечная точка с запятой является необязательной из-за правил JavaScript для автоматической вставки точки с запятой (ASI). Этот параметр теперь доступен в &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt; и будет доступен в Visual Studio 16.4 Preview 2 в меню &quot;Инструменты&quot;.</target>
        </trans-unit>
        <trans-unit id="08c6179dcf1375ce19533b773a6b25765f412389" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn&amp;rsquo;t been built (or whose output was out of date) meant that the editing experience wouldn&amp;rsquo;t work well.</source>
          <target state="translated">Ссылки на проекты TypeScript предоставляют нам простой способ разбить кодовую базу, чтобы ускорить компиляцию. К сожалению, редактирование проекта, зависимости которого не были построены (или выходные данные устарели), означало, что редактирование не будет работать должным образом.</target>
        </trans-unit>
        <trans-unit id="8e33dd464f3004daae495bfbf61b1d8f4515a8bc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it&amp;rsquo;s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</source>
          <target state="translated">Система структурных типов TypeScript была разработана на основе того, как обычно пишется код JavaScript. Поскольку в JavaScript широко используются анонимные объекты, такие как функциональные выражения и объектные литералы, гораздо естественнее представлять виды отношений, обнаруженные в библиотеках JavaScript, с помощью системы структурных типов вместо номинальной.</target>
        </trans-unit>
        <trans-unit id="bb4cd132d17765763f4ec7ad513fe8c0ba6e5307" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system allows certain operations that can&amp;rsquo;t be known at compile-time to be safe. When a type system has this property, it is said to not be &amp;ldquo;sound&amp;rdquo;. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we&amp;rsquo;ll explain where these happen and the motivating scenarios behind them.</source>
          <target state="translated">Система типов TypeScript позволяет выполнять определенные операции, о которых невозможно узнать во время компиляции. Когда система типов имеет это свойство, она считается &amp;laquo;ненадежной&amp;raquo;. Места, в которых TypeScript допускает ненадлежащее поведение, были тщательно рассмотрены, и в этом документе мы объясним, где это происходит, и мотивирующие сценарии, стоящие за ними.</target>
        </trans-unit>
        <trans-unit id="bc25ef434b456b8e9b3f38204ffc2330bc4fb76d" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is &lt;em&gt;structural&lt;/em&gt;, not nominal: We can use &lt;code&gt;obj&lt;/code&gt; as a &lt;code&gt;Pointlike&lt;/code&gt; because it has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties that are both numbers. The relationships between types are determined by the properties they contain, not whether they were declared with some particular relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699fd96b329576b8e4f3bea33063886228ddc2e0" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system is also &lt;em&gt;not reified&lt;/em&gt;: There&amp;rsquo;s nothing at runtime that will tell us that &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;Pointlike&lt;/code&gt;. In fact, the &lt;code&gt;Pointlike&lt;/code&gt; type is not present &lt;em&gt;in any form&lt;/em&gt; at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd0cf7a946fdeea7bb4261a202a46f6a006f525" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program. While TypeScript provides many familiar features for these developers, it&amp;rsquo;s worth stepping back to see how JavaScript (and therefore TypeScript) differ from traditional OOP languages. Understanding these differences will help you write better JavaScript code, and avoid common pitfalls that programmers who go straight from C#/Java to TypeScript may fall in to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2727a72bb787115b0b255c31ef21d7adbe04c368" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s understanding of a &lt;em&gt;type&lt;/em&gt; is actually quite different from C# or Java&amp;rsquo;s. Let&amp;rsquo;s explore some differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349e8ba90638f01a95ebe613d90e5ffbcee9736b" translate="yes" xml:space="preserve">
          <source>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &lt;code&gt;[]&lt;/code&gt; to denote an array of that element type:</source>
          <target state="translated">TypeScript, как и JavaScript, позволяет работать с массивами значений. Типы массивов можно записать одним из двух способов. В первом вы используете тип элементов, за которым следует &lt;code&gt;[]&lt;/code&gt; , чтобы обозначить массив этого типа элемента:</target>
        </trans-unit>
        <trans-unit id="4ad04619aba3f2f4ed81caa26fedf4a7d7810729" translate="yes" xml:space="preserve">
          <source>TypeScript-Preview</source>
          <target state="translated">TypeScript-Preview</target>
        </trans-unit>
        <trans-unit id="0fbb22e14b529ffecc219e421d78a3fd5f50af73" translate="yes" xml:space="preserve">
          <source>TypeScript: A Static Type Checker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d9bbe35312804100303ce4556c7c954c09e309" translate="yes" xml:space="preserve">
          <source>TypeScriptAdditionalFlags</source>
          <target state="translated">TypeScriptAdditionalFlags</target>
        </trans-unit>
        <trans-unit id="7b5fe2a5e0980eb4438ba0537940cad4dba1cbf4" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowSyntheticDefaultImports</source>
          <target state="translated">TypeScriptAllowSyntheticDefaultImports</target>
        </trans-unit>
        <trans-unit id="a94bfbe88239bd8121e18f907e172dde0a5dee8d" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnreachableCode</source>
          <target state="translated">TypeScriptAllowUnreachableCode</target>
        </trans-unit>
        <trans-unit id="a57b98365d2468c29049e5c8c8ee824604a3fdb7" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnusedLabels</source>
          <target state="translated">TypeScriptAllowUnusedLabels</target>
        </trans-unit>
        <trans-unit id="52c7a27301fde259e8f6bb99fc56cb8133f9b303" translate="yes" xml:space="preserve">
          <source>TypeScriptAlwaysStrict</source>
          <target state="translated">TypeScriptAlwaysStrict</target>
        </trans-unit>
        <trans-unit id="2ed81307b38a7333d37096546abf4a0b57b93c74" translate="yes" xml:space="preserve">
          <source>TypeScriptBaseUrl</source>
          <target state="translated">TypeScriptBaseUrl</target>
        </trans-unit>
        <trans-unit id="77f797b2abb4954f5643abb4b5b80d59868c9236" translate="yes" xml:space="preserve">
          <source>TypeScriptCharset</source>
          <target state="translated">TypeScriptCharset</target>
        </trans-unit>
        <trans-unit id="107cd94d243e6194c069f50feafef3b1230a7556" translate="yes" xml:space="preserve">
          <source>TypeScriptCompileBlocked</source>
          <target state="translated">TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="7acf8c8a12467f8aca42a0fb5a3ef1f764482e71" translate="yes" xml:space="preserve">
          <source>TypeScriptDeclarationDir</source>
          <target state="translated">TypeScriptDeclarationDir</target>
        </trans-unit>
        <trans-unit id="4a2236f58ea00d2b0bb17b6cea7aca0c8a68c053" translate="yes" xml:space="preserve">
          <source>TypeScriptESModuleInterop</source>
          <target state="translated">TypeScriptESModuleInterop</target>
        </trans-unit>
        <trans-unit id="55c811b895566e510d35f99a3a36ec8a3177f330" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitBOM</source>
          <target state="translated">TypeScriptEmitBOM</target>
        </trans-unit>
        <trans-unit id="b2959142651db2ba36f7a76acb1a7cd0464dd2f0" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDeclarationOnly</source>
          <target state="translated">TypeScriptEmitDeclarationOnly</target>
        </trans-unit>
        <trans-unit id="17656226f24afbbb0494dc47d1fdf5cb6aec6e7e" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDecoratorMetadata</source>
          <target state="translated">TypeScriptEmitDecoratorMetadata</target>
        </trans-unit>
        <trans-unit id="454a8f8d5acc53cc5c5237683c54fb6329217df3" translate="yes" xml:space="preserve">
          <source>TypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a24003307b278d63a345cf4646070ee3538d81" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalAsyncFunctions</source>
          <target state="translated">TypeScriptExperimentalAsyncFunctions</target>
        </trans-unit>
        <trans-unit id="f178eb0d68749f84390526fcfcf73643580199b8" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalDecorators</source>
          <target state="translated">TypeScriptExperimentalDecorators</target>
        </trans-unit>
        <trans-unit id="227102f3c5d5c0c4fe35d5a94e14769df56ea3ea" translate="yes" xml:space="preserve">
          <source>TypeScriptForceConsistentCasingInFileNames</source>
          <target state="translated">TypeScriptForceConsistentCasingInFileNames</target>
        </trans-unit>
        <trans-unit id="e8221bda0f5ae2cb80b553adafbf9c7d7eb1ff79" translate="yes" xml:space="preserve">
          <source>TypeScriptGeneratesDeclarations</source>
          <target state="translated">TypeScriptGeneratesDeclarations</target>
        </trans-unit>
        <trans-unit id="12faa091e4a57a36c933420258af4a9f60dccc85" translate="yes" xml:space="preserve">
          <source>TypeScriptImportHelpers</source>
          <target state="translated">TypeScriptImportHelpers</target>
        </trans-unit>
        <trans-unit id="ee1203ba67f873be0ddd284d0922dc4eaed56181" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSourceMap</source>
          <target state="translated">TypeScriptInlineSourceMap</target>
        </trans-unit>
        <trans-unit id="388355e20cca01322235dfa01c312ca0d6781b5a" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSources</source>
          <target state="translated">TypeScriptInlineSources</target>
        </trans-unit>
        <trans-unit id="d77acf48160dec4408ea9726aa2e65d9aca96302" translate="yes" xml:space="preserve">
          <source>TypeScriptIsolatedModules</source>
          <target state="translated">TypeScriptIsolatedModules</target>
        </trans-unit>
        <trans-unit id="956314972e52b72d9e36530ee0a4e72a92acae0b" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXEmit</source>
          <target state="translated">TypeScriptJSXEmit</target>
        </trans-unit>
        <trans-unit id="a67c071d130c25aefdb45b19dfa130ff6bb485ad" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFactory</source>
          <target state="translated">TypeScriptJSXFactory</target>
        </trans-unit>
        <trans-unit id="37a4427a09452551dd538cba6e5a87a9c65983c9" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFragmentFactory</source>
          <target state="translated">TypeScriptJSXFragmentFactory</target>
        </trans-unit>
        <trans-unit id="4552cc5179a4f2f2d43bbca69cfe48ae1d8a59ca" translate="yes" xml:space="preserve">
          <source>TypeScriptLib</source>
          <target state="translated">TypeScriptLib</target>
        </trans-unit>
        <trans-unit id="0572909efb507dda301b9d8012fab7e5de772948" translate="yes" xml:space="preserve">
          <source>TypeScriptMapRoot</source>
          <target state="translated">TypeScriptMapRoot</target>
        </trans-unit>
        <trans-unit id="dc7b169788198faee3555056c08f9f57327e0a3f" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleKind</source>
          <target state="translated">TypeScriptModuleKind</target>
        </trans-unit>
        <trans-unit id="421c0ae622f44c1602b14f2b708d2cca0d2934ce" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleResolution</source>
          <target state="translated">TypeScriptModuleResolution</target>
        </trans-unit>
        <trans-unit id="35fa542971e052e37cc4839000b5258adf72a14c" translate="yes" xml:space="preserve">
          <source>TypeScriptNewLine</source>
          <target state="translated">TypeScriptNewLine</target>
        </trans-unit>
        <trans-unit id="fc2a8ef1565c45f435f3d5ef342d1c6dae60cbb5" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitHelpers</source>
          <target state="translated">TypeScriptNoEmitHelpers</target>
        </trans-unit>
        <trans-unit id="e36e19ff5e1f6a8202b09c668028ec57276c68b9" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitOnError</source>
          <target state="translated">TypeScriptNoEmitOnError</target>
        </trans-unit>
        <trans-unit id="5b756225451ecee18834373559b43fedcb96fba8" translate="yes" xml:space="preserve">
          <source>TypeScriptNoFallthroughCasesInSwitch</source>
          <target state="translated">TypeScriptNoFallthroughCasesInSwitch</target>
        </trans-unit>
        <trans-unit id="d92e432f5565e45efa98aec9e0c61f938d26c756" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitAny</source>
          <target state="translated">TypeScriptNoImplicitAny</target>
        </trans-unit>
        <trans-unit id="1c9c8201c130add485ca511eb79ea6e375bc4375" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitReturns</source>
          <target state="translated">TypeScriptNoImplicitReturns</target>
        </trans-unit>
        <trans-unit id="3f55bf3dfa28bf03f3b28f94aa19817851b78cae" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitThis</source>
          <target state="translated">TypeScriptNoImplicitThis</target>
        </trans-unit>
        <trans-unit id="6f256f510247fb48347ab1a84a79bfdc18f35187" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitUseStrict</source>
          <target state="translated">TypeScriptNoImplicitUseStrict</target>
        </trans-unit>
        <trans-unit id="8bd63af2b503b90aadf320b0938c7cc2e9e1080f" translate="yes" xml:space="preserve">
          <source>TypeScriptNoLib</source>
          <target state="translated">TypeScriptNoLib</target>
        </trans-unit>
        <trans-unit id="aba68b0d2bfe600c1b7505f9cf090259fafedf3a" translate="yes" xml:space="preserve">
          <source>TypeScriptNoResolve</source>
          <target state="translated">TypeScriptNoResolve</target>
        </trans-unit>
        <trans-unit id="362c0511319630974131db1f54ca0f8546597ce7" translate="yes" xml:space="preserve">
          <source>TypeScriptNoStrictGenericChecks</source>
          <target state="translated">TypeScriptNoStrictGenericChecks</target>
        </trans-unit>
        <trans-unit id="dfa69886ed42a2dc63f9a0eab77d8450ce96b009" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedLocals</source>
          <target state="translated">TypeScriptNoUnusedLocals</target>
        </trans-unit>
        <trans-unit id="cefd9f6aa4a0ee3b0be73fb43be3ecc77bfe22df" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedParameters</source>
          <target state="translated">TypeScriptNoUnusedParameters</target>
        </trans-unit>
        <trans-unit id="6565a78c53fe02fdb81995bb6c6ec68f1f0ea3bd" translate="yes" xml:space="preserve">
          <source>TypeScriptOutDir</source>
          <target state="translated">TypeScriptOutDir</target>
        </trans-unit>
        <trans-unit id="b14c0569c9dd07bb52cefa5e53a9ee362f59b00f" translate="yes" xml:space="preserve">
          <source>TypeScriptOutFile</source>
          <target state="translated">TypeScriptOutFile</target>
        </trans-unit>
        <trans-unit id="644b7783acc77f0caa187daf9c367ba62b739548" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveConstEnums</source>
          <target state="translated">TypeScriptPreserveConstEnums</target>
        </trans-unit>
        <trans-unit id="44c9e768eb6070e00bdba352e27ce7e68b24160f" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveSymlinks</source>
          <target state="translated">TypeScriptPreserveSymlinks</target>
        </trans-unit>
        <trans-unit id="4130284b0addaca5f98609c12c577055315ad705" translate="yes" xml:space="preserve">
          <source>TypeScriptReactNamespace</source>
          <target state="translated">TypeScriptReactNamespace</target>
        </trans-unit>
        <trans-unit id="373f7134beec8752f28917f8c2d07c6972a8eda7" translate="yes" xml:space="preserve">
          <source>TypeScriptRemoveComments</source>
          <target state="translated">TypeScriptRemoveComments</target>
        </trans-unit>
        <trans-unit id="72de35523759783c4427070755e0bb5453621f68" translate="yes" xml:space="preserve">
          <source>TypeScriptRootDir</source>
          <target state="translated">TypeScriptRootDir</target>
        </trans-unit>
        <trans-unit id="6aa743721c9942df651b926d8a6b9d1d8b06dee1" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipDefaultLibCheck</source>
          <target state="translated">TypeScriptSkipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="8bfb0bbce64d6d061521026129b6afc021fdb739" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipLibCheck</source>
          <target state="translated">TypeScriptSkipLibCheck</target>
        </trans-unit>
        <trans-unit id="11cea9751a4427f602e3999e641567437522451c" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceMap</source>
          <target state="translated">TypeScriptSourceMap</target>
        </trans-unit>
        <trans-unit id="981b0099a78995ed3e09e63f3468ae20d833111d" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceRoot</source>
          <target state="translated">TypeScriptSourceRoot</target>
        </trans-unit>
        <trans-unit id="144320f2ae79b3129b36ee19ddeac0b49fefd1cb" translate="yes" xml:space="preserve">
          <source>TypeScriptStrict</source>
          <target state="translated">TypeScriptStrict</target>
        </trans-unit>
        <trans-unit id="dd87b21546d155f9fa69bfbdc72090ba951be0b1" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictFunctionTypes</source>
          <target state="translated">TypeScriptStrictFunctionTypes</target>
        </trans-unit>
        <trans-unit id="a6d54bf19b0c132487ec76f847985482640ea044" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictNullChecks</source>
          <target state="translated">TypeScriptStrictNullChecks</target>
        </trans-unit>
        <trans-unit id="102ce2e8221cdb409f6a7a01055c5b3f52db3b57" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictPropertyInitialization</source>
          <target state="translated">TypeScriptStrictPropertyInitialization</target>
        </trans-unit>
        <trans-unit id="565bf41241b63a69256bebd7801f835b429830df" translate="yes" xml:space="preserve">
          <source>TypeScriptStripInternal</source>
          <target state="translated">TypeScriptStripInternal</target>
        </trans-unit>
        <trans-unit id="558de0db52b8fdbbfefba7315f0e5b368e1bccc8" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressExcessPropertyErrors</source>
          <target state="translated">TypeScriptSuppressExcessPropertyErrors</target>
        </trans-unit>
        <trans-unit id="321f13b1fb2371cd5951fbfd893bddec800abf02" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressImplicitAnyIndexErrors</source>
          <target state="translated">TypeScriptSuppressImplicitAnyIndexErrors</target>
        </trans-unit>
        <trans-unit id="1df2c0c33e87134f7b9585a2fc5c306565947b0c" translate="yes" xml:space="preserve">
          <source>TypeScriptTarget</source>
          <target state="translated">TypeScriptTarget</target>
        </trans-unit>
        <trans-unit id="71d1dceb1918725eab2477bf3bc8195ca94011da" translate="yes" xml:space="preserve">
          <source>TypeScriptUseDefineForClassFields</source>
          <target state="translated">TypeScriptUseDefineForClassFields</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="d69d793fa4b90aab364868879e764b399a806ac0" translate="yes" xml:space="preserve">
          <source>Types - &lt;code&gt;types&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f831a607f5835e209904afa74400f9d95d0c1f0" translate="yes" xml:space="preserve">
          <source>Types as Sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a23621c19578981ae69a01b97eead68c0765db" translate="yes" xml:space="preserve">
          <source>Types by Inference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34915d42cc54d52a01ea82c5bdce2991a6ef1cbb" translate="yes" xml:space="preserve">
          <source>Types can exist in &lt;em&gt;namespaces&lt;/em&gt;. For example, if we have the declaration &lt;code&gt;let x: A.B.C&lt;/code&gt;, we say that the type &lt;code&gt;C&lt;/code&gt; comes from the &lt;code&gt;A.B&lt;/code&gt; namespace.</source>
          <target state="translated">Типы могут существовать в &lt;em&gt;пространствах имен&lt;/em&gt; . Например, если у нас есть объявление &lt;code&gt;let x: A.B.C&lt;/code&gt; , мы говорим, что тип &lt;code&gt;C&lt;/code&gt; происходит из пространства имен &lt;code&gt;A.B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ee9af272b9b52e38ff727c2aeeaf8e298f25123" translate="yes" xml:space="preserve">
          <source>Types in Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4983c5239614810aa77447dfbec17bd7041d4202" translate="yes" xml:space="preserve">
          <source>Types that have a common, singleton type property &amp;mdash; the &lt;em&gt;discriminant&lt;/em&gt;.</source>
          <target state="translated">Типы, которые имеют общее свойство одноэлементного типа - &lt;em&gt;дискриминант&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ab7315f529976c1e9046634d7f86b088c404171a" translate="yes" xml:space="preserve">
          <source>Types with a string index signature can be indexed using the &lt;code&gt;[]&lt;/code&gt; notation, but were not allowed to use the &lt;code&gt;.&lt;/code&gt;. Starting with TypeScript 2.2 using either should be allowed.</source>
          <target state="translated">Типы со строковой индексной подписью могут быть проиндексированы с использованием нотации &lt;code&gt;[]&lt;/code&gt; , но им не разрешено использовать &lt;code&gt;.&lt;/code&gt; . Начиная с TypeScript 2.2 использование любого из них должно быть разрешено.</target>
        </trans-unit>
        <trans-unit id="eefc11c2a4fd735c4e7783f6bcfa193306bfe237" translate="yes" xml:space="preserve">
          <source>Typescript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="translated">Typescript заимствует синтаксис приведения из Closure. Это позволяет &lt;code&gt;@type&lt;/code&gt; типы в другие типы, добавляя тег @type перед любым выражением в скобках.</target>
        </trans-unit>
        <trans-unit id="4c9358fb040ac0e3e60567763fe2b8b87185ed9b" translate="yes" xml:space="preserve">
          <source>Typescript is smart enough to infer the type of things in other contexts as well:</source>
          <target state="translated">Typescript достаточно умен,чтобы делать выводы о типе вещей и в других контекстах:</target>
        </trans-unit>
        <trans-unit id="aa237f14744bf9c080f4239d70330d26fd6782a1" translate="yes" xml:space="preserve">
          <source>Typically, exporting from a module involves adding properties to a value like &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:</source>
          <target state="translated">Обычно экспорт из модуля включает добавление свойств к значению, например, &lt;code&gt;exports&lt;/code&gt; или &lt;code&gt;module.exports&lt;/code&gt; . TypeScript позволяет использовать операторы экспорта верхнего уровня. Например, если вы экспортировали такую ​​функцию:</target>
        </trans-unit>
        <trans-unit id="c2df529fd52e531e7ccfbb71ef147f00c590c161" translate="yes" xml:space="preserve">
          <source>Typing the function</source>
          <target state="translated">Ввод функции</target>
        </trans-unit>
        <trans-unit id="1184391d4660ab61ecb650550cc662801a4ad10e" translate="yes" xml:space="preserve">
          <source>UMD SimpleModule.js</source>
          <target state="translated">UMD SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="afb3e96e84eea2d4709a70ab3751ff0f583aa243" translate="yes" xml:space="preserve">
          <source>UMD modules</source>
          <target state="translated">модули UMD</target>
        </trans-unit>
        <trans-unit id="bf3e09cfd260f3d9900f06488088b667722b7926" translate="yes" xml:space="preserve">
          <source>Uglify</source>
          <target state="translated">Uglify</target>
        </trans-unit>
        <trans-unit id="0a5bbb787c318135c5901c5f8fb697634bd5bb32" translate="yes" xml:space="preserve">
          <source>Uglify compacts your code so that it takes less time to download.</source>
          <target state="translated">Углубление уплотняет ваш код,так что загрузка занимает меньше времени.</target>
        </trans-unit>
        <trans-unit id="ae386e47ac367ccb8dc289004083400a638ccbc5" translate="yes" xml:space="preserve">
          <source>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called &amp;ldquo;assertion signatures&amp;rdquo; which model these assertion functions.</source>
          <target state="translated">В конечном итоге цель TypeScript состоит в том, чтобы набирать существующие конструкции JavaScript наименее разрушительным образом. По этой причине TypeScript 3.7 представляет новую концепцию, называемую &amp;laquo;сигнатуры утверждений&amp;raquo;, которые моделируют эти функции утверждения.</target>
        </trans-unit>
        <trans-unit id="4339e741945b9652bb1d49489e6a98543eef7bb2" translate="yes" xml:space="preserve">
          <source>Uncalled Function Checks</source>
          <target state="translated">Неустановленные функциональные проверки</target>
        </trans-unit>
        <trans-unit id="180b1f03e6992ccd4fc623bfa5063f77a58ada25" translate="yes" xml:space="preserve">
          <source>Unconditional calls to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">Безусловные вызовы &lt;code&gt;require&lt;/code&gt; или &lt;code&gt;define&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b497122fd6b99841feeae2f0b3528acf90c34986" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; function type parameter positions are checked &lt;em&gt;contravariantly&lt;/em&gt; instead of &lt;em&gt;bivariantly&lt;/em&gt;. For some background on what variance means for function types check out &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;What are covariance and contravariance?&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;--strictFunctionTypes&lt;/code&gt; позиции параметров типа функции проверяются &lt;em&gt;контравариантно,&lt;/em&gt; а не &lt;em&gt;бивариантно&lt;/em&gt; . Чтобы узнать, что означает дисперсия для типов функций, ознакомьтесь с разделом &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;Что такое ковариация и контравариантность? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2346be489fd11bd810e990b096f9680008f047bd" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; the first assignment is still permitted if &lt;code&gt;compare&lt;/code&gt; was declared as a method. Effectively, &lt;code&gt;T&lt;/code&gt; is bivariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in method parameter positions.</source>
          <target state="translated">В параметре &lt;code&gt;--strictFunctionTypes&lt;/code&gt; первое присвоение по-прежнему разрешено, если &lt;code&gt;compare&lt;/code&gt; было объявлено как метод. Фактически, &lt;code&gt;T&lt;/code&gt; является двухвариантным в &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; потому что он используется только в позициях параметров метода.</target>
        </trans-unit>
        <trans-unit id="33054f0cbee74c9f788ca4bd77541c3e143d3d3f" translate="yes" xml:space="preserve">
          <source>Under the new &lt;code&gt;--esModuleInterop&lt;/code&gt; these two issues should be addressed:</source>
          <target state="translated">В новом &lt;code&gt;--esModuleInterop&lt;/code&gt; должны быть решены эти две проблемы:</target>
        </trans-unit>
        <trans-unit id="128561d89ec896d82327b08129ac6710b805e301" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">Понимание &lt;code&gt;private&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54219e3d20bedb021463636f2132089eb4de56ba" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">Понимание &lt;code&gt;protected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc76f54e044a62bc08d7f563732d6c4137e806c" translate="yes" xml:space="preserve">
          <source>Understanding Errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb57f5cf2c9525393089f7f613c8715146826b2" translate="yes" xml:space="preserve">
          <source>Understanding TypeScript&amp;rsquo;s &lt;code&gt;private&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23e9d7d02cff72c54df81048c1a4380b98b0319" translate="yes" xml:space="preserve">
          <source>Understanding private</source>
          <target state="translated">Понимание частного</target>
        </trans-unit>
        <trans-unit id="95841ad8022df544f75a9cb58504b9e361799465" translate="yes" xml:space="preserve">
          <source>Understanding protected</source>
          <target state="translated">Понимание защищено</target>
        </trans-unit>
        <trans-unit id="ce277cc9234cfe2b86b777dd92906ff2f86a4ffc" translate="yes" xml:space="preserve">
          <source>Understanding the sample</source>
          <target state="translated">Понимание образца</target>
        </trans-unit>
        <trans-unit id="b8046695cbb07b887254bfc5fba8b62777baab42" translate="yes" xml:space="preserve">
          <source>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</source>
          <target state="translated">Понимание того,что создается с каждой декларацией,поможет вам понять,что объединяется,когда вы выполняете объединение деклараций.</target>
        </trans-unit>
        <trans-unit id="b6d31265a9d2bb701584804cfe2084c1e863a4e3" translate="yes" xml:space="preserve">
          <source>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</source>
          <target state="translated">К сожалению,в TypeScript эти проверки никогда не могли быть правильно закодированы.Для свободно написанного кода это означало,что TypeScript проверял меньше,а для слегка консервативного кода это часто заставляло пользователей использовать утверждения типов.</target>
        </trans-unit>
        <trans-unit id="f5ac25ede763c83433a3b880f5f3fc5c401f7ac2" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;--declaration&lt;/code&gt; didn&amp;rsquo;t work with the &lt;code&gt;--allowJs&lt;/code&gt; flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn&amp;rsquo;t use the &lt;code&gt;--declaration&lt;/code&gt; flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!</source>
          <target state="translated">К сожалению, &lt;code&gt;--declaration&lt;/code&gt; не работает с флагом &lt;code&gt;--allowJs&lt;/code&gt; , который позволяет смешивать входные файлы TypeScript и JavaScript. Это было разочаровывающим ограничением, потому что это означало, что пользователи не могли использовать флаг &lt;code&gt;--declaration&lt;/code&gt; при переносе кодовых баз, даже если они были аннотированы JSDoc. TypeScript 3.7 меняет это и позволяет использовать оба параметра вместе!</target>
        </trans-unit>
        <trans-unit id="90407376a294ed45dab6024b8ace72b1f1a4f495" translate="yes" xml:space="preserve">
          <source>Unfortunately, mapped types like the &lt;code&gt;Readonly&lt;/code&gt; utility type were effectively no-ops on array and tuple types.</source>
          <target state="translated">К сожалению, сопоставленные типы, такие как служебный тип &lt;code&gt;Readonly&lt;/code&gt; , фактически не работали с типами массивов и кортежей.</target>
        </trans-unit>
        <trans-unit id="c9f9b24434ff80b111bededc5c17e2eb1610c1fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, the type of &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is still &lt;code&gt;any&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;this&lt;/code&gt; comes from the function expression inside the object literal. To fix this, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">К сожалению, тип &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; все еще &lt;code&gt;any&lt;/code&gt; . Это потому, что &lt;code&gt;this&lt;/code&gt; происходит от выражения функции внутри литерала объекта. Чтобы исправить это, вы можете явно указать &lt;code&gt;this&lt;/code&gt; параметр. &lt;code&gt;this&lt;/code&gt; фальшивые параметры, которые идут первыми в списке параметров функции:</target>
        </trans-unit>
        <trans-unit id="e53ce54f63b88cf452ded6201871a14783c0be8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, this means that constructor functions that are also callable cannot use &lt;code&gt;@constructor&lt;/code&gt;.</source>
          <target state="translated">К сожалению, это означает, что функции конструктора, которые также можно &lt;code&gt;@constructor&lt;/code&gt; не могут использовать @constructor .</target>
        </trans-unit>
        <trans-unit id="da9748783613337de4d74ee2abacadcb4e991578" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:</source>
          <target state="translated">К сожалению,несмотря на то,что это казалось направлением,в котором предложение двигалось в прежние времена,существует чрезвычайно большая вероятность того,что поля общественного класса будут стандартизированы по-другому.Вместо этого,в оригинальном примере кода,возможно,потребуется де-сугар для чего-то более близкого к следующему:</target>
        </trans-unit>
        <trans-unit id="b582e2c337ad84d8772f97cd78414fbed01f687b" translate="yes" xml:space="preserve">
          <source>Unicode codepoint escapes in strings</source>
          <target state="translated">Юникод кодовых точек уходит в строки</target>
        </trans-unit>
        <trans-unit id="d0fec623da4b84453812e1c4c0b17b0a532ec7d4" translate="yes" xml:space="preserve">
          <source>Union Exhaustiveness checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">Союзные Типы</target>
        </trans-unit>
        <trans-unit id="b7ed90cee7078e9ede776e2d455827cd6c390d7b" translate="yes" xml:space="preserve">
          <source>Union enums and enum member types</source>
          <target state="translated">Объединенные перечисления и типы членов перечисления</target>
        </trans-unit>
        <trans-unit id="aba2f05474229fdcd9d1da33808bf8c11dd33d17" translate="yes" xml:space="preserve">
          <source>Union type subtype reduction only removes a class type if it is a subclass of &lt;em&gt;and&lt;/em&gt; derives from another class type in the union.</source>
          <target state="translated">Сокращение подтипа типа объединения удаляет только тип класса, если он является подклассом &lt;em&gt;и является&lt;/em&gt; производным от другого типа класса в объединении.</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">Виды союзов</target>
        </trans-unit>
        <trans-unit id="56de4c1005168da2654053cbc54188220ab6bb4f" translate="yes" xml:space="preserve">
          <source>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</source>
          <target state="translated">Объединение типов также позволяет улучшить вывод типа в массивах и других местах,где у вас может быть несколько типов значений в коллекции:</target>
        </trans-unit>
        <trans-unit id="3e7108953bcfc1c7c0311e2518816a93bc306b40" translate="yes" xml:space="preserve">
          <source>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;string[]&lt;/code&gt; or a function that returns a &lt;code&gt;string&lt;/code&gt;. You can now write:</source>
          <target state="translated">Типы Union - мощный способ выразить значение, которое может быть одним из нескольких типов. Например, у вас может быть API для запуска программы, которая принимает командную &lt;code&gt;string&lt;/code&gt; как строку , &lt;code&gt;string[]&lt;/code&gt; или функцию, возвращающую &lt;code&gt;string&lt;/code&gt; . Теперь вы можете написать:</target>
        </trans-unit>
        <trans-unit id="70635a04ab9351bca09c5621dffee8f76929cc2c" translate="yes" xml:space="preserve">
          <source>Union types are an advanced topic that we&amp;rsquo;ll cover in a later chapter.</source>
          <target state="translated">Типы союза - это сложная тема, которую мы рассмотрим в следующей главе.</target>
        </trans-unit>
        <trans-unit id="3fa5955704db38dbb3e16e34ca92691e9ea2bbf5" translate="yes" xml:space="preserve">
          <source>Union types are closely related to intersection types, but they are used very differently. Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">Типы объединения тесно связаны с типами пересечений, но используются по-разному. Иногда вы сталкиваетесь с библиотекой, которая ожидает, что параметр будет либо &lt;code&gt;number&lt;/code&gt; либо &lt;code&gt;string&lt;/code&gt; . Например, возьмите следующую функцию:</target>
        </trans-unit>
        <trans-unit id="cd921c2ea01c32f5a34e452b767384ff1f31852e" translate="yes" xml:space="preserve">
          <source>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a &lt;code&gt;Fish&lt;/code&gt;? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</source>
          <target state="translated">Типы объединения полезны для моделирования ситуаций, когда значения могут перекрываться в типах, которые они могут принимать. Что происходит, когда нам нужно конкретно знать, есть ли у нас &lt;code&gt;Fish&lt;/code&gt; ? Распространенной идиомой в JavaScript для различения двух возможных значений является проверка наличия члена. Как мы уже упоминали, вы можете получить доступ только к тем членам, которые гарантированно входят во все составляющие типа объединения.</target>
        </trans-unit>
        <trans-unit id="d4d68a0298812ddd887befc8ebd536a465311e12" translate="yes" xml:space="preserve">
          <source>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type &lt;code&gt;A | B&lt;/code&gt;, we only know for &lt;em&gt;certain&lt;/em&gt; that it has members that both &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;B&lt;/code&gt; have. In this example, &lt;code&gt;Bird&lt;/code&gt; has a member named &lt;code&gt;fly&lt;/code&gt;. We can&amp;rsquo;t be sure whether a variable typed as &lt;code&gt;Bird | Fish&lt;/code&gt; has a &lt;code&gt;fly&lt;/code&gt; method. If the variable is really a &lt;code&gt;Fish&lt;/code&gt; at runtime, then calling &lt;code&gt;pet.fly()&lt;/code&gt; will fail.</source>
          <target state="translated">Типы Union здесь могут быть немного сложными, но чтобы привыкнуть, нужно просто немного интуиции. Если значение имеет тип &lt;code&gt;A | B&lt;/code&gt; , мы знаем только &lt;em&gt;уверены&lt;/em&gt; , что у него есть элементы , которые , как &lt;em&gt;и &lt;/em&gt; &lt;code&gt;B&lt;/code&gt; имеют. В этом примере у &lt;code&gt;Bird&lt;/code&gt; есть член с именем &lt;code&gt;fly&lt;/code&gt; . Мы не можем быть уверены, что переменная типа &lt;code&gt;Bird | Fish&lt;/code&gt; есть &lt;code&gt;fly&lt;/code&gt; . Если во время выполнения переменная действительно является &lt;code&gt;Fish&lt;/code&gt; , вызов &lt;code&gt;pet.fly()&lt;/code&gt; завершится ошибкой. &lt;code&gt;A&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="00002b164c08859d5a15579e55c8f17ce6478546" translate="yes" xml:space="preserve">
          <source>Unions</source>
          <target state="translated">Unions</target>
        </trans-unit>
        <trans-unit id="f48468b06a9e4516b5c97a2b05c0405b665a11bd" translate="yes" xml:space="preserve">
          <source>Unions and Intersection Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a013266da3448b7cdbeb6ae12b743b8431bc0dc9" translate="yes" xml:space="preserve">
          <source>Unions provide a way to handle different types too. For example, you may have a function that takes an &lt;code&gt;array&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716232e9652a75720d14510144c825017458f7cc" translate="yes" xml:space="preserve">
          <source>Unions with Common Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec354f7a8e237dd28115d025f20f869218004ad" translate="yes" xml:space="preserve">
          <source>Unit types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9003e1fae84a4609d6b8fb77cb5eb2556e480e27" translate="yes" xml:space="preserve">
          <source>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; has the type &lt;code&gt;&quot;foo&quot;&lt;/code&gt;. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7819b34ff87570745fbe461e36a16f80e562ce" translate="yes" xml:space="preserve">
          <source>Unknown</source>
          <target state="translated">Unknown</target>
        </trans-unit>
        <trans-unit id="ece8b3c6faf7510538396ff92255b9fc5deb4014" translate="yes" xml:space="preserve">
          <source>Unless you take specific measures to avoid it, the internal state of a &lt;code&gt;const&lt;/code&gt; variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are &lt;code&gt;readonly&lt;/code&gt;. The &lt;a href=&quot;interfaces&quot;&gt;chapter on Interfaces&lt;/a&gt; has the details.</source>
          <target state="translated">Если вы не примете конкретных мер, чтобы избежать этого, внутреннее состояние &lt;code&gt;const&lt;/code&gt; переменной все еще можно изменить. К счастью, TypeScript позволяет указать, что члены объекта доступны только для &lt;code&gt;readonly&lt;/code&gt; . В &lt;a href=&quot;interfaces&quot;&gt;главе об интерфейсах&lt;/a&gt; есть подробности.</target>
        </trans-unit>
        <trans-unit id="c861cf88ebb1a5b494f6992b73222db7fff28246" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;re really trying to take advantage of JavaScript&amp;rsquo;s runtime behavior in a clever way, it&amp;rsquo;s advised that you don&amp;rsquo;t do this.</source>
          <target state="translated">Если вы действительно не пытаетесь разумно использовать поведение JavaScript во время выполнения, вам не рекомендуется этого делать.</target>
        </trans-unit>
        <trans-unit id="84b3e4863aee46ac562de68360e58df6ef13bb83" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;unknown&lt;/code&gt;, variables of type &lt;code&gt;any&lt;/code&gt; allow you to access arbitrary properties, even ones that don&amp;rsquo;t exist. These properties include functions and TypeScript will not check their existence or type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f45df55b8eab061b85101f488f9a767624cd64" translate="yes" xml:space="preserve">
          <source>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading &lt;code&gt;|&lt;/code&gt; is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c675fd40f67f1744d7a77a8ad4c15f4daebdc18" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;mdash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1461542d00d5010806839c20e64aa1678fdff5" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, Typescript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;ndash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="translated">В отличие от системы типов JSDoc, Typescript позволяет отмечать типы только как содержащие null или нет. Нет явного недопустимости обнуления - если включена strictNullChecks, &lt;code&gt;number&lt;/code&gt; не допускает обнуления . Если он выключен, &lt;code&gt;number&lt;/code&gt; допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="51985852906766cae660d6a12174c73de43d98b6" translate="yes" xml:space="preserve">
          <source>Unlike plain optional parameters, default-initialized parameters don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass &lt;code&gt;undefined&lt;/code&gt; to get the default initialized value. For example, we could write our last example with only a default initializer on &lt;code&gt;firstName&lt;/code&gt;:</source>
          <target state="translated">В отличие от простых необязательных параметров, параметры, инициализированные по умолчанию, не &lt;em&gt;должны располагаться&lt;/em&gt; после обязательных параметров. Если перед обязательным параметром стоит инициализированный по умолчанию параметр, пользователям необходимо явно передать &lt;code&gt;undefined&lt;/code&gt; , чтобы получить инициализированное значение по умолчанию. Например, мы могли бы написать наш последний пример только с инициализатором по умолчанию для &lt;code&gt;firstName&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b497f9d0d5c2c4f2547035f0fcd80ba5746c84a" translate="yes" xml:space="preserve">
          <source>Unreachable code</source>
          <target state="translated">Недоступный код</target>
        </trans-unit>
        <trans-unit id="1d0500c74b8aa49d1d2f3d7c0b7c86b3a9d2a921" translate="yes" xml:space="preserve">
          <source>Unspecified type parameters default to &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">Параметры неуказанного типа по умолчанию равны &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c849b45ea75a8c2321b502c7837adbcdc9a6ff" translate="yes" xml:space="preserve">
          <source>Unsupported tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1948c97816d203ebc2f90700d76faedc4fbbccfe" translate="yes" xml:space="preserve">
          <source>Untyped imports</source>
          <target state="translated">Непроизводительный импорт</target>
        </trans-unit>
        <trans-unit id="42a377f570d337b6d69100d6ff55ff5b9e97a424" translate="yes" xml:space="preserve">
          <source>Unused labels</source>
          <target state="translated">Неиспользованные этикетки</target>
        </trans-unit>
        <trans-unit id="950c29b1f717e4fff1d2a159fa44b64e58240c0f" translate="yes" xml:space="preserve">
          <source>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; to stop reporting these errors.</source>
          <target state="translated">Также помечаются неиспользуемые ярлыки. Так же, как и проверки недостижимого кода, они включены по умолчанию; используйте &lt;code&gt;--allowUnusedLabels&lt;/code&gt; , чтобы перестать сообщать об этих ошибках.</target>
        </trans-unit>
        <trans-unit id="3ea5ca14dc52b9bd423f61c07136cde4865d6a52" translate="yes" xml:space="preserve">
          <source>Up to this point, we&amp;rsquo;ve only talked about the &lt;em&gt;instance&lt;/em&gt; members of the class, those that show up on the object when it&amp;rsquo;s instantiated. We can also create &lt;em&gt;static&lt;/em&gt; members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &lt;code&gt;static&lt;/code&gt; on the origin, as it&amp;rsquo;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &lt;code&gt;this.&lt;/code&gt; in front of instance accesses, here we prepend &lt;code&gt;Grid.&lt;/code&gt; in front of static accesses.</source>
          <target state="translated">До этого момента мы говорили только о членах &lt;em&gt;экземпляра&lt;/em&gt; класса, которые появляются в объекте при его создании. Мы также можем создавать &lt;em&gt;статические&lt;/em&gt; члены класса, которые видны в самом классе, а не в экземплярах. В этом примере мы используем &lt;code&gt;static&lt;/code&gt; для начала координат, поскольку это общее значение для всех сеток. Каждый экземпляр получает доступ к этому значению, добавляя имя класса. Аналогично добавлению &lt;code&gt;this.&lt;/code&gt; перед обращениями к экземплярам здесь мы добавляем &lt;code&gt;Grid.&lt;/code&gt; перед статическими доступами.</target>
        </trans-unit>
        <trans-unit id="ad67feee99a0f439a0e27027c5ea3dcbcf7ff3d4" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;.vscode/settings.json&lt;/code&gt; with the following:</source>
          <target state="translated">Обновите &lt;code&gt;.vscode/settings.json&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="0c453d2caa8ecb4d47c7c21d916dd5de2c9571a9" translate="yes" xml:space="preserve">
          <source>Update project file to include locally installed &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (at the top) and &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (at the bottom) files:</source>
          <target state="translated">Обновите файл проекта, включив в него локально установленные файлы &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (вверху) и &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (внизу):</target>
        </trans-unit>
        <trans-unit id="61ef22d6991101f4978ea02b3e277ed08f8a02ed" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;Settings - User&lt;/code&gt; file with the following:</source>
          <target state="translated">Обновите &lt;code&gt;Settings - User&lt;/code&gt; файл следующим образом:</target>
        </trans-unit>
        <trans-unit id="8b2b612f6daeee72c04fac6bf2b62e95619d91d9" translate="yes" xml:space="preserve">
          <source>Updating your IDE to use the nightly builds</source>
          <target state="translated">Обновление вашей IDE для использования ночных сборок</target>
        </trans-unit>
        <trans-unit id="baadd0b4691cd923997ea6041f0a70f9d9c1d58d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;--jsxFactory&lt;/code&gt;&lt;/a&gt; instead. Specify the object invoked for &lt;code&gt;createElement&lt;/code&gt; when targeting &lt;code&gt;react&lt;/code&gt; for TSX files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396d021a8d5ef888effc1abd9236b7f66ab50d42" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#outFile&quot;&gt;outFile&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794a3710c02b705cb8176f0ebe766dee147dd40c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#skipLibCheck&quot;&gt;&lt;code&gt;--skipLibCheck&lt;/code&gt;&lt;/a&gt; instead. Skip type checking of default library declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd29d9aedccf4abdd9f95da49e8b3e269208158" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a820b114f9666c422cc3a7015e046eea0e5ef5f7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc2e4b6eb759a2e235283631204f80eaa19dc57" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">Используйте &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; ,&lt;/a&gt; если ваш модуль может быть &lt;em&gt;построен&lt;/em&gt; с использованием &lt;code&gt;new&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dcb83b510816e0232e4eea4a6e8821858e1d88cf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">Используйте &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; , если ваш модуль можно &lt;em&gt;назвать&lt;/em&gt; как функция:</target>
        </trans-unit>
        <trans-unit id="9135ad666eb865ef0f03b22c777b4833dda580f4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--pretty false&lt;/code&gt; on the command line or set &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; to disable &lt;code&gt;--pretty&lt;/code&gt; output.</source>
          <target state="translated">Используйте &lt;code&gt;--pretty false&lt;/code&gt; в командной строке или установите &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; в вашем &lt;code&gt;tsconfig.json&lt;/code&gt; , чтобы отключить вывод &lt;code&gt;--pretty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d777cba827da4d9bd0a80b90d7cc7d35bc7eb763" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare class&lt;/code&gt; to describe a class or class-like object. Classes can have properties and methods as well as a constructor.</source>
          <target state="translated">Используйте &lt;code&gt;declare class&lt;/code&gt; для описания класса или подобного классу объекта. Классы могут иметь свойства и методы, а также конструктор.</target>
        </trans-unit>
        <trans-unit id="1d25646e3d1c96527dec663a49cd97e0a677f024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare function&lt;/code&gt; to declare functions.</source>
          <target state="translated">Используйте &lt;code&gt;declare function&lt;/code&gt; declare для объявления функций.</target>
        </trans-unit>
        <trans-unit id="dc5e87631ffbf23b795c1170d5135c6525f91882" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare namespace&lt;/code&gt; to describe types or values accessed by dotted notation.</source>
          <target state="translated">Используйте &lt;code&gt;declare namespace&lt;/code&gt; для описания типов или значений, к которым осуществляется доступ через точечную нотацию.</target>
        </trans-unit>
        <trans-unit id="646cf6b60f19ec39b9a348c993659c06af5ff17e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare var&lt;/code&gt; to declare variables. If the variable is read-only, you can use &lt;code&gt;declare const&lt;/code&gt;. You can also use &lt;code&gt;declare let&lt;/code&gt; if the variable is block-scoped.</source>
          <target state="translated">Используйте &lt;code&gt;declare var&lt;/code&gt; для объявления переменных. Если переменная доступна только для чтения, вы можете использовать &lt;code&gt;declare const&lt;/code&gt; . Вы также можете использовать &lt;code&gt;declare let&lt;/code&gt; , если переменная имеет блочную область видимости.</target>
        </trans-unit>
        <trans-unit id="fc7b733452effbd68c17f48699824b764aa4d5c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; to watch directories and child directories</source>
          <target state="translated">Используйте &lt;code&gt;fs.watch&lt;/code&gt; для просмотра каталогов и дочерних каталогов</target>
        </trans-unit>
        <trans-unit id="a20558d88b96350c2a6617d2a8806bb939c26e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; which uses file system events (but might not be accurate on different OS) to get the notifications for the file changes/creation/deletion. Note that few OS eg. linux has limit on number of watches and failing to create watcher using &lt;code&gt;fs.watch&lt;/code&gt; will result it in creating using &lt;code&gt;fs.watchFile&lt;/code&gt;</source>
          <target state="translated">Используйте &lt;code&gt;fs.watch&lt;/code&gt; , который использует события файловой системы (но может быть неточным в другой ОС), чтобы получать уведомления об изменениях / создании / удалении файлов. Обратите внимание, что некоторые ОС, например. linux имеет ограничение на количество часов, и &lt;code&gt;fs.watch&lt;/code&gt; создания наблюдателя с использованием fs.watch приведет к его созданию с использованием &lt;code&gt;fs.watchFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8a0ecc46b3020c85d683ef9e7bfc225a06e140d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; but use different polling intervals for source files, config files and missing files</source>
          <target state="translated">Используйте &lt;code&gt;fs.watchFile&lt;/code&gt; , но используйте разные интервалы опроса для исходных файлов, файлов конфигурации и отсутствующих файлов</target>
        </trans-unit>
        <trans-unit id="d9b3f25a00b42d34692eae633c97a930b3ef45c2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; to watch the directories and child directories which is a polling watch (consuming CPU cycles)</source>
          <target state="translated">Используйте &lt;code&gt;fs.watchFile&lt;/code&gt; для просмотра каталогов и дочерних каталогов, которые являются часами опроса (потребляют циклы ЦП)</target>
        </trans-unit>
        <trans-unit id="b82d02e810b66cfc5287f1002d1703389ec9f322" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; as an explicit type annotation instead, or do not add a type annotation as done in the example above.</source>
          <target state="translated">Использовать &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; вместо этого в качестве явной аннотации типа или не добавляйте аннотацию типа, как это сделано в примере выше.</target>
        </trans-unit>
        <trans-unit id="6e4e750a17d76a60f93d2129a4bfe65128e56bdc" translate="yes" xml:space="preserve">
          <source>Use Define For Class Fields - &lt;code&gt;useDefineForClassFields&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c797e1ab4188af4e8f2f348f9d4813348e879b0b" translate="yes" xml:space="preserve">
          <source>Use JSDoc &lt;code&gt;@augments&lt;/code&gt; to specify the types explicitly. for instance:</source>
          <target state="translated">Используйте JSDoc &lt;code&gt;@augments&lt;/code&gt; , чтобы явно указать типы. например:</target>
        </trans-unit>
        <trans-unit id="26914e7e48730258a108abb453430cd3518851d2" translate="yes" xml:space="preserve">
          <source>Use Optional Parameters</source>
          <target state="translated">Использовать дополнительные параметры</target>
        </trans-unit>
        <trans-unit id="1f551ab7cd042c6186f08b5016c6fbb015348adf" translate="yes" xml:space="preserve">
          <source>Use Union Types</source>
          <target state="translated">Использовать Союз Типы</target>
        </trans-unit>
        <trans-unit id="c6e9ca22aa2af3128ca0dfccc6ca984b9a53e2f4" translate="yes" xml:space="preserve">
          <source>Use a dynamic queue where in the frequently modified files will be polled at shorter interval and the files unchanged will be polled less frequently</source>
          <target state="translated">Использовать динамическую очередь,в которой часто изменяемые файлы будут опрашиваться с меньшим интервалом,а неизмененные файлы будут опрашиваться реже</target>
        </trans-unit>
        <trans-unit id="b6bcaab1110f17c72658c24deb9f410172d12ea7" translate="yes" xml:space="preserve">
          <source>Use a type assertion (i.e. &lt;code&gt;opts as Options&lt;/code&gt;).</source>
          <target state="translated">Используйте утверждение типа (т.е. &lt;code&gt;opts as Options&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c373f04992cf46cf315a11d0cfd773d124512011" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;interface&lt;/code&gt; to define a type with properties.</source>
          <target state="translated">Используйте &lt;code&gt;interface&lt;/code&gt; для определения типа со свойствами.</target>
        </trans-unit>
        <trans-unit id="de6bf5682731fffe8d17a1a2893ad0e0e875fbd9" translate="yes" xml:space="preserve">
          <source>Use comma or multiple tags to declare multiple type parameters:</source>
          <target state="translated">Используйте запятую или несколько тегов для объявления параметров нескольких типов:</target>
        </trans-unit>
        <trans-unit id="813eb2c164fdf97484adee07af475b49c979cbf5" translate="yes" xml:space="preserve">
          <source>Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets &lt;em&gt;really&lt;/em&gt; hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.</source>
          <target state="translated">Осторожно используйте деструктуризацию. Как показывает предыдущий пример, все, кроме простейшего выражения деструктуризации, сбивает с толку. Это особенно верно для глубоко вложенной деструктуризации, которую &lt;em&gt;действительно&lt;/em&gt; трудно понять даже без переименования, значений по умолчанию и аннотаций типов. Старайтесь, чтобы деструктурирующие выражения были небольшими и простыми. Вы всегда можете написать задания, которые деструктуризация создаст самостоятельно.</target>
        </trans-unit>
        <trans-unit id="84ca1d512ea34e66413a09bf03aea43da1cd5e61" translate="yes" xml:space="preserve">
          <source>Use dynamic polling queue to poll changes to the directory and child directories.</source>
          <target state="translated">Используйте динамическую очередь опроса для опроса изменений в каталогах и дочерних каталогах.</target>
        </trans-unit>
        <trans-unit id="476bd570b1cb323c844b457111807cf0bfe14c03" translate="yes" xml:space="preserve">
          <source>Use namespaces to organize types.</source>
          <target state="translated">Используйте пространства имен для организации типов.</target>
        </trans-unit>
        <trans-unit id="a7fb2226e7d1637c125b100d2ae8ebe1ff2bbb66" translate="yes" xml:space="preserve">
          <source>Use returned values from super calls as &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">Используйте возвращаемые значения из супервызовов как 'this'</target>
        </trans-unit>
        <trans-unit id="4281cb2734b20854fad7ce1621ef834a4a1b4e65" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674fffd874755fee3353fca4923c07272aaa239e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec0cfa03e45ca3f1d25fc09af8034cc6ba3a098" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Используйте шаблон &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt; &lt;code&gt;global-modifying-module.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f66cc8b895d213df6b8e2c503e64c2fdad1da70f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module.d.ts.md&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467a1132d18100a2fea14dea179fb807cc8c9786" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Используйте шаблон &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global-plugin.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ded88ccc850f489f2c1db682f66acc6ce6e89c02" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">Используйте шаблон &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d00f93f8ed19c310af833f02b233f61189f29867" translate="yes" xml:space="preserve">
          <source>Use the namespace import pattern if you&amp;rsquo;re importing a large number of things</source>
          <target state="translated">Используйте шаблон импорта пространства имен, если вы импортируете большое количество вещей</target>
        </trans-unit>
        <trans-unit id="181dfdffa543aacf139786370fa1942354e5e0e8" translate="yes" xml:space="preserve">
          <source>Use the specified end of line sequence to be used when emitting files: &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) or &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix).&amp;rdquo;</source>
          <target state="translated">Используйте указанную последовательность конца строки, которая будет использоваться при &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; файлов: &amp;laquo;crlf&amp;raquo; (windows) или &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix) &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="991f181fa1f670d03fe9e8348c63df208559c8f3" translate="yes" xml:space="preserve">
          <source>Use the template &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5dbc74cf020a727ea7578eaadc331456e2cdd0" translate="yes" xml:space="preserve">
          <source>Use these directives only when you&amp;rsquo;re authoring a &lt;code&gt;d.ts&lt;/code&gt; file by hand.</source>
          <target state="translated">Используйте эти директивы только при &lt;code&gt;d.ts&lt;/code&gt; файла d.ts вручную.</target>
        </trans-unit>
        <trans-unit id="3c9eac17e15f70b4957575dc44afd54e3e8ed5d8" translate="yes" xml:space="preserve">
          <source>Use your best judgement, and if applicable, consult the matter with the rest of your team.</source>
          <target state="translated">Используйте свои лучшие суждения и,если применимо,проконсультируйтесь по этому вопросу с остальными членами команды.</target>
        </trans-unit>
        <trans-unit id="2adb0f1b976920901a418d9f6d757aa6988d5b84" translate="yes" xml:space="preserve">
          <source>Used to output diagnostic information for debugging. This command is a subset of &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;extendedDiagnostics&lt;/code&gt;&lt;/a&gt; which are more user-facing results, and easier to interpret.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e789822c27891d496e2d1c824f3137fc0a60e8" translate="yes" xml:space="preserve">
          <source>User Combinations</source>
          <target state="translated">Комбинации пользователей</target>
        </trans-unit>
        <trans-unit id="6db409b39dc46fb85822ac1924c1fb876244cc1a" translate="yes" xml:space="preserve">
          <source>User-Defined Type Guards</source>
          <target state="translated">Охрана типа,определяемая пользователем</target>
        </trans-unit>
        <trans-unit id="d8895e69c18f832a3dc18dc0b25ac0287a552c83" translate="yes" xml:space="preserve">
          <source>User-defined type guard functions</source>
          <target state="translated">Пользовательские функции защиты типа</target>
        </trans-unit>
        <trans-unit id="865aa2eab27a2eebc9f8c1b7ee2b45dba99a5722" translate="yes" xml:space="preserve">
          <source>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; syntax), and are directly nested either your own modules, or in another top level ambient external module.</source>
          <target state="translated">Теперь пользователи могут объявить любые дополнения, которые они хотят сделать или которые уже сделали другие потребители, в существующий модуль. Расширения модулей выглядят как простые старые объявления внешнего модуля (т.е. синтаксис &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; ) и напрямую вложены либо в ваши собственные модули, либо в другой внешний внешний модуль верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="b92638c4a093946ffe782b9c6ea843146edd2d04" translate="yes" xml:space="preserve">
          <source>Users can now ensure that the type system will catch such errors. Here&amp;rsquo;s our new &lt;code&gt;AnimationOptions&lt;/code&gt; using string literal types:</source>
          <target state="translated">Теперь пользователи могут быть уверены, что система типов уловит такие ошибки. Вот наши новые &lt;code&gt;AnimationOptions&lt;/code&gt; с использованием строковых литералов:</target>
        </trans-unit>
        <trans-unit id="971fc6da1fad26d48864984a1a77ed97685d4f3a" translate="yes" xml:space="preserve">
          <source>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</source>
          <target state="translated">Пользователи,использующие более новые версии TS,увидят подсказку обновить свой проект при первой загрузке.</target>
        </trans-unit>
        <trans-unit id="076baa79ca77082f0ca2b3320f7136b88d1a143c" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;rootDirs&amp;rsquo;, you can inform the compiler of the &lt;em&gt;roots&lt;/em&gt; making up this &amp;ldquo;virtual&amp;rdquo; directory; and thus the compiler can resolve relative modules imports within these &amp;ldquo;virtual&amp;rdquo; directories &lt;em&gt;as if&lt;/em&gt; were merged together in one directory.</source>
          <target state="translated">Используя 'rootDirs', вы можете сообщить компилятору о &lt;em&gt;корнях,&lt;/em&gt; составляющих этот &amp;laquo;виртуальный&amp;raquo; каталог; и, таким образом, компилятор может разрешить относительный импорт модулей в этих &amp;laquo;виртуальных&amp;raquo; каталогах, &lt;em&gt;как если бы они&lt;/em&gt; были объединены в один каталог.</target>
        </trans-unit>
        <trans-unit id="9c907fc236b5576ec4b9496e0b00bbfb71e593bd" translate="yes" xml:space="preserve">
          <source>Using --noResolve</source>
          <target state="translated">Используя --noResolve</target>
        </trans-unit>
        <trans-unit id="fea016f48554330486c9c94e60974382dcd30124" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</source>
          <target state="translated">Использование &lt;code&gt;&quot;paths&quot;&lt;/code&gt; также позволяет выполнять более сложные сопоставления, включая несколько резервных местоположений. Рассмотрим конфигурацию проекта, в которой только некоторые модули доступны в одном месте, а остальные - в другом.</target>
        </trans-unit>
        <trans-unit id="42ba4227d3af5762437561f59f30ce6a1e5f2260" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</source>
          <target state="translated">Использование &lt;code&gt;&quot;paths&quot;&lt;/code&gt; также позволяет использовать более сложные сопоставления, включая несколько резервных местоположений. Рассмотрим конфигурацию проекта, в которой только некоторые модули доступны в одном месте, а остальные - в другом. На этапе сборки все они будут собраны в одном месте. Макет проекта может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="06cd012e6c788da38d72b27da1a7bbf3bef7051d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--noResolve&lt;/code&gt;</source>
          <target state="translated">Использование &lt;code&gt;--noResolve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3bbb6573d95fdc85524c7db21fa164109d78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;// @ts-check&lt;/code&gt; in a JavaScript file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8afa8edba85ebf100416b76304f95c6450f3141c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; для одного из файлов в компиляции эквивалентно компиляции с &lt;code&gt;--lib es2017.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4933f2a2e7814cc135c9b1388e792cdd66475c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from&lt;/code&gt; clause a module can copy the exports of a given module to the current module without introducing local names.</source>
          <target state="translated">Используя предложение &lt;code&gt;from&lt;/code&gt; , модуль может копировать экспорт данного модуля в текущий модуль без введения локальных имен.</target>
        </trans-unit>
        <trans-unit id="37a797ad92e300fcb869331595d2c4e343d74dfd" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</source>
          <target state="translated">Использование &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; в аннотации типа позволяет войти в модуль и получить доступ к его экспортированному объявлению без его импорта.</target>
        </trans-unit>
        <trans-unit id="72074f269aec1329aae7105fabf958e05d5c07ed" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;instanceof&lt;/code&gt; with classes and union types:</source>
          <target state="translated">Использование &lt;code&gt;instanceof&lt;/code&gt; с классами и типами объединения:</target>
        </trans-unit>
        <trans-unit id="111256c2f12b3cd232c38c44c986dfdd41c62efb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;rootDirs&lt;/code&gt;, you can inform the compiler that there are many &amp;ldquo;virtual&amp;rdquo; directories acting as a single root. This allows the compiler to resolve relative module imports within these &amp;ldquo;virtual&amp;rdquo; directories, as if they were merged in to one directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdc800bcd35f72f5dd0659132e5a66ef820079a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; is quite a drastic approach. It is recommended to use a &lt;code&gt;@ts-ignore&lt;/code&gt; comment instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd8860cf6465e1b2bdf45812f3f39ab68cf98e0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3148c33827558727523c9ea9ec8a97850719dfe8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; to test a variable:</source>
          <target state="translated">Использование &lt;code&gt;typeof&lt;/code&gt; для проверки переменной:</target>
        </trans-unit>
        <trans-unit id="3512c5d8c5a6f92bc7eb3bc3316fb1091e9fc207" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; with union types and &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">Использование &lt;code&gt;typeof&lt;/code&gt; с типами union и &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d577340ac4bb94fb9a7eb6e17e1355af2faee1e" translate="yes" xml:space="preserve">
          <source>Using API</source>
          <target state="translated">Использование API</target>
        </trans-unit>
        <trans-unit id="87b350fddfa272510c3726ee54b4b05350ba043d" translate="yes" xml:space="preserve">
          <source>Using Babel with TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea338f92c90962e364abdd73770a9a8e0a22f76" translate="yes" xml:space="preserve">
          <source>Using Class Types in Generics</source>
          <target state="translated">Использование типов классов в общих чертах</target>
        </trans-unit>
        <trans-unit id="43300137282de05306e305d02f5a4e3a4a8e2d0d" translate="yes" xml:space="preserve">
          <source>Using Command Line Interface</source>
          <target state="translated">Использование интерфейса командной строки</target>
        </trans-unit>
        <trans-unit id="8b74d8a06cce7b65888ba4e8c7818fe0688bd9a8" translate="yes" xml:space="preserve">
          <source>Using Modules</source>
          <target state="translated">Использование модулей</target>
        </trans-unit>
        <trans-unit id="c5dfdd934dc02ab2c210cf3f3003872dcd3d25e6" translate="yes" xml:space="preserve">
          <source>Using Namespaces</source>
          <target state="translated">Использование именных пространств</target>
        </trans-unit>
        <trans-unit id="2340df0448163b853367fed9720dff6a29c60ae1" translate="yes" xml:space="preserve">
          <source>Using NuGet with MSBuild</source>
          <target state="translated">Использование NuGet с MSBuild</target>
        </trans-unit>
        <trans-unit id="547f3d366f6ba6dbebb442ff52e5209ac22bfe3d" translate="yes" xml:space="preserve">
          <source>Using React</source>
          <target state="translated">Использование Реакции</target>
        </trans-unit>
        <trans-unit id="d7491bb32b4d14f757fef9c824559f69f7177e06" translate="yes" xml:space="preserve">
          <source>Using Type Guards, you can easily work with a variable of a union type:</source>
          <target state="translated">С помощью типовой охраны вы можете легко работать с переменной типа союза:</target>
        </trans-unit>
        <trans-unit id="eccd06efc2831f9179398ffcb9ce80cec01c9e63" translate="yes" xml:space="preserve">
          <source>Using Type Parameters in Generic Constraints</source>
          <target state="translated">Использование параметров типа в общих ограничениях</target>
        </trans-unit>
        <trans-unit id="bb7c0204b1637ead9e29a3786a6bee30ee0e9071" translate="yes" xml:space="preserve">
          <source>Using TypeScript in several environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba60f8a349037067c0634dc31a0ac923864cdd8c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">Использование &lt;code&gt;baseUrl&lt;/code&gt; - обычная практика в приложениях, использующих загрузчики модулей AMD, где модули &amp;laquo;развертываются&amp;raquo; в одной папке во время выполнения. Предполагается, что все импортированные модули с не относительными именами относятся к &lt;code&gt;baseUrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb2a81ce273392d8c282cd088fcd0585336e4cfd" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</source>
          <target state="translated">Использование &lt;code&gt;baseUrl&lt;/code&gt; - обычная практика в приложениях, использующих загрузчики модулей AMD, где модули &amp;laquo;развертываются&amp;raquo; в одной папке во время выполнения. Исходные коды этих модулей могут находиться в разных каталогах, но сценарий сборки объединит их все вместе.</target>
        </trans-unit>
        <trans-unit id="01d1846571758e1dd49125e990cfbfc2f7782c55" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;tsconfig.json&lt;/code&gt; which has &lt;code&gt;explainFiles&lt;/code&gt; set to true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e01fea434d511ae7f89196d33d7e8c07fa0679" translate="yes" xml:space="preserve">
          <source>Using a class as an interface</source>
          <target state="translated">Использование класса в качестве интерфейса</target>
        </trans-unit>
        <trans-unit id="b21dff09db83d498fc08fa858a2c6f95c4bc7857" translate="yes" xml:space="preserve">
          <source>Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:</source>
          <target state="translated">Использовать перепись просто:просто получите доступ к любому члену как к свойству из самого переписящего списка и объявите типы,используя имя переписящего списка:</target>
        </trans-unit>
        <trans-unit id="e8cff08e29703580b7ac86809f0f79615642a204" translate="yes" xml:space="preserve">
          <source>Using npm</source>
          <target state="translated">Используя npm</target>
        </trans-unit>
        <trans-unit id="f97748b0bee558e2605da416afdbef74fd01695b" translate="yes" xml:space="preserve">
          <source>Using other JSX frameworks</source>
          <target state="translated">Использование других JSX-фреймворков</target>
        </trans-unit>
        <trans-unit id="5c78cf487464fa0e7c06524cc2aed76314129a78" translate="yes" xml:space="preserve">
          <source>Using target &lt;code&gt;--target ES2016&lt;/code&gt; will instruct the compiler not to transform ES2016-specific features, e.g. &lt;code&gt;**&lt;/code&gt; operator.</source>
          <target state="translated">Использование target &lt;code&gt;--target ES2016&lt;/code&gt; проинструктирует компилятор не преобразовывать специфичные для ES2016 функции, например оператор &lt;code&gt;**&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bbd5627cb0ada9bd95ef8d96473ec05f861c62" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property</source>
          <target state="translated">Использование свойства &lt;code&gt;&quot;files&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd019ddcfa9a356cc6a71911adc51d98cc08a82d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties</source>
          <target state="translated">Использование свойств &lt;code&gt;&quot;include&quot;&lt;/code&gt; и &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">Использование оператора &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f1886e62dc25a8ce4c42a8a5cea86b655977fa4" translate="yes" xml:space="preserve">
          <source>Using the CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd12de5962e5ab568b3c5a067da105ee87fe5e16" translate="yes" xml:space="preserve">
          <source>Using this TSConfig:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05695053496c73d09b9080abbb8ddbcec5718d22" translate="yes" xml:space="preserve">
          <source>Using this ability, &lt;code&gt;lib.d.ts&lt;/code&gt; now has a new &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; type. This type strips &lt;code&gt;?&lt;/code&gt; modifiers from all properties of &lt;code&gt;T&lt;/code&gt;, thus making all properties required.</source>
          <target state="translated">Используя эту возможность, &lt;code&gt;lib.d.ts&lt;/code&gt; теперь имеет новый тип &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; . Это типа полоски &lt;code&gt;?&lt;/code&gt; модификаторы из всех свойств &lt;code&gt;T&lt;/code&gt; , что делает все свойства обязательными.</target>
        </trans-unit>
        <trans-unit id="6f3cf80ca63760070e6103046db8653a28ce64e1" translate="yes" xml:space="preserve">
          <source>Using tsconfig.json</source>
          <target state="translated">Используя tsconfig.json</target>
        </trans-unit>
        <trans-unit id="e3ff1e8a9c36f6f4750c05884c5f542d5a46249b" translate="yes" xml:space="preserve">
          <source>Using type predicates</source>
          <target state="translated">Использование типовых предикатов</target>
        </trans-unit>
        <trans-unit id="3601427971630988ad2755ef28a7717d757f3df8" translate="yes" xml:space="preserve">
          <source>Using with &lt;code&gt;export =&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;</source>
          <target state="translated">Использование с &lt;code&gt;export =&lt;/code&gt; или &lt;code&gt;import&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">Типы полезности</target>
        </trans-unit>
        <trans-unit id="9f89751a678d7643787dbd16a9f2d25d5880c644" translate="yes" xml:space="preserve">
          <source>VS Code has the ability for a extension to &lt;a href=&quot;https://code.visualstudio.com/api/references/contribution-points#contributes.typescriptServerPlugins&quot;&gt;automatically include language service plugins&lt;/a&gt;, and so you may have some running in your editor without needing to define them in your &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdf32ce970b80477ef67d464ba5d9d15cfb327c" translate="yes" xml:space="preserve">
          <source>Validation.ts</source>
          <target state="translated">Validation.ts</target>
        </trans-unit>
        <trans-unit id="524163f0faa0530bac2b1baaeb887189c9c73216" translate="yes" xml:space="preserve">
          <source>Validators in a single file</source>
          <target state="translated">Валидаторы в одном файле</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5a0535139a31a774a3c9068d34adc7058d5bf642" translate="yes" xml:space="preserve">
          <source>Value of &lt;em&gt;baseUrl&lt;/em&gt; is determined as either:</source>
          <target state="translated">Значение &lt;em&gt;baseUrl&lt;/em&gt; определяется как:</target>
        </trans-unit>
        <trans-unit id="577084450a5e984b5f6966940c5dcc148307a726" translate="yes" xml:space="preserve">
          <source>Value-based elements</source>
          <target state="translated">Основанные на стоимости элементы</target>
        </trans-unit>
        <trans-unit id="3f2f78c89fa82d18f5843ae8eee30d072a82336b" translate="yes" xml:space="preserve">
          <source>Value-based elements are simply looked up by identifiers that are in scope.</source>
          <target state="translated">Элементы,основанные на значении,просто просматриваются по идентификаторам,которые находятся в области видимости.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="d79ccf393d6a199b4ad9ea5944ca607bfd113cf4" translate="yes" xml:space="preserve">
          <source>Var-args parameter declaration inferred from use of &lt;code&gt;arguments&lt;/code&gt;</source>
          <target state="translated">Объявление параметра var-args, полученное в результате использования &lt;code&gt;arguments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="5ae56dde19ee92722af581b79a15e413c188460b" translate="yes" xml:space="preserve">
          <source>Variable Declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532e17316f9909fba79f94428471eb6888d1b255" translate="yes" xml:space="preserve">
          <source>Variable Declarations</source>
          <target state="translated">Переменные декларации</target>
        </trans-unit>
        <trans-unit id="b3912d587e9569bb7bfd495613a05ef2130c8e37" translate="yes" xml:space="preserve">
          <source>Variable capturing quirks</source>
          <target state="translated">Переменные причуды захвата</target>
        </trans-unit>
        <trans-unit id="7c09718bb5da0232e2044986eb3a280f493f26a9" translate="yes" xml:space="preserve">
          <source>Variables declared in a &lt;code&gt;catch&lt;/code&gt; clause also have similar scoping rules.</source>
          <target state="translated">Переменные, объявленные в предложении &lt;code&gt;catch&lt;/code&gt; , также имеют аналогичные правила области видимости.</target>
        </trans-unit>
        <trans-unit id="b11bd74b68068c8cda414d69c145cdd12377e1bb" translate="yes" xml:space="preserve">
          <source>Version selection with &lt;code&gt;typesVersions&lt;/code&gt;</source>
          <target state="translated">Выбор версии с &lt;code&gt;typesVersions&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4133624045854a306b02e62768cbf604af93f40f" translate="yes" xml:space="preserve">
          <source>Via npm (the Node.js package manager)</source>
          <target state="translated">Через npm (менеджер пакетов Node.js)</target>
        </trans-unit>
        <trans-unit id="bbef03a29ac970d4beb2f168015277f559e746e0" translate="yes" xml:space="preserve">
          <source>Virtual Directories with &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">Виртуальные &lt;code&gt;rootDirs&lt;/code&gt; с rootDirs</target>
        </trans-unit>
        <trans-unit id="fd7f9c3ff1ebf06a17bf0502aaa043bb8f017fe6" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 and 2015</source>
          <target state="translated">Визуальная студия 2013 и 2015</target>
        </trans-unit>
        <trans-unit id="023fa801554be0ffd9cb5b6327c0e269a7154d1a" translate="yes" xml:space="preserve">
          <source>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2015 и Visual Studio 2013 с обновлением 2 по умолчанию включают TypeScript. Если вы не установили TypeScript с Visual Studio, вы все равно можете &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;его скачать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353b01045c518e21b3e08d0cee10940ef65c683f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2017 и Visual Studio 2015 с обновлением 3 по умолчанию включают TypeScript. Если вы не установили TypeScript с Visual Studio, вы все равно можете &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;его скачать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bd86a16fcf22eb738bf2f6614ab69242ef036b" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studio Code</target>
        </trans-unit>
        <trans-unit id="a54600c66809939b059f9682e260da90c5cc8595" translate="yes" xml:space="preserve">
          <source>Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.</source>
          <target state="translated">Visual Studio должна начать установку gulp и del сразу после сохранения файла.Если нет,щелкните правой кнопкой мыши на package.json,а затем на Restore Packages.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="1e2aae0cdb6f3a79d62e669c768545f8953beef6" translate="yes" xml:space="preserve">
          <source>Watch Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369e965336691b4254b406f11997b3fb8754eafe" translate="yes" xml:space="preserve">
          <source>Watchify</source>
          <target state="translated">Watchify</target>
        </trans-unit>
        <trans-unit id="4306cbf1196af02448fb51c54f07ce1e5c41ddbb" translate="yes" xml:space="preserve">
          <source>Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.</source>
          <target state="translated">Watchify запускает gulp и поддерживает его в рабочем состоянии,инкрементально компилируя каждый раз,когда вы сохраняете файл.Это позволяет сохранить цикл редактирования и обновления в браузере.</target>
        </trans-unit>
        <trans-unit id="2e4ac287a7b8a6ec87dd3885f171fdb1cb26939c" translate="yes" xml:space="preserve">
          <source>Watchify, Babel, and Uglify</source>
          <target state="translated">Смотри,Вавель и возвышай.</target>
        </trans-unit>
        <trans-unit id="f89058c451cdea76e04b5f0c00e5ff23bd62a1b8" translate="yes" xml:space="preserve">
          <source>We added two overload signatures to &lt;code&gt;myCoolFunction&lt;/code&gt;. The first checks states that &lt;code&gt;myCoolFunction&lt;/code&gt; takes a function (which takes a &lt;code&gt;number&lt;/code&gt;), and then a list of &lt;code&gt;number&lt;/code&gt;s. The second one says that it will take a function as well, and then uses a rest parameter (&lt;code&gt;...nums&lt;/code&gt;) to state that any number of arguments after that need to be &lt;code&gt;number&lt;/code&gt;s.</source>
          <target state="translated">Мы добавили две сигнатуры перегрузки в &lt;code&gt;myCoolFunction&lt;/code&gt; . Первая проверка утверждает, что &lt;code&gt;myCoolFunction&lt;/code&gt; принимает функцию (которая принимает &lt;code&gt;number&lt;/code&gt; ), а затем список &lt;code&gt;number&lt;/code&gt; s. Второй говорит, что он также примет функцию, а затем использует параметр rest ( &lt;code&gt;...nums&lt;/code&gt; ), чтобы указать, что любое количество аргументов после этого должно быть &lt;code&gt;number&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="906c596e0e9e46a347b462739c927291c09ad640" translate="yes" xml:space="preserve">
          <source>We also disable the project properties page when you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file. This means that all configuration changes have to be made in the &lt;code&gt;tsconfig.json&lt;/code&gt; file itself.</source>
          <target state="translated">Мы также отключаем страницу свойств проекта при добавлении файла &lt;code&gt;tsconfig.json&lt;/code&gt; . Это означает, что все изменения конфигурации необходимо вносить в &lt;code&gt;tsconfig.json&lt;/code&gt; файл tsconfig.json .</target>
        </trans-unit>
        <trans-unit id="862f52cc171b96bf071e122091285af320650575" translate="yes" xml:space="preserve">
          <source>We also have an &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.epub&quot;&gt;epub&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/assets/typescript-handbook-beta.pdf&quot;&gt;pdf&lt;/a&gt; version of the Handbook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce7ec51558a4620670481cd3447782aedb45ad7" translate="yes" xml:space="preserve">
          <source>We also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let&amp;rsquo;s modify &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Нам также нужен TypeScript target ES2015. Затем Babel создаст ES5 из кода ES2015, который генерирует TypeScript. Изменим &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb158a631eeb5215d7f9b41d49e937425bf4888b" translate="yes" xml:space="preserve">
          <source>We are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;Declaration Reference&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca6da16584407722c05c582e9312d4b12506c7e" translate="yes" xml:space="preserve">
          <source>We assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Мы предполагаем, что вы уже используете &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; с &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dccbace9aee63165dc6770bfacb34962fe498a76" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">Мы называем объявления, которые не определяют реализацию, &amp;laquo;окружающим&amp;raquo;. Обычно они определены в файлах &lt;code&gt;.d.ts&lt;/code&gt; . Если вы знакомы с C / C ++, вы можете рассматривать их как файлы &lt;code&gt;.h&lt;/code&gt; . Давайте посмотрим на несколько примеров.</target>
        </trans-unit>
        <trans-unit id="92c076044fe3078a3a2d956ae660fa0b4723354a" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically, these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">Мы называем объявления, которые не определяют реализацию, &amp;laquo;окружающим&amp;raquo;. Обычно они определены в файлах &lt;code&gt;.d.ts&lt;/code&gt; . Если вы знакомы с C / C ++, вы можете рассматривать их как файлы &lt;code&gt;.h&lt;/code&gt; . Давайте посмотрим на несколько примеров.</target>
        </trans-unit>
        <trans-unit id="d7554b9ee0145ef5796d9b34e5b993a1e04de397" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; to log to the console.</source>
          <target state="translated">Мы вызвали &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; войти в консоль.</target>
        </trans-unit>
        <trans-unit id="5dedc9b8f5d0ca8dda8092dbf79a3b7121e6221e" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; so that Browserify will run the &lt;code&gt;bundle&lt;/code&gt; function every time one of your TypeScript files changes.</source>
          <target state="translated">Мы вызвали &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; так что Browserify будет запускать функцию &lt;code&gt;bundle&lt;/code&gt; каждый раз при изменении одного из ваших файлов TypeScript.</target>
        </trans-unit>
        <trans-unit id="d78c8a7db971a258629029d93d5ac32c8f9a6480" translate="yes" xml:space="preserve">
          <source>We can add additional members to an &lt;code&gt;interface&lt;/code&gt; with another &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="translated">Мы можем добавить дополнительные члены в &lt;code&gt;interface&lt;/code&gt; с другим объявлением &lt;code&gt;interface&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72346222530ba2a9b0966af45f7d0245b45ebadb" translate="yes" xml:space="preserve">
          <source>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</source>
          <target state="translated">Мы можем добавить типы к каждому из параметров,а затем в саму функцию для добавления типа возврата.TypeScript может вычислить тип возвращаемого параметра,посмотрев на операторы возврата,поэтому во многих случаях мы также можем опционально оставить эту опцию выключенной.</target>
        </trans-unit>
        <trans-unit id="3ffa5dba257543828c847bbd33acb3e1bdc1db72" translate="yes" xml:space="preserve">
          <source>We can also declare a variable inside of a function:</source>
          <target state="translated">Мы также можем объявить переменную внутри функции:</target>
        </trans-unit>
        <trans-unit id="661d963b4beb85aa27dfba66adb8817f5f2d18c5" translate="yes" xml:space="preserve">
          <source>We can also explicitly give type information to the function&amp;rsquo;s argument to override any contextual type:</source>
          <target state="translated">Мы также можем явно предоставить информацию о типе аргументу функции, чтобы переопределить любой контекстный тип:</target>
        </trans-unit>
        <trans-unit id="eaa8774bff1b83856163130bd5db5fa1d1e6c687" translate="yes" xml:space="preserve">
          <source>We can also have a type alias refer to itself in a property:</source>
          <target state="translated">Мы также можем иметь псевдоним типа ссылаться на себя в собственности:</target>
        </trans-unit>
        <trans-unit id="a869a9aafbfef91521e95e5db94bb387cae93e3a" translate="yes" xml:space="preserve">
          <source>We can also write the generic type as a call signature of an object literal type:</source>
          <target state="translated">Мы также можем написать общий тип как сигнатуру вызова объектного буквального типа:</target>
        </trans-unit>
        <trans-unit id="658e04fc9fb0e75106204a24f2c9d06bdf8f78c2" translate="yes" xml:space="preserve">
          <source>We can alternatively write the sample example this way:</source>
          <target state="translated">Альтернативно мы можем написать пример таким образом:</target>
        </trans-unit>
        <trans-unit id="ff36204ad2dc388ad3938b7f629d5c14ff6e7faf" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@configurable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Мы можем определить декоратор &lt;code&gt;@configurable&lt;/code&gt; , используя следующее объявление функции:</target>
        </trans-unit>
        <trans-unit id="82bc383c0b279737360de0b5872e4eaf53cabffa" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@enumerable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Мы можем определить декоратор &lt;code&gt;@enumerable&lt;/code&gt; , используя следующее объявление функции:</target>
        </trans-unit>
        <trans-unit id="7089db4e18a0f27d1d43d048ff6a50fbd3dce944" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@sealed&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">Мы можем определить декоратор &lt;code&gt;@sealed&lt;/code&gt; , используя следующее объявление функции:</target>
        </trans-unit>
        <trans-unit id="9b791fa8333e00451d101fd617a6f57b865394fd" translate="yes" xml:space="preserve">
          <source>We can extend the existing module like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d89086425b5ee284135e15deb90e23ed2590c7" translate="yes" xml:space="preserve">
          <source>We can fix this by making sure the function is bound to the correct &lt;code&gt;this&lt;/code&gt; before we return the function to be used later. This way, regardless of how it&amp;rsquo;s later used, it will still be able to see the original &lt;code&gt;deck&lt;/code&gt; object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the &lt;code&gt;this&lt;/code&gt; where the function is created rather than where it is invoked:</source>
          <target state="translated">Мы можем исправить это, убедившись, что функция привязана к правильному &lt;code&gt;this&lt;/code&gt; , прежде чем мы вернем функцию, которая будет использоваться позже. Таким образом, независимо от того, как он будет использоваться позже, он все равно сможет видеть исходный объект &lt;code&gt;deck&lt;/code&gt; . Для этого мы изменим выражение функции, чтобы использовать синтаксис стрелки ECMAScript 6. Стрелочные функции фиксируют &lt;code&gt;this&lt;/code&gt; , где функция создается, а не где она вызывается:</target>
        </trans-unit>
        <trans-unit id="c6ea0d2b6b5f45da1e1324a08cfc0e11b786897c" translate="yes" xml:space="preserve">
          <source>We can see this in action in the following example:</source>
          <target state="translated">Это можно увидеть в действии в следующем примере:</target>
        </trans-unit>
        <trans-unit id="65140ca83fcc5d0530859c1beb185464ff42f37a" translate="yes" xml:space="preserve">
          <source>We can see this more clearly in this example:</source>
          <target state="translated">Мы видим это более четко в этом примере:</target>
        </trans-unit>
        <trans-unit id="ee21326f232b62bacd8134f20c57de98fb355244" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@format&lt;/code&gt; decorator and &lt;code&gt;getFormat&lt;/code&gt; functions using the following function declarations:</source>
          <target state="translated">Затем мы можем определить &lt;code&gt;@format&lt;/code&gt; декоратора и &lt;code&gt;getFormat&lt;/code&gt; функции , используя следующие объявления функций:</target>
        </trans-unit>
        <trans-unit id="bd3c3bda45ff67c029de2e2368aec01e7ef3a4eb" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@required&lt;/code&gt; and &lt;code&gt;@validate&lt;/code&gt; decorators using the following function declarations:</source>
          <target state="translated">Затем мы можем определить декораторы &lt;code&gt;@required&lt;/code&gt; и &lt;code&gt;@validate&lt;/code&gt; , используя следующие объявления функций:</target>
        </trans-unit>
        <trans-unit id="db549ad2d4eebb5605913a990e51c4ee29c07c32" translate="yes" xml:space="preserve">
          <source>We can use this information to record metadata about the property, as in the following example:</source>
          <target state="translated">Мы можем использовать эту информацию для записи метаданных о свойстве,как в следующем примере:</target>
        </trans-unit>
        <trans-unit id="ea01d2c138e3b5218d8e1d52564f033747bdd0ce" translate="yes" xml:space="preserve">
          <source>We can write a decorator factory in the following fashion:</source>
          <target state="translated">Мы можем написать фабрику декораторов следующим образом:</target>
        </trans-unit>
        <trans-unit id="171a94c1fd6a31b533d269529646e906879fde4e" translate="yes" xml:space="preserve">
          <source>We can write the same example again, this time using an interface to describe the requirement of having the &lt;code&gt;label&lt;/code&gt; property that is a string:</source>
          <target state="translated">Мы можем написать тот же пример снова, на этот раз используя интерфейс для описания требования наличия свойства &lt;code&gt;label&lt;/code&gt; , которое является строкой:</target>
        </trans-unit>
        <trans-unit id="d0f35bfcf99e7f68867547c0414c1be9551ec721" translate="yes" xml:space="preserve">
          <source>We could also add a namespaced type to a class:</source>
          <target state="translated">Мы также можем добавить в класс тип с интервалом имен:</target>
        </trans-unit>
        <trans-unit id="f1593c28383f7f19b9f300464de36e13bda32294" translate="yes" xml:space="preserve">
          <source>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</source>
          <target state="translated">Мы могли бы также использовать другое имя для общего параметра типа,при условии,что количество переменных типа и то,как они используются,выстраиваются в линию.</target>
        </trans-unit>
        <trans-unit id="81879f8730c017d5576f5e7bef1f5b5dd6185843" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using this flag in a modern codebase, you can suppress one-off cases where you need it using &lt;code&gt;// @ts-ignore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae12050685d86d62a3f9d2765b3b1a3a61021e1" translate="yes" xml:space="preserve">
          <source>We frequently see the question &amp;ldquo;Should I learn JavaScript or TypeScript?&amp;ldquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a79655a0f6dc78edf29c467dcf807b7ee04905" translate="yes" xml:space="preserve">
          <source>We just imported our &lt;code&gt;Hello&lt;/code&gt; component into &lt;code&gt;index.tsx&lt;/code&gt;. Notice that unlike with &lt;code&gt;&quot;react&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt;, we used a &lt;em&gt;relative path&lt;/em&gt; to &lt;code&gt;Hello.tsx&lt;/code&gt; - this is important. If we hadn&amp;rsquo;t, TypeScript would&amp;rsquo;ve instead tried looking in our &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">Мы только что импортировали наш компонент &lt;code&gt;Hello&lt;/code&gt; в &lt;code&gt;index.tsx&lt;/code&gt; . Обратите внимание, что в отличие от &lt;code&gt;&quot;react&quot;&lt;/code&gt; или &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt; , мы использовали &lt;em&gt;относительный путь&lt;/em&gt; к &lt;code&gt;Hello.tsx&lt;/code&gt; - это важно. Если бы мы этого не сделали, TypeScript вместо этого попытался бы поискать в нашей папке &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fbc60a8f3964107caa151501b90a1aec6061763" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content &amp;ndash; e.g. from the user &amp;ndash; or we may want to intentionally accept all values in our API. In these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it the &lt;code&gt;unknown&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b6c237e5c56a0727a6cedbb2962b0899558457" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">Нам может потребоваться описать тип переменных, которые мы не знаем, когда пишем приложение. Эти значения могут поступать из динамического содержимого, например, от пользователя или сторонней библиотеки. В этих случаях мы хотим отказаться от проверки типов и позволить значениям проходить проверки во время компиляции. Для этого мы помечаем их &lt;code&gt;any&lt;/code&gt; типом:</target>
        </trans-unit>
        <trans-unit id="7e0b762a7d5b6b35f90cd8500631ccf9ab22b8c1" translate="yes" xml:space="preserve">
          <source>We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;NPM Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Нам нужно настроить NPM, чтобы можно было загружать пакеты JavaScript. Щелкните проект правой кнопкой мыши и выберите &amp;laquo; &lt;strong&gt;Новый элемент&amp;raquo;&lt;/strong&gt; . Затем выберите &lt;strong&gt;файл конфигурации NPM&lt;/strong&gt; и используйте имя по умолчанию &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc466c22e7712a5cff2da5cf89c0cc81b64e2a7" translate="yes" xml:space="preserve">
          <source>We owe a big thanks to GitHub user &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay&lt;/a&gt; who took the initiative to create a &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;proof-of-concept&lt;/a&gt; and iterated to provide us with with &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;the current version&lt;/a&gt;.</source>
          <target state="translated">Мы &lt;a href=&quot;https://github.com/jwbay&quot;&gt;выражаем огромную&lt;/a&gt; благодарность пользователю GitHub @jwbay, который проявил инициативу по созданию &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;доказательства концепции&lt;/a&gt; и повторил попытку , чтобы предоставить нам &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;текущую версию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="894e0a020d31c47096948e05d4d7e1a77b0f6785" translate="yes" xml:space="preserve">
          <source>We owe a large thanks to community members &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; and &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; for implementing this feature! For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;check out their pull request&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;the nullish coalescing proposal repository&lt;/a&gt;.</source>
          <target state="translated">Мы очень благодарны членам сообщества &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Венлу Вангу&lt;/a&gt; и &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Тициану Черникове Драгомиру&lt;/a&gt; за реализацию этой функции! Для получения более подробной информации, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;проверить их запрос тянуть&lt;/a&gt; и &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;в nullish хранилище коалесцирующего предложения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd7c75518818af1c60b72b48de1120f76c7411f" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;#strict&quot;&gt;compiler option &lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; to opt-in to every possible improvement as they are built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027ffea53cb8344a8ca0b02644101c1fc88508e6" translate="yes" xml:space="preserve">
          <source>We said earlier that some languages wouldn&amp;rsquo;t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as &lt;em&gt;static checking&lt;/em&gt;. Determining what&amp;rsquo;s an error and what&amp;rsquo;s not based on the kinds of values being operated on is known as static &lt;em&gt;type&lt;/em&gt; checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be98474a5452e0a16847898535c758700d80e71" translate="yes" xml:space="preserve">
          <source>We say that this version of the &lt;code&gt;identity&lt;/code&gt; function is generic, as it works over a range of types. Unlike using &lt;code&gt;any&lt;/code&gt;, it&amp;rsquo;s also just as precise (ie, it doesn&amp;rsquo;t lose any information) as the first &lt;code&gt;identity&lt;/code&gt; function that used numbers for the argument and return type.</source>
          <target state="translated">Мы говорим, что эта версия функции &lt;code&gt;identity&lt;/code&gt; является общей, так как она работает с рядом типов. В отличие от &lt;code&gt;any&lt;/code&gt; , он также такой же точный (т. Е. Не теряет никакой информации), как первая функция &lt;code&gt;identity&lt;/code&gt; которая использовала числа для аргумента и типа возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="b6da2cbd96b3e75b9187d15de475de9ac9b10faa" translate="yes" xml:space="preserve">
          <source>We strongly encourage users to try the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</source>
          <target state="translated">Мы настоятельно рекомендуем пользователям попробовать &lt;code&gt;useDefineForClassFields&lt;/code&gt; флаг useDefineForClassFields и сообщить об этом в нашей системе отслеживания проблем или в комментариях ниже. Это включает отзывы о сложности принятия флага, чтобы мы могли понять, как мы можем упростить миграцию.</target>
        </trans-unit>
        <trans-unit id="c7a2b84a24b11f7b028b0dbae7870221e6b866b5" translate="yes" xml:space="preserve">
          <source>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</source>
          <target state="translated">Мы понимаем,что тонна монохромного выхода может быть немного трудной для глаз.Цвета могут помочь определить,где сообщение начинается и заканчивается,и эти визуальные подсказки важны,когда выходной сигнал ошибки становится подавляющим.</target>
        </trans-unit>
        <trans-unit id="9c538d5dd6bb04252a1e101d363501930cb1f96c" translate="yes" xml:space="preserve">
          <source>We used a &lt;code&gt;.ts&lt;/code&gt; extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</source>
          <target state="translated">Мы использовали расширение &lt;code&gt;.ts&lt;/code&gt; , но этот код - всего лишь JavaScript. Вы могли скопировать / вставить это прямо из существующего приложения JavaScript.</target>
        </trans-unit>
        <trans-unit id="0e0159d00e8ed5efa3d03297f6ba1361aeceb56f" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;NetworkFromCachedState&lt;/code&gt; to &lt;code&gt;NetworkState&lt;/code&gt;, we need to update &lt;code&gt;logger&lt;/code&gt; as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5123383e9966536bbcb7f101d2b7d8f6a074dca8" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;Triangle&lt;/code&gt; to &lt;code&gt;Shape&lt;/code&gt;, we need to update &lt;code&gt;area&lt;/code&gt; as well:</source>
          <target state="translated">Мы хотели бы, чтобы компилятор сообщал нам, когда мы не охватываем все варианты размеченного объединения. Например, если мы добавим &lt;code&gt;Triangle&lt;/code&gt; к &lt;code&gt;Shape&lt;/code&gt; , нам также нужно обновить &lt;code&gt;area&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c5b24b66e133e695b5340a53b29a9a03a4588c0" translate="yes" xml:space="preserve">
          <source>We wrapped our &lt;code&gt;browserify&lt;/code&gt; instance in a call to &lt;code&gt;watchify&lt;/code&gt;, and then held on to the result.</source>
          <target state="translated">Мы обернули наш экземпляр &lt;code&gt;browserify&lt;/code&gt; в вызов &lt;code&gt;watchify&lt;/code&gt; , а затем задержались на результате.</target>
        </trans-unit>
        <trans-unit id="b6077b883e1d7e622df4d40c8eae3398ce7b9837" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d like to extend a huge thanks to &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; for all the work on this feature. We&amp;rsquo;re grateful for the contribution, and we&amp;rsquo;re sure our users are too!</source>
          <target state="translated">Мы хотели бы выразить огромную благодарность &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Калебу Сандеру&lt;/a&gt; за всю работу над этой функцией. Мы благодарны за вклад, и мы уверены, что наши пользователи тоже!</target>
        </trans-unit>
        <trans-unit id="2955af2348407c162d10bf22c8f15b1a2bc20810" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also need a page to display our &lt;code&gt;Hello&lt;/code&gt; component. Create a file at the root of &lt;code&gt;proj&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt; with the following contents:</source>
          <target state="translated">Нам также понадобится страница для отображения нашего компонента &lt;code&gt;Hello&lt;/code&gt; . Создайте файл в корне &lt;code&gt;proj&lt;/code&gt; именем &lt;code&gt;index.html&lt;/code&gt; со следующим содержанием:</target>
        </trans-unit>
        <trans-unit id="9886aca5459083f9b058f494e9b979c3c4ef1899" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover classes later in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0e5a7f6725b7d626b76e36ae307b3fc402a1e2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss index signatures in a bit, but here we&amp;rsquo;re saying a &lt;code&gt;SquareConfig&lt;/code&gt; can have any number of properties, and as long as they aren&amp;rsquo;t &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;width&lt;/code&gt;, their types don&amp;rsquo;t matter.</source>
          <target state="translated">Мы немного обсудим подписи индекса, но здесь мы говорим, что &lt;code&gt;SquareConfig&lt;/code&gt; может иметь любое количество свойств, и пока они не имеют &lt;code&gt;color&lt;/code&gt; или &lt;code&gt;width&lt;/code&gt; , их типы не имеют значения.</target>
        </trans-unit>
        <trans-unit id="1a2f59b32ace790506f0abdad902dd97d8982882" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first start off with numeric enums, which are probably more familiar if you&amp;rsquo;re coming from other languages. An enum can be defined using the &lt;code&gt;enum&lt;/code&gt; keyword.</source>
          <target state="translated">Сначала мы начнем с числовых перечислений, которые, вероятно, более знакомы, если вы переходите с других языков. Перечисление можно определить с помощью ключевого слова &lt;code&gt;enum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff341e9ebeb5367479b561ddef0d845208be6d6e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll learn more about how classes relate to each other in the Classes chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19448f8bcee986b6f99112a504f95247ef4c159e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start with Watchify to provide background compilation:</source>
          <target state="translated">Мы начнем с Watchify, чтобы обеспечить фоновую компиляцию:</target>
        </trans-unit>
        <trans-unit id="0b37518565138e9254324247a79b02efcfc6deef" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also creating another value that we call the &lt;em&gt;constructor function&lt;/em&gt;. This is the function that is called when we &lt;code&gt;new&lt;/code&gt; up instances of the class. To see what this looks like in practice, let&amp;rsquo;s take a look at the JavaScript created by the above example:</source>
          <target state="translated">Мы также создаем другое значение, которое вызываем &lt;em&gt;функцией конструктора&lt;/em&gt; . Это функция, которая вызывается, когда мы создаем &lt;code&gt;new&lt;/code&gt; экземпляры класса. Чтобы увидеть, как это выглядит на практике, давайте взглянем на JavaScript, созданный в приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="7aff8cf77620ede7bc7d3e8d39158810b0f689b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also including two other utility types as well: &lt;code&gt;Record&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt;.</source>
          <target state="translated">Мы также включаем два других типа утилит: &lt;code&gt;Record&lt;/code&gt; и &lt;code&gt;Pick&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3e9714b389303e76259f45a7e8e4a3371445cb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also introducing a new mode for &lt;code&gt;tsc&lt;/code&gt;, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand in hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">Мы также представляем новый режим для &lt;code&gt;tsc&lt;/code&gt; , флаг &lt;code&gt;--build&lt;/code&gt; , который работает рука об руку со ссылками на проекты, чтобы обеспечить более быструю сборку TypeScript.</target>
        </trans-unit>
        <trans-unit id="0a856c3b5c5d0b1b8b27ac26776fabf8b60ed0f0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve also added support for &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;declaration source maps&lt;/a&gt;. If you enable &lt;code&gt;--declarationMap&lt;/code&gt;, you&amp;rsquo;ll be able to use editor features like &amp;ldquo;Go to Definition&amp;rdquo; and Rename to transparently navigate and edit code across project boundaries in supported editors.</source>
          <target state="translated">Мы также добавили поддержку &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;карт источников объявлений&lt;/a&gt; . Если вы включите &lt;code&gt;--declarationMap&lt;/code&gt; , вы сможете использовать такие функции редактора, как &amp;laquo;Перейти к определению&amp;raquo; и &amp;laquo;Переименовать&amp;raquo;, чтобы прозрачно перемещаться и редактировать код через границы проекта в поддерживаемых редакторах.</target>
        </trans-unit>
        <trans-unit id="f8e13c786c22514d18489b8a515cda5e549982a7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now added a type variable &lt;code&gt;T&lt;/code&gt; to the identity function. This &lt;code&gt;T&lt;/code&gt; allows us to capture the type the user provides (e.g. &lt;code&gt;number&lt;/code&gt;), so that we can use that information later. Here, we use &lt;code&gt;T&lt;/code&gt; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</source>
          <target state="translated">Теперь мы добавили переменную типа &lt;code&gt;T&lt;/code&gt; в функцию идентификации. Этот &lt;code&gt;T&lt;/code&gt; позволяет нам фиксировать тип, который предоставляет пользователь (например, &lt;code&gt;number&lt;/code&gt; ), чтобы мы могли использовать эту информацию позже. Здесь мы снова используем &lt;code&gt;T&lt;/code&gt; в качестве возвращаемого типа. При осмотре мы теперь видим, что для аргумента и типа возвращаемого значения используется один и тот же тип. Это позволяет нам передавать информацию этого типа с одной стороны функции и с другой.</target>
        </trans-unit>
        <trans-unit id="5d422ede737ddc07ca03c94e0a0c10b9d58412d1" translate="yes" xml:space="preserve">
          <source>Weak Type Detection</source>
          <target state="translated">Обнаружение слабых типов</target>
        </trans-unit>
        <trans-unit id="1b5eb8b25701e63a0124e28e65777b9976429161" translate="yes" xml:space="preserve">
          <source>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of &amp;ldquo;the web&amp;rdquo;, starting as a simple network of static pages, and evolving into a platform for rich &lt;em&gt;applications&lt;/em&gt; of all kinds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="c81830d8b730ad2fae90f8032a7776f8b0e39714" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;awesome-typescript-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="translated">Интеграция с Webpack довольно проста. Вы можете использовать &lt;code&gt;awesome-typescript-loader&lt;/code&gt; , загрузчик TypeScript, в сочетании с &lt;code&gt;source-map-loader&lt;/code&gt; для упрощения отладки. Просто беги</target>
        </trans-unit>
        <trans-unit id="ac0ca563dd0d3261e9ed866ed6e122036a96d12c" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;ts-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f41141dbd3f1cbecbaad98cf3de708ecdf41b9b" translate="yes" xml:space="preserve">
          <source>Webpack is a tool that will bundle your code and optionally all of its dependencies into a single &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Webpack - это инструмент, который объединит ваш код и, при необходимости, все его зависимости в один файл &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7901ed28bacfe5bf0d524efc7190b1e5a54f7326" translate="yes" xml:space="preserve">
          <source>Webpack will eventually generate the &lt;code&gt;dist&lt;/code&gt; directory for us.</source>
          <target state="translated">Webpack в конечном итоге сгенерирует для нас каталог &lt;code&gt;dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fad9fe5b80f48cd956db4822a16674a29a1b973" translate="yes" xml:space="preserve">
          <source>Websites are made up of HTML and/or XML documents. These documents are static, they do not change. The &lt;em&gt;Document Object Model (DOM)&lt;/em&gt; is a programming interface implemented by browsers in order to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it in order to make dynamic websites even easier to develop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39db66a63832d879643a9c74c80d078ce3a9abfa" translate="yes" xml:space="preserve">
          <source>Weeding out Errors</source>
          <target state="translated">Устранение ошибок</target>
        </trans-unit>
        <trans-unit id="e97ac55d12c65e8ccc90515dafcb06d1bbf38e6c" translate="yes" xml:space="preserve">
          <source>Well-known Symbols</source>
          <target state="translated">Известные символы</target>
        </trans-unit>
        <trans-unit id="a62da38185ade2ed494ca3c34e28aed2e07c4954" translate="yes" xml:space="preserve">
          <source>What does this affect?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b453e4894b5221614db3412183873d5d5a3d6fc9" translate="yes" xml:space="preserve">
          <source>What if we want to also log the length of the argument &lt;code&gt;arg&lt;/code&gt; to the console with each call? We might be tempted to write this:</source>
          <target state="translated">Что, если мы хотим также записывать длину аргумента &lt;code&gt;arg&lt;/code&gt; в консоль при каждом вызове? У нас может возникнуть соблазн написать это:</target>
        </trans-unit>
        <trans-unit id="45fda52dea40ed49a1af31b0fc06e0a0f19b734d" translate="yes" xml:space="preserve">
          <source>What if we&amp;rsquo;re not running in TypeScript 3.1 in this example? Well, if none of the fields in &lt;code&gt;typesVersions&lt;/code&gt; get matched, TypeScript falls back to the &lt;code&gt;types&lt;/code&gt; field, so here TypeScript 3.0 and earlier will be redirected to &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">Что, если в этом примере мы не используем TypeScript 3.1? Что ж, если ни одно из полей в &lt;code&gt;typesVersions&lt;/code&gt; не соответствует, TypeScript возвращается к полю &lt;code&gt;types&lt;/code&gt; , поэтому здесь TypeScript 3.0 и более ранние версии будут перенаправлены в &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e305f4bbf1ed90aa73345044f0a492bd2c96f31" translate="yes" xml:space="preserve">
          <source>What is JavaScript? A Brief History</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6349e923db276196bacfe2471e600626fa732ab4" translate="yes" xml:space="preserve">
          <source>What is a Project Reference?</source>
          <target state="translated">Что такое эталон проекта?</target>
        </trans-unit>
        <trans-unit id="549e8639ff7e2907dd68d7e827ef96b82a333747" translate="yes" xml:space="preserve">
          <source>What is a tsconfig.json</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59beb27768eff0de85903d679ab600335df3cfc4" translate="yes" xml:space="preserve">
          <source>What is supported in my version of Visual Studio?</source>
          <target state="translated">Что поддерживается в моей версии Visual Studio?</target>
        </trans-unit>
        <trans-unit id="2aab3d2a4f95d11fe606c90edd3b7781f2071f7b" translate="yes" xml:space="preserve">
          <source>What should you look for?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebc3fc3da860ce67243a9d91e606b84eda07cf2" translate="yes" xml:space="preserve">
          <source>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</source>
          <target state="translated">Все эти две вещи сводятся к тому,что смешивание свойств с аксессуарами будет вызывать проблемы,как и повторное раскрытие свойств без инициализаторов.</target>
        </trans-unit>
        <trans-unit id="d5327b36090577d46345fd56199590737f1090b4" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New</source>
          <target state="translated">Что нового</target>
        </trans-unit>
        <trans-unit id="95f6717c2192f745e156c7402e0db762fe4e4e69" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--strictNullChecks&lt;/code&gt; is off, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are similar to &lt;code&gt;never&lt;/code&gt;: assignable to most types, most types are not assignable to them. They are assignable to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b836451dc899cfda6806c9a3b2b05b44b6f4cc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--strictNullChecks&lt;/code&gt; is on, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; behave more like &lt;code&gt;void&lt;/code&gt;: not assignable to or from anything, except for &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, and &lt;code&gt;void&lt;/code&gt; (&lt;code&gt;undefined&lt;/code&gt; is always assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19f846e4de2aa633d8a22d53f27123620724843" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@sealed&lt;/code&gt; is executed, it will seal both the constructor and its prototype.</source>
          <target state="translated">Когда &lt;code&gt;@sealed&lt;/code&gt; , он запечатывает и конструктор, и его прототип.</target>
        </trans-unit>
        <trans-unit id="de89d2eba1215f58d1dd8899c9e7c9afa82b2bb8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;declaration&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, running the compiler with this TypeScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d97be1b8d72d15598e3c754e9841feedf07996a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;downlevelIteration&lt;/code&gt; is enabled, TypeScript will use a helper function that checks for a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation (either native or polyfill). If this implementation is missing, you&amp;rsquo;ll fall back to index-based iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030f0dfcec29d2c5288e91c918593dc6c753cec6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;localStorage.volume&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, the page will set the volume to &lt;code&gt;0.5&lt;/code&gt; which is unintended. &lt;code&gt;??&lt;/code&gt; avoids some unintended behavior from &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; being treated as falsy values.</source>
          <target state="translated">Если для &lt;code&gt;localStorage.volume&lt;/code&gt; установлено значение &lt;code&gt;0&lt;/code&gt; , на странице будет установлено значение &lt;code&gt;0.5&lt;/code&gt; что является непреднамеренным. &lt;code&gt;??&lt;/code&gt; позволяет избежать непреднамеренного поведения из-за того, что &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; обрабатываются как ложные значения.</target>
        </trans-unit>
        <trans-unit id="f8cdcfeef8004c101022b373d173e5e67f254a91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outFile&lt;/code&gt; is used, the build information file&amp;rsquo;s name will be based on the output file&amp;rsquo;s name. As an example, if our output JavaScript file is &lt;code&gt;./output/foo.js&lt;/code&gt;, then under the &lt;code&gt;--incremental&lt;/code&gt; flag, TypeScript will generate the file &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt;. As above, this can be controlled with the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">Когда используется &lt;code&gt;outFile&lt;/code&gt; , имя файла информации о сборке будет основано на имени выходного файла. Например, если наш выходной файл JavaScript - &lt;code&gt;./output/foo.js&lt;/code&gt; , то с флагом &lt;code&gt;--incremental&lt;/code&gt; TypeScript сгенерирует файл &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt; . Как и выше, этим можно управлять с &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; флага --tsBuildInfoFile .</target>
        </trans-unit>
        <trans-unit id="a6b4ab4c97cea9690c0e23272de9b69e351862d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;removeComments&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85b0524d36ff619229702608a55d6837ddd69c1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are effectively ignored by the language. This can lead to unexpected errors at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f13327933b18823e01adeaea42756b80600b7ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; have their own distinct types and you&amp;rsquo;ll get a type error if you try to use them where a concrete value is expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f520248f652ff2167281b35bfd68546d3ba6914b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is enabled, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; get their own types called &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Whenever anything is &lt;em&gt;possibly&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;, you can use a union type with the original type. So for instance, if something could be a &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you&amp;rsquo;d write the type out as &lt;code&gt;number | null&lt;/code&gt;.</source>
          <target state="translated">Когда включена &lt;code&gt;strictNullChecks&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; получают свои собственные типы, называемые &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; соответственно. Когда что-либо, &lt;em&gt;возможно, имеет значение &lt;/em&gt; &lt;code&gt;null&lt;/code&gt; , вы можете использовать тип объединения с исходным типом. Так, например, если что-то может быть &lt;code&gt;number&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; , вы должны записать тип как &lt;code&gt;number | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bbf9f8fcdd1b99e48e1893b7a75fd930f81e35d" translate="yes" xml:space="preserve">
          <source>When Javascript classes extend a generic base class, there is nowhere to specify what the type parameter should be. The &lt;code&gt;@extends&lt;/code&gt; tag provides a place for that type parameter:</source>
          <target state="translated">Когда классы Javascript расширяют общий базовый класс, негде указать, каким должен быть параметр типа. &lt;code&gt;@extends&lt;/code&gt; тег предоставляет место для этого параметра типа:</target>
        </trans-unit>
        <trans-unit id="04de13704216a9db06f5ffa39317b375f05787e0" translate="yes" xml:space="preserve">
          <source>When TypeScript compiles files, it keeps the same directory structure in the output directory as exists in the input directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d424ff2d89383aadc098c9555b347abf8e1516" translate="yes" xml:space="preserve">
          <source>When TypeScript opens a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8c176e99ff6882e6b0d9b7305bf530d1b1a588" translate="yes" xml:space="preserve">
          <source>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</source>
          <target state="translated">Когда вызов функции включает в качестве последнего аргумента выражение типа кортежа в виде спреда,выражение в виде спреда соответствует последовательности дискретных аргументов типов элементов кортежа.</target>
        </trans-unit>
        <trans-unit id="9c33bce0f75302f0d6e1a7e860836fefe8f472c2" translate="yes" xml:space="preserve">
          <source>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</source>
          <target state="translated">Когда функция имеет параметр покоя,она рассматривается как бесконечный ряд дополнительных параметров.</target>
        </trans-unit>
        <trans-unit id="fd713400776c7d40925b3ed1ecacc3ed2345c946" translate="yes" xml:space="preserve">
          <source>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</source>
          <target state="translated">Когда функция перегружена,каждая перегрузка в типе источника должна быть сопоставлена с совместимой сигнатурой на целевом типе.Это обеспечивает возможность вызова целевой функции во всех тех же ситуациях,что и функции источника.</target>
        </trans-unit>
        <trans-unit id="5607cf867fc582d411cd22588c4ee37feb393557" translate="yes" xml:space="preserve">
          <source>When a member is marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="translated">Когда член помечен как &lt;code&gt;private&lt;/code&gt; , к нему нельзя получить доступ извне содержащего его класса. Например:</target>
        </trans-unit>
        <trans-unit id="584d36e45bec249f6c98a43c17d122b7fd42bae9" translate="yes" xml:space="preserve">
          <source>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:</source>
          <target state="translated">Когда параметр rest имеет тип кортежа,тип кортежа разворачивается в последовательность дискретных параметров.Например,следующие два объявления эквивалентны:</target>
        </trans-unit>
        <trans-unit id="564e9e469a41360585db50dc07312fe0e7a957af" translate="yes" xml:space="preserve">
          <source>When a type inference is made from several expressions, the types of those expressions are used to calculate a &amp;ldquo;best common type&amp;rdquo;. For example,</source>
          <target state="translated">Когда вывод типа производится из нескольких выражений, типы этих выражений используются для вычисления &amp;laquo;наилучшего общего типа&amp;raquo;. Например,</target>
        </trans-unit>
        <trans-unit id="5b460fc1b0afb2a95c11c3857f5c3f8edcb0a57d" translate="yes" xml:space="preserve">
          <source>When a variable is declared using &lt;code&gt;let&lt;/code&gt;, it uses what some call &lt;em&gt;lexical-scoping&lt;/em&gt; or &lt;em&gt;block-scoping&lt;/em&gt;. Unlike variables declared with &lt;code&gt;var&lt;/code&gt; whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or &lt;code&gt;for&lt;/code&gt;-loop.</source>
          <target state="translated">Когда переменная объявляется с помощью &lt;code&gt;let&lt;/code&gt; , она использует то, что некоторые называют &lt;em&gt;lexical-scoping&lt;/em&gt; или &lt;em&gt;block-scoping&lt;/em&gt; . В отличие от переменных, объявленных с помощью &lt;code&gt;var&lt;/code&gt; , чьи области видимости просачиваются в их содержащую функцию, переменные с областью видимости блока не видны за пределами ближайшего содержащего их блока или &lt;code&gt;for&lt;/code&gt; -loop.</target>
        </trans-unit>
        <trans-unit id="e90a72104ebe8868314228d24725924c08766c5b" translate="yes" xml:space="preserve">
          <source>When accessing an element with a known index, the correct type is retrieved:</source>
          <target state="translated">При обращении к элементу с известным индексом извлекается правильный тип:</target>
        </trans-unit>
        <trans-unit id="d43b1825ee2b2cb0d745c365143986923701b4d7" translate="yes" xml:space="preserve">
          <source>When all members in an enum have literal enum values, some special semantics come to play.</source>
          <target state="translated">Когда все члены переписи имеют буквальные значения перечисления,в игру вступает какая-то особая семантика.</target>
        </trans-unit>
        <trans-unit id="84234191fb7cb5a1d6647ae5bcd64e2e66fdf73e" translate="yes" xml:space="preserve">
          <source>When an array literal is contextually typed by the implied type of an array binding pattern:</source>
          <target state="translated">Когда литерал массива контекстно типизируется подразумеваемым типом шаблона привязки массива:</target>
        </trans-unit>
        <trans-unit id="6db5ea81f7f1151fab25e118bfe8501e1c5b8304" translate="yes" xml:space="preserve">
          <source>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</source>
          <target state="translated">Когда тип интерфейса расширяет тип класса,он наследует члены класса,но не их реализации.Это выглядит так,как будто интерфейс объявил все члены класса без предоставления реализации.Интерфейсы наследуют даже закрытые и защищенные члены базового класса.Это означает,что при создании интерфейса,расширяющего класс с закрытыми или защищенными членами,этот тип интерфейса может быть реализован только этим классом или его подклассом.</target>
        </trans-unit>
        <trans-unit id="5744d6fdcbf8dc3476727393bac3b4cddf93ada3" translate="yes" xml:space="preserve">
          <source>When an object literal is contextually typed by the implied type of an object binding pattern:</source>
          <target state="translated">Когда объект буквально набирается контекстуально под подразумеваемым типом шаблона привязки объекта:</target>
        </trans-unit>
        <trans-unit id="be88d1b03a9be5d8830da895b57d21e37b131ee9" translate="yes" xml:space="preserve">
          <source>When an object with a numeric index signature of type &lt;code&gt;T&lt;/code&gt; (such as an array) is indexed by a &lt;code&gt;for..in&lt;/code&gt; variable of a containing &lt;code&gt;for..in&lt;/code&gt; statement for an object &lt;em&gt;with&lt;/em&gt; a numeric index signature and &lt;em&gt;without&lt;/em&gt; a string index signature (again such as an array), the value produced is of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Когда объект с числовым индексом сигнатурой типа &lt;code&gt;T&lt;/code&gt; (например, массив) индексируются с помощью &lt;code&gt;for..in&lt;/code&gt; переменных, содержащего &lt;code&gt;for..in&lt;/code&gt; заявления для объекта &lt;em&gt;с&lt;/em&gt; числовым индексом подписью и &lt;em&gt;без&lt;/em&gt; индекса строки подписи (опять - таки такие , как массив), производимое значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a191b524d20c2c29223783fb417af58e807f338" translate="yes" xml:space="preserve">
          <source>When calling this function, TypeScript will try to figure out the types of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; through a process called &lt;em&gt;type argument inference&lt;/em&gt;. This inference process usually works pretty well:</source>
          <target state="translated">При вызове этой функции TypeScript пытается определить типы &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; с помощью процесса, называемого &lt;em&gt;выводом аргумента типа&lt;/em&gt; . Этот процесс вывода обычно работает очень хорошо:</target>
        </trans-unit>
        <trans-unit id="a79acd611da5588e33a3cd349e2f634dc5e04388" translate="yes" xml:space="preserve">
          <source>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.</source>
          <target state="translated">При сравнении функций для совместимости опциональные и необходимые параметры взаимозаменяемы.Дополнительные опциональные параметры типа источника не являются ошибкой,а опциональные параметры типа целевого источника без соответствующих параметров типа источника не являются ошибкой.</target>
        </trans-unit>
        <trans-unit id="03084317d53b13f20dd727e5c86474664f6cced3" translate="yes" xml:space="preserve">
          <source>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</source>
          <target state="translated">При сравнении типов параметров функции,назначение проходит успешно,если либо исходный параметр может быть назначен целевому параметру,либо наоборот.Это неправильно,потому что вызывающему абоненту может быть присвоена функция,которая принимает более специализированный тип,но вызывает функцию с менее специализированным типом.На практике подобного рода ошибки встречаются редко,что позволяет использовать множество распространенных JavaScript-шаблонов.Краткий пример:</target>
        </trans-unit>
        <trans-unit id="e381f7d0b16f43f925b00a27f8c4e30f5d16099b" translate="yes" xml:space="preserve">
          <source>When compiled in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, optional properties and methods automatically have &lt;code&gt;undefined&lt;/code&gt; included in their type. Thus, the &lt;code&gt;b&lt;/code&gt; property above is of type &lt;code&gt;number | undefined&lt;/code&gt; and the &lt;code&gt;g&lt;/code&gt; method above is of type &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt;. Type guards can be used to strip away the &lt;code&gt;undefined&lt;/code&gt; part of the type:</source>
          <target state="translated">При компиляции в режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; необязательные свойства и методы автоматически включают &lt;code&gt;undefined&lt;/code&gt; в их тип. Таким образом, указанное выше свойство &lt;code&gt;b&lt;/code&gt; имеет тип &lt;code&gt;number | undefined&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; выше метод имеет тип &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt; . Защитники типа могут использоваться для удаления &lt;code&gt;undefined&lt;/code&gt; части типа:</target>
        </trans-unit>
        <trans-unit id="5bbcd2d4cb15d58c0854ed82d657d8c796031edd" translate="yes" xml:space="preserve">
          <source>When compiled, each module will become a separate &lt;code&gt;.js&lt;/code&gt; file. As with reference tags, the compiler will follow &lt;code&gt;import&lt;/code&gt; statements to compile dependent files.</source>
          <target state="translated">После компиляции каждый модуль станет отдельным файлом &lt;code&gt;.js&lt;/code&gt; . Как и в случае со ссылочными тегами, компилятор будет следовать операторам &lt;code&gt;import&lt;/code&gt; для компиляции зависимых файлов.</target>
        </trans-unit>
        <trans-unit id="751fdd8e03ce07c29b56146fecc9f825067cb792" translate="yes" xml:space="preserve">
          <source>When compiling to pre-ES6 targets, the string is decomposed:</source>
          <target state="translated">При компиляции по целям preES6 строка разлагается:</target>
        </trans-unit>
        <trans-unit id="4156655ae276c8b3ed96d041dfc8baeba1797652" translate="yes" xml:space="preserve">
          <source>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</source>
          <target state="translated">При создании фабрик в TypeScript с использованием генерики,необходимо обращаться к типам классов по их конструкторским функциям.Например,</target>
        </trans-unit>
        <trans-unit id="dcace02a91899e1f338f3e9e2fa474b942645716" translate="yes" xml:space="preserve">
          <source>When enabled, TypeScript will check all code paths in a function to ensure they return a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a561b2561570486c65edf072423fc080bd866b" translate="yes" xml:space="preserve">
          <source>When enabled, as long as the &lt;code&gt;reflect-metadata&lt;/code&gt; library has been imported, additional design-time type information will be exposed at runtime.</source>
          <target state="translated">Если этот параметр включен, до тех пор, пока библиотека &lt;code&gt;reflect-metadata&lt;/code&gt; импортирована, дополнительная информация о типе времени разработки будет отображаться во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2e2b57241329652bf13e53eebcd41139c80c8d1c" translate="yes" xml:space="preserve">
          <source>When enabled, this flag causes functions parameters to be checked more correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2be8d3bddd72617c23414391cc48bc565dfaa5" translate="yes" xml:space="preserve">
          <source>When exporting a module using &lt;code&gt;export =&lt;/code&gt;, TypeScript-specific &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; must be used to import the module.</source>
          <target state="translated">При экспорте модуля с помощью &lt;code&gt;export =&lt;/code&gt; для &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; необходимо использовать импортный модуль, специфичный для TypeScript, = require (&quot;модуль&quot;) .</target>
        </trans-unit>
        <trans-unit id="06ca5da26932f2433c3883f2ba92d649c8f8ac14" translate="yes" xml:space="preserve">
          <source>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</source>
          <target state="translated">При первом переходе к организации,основанной на модулях,распространенной тенденцией является обертывание экспорта в дополнительный слой пространств имен.Модули имеют собственную область действия,и только экспортированные декларации видны снаружи модуля.Учитывая это,пространство имён при работе с модулями предоставляет очень малое значение,если таковое вообще есть.</target>
        </trans-unit>
        <trans-unit id="668eaece6bc69ffaa69b4efacde9943b15dbace6" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript file will raise an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7376b10eff8993749ce4879a342660552379ff7" translate="yes" xml:space="preserve">
          <source>When imported into a TypeScript module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cbb0349fc79c96ec431ec47e8f342090438ecb" translate="yes" xml:space="preserve">
          <source>When importing using the &lt;code&gt;Node&lt;/code&gt; module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from &amp;ldquo;identical&amp;rdquo; packages. If a file originates from a package with a &lt;code&gt;package.json&lt;/code&gt; containing the same &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain &lt;code&gt;private&lt;/code&gt; members that cause them to be structurally incompatible.</source>
          <target state="translated">При импорте с использованием стратегии разрешения модулей &lt;code&gt;Node&lt;/code&gt; в TypeScript 2.5 компилятор теперь проверяет, происходят ли файлы из &amp;laquo;идентичных&amp;raquo; пакетов. Если файл происходит из пакета с &lt;code&gt;package.json&lt;/code&gt; , содержащим те же поля &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;version&lt;/code&gt; что и ранее встреченный пакет, то TypeScript перенаправит себя на самый верхний пакет. Это помогает решить проблемы, когда два пакета могут содержать идентичные объявления классов, но содержат &lt;code&gt;private&lt;/code&gt; члены, из-за которых они становятся структурно несовместимыми.</target>
        </trans-unit>
        <trans-unit id="e53d751bb35ec11bb8d50707759e0855efc875fb" translate="yes" xml:space="preserve">
          <source>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the &lt;em&gt;last&lt;/em&gt; signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</source>
          <target state="translated">При выводе из типа с несколькими сигнатурами вызовов (например, типа перегруженной функции) выводы делаются из &lt;em&gt;последней&lt;/em&gt; сигнатуры (что, по-видимому, является наиболее допустимым универсальным случаем). Невозможно выполнить разрешение перегрузки на основе списка типов аргументов.</target>
        </trans-unit>
        <trans-unit id="c0e5d12e818f1a128405e0dcf37599e5124ab4c5" translate="yes" xml:space="preserve">
          <source>When input files are specified on the command line, &lt;code&gt;tsconfig.json&lt;/code&gt; files are ignored.</source>
          <target state="translated">Когда входные файлы указаны в командной строке, файлы &lt;code&gt;tsconfig.json&lt;/code&gt; игнорируются.</target>
        </trans-unit>
        <trans-unit id="c7dbba16b050a53843a9368cb4cf7aacd6cb532e" translate="yes" xml:space="preserve">
          <source>When install is complete, rebuild!</source>
          <target state="translated">После завершения установки восстановите!</target>
        </trans-unit>
        <trans-unit id="9030ab49af527527a3048a47ea128f0c0c219027" translate="yes" xml:space="preserve">
          <source>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</source>
          <target state="translated">При взаимодействии со сторонним JavaScript,возможно,потребуется использовать шаблоны,подобные приведенным выше,чтобы полностью описать форму типа.</target>
        </trans-unit>
        <trans-unit id="6164dc5fed96c16868282dad3b94f86d550f8593" translate="yes" xml:space="preserve">
          <source>When looking at the code of a global library, you&amp;rsquo;ll usually see:</source>
          <target state="translated">Глядя на код глобальной библиотеки, вы обычно видите:</target>
        </trans-unit>
        <trans-unit id="8a513a2bca42391a3829f6aa2918feafe16fa0e9" translate="yes" xml:space="preserve">
          <source>When making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b922be38a1d8a16178d415d54259031e8aa4f6f" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="translated">Когда несколько декораторов применяются к одному объявлению, их оценка аналогична &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;композиции функций в математике&lt;/a&gt; . В этой модели при составлении функций &lt;em&gt;f&lt;/em&gt; и &lt;em&gt;g&lt;/em&gt; результирующая композиция ( &lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt; ) ( &lt;em&gt;x&lt;/em&gt; ) эквивалентна &lt;em&gt;f&lt;/em&gt; ( &lt;em&gt;g&lt;/em&gt; ( &lt;em&gt;x&lt;/em&gt; )).</target>
        </trans-unit>
        <trans-unit id="954328cfc017ca1687105e4509b95a1b13d2af54" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fa362fa464bde97faa89642caf12d0cece53ae" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;https://wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2ce3b2acc4dd5238eaac40a3c2b746b0805538" translate="yes" xml:space="preserve">
          <source>When needed, the compiler &lt;em&gt;widens&lt;/em&gt; &amp;mdash; converts to a supertype &amp;mdash; the unit type to the primitive type, such as &lt;code&gt;&quot;foo&quot;&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;. This happens when using mutability, which can hamper some uses of mutable variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6f6092ccbf1d0a9294c7e4c282859a027ca09d" translate="yes" xml:space="preserve">
          <source>When no best common type is found, the resulting inference is the union array type, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt;.</source>
          <target state="translated">Когда лучший общий тип не найден, в результате получается объединенный тип массива &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="577abe4bb126beb561a8efdcb48a28392a4a75af" translate="yes" xml:space="preserve">
          <source>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; has a single construct signature &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt;.</source>
          <target state="translated">При получении сигнатур конструкции типа пересечения, который содержит типы конструктора миксина, сигнатуры конструкции миксина отбрасываются, а их типы экземпляров смешиваются с типами возвращаемых сигнатур других конструкций в типе пересечения. Например, тип пересечения &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; имеет единственную подпись конструкции &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5037d7b746e687be44f9da9ad23e7dc846aba52" translate="yes" xml:space="preserve">
          <source>When reading from a union type, you can see any properties that are shared by them:</source>
          <target state="translated">При чтении с союзного типа,вы можете увидеть любые свойства,которые являются общими для них:</target>
        </trans-unit>
        <trans-unit id="35582d74eec1d631b57c2de10a47c90c793d3dde" translate="yes" xml:space="preserve">
          <source>When relating the type of &lt;code&gt;map&lt;/code&gt; in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</source>
          <target state="translated">При связывании типа &lt;code&gt;map&lt;/code&gt; в TS 2.4 язык проверяет, является ли каждый параметр типом обратного вызова, и если да, то он гарантирует, что эти параметры проверяются контравариантным образом по отношению к текущему отношению.</target>
        </trans-unit>
        <trans-unit id="39dea6a28c7ed5ec45fbae153245367a81c4db31" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; allows you to write an import like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c583a10fdbc7daf7e0efcc6636eb8647630843da" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt; lets you access UMD exports as globals from inside module files. A module file is a file that has imports and/or exports. Without this flag, using an export from a UMD module requires an import declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c950a1a9d1adb8bf75c10364f43b53406e85813" translate="yes" xml:space="preserve">
          <source>When set to true, TypeScript will raise an error when a class property was declared but not set in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e345c366b26184d9f74a06f292f247bfab9bfef" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will check that the built-in methods of functions &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;bind&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; are invoked with correct argument for the underlying function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ba421a210ee671b7d2e94cf97295f944594d7c" translate="yes" xml:space="preserve">
          <source>When set, TypeScript will include the original content of the &lt;code&gt;.ts&lt;/code&gt; file as an embedded string in the source map. This is often useful in the same cases as &lt;code&gt;inlineSourceMap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4ff52db3699946536782a20c9a209457b23419" translate="yes" xml:space="preserve">
          <source>When set, instead of writing out a &lt;code&gt;.js.map&lt;/code&gt; file to provide source maps, TypeScript will embed the source map content in the &lt;code&gt;.js&lt;/code&gt; files. Although this results in larger JS files, it can be convenient in some scenarios. For example, you might want to debug JS files on a webserver that doesn&amp;rsquo;t allow &lt;code&gt;.map&lt;/code&gt; files to be served.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff10b12f6a9033fbc10cf950cc0ed31b94b4a4d" translate="yes" xml:space="preserve">
          <source>When specifying a greeting, you must pass a &lt;code&gt;GreetingSettings&lt;/code&gt; object. This object has the following properties:</source>
          <target state="translated">При указании приветствия необходимо передать объект &lt;code&gt;GreetingSettings&lt;/code&gt; . Этот объект имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="43988d6b430a774a26861955cc54fd9c702d0452" translate="yes" xml:space="preserve">
          <source>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</source>
          <target state="translated">При указании аргументов типа необходимо указывать только аргументы типа для требуемых параметров типа.Неопределенные типовые параметры будут преобразовываться к своим типам по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1ebe929f8f784ba5280922a50ab6e379d8859057" translate="yes" xml:space="preserve">
          <source>When targeting ES3/ES5, the following code</source>
          <target state="translated">При нацеливании на ES3/ES5 следующий код</target>
        </trans-unit>
        <trans-unit id="156025a3f40907ffeac72e030a3a730a1deebeb1" translate="yes" xml:space="preserve">
          <source>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate &lt;code&gt;for..of&lt;/code&gt; loops to target the built-in iterator implementation in the engine.</source>
          <target state="translated">При нацеливании на механизм, совместимый с ECMAScipt 2015, компилятор будет генерировать циклы &lt;code&gt;for..of&lt;/code&gt; для нацеливания на реализацию встроенного в механизм итератора.</target>
        </trans-unit>
        <trans-unit id="81f1ae5ab6877859c51c53b6981d29f05adff0a6" translate="yes" xml:space="preserve">
          <source>When targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of &lt;code&gt;Array&lt;/code&gt; type. It is an error to use &lt;code&gt;for..of&lt;/code&gt; loops on non-Array values, even if these non-Array values implement the &lt;code&gt;Symbol.iterator&lt;/code&gt; property.</source>
          <target state="translated">При ориентации на движок, совместимый с ES5 или ES3, итераторы разрешены только для значений типа &lt;code&gt;Array&lt;/code&gt; . Использование циклов &lt;code&gt;for..of&lt;/code&gt; для значений, отличных от массива, является ошибкой , даже если эти значения, не являющиеся массивами, реализуют свойство &lt;code&gt;Symbol.iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6f752156fda72ea7aae2689896f7e4699113094" translate="yes" xml:space="preserve">
          <source>When the module &lt;strong&gt;does not&lt;/strong&gt; explicitly specify a default export.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c37c6770fe59c21b776453641387b80134be5e8" translate="yes" xml:space="preserve">
          <source>When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da87dafd3c996b8acd299c5e81f629e20d29370b" translate="yes" xml:space="preserve">
          <source>When this option is set, TypeScript will issue an error if a program tries to include a file by a casing different from the casing on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990f9e6deb289272b10e4e4125770810112d182e" translate="yes" xml:space="preserve">
          <source>When this setting is on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fff15c1d3e5e5f2e18f1d4a6ac9350c4a78b3f2" translate="yes" xml:space="preserve">
          <source>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</source>
          <target state="translated">Когда для параметров покоя выводятся типы кортежей,необязательные параметры в источнике становятся необязательными элементами кортежей в выводимом типе.</target>
        </trans-unit>
        <trans-unit id="75737547c96987306eebfed378fbd115f0634d72" translate="yes" xml:space="preserve">
          <source>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;. A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="translated">При использовании разрешения модуля узла в TypeScript 3.1, когда TypeScript &lt;code&gt;package.json&lt;/code&gt; файл package.json, чтобы выяснить, какие файлы ему нужно прочитать, он сначала просматривает новое поле с именем &lt;code&gt;typesVersions&lt;/code&gt; . Пакет &lt;code&gt;package.json&lt;/code&gt; с полем &lt;code&gt;typesVersions&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="1ae8b3b63e3d4432d7dcb8ebb6d1406c00d3f904" translate="yes" xml:space="preserve">
          <source>When using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn&amp;rsquo;t support native file watchers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4850716ae612670ae2d56349b6a2660a6446e72a" translate="yes" xml:space="preserve">
          <source>When we do, the compiler will give us an error that we&amp;rsquo;re using the &lt;code&gt;.length&lt;/code&gt; member of &lt;code&gt;arg&lt;/code&gt;, but nowhere have we said that &lt;code&gt;arg&lt;/code&gt; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &lt;code&gt;number&lt;/code&gt; instead, which does not have a &lt;code&gt;.length&lt;/code&gt; member.</source>
          <target state="translated">Когда мы это сделаем, компилятор выдаст нам ошибку, что мы используем член &lt;code&gt;.length&lt;/code&gt; для &lt;code&gt;arg&lt;/code&gt; , но нигде мы не сказали, что &lt;code&gt;arg&lt;/code&gt; имеет этот член. Помните, мы говорили ранее, что эти переменные типа заменяют любые и все типы, поэтому кто-то, использующий эту функцию, мог бы вместо этого передать &lt;code&gt;number&lt;/code&gt; , которое не имеет члена &lt;code&gt;.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217dd70751ec70c2507f34daeb4f28f27ba30001" translate="yes" xml:space="preserve">
          <source>When we first touched on the idea of variable capturing with &lt;code&gt;var&lt;/code&gt; declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an &amp;ldquo;environment&amp;rdquo; of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.</source>
          <target state="translated">Когда мы впервые коснулись идеи захвата переменных с помощью объявления &lt;code&gt;var&lt;/code&gt; , мы кратко рассмотрели, как действуют переменные после захвата. Чтобы лучше понять это, каждый раз при запуске области видимости создается &amp;laquo;среда&amp;raquo; переменных. Эта среда и ее захваченные переменные могут существовать даже после того, как все в ее области завершено.</target>
        </trans-unit>
        <trans-unit id="7c4c9e905df51f2991607084fd0766320f038e1a" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to declare that you do not want a project to be included when using features like &lt;em&gt;find all references&lt;/em&gt; or &lt;em&gt;jump to definition&lt;/em&gt; in an editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c31435415edfd38b4ca387c630ed5c177c68f06" translate="yes" xml:space="preserve">
          <source>When working with &lt;a href=&quot;docs/handbook/project-references&quot;&gt;composite TypeScript projects&lt;/a&gt;, this option provides a way to go &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#build-free-editing-with-project-references&quot;&gt;back to the pre-3.7&lt;/a&gt; behavior where d.ts files were used to as the boundaries between modules. In 3.7 the source of truth is now your TypeScript files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fe803409a586a0ea7a977ee5a94d526da6f55e" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;.d.ts&lt;/code&gt; files for JavaScript files you may want to use &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt; or use &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt; to ensure that the JavaScript files are not overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff7f4efa05e217597245c432a821c2527e220ab" translate="yes" xml:space="preserve">
          <source>When working with classes and interfaces, it helps to keep in mind that a class has &lt;em&gt;two&lt;/em&gt; types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</source>
          <target state="translated">При работе с классами и интерфейсами полезно иметь в виду, что у класса есть &lt;em&gt;два&lt;/em&gt; типа: тип статической стороны и тип стороны экземпляра. Вы можете заметить, что если вы создадите интерфейс с подписью конструкции и попытаетесь создать класс, реализующий этот интерфейс, вы получите ошибку:</target>
        </trans-unit>
        <trans-unit id="59ca9320ae741734ed0a3e6c543e8c5deef3ad35" translate="yes" xml:space="preserve">
          <source>When writing in JavaScript files (using &lt;code&gt;allowJs&lt;/code&gt;), TypeScript now recognizes declarations that use &lt;code&gt;Object.defineProperty&lt;/code&gt;. This means you&amp;rsquo;ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the &lt;code&gt;checkJs&lt;/code&gt; option or adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to the top of your file).</source>
          <target state="translated">При записи в файлы JavaScript (с использованием &lt;code&gt;allowJs&lt;/code&gt; ) TypeScript теперь распознает объявления, использующие &lt;code&gt;Object.defineProperty&lt;/code&gt; . Это означает, что вы получите лучшее завершение и более &lt;code&gt;checkJs&lt;/code&gt; проверку типов при включении проверки типов в файлах JavaScript (включив параметр checkJs или добавив комментарий &lt;code&gt;// @ts-check&lt;/code&gt; в начало файла).</target>
        </trans-unit>
        <trans-unit id="2c9a1bcb431f60ef891dc5272428f61ccd6deae4" translate="yes" xml:space="preserve">
          <source>When you are trying to debug why a module isn&amp;rsquo;t being included. You can set &lt;code&gt;traceResolutions&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; to have TypeScript print information about its resolution process for each processed file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5f993452425d2ee4ab0f5de68ed85198028eec" translate="yes" xml:space="preserve">
          <source>When you begin to use generics, you&amp;rsquo;ll notice that when you create generic functions like &lt;code&gt;identity&lt;/code&gt;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</source>
          <target state="translated">Когда вы начнете использовать универсальные шаблоны, вы заметите, что при создании универсальных функций, таких как &lt;code&gt;identity&lt;/code&gt; , компилятор будет обеспечивать, чтобы вы правильно использовали любые типизированные параметры в теле функции. То есть вы фактически относитесь к этим параметрам так, как будто они могут быть любого типа.</target>
        </trans-unit>
        <trans-unit id="bb76a0dfbc0b927a30bc60fb3308eae1c0c32030" translate="yes" xml:space="preserve">
          <source>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the &lt;em&gt;instance&lt;/em&gt; of the class.</source>
          <target state="translated">Когда вы объявляете класс в TypeScript, вы фактически создаете несколько объявлений одновременно. Первый - это тип &lt;em&gt;экземпляра&lt;/em&gt; класса.</target>
        </trans-unit>
        <trans-unit id="63841123e89ff79b5bb8a778012e2675dfb6bf27" translate="yes" xml:space="preserve">
          <source>When you declare a variable via &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, you are telling the compiler that there is the chance that this variable will change its contents. In contrast, using &lt;code&gt;const&lt;/code&gt; to declare a variable will inform TypeScript that this object will never change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffefcf45ac3a82bd7f38544ffbfd55e8c346d30" translate="yes" xml:space="preserve">
          <source>When you have a JavaScript project in your editor, TypeScript will provide types for your &lt;code&gt;node_modules&lt;/code&gt; automatically using the DefinitelyTyped set of &lt;code&gt;@types&lt;/code&gt; definitions. This is called automatic type acquisition, and you can customize it using the &lt;code&gt;typeAcquisition&lt;/code&gt; object in your configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c36dbc166af4c2b15a69645f3c727647f3368c" translate="yes" xml:space="preserve">
          <source>When you have this option set, by not including a module in the &lt;code&gt;types&lt;/code&gt; array it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbca5cdf2d57a23f367d0a1514252e4f2c75c7b6" translate="yes" xml:space="preserve">
          <source>When you reference a project, new things happen:</source>
          <target state="translated">Когда вы ссылаетесь на проект,происходят новые вещи:</target>
        </trans-unit>
        <trans-unit id="34a19e5b1b2f656dfeb0df790e074ddaa8c1d34a" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;this&lt;/code&gt; keyword outside of classes, it has the type &lt;code&gt;any&lt;/code&gt; by default. For instance, imagine a &lt;code&gt;Point&lt;/code&gt; class, and imagine a function that we wish to add as a method:</source>
          <target state="translated">Когда вы используете ключевое слово &lt;code&gt;this&lt;/code&gt; вне классов, по умолчанию оно имеет тип &lt;code&gt;any&lt;/code&gt; . Например, представьте класс &lt;code&gt;Point&lt;/code&gt; и функцию, которую мы хотим добавить в качестве метода:</target>
        </trans-unit>
        <trans-unit id="70c371f96f2c201ef59af8e252df237c2c99859d" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re happy, clone &lt;a href=&quot;https://github.com/DefinitelyTyped&quot;&gt;DefinitelyTyped/DefinitelyTyped&lt;/a&gt; and follow the instructions in the README.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2ff1337f892c7263b4813735bcd04bc80f2255" translate="yes" xml:space="preserve">
          <source>When:</source>
          <target state="translated">When:</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2e1366df4a2e5026b79e734a847a45f2224acce3" translate="yes" xml:space="preserve">
          <source>Whether to keep outdated console output in watch mode instead of clearing the screen every time a change happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619362ecade2fffba9685e4a969d18b8cca8689d" translate="yes" xml:space="preserve">
          <source>Which can be described by the following .d.ts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33710489e78a6feef64468d41a06aab499f59059" translate="yes" xml:space="preserve">
          <source>Which can be described with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bbf399003bd64788409edf57ef8dcc79e01d02" translate="yes" xml:space="preserve">
          <source>Which can be switched out with your own globals via this flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6de3b1c6e1142dd03c8ec0d38d67a76b4d0290" translate="yes" xml:space="preserve">
          <source>Which creates quite a lot of JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938fe38b788f59c1c6e957d41be0c2a25ffdccf8" translate="yes" xml:space="preserve">
          <source>Which generates code like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962849684c80963bf61b9a409447ab660d400c45" translate="yes" xml:space="preserve">
          <source>Which in turn can be imported using default imports:</source>
          <target state="translated">Который,в свою очередь,может быть импортирован с помощью импорта по умолчанию:</target>
        </trans-unit>
        <trans-unit id="cf6447c6242e379fc5cad3f436eb54be60f4dba3" translate="yes" xml:space="preserve">
          <source>Which leads us to writing our first generic interface. Let&amp;rsquo;s take the object literal from the previous example and move it to an interface:</source>
          <target state="translated">Это привело нас к написанию нашего первого универсального интерфейса. Возьмем литерал объекта из предыдущего примера и переместим его в интерфейс:</target>
        </trans-unit>
        <trans-unit id="70bd03441762cc2b325aef1bac1f313f2d0e16b5" translate="yes" xml:space="preserve">
          <source>Which translates to:</source>
          <target state="translated">Что в переводе означает:</target>
        </trans-unit>
        <trans-unit id="3dbf1444b14bbeff8ff24b42f88c1114396361cf" translate="yes" xml:space="preserve">
          <source>Which would include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfe760aa187d990362b3f4c61beb430484ea0d1" translate="yes" xml:space="preserve">
          <source>Which would print this output to the console:</source>
          <target state="translated">Который распечатает этот вывод на консоль:</target>
        </trans-unit>
        <trans-unit id="53ebf7ccbab25bb66042f79bfb51a8652406a52d" translate="yes" xml:space="preserve">
          <source>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to &amp;ldquo;just work&amp;rdquo; TypeScript. Additionally, this approach for property declarations allows us to express common patterns like &lt;code&gt;defaultProps&lt;/code&gt; and &lt;code&gt;propTypes&lt;/code&gt; on React function components (formerly known as SFCs).</source>
          <target state="translated">Хотя экспорт ECMAScript часто является лучшим способом обеспечения этой функциональности, эта новая поддержка позволяет коду, написанному в этом стиле, &amp;laquo;просто работать&amp;raquo; TypeScript. Кроме того, этот подход к объявлению свойств позволяет нам выражать общие шаблоны, такие как &lt;code&gt;defaultProps&lt;/code&gt; и &lt;code&gt;propTypes&lt;/code&gt; , в компонентах функции React (ранее известных как SFC).</target>
        </trans-unit>
        <trans-unit id="fad58bbb4ff5e3b9b95e4764b17888edf69eef4d" translate="yes" xml:space="preserve">
          <source>While TypeScript 3.7 isn&amp;rsquo;t changing any existing emit by default, we&amp;rsquo;ve been rolling out changes incrementally to help users mitigate potential future breakage. We&amp;rsquo;ve provided a new flag called &lt;code&gt;useDefineForClassFields&lt;/code&gt; to enable this emit mode with some new checking logic.</source>
          <target state="translated">В то время как TypeScript 3.7 по умолчанию не изменяет ни одно существующее излучение, мы постепенно внедряем изменения, чтобы помочь пользователям уменьшить потенциальные поломки в будущем. Мы предоставили новый флаг под названием &lt;code&gt;useDefineForClassFields&lt;/code&gt; , чтобы включить этот режим вывода с некоторой новой логикой проверки.</target>
        </trans-unit>
        <trans-unit id="f56a592c618616410fc71f4bbabb49d78514f411" translate="yes" xml:space="preserve">
          <source>While allowing people to randomly set &lt;code&gt;fullName&lt;/code&gt; directly is pretty handy, we may also want enforce some constraints when &lt;code&gt;fullName&lt;/code&gt; is set.</source>
          <target state="translated">Хотя разрешить людям произвольно задавать &lt;code&gt;fullName&lt;/code&gt; напрямую довольно удобно, мы также можем захотеть применить некоторые ограничения при установке &lt;code&gt;fullName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="636d4d19d4405d30263f2aa95da0f2c2a734da53" translate="yes" xml:space="preserve">
          <source>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let&amp;rsquo;s start with a basic example of two functions that differ only in their parameter lists:</source>
          <target state="translated">Хотя сравнение примитивных типов и типов объектов относительно просто, вопрос о том, какие функции следует считать совместимыми, немного сложнее. Начнем с базового примера двух функций, которые различаются только списками параметров:</target>
        </trans-unit>
        <trans-unit id="03a5fd4e6d293c6d495eff753858affb70025397" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s good practice to use &lt;code&gt;ReadonlyArray&lt;/code&gt; over &lt;code&gt;Array&lt;/code&gt; when no mutation is intended, it&amp;rsquo;s often been a pain given that arrays have a nicer syntax. Specifically, &lt;code&gt;number[]&lt;/code&gt; is a shorthand version of &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;, just as &lt;code&gt;Date[]&lt;/code&gt; is a shorthand for &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Хотя это хорошая практика , чтобы использовать &lt;code&gt;ReadonlyArray&lt;/code&gt; над &lt;code&gt;Array&lt;/code&gt; , когда мутация не предназначена, она часто была боль , учитывая , что массивы имеют синтаксис лучше. В частности, &lt;code&gt;number[]&lt;/code&gt; является сокращенной версией &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; , так же как &lt;code&gt;Date[]&lt;/code&gt; является сокращением для &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c74aaa3335f7bff7bf6990f82abec0b22352a01" translate="yes" xml:space="preserve">
          <source>While not a breakage per se, opting in to the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag can cause breakage when:</source>
          <target state="translated">Хотя это и не является поломкой как таковой, выбор флага &lt;code&gt;useDefineForClassFields&lt;/code&gt; может вызвать поломку в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="ebbe87035da271030af0d806842f81f2cc35cc3b" translate="yes" xml:space="preserve">
          <source>While not strictly a language change, nightly builds are now available by installing with the following command:</source>
          <target state="translated">Хотя,строго говоря,это не означает смену языка,но ночные сборки теперь доступны при установке с помощью следующей команды:</target>
        </trans-unit>
        <trans-unit id="3360869251a9b9ea8953b44e203398f6f81cb993" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#enums-at-runtime&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="translated">В то время как строковые перечисления не имеют поведения автоматического увеличения, строковые перечисления имеют то преимущество, что они хорошо &amp;laquo;сериализуются&amp;raquo;. Другими словами, если вы выполняли отладку и должны были прочитать значение времени выполнения числового перечисления, значение часто бывает непрозрачным - оно не передает никакого полезного значения само по себе (хотя &lt;a href=&quot;#enums-at-runtime&quot;&gt;обратное сопоставление&lt;/a&gt; часто может помочь), строковые перечисления позволяют вам чтобы дать осмысленное и читаемое значение при запуске вашего кода, независимо от имени самого члена перечисления.</target>
        </trans-unit>
        <trans-unit id="9889e9833569f06fb69539d73f7b2696ca91f5f9" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#reverse-mappings&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c063d2ee2675e04f30864acccf31e9c245c672" translate="yes" xml:space="preserve">
          <source>While string index signatures are a powerful way to describe the &amp;ldquo;dictionary&amp;rdquo; pattern, they also enforce that all properties match their return type. This is because a string index declares that &lt;code&gt;obj.property&lt;/code&gt; is also available as &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt;. In the following example, &lt;code&gt;name&lt;/code&gt;&amp;rsquo;s type does not match the string index&amp;rsquo;s type, and the type checker gives an error:</source>
          <target state="translated">Хотя подписи строкового индекса являются мощным способом описания шаблона &amp;laquo;словарь&amp;raquo;, они также обеспечивают соответствие всех свойств их возвращаемому типу. Это потому, что строковый индекс объявляет, что &lt;code&gt;obj.property&lt;/code&gt; также доступен как &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt; . В следующем примере &lt;code&gt;name&lt;/code&gt; типа &amp;laquo;s не соответствует типу Строковый индекс, и тип проверки выдает ошибку:</target>
        </trans-unit>
        <trans-unit id="205fbdc2b0eb96d4c083fa10d1cf873197618502" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;any&lt;/code&gt; is certainly generic in that it will cause the function to accept any and all types for the type of &lt;code&gt;arg&lt;/code&gt;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</source>
          <target state="translated">Хотя использование &lt;code&gt;any&lt;/code&gt; , безусловно, является общим в том смысле, что это приведет к тому, что функция будет принимать любые и все типы для типа &lt;code&gt;arg&lt;/code&gt; , мы фактически теряем информацию о том, что это был за тип, когда функция возвращает. Если мы передали число, единственная информация, которая у нас есть, - это то, что может быть возвращен любой тип.</target>
        </trans-unit>
        <trans-unit id="ad9ab077983f93d52e50138e0c0b8bb1d71036dc" translate="yes" xml:space="preserve">
          <source>While you can use TypeScript to produce JavaScript code from TypeScript code, it&amp;rsquo;s also common to use other transpilers such as &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt; to do this. However, other transpilers only operate on a single file at a time, which means they can&amp;rsquo;t apply code transforms that depend on understanding the full type system. This restriction also applies to TypeScript&amp;rsquo;s &lt;code&gt;ts.transpileModule&lt;/code&gt; API which is used by some build tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3773d499a43f196d119753de15012adfe413581f" translate="yes" xml:space="preserve">
          <source>While you might imagine close interaction between &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;bigint&lt;/code&gt;, the two are separate domains.</source>
          <target state="translated">Хотя вы можете представить себе тесное взаимодействие между &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;bigint&lt;/code&gt; , это два разных домена.</target>
        </trans-unit>
        <trans-unit id="7942bdf53c9b517b254a399642caadffcd723ac5" translate="yes" xml:space="preserve">
          <source>Why does a module in the exclude list still get picked up by the compiler?</source>
          <target state="translated">Почему модуль из списка исключений все еще подхватывается компилятором?</target>
        </trans-unit>
        <trans-unit id="dd7392a9f697967405bb99a3337ee2df7f8bb374" translate="yes" xml:space="preserve">
          <source>Wildcard character in module names</source>
          <target state="translated">Символ Wildcard в названиях модулей</target>
        </trans-unit>
        <trans-unit id="90ff022ca86ce297643ad53057127508fda59a21" translate="yes" xml:space="preserve">
          <source>Wildcard module declarations</source>
          <target state="translated">Объявления модуля Wildcard</target>
        </trans-unit>
        <trans-unit id="e1deac0ee95462765acc0e4d19e587e5b367dac8" translate="yes" xml:space="preserve">
          <source>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Имена модулей с подстановочными знаками могут быть даже более полезными при переходе с нетипизированной базы кода. В сочетании с сокращенными объявлениями внешних модулей набор модулей может быть легко объявлен как &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="576eaaaec7aa1978999d8da3f80d2816c7c61923" translate="yes" xml:space="preserve">
          <source>Will generate an &lt;code&gt;index.js&lt;/code&gt; file like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294ac8947e55f645c50e17c1f027a18712e8f38f" translate="yes" xml:space="preserve">
          <source>Will generate the following JavaScript output:</source>
          <target state="translated">Сгенерирует следующий вывод JavaScript:</target>
        </trans-unit>
        <trans-unit id="49659e5a07d9ec9ddbc5ea2cded9dfed86235252" translate="yes" xml:space="preserve">
          <source>Will generate:</source>
          <target state="translated">Будет генерировать:</target>
        </trans-unit>
        <trans-unit id="9d704e8d8dc3b8c3f478cd3a1e99749549751af4" translate="yes" xml:space="preserve">
          <source>Will not add globals to your project (e.g &lt;code&gt;process&lt;/code&gt; in node, or &lt;code&gt;expect&lt;/code&gt; in Jest)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c5226c3b0025dce708838e9de5a2bc24249633" translate="yes" xml:space="preserve">
          <source>Will not have exports appear as auto-import recommendations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74eea0f1c70b52371bc0816bb556d0f8780652ce" translate="yes" xml:space="preserve">
          <source>Will produce a &lt;code&gt;.d.ts&lt;/code&gt; file like</source>
          <target state="translated">Будет &lt;code&gt;.d.ts&lt;/code&gt; файл .d.ts, например</target>
        </trans-unit>
        <trans-unit id="8dc5830cdd248d481961de84dd0f5250619d9bd8" translate="yes" xml:space="preserve">
          <source>Will result in assigning the name &lt;code&gt;NamedModule&lt;/code&gt; to the module as part of calling the AMD &lt;code&gt;define&lt;/code&gt;:</source>
          <target state="translated">Будет ли в результате присвоения имени &lt;code&gt;NamedModule&lt;/code&gt; к модулю как часть вызова AMD &lt;code&gt;define&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ccd47948ed1aa34956ec39f702d4f4d8e5beb53d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;React 17&lt;/a&gt; the library supports a new form of JSX transformation via a separate import.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d439834e2baaed052d93e4971a2a939ad111045c" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fa735b620d5297fbccee8fa108c418d0b3be08" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;allowUnreachableCode&quot;: false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c698c1cfe17edf510077db506e15f74e06ad129" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&quot;baseUrl&quot;: &quot;./&quot;&lt;/code&gt; inside this project TypeScript will look for files starting at the same folder as the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13740d4f0b7aedad3ff699e83aa212feeaefbb89" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--downlevelIteration&lt;/code&gt;, the compiler uses new type check and emit behavior that attempts to call a &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</source>
          <target state="translated">С &lt;code&gt;--downlevelIteration&lt;/code&gt; компилятор использует проверку нового типа и генерирует поведение, которое пытается вызвать &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; для итерационного объекта, если он найден, и создает итератор синтетического массива над объектом, если это не так.</target>
        </trans-unit>
        <trans-unit id="0baf96b645c93694808d46132810c65e4ff0d180" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--esModuleInterop&lt;/code&gt; two new helpers are generated &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; for import &lt;code&gt;*&lt;/code&gt; and import &lt;code&gt;default&lt;/code&gt; respectively. For instance input like:</source>
          <target state="translated">С помощью &lt;code&gt;--esModuleInterop&lt;/code&gt; создаются два новых помощника &lt;code&gt;__importStar&lt;/code&gt; и &lt;code&gt;__importDefault&lt;/code&gt; для импорта &lt;code&gt;*&lt;/code&gt; и импорта по &lt;code&gt;default&lt;/code&gt; соответственно. Например, введите:</target>
        </trans-unit>
        <trans-unit id="3da68912666fd5861031d156bf5a2c7082eb8729" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;, this example will trigger an error:</source>
          <target state="translated">С &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; этот пример вызовет ошибку:</target>
        </trans-unit>
        <trans-unit id="f2e90c030cc7f4b83e2a77c542e137b8a0ccca5d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--strictNullChecks&lt;/code&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="translated">С &lt;code&gt;--strictNullChecks&lt;/code&gt; необязательный параметр автоматически добавляет &lt;code&gt;| undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="32a499399a274aac8c9b26572f194ee6506912c8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. You will also get an error if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="translated">С &lt;code&gt;@constructor&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; проверяется в функции конструктора &lt;code&gt;C&lt;/code&gt; , так что вы получите предложения для &lt;code&gt;initialize&lt;/code&gt; методы и ошибок , если передать его номер. Вы также получите сообщение об ошибке, если вызовете &lt;code&gt;C&lt;/code&gt; вместо его создания.</target>
        </trans-unit>
        <trans-unit id="a035a3570a36bd407b773b9516d29f13b1a3f416" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. Your editor may also show warnings if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d91be3836c575b7186f6f373bced4bbebe5f6bb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; not set to true (default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf84665fe838195d196abf704465f50c25a018" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; set to true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91ba76f93ca7d7e7796d620a3627489f9dfc963" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856c403e9c9ac477d8823a19f4509e5405076b88" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;esModuleInterop&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df6054d7160294fcb8ad604c1672c83e1b676c9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;false&lt;/code&gt;, the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ea5d91d6887a555bb6f2794a07c5714e99ed42" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;import&lt;/code&gt; types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</source>
          <target state="translated">При доступных типах &lt;code&gt;import&lt;/code&gt; многие ошибки видимости, сообщаемые во время генерации файла объявления, могут быть обработаны компилятором без необходимости изменять ввод.</target>
        </trans-unit>
        <trans-unit id="0b3f0c8f5386232b3414f9e7bc8c3f6e1ed65eec" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;jsxFactory: &quot;h&quot;&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84d42cb295076793894c8acadb047e99a4e746a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;object&lt;/code&gt; type, APIs like &lt;code&gt;Object.create&lt;/code&gt; can be better represented. For example:</source>
          <target state="translated">С &lt;code&gt;object&lt;/code&gt; типа, API - интерфейсы , такие как &lt;code&gt;Object.create&lt;/code&gt; могут быть лучше представлены. Например:</target>
        </trans-unit>
        <trans-unit id="8ea2d3d828b1a918f20e697667351b7f6a125a32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;preserveConstEnums&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;enum&lt;/code&gt; exists at runtime and the numbers are still emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a01b47e5ab896c53b6fbdf6dc40647a614653e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;state&lt;/code&gt; as a literal type, you can compare the value of &lt;code&gt;state&lt;/code&gt; to the equivalent string and TypeScript will know which type is currently being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e1537de3780fc9b8daffc9debdc08216587d32" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;em&gt;on&lt;/em&gt;, the error is correctly detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b06dec962cd4ac1d5fed3f2e1a225bfd61e2b" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;stripInternal&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; the &lt;code&gt;d.ts&lt;/code&gt; emitted will be redacted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa847821456a4401d0546fcc0d18f6208406246" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;this&lt;/code&gt; annotated, you make it explicit that &lt;code&gt;onClickBad&lt;/code&gt; must be called on an instance of &lt;code&gt;Handler&lt;/code&gt;. Then TypeScript will detect that &lt;code&gt;addClickListener&lt;/code&gt; requires a function that has &lt;code&gt;this: void&lt;/code&gt;. To fix the error, change the type of &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">С помощью &lt;code&gt;this&lt;/code&gt; аннотации вы явно указываете, что &lt;code&gt;onClickBad&lt;/code&gt; должен вызываться для экземпляра &lt;code&gt;Handler&lt;/code&gt; . Затем TypeScript обнаружит, что &lt;code&gt;addClickListener&lt;/code&gt; требует функции со &lt;code&gt;this: void&lt;/code&gt; . Чтобы исправить эту ошибку, измените тип &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af6f22a2cba3d56fa994838cc0aadc7b657d06d7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275d348200c6c9320565561ab80694a7f189a460" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;var&lt;/code&gt; declarations, we mentioned that it didn&amp;rsquo;t matter how many times you declared your variables; you just got one.</source>
          <target state="translated">Что &lt;code&gt;var&lt;/code&gt; объявлений var , мы упоминали, что не имеет значения, сколько раз вы объявляли свои переменные; ты только что получил.</target>
        </trans-unit>
        <trans-unit id="c9b5a6af6e81107e965d92874d8f98c54b8d5351" translate="yes" xml:space="preserve">
          <source>With ES6&amp;rsquo;s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt;. TypeScript will emit the string in ES3/ES5 as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;.</source>
          <target state="translated">С помощью escape-символов ES6 вы можете четко представить этот точный символ в строках и шаблонных строках с помощью одного escape- &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt; : &amp;laquo;\ u {20bb7}&amp;raquo; . TypeScript выдаст строку в ES3 / ES5 как &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3fe0d7c3c1bcf18bd50d0141170db310dc43d9e" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.6, type aliases can be generic. For example:</source>
          <target state="translated">С помощью TypeScript 1.6 псевдонимы типа могут быть общими.Например:</target>
        </trans-unit>
        <trans-unit id="460f7c766e92b496f73d02d4ccf0cc4d7ee440b6" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded Polymorphism&lt;/a&gt;.</source>
          <target state="translated">С TypeScript 1.8 становится возможным для ограничения параметра типа ссылаться на параметры типа из того же списка параметров типа. Раньше это было ошибкой. Эта возможность обычно называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-ограниченным полиморфизмом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10bf274b692b3bbc5a7692bb92ffc8f07852abb4" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</source>
          <target state="translated">С помощью TypeScript 1.8 теги JSX теперь классифицируются и окрашиваются в Visual Studio 2015.</target>
        </trans-unit>
        <trans-unit id="c62a9b4ded80d831595f6cf41c707a66d7b472df" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, we&amp;rsquo;ve introduced string literal types. These types are written the same way string literals are, but in type positions.</source>
          <target state="translated">В TypeScript 1.8 мы представили строковые литералы. Эти типы записываются так же, как и строковые литералы, но в позициях типа.</target>
        </trans-unit>
        <trans-unit id="cafdb66c7fc578df947b8db9b1207f3133582261" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.0, the compiler will look up definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.ts&lt;/code&gt; or &lt;code&gt;./moduleA.d.t&lt;/code&gt;.</source>
          <target state="translated">С TypeScript 2.0 компилятор будет искать определение &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; в &lt;code&gt;./moduleA.ts&lt;/code&gt; или &lt;code&gt;./moduleA.d.t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f9f7cdd4003c7ab1f53ac08b77e405631b7232" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, instead of just choosing &lt;code&gt;any&lt;/code&gt;, TypeScript will infer types based on what you end up assigning later on.</source>
          <target state="translated">В TypeScript 2.1 вместо того, чтобы просто выбирать &lt;code&gt;any&lt;/code&gt; , TypeScript будет определять типы на основе того, что вы в конечном итоге назначаете позже.</target>
        </trans-unit>
        <trans-unit id="9277e32824b441ad62cb76d21644b7bd58f69e2f" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; or &lt;code&gt;node_modules/@types/foo&lt;/code&gt;) still takes priority if it exists.</source>
          <target state="translated">С TypeScript 2.1 вы можете импортировать модуль JavaScript без объявления типа. Объявление типа (например, &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; или &lt;code&gt;node_modules/@types/foo&lt;/code&gt; ) по-прежнему имеет приоритет, если оно существует.</target>
        </trans-unit>
        <trans-unit id="fbf94ecb57bb0f01e4f682c5fcfc23891843f05c" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; applied to an intersection type is transformed to a union of &lt;code&gt;keyof&lt;/code&gt; applied to each intersection constituent. In other words, types of the form &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; are transformed to be &lt;code&gt;keyof A | keyof B&lt;/code&gt;. This change should address inconsistencies with inference from &lt;code&gt;keyof&lt;/code&gt; expressions.</source>
          <target state="translated">В TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; , применяемый к типу пересечения, преобразуется в объединение &lt;code&gt;keyof&lt;/code&gt; , применяемого к каждому компоненту пересечения. Другими словами, типы формы &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; преобразуются в &lt;code&gt;keyof A | keyof B&lt;/code&gt; . Это изменение должно устранить несоответствия с выводами из выражений &lt;code&gt;keyof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799099f20671837db4b655a12286097f02ebcd18" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</source>
          <target state="translated">С помощью TypeScript 2.9 об ошибках не сообщается,и теперь сгенерированный файл выглядит так:</target>
        </trans-unit>
        <trans-unit id="593a67e967dde8319eb871882cb980edd2921bd0" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c155aa6cb506c0f0942a50171b6b5c899640514a" translate="yes" xml:space="preserve">
          <source>With TypeScript 3.8, you can use &lt;code&gt;export * as ns&lt;/code&gt; as a shorthand for re-exporting another module with a name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61e7a4d8ea1ab6a29d0ab09e04c9367f5313f2f" translate="yes" xml:space="preserve">
          <source>With TypeScript being a superset of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Поскольку TypeScript является надмножеством JavaScript, язык, естественно, поддерживает &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; . Здесь мы подробнее остановимся на этих новых объявлениях и о том, почему они предпочтительнее &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64acedeec41f3540960ea284815c1fcdf273f591" translate="yes" xml:space="preserve">
          <source>With TypeScript being an extension of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05547de14b26a58915e578c86428fac86c5d55e1" translate="yes" xml:space="preserve">
          <source>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with Unions, and with Generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d707a1290fe39949a2e479395f58ab100dab281" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;tsconfig.json&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3feff2c10853072f1034314c16cdb18d37370a30" translate="yes" xml:space="preserve">
          <source>With a corresponding &lt;code&gt;helloWorld.d.ts&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f706ee444b6a34fbb533bf241523f396e3c6d47a" translate="yes" xml:space="preserve">
          <source>With a union, you can declare that a type could be one of many types. For example, you can describe a &lt;code&gt;boolean&lt;/code&gt; type as being either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f558e3e809cb29cfb2ac66cc2514576d7422f4" translate="yes" xml:space="preserve">
          <source>With definite assignment assertions, we can assert that &lt;code&gt;x&lt;/code&gt; is really assigned by appending an &lt;code&gt;!&lt;/code&gt; to its declaration:</source>
          <target state="translated">С определенными утверждениями присваивания мы можем утверждать, что &lt;code&gt;x&lt;/code&gt; действительно присваивается, добавляя &lt;code&gt;!&lt;/code&gt; к его декларации:</target>
        </trans-unit>
        <trans-unit id="1b9ea4bd3d43c0f24f8d1235be222ef088964840" translate="yes" xml:space="preserve">
          <source>With generic parameter defaults we can reduce it to:</source>
          <target state="translated">С помощью общих настроек параметров по умолчанию мы можем это уменьшить:</target>
        </trans-unit>
        <trans-unit id="285525d91c532d67502baa5d535e42948f1fec46" translate="yes" xml:space="preserve">
          <source>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</source>
          <target state="translated">С помощью индексных типов можно заставить компилятор проверить код,использующий динамические имена свойств.Например,обычным JavaScript шаблоном является выбор подмножества свойств из объекта:</target>
        </trans-unit>
        <trans-unit id="16dcd92f3ae6feec4cfbb7198eb7027566939a02" translate="yes" xml:space="preserve">
          <source>With more &lt;code&gt;tsconfig.json&lt;/code&gt; files, you&amp;rsquo;ll usually want to use &lt;a href=&quot;tsconfig-json&quot;&gt;Configuration file inheritance&lt;/a&gt; to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.</source>
          <target state="translated">При наличии большего &lt;code&gt;tsconfig.json&lt;/code&gt; файлов tsconfig.json вы обычно захотите использовать &lt;a href=&quot;tsconfig-json&quot;&gt;наследование файлов конфигурации&lt;/a&gt; для централизации общих параметров компилятора. Таким образом, вы можете изменить настройку в одном файле, вместо того, чтобы редактировать несколько файлов.</target>
        </trans-unit>
        <trans-unit id="6c19413ec559ade6957207124c85c3143a8ddce9" translate="yes" xml:space="preserve">
          <source>With the flag set to &lt;code&gt;false&lt;/code&gt; (default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc980dcbd81da3823a44dd1638ddc07a1ed0b4b4" translate="yes" xml:space="preserve">
          <source>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;stage 2 proposal&lt;/a&gt; for JavaScript and are available as an experimental feature of TypeScript.</source>
          <target state="translated">С появлением классов в TypeScript и ES6 теперь существуют определенные сценарии, требующие дополнительных функций для поддержки аннотирования или изменения классов и членов классов. Декораторы позволяют добавлять как аннотации, так и синтаксис метапрограммирования для объявлений классов и членов. Декораторы - это &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;предложение этапа 2&lt;/a&gt; для JavaScript, которое доступно в качестве экспериментальной функции TypeScript.</target>
        </trans-unit>
        <trans-unit id="d5cc45fbb67785639194811b9d1feec6410a8444" translate="yes" xml:space="preserve">
          <source>With these all set up, then you can create a class which represents the base class with mixins applied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c7c6883f9c76d8e00e3e2c0ffe4b6a8b55fa95" translate="yes" xml:space="preserve">
          <source>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</source>
          <target state="translated">С помощью этих функций можно сильно набрать ряд функций более высокого порядка,которые преобразовывают функции и их перечни параметров.</target>
        </trans-unit>
        <trans-unit id="57d2f941d62c110711648e01f573d26e835149f4" translate="yes" xml:space="preserve">
          <source>With this TypeScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433e4f23f467e7ae0dc8cfdd04d371137cd886c1" translate="yes" xml:space="preserve">
          <source>With this change, the overloads now give us type checked calls to the &lt;code&gt;pickCard&lt;/code&gt; function.</source>
          <target state="translated">С этим изменением перегрузки теперь предоставляют нам вызовы функции &lt;code&gt;pickCard&lt;/code&gt; с проверкой типа .</target>
        </trans-unit>
        <trans-unit id="78f2f313b67611945a513d63a8211e0d1592c710" translate="yes" xml:space="preserve">
          <source>With this enabled, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50288405a714a4c057a990453fc548fab19c0a86" translate="yes" xml:space="preserve">
          <source>With union types able to represent a wide range of type scenarios, we&amp;rsquo;ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</source>
          <target state="translated">С типами объединения, способными представлять широкий спектр сценариев типов, мы решили повысить строгость некоторых общих вызовов. Раньше такой код (что удивительно) компилировался без ошибок:</target>
        </trans-unit>
        <trans-unit id="4aaf334cc02fe3036ee03973d99bc9627c8d8c34" translate="yes" xml:space="preserve">
          <source>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</source>
          <target state="translated">В случае с объединением типов,теперь вы можете указать желаемое поведение как на сайте объявления функций,так и на сайте вызова:</target>
        </trans-unit>
        <trans-unit id="cfa2a879186e45980c1b4dd8c08f6c7e24cfb812" translate="yes" xml:space="preserve">
          <source>With:</source>
          <target state="translated">With:</target>
        </trans-unit>
        <trans-unit id="1faa6ed78c77561690bfff2329835e7f699fad40" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method), but the &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Location&lt;/code&gt; classes are not.</source>
          <target state="translated">В &lt;code&gt;Control&lt;/code&gt; класса можно получить доступ к &lt;code&gt;state&lt;/code&gt; закрытому члену через экземпляр &lt;code&gt;SelectableControl&lt;/code&gt; . По сути, &lt;code&gt;SelectableControl&lt;/code&gt; действует как &lt;code&gt;Control&lt;/code&gt; , который, как известно, имеет метод &lt;code&gt;select&lt;/code&gt; . В &lt;code&gt;Button&lt;/code&gt; и &lt;code&gt;TextBox&lt;/code&gt; классов являются подтипами &lt;code&gt;SelectableControl&lt;/code&gt; (потому что они оба наследуют от &lt;code&gt;Control&lt;/code&gt; и имеют &lt;code&gt;select&lt;/code&gt; метода), но &lt;code&gt;Image&lt;/code&gt; и &lt;code&gt;Location&lt;/code&gt; классы не являются.</target>
        </trans-unit>
        <trans-unit id="40659a03fa7e7592baf48c7a0c5720e665372319" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method). The &lt;code&gt;ImageControl&lt;/code&gt; class has it&amp;rsquo;s own &lt;code&gt;state&lt;/code&gt; private member rather than extending &lt;code&gt;Control&lt;/code&gt;, so it cannot implement &lt;code&gt;SelectableControl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11991f5f3539f8365b2755a33096a790d376c466" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extends&lt;/code&gt; clause of a conditional type, it is now possible to have &lt;code&gt;infer&lt;/code&gt; declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple &lt;code&gt;infer&lt;/code&gt; locations for the same type variable.</source>
          <target state="translated">В предложении &lt;code&gt;extends&lt;/code&gt; условного типа теперь можно иметь объявления &lt;code&gt;infer&lt;/code&gt; которые вводят переменную типа, которая должна выводиться. На такие переменные предполагаемого типа можно ссылаться в истинной ветви условного типа. Для переменной одного и того же типа можно иметь несколько &lt;code&gt;infer&lt;/code&gt; местоположений.</target>
        </trans-unit>
        <trans-unit id="025d407dde53ca8d56d3a7b67f8687df35d8b119" translate="yes" xml:space="preserve">
          <source>Within the same block duplicate definitions are still disallowed.</source>
          <target state="translated">Внутри одного и того же блока дубликаты определений по-прежнему запрещены.</target>
        </trans-unit>
        <trans-unit id="9735c33d4a9302da353c7b0e0f8ad6d2bbb66115" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;downlevelIteration&lt;/code&gt; enabled, a &lt;code&gt;for / of&lt;/code&gt; loop on any object is downleveled to a traditional &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244687c671b9bf5c3bf00c75ac23daf9254dabd2" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;ScientificCalculator&lt;/code&gt; would not have been able to extend &lt;code&gt;BasicCalculator&lt;/code&gt; and keep the fluent interface. &lt;code&gt;multiply&lt;/code&gt; would have returned &lt;code&gt;BasicCalculator&lt;/code&gt;, which doesn&amp;rsquo;t have the &lt;code&gt;sin&lt;/code&gt; method. However, with &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;multiply&lt;/code&gt; returns &lt;code&gt;this&lt;/code&gt;, which is &lt;code&gt;ScientificCalculator&lt;/code&gt; here.</source>
          <target state="translated">Без &lt;code&gt;this&lt;/code&gt; типов &lt;code&gt;ScientificCalculator&lt;/code&gt; не смог бы расширить &lt;code&gt;BasicCalculator&lt;/code&gt; и сохранить плавный интерфейс. &lt;code&gt;multiply&lt;/code&gt; вернул бы &lt;code&gt;BasicCalculator&lt;/code&gt; , в котором нет метода &lt;code&gt;sin&lt;/code&gt; . Однако для &lt;code&gt;this&lt;/code&gt; типов &lt;code&gt;multiply&lt;/code&gt; возвращает &lt;code&gt;this&lt;/code&gt; , в данном случае это &lt;code&gt;ScientificCalculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e062851d9b41c2fc52e761a5a5db277213a8a79" translate="yes" xml:space="preserve">
          <source>Without generics, we would either have to give the identity function a specific type:</source>
          <target state="translated">Без дженериков мы либо должны были бы придать функции идентификации определенный тип:</target>
        </trans-unit>
        <trans-unit id="94acabacd4951abae06ed7d329ea42ae0a58c740" translate="yes" xml:space="preserve">
          <source>Without knowledge of the values of these members, other transpilers can&amp;rsquo;t replace the references to &lt;code&gt;Number&lt;/code&gt;, which would be a runtime error if left alone (since there are no &lt;code&gt;Numbers&lt;/code&gt; object at runtime). Because of this, when &lt;code&gt;isolatedModules&lt;/code&gt; is set, it is an error to reference an ambient &lt;code&gt;const enum&lt;/code&gt; member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c884ae62ed0b7457d954e4a71482e1be406a95c" translate="yes" xml:space="preserve">
          <source>Without knowledge of the values of these members, other transpilers can&amp;rsquo;t replace the references to &lt;code&gt;Numbers&lt;/code&gt;, which would be a runtime error if left alone (since there are no &lt;code&gt;Numbers&lt;/code&gt; object at runtime). Because of this, when &lt;code&gt;isolatedModules&lt;/code&gt; is set, it is an error to reference an ambient &lt;code&gt;const enum&lt;/code&gt; member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00201f849d1c48c82416c11f802e9a66c3600782" translate="yes" xml:space="preserve">
          <source>Without setting &lt;code&gt;removeComments&lt;/code&gt; or having it as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac4729283ab9e6a4c94196cc65d3824136d4f5b" translate="yes" xml:space="preserve">
          <source>Without this flag, TypeScript will allow you to use the dot syntax to access fields which are not defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f67c21f22ceab8ce26ba774a06869c3e5ea9d49" translate="yes" xml:space="preserve">
          <source>Working with Generic Type Variables</source>
          <target state="translated">Работа с общими переменными типа</target>
        </trans-unit>
        <trans-unit id="5dec7390553f0c8e11febdec62abeb23d870ba14" translate="yes" xml:space="preserve">
          <source>Working with Other JavaScript Libraries</source>
          <target state="translated">Работа с другими библиотеками JavaScript</target>
        </trans-unit>
        <trans-unit id="0e5c5aeb5b5c1f3bc5c5f5f8d62b7bc1a585d5dc" translate="yes" xml:space="preserve">
          <source>Works in tandem with &lt;code&gt;allowJs&lt;/code&gt;. When &lt;code&gt;checkJs&lt;/code&gt; is enabled then errors are reported in JavaScript files. This is the equivalent of including &lt;code&gt;// @ts-check&lt;/code&gt; at the top of all JavaScript files which are included in your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb174c18ecc84cb0d3bcf90788707696b007bc5" translate="yes" xml:space="preserve">
          <source>Would add &lt;code&gt;preact/jsx-runtime&lt;/code&gt; as an import for the &lt;code&gt;_jsx&lt;/code&gt; factory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584f179f141358ddf434da1f8a8d5abbc0ae519b" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have a source file at &lt;code&gt;https://my-website.com/debug/source/index.ts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efdb26317cc1befd0965c705beeabd7a3facadd" translate="yes" xml:space="preserve">
          <source>Would declare that &lt;code&gt;index.js&lt;/code&gt; will have sourcemaps at &lt;code&gt;https://my-website.com/debug/sourcemaps/index.js.map&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6170858562fd81d218ec9a03c46f20224b39cf2" translate="yes" xml:space="preserve">
          <source>Would echo paths like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1231a1512daa0744414ea3f58fde0c7b8ae3edc8" translate="yes" xml:space="preserve">
          <source>Would look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c17b2d1a864a8fcd44eef5059b45f5c7e951923" translate="yes" xml:space="preserve">
          <source>Would place the d.ts for the &lt;code&gt;index.ts&lt;/code&gt; in a &lt;code&gt;types&lt;/code&gt; folder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb6c46801aca7729ea1a91a878ce6c995fb3d2b" translate="yes" xml:space="preserve">
          <source>Write a .d.ts declaration for a simple function, object, or class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944e87083d9fc0d208f24e3ca6004e001d6ee8c0" translate="yes" xml:space="preserve">
          <source>Write a HTML page</source>
          <target state="translated">Написать HTML-страницу</target>
        </trans-unit>
        <trans-unit id="9a3206c5e21cfc9c171ea878cfc1acee74565cd8" translate="yes" xml:space="preserve">
          <source>Write a simple example</source>
          <target state="translated">Напишите простой пример</target>
        </trans-unit>
        <trans-unit id="e885a108400a007a39fa103119566542fbe5da72" translate="yes" xml:space="preserve">
          <source>Write some code</source>
          <target state="translated">Напишите код</target>
        </trans-unit>
        <trans-unit id="efab40cfd729fdef6a3321a502f603a5fd3d1efd" translate="yes" xml:space="preserve">
          <source>Write-only references now flagged as unused</source>
          <target state="translated">Ссылки только для записи теперь помечены как неиспользуемые</target>
        </trans-unit>
        <trans-unit id="1f09dbf6607d2b3a3fef434b06897c0d44094e34" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive atop every generated file.</source>
          <target state="translated">Пишет &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; директива поверх каждого сгенерированного файла.</target>
        </trans-unit>
        <trans-unit id="caefe3ddb12a11eef5e5aa559be74af44b08a512" translate="yes" xml:space="preserve">
          <source>Writing a Configuration File</source>
          <target state="translated">Написание файла конфигурации</target>
        </trans-unit>
        <trans-unit id="8d3bf80dd76a472762dc04013242f325f5d4630a" translate="yes" xml:space="preserve">
          <source>Writing the function type</source>
          <target state="translated">Запись типа функции</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="124e1188da963d3aaab4e295c7a108fbd2a41dd4" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see:</source>
          <target state="translated">Вы &lt;em&gt;не&lt;/em&gt; увидите:</target>
        </trans-unit>
        <trans-unit id="a0826b2d3de77311d09a836d3625c330fde392d4" translate="yes" xml:space="preserve">
          <source>You also need to include &lt;code&gt;esnext&lt;/code&gt; in your &lt;code&gt;--lib&lt;/code&gt; option, to get the &lt;code&gt;AsyncIterator&lt;/code&gt; declaration if you do not already have it.</source>
          <target state="translated">Вам также необходимо включить &lt;code&gt;esnext&lt;/code&gt; в вашу опцию &lt;code&gt;--lib&lt;/code&gt; , чтобы получить объявление &lt;code&gt;AsyncIterator&lt;/code&gt; , если у вас его еще нет.</target>
        </trans-unit>
        <trans-unit id="9dbfe774d94760df702cae74c61861ed61736c9f" translate="yes" xml:space="preserve">
          <source>You are not sure that TypeScript has included a file you expected, as a part of debugging the &lt;a href=&quot;#Project_Files_0&quot;&gt;file inclusion settings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb77374dde597ec3f89f049a8b2572ac5e594b0" translate="yes" xml:space="preserve">
          <source>You are using TypeScript to only generate &lt;code&gt;d.ts&lt;/code&gt; files for your consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61cc6e69930635f4f2ec81f40d529f5f6496336" translate="yes" xml:space="preserve">
          <source>You are using a transpiler other than TypeScript to generate your JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d178984134105b099386ca1a8bdc43d115ba87" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;see more details in the pull request&lt;/a&gt;.</source>
          <target state="translated">Вы можете &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;увидеть более подробную информацию в запросе на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc0ff3454e62e27b1d1616762b98ba9e340784f" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;read up more about this change by reading up on its pull request&lt;/a&gt;.</source>
          <target state="translated">Вы можете &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;узнать больше об этом изменении, прочитав его запрос на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2d37b1f71e5cef3cd269ee2fede52081b3627c" translate="yes" xml:space="preserve">
          <source>You can also add declarations to the global scope from inside a module:</source>
          <target state="translated">Объявления можно также добавлять в глобальную область применения изнутри модуля:</target>
        </trans-unit>
        <trans-unit id="aa5e7508cbf31286f90d3fa92778943caff41bbb" translate="yes" xml:space="preserve">
          <source>You can also create nested namespaces in one declaration:</source>
          <target state="translated">Вы также можете создавать вложенные пространства имен в одном объявлении:</target>
        </trans-unit>
        <trans-unit id="c9e0636992c973f4dd8a12b1aab83b4e3dc21c83" translate="yes" xml:space="preserve">
          <source>You can also describe methods in an interface that are implemented in the class, as we do with &lt;code&gt;setTime&lt;/code&gt; in the below example:</source>
          <target state="translated">Вы также можете описать методы в интерфейсе, которые реализованы в классе, как мы это делаем с &lt;code&gt;setTime&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="10881a4ac29a88d1e8e385325bacc892d71cbc57" translate="yes" xml:space="preserve">
          <source>You can also destructure objects:</source>
          <target state="translated">Вы также можете уничтожать объекты:</target>
        </trans-unit>
        <trans-unit id="f263658c8957170383fc6acd098a9e253a17a6eb" translate="yes" xml:space="preserve">
          <source>You can also enable prepending the output of a dependency using the &lt;code&gt;prepend&lt;/code&gt; option in a reference:</source>
          <target state="translated">Вы также можете включить добавление вывода зависимости, используя опцию &lt;code&gt;prepend&lt;/code&gt; в ссылке:</target>
        </trans-unit>
        <trans-unit id="7a3ee9c0b30719b4ec3010d9b67f41513948956a" translate="yes" xml:space="preserve">
          <source>You can also give different names to properties:</source>
          <target state="translated">Вы также можете давать различные имена объектам недвижимости:</target>
        </trans-unit>
        <trans-unit id="46914e5a790630d332743102ee7c0fd4a1d3bfaa" translate="yes" xml:space="preserve">
          <source>You can also import commonjs modules &amp;mdash; modules written using node.js&amp;rsquo; module system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57504dce8579275ca3fec263bbff7e03026c0c14" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56c11bed0da0fe19acfcb08f266a5ef3e86db8" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is Typescript-specific and differs from the JSDoc standard:</source>
          <target state="translated">Вы также можете импортировать декларации из других файлов,используя типы импорта.Этот синтаксис специфичен для Typescript и отличается от стандарта JSDoc:</target>
        </trans-unit>
        <trans-unit id="dca8a7aa37da66a7e0661bda41e830a52a5189ae" translate="yes" xml:space="preserve">
          <source>You can also override existing properties and add new ones:</source>
          <target state="translated">Вы также можете переопределить существующие свойства и добавить новые:</target>
        </trans-unit>
        <trans-unit id="e783edc2ccbd9e24ba2f903e758def00265edb8b" translate="yes" xml:space="preserve">
          <source>You can also run into errors with &lt;code&gt;this&lt;/code&gt; in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. With some work you can use &lt;code&gt;this&lt;/code&gt; parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Вы также можете столкнуться с ошибками из-за &lt;code&gt;this&lt;/code&gt; в обратных вызовах, когда вы передаете функции в библиотеку, которая позже будет их вызывать. Поскольку библиотека, которая вызывает ваш обратный вызов, будет вызывать его как обычную функцию, &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; . После некоторой работы вы можете использовать &lt;code&gt;this&lt;/code&gt; параметры для предотвращения ошибок и с обратными вызовами. Во-первых, автору библиотеки необходимо аннотировать тип обратного вызова &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8bc617eb0b3c708d101d575cea082665b2e4c486" translate="yes" xml:space="preserve">
          <source>You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:</source>
          <target state="translated">Также можно указать ограничение по типу перед именем параметра типа.Ограничением является только первый параметр типа в списке:</target>
        </trans-unit>
        <trans-unit id="d00d3142af394bb2294c1c64058dcebe2e496a01" translate="yes" xml:space="preserve">
          <source>You can also specify object literal types. For example, an object with properties &amp;lsquo;a&amp;rsquo; (string) and &amp;lsquo;b&amp;rsquo; (number) uses the following syntax:</source>
          <target state="translated">Вы также можете указать типы литералов объекта. Например, объект со свойствами 'a' (строка) и 'b' (число) использует следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="fe8328cdac7d502c96b86354aece870f05fd04b3" translate="yes" xml:space="preserve">
          <source>You can also spread objects:</source>
          <target state="translated">Также можно распространять объекты:</target>
        </trans-unit>
        <trans-unit id="1908bbe93e9847a90199e01d70ec2bf4ba120262" translate="yes" xml:space="preserve">
          <source>You can also update your IDE to use the nightly drop. First you will need to install the package through npm. You can either install the npm package globally or to a local &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">Вы также можете обновить свою IDE, чтобы использовать ночной дроп. Сначала вам нужно будет установить пакет через npm. Вы можете установить пакет npm глобально или в локальную папку &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd769df0df5d6f0aa6315e5bbbcccdf2351c2f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;em&gt;template strings&lt;/em&gt;, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (&lt;code&gt;`&lt;/code&gt;) character, and embedded expressions are of the form &lt;code&gt;${ expr }&lt;/code&gt;.</source>
          <target state="translated">Вы также можете использовать &lt;em&gt;строки шаблона&lt;/em&gt; , которые могут занимать несколько строк и содержать встроенные выражения. Эти строки окружены символом обратной кавычки / обратной кавычки ( &lt;code&gt;`&lt;/code&gt; ), а встроенные выражения имеют форму &lt;code&gt;${ expr }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8642a91579cb79f285b253bbe1a7a6a5ff3ec30" translate="yes" xml:space="preserve">
          <source>You can also use a const-assertion, which operates on arrays and object literals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf980f17e02d8f2a94115cf1b8ed0aa09a9c8f3" translate="yes" xml:space="preserve">
          <source>You can also use a union type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55dd36012d4dbcf4dacc5832f2294fe2f575c7c" translate="yes" xml:space="preserve">
          <source>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</source>
          <target state="translated">Вы можете присвоить объект буквально непосредственно свойству prototype.Индивидуальное назначение прототипа тоже работает:</target>
        </trans-unit>
        <trans-unit id="8c16422cd5326d69a5eb84cd5f6aae392dfed484" translate="yes" xml:space="preserve">
          <source>You can call the function &lt;code&gt;greet&lt;/code&gt; with a string to show a greeting to the user.</source>
          <target state="translated">Вы можете вызвать функцию &lt;code&gt;greet&lt;/code&gt; со строкой, чтобы показать пользователю приветствие.</target>
        </trans-unit>
        <trans-unit id="1a7ff571453a3f2b2057590cf96aa4493691af9b" translate="yes" xml:space="preserve">
          <source>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called &lt;em&gt;discriminated unions&lt;/em&gt;, also known as &lt;em&gt;tagged unions&lt;/em&gt; or &lt;em&gt;algebraic data types&lt;/em&gt;. Discriminated unions are useful in functional programming. Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</source>
          <target state="translated">Вы можете комбинировать одноточечно типов, типов союзов, охранников типа и псевдонимов типа построить продвинутую картину под названием &lt;em&gt;дискриминационных профсоюзы&lt;/em&gt; , также известную как &lt;em&gt;меченые союзы&lt;/em&gt; или &lt;em&gt;алгебраические типы данных&lt;/em&gt; . Дискриминационные союзы полезны в функциональном программировании. Некоторые языки автоматически определяют профсоюзы за вас; TypeScript вместо этого основывается на шаблонах JavaScript в том виде, в каком они существуют сегодня. Всего три ингредиента:</target>
        </trans-unit>
        <trans-unit id="6d357850b01dac1eeac6457b17d7ca5319c972ef" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Point&lt;/code&gt; by assigning an object literal. After the assignment, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can&amp;rsquo;t be changed.</source>
          <target state="translated">Вы можете создать &lt;code&gt;Point&lt;/code&gt; , назначив литерал объекта. После присвоения &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; изменить нельзя.</target>
        </trans-unit>
        <trans-unit id="4fb6b2a81bd2b7aaa5985f5e53a25640c10196cd" translate="yes" xml:space="preserve">
          <source>You can create a greeter by instantiating the &lt;code&gt;Greeter&lt;/code&gt; object, or create a customized greeter by extending from it.</source>
          <target state="translated">Вы можете создать средство приветствия, создав экземпляр объекта &lt;code&gt;Greeter&lt;/code&gt; , или создать настраиваемое средство приветствия, расширив его.</target>
        </trans-unit>
        <trans-unit id="75665cb8837cc0487308ee22852413c93f1fc259" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in a list using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">Вы можете создать переменную для оставшихся элементов в списке, используя синтаксис &lt;code&gt;...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8460f1444f4aa17633ac5c787a8314796932f6a5" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in an object using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">Вы можете создать переменную для остальных элементов объекта, используя синтаксис &lt;code&gt;...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="671e7dc200d0c80a25936e430c7090352f3d72ae" translate="yes" xml:space="preserve">
          <source>You can declare a type parameter that is constrained by another type parameter. For example, here we&amp;rsquo;d like to get a property from an object given its name. We&amp;rsquo;d like to ensure that we&amp;rsquo;re not accidentally grabbing a property that does not exist on the &lt;code&gt;obj&lt;/code&gt;, so we&amp;rsquo;ll place a constraint between the two types:</source>
          <target state="translated">Вы можете объявить параметр типа, который ограничен другим параметром типа. Например, здесь мы хотим получить свойство от объекта по его имени. Мы хотели бы убедиться, что мы случайно не захватим свойство, которого нет в &lt;code&gt;obj&lt;/code&gt; , поэтому мы поместим ограничение между двумя типами:</target>
        </trans-unit>
        <trans-unit id="bb0d4186733111c3ff772adfa9929d9115f1fe52" translate="yes" xml:space="preserve">
          <source>You can declare generic functions with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f192a3654a48e7ea0a0cc0a370781ac7a446e607" translate="yes" xml:space="preserve">
          <source>You can declare generic types with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="translated">Вы можете объявить универсальные типы с помощью тега &lt;code&gt;@template&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39c755b295968915cb7f36206ab4acb5152d4feb" translate="yes" xml:space="preserve">
          <source>You can declare your own types that use generics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125273b21991da50ace34ccf074e5c40f14c2af0" translate="yes" xml:space="preserve">
          <source>You can define a root folder where you can do absolute file resolution. E.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc9cd9cf610e86ca2fc0386a0460cd60dd0d41d" translate="yes" xml:space="preserve">
          <source>You can explicitly describe this object&amp;rsquo;s shape using an &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8f084feb2f8af2ede413a048aa5f0369d9c8d1" translate="yes" xml:space="preserve">
          <source>You can explore the source code for the &lt;a href=&quot;https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts&quot;&gt;DOM type definitions&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e46331273cd57070033fdf01cbe89968dccfda4" translate="yes" xml:space="preserve">
          <source>You can export with an export list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c976f009cdbf256d8a8056997c9ba760d321e8" translate="yes" xml:space="preserve">
          <source>You can find documentation on TypeScript projects in &lt;a href=&quot;docs/handbook/project-references&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3447a0f97b5b49eecb748e301d9ac2eec21d57cb" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/api.md&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9a4311f9cdef796f23298f9df9ad3c9567377d" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/api.md#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578813d014f5da6ccea41bacd872a0d259c87786" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="translated">Дополнительную документацию по baseUrl можно найти в документации по &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; и &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3565b07531ff1df206f19c27fc9bf382f93d1b9c" translate="yes" xml:space="preserve">
          <source>You can find out more about decorator support in TypeScript in &lt;a href=&quot;docs/handbook/decorators&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba620983de41a7ef95236f421d1dc97955b1aa9" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;#supported-jsdoc&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Вы можете найти полный список поддерживаемых шаблонов JSDoc &lt;a href=&quot;#supported-jsdoc&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34fda10118f041f159330cd7abc22afc3606cf87" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;jsdoc-supported-types&quot;&gt;in JSDoc Supported Types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c476c80d4a52dce79024022ae48c95db9d5b6f4d" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f608f667f472aa22cebd5f33fb938554db51b9e" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of definition by understanding some key concepts of how TypeScript works.</source>
          <target state="translated">Вы можете полностью понять,как сделать любую форму определения,понимая некоторые ключевые концепции того,как работает TypeScript.</target>
        </trans-unit>
        <trans-unit id="ffbbf130c4a666890a749997011788aa15e53216" translate="yes" xml:space="preserve">
          <source>You can have TypeScript raise errors when this happens via the compiler flag &lt;code&gt;strictFunctionTypes&lt;/code&gt;.</source>
          <target state="translated">Вы можете вызвать ошибки TypeScript, когда это происходит через флаг компилятора &lt;code&gt;strictFunctionTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7cf81fd3fe04126a6e45600ef8b2c4d2d493009" translate="yes" xml:space="preserve">
          <source>You can install this library via npm:</source>
          <target state="translated">Вы можете установить эту библиотеку через npm:</target>
        </trans-unit>
        <trans-unit id="6152873a2f68376c518851001d0d205cfc51fe07" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68173b0a46e94261744a5e3bad0e83f40a64e4d8" translate="yes" xml:space="preserve">
          <source>You can learn how to do this in our &lt;a href=&quot;https://www.typescriptlang.org/download&quot;&gt;installation page&lt;/a&gt;. You want to make sure these files are included in your package if you have the files in your project&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947cee68bd128ad7579db636c222ec6f612e50a8" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;tsconfig.json&lt;/code&gt; files &lt;a href=&quot;tsconfig-json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о файлах &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;a href=&quot;tsconfig-json&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0002bbb784dd22adfca99735cd3bee016fc7bc2f" translate="yes" xml:space="preserve">
          <source>You can learn more about configuring webpack &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о настройке webpack &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11a81cf552959831fd7e6995da492be14d30da53" translate="yes" xml:space="preserve">
          <source>You can learn more about how to measure and understand the output in the performance &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;section of the wiki&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd112a39c804a14040d8ee141d2691324c73c733" translate="yes" xml:space="preserve">
          <source>You can learn more about the options in the &lt;a href=&quot;https://www.typescriptlang.org/reference&quot;&gt;tsconfig reference&lt;/a&gt;. An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acea5010ea541a31bcbc5992b38da22bdf966f2" translate="yes" xml:space="preserve">
          <source>You can make properties readonly by using the &lt;code&gt;readonly&lt;/code&gt; keyword. Readonly properties must be initialized at their declaration or in the constructor.</source>
          <target state="translated">Вы можете сделать свойства доступными только для чтения, используя ключевое слово &lt;code&gt;readonly&lt;/code&gt; . Свойства только для чтения должны быть инициализированы при их объявлении или в конструкторе.</target>
        </trans-unit>
        <trans-unit id="5ac33330400d5a0e5b89b577a3c10f0de7e4e12f" translate="yes" xml:space="preserve">
          <source>You can now define an &lt;em&gt;alias&lt;/em&gt; for a type using the &lt;code&gt;type&lt;/code&gt; keyword:</source>
          <target state="translated">Теперь вы можете определить &lt;em&gt;псевдоним&lt;/em&gt; для типа с помощью ключевого слова &lt;code&gt;type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e434657788b8ddc40cdc0edab54832db855ade3" translate="yes" xml:space="preserve">
          <source>You can pass any of the three allowed strings, but any other string will give the error</source>
          <target state="translated">Вы можете передать любую из трех разрешенных строк,но любая другая строка выдаст ошибку</target>
        </trans-unit>
        <trans-unit id="d470740bd26919fb50f6301789d422e287938cf6" translate="yes" xml:space="preserve">
          <source>You can provide &lt;code&gt;tsc -b&lt;/code&gt; with multiple config file paths (e.g. &lt;code&gt;tsc -b src test&lt;/code&gt;). Just like &lt;code&gt;tsc -p&lt;/code&gt;, specifying the config file name itself is unnecessary if it&amp;rsquo;s named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">Вы можете &lt;code&gt;tsc -b&lt;/code&gt; с несколькими путями к файлам конфигурации (например, &lt;code&gt;tsc -b src test&lt;/code&gt; ). Как и &lt;code&gt;tsc -p&lt;/code&gt; , указывать само имя файла конфигурации не нужно, если он называется &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8c2c8135b90f55175c15912e8774ea2151cd6c3" translate="yes" xml:space="preserve">
          <source>You can read more about how references works in the &lt;a href=&quot;docs/handbook/project-references&quot;&gt;Project References&lt;/a&gt; section of the handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0c4b0cf188a255ee3afb8b2ea5e76910a20990" translate="yes" xml:space="preserve">
          <source>You can read more about the process in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;loading modules from &lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о процессе в документации Node.js по &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;загрузке модулей из &lt;code&gt;node_modules&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45ae7c33d245bc14dc13773d18d87a71cb89dde7" translate="yes" xml:space="preserve">
          <source>You can read more about the transition in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the 3.7 release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5500a793cafd40811d12bec320b636a9073b8503" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;docs/handbook/module-resolution#tracing-module-resolution&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dbf3245e466cb4f090abb7404f3d0e9c3f028b" translate="yes" xml:space="preserve">
          <source>You can read more about this in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#better-directory-watching-on-linux-and-watchoptions&quot;&gt;the release notes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c1237490875a34de9e3a6f34ec2e6bab8560cf" translate="yes" xml:space="preserve">
          <source>You can read more about this in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;file modules&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;folder modules&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше об этом в документации Node.js о &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;файловых модулях&lt;/a&gt; и &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;модулях папок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecd3a208f74e578df2b2a2fa60c227e643c4ba88" translate="yes" xml:space="preserve">
          <source>You can read the type of &lt;code&gt;loggingIdentity&lt;/code&gt; as &amp;ldquo;the generic function &lt;code&gt;loggingIdentity&lt;/code&gt; takes a type parameter &lt;code&gt;T&lt;/code&gt;, and an argument &lt;code&gt;arg&lt;/code&gt; which is an array of &lt;code&gt;T&lt;/code&gt;s, and returns an array of &lt;code&gt;T&lt;/code&gt;s.&amp;rdquo; If we passed in an array of numbers, we&amp;rsquo;d get an array of numbers back out, as &lt;code&gt;T&lt;/code&gt; would bind to &lt;code&gt;number&lt;/code&gt;. This allows us to use our generic type variable &lt;code&gt;T&lt;/code&gt; as part of the types we&amp;rsquo;re working with, rather than the whole type, giving us greater flexibility.</source>
          <target state="translated">Вы можете прочитать тип &lt;code&gt;loggingIdentity&lt;/code&gt; как &amp;laquo;универсальная функция &lt;code&gt;loggingIdentity&lt;/code&gt; принимает параметр типа &lt;code&gt;T&lt;/code&gt; и аргумент &lt;code&gt;arg&lt;/code&gt; , который является массивом &lt;code&gt;T&lt;/code&gt; s, и возвращает массив &lt;code&gt;T&lt;/code&gt; s&amp;raquo;. Если бы мы передали массив чисел, мы бы получили обратно массив чисел, так как &lt;code&gt;T&lt;/code&gt; привязывается к &lt;code&gt;number&lt;/code&gt; . Это позволяет нам использовать переменную универсального типа &lt;code&gt;T&lt;/code&gt; как часть типов, с которыми мы работаем, а не как весь тип, что дает нам большую гибкость.</target>
        </trans-unit>
        <trans-unit id="39f93a09cc5f4b2491c0b2ccab1b26b016dd256f" translate="yes" xml:space="preserve">
          <source>You can see an example DTS below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb82b9593a1fc045e2a68f5072eaf1a1f4d845d" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4219455f5a7b401b488cbe6f3cc25db24a4f9204" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть пример использования Webpack в нашем &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;руководстве по React и Webpack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="522afc6f6129110c8704aded05f62e148f7fcfe8" translate="yes" xml:space="preserve">
          <source>You can see these patterns in the TypeScript repo - see &lt;code&gt;src/tsconfig_base.json&lt;/code&gt;, &lt;code&gt;src/tsconfig.json&lt;/code&gt;, and &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; as key examples.</source>
          <target state="translated">Вы можете увидеть эти шаблоны в &lt;code&gt;src/tsconfig_base.json&lt;/code&gt; TypeScript - см. Src / tsconfig_base.json , &lt;code&gt;src/tsconfig.json&lt;/code&gt; и &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; в качестве ключевых примеров.</target>
        </trans-unit>
        <trans-unit id="342e97c124555c4631ae12805973e016d0bd72c0" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line.</source>
          <target state="translated">Вы можете пропустить проверку некоторых файлов, добавив к ним комментарий &lt;code&gt;// @ts-nocheck&lt;/code&gt; ; и наоборот, вы можете проверить только несколько файлов &lt;code&gt;.js&lt;/code&gt; , добавив к ним комментарий &lt;code&gt;// @ts-check&lt;/code&gt; без установки &lt;code&gt;--checkJs&lt;/code&gt; . Вы также можете игнорировать ошибки в определенных строках, добавив &lt;code&gt;// @ts-ignore&lt;/code&gt; в предыдущую строку.</target>
        </trans-unit>
        <trans-unit id="964c60dd8551d7582983d7537470492d6195db2c" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely, you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line. Note that if you have a &lt;code&gt;tsconfig.json&lt;/code&gt;, JS checking will respect strict flags like &lt;code&gt;noImplicitAny&lt;/code&gt;, &lt;code&gt;strictNullChecks&lt;/code&gt;, etc. However, because of the relative looseness of JS checking, combining strict flags with it may be surprising.</source>
          <target state="translated">Вы можете пропустить проверку некоторых файлов, добавив к ним комментарий &lt;code&gt;// @ts-nocheck&lt;/code&gt; ; и наоборот, вы можете выбрать для проверки только несколько файлов &lt;code&gt;.js&lt;/code&gt; , добавив к ним комментарий &lt;code&gt;// @ts-check&lt;/code&gt; без установки &lt;code&gt;--checkJs&lt;/code&gt; . Вы также можете игнорировать ошибки в определенных строках, добавив &lt;code&gt;// @ts-ignore&lt;/code&gt; в предыдущую строку. Обратите внимание, что если у вас есть &lt;code&gt;tsconfig.json&lt;/code&gt; , проверка JS будет &lt;code&gt;noImplicitAny&lt;/code&gt; строгие флаги, такие как noImplicitAny , &lt;code&gt;strictNullChecks&lt;/code&gt; и т. Д. Однако из-за относительной слабости проверки JS объединение с ней строгих флагов может быть неожиданным.</target>
        </trans-unit>
        <trans-unit id="a94719f47d299841e6e51ceee5706dcecbbee79d" translate="yes" xml:space="preserve">
          <source>You can specify any number of config files:</source>
          <target state="translated">Вы можете указать любое количество конфигурационных файлов:</target>
        </trans-unit>
        <trans-unit id="49e57a0ea093e19313c1e384f922d69417882b6c" translate="yes" xml:space="preserve">
          <source>You can specify array types using a variety of syntaxes:</source>
          <target state="translated">Вы можете задавать типы массивов,используя различные синтаксисы:</target>
        </trans-unit>
        <trans-unit id="a70277082e31e5e52d3d480b2d3e85e69cad3826" translate="yes" xml:space="preserve">
          <source>You can specify function types using either TypeScript or Closure syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34efcdea59af77ca626a5d378a5a510fc13373a4" translate="yes" xml:space="preserve">
          <source>You can specify function types using either Typescript or Closure syntax:</source>
          <target state="translated">Вы можете указать типы функций,используя либо Typescript,либо синтаксис Closure:</target>
        </trans-unit>
        <trans-unit id="374bf1cc94385f96a421817886992b3a7d544791" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7d6f924eeeb484fecdc0bbd17378d7530144b6" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or Typescript syntax.</source>
          <target state="translated">Вы можете указать объекты,похожие на карты и массивы,используя строковые и числовые индексы,используя либо стандартный синтаксис JSDoc,либо синтаксис Typescript.</target>
        </trans-unit>
        <trans-unit id="e5b4c27e6b170dfa095f022ece8aad3250bbb88a" translate="yes" xml:space="preserve">
          <source>You can specify the type of &lt;em&gt;children&lt;/em&gt; like any other attribute. This will override the default type from, eg the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt; if you use them.</source>
          <target state="translated">Вы можете указать тип &lt;em&gt;дочерних&lt;/em&gt; элементов, как и любой другой атрибут. Это переопределит тип по умолчанию, например, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;типы React,&lt;/a&gt; если вы их используете.</target>
        </trans-unit>
        <trans-unit id="aa5974276811e58130f1843d3263db447637e938" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt; in your tsconfig.json&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37fd121d8b3692df1ee3680ad29d96a4b8894ae" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option in your &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; file.</source>
          <target state="translated">Вы можете указать этот режим с помощью &lt;code&gt;--jsx&lt;/code&gt; командной строки --jsx или соответствующей опции в файле &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e710607df82b140e1dbb754cf8fc5b94b8059800" translate="yes" xml:space="preserve">
          <source>You can then declare that a JavaScript object conforms to the shape of your new &lt;code&gt;interface&lt;/code&gt; by using syntax like &lt;code&gt;: TypeName&lt;/code&gt; after a variable declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90dfbdf6b89a09fcab1c28a3e863c8c3729853fd" translate="yes" xml:space="preserve">
          <source>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65236d6747127a47949cb8a9fb216884384fd47" translate="yes" xml:space="preserve">
          <source>You can think of this as TypeScript &amp;ldquo;toughening up&amp;rdquo; the weak guarantees of these types to catch what would otherwise be silent bugs.</source>
          <target state="translated">Вы можете думать об этом как о том, что TypeScript &amp;laquo;усиливает&amp;raquo; слабые гарантии этих типов, чтобы отловить то, что в противном случае было бы скрытыми ошибками.</target>
        </trans-unit>
        <trans-unit id="5097622074f85132325f78b68e79fba79fe3f621" translate="yes" xml:space="preserve">
          <source>You can think of this feature - the &lt;code&gt;??&lt;/code&gt; operator - as a way to &amp;ldquo;fall back&amp;rdquo; to a default value when dealing with &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. When we write code like</source>
          <target state="translated">Вы можете думать об этом особенности - &lt;code&gt;??&lt;/code&gt; оператор - как способ &amp;laquo;отступить&amp;raquo; к значению по умолчанию при работе с &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Когда мы пишем код, как</target>
        </trans-unit>
        <trans-unit id="be980ac4c9e799583178b2189eb7f2bb72eb8228" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt; when you provide your own implementations of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66e09412263a50bdba0d73f81189d39cb3e2051" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; via &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt; to reduce the amount of inline JavaScript too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b09ddf784752f3c6f4d86dc25ca304e62284b0e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;export as namespace&lt;/code&gt; to declare that your module will be available in the global scope in UMD contexts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b715cffb2277991c0db4c0b6b9e109955e0bcf" translate="yes" xml:space="preserve">
          <source>You can use a type alias to make a shorthand for a type:</source>
          <target state="translated">Вы можете использовать псевдоним для обозначения типа:</target>
        </trans-unit>
        <trans-unit id="f059cdce98ff966444670c2070525a863818425c" translate="yes" xml:space="preserve">
          <source>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391c1498a82ae1b3dc563cb57e6b7cbe9562f400" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt; on the first line.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;object&lt;/code&gt; или &lt;code&gt;Object&lt;/code&gt; в первой строке.</target>
        </trans-unit>
        <trans-unit id="73ad51c87d1ff2edbd6bedd2ce2c75e2f55b6846" translate="yes" xml:space="preserve">
          <source>You can use interfaces to annotate parameters and return values to functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446759c7e9287dd9b2744b78bd72e945161fa89b" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use any Typescript type, and most JSDoc types.</source>
          <target state="translated">Вы можете использовать тег &amp;laquo;@type&amp;raquo; и ссылаться на имя типа (либо примитив, определенный в объявлении TypeScript, либо в теге JSDoc &amp;laquo;@typedef&amp;raquo;). Вы можете использовать любой тип TypeScript и большинство типов JSDoc.</target>
        </trans-unit>
        <trans-unit id="46b8562cf700f30f831c7873691acf285a8928d7" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use most JSDoc types and any TypeScript type, from &lt;a href=&quot;basic-types&quot;&gt;the most basic like &lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;advanced-types&quot;&gt;the most advanced, like conditional types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6198a75a95e389a7a03972f1adcbada6802fc1" translate="yes" xml:space="preserve">
          <source>You can use this flag to discover where TypeScript is spending it&amp;rsquo;s time when compiling. This is a tool used for understanding the performance characteristics of your codebase overall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a45fbb2d4cb410ac9052a3f0018033b37e3130" translate="yes" xml:space="preserve">
          <source>You can use this pattern with other parts of the type system to get type-safe lookups.</source>
          <target state="translated">Вы можете использовать этот шаблон с другими частями системы типов для получения безопасного поиска.</target>
        </trans-unit>
        <trans-unit id="ca792ffbb908ece0647bb752e2d90bf39f35c90e" translate="yes" xml:space="preserve">
          <source>You can work around this by using functions to return your classes which differ based on a generic:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcf07ddca5f6840ea854ce2231a54e72513b8b2" translate="yes" xml:space="preserve">
          <source>You can work around this with a type annotation for &lt;code&gt;s&lt;/code&gt;, but that in turn prevents assignments to &lt;code&gt;s&lt;/code&gt; of variables that are not of type &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b5c6c408a6a967509763c765d774adc0ad149" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;mdash; just patches to existing declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df1f23ca2dd7c39f8e49a4cc5f4fc6278b9486d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;ndash; just patches to existing declarations.</source>
          <target state="translated">Вы не можете объявлять новые объявления верхнего уровня в дополнении - просто исправляйте существующие объявления.</target>
        </trans-unit>
        <trans-unit id="81a1eeecad5bacc57bd430d953c632133311eb85" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e3055df49675bbb87854f15fad0bf01e0d93c4" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is readonly.</source>
          <target state="translated">Вы не можете установить &lt;code&gt;myArray[2]&lt;/code&gt; потому что подпись индекса доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="767af037748d5f5e35da8733c684e29d4e2efa46" translate="yes" xml:space="preserve">
          <source>You cannot use decorators to provide mixins via code flow analysis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e14e65723450d9d571a4aeb121d26c5a7c7c1f" translate="yes" xml:space="preserve">
          <source>You could also define the type of &lt;code&gt;options&lt;/code&gt; and add a type assertion on the object literal.</source>
          <target state="translated">Вы также можете определить тип &lt;code&gt;options&lt;/code&gt; и добавить утверждение типа в литерал объекта.</target>
        </trans-unit>
        <trans-unit id="10223649f26ed1ba254c71d5968c360f3987e66e" translate="yes" xml:space="preserve">
          <source>You could argue that this program is correctly typed, since the &lt;code&gt;width&lt;/code&gt; properties are compatible, there&amp;rsquo;s no &lt;code&gt;color&lt;/code&gt; property present, and the extra &lt;code&gt;colour&lt;/code&gt; property is insignificant.</source>
          <target state="translated">Вы можете возразить, что эта программа набрана правильно, поскольку свойства &lt;code&gt;width&lt;/code&gt; совместимы, свойство &lt;code&gt;color&lt;/code&gt; отсутствует, а свойство дополнительного &lt;code&gt;colour&lt;/code&gt; имеет значения.</target>
        </trans-unit>
        <trans-unit id="453e1d8a491394744db85218dccb0ae80c5b3442" translate="yes" xml:space="preserve">
          <source>You could use multiple tsconfig files to solve &lt;em&gt;some&lt;/em&gt; of those problems, but new ones would appear:</source>
          <target state="translated">Вы можете использовать несколько файлов tsconfig для решения &lt;em&gt;некоторых&lt;/em&gt; из этих проблем, но появятся новые:</target>
        </trans-unit>
        <trans-unit id="3c150ba833a45169bc5e39fe665acb71dd66349e" translate="yes" xml:space="preserve">
          <source>You have polyfills or native implementations for some, but not all, of a higher level ECMAScript version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783ca79e34aba59fadb024fdf75ec796a34f288d" translate="yes" xml:space="preserve">
          <source>You may already be familiar with this style of type from other languages. In the next section, we&amp;rsquo;ll cover how you can create your own generic types like &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Возможно, вы уже знакомы с этим стилем шрифта на других языках. В следующем разделе мы рассмотрим, как вы можете создавать свои собственные универсальные типы, такие как &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e224facb474f21f90e2b2be7d6c67fc9a0105ac" translate="yes" xml:space="preserve">
          <source>You may be wondering why we allow &amp;lsquo;discarding&amp;rsquo; parameters like in the example &lt;code&gt;y = x&lt;/code&gt;. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, &lt;code&gt;Array#forEach&lt;/code&gt; provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it&amp;rsquo;s very useful to provide a callback that only uses the first parameter:</source>
          <target state="translated">Вам может быть интересно, почему мы разрешаем &amp;laquo;отбрасывать&amp;raquo; параметры, как в примере &lt;code&gt;y = x&lt;/code&gt; . Причина, по которой это присвоение разрешено, заключается в том, что игнорирование дополнительных параметров функции на самом деле довольно распространено в JavaScript. Например, &lt;code&gt;Array#forEach&lt;/code&gt; предоставляет три параметра функции обратного вызова: элемент массива, его индекс и содержащий массив. Тем не менее, очень полезно предоставить обратный вызов, который использует только первый параметр:</target>
        </trans-unit>
        <trans-unit id="52a0e16871788839263e691e58ca61bc61635cd5" translate="yes" xml:space="preserve">
          <source>You may have noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword is actually a newer JavaScript construct that TypeScript makes available. You can read in the Handbook Reference on &lt;a href=&quot;variable-declarations&quot;&gt;Variable Declarations&lt;/a&gt; more about how &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; fix a lot of the problems with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160fde4a217a4e964a5d1723b8afe990d3ed06e" translate="yes" xml:space="preserve">
          <source>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6203b314b9679b4e6a450edc94780928a6921225" translate="yes" xml:space="preserve">
          <source>You may need to restart VS for the red squiggly lines below &lt;code&gt;UseDefaultFiles&lt;/code&gt; and &lt;code&gt;UseStaticFiles&lt;/code&gt; to disappear.</source>
          <target state="translated">Возможно, вам придется перезапустить VS, чтобы красные волнистые линии под &lt;code&gt;UseDefaultFiles&lt;/code&gt; и &lt;code&gt;UseStaticFiles&lt;/code&gt; исчезли.</target>
        </trans-unit>
        <trans-unit id="5d0a6344f0b1a26e856b642628201bf4d2566c8e" translate="yes" xml:space="preserve">
          <source>You may still mark a member &lt;code&gt;public&lt;/code&gt; explicitly. We could have written the &lt;code&gt;Animal&lt;/code&gt; class from the previous section in the following way:</source>
          <target state="translated">Вы по-прежнему можете явно отметить участника как &lt;code&gt;public&lt;/code&gt; . Мы могли бы написать класс &lt;code&gt;Animal&lt;/code&gt; из предыдущего раздела следующим образом:</target>
        </trans-unit>
        <trans-unit id="7ef83e7afe42eda500cffed4a0d1116b24bc397f" translate="yes" xml:space="preserve">
          <source>You may use the type guard &lt;code&gt;isFish&lt;/code&gt; to filter an array of &lt;code&gt;Fish | Bird&lt;/code&gt; and obtain an array of &lt;code&gt;Fish&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb996842f792b4271e727f1a43257b60e8cebb4e" translate="yes" xml:space="preserve">
          <source>You may want to change these for a few reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf04c61ef2202484a43e999d7405474bf9abd112" translate="yes" xml:space="preserve">
          <source>You may want to provide a type for JavaScript code which does not exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc16c019974ce3ac91057cddfe1e72a32d707b7" translate="yes" xml:space="preserve">
          <source>You may&amp;rsquo;ve noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword was introduced to JavaScript in ES2015 and is now considered the standard because it&amp;rsquo;s safer than &lt;code&gt;var&lt;/code&gt;. We&amp;rsquo;ll discuss the details later, but many common problems in JavaScript are alleviated by using &lt;code&gt;let&lt;/code&gt;, so you should use it instead of &lt;code&gt;var&lt;/code&gt; whenever possible.</source>
          <target state="translated">Возможно, вы заметили, что до сих пор мы использовали ключевое слово &lt;code&gt;let&lt;/code&gt; вместо ключевого слова &lt;code&gt;var&lt;/code&gt; JavaScript, с которым вы, возможно, более знакомы. &lt;code&gt;let&lt;/code&gt; ключевое слово было введено в JavaScript в ES2015 и теперь считается стандартом , потому что это безопаснее , чем &lt;code&gt;var&lt;/code&gt; . Мы обсудим детали позже, но многие общие проблемы в JavaScript решаются с помощью &lt;code&gt;let&lt;/code&gt; , поэтому вы должны использовать его вместо &lt;code&gt;var&lt;/code&gt; , когда это возможно.</target>
        </trans-unit>
        <trans-unit id="c6ca7fd5f06b5916404ff0286e5a8b87e56d87ec" translate="yes" xml:space="preserve">
          <source>You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.</source>
          <target state="translated">Вы также можете выполнять некоторые промежуточные шаги на вашем JavaScript,такие как комплектация или использование другого транспайлера,например Babel.В этом случае,возможно,у вас уже есть структура папок,подобная этой настройке.</target>
        </trans-unit>
        <trans-unit id="77d12568f27dbc483de4e3aa9461fb0fdafcd3b7" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; to say that a value can have any property on it because &lt;code&gt;Object&lt;/code&gt; is, for most purposes, the most general type. However &lt;strong&gt;&lt;code&gt;any&lt;/code&gt; is actually the type you want to use&lt;/strong&gt; in those situations, since it&amp;rsquo;s the most &lt;em&gt;flexible&lt;/em&gt; type.</source>
          <target state="translated">У вас может возникнуть соблазн использовать &lt;code&gt;Object&lt;/code&gt; или &lt;code&gt;{}&lt;/code&gt; , чтобы сказать, что значение может иметь любое свойство, потому что &lt;code&gt;Object&lt;/code&gt; для большинства целей является наиболее общим типом. Однако на &lt;strong&gt;самом деле вы хотите использовать&lt;/strong&gt; в таких ситуациях &lt;strong&gt; &lt;code&gt;any&lt;/code&gt; тип&lt;/strong&gt; , поскольку это наиболее &lt;em&gt;гибкий&lt;/em&gt; тип.</target>
        </trans-unit>
        <trans-unit id="902577569221e3d57d91dd10a280916026992b82" translate="yes" xml:space="preserve">
          <source>You might be wondering about that &lt;code&gt;externals&lt;/code&gt; field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn&amp;rsquo;t change.</source>
          <target state="translated">Вам может быть интересно узнать об этом поле &lt;code&gt;externals&lt;/code&gt; . Мы хотим избежать объединения всего React в один файл, поскольку это увеличивает время компиляции, и браузеры обычно могут кэшировать библиотеку, если она не изменяется.</target>
        </trans-unit>
        <trans-unit id="3787c905bb80e813db582cc0b39b9469c3749297" translate="yes" xml:space="preserve">
          <source>You might find yourself using &lt;code&gt;?.&lt;/code&gt; to replace a lot of code that performs repetitive nullish checks using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;?.&lt;/code&gt; для замены большого количества кода, который выполняет повторяющиеся проверки на нулевое значение с помощью оператора &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="453b06c204a19fa2060d497fe42b9d6b893f9b0c" translate="yes" xml:space="preserve">
          <source>You might have previously written that like so:</source>
          <target state="translated">Возможно,ты уже писал это раньше:</target>
        </trans-unit>
        <trans-unit id="79ec33e56a8b7eaeb4d65dc92383b5f0d769696d" translate="yes" xml:space="preserve">
          <source>You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we&amp;rsquo;ll do our best to cover the gist of things.</source>
          <target state="translated">У вас может быть еще несколько шагов сборки в вашем конвейере. Возможно, вы что-то присоединяете к каждому из своих файлов. Каждый инструмент сборки индивидуален, но мы постараемся охватить суть вещей.</target>
        </trans-unit>
        <trans-unit id="4d2749eb8b0574a3a2922dc523ce38ed21997148" translate="yes" xml:space="preserve">
          <source>You might see documentation like this:</source>
          <target state="translated">Возможно,вы увидите такую документацию:</target>
        </trans-unit>
        <trans-unit id="9ebbdb79f43467b01f07e5bf9e813b83bf4b06f2" translate="yes" xml:space="preserve">
          <source>You might start out getting a bunch of errors like &lt;code&gt;Cannot find name 'require'.&lt;/code&gt;, and &lt;code&gt;Cannot find name 'define'.&lt;/code&gt;. In these cases, it&amp;rsquo;s likely that you&amp;rsquo;re using modules. While you can just convince TypeScript that these exist by writing out</source>
          <target state="translated">Вы можете начать получать кучу ошибок, например, &lt;code&gt;Cannot find name 'require'.&lt;/code&gt; , и &lt;code&gt;Cannot find name 'define'.&lt;/code&gt; . В этих случаях вполне вероятно, что вы используете модули. Хотя вы можете просто убедить TypeScript в их существовании, написав</target>
        </trans-unit>
        <trans-unit id="a98f3b8ccf34fbf5eb87c6d57b621277a9a767e5" translate="yes" xml:space="preserve">
          <source>You no longer need to either explicitly declare &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;extend React.Props&lt;/code&gt;</source>
          <target state="translated">Вам больше не нужно явно объявлять &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;key&lt;/code&gt; или &lt;code&gt;extend React.Props&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc9e6801f613004f3ef228abfb6dc5acf9a7df7a" translate="yes" xml:space="preserve">
          <source>You should expect each chapter or page to provide you with a strong understanding of the given concepts. The TypeScript Handbook is not a complete language specification, but it is intended to be a comprehensive guide to all of the language&amp;rsquo;s features and behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20ea1578d72074920168379785a4d62e2beb851" translate="yes" xml:space="preserve">
          <source>You should first read &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; for an overview on the way they all work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22090ec26c2134c8a6e2097c73237d381154a0ba" translate="yes" xml:space="preserve">
          <source>You should strongly consider turning this on if you&amp;rsquo;re using project references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273fc30ccbe12c9343d1e8b3f416cecb591b9158" translate="yes" xml:space="preserve">
          <source>You shouldn&amp;rsquo;t need this. By default, when emitting a module file to a non-ES6 target, TypeScript emits a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue at the top of the file. This setting disables the prologue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb008eccba10a9a792e21493ddf4d96a2e05ffe" translate="yes" xml:space="preserve">
          <source>You want to transpile TypeScript as a part of a build chain in the terminal where the filenames are processed in the next command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfb9bf7e9a5a70d6661bc4978c8808ff85beea" translate="yes" xml:space="preserve">
          <source>You will mostly see intersection types used for mixins and other concepts that don&amp;rsquo;t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here&amp;rsquo;s a simple example that shows how to create a mixin:</source>
          <target state="translated">В основном вы увидите типы пересечений, используемые для миксинов и других концепций, которые не вписываются в классическую объектно-ориентированную форму. (В JavaScript их много!) Вот простой пример, показывающий, как создать миксин:</target>
        </trans-unit>
        <trans-unit id="f88663c08b841df52333cc0dae0185031e7b194f" translate="yes" xml:space="preserve">
          <source>You will not get any errors. However, if you turn on &lt;code&gt;checkJs&lt;/code&gt; then you will get error messages from the JavaScript file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d538693b1e7a8713fd015bc6f34e84e12105e70c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use &lt;code&gt;./dist/main.js&lt;/code&gt;. You can always go back and change these in the &lt;code&gt;package.json&lt;/code&gt; file that&amp;rsquo;s been generated for you.</source>
          <target state="translated">Вам будет предложен ряд подсказок. Вы можете использовать значения по умолчанию, кроме точки входа. В качестве точки входа используйте &lt;code&gt;./dist/main.js&lt;/code&gt; . Вы всегда можете вернуться и изменить их в созданном для вас файле &lt;code&gt;package.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="639d21bc62abc7441d41597c046101c12fe57e01" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that in the class when we refer to one of the members of the class we prepend &lt;code&gt;this.&lt;/code&gt;. This denotes that it&amp;rsquo;s a member access.</source>
          <target state="translated">Вы заметите, что в классе, когда мы обращаемся к одному из членов класса, мы добавляем &lt;code&gt;this.&lt;/code&gt; . Это означает, что это членский доступ.</target>
        </trans-unit>
        <trans-unit id="96310a35cd7703a91b61529ec989ae56b9f242ba" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see examples that look like this:</source>
          <target state="translated">Вы увидите такие примеры:</target>
        </trans-unit>
        <trans-unit id="5a5b2c7c93441f6c370caaf81abe9018ba769023" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see that there are two syntaxes for building types: &lt;a href=&quot;https://www.typescriptlang.org/play/?e=83#example/types-vs-interfaces&quot;&gt;Interfaces and Types&lt;/a&gt;. You should prefer &lt;code&gt;interface&lt;/code&gt;. Use &lt;code&gt;type&lt;/code&gt; when you need specific features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f270d2ae21cc7300335c3380e8b45bcd31b76c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the &lt;code&gt;arguments&lt;/code&gt; object instead of writing out any parameters:</source>
          <target state="translated">Иногда вы обнаруживаете, что вызываете функцию со слишком большим / небольшим количеством аргументов. Обычно это ошибка, но в некоторых случаях вы могли объявить функцию, которая использует объект &lt;code&gt;arguments&lt;/code&gt; вместо записи каких-либо параметров:</target>
        </trans-unit>
        <trans-unit id="20cb63d917861135d9d38ee4daf7eae6a3aead46" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll typically see modular libraries include one of these lines in their documentation:</source>
          <target state="translated">Обычно вы увидите, что модульные библиотеки включают в свою документацию одну из следующих строк:</target>
        </trans-unit>
        <trans-unit id="c9d443a11ab3a7c14d4920d4c70eef21109fe48c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</source>
          <target state="translated">Обычно в документации к глобальной библиотеке вы увидите руководство по использованию библиотеки в теге сценария HTML:</target>
        </trans-unit>
        <trans-unit id="3dffae8ffc86fe15706e64a3a387cd0d95f60fa7" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll want to bring your TypeScript files together - both the code you&amp;rsquo;ll be writing as well as any necessary declaration files.</source>
          <target state="translated">Вы захотите объединить свои файлы TypeScript - как код, который вы будете писать, так и любые необходимые файлы объявлений.</target>
        </trans-unit>
        <trans-unit id="6c61d3ce52f41b7a2b4d4549b6255c2f3af699ec" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve probably already heard that TypeScript is a &amp;ldquo;flavor&amp;rdquo; or &amp;ldquo;variant&amp;rdquo; of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947d14a2174247c5b66d9b89b8d5cbb14d3c55b1" translate="yes" xml:space="preserve">
          <source>Your declaration files should thus be</source>
          <target state="translated">Таким образом,ваши файлы декларации должны быть</target>
        </trans-unit>
        <trans-unit id="3e3e5fe5867a90441e1c7a4c99511a740d6fdb06" translate="yes" xml:space="preserve">
          <source>Your program doesn&amp;rsquo;t run in a browser, so you don&amp;rsquo;t want the &lt;code&gt;&quot;dom&quot;&lt;/code&gt; type definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fee6aeee4c8ecf2f473cd812413ce00001a6540" translate="yes" xml:space="preserve">
          <source>Your runtime platform provides certain JavaScript API objects (maybe through polyfills), but doesn&amp;rsquo;t yet support the full syntax of a given ECMAScript version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440ddccd9fb08c957f616ff6766040aab7a385dd" translate="yes" xml:space="preserve">
          <source>ZipCodeValidator.ts</source>
          <target state="translated">ZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="d130dd019725c3415fcffb0d0068497b6ab5463c" translate="yes" xml:space="preserve">
          <source>a default import like &lt;code&gt;import moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;).default&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f974c701a93b4450d9860f64bfb55d3dd330753" translate="yes" xml:space="preserve">
          <source>a double-precision IEEE 754 floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103388cf7ca274b241718ae87f010b3c451a1308" translate="yes" xml:space="preserve">
          <source>a literal enum expression (basically a string literal or a numeric literal)</source>
          <target state="translated">буквальное выражение перечисления (в основном строковый или числовой литерал)</target>
        </trans-unit>
        <trans-unit id="d8a7d3fe2ecf18d5a1f75697ddb3939f637d6862" translate="yes" xml:space="preserve">
          <source>a namespace import like &lt;code&gt;import * as moment from &quot;moment&quot;&lt;/code&gt; acts the same as &lt;code&gt;const moment = require(&quot;moment&quot;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c353e97b94a39673f6777646c09f2fc9ba56cf1" translate="yes" xml:space="preserve">
          <source>a parenthesized constant enum expression</source>
          <target state="translated">парентезированное постоянное выражение перечисления</target>
        </trans-unit>
        <trans-unit id="6f264047eeed3d46fe957e11ffb9269c2a50015e" translate="yes" xml:space="preserve">
          <source>a reference to previously defined constant enum member (which can originate from a different enum)</source>
          <target state="translated">ссылка на ранее определенный постоянный член перечисления (который может происходить из другого перечисления)</target>
        </trans-unit>
        <trans-unit id="9fd2ce9f0c4f3c8c3e340067701294ac5d5eb8f9" translate="yes" xml:space="preserve">
          <source>a subtype of &lt;code&gt;undefined&lt;/code&gt; intended for use as a return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528b1c807d172a8f416db6731cf13e39f6f146c" translate="yes" xml:space="preserve">
          <source>a unary minus applied to any numeric literal (e.g. &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-100&lt;/code&gt;)</source>
          <target state="translated">унарный минус, применяемый к любому числовому литералу (например, &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;-100&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e0de8923dd9a86f5d289496a0c29c4b707c6eee6" translate="yes" xml:space="preserve">
          <source>a unique value usually used as a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4ccee361c095697aa4c9d3e90553c49ca21ae4" translate="yes" xml:space="preserve">
          <source>also equivalent to the unit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442d3d9c923419455d4cda7f945720f15e70bc16" translate="yes" xml:space="preserve">
          <source>amdModule.js</source>
          <target state="translated">amdModule.js</target>
        </trans-unit>
        <trans-unit id="bd7d452e38c7164a50e08e9fa4635c29c0daaa0b" translate="yes" xml:space="preserve">
          <source>amdModule.ts</source>
          <target state="translated">amdModule.ts</target>
        </trans-unit>
        <trans-unit id="d28fdf8d5aa89ce199b0e06ebcd80f424c23a2d8" translate="yes" xml:space="preserve">
          <source>an expression</source>
          <target state="translated">выражение</target>
        </trans-unit>
        <trans-unit id="c9d85523bbe34073152505725bb477f4e59b253d" translate="yes" xml:space="preserve">
          <source>an immutable UTF-16 string.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
