<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">Внутри класса вы можете объявлять расширения для другого класса. Внутри такого расширения есть несколько &lt;em&gt;неявных получателей&lt;/em&gt; - объектов, к членам которых можно получить доступ без квалификатора. Экземпляр класса, в котором объявлено расширение, называется &lt;em&gt;получателем отправки&lt;/em&gt; , а экземпляр типа получателя метода &lt;em&gt;расширения&lt;/em&gt; называется &lt;em&gt;получателем расширения&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Внутри функции параметр &lt;code&gt;vararg&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; отображается как массив &lt;code&gt;T&lt;/code&gt; , то есть переменная &lt;code&gt;ts&lt;/code&gt; в приведенном выше примере имеет тип &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">Внутри лямбда-выражения с получателем вы можете использовать &lt;code&gt;this&lt;/code&gt; для ссылки на объект-получатель (в данном случае &lt;code&gt;car&lt;/code&gt; ). Как обычно, вы можете опустить &lt;code&gt;this&lt;/code&gt; если нет конфликтов имен, поэтому мы можем просто сказать &lt;code&gt;$horsepowers&lt;/code&gt; вместо &lt;code&gt;${this.horsepowers}&lt;/code&gt; . Поэтому имейте в виду, что в Kotlin &lt;code&gt;this&lt;/code&gt; может иметь разные значения в зависимости от контекста: если оно используется внутри (возможно, вложенных) лямбда-выражений с приемниками, оно относится к объекту-получателю самого внутреннего включающего лямбда-выражения с приемником. Если вам нужно &amp;laquo;вырваться&amp;raquo; из функционального литерала и получить &amp;laquo;оригинал&amp;raquo;, &lt;code&gt;this&lt;/code&gt; (экземпляр, в котором выполняется функция-член, внутри которой вы находитесь), укажите имя содержащего класса после &lt;code&gt;this@&lt;/code&gt; - поэтому, если вы находитесь внутри литерала функции с приемником внутри функции-члена Car, используйте &lt;code&gt;this@Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">Внутри внутреннего класса доступ к суперклассу внешнего класса осуществляется с помощью ключевого слова &lt;em&gt;super&lt;/em&gt; с именем внешнего класса: &lt;code&gt;super@Outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">Внутри записей перечисления определение вложенного типа, который не является &lt;code&gt;inner class&lt;/code&gt; , устарело из-за проблем в логике инициализации. Это вызывает предупреждение в Kotlin 1.2 и становится ошибкой в ​​Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">Внутри блока &lt;code&gt;apply&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; относится к &lt;code&gt;maybeNull&lt;/code&gt; . Там в неявном &lt;code&gt;this&lt;/code&gt; перед &lt;code&gt;memberPropertyA&lt;/code&gt; , &lt;code&gt;memberPropertyB&lt;/code&gt; и &lt;code&gt;memberFunctionA&lt;/code&gt; (если они не не существует на &lt;code&gt;maybeNull&lt;/code&gt; , в этом случае они будут искать в областях , содержащих). После этого &lt;code&gt;memberFunctionB()&lt;/code&gt; также вызывается для &lt;code&gt;maybeNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="201f7c7f50eead5096b8205dfcee81a61ab42986" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;kotlin&lt;/code&gt; section, you can manage the following aspects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">Внутри тела функционального литерала объект-получатель, переданный вызову, становится &lt;em&gt;неявным &lt;/em&gt;&lt;em&gt;this&lt;/em&gt; , так что вы можете получить доступ к членам этого объекта-получателя без каких-либо дополнительных квалификаторов или получить доступ к объекту-получателю с помощью &lt;a href=&quot;this-expressions&quot;&gt;выражения &lt;/a&gt; &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">Внутри класса,который объявляет свойство lateinit,можно проверить,было ли оно инициализировано:</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">Внутри файла документация для модуля в целом и для отдельных пакетов представлена ​​соответствующими заголовками первого уровня. Текст заголовка должен быть &amp;laquo;Модуль &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &amp;raquo; для модуля и &amp;laquo;Пакет &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &amp;raquo; для пакета.</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">Внутри лямбда функции области видимости объект контекста доступен по короткой ссылке вместо его фактического имени. Каждая функция области видимости использует один из двух способов доступа к объекту контекста: как лямбда- &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;приемник&lt;/a&gt; ( &lt;code&gt;this&lt;/code&gt; ) или как лямбда-аргумент ( &lt;code&gt;it&lt;/code&gt; ). Оба предоставляют одинаковые возможности, поэтому мы опишем плюсы и минусы каждого для разных случаев и дадим рекомендации по их использованию.</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">Посмотреть сгенерированные API Kotlin из библиотеки C</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">Для получения подробной информации проверьте содержимое &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; дистрибутива.</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">Проверка сгенерированных API Kotlin для C-библиотеки</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">Установите пользовательский неуправляемый крюк для исключений.Возвращает старый крюк,или нулевой,если он не был указан.Крюк вызывается всякий раз,когда есть неисправленное исключение,достигающее границ мира Котлина,т.е.верхнего уровня main(),или когда вызов Objective-C к Котлину,не помеченный @Throws,бросает исключение.Крюк должен быть замороженной лямбдой,чтобы его можно было вызвать из любого потока/работника.Крючок вызывается один раз,а затем очищается,так что обнаружение утечки памяти работает,как и ожидалось,даже при использовании пользовательских крючков исключений.</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">Установите libgit2 и подготовьте корешки для git-библиотеки:</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">Установите &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;расширение JetBrains для Chrome,&lt;/a&gt; которое позволяет выполнять отладку внутри IntelliJ IDEA через Chrome. Это полезно для любого типа веб-приложений, разработанных с помощью IntelliJ IDEA, а не только для Kotlin.</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a87099d120ccde681dac7b4563f2ddd1e2d4aca" translate="yes" xml:space="preserve">
          <source>Install the Kotlin Plugin 1.4.x or higher in the IDE. You can check the Kotlin version in &lt;strong&gt;Tools&lt;/strong&gt; | &lt;strong&gt;Kotlin&lt;/strong&gt; | &lt;strong&gt;Configure Plugin Updates&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">Установка плагина EduTools</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">Бытовые проверки</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">Поля Экземпляра</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">Экземпляр,требуемый для вызова члена,или внешний экземпляр класса для внутреннего конструктора класса.</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">инстанцирование типа функции</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">Вместо непосредственного вызова метода, &lt;code&gt;matches&lt;/code&gt; мы сохраняем ссылку на него. Такая ссылка привязывается к получателю. Его можно вызвать напрямую (как в примере выше) или использовать всякий раз, когда ожидается выражение типа функции:</target>
        </trans-unit>
        <trans-unit id="aad6314ddaef7ba86c76eaf3164d0bca4da5fc5d" translate="yes" xml:space="preserve">
          <source>Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into an instance of a class that implements the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">Вместо того,чтобы создавать объект функции для параметра и генерировать вызов,компилятор мог бы выдать следующий код:</target>
        </trans-unit>
        <trans-unit id="07b156a4a7a7d22439a598737b46c70a6ec2b640" translate="yes" xml:space="preserve">
          <source>Instead of doing this, you can create a hierarchical structure with &lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;target shortcuts&lt;/a&gt; available for typical multi-target scenarios, or you can manually declare and connect the source sets. For example, you can create two iOS targets and a shared source set with the &lt;code&gt;ios()&lt;/code&gt; shortcut:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db904fe60f6fc13954beaf8c6781a1e474eddead" translate="yes" xml:space="preserve">
          <source>Instead of manually compiling and executing our Kotlin/JS project every time we want to see the changes we made, we can make use of the &lt;em&gt;continuous compilation&lt;/em&gt; mode. Instead of using the regular &lt;code&gt;run&lt;/code&gt; command, we instead invoke the Gradle wrapper in &lt;em&gt;continuous&lt;/em&gt; mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">Вместо потоков среда исполнения Kotlin / Native предлагает концепцию рабочих: одновременно выполняемые потоки потока управления со связанной очередью запросов. Рабочие очень похожи на актеров в модели актера. Рабочий может обмениваться объектами Kotlin с другим воркером, так что в любой момент каждый изменяемый объект принадлежит одному воркеру, но право собственности может быть передано. См. Раздел &amp;laquo; &lt;a href=&quot;#transfer&quot;&gt;Перенос объектов и замораживание&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">Указывает компилятору сгенерировать или опустить подстановочные знаки для аргументов типа, соответствующих параметрам с отклонением от места объявления, например таким, как &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">Инструктирует компилятор генерировать подстановочный символ для аннотированных аргументов типа,соответствующих параметрам с дисперсией объявление-сайт.</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Инструктирует компилятор Kotlin не генерировать геттеры/установки для данного свойства и выставлять его в виде поля.</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">Инструктирует компилятор Kotlin генерировать перегрузки для этой функции,которые подставляют значения параметров по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">Инструктирует компилятор Kotlin относиться к аннотированному классу Java как к чистой реализации заданного интерфейса Kotlin.&quot;Чисто&quot; здесь означает,что каждый тип параметра класса становится не-платформенным типом аргумента этого интерфейса.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">Целочисленные типы</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Целочисленные типы в Kotlin имеют &lt;em&gt;ограниченный размер&lt;/em&gt; , в отличие от произвольно больших целых чисел в Python. Предел зависит от типа, который определяет, сколько бит занимает число в памяти:</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">Диапазоны интегральных типов ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt; ) имеют дополнительную функцию: их можно перебирать. Эти диапазоны также являются &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;прогрессиями&lt;/a&gt; соответствующих интегральных типов. Такие диапазоны обычно используются для итерации в &lt;code&gt;for&lt;/code&gt; петель.</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA может запускать ваши царапины автоматически. Чтобы получить результаты выполнения после того, как вы перестанете печатать на короткое время, включите &lt;strong&gt;интерактивный режим&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="918971018a2752255f900c2cf2e714f49b6e48a7" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412b9a62ef1aac11c1728c644747bfbcd40b3ae6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA добавит нам соответствующие записи в &lt;a href=&quot;#maven-configuration&quot;&gt;конфигурацию Maven&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">Взаимодействовать с МДМ</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">Взаимодействие с МЗУ</target>
        </trans-unit>
        <trans-unit id="4ee5033c0dc3e88efff33103b78dd8f7118a9355" translate="yes" xml:space="preserve">
          <source>Interactive editors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Продолжение перехвата с помощью &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Продолжение перехвата с помощью &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">Перехват переданного имущества,имеющего обязательную силу</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Перехватывает это продолжение с помощью &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">Схема реализации интерфейса</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Интерфейс , представляющие собой продолжение после точки подвеса , которая возвращает значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Интерфейс , представляющие собой продолжение после точки подвеса , которая возвращает значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">Оба интерфейса &lt;em&gt;A&lt;/em&gt; и &lt;em&gt;B&lt;/em&gt; объявляют функции &lt;em&gt;foo ()&lt;/em&gt; и &lt;em&gt;bar ()&lt;/em&gt; . Оба они реализуют &lt;em&gt;foo ()&lt;/em&gt; , но только &lt;em&gt;B&lt;/em&gt; реализует &lt;em&gt;bar ()&lt;/em&gt; ( &lt;em&gt;bar ()&lt;/em&gt; не помечен как абстрактный в &lt;em&gt;A&lt;/em&gt; , потому что это значение по умолчанию для интерфейсов, если функция не имеет тела). Теперь, если мы получим конкретный класс &lt;em&gt;C&lt;/em&gt; от &lt;em&gt;A&lt;/em&gt; , мы, очевидно, должны переопределить &lt;em&gt;bar ()&lt;/em&gt; и предоставить реализацию.</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">Наследование интерфейсов</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Интерфейсы в Котлине очень похожи на Java 8.Они могут содержать декларации абстрактных методов,а также реализации методов.Их отличие от абстрактных классов состоит в том,что интерфейсы не могут хранить состояние.Они могут иметь свойства,но они должны быть абстрактными или предоставлять реализации доступа.</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2e69a2381964d98d7dca2d48b42c9749b41571" translate="yes" xml:space="preserve">
          <source>Intermediate flow operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">Интерфейс с Java</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Интероперабельность с отражением Java</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Совместимость со Swift / Objective-C также обеспечивается и рассматривается в отдельном документе &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc3ed9f2e2ef0d7ff8b99c31c5f5dfba491948e8" translate="yes" xml:space="preserve">
          <source>Introduce a local variable &lt;code&gt;name&lt;/code&gt; with the keyword &lt;code&gt;val&lt;/code&gt;. It will get its value from an input where you will enter your name &amp;ndash; &lt;code&gt;readLine()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Представляем выражение как переменную в локальной области видимости: &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">Введение в Котлин (на русском языке)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Введение в программирование Kotlin</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="f4afeb75d0f49bdd06579dbdb4f04043561414aa" translate="yes" xml:space="preserve">
          <source>Invariant projections of type arguments, such as &lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;, &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">Инвертирует биты в это значение.</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">Инвертирует биты,включая знаковый бит в это значение.</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">Вызов &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; возобновляет сопрограмму непосредственно в потоке вызывающего, не проходя через &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor,&lt;/a&gt; который может присутствовать в CoroutineContext &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;сопрограммы&lt;/a&gt; . Ответственность за обеспечение правильного контекста вызова лежит на вызывающей стороне. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; можно использовать для получения перехваченного продолжения.</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">провоцирующий оператор</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">Вызывается для экземпляра продолжения, возвращаемого функцией &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation,&lt;/a&gt; когда исходное продолжение завершается и больше не будет использоваться. Эта функция вызывается только в том случае, если &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; вернул экземпляр продолжения, отличный от того, с которым она была вызвана.</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">Вызов &lt;code&gt;call()&lt;/code&gt; для объекта функции вызовет функцию. Если это функция-член, первым параметром должен быть &lt;em&gt;получатель&lt;/em&gt; (объект, для которого функция должна быть вызвана, в данном случае &lt;code&gt;person&lt;/code&gt; ), а остальные параметры должны быть обычными параметрами функции (в данном случае &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ). ,</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">Вызов &lt;code&gt;findViewById()&lt;/code&gt; может быть медленным, особенно в случае огромных иерархий представлений, поэтому Android Extensions пытается минимизировать вызовы &lt;code&gt;findViewById()&lt;/code&gt; путем кэширования представлений в контейнерах.</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">Призыв к экземпляру типа функции</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">Призывные функции на других коллекциях</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Является ли Котлин объектно-ориентированным языком или функциональным?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Совместима ли Kotlin с языком программирования Java?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">Котлин свободен?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">Котлин трудный?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">Котлин в социальных сетях?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">Функция расширения</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">Есть ли конференция в Котлине?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">Разве это не то,чего мы хотели с самого начала?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">Изоляция деклараций в отдельном объекте JavaScript</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">Он также работает с мета-аннотациями:</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">Это можно продемонстрировать на простом примере создания сопрограмм в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">Конечно, это можно сделать одним выражением: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">Он демонстрирует несколько новых техник. Один использует &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; с явно указанным контекстом, а другой использует функцию &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; для изменения контекста сопрограммы, оставаясь при этом в той же сопрограмме, как вы можете видеть в выводе ниже:</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">Не имеет значения (для корректности),в каком контексте выполняется сам агент.Актор-это корутин,а корутин выполняется последовательно,поэтому привязка состояния к конкретной корутине работает как решение проблемы общего мутируемого состояния.Действительно,агенты могут изменять свое собственное частное состояние,но могут влиять друг на друга только через сообщения (избегая необходимости в каких-либо блокировках).</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">&lt;code&gt;writeLogMessage&lt;/code&gt; , что целевые объекты предоставят реализации writeLogMessage для конкретной платформы , и теперь общий код может использовать это объявление без какого-либо рассмотрения того, как оно реализовано.</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">Его также удобно использовать,когда вместо лямбды у вас есть ссылка на звонок:</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">Также возможно настроить все задачи компиляции Kotlin в проекте:</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">Также возможна отладка приложений Kotlin с помощью стандартного отладчика Chrome.Просто убедитесь,что вы действительно генерируете исходные карты.</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Также можно перебирать числа с произвольным шагом (не обязательно с 1). Это делается с помощью &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; функции.</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">Удобно импортировать все свойства виджета для конкретного макета за один заход:</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">Он создается путем присоединения функции &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; к источнику элементов. Чтобы получить экземпляр &lt;a href=&quot;index&quot;&gt;Grouping,&lt;/a&gt; используйте одну из функций расширения &lt;code&gt;groupingBy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6148f03cfc2015e2c10414350a23c5c6eccbddac" translate="yes" xml:space="preserve">
          <source>It is currently prohibited to export the following kinds of declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">Это легко продемонстрировать в действии:</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">Скомпилированный код Kotlin легко включить в существующие проекты, написанные на C, C ++, Swift, Objective-C и других языках. Также легко использовать существующий собственный код, статические или динамические &lt;a href=&quot;native/c_interop&quot;&gt;библиотеки&lt;/a&gt; C, &lt;a href=&quot;native/objc_interop&quot;&gt;фреймворки&lt;/a&gt; Swift / Objective-C , графические движки и все остальное прямо из Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="a1e4c80fa63f2c717618535a583de6ba5b964535" translate="yes" xml:space="preserve">
          <source>It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the &lt;code&gt;addEventListener&lt;/code&gt; function that registers a piece of code with a reaction for incoming events and continues further work. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; operator can serve this role. However, &lt;code&gt;onEach&lt;/code&gt; is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling &lt;code&gt;onEach&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">Сгенерированные классы-оболочки для &lt;code&gt;struct&lt;/code&gt; C и типов &lt;code&gt;union&lt;/code&gt; из Kotlin легко использовать . Благодаря сгенерированным свойствам кажется естественным использовать их в коде Kotlin. На данный момент единственный вопрос заключается в том, как создать новый экземпляр для этих классов. Как видно из объявлений &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; , их конструкторам требуется &lt;code&gt;NativePtr&lt;/code&gt; . Конечно, мы не хотим иметь дело с указателями вручную. Вместо этого мы можем использовать Kotlin API для создания экземпляров этих объектов для нас.</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">Он эквивалентен этому Java-коду:</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">Встроенным классам запрещено участвовать в иерархии классов. Это означает, что встроенные классы не могут расширять другие классы и должны быть &lt;em&gt;окончательными&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">Важно отметить, что некоторые из &lt;a href=&quot;#supported-platforms&quot;&gt;целевых объектов Kotlin / Native&lt;/a&gt; могут быть созданы только с помощью соответствующего хост-компьютера:</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">Важно понимать, что, как и в случае с &lt;code&gt;callAnything()&lt;/code&gt; , &lt;code&gt;dataTable()&lt;/code&gt; должна существовать во время выполнения. В нашем случае нам нужно убедиться, что соответствующий файл скрипта для нашего плагина включен:</target>
        </trans-unit>
        <trans-unit id="12337a359954227bfe96e37274de5fc654fa35be" translate="yes" xml:space="preserve">
          <source>It is not recommended that you publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">Не рекомендуется публиковать варианты,сгруппированные по вкусу продукта,если они имеют различные зависимости,так как они будут объединены в один список зависимостей.</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">Необязательно сопоставлять директории и пакеты:исходные файлы могут быть произвольно помещены в файловую систему.</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">Теперь можно перечислить значения класса перечисления в общем виде.</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">Он не зависит от платформы.Независимо от того,нацелены ли мы на JVM,JavaScript или любую другую платформу,код,который мы пишем,тот же самый.Под обложками компилятор заботится об адаптации его к каждой платформе.</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">Класс может реализовать тип функции, как если бы он был интерфейсом. Затем он должен предоставить операторную функцию, называемую &lt;code&gt;invoke&lt;/code&gt; , с данной сигнатурой, и затем экземпляры этого класса могут быть назначены переменной этого типа функции:</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">Можно аннотировать аргументы типов общих типов,чтобы предоставить информацию об их недействительности.Например,рассмотрим эти аннотации на Java-декларации:</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">Можно настроить языковые параметры всех исходных наборов одновременно:</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">Можно создать указатель со стабильной областью видимости C-представления &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; используя свойство расширения &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; , доступное в &lt;code&gt;memScoped { ... }&lt;/code&gt; . Это позволяет использовать API-интерфейсы, для которых требуются указатели C со временем жизни, привязанным к определенному &lt;code&gt;MemScope&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">Можно объявлять контракты для ваших собственных функций, но это &lt;strong&gt;экспериментальная&lt;/strong&gt; функция &lt;strong&gt;,&lt;/strong&gt; поскольку текущий синтаксис находится в состоянии раннего прототипа и, скорее всего, будет изменен. Также обратите внимание, что в настоящее время компилятор Kotlin не проверяет контракты, поэтому ответственность за написание правильных и надежных контрактов лежит на программисте.</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">Можно фильтровать заголовки по глобусам. &lt;code&gt;headerFilter&lt;/code&gt; значение свойства из &lt;code&gt;.def&lt;/code&gt; файла обрабатываются как разделенные пробелами списка комков. Если включенный заголовок совпадает с каким-либо из глобусов, то объявления из этого заголовка включаются в привязки.</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">В многоплатформенной библиотеке можно иметь несколько целей для одной платформы.Например,эти мишени могут предоставлять один и тот же API и различаться в библиотеках,с которыми они сотрудничают во время выполнения,таких как тестирующие фреймворки или решения для протоколирования.</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">Можно указать,какие типы сборки будут использоваться для создания двоичных файлов,а какие нет.В следующем примере создается только отладочный исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">Это довольно распространенная ситуация, когда у вас есть список ключей и вы хотите построить карту, связывая каждый из этих ключей с некоторым значением. &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; можно было сделать с помощью функции associate {it to getValue (it)} , но теперь мы представляем более эффективную и простую в использовании альтернативу: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af6059bcf4a05b2b995079d84a33266eddebc57" translate="yes" xml:space="preserve">
          <source>It is recommended to only provide external declarations manually in your source folder &lt;em&gt;or&lt;/em&gt; enabling the generation of external declarations at build time for any single dependency. Doing both can result in resolution issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">Можно безопасно рассматривать &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; как &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - тогда вы ограничены только добавлением к нему экземпляров &lt;code&gt;Apple&lt;/code&gt; , но это нормально, потому что он способен получать любые &lt;code&gt;Fruit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">Можно безопасно обращаться с &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; как с &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - единственное, что он когда-либо будет производить, - это экземпляры &lt;code&gt;Apple&lt;/code&gt; , но это нормально, потому что &lt;code&gt;Apple&lt;/code&gt; - это &lt;code&gt;Fruit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">Это то же самое, что и установленный хэш-код &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;записей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">Пришло время попробовать использовать функции C из нашей программы Kotlin. Давайте &lt;code&gt;accept_fun&lt;/code&gt; функцию accept_fun и передадим указатель функции C лямбда- выражению Kotlin:</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">Очень удобно объявить параметр типа T как &lt;em&gt;out&lt;/em&gt; и избежать проблем с выделением подтипов на сайте использования, но некоторые классы фактически &lt;strong&gt;не могут&lt;/strong&gt; быть ограничены только возвратом &lt;code&gt;T&lt;/code&gt; ! Хорошим примером этого является Array:</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">Он запускает 100K корутины и через секунду каждая корутина печатает точку.Теперь попробуй это с нитками.Что случится? (Скорее всего,ваш код выдаст какую-нибудь ошибку вне памяти).</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">Это приводит к тому,что в Котлине видна следующая подпись:</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">Это может быть полезно только в том случае,если объявление кажется неудобным для использования из Java без подстановочного символа.</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">Это может быть полезно только в том случае,если объявление кажется неудобным для использования из Java.</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">Следующим логичным шагом может показаться устранение этой неясности путем переключения значений по умолчанию в IntelliJ IDEA и приведение форматирования в соответствие с Котлинскими конвенциями по кодированию.Но это будет означать,что все существующие проекты Kotlin будут иметь новый стиль кода,включенный в момент установки плагина Kotlin.Не совсем ожидаемый результат для обновления плагина,не так ли?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">Это означает, что к моменту выполнения конструктора базового класса свойства, объявленные или переопределенные в производном классе, еще не инициализированы. Если какое-либо из этих свойств используется в логике инициализации базового класса (прямо или косвенно, через другую переопределенную реализацию &lt;em&gt;открытого&lt;/em&gt; члена), это может привести к неправильному поведению или сбою во время выполнения. Поэтому при разработке базового класса следует избегать использования &lt;em&gt;открытых&lt;/em&gt; членов в конструкторах, инициализаторах свойств и блоках &lt;em&gt;инициализации&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">Может возникнуть соблазн использовать класс JVM &lt;code&gt;java.util.Scanner&lt;/code&gt; для анализа менее структурированных форматов ввода. Kotlin разработан так, чтобы хорошо взаимодействовать с библиотеками JVM, поэтому их использование в Kotlin кажется вполне естественным. Однако учтите, что &lt;code&gt;java.util.Scanner&lt;/code&gt; работает очень медленно. На самом деле настолько медленным, что анализ 10 &lt;sup&gt;5&lt;/sup&gt; или более целых чисел с ним может не укладываться в типичный 2-секундный временной лимит, который будет обрабатывать простой Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">Он печатает &amp;laquo;отправка&amp;raquo; &lt;em&gt;пять&lt;/em&gt; раз, используя буферный канал с пропускной способностью &lt;em&gt;четыре&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">Он печатает следующие строки:</target>
        </trans-unit>
        <trans-unit id="4fc49613736421c5526df5f47051346dc40ed425" translate="yes" xml:space="preserve">
          <source>It prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">При работе в &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;режиме отладки&lt;/a&gt; он производит что-то подобное :</target>
        </trans-unit>
        <trans-unit id="937e4c5bd1079031a2dfad58d8e0700ddac7f05b" translate="yes" xml:space="preserve">
          <source>It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">Она производит нечто подобное:</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">Он производит следующий вывод (возможно,в другом порядке):</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">Он производит следующий результат:</target>
        </trans-unit>
        <trans-unit id="020338510019284e271656ee98c10ee9502fa284" translate="yes" xml:space="preserve">
          <source>It produces the following three lines, each line appearing after each second:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b842d5f86ada273da6149c65d3d77df472ae9b5" translate="yes" xml:space="preserve">
          <source>It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">Он возвращает композицию из двух переданных ему функций: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; . Теперь вы можете применить его к вызываемым ссылкам:</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">Он принимает два параметра типа &lt;code&gt;Int&lt;/code&gt; и возвращает значение типа &lt;code&gt;Double&lt;/code&gt; , поэтому его тип - &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; . Мы можем ссылаться на саму функцию, добавив к ее имени префикса &lt;code&gt;::&lt;/code&gt; , и мы можем присвоить ее переменной (тип которой обычно определяется, но мы показываем сигнатуру типа для демонстрации):</target>
        </trans-unit>
        <trans-unit id="2543e91e8c67adc1567e54c9ccc67fdf2ca3724a" translate="yes" xml:space="preserve">
          <source>It was really annoying when all the arguments were in their correct positions but you wanted to specify a name for one argument in the middle. It was especially helpful for making absolutely clear which attribute a boolean or &lt;code&gt;null&lt;/code&gt; value belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">Он создаст общий объект для конкретной платформы (.so в Linux, .dylib в macOS и .dll в целях Windows) и заголовок языка C, что позволит использовать все общедоступные API, доступные в вашей программе Kotlin / Native с C / Код на C ++. См. &lt;code&gt;samples/python_extension&lt;/code&gt; для примера использования такого общего объекта для обеспечения моста между Python и Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">Он создаст статический объект,специфичный для платформы (.a библиотечный формат)и заголовок языка Си,позволяющий использовать все публичные API,доступные в вашей программе Kotlin/Native из Си/Си++кода.</target>
        </trans-unit>
        <trans-unit id="7c5675ec989f2dc249c2ff33b781d2949c2f52a5" translate="yes" xml:space="preserve">
          <source>It works only for interop libraries shipped with Kotlin/Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">Начать использовать Kotlin для разработки под Android очень просто. В этом руководстве мы проследим за процессом разогрева с помощью Android Studio. Если вы используете Intellij IDEA с Android, процесс почти такой же.</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">Разрешено передавать тот же массив в место &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;назначения&lt;/a&gt; и даже указывать поддиапазон, чтобы он перекрывался с диапазоном назначения.</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">Разрешено передавать тот же массив в место &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;назначения&lt;/a&gt; и даже указывать поддиапазон, чтобы он перекрывался с диапазоном назначения.</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">Всегда можно явно указать стиль кода IntelliJ IDEA как правильный стиль кода для проекта. Для этого переключитесь на схему &amp;laquo; &lt;em&gt;Проект&amp;raquo;&lt;/em&gt; в &amp;laquo; &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; и выберите &lt;em&gt;&amp;laquo;Kotlin obsolete IntelliJ IDEA codestyle&amp;raquo;&lt;/em&gt; в &lt;em&gt;&amp;laquo;Использовать значения по умолчанию из:&amp;raquo;&lt;/em&gt; на вкладке &amp;laquo; &lt;em&gt;Загрузка&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">В настоящее время невозможно передать &lt;em&gt;null&lt;/em&gt; методу, объявленному как varargs.</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">Наследование от &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; нормально , и у нас нет проблем с &lt;code&gt;a()&lt;/code&gt; и &lt;code&gt;b()&lt;/code&gt; поскольку &lt;code&gt;C&lt;/code&gt; наследует только одну реализацию каждой из этих функций. Но для &lt;code&gt;f()&lt;/code&gt; у нас есть две реализации, унаследованные от &lt;code&gt;C&lt;/code&gt; , и поэтому мы должны переопределить &lt;code&gt;f()&lt;/code&gt; в &lt;code&gt;C&lt;/code&gt; и предоставить нашу собственную реализацию, которая устраняет двусмысленность.</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">Важно закрыть поток,когда вы закончили с ним,в противном случае ваша программа утечет обработчик файла.Смотрите следующий раздел о том,как это сделать красиво.</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">Важно убедиться, что установлен флажок &lt;em&gt;Включить поддержку Kotlin&lt;/em&gt; . А пока мы можем оставить настройки по умолчанию на следующем шаге мастера. Затем мы переходим к выбору опции &amp;laquo; &lt;em&gt;Пустое действие&amp;raquo;&lt;/em&gt; и нажимаем &amp;laquo; &lt;em&gt;Далее&amp;raquo;&lt;/em&gt; , наконец, нажимаем &amp;laquo; &lt;em&gt;Готово&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">Важно понимать,что теперь это родное приложение,и для его работы не требуется ни время выполнения,ни виртуальная машина.Теперь мы можем запустить скомпилированный двоичный файл из консоли:</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Не рекомендуется применять плагины Kotlin с помощью &lt;code&gt;apply&lt;/code&gt; в Gradle Kotlin DSL. Подробности представлены &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">Часто бывает так, что нам нужно скопировать объект, изменив &lt;em&gt;некоторые&lt;/em&gt; его свойства, но оставив остальные без изменений. Для этого и создается функция &lt;code&gt;copy()&lt;/code&gt; . Для указанного выше класса &lt;code&gt;User&lt;/code&gt; его реализация будет следующей:</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">Для компонента можно объявить зависимость от кинтеропа:</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">Можно зависеть от библиотеки Kotlin / Native, опубликованной ранее в репозитории maven. Плагин полагается на поддержку &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;метаданных&lt;/a&gt; Gradle, поэтому соответствующая функция должна быть включена. Добавьте следующую строку в свой &lt;code&gt;settings.gradle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">Рекомендуется распространять экспериментальный статус на API,зависящий от беззнаковых типов,снабжая его этой аннотацией.</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">Вы сами решаете,должны ли ваши клиенты явно согласиться на использование вашего API,но имейте в виду,что беззнаковые типы являются экспериментальной функцией,поэтому API,использующий их,может внезапно сломаться из-за изменений в языке.</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">Полезно укорачивать длинные типовые.Например,часто бывает заманчиво укоротить коллекционные типы:</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">Очень часто выражение лямбда имеет только один параметр.</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">Итерирует каждую строку этого читателя, вызывает &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;действие&lt;/a&gt; для каждой прочитанной строки и закрывает &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Ридер,&lt;/a&gt; когда оно завершено.</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">Интригуя по коллекции:</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">Итерация на расстоянии:</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">Итератор для символов заданной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Итераторы могут быть получены для наследников интерфейса &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , включая &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;List&lt;/code&gt; , путем вызова функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; . После получения итератора он указывает на первый элемент коллекции; вызов функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; возвращает этот элемент и перемещает позицию итератора на следующий элемент, если он существует. Как только итератор проходит через последний элемент, он больше не может использоваться для получения элементов; его также нельзя вернуть в предыдущее положение. Чтобы снова пройти по коллекции, создайте новый итератор.</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">JAR-файл для проекта Android из исходного набора &lt;code&gt;androidMain&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">поддержка JPA</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="18acc06f648ff3dfaa92d38568a89dcb1c336e71" translate="yes" xml:space="preserve">
          <source>JS + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305 ( &lt;code&gt;javax.annotation&lt;/code&gt; , подробнее ниже)</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 Поддержка</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="ba55f5a90bf0d3ce9f1b0f807b6ef302c9ac96c9" translate="yes" xml:space="preserve">
          <source>JVM + Android targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91c8eab1c7dd4c61791a6e6cea54a63f44fc1bc" translate="yes" xml:space="preserve">
          <source>JVM + JS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c072fe1de9573a0b46a9ce0b06fdf1d4adc47cb" translate="yes" xml:space="preserve">
          <source>JVM + JS + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9d77993a56f0043f2307875f7d47573f436cff" translate="yes" xml:space="preserve">
          <source>JVM + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">СПС 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM Бэкэнд</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">бэкэнд СПМ</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458cadbdc19f7b0625a6ae9eae43cf7d180c87dd" translate="yes" xml:space="preserve">
          <source>JVM modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7843626ea3524e7d3635490a634ced48fdacaeb5" translate="yes" xml:space="preserve">
          <source>JVM targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">баночное дело</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">попытка Java 7 с использованием ресурсов</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">поддержка Java 8 байткодов</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Поддержка стандартной библиотеки Java 8</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java-аннотации</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java-массивы</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http сервлеты могут использоваться в Kotlin так же,как и любая другая библиотека или фреймворк Java.Мы посмотрим,как сделать простой контроллер,который возвращает &quot;Привет,мир!&quot;.</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">Java-интероперабельность</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Отражение Java</target>
        </trans-unit>
        <trans-unit id="2fbdce03c9470f1b2722c2ee692684eb6163442c" translate="yes" xml:space="preserve">
          <source>Java SAM interfaces in Kotlin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">Поддержка Java в JVM Targets</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Ява Варрагс</target>
        </trans-unit>
        <trans-unit id="83c71cd47e81bcbb82cda5a763f3b5d7be5fba22" translate="yes" xml:space="preserve">
          <source>Java Virtual Machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java аннотации на 100% совместимы с Kotlin:</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">В классах Java иногда используется объявление метода для индексов с переменным количеством аргументов (varargs):</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">параметры Java-компилятора</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">ява дженерики в Котлине</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Java-взаимодействие:</target>
        </trans-unit>
        <trans-unit id="05bbb6e796992dd8a4fef0cfa9a4d27c4b673a12" translate="yes" xml:space="preserve">
          <source>Java libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java получила поддержку типов функций и лямбда-выражений только несколько лет назад.Ранее Java работала над этим,используя интерфейс для определения сигнатуры функции и разрешая встроенное анонимное определение класса,реализующего интерфейс.Это также доступно в Kotlin,отчасти для совместимости с библиотеками Java,а отчасти потому,что это может быть удобно для указания обработчиков событий (в частности,если есть более одного типа событий,которые должны быть прослушаны одним и тем же объектом слушателя).Рассмотрим интерфейс или (возможно,абстрактный)класс,а также функцию,которая берет его экземпляр:</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Отражение Java работает с классами Kotlin и наоборот. Как упоминалось выше, вы можете использовать &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; или &lt;code&gt;instance.javaClass&lt;/code&gt; для входа в отражение Java через &lt;code&gt;java.lang.Class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">Java-типы,которые имеют аннотации обнуления,представлены не в виде платформенных типов,а в виде действительных нулевых или ненулевых типов Котлина.Компилятор поддерживает несколько вкусов аннотаций обнуляемости,в том числе:</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Массивы Java отображаются, как указано &lt;a href=&quot;java-interop#java-arrays&quot;&gt;ниже&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Примитивные типы Java в ячейках сопоставляются с нулевыми типами Kotlin:</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Сырые типы Java преобразуются в звездные проекции,</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Подстановочные знаки Java преобразуются в типовые проекции,</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">вызовы Java-метода по умолчанию</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">Java-отражение</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">конвертер Java2Kotlin</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScript Бэкэнд</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">модули JavaScript</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">отражение JavaScript</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScript-бэкэнд</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">Бэкэнд JavaScript теперь генерирует более статически проверяемый код,который более дружественен к инструментам обработки JS-кода,таким как минификаторы,оптимизаторы,подложки и т.д.</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">В JavaScript нет концепции пакетов (пространств имен). Обычно они эмулируются вложенными объектами. Компилятор превращает ссылки на &lt;code&gt;external&lt;/code&gt; объявления либо в простые имена без префикса (в случае &lt;em&gt;простых&lt;/em&gt; модулей), либо в простой импорт. Однако, если библиотека JavaScript предоставляет свои объявления в пакетах, вас это не удовлетворит. Вы можете указать компилятору сгенерировать дополнительный префикс перед ссылками на &lt;code&gt;external&lt;/code&gt; объявления с помощью &lt;code&gt;@JsQualifier(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">В JavaScript нет концепции интерфейсов. Когда функция ожидает, что ее параметр будет поддерживать методы &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; , вы просто передаете объекты, которые действительно имеют эти методы. Вы можете использовать интерфейсы, чтобы выразить это для статически типизированного Котлина, например:</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b5802824529ccfad8f8c81c90d94e61f99e64f2" translate="yes" xml:space="preserve">
          <source>JavaScript targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains разрабатывает и поддерживает несколько инструментов специально для сообщества &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React&lt;/a&gt; : привязки React, а также приложение &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin&lt;/a&gt; . Последний поможет вам начать создавать приложения React с Kotlin без конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">Работа в контексте</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">Присоединяйтесь к нам,чтобы продолжить изучение языковых типов C и их представление в Kotlin/Native в соответствующих учебниках:</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">Присоединение к курсу</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">Джошуа Блох называет те объекты, которые вы &lt;strong&gt;читаете&lt;/strong&gt; только от &lt;strong&gt;производителей&lt;/strong&gt; , а те, которые вы &lt;strong&gt;пишете,&lt;/strong&gt; - &lt;strong&gt;потребителям&lt;/strong&gt; . Он рекомендует: &amp;laquo; &lt;em&gt;Для максимальной гибкости используйте типы подстановочных знаков для входных параметров, которые представляют производителей или потребителей&lt;/em&gt; &amp;raquo;, и предлагает следующую мнемонику:</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">Прыжки между резьбами</target>
        </trans-unit>
        <trans-unit id="c4dd39bfc503df3e7ae8d48062e97ce8c118b15c" translate="yes" xml:space="preserve">
          <source>Jupyter Kotlin kernel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">Просто добавьте JAR-файл плагина в плагин Classpath компилятора и укажите список аннотаций sam-with-receiver:</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Как и в Java 8,Kotlin теперь позволяет использовать подчёркивания в числовых буквах для разделения групп цифр:</target>
        </trans-unit>
        <trans-unit id="884734e755cc6d6bbd1b938aff073932b22e3094" translate="yes" xml:space="preserve">
          <source>Just change the Kotlin version to &lt;code&gt;1.4.0&lt;/code&gt; and re-import your Gradle or Maven project. The IDE will then ask you about migration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Как и Java 8,Котлин поддерживает преобразование SAM.Это означает,что функциональные литералы Котлина могут быть автоматически преобразованы в реализации Java-интерфейсов одним ненарушимым методом,если типы параметров метода интерфейса соответствуют типам параметров функции Котлина.</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">Так же,как и Java и JavaScript,Kotlin поддерживает комментарии в конце строки и блокировку.</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Подобно анонимным внутренним классам Java,код в объектных выражениях может получать доступ к переменным из закрывающейся области видимости.(В отличие от Java,это не ограничивается конечными или фактически конечными переменными).</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Как и в Java, особый случай - параметр &lt;code&gt;value&lt;/code&gt; ; его значение можно указать без явного имени:</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Как и в Java, классы перечисления в Kotlin имеют синтетические методы, позволяющие перечислить определенные константы перечисления и получить константу перечисления по их имени. Сигнатуры этих методов следующие (при условии, что имя класса enum - &lt;code&gt;EnumClass&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">Как и обычные члены объекта-сопутника,их можно вызывать,используя в качестве классификатора только имя класса:</target>
        </trans-unit>
        <trans-unit id="27573ad44b2952298adae482665b1d05330c84b0" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt; extension function in the Kotlin standard library, flows have a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt; operator that combines the corresponding values of two flows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">Как и в случае с JavaDoc, комментарии KDoc начинаются с &lt;code&gt;/**&lt;/code&gt; и заканчиваются &lt;code&gt;*/&lt;/code&gt; . Каждая строка комментария может начинаться со звездочки, которая не считается частью содержания комментария.</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="7d24ba100f0e49fea8997c1580577eea18ef483a" translate="yes" xml:space="preserve">
          <source>KAPT: Names of synthetic &lt;code&gt;$annotations()&lt;/code&gt; methods for properties have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">синтаксис KDoc</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">В настоящее время KDoc поддерживает следующие теги блоков:</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc не поддерживает тег &lt;code&gt;@deprecated&lt;/code&gt; . Вместо этого используйте аннотацию &lt;code&gt;@Deprecated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">синтаксис KDoc</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt может генерировать исходники Kotlin. Просто запишите сгенерированные исходные файлы Kotlin в каталог, указанный в &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; , и эти файлы будут скомпилированы вместе с основными исходными кодами .</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Плагин компилятора Kapt доступен в бинарном дистрибутиве компилятора Kotlin.</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt использует компилятор Java для запуска процессоров аннотаций.</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">Имейте в виду, что это всего лишь синтаксический сахар - на самом деле вы не изменяете класс или его экземпляры. Следовательно, вам необходимо импортировать функцию / свойство расширения везде, где вы хотите их использовать (поскольку они не переносятся вместе с экземплярами класса). По той же причине вы не можете переопределить члены расширения - вы можете переопределить их для подтипов, но разрешение происходит во время компиляции на основе статического типа выражения, для которого вы его вызываете. Итак, если вы объявляете функцию расширения для &lt;code&gt;Vehicle&lt;/code&gt; и функцию с тем же именем и подписью для ее подкласса &lt;code&gt;Car&lt;/code&gt; , и вы делаете следующее, будет вызываться функция расширения для &lt;code&gt;Vehicle&lt;/code&gt; , даже если &lt;code&gt;v&lt;/code&gt; на самом деле является &lt;code&gt;Car&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">Сохраните язык современным на протяжении многих лет.</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Приложение Keepsafe App Lock также было &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;преобразовано в 100% Kotlin&lt;/a&gt; , что привело к уменьшению количества исходных строк на 30% и уменьшению количества методов на 10%.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">Ключ для элементов &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; - это тип элемента с этим ключом.</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">Ключ для элементов &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; - это тип элемента с этим ключом. Ключи в контексте сравниваются &lt;em&gt;по ссылке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">Ключевые слова и операторы</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">Вид модуля,сгенерированного компилятором</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">Вроде этого параметра.</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind представляет собой конкретную позицию объявления параметра в исходном коде,например,экземпляр,параметр приемника-расширителя или параметр значения.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">Известные проблемы</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1 представил сопрограммы, новый способ написания асинхронного, неблокирующего кода (и многое другое). В этом руководстве мы рассмотрим некоторые основы использования сопрограмм Kotlin с помощью библиотеки &lt;code&gt;kotlinx.coroutines&lt;/code&gt; , которая представляет собой набор помощников и оберток для существующих библиотек Java.</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1 снимает некоторые из ограничений на герметичность и классы данных,которые присутствовали в Kotlin 1.0.Теперь в том же файле можно определить подклассы класса опечатанных данных верхнего уровня,а не только вложенные классы класса опечатанных данных.Классы данных теперь могут расширять другие классы.Это можно использовать для красивого и чистого определения иерархии классов выражений:</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2 представляет набор функций для работы с &lt;code&gt;BigInteger&lt;/code&gt; и &lt;code&gt;BigDecimal&lt;/code&gt; и их создания из других числовых типов. Эти:</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3 продолжает развиваться и совершенствовать API для скриптов,внедряя некоторые экспериментальные средства для настройки скриптов,такие как добавление внешних свойств,обеспечение статических или динамических зависимостей и так далее.</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3 продолжает улучшать и совершенствовать родную цель. См. Подробности в &lt;a href=&quot;native-overview&quot;&gt;обзоре Kotlin / Native&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3 представил более простую форму &lt;code&gt;main&lt;/code&gt; , которая не принимает параметров. Теперь &amp;laquo;Hello, World&amp;raquo; в Котлине на 19 символов короче!</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3 вводит новый вид объявления - &lt;code&gt;inline class&lt;/code&gt; . Встроенные классы можно рассматривать как ограниченную версию обычных классов, в частности, встроенные классы должны иметь ровно одно свойство:</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">В Kotlin 1.3 введены вызываемые ссылки на функции приостановки и поддержку Coroutines в Reflection API.</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">В Kotlin 1.3 появилась поддержка рабочих &lt;em&gt;файлов&lt;/em&gt; Kotlin с &lt;em&gt;нуля&lt;/em&gt; . &lt;em&gt;Скретч-файл&lt;/em&gt; - это файл сценария kotlin с расширением .kts, который вы можете запустить и получить результаты оценки прямо в редакторе.</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3 вводит поддержку &lt;a href=&quot;coding-conventions&quot;&gt;рекомендуемого стиля кода&lt;/a&gt; в IDE. Ознакомьтесь с инструкциями по миграции на &lt;a href=&quot;code-style-migration-guide&quot;&gt;этой странице&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">В Kotlin 1.3 введены беззнаковые целочисленные типы:</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 ослабляет это ограничение и добавляет поддержку функций с большей арсеналностью:</target>
        </trans-unit>
        <trans-unit id="066cd750e197b01a81e98cd924fadfe8604b9df8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 supports more cases for using callable references:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5350f6595e85d319ae1e0cc79c4bfec4d9dbf0c3" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 uses a new, more powerful type inference algorithm. This new algorithm was already available to try in Kotlin 1.3 by specifying a compiler option, and now it&amp;rsquo;s used by default. You can find the full list of issues fixed in the new algorithm in &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrack&lt;/a&gt;. Here you can find some of the most noticeable improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc80b855b0a3b819dba3841d64e1cfc7470a8c4" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 adds &lt;code&gt;module-info.java&lt;/code&gt; module information to default standard library artifacts. This lets you use them with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt; tool&lt;/a&gt;, which generates custom Java runtime images containing only the platform modules that are required for your app. You could already use jlink with Kotlin standard library artifacts, but you had to use separate artifacts to do so &amp;ndash; the ones with the &amp;ldquo;modular&amp;rdquo; classifier &amp;ndash; and the whole setup wasn&amp;rsquo;t straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0378da784d7afe2b6f5df83cd22d948f8f205d9b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with a variety of different language features and improvements. They include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c73be7140ebf78f98979e2eca4cd593ef933ad" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with lots of features and improvements in the tooling for multiplatform programming. Some of them just work out of the box on existing projects, and some require additional configuration steps. This guide will help you migrate your multiplatform projects to 1.4.0 and get the benefits of all its new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7a073ad0548ea1abeb025f0d02a8940c8b2833" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 does not provide a public API for such extensions yet, but we are working closely with our partners, including &lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack Compose&lt;/a&gt;, who are already building their compiler plugins using our new backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119bb4e318a0a5c97768f9b15754a1c8be59df76" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 includes a number of JVM-specific improvements, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b88cbfefbff762c9e5fd3f41575d2d7448be9e" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 introduces the Alpha IR compiler for Kotlin/JS. For more detailed information about the Kotlin/JS IR compiler&amp;rsquo;s backend and how to configure it, consult the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">&lt;code&gt;object Object&lt;/code&gt; Kotlin Объект доступен как &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; . Есть функция &lt;code&gt;_instance&lt;/code&gt; для получения единственного экземпляра объекта.</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Расширения для Android Котлин</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Котлинские конвенции по кодированию и форматер IntelliJ IDEA</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">Обзор коллекций Котлин</target>
        </trans-unit>
        <trans-unit id="2e918bca9080c65d49a41d94237060bf519ea8e7" translate="yes" xml:space="preserve">
          <source>Kotlin Compiler Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">Котлин Определение</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Образовательный модуль Котлина</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">Эволюция Котлина</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">Котлин Примеры</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Плагин Kotlin Gradle 1.3.41 работает с Android Gradle Plugin 3.0 и выше.</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript Обзор</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;API выборки W3C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">Kotlin JavaScript-оболочки для &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;файлового API W3C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;API XMLHttpRequest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;API времени навигации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">Оболочки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;API веб-уведомлений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">Оболочки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM API.</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM CSS API.</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">Обертки Kotlin JavaScript для DOM SVG API.</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM URL API.</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">Котлин JavaScript обертки для DOM событий API.</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">Котлин JavaScript-обертки для API разбора DOM.</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">Котлин JavaScript-обертки для WebGL API.</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">Котлин Коанс</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Котлин Коанс-это серия упражнений,которые познакомят вас с синтаксисом Котлина.Каждое упражнение создается как неудачный юнит-тест,и ваша задача-заставить его пройти.Вы можете работать с Котлинским Коаном одним из следующих двух способов:</target>
        </trans-unit>
        <trans-unit id="409a3dab696a4f7e601ab24128dac2f50d01d468" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c495a5c1562a573edd3b920fba276a2422fbf84" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Gradle DSL Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Для многоплатформенных проектов Котлин требуются версии Gradle 4.7 и выше,более старые версии Gradle не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Многоплатформенные проекты Kotlin поддерживают платформу Android, предоставляя предустановку &lt;code&gt;android&lt;/code&gt; . Для создания цели Android требуется, чтобы к проекту вручную был применен один из плагинов Android Gradle, например &lt;code&gt;com.android.application&lt;/code&gt; или &lt;code&gt;com.android.library&lt;/code&gt; . Для каждого подпроекта Gradle может быть создана только одна цель Android:</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">Котлинские номера и NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Котлин Программирование:Путеводитель по Большому Ранчо Ботаников</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">API сценариев Котлин</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Котлин Скриптс (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Стандартная библиотека Котлина</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin позволяет нам предоставлять реализации для предопределенного набора операторов наших типов. Эти операторы имеют фиксированное символическое представление (например, &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;*&lt;/code&gt; ) и фиксированный &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;приоритет&lt;/a&gt; . Для реализации оператора мы предоставляем функцию- &lt;a href=&quot;functions#member-functions&quot;&gt;член&lt;/a&gt; или функцию &lt;a href=&quot;extensions&quot;&gt;расширения&lt;/a&gt; с фиксированным именем для соответствующего типа, то есть левосторонний тип для бинарных операций и тип аргумента для унарных. Функции, которые перегружают операторы, должны быть помечены модификатором &lt;code&gt;operator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin позволяет компилировать ваши проекты Kotlin в модули JavaScript для популярных модульных систем.Вот список доступных опций:</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin позволяет вам обеспечить видимость символов (что Python делает только с помощью соглашений о подчеркивании) с помощью &lt;em&gt;модификаторов видимости&lt;/em&gt; , которые могут быть помещены в объявления символов. Если вы не предоставите модификатор видимости, вы получите уровень видимости по умолчанию, который является &lt;em&gt;общедоступным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">В Kotlin также есть специализированные классы для представления массивов примитивных типов без накладных расходов: &lt;code&gt;ByteArray&lt;/code&gt; , &lt;code&gt;ShortArray&lt;/code&gt; , &lt;code&gt;IntArray&lt;/code&gt; и так далее. Эти классы не имеют отношения наследования к классу &lt;code&gt;Array&lt;/code&gt; , но имеют одинаковый набор методов и свойств. У каждого из них также есть соответствующая фабричная функция:</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin также поддерживает обычную нотацию для чисел с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Котлин и непрерывная интеграция с TeamCity</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">Котлин и OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Котлин и Свифт определяют nullability как часть спецификации типа,в то время как Objc определяет nullability по методам и свойствам типа.Таким образом,следующее:</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Приложения Kotlin могут быть развернуты на любом хосте,поддерживающем Java-приложения,включая Amazon Web Services,Google Cloud Platform и другие.</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">Котлин как статически типизированный язык программирования хорошо подходит для написания скриптов Gradle build.Благодаря статическому выводу типа,компилятор Kotlin обнаруживает ошибки раньше и выдает важные сообщения об ошибках компиляции и предупреждения.Как IDE,так и компилятор могут использовать информацию о типах для вывода доступных функций и свойств в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Котлин также может быть использован в качестве скриптового языка.Скрипт-это исходный файл Kotlin (.kts)с исполняемым кодом верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin может быть скомпилирован для нескольких различных платформ.В данном документе мы предполагаем,что целевой платформой является виртуальная машина Java,которая предоставляет некоторые дополнительные возможности-в частности,ваш код будет скомпилирован в байткод Java и,следовательно,будет взаимодействовать с большой экосистемой библиотек Java.</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Котлин может быть использован для любых разработок,будь то серверная часть,клиентская часть,веб или Android.В настоящее время Kotlin/Native работает над поддержкой других платформ,таких как встраиваемые системы,макросы и iOS.Люди используют Kotlin для мобильных и серверных приложений,клиентской стороны с JavaScript или JavaFX,и науки о данных,просто чтобы назвать несколько возможностей.</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin можно использовать вместе с существующими сторонними библиотеками и фреймворками, такими как jQuery или React. Для доступа рамок третьей стороны с сильно типизированным API, вы можете преобразовать определения Машинописи Из &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Определенно Введенные&lt;/a&gt; определений типа хранилище для Котлина с помощью &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; инструмента. В качестве альтернативы вы можете использовать &lt;a href=&quot;dynamic-type&quot;&gt;динамический тип&lt;/a&gt; для доступа к любой структуре без строгой типизации.</target>
        </trans-unit>
        <trans-unit id="8ac487e3599218d513d99cbe95341abd1004db54" translate="yes" xml:space="preserve">
          <source>Kotlin can build a &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;source set hierarchy&lt;/a&gt; with the &lt;code&gt;dependsOn&lt;/code&gt; relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin может быть довольно близок к компактности понимания Python &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; . Предполагая, что &lt;code&gt;people&lt;/code&gt; - это коллекция объектов &lt;code&gt;Person&lt;/code&gt; со свойством &lt;code&gt;name&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a109a14558842e44146557931b4bc933ed0c8e4" translate="yes" xml:space="preserve">
          <source>Kotlin can now generate type annotations in the JVM bytecode (target version 1.8+), so that they become available in Java reflection at runtime. To emit the type annotation in the bytecode, follow these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01363668f0c8a96c308b85201388c8e9019873f8" translate="yes" xml:space="preserve">
          <source>Kotlin can use only Swift declarations marked with the &lt;code&gt;@objc&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin не может различать числовые типы во время выполнения (кроме &lt;code&gt;kotlin.Long&lt;/code&gt; ), т.е. работает следующий код:</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Котлин заботится о стабильности и обратной совместимости кода:Политика совместимости Kotlin гласит,что &quot;прерывание изменений&quot; (например,изменение,которое делает код,который раньше компилировался хорошо,больше не компилируется)может быть введено только в мажорных релизах (1.2,1.3 и т.д.).</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Классы и интерфейсы Kotlin могут быть разделены на подклассы и протоколы Swift/Objective-C.</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Классы Kotlin имеют базовый класс &lt;code&gt;KotlinBase&lt;/code&gt; в Objective-C, класс расширяет там класс &lt;code&gt;NSObject&lt;/code&gt; . У нас также есть оболочки для коллекций и исключений. Большинство типов коллекций сопоставляются с аналогичными типами коллекций с другой стороны:</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Котлинский код можно легко вызвать с Java.Например,экземпляры класса Kotlin могут быть легко созданы и работать в методах Java.Тем не менее,существуют определенные различия между Java и Котлином,которые требуют внимания при интеграции кода Котлин в Java.На этой странице мы расскажем о том,как настроить взаимодействие вашего кода Котлин с его Java-клиентами.</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Коллекции Kotlin (например, &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; и т. Д.) Не сопоставляются ни с каким конкретным типом JavaScript.</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Коллекции Kotlin конвертируются в коллекции Swift / Objective-C, как описано в таблице выше. Коллекции Swift / Objective-C сопоставляются с Kotlin таким же образом, за исключением &lt;code&gt;NSMutableSet&lt;/code&gt; и &lt;code&gt;NSMutableDictionary&lt;/code&gt; . &lt;code&gt;NSMutableSet&lt;/code&gt; не преобразуется в Kotlin &lt;code&gt;MutableSet&lt;/code&gt; . Чтобы передать объект для Kotlin &lt;code&gt;MutableSet&lt;/code&gt; , вы можете создать такую ​​коллекцию Kotlin явно, создав ее в Kotlin с помощью, например, &lt;code&gt;mutableSetOf()&lt;/code&gt; , или используя класс &lt;code&gt;KotlinMutableSet&lt;/code&gt; в Swift (или &lt;code&gt;${prefix}MutableSet&lt;/code&gt; в Objective-C, где &lt;code&gt;prefix&lt;/code&gt; префикс имен фреймворков). То же самое и с &lt;code&gt;MutableMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Коллекции Kotlin содержат функции для часто используемых &lt;em&gt;агрегатных операций&lt;/em&gt; - операций, которые возвращают одно значение на основе содержимого коллекции. Большинство из них хорошо известны и работают так же, как и на других языках:</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Коллекции Котлина предоставляют набор функций для извлечения отдельных элементов из коллекций.Функции,описанные на этой странице,применимы как к спискам,так и к наборам.</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Котлинское сообщество открыто,полезно и гостеприимно.Не стесняйтесь присоединяться и спрашивайте на любой понравившейся вам платформе:</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Компилятор Kotlin генерирует обычные JavaScript-классы,функции и свойства,которые вы можете свободно использовать из JavaScript-кода.Тем не менее,есть некоторые тонкости,которые следует помнить.</target>
        </trans-unit>
        <trans-unit id="e2af437257c982ea32c02d4a42942eceaf188caa" translate="yes" xml:space="preserve">
          <source>Kotlin compiler offers &lt;em&gt;explicit API mode&lt;/em&gt; for library authors. In this mode, the compiler performs additional checks that help make the library&amp;rsquo;s API clearer and more consistent. It adds the following requirements for declarations exposed to the library&amp;rsquo;s public API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Компилятор Kotlin выдает байт-код,таким образом,действительно нет никакой разницы во внешнем виде и ощущении Kotlin-приложений по сравнению с приложениями,написанными на Java.</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">особенности компилятора Kotlin</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Компилятор Kotlin сгенерирует следующий вывод</target>
        </trans-unit>
        <trans-unit id="f142a3debb6f5ab93f8769b5839aca7d9de9a318" translate="yes" xml:space="preserve">
          <source>Kotlin compilers have a number of options for tailoring the compiling process. Compiler options for different targets are listed on this page together with a description of each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Котлинские конструкторы импортируются в качестве инициализаторов в Свифт/Объект-С.</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Котлин документации является хорошим местом,чтобы начать,проверьте эти ссылки,чтобы намочить ноги:</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">В Kotlin нет &lt;em&gt;диспетчеров ресурсов&lt;/em&gt; Python или &lt;em&gt;try-with-resources&lt;/em&gt; Java , но благодаря функциям расширения можно &lt;code&gt;use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">В Kotlin нет проверенных &lt;a href=&quot;exceptions&quot;&gt;исключений&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Котлин не проверяет исключения.Причин для этого много,но мы приведем простой пример.</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Котлин не реализует ленивую инициализацию свойств верхнего уровня в JavaScript.</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Котлин обеспечивает тип безопасности операций , связанных с &lt;a href=&quot;generics&quot;&gt;дженерики&lt;/a&gt; во время компиляции, в то время, во время выполнения, экземпляры общих типов не держат информацию о своих действительных аргументов типа. Например, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; стирается до &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; . В общем, во время выполнения невозможно проверить, принадлежит ли экземпляр универсальному типу с определенными аргументами типа.</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin подвергает свою структуру пакета JavaScript,поэтому,если вы не определяете свои объявления в корневом пакете,вы должны использовать полностью квалифицированные имена в JavaScript.Например:</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Котлин исправляет ряд проблем,от которых страдает Java:</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Котлин следует конвенциям по наименованию Java.В частности:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Котлин для Android Case Studies</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Котлин для разработчиков Android</target>
        </trans-unit>
        <trans-unit id="697d1de6e7cb2c06571dc421613de269a61dd215" translate="yes" xml:space="preserve">
          <source>Kotlin for Data Science</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Котлин для Java-разработчиков</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Объекты с функциональным типом Kotlin (например, лямбды) преобразуются в блоки функций Swift / Objective-C. Однако существует разница в том, как типы параметров и возвращаемые значения отображаются при преобразовании функции и типа функции. В последнем случае примитивные типы отображаются в их коробочное представление. Возвращаемое значение Kotlin &lt;code&gt;Unit&lt;/code&gt; представлено как соответствующий синглтон &lt;code&gt;Unit&lt;/code&gt; в Swift / Objective-C. Значение этого синглтона можно получить так же, как и для любого другого &lt;code&gt;object&lt;/code&gt; Kotlin (см. Синглтоны в таблице выше). Подводя итог:</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Функции Kotlin являются &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;первоклассными&lt;/em&gt;&lt;/a&gt; , что означает, что они могут храниться в переменных и структурах данных, передаваться в качестве аргументов и возвращаться из других &lt;a href=&quot;#higher-order-functions&quot;&gt;функций более высокого порядка&lt;/a&gt; . Вы можете работать с функциями любым способом, который возможен для других нефункциональных значений.</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin генерирует JavaScript код,совместимый с Asynchronous Module Definition (AMD),CommonJS и Universal Model Definition (UMD).</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin обрабатывает номера в некотором роде близко к Java,но не точно так же.Например,для чисел нет неявных расширенных преобразований,а литералы в некоторых случаях немного отличаются.</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Котлин имеет довольно небольшой размер исполняемого файла:библиотека составляет примерно 964КБ (на 1.3.41).Это означает,что Kotlin добавляет немного к размеру .apk файла.</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin располагает обширной стандартной библиотекой,которая может быть использована в ваших приложениях.Настройте следующую зависимость в файле pom:</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Котлин был успешно принят крупными компаниями,и некоторые из них поделились своим опытом:</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin имеет как объектно-ориентированные, так и функциональные конструкции. Вы можете использовать его как в OO, так и в FP-стилях или смешивать их элементы. Благодаря первоклассной поддержке таких функций, как функции высшего порядка, типы функций и лямбда-выражения, Kotlin - отличный выбор, если вы занимаетесь или изучаете функциональное программирование.</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin имеет классы и их члены по умолчанию &lt;code&gt;final&lt;/code&gt; , что делает неудобным использование фреймворков и библиотек, таких как Spring AOP, которые требуют, чтобы классы были &lt;code&gt;open&lt;/code&gt; . &lt;em&gt;Все открытый&lt;/em&gt; плагин компилятора приспосабливается Котлин требований этих рамок и делает классы аннотированные с конкретными аннотациями и их члены открыть без явного &lt;code&gt;open&lt;/code&gt; ключевого слова.</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">У Kotlin есть собственная библиотека отражений (в &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; должен быть включен kotlin-reflection.jar ). При ориентации на JVM вы также можете использовать средства отражения Java. Обратите внимание, что отражение Kotlin еще не совсем полнофункционально - в частности, вы не можете использовать его для проверки встроенных классов, таких как &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin унаследовал от Java суетливый (но очень гибкий) способ выполнения ввода-вывода, но с некоторыми упрощающими дополнительными функциями. Мы не будем вдаваться во все это здесь, поэтому для начала вот как перебирать все строки файла (вам понадобится &lt;code&gt;import java.io.File&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin унаследовал систему массивных массивов Java, поэтому у примитивных типов есть свои собственные типы массивов и функции преобразования, в то время как любой другой тип использует общий тип &lt;code&gt;Array&lt;/code&gt; , в который вы можете преобразовать с помощью &lt;code&gt;.toTypedArray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">В Kotlin нет концепции проверенных исключений, все исключения Kotlin не отмечены. Swift только проверял ошибки. Поэтому, если код Swift или Objective-C вызывает метод Kotlin, который генерирует исключение для обработки, тогда метод Kotlin должен быть помечен аннотацией &lt;code&gt;@Throws&lt;/code&gt; . В этом случае все исключения Kotlin (кроме экземпляров &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;RuntimeException&lt;/code&gt; и подклассов) переводятся в Swift error / &lt;code&gt;NSError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin теперь имеет возможность генерировать байт-код Java 8 ( &lt;code&gt;-jvm-target 1.8&lt;/code&gt; командной строки -jvm-target 1.8 или соответствующие параметры в Ant / Maven / Gradle). На данный момент это не меняет семантику байт-кода (в частности, методы по умолчанию в интерфейсах и лямбдах генерируются точно так же, как в Kotlin 1.0), но мы планируем использовать это позже.</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">Kotlin имеет правильные &lt;a href=&quot;lambdas#function-types&quot;&gt;типы функций&lt;/a&gt; , в отличие от Java-преобразований SAM.</target>
        </trans-unit>
        <trans-unit id="0bf97cc3e62a44a9f204f95382694f7ebe3c3d2c" translate="yes" xml:space="preserve">
          <source>Kotlin has supported SAM conversions for Java interfaces from the beginning, but there was one case that wasn&amp;rsquo;t supported, which was sometimes annoying when working with existing Java libraries. If you called a Java method that took two SAM interfaces as parameters, both arguments needed to be either lambdas or regular objects. You couldn't pass one argument as a lambda and another as an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">У Котлина есть три структурных прыжковых выражения:</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Котлин имеет два типа строковых литералов:экранированные строки,в которых могут быть экранированные символы,и сырые строки,которые могут содержать новые строки и произвольный текст.Экрапированная строка очень похожа на Java-строку:</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">Котлин в действии</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Котлин вводит следующие типы для беззнаковых целых чисел:</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin-это скомпилированный,статически типизированный язык,который может предоставить некоторые начальные трудности для людей,привыкших к интерпретируемому,динамически типизированному Python.Цель этого документа-объяснить существенную часть синтаксиса Котлина и его концепций с точки зрения того,как они сравниваются с соответствующими концепциями на Python.</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Котлин отлично подходит для разработки Android-приложений,перенося все преимущества современного языка на платформу Android без введения каких-либо новых ограничений:</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin отлично подходит для разработки серверных приложений,позволяя писать лаконичный и выразительный код,сохраняя при этом полную совместимость с существующими стеками технологий на основе Java и плавный ход обучения:</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlin - это прагматичный и малоизвестный язык, поддерживающий как императивные, так и функциональные стили программирования, не подталкивая разработчика ни к одному из них. Мы можем реализовать функцию &lt;code&gt;f&lt;/code&gt; в функциональном стиле, используя такие функции Kotlin, как &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;хвостовая рекурсия&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin - это статически типизированный язык программирования OSS, предназначенный для JVM, Android, JavaScript и Native. Он разработан &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; . Проект стартовал в 2010 году и с самого начала был открытым. Первый официальный выпуск 1.0 был в феврале 2016 года.</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin совместим с CommonJS, AMD и UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;что упрощает взаимодействие с различными&lt;/a&gt; модульными системами.</target>
        </trans-unit>
        <trans-unit id="60bc1c7729db3b60c6d62ba20f7492d0f9556d43" translate="yes" xml:space="preserve">
          <source>Kotlin is concise, readable and easy to learn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin разработан как прагматичный инструмент для программистов.Когда речь заходит об эволюции языка,его прагматичность определяется следующими принципами:</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin разработан, чтобы его было легко изучить для людей, которые уже знают Java. Краткий обзор различий представлен на &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;официальной странице сравнения&lt;/a&gt; . Краткое введение в базовый синтаксис Kotlin для разработчиков программного обеспечения можно найти прямо в справочном разделе веб-сайта, начиная с &lt;a href=&quot;../reference/basic-syntax&quot;&gt;базового синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Котлин разработан с учетом Java-интероперабельности.Существующий Java-код может быть вызван из Котлина естественным образом,а Kotlin-код также может быть использован из Java довольно гладко.В этом разделе мы опишем некоторые детали вызова Java кода из Котлина.</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin распространяется вместе &lt;code&gt;kotlin.js&lt;/code&gt; стандартной библиотекой kotlin.js в виде одного файла, который сам скомпилирован как модуль UMD, поэтому вы можете использовать его с любой системой модулей, описанной выше. Также он доступен на NPM как &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;пакет &lt;/a&gt; &lt;code&gt;kotlin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Котлин вдохновлен существующими языками,такими как Java,C#,JavaScript,Scala и Groovy.Мы постарались сделать так,чтобы Котлин был легким для изучения,чтобы люди могли легко прыгать на борт,читать и писать Котлин в течение нескольких дней.Изучение идиоматического Kotlin и использование некоторых дополнительных функций может занять немного больше времени,но в целом это не сложный язык.</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Котлин более лаконичен. По приблизительным оценкам, количество строк кода сократилось примерно на 40%. Он также более безопасен для типов, например, поддержка типов, не допускающих значения NULL, делает приложения менее уязвимыми для NPE. Другие функции, включая интеллектуальное преобразование, функции высшего порядка, функции расширения и лямбда-выражения с приемниками, обеспечивают возможность написания выразительного кода, а также упрощают создание DSL.</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin в основном разрабатывается командой инженеров JetBrains (текущий размер команды составляет 50+). Ведущий дизайнер языка - &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Андрей Бреслав&lt;/a&gt; . Помимо основной команды, на GitHub также есть более 250 внешних участников.</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin поддерживается всеми основными IDE Java, включая &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; и &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt; . Кроме того, доступен &lt;a href=&quot;../tutorials/command-line&quot;&gt;компилятор командной строки,&lt;/a&gt; обеспечивающий прямую поддержку компиляции и запуска приложений.</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Котлин хорошо охвачен онлайн-курсами,посмотрите рекомендуемые курсы здесь:</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">Котлин позволяет легко создавать диапазоны значений с помощью &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt; функции из &lt;code&gt;kotlin.ranges&lt;/code&gt; пакета и его оператор формы &lt;code&gt;..&lt;/code&gt; . Обычно &lt;code&gt;rangeTo()&lt;/code&gt; дополняется функциями &lt;code&gt;in&lt;/code&gt; или &lt;code&gt;!in&lt;/code&gt; In .</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin позволяет управлять коллекциями независимо от того, какой именно тип объектов в них хранится. Другими словами, вы добавляете &lt;code&gt;String&lt;/code&gt; в список &lt;code&gt;String&lt;/code&gt; таким же образом, как и с &lt;code&gt;Int&lt;/code&gt; или определяемым пользователем классом. Итак, Стандартная библиотека Kotlin предлагает общие интерфейсы, классы и функции для создания, наполнения и управления коллекциями любого типа.</target>
        </trans-unit>
        <trans-unit id="a804893fba1e9dc304662ad5aa9e7244e8ba7e41" translate="yes" xml:space="preserve">
          <source>Kotlin libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">метаданные Котлина</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Модули Kotlin можно использовать в коде Swift / Objective-C, если они скомпилированы в фреймворк (см. Раздел &amp;laquo;Цели и типы вывода&amp;raquo; в &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;документации плагина Gradle&lt;/a&gt; ). См. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;Пример калькулятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f16158d7bd59887136035c889e332065c93a9e3" translate="yes" xml:space="preserve">
          <source>Kotlin multiplatform projects use compilations for producing artifacts. Each target can have one or more compilations, for example, for production and test purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin теперь интегрируется с &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;API javax.script&lt;/a&gt; (JSR-223). API позволяет оценивать фрагменты кода во время выполнения:</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin теперь поддерживает сохранение имен параметров в байт-коде. Это можно включить с помощью &lt;code&gt;-java-parameters&lt;/code&gt; командной строки -java-parameters .</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; типы Kotlin, за исключением kotlin.Long , отображаются в JavaScript Number.</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Объекты Котлина могут быть пиннингованы,т.е.их положение в памяти гарантированно будет стабильным до тех пор,пока они не будут пиннингованы,а указатели на такие объекты внутренние данные могут быть переданы в функции С.Например</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">Плагин Kotlin 1.3.21 или выше должен быть установлен в среде IDE. Это можно проверить с помощью &lt;em&gt;Language &amp;amp; Frameworks | &lt;/em&gt;Раздел &quot; &lt;em&gt;Обновления Kotlin&quot;&lt;/em&gt; в &lt;em&gt;настройках&lt;/em&gt; (или &lt;em&gt;предпочтениях&lt;/em&gt; ) среды IDE.</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">Плагин Kotlin для IntelliJ IDEA поддерживает &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;царапины&lt;/a&gt; . Scratches позволяют создавать черновики кода в том же окне IDE, что и ваш проект, и запускать их на лету. Царапины не привязаны к проектам; вы можете получить доступ и запустить все свои царапины из любого окна IntelliJ IDEA в вашей ОС.</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Котлин сохраняет ленивую инициализацию объекта в JavaScript.</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin сохраняет семантику переполнения для &lt;code&gt;kotlin.Int&lt;/code&gt; , &lt;code&gt;kotlin.Byte&lt;/code&gt; , &lt;code&gt;kotlin.Short&lt;/code&gt; , &lt;code&gt;kotlin.Char&lt;/code&gt; и &lt;code&gt;kotlin.Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Коробки примитивных типов Kotlin отображаются в специальные классы Swift / Objective-C. Например, поле &lt;code&gt;kotlin.Int&lt;/code&gt; представлено как &lt;code&gt;KotlinInt&lt;/code&gt; класса KotlinInt в Swift (или экземпляр &lt;code&gt;${prefix}Int&lt;/code&gt; в Objective-C, где &lt;code&gt;prefix&lt;/code&gt; - это префикс имен фреймворков). Эти классы являются производными от &lt;code&gt;NSNumber&lt;/code&gt; , поэтому экземпляры являются собственными &lt;code&gt;NSNumber&lt;/code&gt; , поддерживающими все соответствующие операции.</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231e51698e1b22447348936da3858b45208fbb94" translate="yes" xml:space="preserve">
          <source>Kotlin projects require a recent version of Gradle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">Свойства Kotlin,объявленные в именованном объекте или в качестве объекта-сопутника,будут иметь статические поля подложки либо в этом именованном объекте,либо в классе,содержащем объект-сопутник.</target>
        </trans-unit>
        <trans-unit id="b0f8122e9d8ea69357864a2385801f06d58ec608" translate="yes" xml:space="preserve">
          <source>Kotlin provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt; and DSL to configure this for a specific compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin предоставляет ряд опций компилятора,которые доступны и в IntelliJ IDEA.В дополнение к тому,что мы только что видели для генерации исходных карт,у нас также есть возможность установить</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">Kotlin предоставляет множество функций для выполнения блока кода в контексте заданного объекта: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , а &lt;code&gt;also&lt;/code&gt; . Инструкции по выбору подходящей функции осциллографа для вашего случая см. В &lt;a href=&quot;scope-functions&quot;&gt;разделе Функции осциллографа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin предоставляет для этого так называемый синтаксис &lt;strong&gt;звездной проекции&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin предоставляет возможность нацеливания на JavaScript.Это делается путем переноса Kotlin на JavaScript.Текущая реализация нацелена на ECMAScript 5.1,но есть планы,что в конце концов она будет нацелена и на ECMAScript 2015.</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin предоставляет следующие встроенные типы представления чисел (это близко к Java):</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Котлин выполняет три задания для муравья:</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin требует, чтобы каждое свойство-член инициализировалось во время создания экземпляра. Иногда класс предназначен для использования таким образом, что у конструктора недостаточно информации для инициализации всех свойств (например, при создании класса построителя или при использовании внедрения зависимостей на основе свойств). Чтобы не делать эти свойства обнуляемыми, вы можете использовать &lt;em&gt;свойство&lt;/em&gt; с &lt;em&gt;поздней инициализацией&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">Скрипты Kotlin в файлах &lt;code&gt;build.gradle.kts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Синглтон Kotlin (сделанный с объявлением &lt;code&gt;object&lt;/code&gt; , включая &lt;code&gt;companion object&lt;/code&gt; ) импортируется в Swift / Objective-C как класс с одним экземпляром. Экземпляр доступен через фабричный метод, то есть как &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; в Objective-C и &lt;code&gt;MySingleton()&lt;/code&gt; в Swift.</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">котлинские синглоны</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">Kotlin исходный файл или каталог для компиляции</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Исходные наборы Kotlin могут быть связаны с отношением &lt;em&gt;&amp;laquo;зависит от&amp;raquo;&lt;/em&gt; , так что если исходный набор &lt;code&gt;foo&lt;/code&gt; зависит от &lt;code&gt;bar&lt;/code&gt; исходного набора, то:</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Исходные тексты Kotlin могут смешиваться с исходными текстами Java в одной и той же папке или в разных папках.По умолчанию используются разные папки:</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448431d8ccbcd8c407715ad54cff923c4f538ad6" translate="yes" xml:space="preserve">
          <source>Kotlin standard libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Артефакты стандартной библиотеки Kotlin и сплит-пакеты</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin поддерживает стиль функционального программирования, известный как &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;хвостовая рекурсия&lt;/a&gt; . Это позволяет записывать некоторые алгоритмы, которые обычно пишутся с использованием циклов, с использованием рекурсивной функции, но без риска переполнения стека. Когда функция помечена модификатором &lt;code&gt;tailrec&lt;/code&gt; и соответствует требуемой форме, компилятор оптимизирует рекурсию, оставляя вместо этого быструю и эффективную версию на основе цикла:</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает обработку &lt;em&gt;аннотаций с помощью инструмента обработки аннотаций Kotlin&lt;/em&gt; ( &lt;code&gt;kapt&lt;/code&gt; ). Использование kapt с Gradle описано на &lt;a href=&quot;kapt&quot;&gt;странице kapt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin поддерживает локальные функции,т.е.функцию внутри другой функции:</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin поддерживает наследование классов с одним родителем - поэтому каждый класс (кроме корневого класса &lt;code&gt;Any&lt;/code&gt; ) имеет ровно один родительский класс, называемый &lt;em&gt;суперклассом&lt;/em&gt; . Kotlin хочет, чтобы вы продумали дизайн своего класса, чтобы убедиться, что его действительно безопасно создавать &lt;em&gt;подклассы&lt;/em&gt; , поэтому классы по умолчанию &lt;em&gt;закрыты&lt;/em&gt; и не могут быть унаследованы, если вы явно не объявите класс &lt;em&gt;открытым&lt;/em&gt; или &lt;em&gt;абстрактным&lt;/em&gt; . Затем вы можете создать подкласс от этого класса, объявив новый класс, который упоминает свой родительский класс после двоеточия:</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin поддерживает следующие операторы и специальные символы:</target>
        </trans-unit>
        <trans-unit id="a681ed989bc5949117e886914d64403b1862e6f9" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following platforms and provides target presets for each platform. See how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;use a target preset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает стандартный набор арифметических операций с числами, которые объявлены как члены соответствующих классов (но компилятор оптимизирует вызовы до соответствующих инструкций). См. &lt;a href=&quot;operator-overloading&quot;&gt;Перегрузка оператора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает традиционные операторы &lt;em&gt;break&lt;/em&gt; и &lt;em&gt;continue&lt;/em&gt; в циклах. См. &lt;a href=&quot;returns&quot;&gt;Возвраты и прыжки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin нацелен на широкий спектр версий Java, включая Java 6 и Java 7, где методы по умолчанию в интерфейсах не разрешены. Для вашего удобства компилятор Kotlin обходит это ограничение, но этот обходной путь несовместим с методами по &lt;code&gt;default&lt;/code&gt; , представленными в Java 8.</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">Котлин на JavaScript</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin специально обрабатывает некоторые типы Java. Такие типы не загружаются из Java &amp;laquo;как есть&amp;raquo;, а &lt;em&gt;отображаются&lt;/em&gt; на соответствующие типы Kotlin. Отображение имеет значение только во время компиляции, представление времени выполнения остается неизменным. Примитивные типы Java сопоставляются с соответствующими типами Kotlin (имея в виду &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;типы платформ&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin превращает возвращаемый тип указателя функции в объект &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; допускающий значение NULL . Сначала необходимо явно проверить значение &lt;code&gt;null&lt;/code&gt; . Для этого мы используем &lt;a href=&quot;../../reference/null-safety&quot;&gt;оператор elvis&lt;/a&gt; . Инструмент &lt;code&gt;cinterop&lt;/code&gt; помогает нам превратить указатель функции C в легко вызываемый объект в Kotlin. Это то, что мы сделали в последней строке.</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">Котлин использует семейство типов функций , таких как &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; для объявлений , которые имеют дело с функциями: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin использует префикс &lt;code&gt;libnative_&lt;/code&gt; для всех объявлений в созданном файле &lt;code&gt;libnative_api.h&lt;/code&gt; . Представим отображение типов более наглядно:</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin был разработан для удобного взаимодействия с платформой Java. Он видит классы Java как классы Kotlin, а Java видит классы Kotlin как классы Java. Однако JavaScript - это язык с динамической типизацией, что означает, что он не проверяет типы во время компиляции. Вы можете свободно общаться с JavaScript из Kotlin через &lt;a href=&quot;dynamic-type&quot;&gt;динамические&lt;/a&gt; типы, но если вам нужна вся мощь системы типов Kotlin, вы можете создавать заголовки Kotlin для библиотек JavaScript.</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin позволит вам объявить это свойство без его инициализации, и вы можете установить значение свойства в какой-то момент после построения (напрямую или через функцию). Сам класс, а также его пользователи обязаны позаботиться о том, чтобы не читать свойство до того, как оно было установлено, и Kotlin позволяет вам писать код, который считывает &lt;code&gt;name&lt;/code&gt; как если бы это было обычное свойство, не допускающее значения NULL. Однако компилятор не может обеспечить правильное использование, поэтому, если свойство читается до того, как оно было установлено, во время выполнения будет &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin довольно гладко работает с Spring Boot, и многие шаги, описанные в &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; по созданию службы RESTful, можно дословно выполнить для Kotlin. Однако есть некоторые незначительные различия, когда дело доходит до определения конфигурации Gradle и структуры макета проекта, а также кода инициализации.</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin работает с различными &lt;a href=&quot;build-tools&quot;&gt;инструментами сборки&lt;/a&gt; , поэтому, если мы используем стандартный инструмент, такой как Ant, Maven или Gradle, процесс настройки проекта Kotlin ничем не отличается от любого другого языка или библиотеки, которые интегрируются с этими инструментами. Там, где есть некоторые незначительные требования и различия, - это использование JBS, внутренней системы сборки, которую использует IntelliJ IDEA, которая также поддерживается в TeamCity.</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Подход Котлина к работе с асинхронным кодом заключается в использовании коруселей,то есть в идее приостановки вычислений,т.е.в идее,что функция может в какой-то момент приостановить свое выполнение,а потом возобновить его.</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Инструмент создания документации Kotlin называется &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; . Инструкции по использованию см. В &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Синтаксис документации Kotlin называется &lt;em&gt;KDoc&lt;/em&gt; . Блок KDoc помещается над конструкцией, которую он описывает, и начинается с &lt;code&gt;/**&lt;/code&gt; и заканчивается &lt;code&gt;*/&lt;/code&gt; (возможно, на одной строке; в противном случае каждая промежуточная строка должна начинаться с выровненной звездочки). Первый блок текста - это резюме; затем вы можете использовать &lt;em&gt;блочные теги&lt;/em&gt; для предоставления информации о конкретных частях конструкции. Некоторые теги блоков - это &lt;code&gt;@param&lt;/code&gt; для параметров функции и параметров универсального типа и &lt;code&gt;@return&lt;/code&gt; для возвращаемого значения. Вы можете ссылаться на идентификаторы внутри скобок. Весь текст за пределами ссылок и имен тегов блоков находится в формате Markdown.</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Дженерики Kotlin немного отличаются от Java (см. &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt; ). При импорте типов Java в Kotlin мы выполняем некоторые преобразования:</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Циклы Kotlin похожи на циклы Python. &lt;code&gt;for&lt;/code&gt; выполняет &lt;em&gt;итерацию&lt;/em&gt; по всему, что является &lt;em&gt;итератором&lt;/em&gt; (все, что имеет функцию &lt;code&gt;iterator()&lt;/code&gt; которая предоставляет объект &lt;code&gt;Iterator&lt;/code&gt; ), или все, что само является итератором:</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Объектная модель Kotlin существенно отличается от модели Python. Самое главное, классы &lt;em&gt;не&lt;/em&gt; могут &lt;em&gt;быть&lt;/em&gt; изменены динамически во время выполнения! (Есть некоторые ограниченные исключения из этого, но вы вообще не должны делать это , однако,. &lt;em&gt;Есть&lt;/em&gt; возможность динамически &lt;em&gt;проверять&lt;/em&gt; классы и объекты во время выполнения с помощью функции , называемой &lt;em&gt;рефлексии&lt;/em&gt; . - это может быть полезно, но должны быть разумно использованы) Все свойства (атрибуты) и функции, которые могут когда-либо понадобиться в классе, должны быть объявлены либо непосредственно в теле класса, либо как &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;функции расширения&lt;/em&gt;&lt;/a&gt; , поэтому вам следует тщательно продумать дизайн своего класса.</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Система типов Kotlin направлена ​​на устранение опасности нулевых ссылок из кода, также известной как &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;ошибка&lt;/a&gt; на миллиард долларов .</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Система типов Kotlin направлена ​​на устранение исключений &lt;code&gt;NullPointerException&lt;/code&gt; из нашего кода. Единственными возможными причинами НПЭ могут быть:</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin, как язык, предоставляет только минимальные низкоуровневые API в своей стандартной библиотеке, чтобы позволить другим библиотекам использовать сопрограммы. В отличие от многих других языков с аналогичными возможностями, &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; не являются ключевыми словами в Kotlin и даже не являются частью его стандартной библиотеки. Более того, концепция &lt;em&gt;приостановки функции&lt;/em&gt; Kotlin обеспечивает более безопасную и менее подверженную ошибкам абстракцию для асинхронных операций, чем Futures и Promises.</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">Kotlin, подобно C # и Gosu, предоставляет возможность расширять класс с помощью новых функций без необходимости наследовать от класса или использовать какой-либо тип шаблона проектирования, такой как Decorator. Это делается с помощью специальных объявлений, называемых &lt;em&gt;расширениями&lt;/em&gt; . Котлин поддерживает &lt;em&gt;функцию расширения&lt;/em&gt; и &lt;em&gt;свойство расширения&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c551ceb4f789ea0a28725793cbf50b7fde3239c9" translate="yes" xml:space="preserve">
          <source>Kotlin/JS compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c71e5ac2d4139fc0df7bb50e9a0d7dcc0b261db" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects can target two different execution environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd41eae9565ad317afb86080bea814ec06af110" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects use Gradle as a build system. To let developers easily manage their Kotlin/JS projects, we offer the &lt;code&gt;kotlin.js&lt;/code&gt; Gradle plugin that provides project configuration tools together with helper tasks for automating routines typical for JavaScript development. For example, the plugin downloads the &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; package manager for managing &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; dependencies in background and can build a JavaScript bundle from a Kotlin project using &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;. Dependency management and configuration adjustments can be done to a large part directly from the Gradle build file, with the option to override automatically generated configurations for full control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101afe89559b0f2b0c4257af7917cfec768ae3d7" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / собственные &lt;a href=&quot;native/platform_libs&quot;&gt;библиотеки&lt;/a&gt; помогают делиться кодом Kotlin между проектами. POSIX, gzip, OpenGL, Metal, Foundation и многие другие популярные библиотеки и фреймворки Apple предварительно импортированы и включены как библиотеки Kotlin / Native в пакет компилятора.</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Плагин Котлин/Отрицательная Колыбель</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Котлин/Отрицательные прогонные декларации</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native также тесно интегрирован с технологиями Apple. &lt;a href=&quot;apple-framework&quot;&gt;Котлин / Native как компания Apple Framework&lt;/a&gt; учебник объясняет , как компилировать код Котлин в качестве основы для Swift и Objective-C.</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native также тесно интегрирован с Objective-C и Swift. Он описан в учебнике &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">Котлин/Отрицательное как динамическая библиотека</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">Котлин/Отрицательное в качестве основы Apple.</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native можно использовать для многих &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;целей&lt;/a&gt; и приложений, включая, помимо прочего, macOS, Windows, Linux и &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; , инструмент генерирует привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробная информация обсуждается в учебнике &amp;laquo; &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Взаимодействие с библиотеками C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; ; инструмент создает привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробно об этом можно &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;прочитать в&lt;/a&gt; учебнике &amp;laquo; Взаимодействие с библиотеками C.</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; ; инструмент создает привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробно об этом можно &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;прочитать в&lt;/a&gt; учебнике &amp;laquo; Взаимодействие с библиотеками C. Самый быстрый способ опробовать сопоставление C API - иметь все объявления C в файле &lt;code&gt;interop.def&lt;/code&gt; , вообще не создавая никаких файлов &lt;code&gt;.h&lt;/code&gt; или &lt;code&gt;.c&lt;/code&gt; . Затем поместите объявления C в файл &lt;code&gt;interop.def&lt;/code&gt; после специальной строки разделителя &lt;code&gt;---&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Компилятор Kotlin / Native может создавать динамическую библиотеку из имеющегося у нас кода Kotlin. Динамическая библиотека часто поставляется с файлом заголовка, файлом &lt;code&gt;.h&lt;/code&gt; , который мы будем использовать для вызова скомпилированного кода из C.</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Компилятор Kotlin/Native может создать фреймворк для макросов и iOS из кода Kotlin.Созданный фреймворк содержит все объявления и двоичные файлы,необходимые для использования его с Objective-C и Swift.Лучший способ понять эти приемы-попробовать их самим.Сначала создадим крошечную библиотеку Kotlin и будем использовать ее из программы Objective-C.</target>
        </trans-unit>
        <trans-unit id="b715f52434e20442ebb46ac504b8f84bf0548313" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler compiles Kotlin source files into native binaries for the &lt;a href=&quot;native-overview#target-platforms&quot;&gt;supported platforms&lt;/a&gt;. The command-line tool for Kotlin/Native compilation is &lt;code&gt;kotlinc-native&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72370bde43174b087fc25e3ae6d822902a3834d6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c8b720dae4415d29464c12eeee3db3497f57a4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native doesn't support Maven and IntelliJ IDEA native builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">Котлин/Национальный для коренных жителей</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native поддерживает двунаправленное взаимодействие с языками Objective-C и Swift. Объекты Kotlin интегрируются с подсчетом ссылок Objective-C / Swift. Неиспользуемые объекты Kotlin автоматически удаляются. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; статья содержит больше информации о деталях реализации Interop. Конечно, можно импортировать существующий фреймворк и использовать его из Kotlin. Kotlin / Native поставляется с хорошим набором предварительно импортированных системных фреймворков.</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">В Kotlin / Native есть сборка мусора, но она не помогает нам справляться с объектами Kotlin из языка C. Kotlin / Native взаимодействует с Objective-C и Swift и интегрируется с их счетчиками ссылок. В статье документации &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; содержится более подробная информация об этом. Также есть учебник &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3fb305a0493b588bb98fac3fd02dfc049654c2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has received a number of performance improvements that speed up both the development process and execution. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native реализует строгие проверки изменчивости, обеспечивая важный инвариант, что объект либо неизменяем, либо доступен из одного потока в данный момент времени ( &lt;code&gt;mutable XOR global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Взаимодействие Kotlin / Native со Swift и Objective-C описано в статье &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;документации&lt;/a&gt; . Кроме того, эта же тема рассматривается в учебнике &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Котлин/Отрицательная совместимость</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Котлин/Отрицательная совместимость со Swift/Объект-C</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native - это технология компиляции кода Kotlin в собственные двоичные файлы, которые могут работать без виртуальной машины. Это &lt;a href=&quot;https://llvm.org/&quot;&gt;серверная часть на&lt;/a&gt; основе LLVM для компилятора Kotlin и собственная реализация стандартной библиотеки Kotlin.</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native в настоящее время находится &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;в разработке&lt;/a&gt; . Он компилирует Kotlin в собственный код, который может работать без виртуальной машины. Выпущена предварительная версия Technology Preview, но она еще не готова к производству и еще не нацелена на все платформы, которые мы планируем поддерживать в версии 1.0. Для получения дополнительной информации ознакомьтесь с &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;сообщением&lt;/a&gt; в блоге, в котором анонсируется Kotlin / Native .</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native в первую очередь предназначен для компиляции для платформ, на которых &lt;em&gt;виртуальные машины&lt;/em&gt; нежелательны или невозможны, например для встроенных устройств или iOS. Он решает ситуации, когда разработчику необходимо создать автономную программу, не требующую дополнительной среды выполнения или виртуальной машины.</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Котлин/Национальные библиотеки</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native библиотеки-это zip-файлы,содержащие предопределенную структуру каталогов,со следующей раскладкой:</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Для плагина Kotlin / Native требуется более новая версия Gradle, давайте &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; и используем следующий &lt;code&gt;distrubutionUrl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native обеспечивает двунаправленную совместимость с Objective-C / Swift. В коде Kotlin можно использовать фреймворки и библиотеки Objective-C. Модули Kotlin также можно использовать в коде Swift / Objective-C. Кроме того, в Kotlin / Native есть &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt; . Существует также руководство по &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native как динамической библиотеке&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native обеспечивает двустороннюю совместимость с Objective-C. Фреймворки и библиотеки Objective-C можно использовать в коде Kotlin, если они правильно импортированы в сборку (системные фреймворки импортируются по умолчанию). См., Например, &amp;laquo;Использование cinterop&amp;raquo; в &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;документации плагина Gradle&lt;/a&gt; . Библиотеку Swift можно использовать в коде Kotlin, если ее API экспортируется в Objective-C с помощью &lt;code&gt;@objc&lt;/code&gt; . Модули Pure Swift пока не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native предоставляет нам возможность использовать стандартные библиотеки C, открывая целую экосистему функциональности, которая существует практически для всего, что нам может понадобиться. Фактически, Kotlin / Native уже поставляется с набором предварительно созданных &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;библиотек платформы,&lt;/a&gt; которые предоставляют некоторые дополнительные общие функции по сравнению со стандартной библиотекой.</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native не поощряет классическую потоково-ориентированную параллельную модель с взаимоисключающими блоками кода и условными переменными,так как эта модель,как известно,подвержена ошибкам и ненадежна.Вместо этого мы предлагаем набор альтернативных подходов,позволяющих использовать аппаратное совпадение и реализовывать блокировку ввода-вывода.Эти подходы являются следующими и будут рассмотрены в последующих разделах:</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">Котлин/Отрицательные источники и примеры</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Котлин/Отрицательные источники и примеры (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Котлин/Отрицательные источники и примеры (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native также поддерживает взаимодействие C. Ознакомьтесь с руководством по &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native как динамической библиотеке&lt;/a&gt; для этого или посмотрите статью документации &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native поддерживает следующие платформы:</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native поддерживает двустороннее взаимодействие с родным миром.С одной стороны,компилятор создает:</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Пресеты Kotlin / Native target (см. &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;Примечания&lt;/a&gt; ниже):</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Цели Kotlin / Native не требуют дополнительных тестовых зависимостей, а &lt;code&gt;kotlin.test&lt;/code&gt; API kotlin.test являются встроенными.</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native использует систему сборки &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; через плагин &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; . Ниже мы рассмотрим, как настроить сборку Gradle. В некоторых случаях компилятор Kotlin / Native все еще можно получить вручную (не рекомендуется) со &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;страницы выпусков Kotlin на GitHub&lt;/a&gt; . В этом руководстве мы сосредоточены на использовании сборок Gradle.</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">Приложение KotlinConf Spinner</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">приложение KotlinConf</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">Выражения лямбды и анонимные функции</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">синтаксис выражения лямбда</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Выражения Лямбда и анонимные функции являются &quot;функциональными литералами&quot;,т.е.функциями,которые не объявляются,а передаются немедленно в качестве выражения.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Лямбда-выражения и анонимные функции вместе называются &lt;em&gt;функциональными литералами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">Лямбда-выражения могут использоваться как функциональные литералы с приемником, когда тип приемника может быть выведен из контекста. Один из наиболее важных примеров их использования - &lt;a href=&quot;type-safe-builders&quot;&gt;типобезопасные компоновщики&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">лямбда-форматирование</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">параметры лямбды</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">результат лямбда</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="92af1ed3cd8ff99b216bc082c8daaf4fcc54a009" translate="yes" xml:space="preserve">
          <source>Lambdas returning &lt;code&gt;kotlin.Result&lt;/code&gt; now return boxed value instead of unboxed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9f9099a35efc6c2d9f032d57efb49b93a9221c" translate="yes" xml:space="preserve">
          <source>Language and stdlib</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3f4623762408896074b73a50b22e0a64f2aec4" translate="yes" xml:space="preserve">
          <source>Language features and improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">Языковые настройки</target>
        </trans-unit>
        <trans-unit id="a69a0d9ceb988516811878ad5b3baf535d6a8d16" translate="yes" xml:space="preserve">
          <source>Language settings are checked for consistency in the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">Языковые настройки исходного набора влияют на то,как источники анализируются в IDE.В связи с существующими ограничениями,в сборке Gradle используются только языковые настройки исходного набора компиляции по умолчанию,которые применяются ко всем источникам,участвующим в компиляции.</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">Свойства и переменные с задержкой инициализированные</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Латеинитные свойства верхнего уровня и локальные переменные</target>
        </trans-unit>
        <trans-unit id="8958c019aa5a02d51718ce29ef1d34ac94e1a924" translate="yes" xml:space="preserve">
          <source>Launching flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">Лениво начал асинхронизировать</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">ленивое имущество</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="88e85262e00274cab89a641da3cb45b95f5a2ce2" translate="yes" xml:space="preserve">
          <source>Learn &lt;a href=&quot;native/cocoapods&quot;&gt;how to add dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">Бассейн знаний</target>
        </trans-unit>
        <trans-unit id="e3737ad5066ff8c2efc62a80380f6fc54741a2ea" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;multiplatform projects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2474d64d95d6b15d329e41bab7ed01766c506ac9" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configure compilations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcd0abba8e732ce3f464292f0728067fe8360ff" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;set up targets manually&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20953bfc9862dd27c555f29879ffef5ff21fa3c3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;build the hierarchy of source sets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ca28cd12d1bd44a1297fd960c1eedef1b345b3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;change the default behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64487eb003a10dbcb473f2557c19c16b00054e2a" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;#share-code-in-libraries&quot;&gt;sharing code in libraries&lt;/a&gt; and &lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;using Native libraries in the hierarchical structure&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed58d30a4c6366747487c1ab11dfdb8bd165900e" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin functional interfaces and SAM conversions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a266a26503caec98e47c6ba6a7a5accc48d540" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;js-project-setup&quot;&gt;configuring Kotlin/JS projects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ece8a8530cbd084c4191e879166f55575d6c48" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-build-native-binaries&quot;&gt;building native binaries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7794648f1ef065710c83db4bd3fd00ce935fd99" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configuring compilations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35eb7e7ef591eb8121626725e4cbc15aad464688" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;compilation for Android&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82dbe77a2cb72a3eed96435795f26fc5fd861ab" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;source sets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8403f45e73c3fa76d6076b7f5f4ef79b474eabc9" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;additional settings for targets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4ffd267ae3e789bf0bdbf84175cab85c2a10c6" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;usage of platform-dependent libraries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bdd6e03dcdfbfdc0a865fbc438364cc7870614" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;configuring dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f6b2049ff0f8271b4ef5ecd9ffeb77c34f8ee0" translate="yes" xml:space="preserve">
          <source>Learn more about creating a &lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;custom compilation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e871fbb0e4ca02f35986ac2bcdf867ebcc67c62b" translate="yes" xml:space="preserve">
          <source>Learn more about debugging coroutines in &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;this blog post&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJ IDEA documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350bcedee9353ee1217f26074d552b05f99da2b" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;technical details&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382bc2b5420e5bc5b00d6eff83fe5cc43062a688" translate="yes" xml:space="preserve">
          <source>Learn more about the available features in the Kotlin/JS IR compiler backend in the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a7c9acfbc9796eb30e7c60b60f1b0ce15271c8" translate="yes" xml:space="preserve">
          <source>Learn more how to &lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;configure interop with native languages&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc982a7f5ebfb278a6eac9d43da3ac1981ee500" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">Учебный Котлин</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">Учебный Котлин с плагином EduTools</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">Оставьте для остальных параметров значения по умолчанию и нажмите &lt;strong&gt;Готово&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">У нас будет два производителя струн: &lt;code&gt;fizz&lt;/code&gt; и &lt;code&gt;buzz&lt;/code&gt; . &lt;code&gt;fizz&lt;/code&gt; производит строку &amp;laquo;Fizz&amp;raquo; каждые 300 мс:</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">Давайте тысячу раз запустим сотню корутингов,делающих одно и то же действие.Мы также измерим время их завершения для дальнейших сравнений:</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">Давайте объединим наши знания о контекстах, детях и работе. Предположим, что у нашего приложения есть объект с жизненным циклом, но этот объект не является сопрограммой. Например, мы пишем приложение для Android и запускаем различные сопрограммы в контексте активности Android для выполнения асинхронных операций по выборке и обновлению данных, анимации и т. Д. Все эти сопрограммы должны быть отменены при уничтожении активности, чтобы избежать утечки памяти. , Мы, конечно, можем манипулировать контекстами и заданиями вручную, чтобы связать жизненные &lt;code&gt;kotlinx.coroutines&lt;/code&gt; действий и сопрограмм, но kotlinx.coroutines предоставляет абстракцию, которая инкапсулирует это: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . Вы должны быть уже знакомы с областью видимости сопрограмм, поскольку все построители сопрограмм объявлены на ней как расширения.</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">Давайте прогоним все семь раз:</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">Давайте начнем с дюжины из них со случайной задержкой.</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">Давайте возьмем &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent на примере async&lt;/a&gt; и &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; функцию, которая одновременно выполняет doSomethingUsefulOne и &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; и возвращает сумму их результатов. Поскольку построитель &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;асинхронных&lt;/a&gt; сопрограмм определен как расширение на &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope,&lt;/a&gt; нам нужно, чтобы он был в области видимости, и это то, что обеспечивает функция &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">Давайте напишем функцию производителя канала, которая использует канал отложенных строковых значений, ожидает каждого полученного отложенного значения, но только до тех пор, пока не появится следующее отложенное значение или пока канал не закроется. В этом примере предложения &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait объединяются&lt;/a&gt; в один и тот же &lt;code&gt;select&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">Давайте напишем пример производителя целых чисел, который отправляет свои значения в &lt;code&gt;side&lt;/code&gt; канал, когда потребители на его основном канале не могут за ним угнаться:</target>
        </trans-unit>
        <trans-unit id="2a09d0572f014b56fede8ceb5d706fa8418ec701" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how to serialize Kotlin objects into JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">Давайте также убедимся, что наши сопрограммы действительно работают параллельно. Если мы добавим 1- секундную &lt;code&gt;delay()&lt;/code&gt; к каждому из &lt;code&gt;async&lt;/code&gt; вызовов, полученная программа не будет работать в течение 1 000 000 секунд (более 11,5 дней):</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">Предположим в приведенном выше коде, что &lt;code&gt;preparePost&lt;/code&gt; - это длительный процесс и, следовательно, блокирует пользовательский интерфейс. Что мы можем сделать, так это запустить его в отдельном потоке. Это позволит нам избежать блокировки пользовательского интерфейса. Это очень распространенный метод, но он имеет ряд недостатков:</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Назовем фреймворк из Objective-C. Для этого мы создаем файл &lt;code&gt;main.m&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Давайте проверим C API нашей библиотеки Kotlin.``</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">Давайте нажмем на конфигурацию запуска &lt;code&gt;App&lt;/code&gt; чтобы запустить наш проект на реальном устройстве Android или в эмуляторе.</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Давайте нажмем кнопку &amp;laquo; &lt;em&gt;Выполнить&amp;raquo;&lt;/em&gt; в Xcode, и мы увидим, что наше приложение работает.</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">Давайте создадим файл-заглушку &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; со следующим содержимым, чтобы увидеть, как объявления примитивных типов C видны из Kotlin:</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">Давайте создадим файл-заглушку &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; со следующим содержимым, чтобы увидеть, как наши объявления C видны из Kotlin:</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">Давайте снова создадим миллион сопрограмм, сохранив их &lt;code&gt;Deferred&lt;/code&gt; объекты. Теперь нет необходимости в атомарном счетчике, поскольку мы можем просто вернуть числа, которые нужно добавить, из наших сопрограмм:</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">Создадим класс &lt;code&gt;Base64Test&lt;/code&gt; в &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; и напишем базовые тесты для Base64.</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">Обозначим функцию f(x)таким образом:добавляем к x 1,затем,пока в результирующем числе есть хотя бы один трейлинговый ноль,удаляем этот ноль.</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">Давайте немного углубимся в то, что это значит. Самым большим достоинством сопрограмм является то, что они могут &lt;em&gt;приостанавливаться,&lt;/em&gt; не блокируя поток. Чтобы сделать это возможным, компилятор должен выдать специальный код, поэтому мы должны отметить в коде функции, которые &lt;em&gt;могут приостанавливаться&lt;/em&gt; . Мы используем для этого модификатор &lt;code&gt;suspend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">Выделим блок кода внутри &lt;code&gt;launch { ... }&lt;/code&gt; в отдельную функцию. Когда вы выполняете рефакторинг &amp;laquo;Извлечь функцию&amp;raquo; в этом коде, вы получаете новую функцию с модификатором &lt;code&gt;suspend&lt;/code&gt; . Это ваша первая &lt;em&gt;функция приостановки&lt;/em&gt; . Функции приостановки могут использоваться внутри сопрограмм так же, как обычные функции, но их дополнительная особенность заключается в том, что они, в свою очередь, могут использовать другие функции приостановки, такие как &lt;code&gt;delay&lt;/code&gt; в этом примере, для &lt;em&gt;приостановки&lt;/em&gt; выполнения сопрограммы.</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">Сначала создадим папку проекта.Все пути в данном руководстве будут относительны к этой папке.Иногда перед добавлением новых файлов необходимо создать недостающие каталоги.</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">Давайте сразу &lt;code&gt;.kt&lt;/code&gt; - введите это в файл с расширением .kt :</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">Давайте включим зависимость от проекта &lt;code&gt;SharedCode&lt;/code&gt; к проекту Android. Нам нужно &lt;code&gt;app/build.gradle&lt;/code&gt; файл app / build.gradle и включить следующую строку в блок &lt;code&gt;dependencies { .. }&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b82b4fa1803ecc5b171c4989f538f93a5e12eeda" translate="yes" xml:space="preserve">
          <source>Let's just check everything is right with the project so far, the project structure should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">Давайте посмотрим на &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , который реализован во внешней библиотеке &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">Давайте посмотрим на полную программу, в которой используется &lt;code&gt;launch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">Давайте посмотрим,что изменилось.В Java вы аннотировали поле,привязав его к соответствующему виду:</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">Убедимся,что сможем запустить приложение на эмуляторе или устройстве iPhone.</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">Переместим &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; папку src / nativeMain / kotlin в проекте. Это путь по умолчанию, по которому расположены исходные файлы, когда &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;используется&lt;/a&gt; плагин kotlin-multiplatform . Мы используем следующий блок, чтобы настроить проект для создания динамической или общей библиотеки для нас:</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">Переместим &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; папку src / nativeMain / kotlin в проекте. Это путь по умолчанию для расположения источников при использовании &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;плагина kotlin-multiplatform&lt;/a&gt; . Мы используем следующий блок, чтобы проинструктировать и настроить проект для создания для нас динамической или общей библиотеки:</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">Заменим &lt;code&gt;testSolution()&lt;/code&gt; функции testSolution () следующим:</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">Давайте запустим много из них</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">Давайте &lt;code&gt;linkNative&lt;/code&gt; задачу linkNative Gradle для сборки библиотеки &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в среде IDE&lt;/a&gt; или вызовем следующую консольную команду:</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">Допустим, вы пишете простую ORM. Ваша библиотека базы данных представляет строку как экземпляры класса &lt;code&gt;Entity&lt;/code&gt; с такими функциями, как &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; и &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; для получения типизированных значений из заданных столбцов. Мы могли бы создать типизированный класс-оболочку следующим образом:</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">Допустим, нам нужно вернуть две вещи из функции. Например, объект результата и какой-то статус. Компактный способ сделать это в Kotlin - объявить &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;класс данных&lt;/em&gt;&lt;/a&gt; и вернуть его экземпляр:</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">Давайте посмотрим, как &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;object&lt;/code&gt; отображаются на Objective-C и Swift. Сформированный &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; файл содержит точные определения для &lt;code&gt;Class&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; и &lt;code&gt;Object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">Давайте посмотрим, что &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; сначала превращается в указатель:</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">Давайте подведем итог тому,что у нас есть в таблице:</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Переключатель назад Давайте в Android Studio и выполнить &lt;code&gt;build&lt;/code&gt; Цель &lt;code&gt;SharedCode&lt;/code&gt; проекта из &lt;em&gt;Gradle&lt;/em&gt; окна инструмента. Задача ищет переменные среды, заданные сборкой Xcode, и копирует правильный вариант платформы в &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; . Затем мы включаем фреймворк из этой папки в сборку.</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">Давайте сначала посмотрим на декларации по времени выполнения Котлина:</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">Давайте рассмотрим конкретный пример.</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">Давайте посмотрим на поле &lt;code&gt;kotlin.root.example&lt;/code&gt; , оно имитирует структуру пакета нашего кода Kotlin с &lt;code&gt;kotlin.root.&lt;/code&gt; префикс.</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">Давайте посмотрим на разницу между &lt;code&gt;Iterable&lt;/code&gt; и &lt;code&gt;Sequence&lt;/code&gt; на примере.</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">Давайте посмотрим на сгенерированные функции, которые принимают наши &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; в качестве параметров. Мы видим, что параметры по значению представлены как &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; . А для параметров типизированного указателя мы видим &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; . Kotlin предоставляет нам API, чтобы легко работать с обоими типами, давайте попробуем и посмотрим.</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">Давайте возьмем трубопроводы в крайнем случае с примером,который генерирует простые числа с помощью трубопровода из корусинок.Начнем с бесконечной последовательности чисел.</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">Давайте попробуем то же самое с корутинами:</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">Попробуем использовать API от Kotlin. &lt;code&gt;pass_string&lt;/code&gt; вызовем pass_string :</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">Давайте обновим скрипты Gradle,чтобы реализовать это и настроить нашу IDE.</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">Давайте использовать его с каналом &lt;code&gt;a&lt;/code&gt; , который четыре раза генерирует строку &amp;laquo;Hello&amp;raquo;, и каналом &lt;code&gt;b&lt;/code&gt; , который генерирует строку &amp;laquo;World&amp;raquo; четыре раза:</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">Давайте пройдемся по интерфейсам и их реализациям.</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Давайте рассмотрим механизмы реализации типобезопасных построителей в Котлине. Прежде всего, нам нужно определить модель, которую мы хотим построить, в этом случае нам нужно смоделировать HTML-теги. Это легко сделать с помощью группы классов. Например, &lt;code&gt;HTML&lt;/code&gt; - это класс, описывающий &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; , т.е. он определяет дочерние элементы, такие как &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; . (См. Его заявление &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;ниже&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="72a321ab062693e53bbb407257b25f97ff6f7e3d" translate="yes" xml:space="preserve">
          <source>Leveraging native libs in the hierarchical structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="944db4e3c24472be792b2084d0de67b6c3f7f699" translate="yes" xml:space="preserve">
          <source>Libraries published with the hierarchical project structure are compatible with all kinds of projects, both with and without the hierarchical project structure. However, libraries published without the hierarchical project structure can&amp;rsquo;t be used in a shared native source set. So, for example, users with &lt;code&gt;ios()&lt;/code&gt; shortcuts in their &lt;code&gt;gradle.build&lt;/code&gt; files won&amp;rsquo;t be able to use your library in their iOS-shared code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">Авторы библиотек могут использовать @Deprecated и @Experimental annotations для контроля эволюции своей поверхности API.Обратите внимание,что @Deprecated(level=HIDDEN)может использоваться для сохранения бинарной совместимости даже для объявлений,удаленных из API.</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">Библиотечный код всегда должен явно указывать возвращаемые типы публичных/защищенных функций и свойств,тем самым никогда не полагаясь на вывод типа для публичного API.Небольшое изменение типового вывода может привести к непреднамеренному изменению типов возвращаемых данных,что приведет к проблемам совместимости двоичных систем.</target>
        </trans-unit>
        <trans-unit id="c7267839499feac3cd8daacca298c9e65946505b" translate="yes" xml:space="preserve">
          <source>Library search path. For more information, see &lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;Library search sequence&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">Последовательность поиска в библиотеке</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Библиотечное обслуживание аннотаций в Котлине.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Лицензия Apache,версия 2.0.</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Как и Java, обобщенные типы Kotlin не сохраняются во время выполнения, т.е. объекты не несут информацию о фактических аргументах типа, переданных их конструкторам, т.е. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; неотличим от &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; . Это делает невозможным выполнение &lt;em&gt;is-&lt;/em&gt; проверок, учитывающих обобщенные типы. Kotlin разрешает &lt;em&gt;is-&lt;/em&gt; проверки только для общих типов с проекцией звезд:</target>
        </trans-unit>
        <trans-unit id="d1e9786250417dc0913291ad74e3ec7573630368" translate="yes" xml:space="preserve">
          <source>Like any other Gradle projects, Kotlin/JS projects support traditional Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;dependency declarations&lt;/a&gt; in the &lt;code&gt;dependencies&lt;/code&gt; section of the build script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Как и в Python, функции в Kotlin являются первоклассными значениями - их можно назначать переменным и передавать как параметры. Тип функции - это &lt;em&gt;тип функции&lt;/em&gt; , который обозначается списком типов параметров в скобках и стрелкой к типу возвращаемого значения. Рассмотрим эту функцию:</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">Как и в Python, операторы могут заканчиваться точкой с запятой, но это не рекомендуется. Нет символа продолжения строки; вместо этого строка автоматически соединяется с одной или несколькими последующими строками, если это единственный способ правильно проанализировать код. На практике это означает, что оператор продолжается на следующей строке, если мы внутри открытой круглой скобки (как в Python), или если строка заканчивается &amp;laquo;висящим оператором&amp;raquo; (в отличие от Python) или если следующая строка не синтаксический анализ, если он не присоединен к предыдущему (также в отличие от Python). Обратите внимание, что это в значительной степени &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;противоположность JavaScript&lt;/a&gt; , который обычно будет соединять строки, пока полученный код все еще анализирует. Таким образом, следующие два выражения в Kotlin и в Python (потому что &lt;code&gt;+&lt;/code&gt; может быть унарным, поэтому вторая строка анализируется сама по себе), но одна в JavaScript:</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">Как и в Python, вы можете писать &lt;em&gt;лямбда-выражения&lt;/em&gt; : объявления безымянных функций с очень компактным синтаксисом, которые оценивают вызываемые объекты функций. В Kotlin лямбды могут содержать несколько операторов, что делает их полезными для &lt;a href=&quot;functional-programming#receivers&quot;&gt;более сложных задач,&lt;/a&gt; чем лямбды с одним выражением в Python. Последний оператор должен быть выражением, результат которого станет возвращаемым значением лямбда (если &lt;code&gt;Unit&lt;/code&gt; не является типом возвращаемого значения переменной / параметра, которому присвоено лямбда-выражение, и в этом случае лямбда не имеет возвращаемого значения). Лямбда-выражение заключено в фигурные скобки и начинается с перечисления имен его параметров и, возможно, их типов (если типы не могут быть выведены из контекста):</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">Как и цифры,символы помечены квадратиками,когда нужна нулевая ссылка.Идентичность не сохраняется при боксировании.</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">Точно так же, если многоплатформенная библиотека опубликована в экспериментальном &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;режиме публикации метаданных Gradle&lt;/a&gt; и проект настроен на использование метаданных, тогда достаточно указать зависимость только один раз для общего набора источников. В противном случае каждый исходный набор для конкретной платформы должен быть снабжен соответствующим платформенным модулем библиотеки в дополнение к общему модулю, как показано выше.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">Линейный поиск</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">Связать библиотеку с приложением</target>
        </trans-unit>
        <trans-unit id="51115a9035c7b2d5f77a89ba3f71882db009bed6" translate="yes" xml:space="preserve">
          <source>Link with the library. To learn about using libraries in Kotlin/native projects, see &lt;a href=&quot;native/libraries&quot;&gt;Kotlin/Native libraries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">Связь с элементами</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPS little endian,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967dea98ac299ce02d355a430918fd09ccd9ae77" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Для целей Linux MIPS ( &lt;code&gt;linuxMips32&lt;/code&gt; и &lt;code&gt;linuxMipsel32&lt;/code&gt; ) требуется хост Linux. Другие цели Linux могут быть созданы на любом поддерживаемом хосте;</target>
        </trans-unit>
        <trans-unit id="11304ba6aa97ab18544ed05fda48e987cfe71d39" translate="yes" xml:space="preserve">
          <source>Linux on ARM64 platforms, for example, Raspberry Pi</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013bd415b99b4bdfce6cddaafa69bba3220fa741" translate="yes" xml:space="preserve">
          <source>Linux on MIPS platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ff9f10883bcb28fb147e475a8a0df8cd56c6a9" translate="yes" xml:space="preserve">
          <source>Linux on hard-float ARM (ARM32) platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c99b7625097db16217dc289034a1cae4cfdd98e" translate="yes" xml:space="preserve">
          <source>Linux on little-endian MIPS (mipsel) platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6493240830afc488468d930ec91963f82322598" translate="yes" xml:space="preserve">
          <source>Linux on x86_64 platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; и &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">Перечень конкретных операций</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">Элементы списка (включая нули) могут дублироваться: список может содержать любое количество одинаковых объектов или вхождений одного объекта. Два списка считаются равными, если они имеют одинаковые размеры и &lt;a href=&quot;equality#structural-equality&quot;&gt;структурно одинаковые&lt;/a&gt; элементы в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">Перечислить итераторы</target>
        </trans-unit>
        <trans-unit id="b7bfa71d045baf9d165ce17f80e019c5294d5073" translate="yes" xml:space="preserve">
          <source>List the available hardware targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">Операции записи списка</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">Списки также предлагают функцию для замены элемента в заданной позиции - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; и его оператор form &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;set()&lt;/code&gt; не изменяет индексы других элементов.</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">Списки и наборы также предоставляют операции по обновлению элементов. Они описаны в &lt;a href=&quot;list-operations&quot;&gt;разделах &amp;laquo;Список конкретных операций&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;map-operations&quot;&gt;Операции для конкретных карт&amp;raquo;&lt;/a&gt; . Для наборов обновление не имеет смысла, поскольку оно фактически удаляет элемент и добавляет другой.</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">Списки поддерживают все стандартные операции для поиска элементов: &lt;code&gt;elementAt()&lt;/code&gt; , &lt;code&gt;first()&lt;/code&gt; , &lt;code&gt;last()&lt;/code&gt; и другие, перечисленные в &lt;a href=&quot;collection-elements&quot;&gt;разделе &amp;laquo;Получение отдельных элементов&amp;raquo;&lt;/a&gt; . Что характерно для списков, так это доступ к элементам по индексу, поэтому самый простой способ прочитать элемент - получить его по индексу. Это делается с помощью функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; с индексом, переданным в аргументе, или сокращенным синтаксисом &lt;code&gt;[index]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">Буквальные константы</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">Локальные удаленные свойства (начиная с 1.1)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">Местные функции</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">Классы местных аннотаций</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">Местные декларации</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">Местная делегированная собственность</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">Локальная функция может обращаться к локальным переменным внешних функций (то есть к закрытию), поэтому в приведенном выше случае &lt;em&gt;посещаемая&lt;/em&gt; может быть локальной переменной:</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">Локальная переменная</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">Локальные переменные обычно объявляются и инициализируются одновременно, и в этом случае &lt;em&gt;предполагается&lt;/em&gt; , что тип переменной является типом выражения, которым вы ее инициализируете:</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">Локальные переменные,функции и классы не могут иметь модификаторов видимости.</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="d42ac4c4f265835ce678f6a048de877eecd3678f" translate="yes" xml:space="preserve">
          <source>Location of Kotlin source files inside the source set directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178313af6182f9b545c1f11580b0d5590fb118f3" translate="yes" xml:space="preserve">
          <source>Location of resources inside the source set directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">Блокировки используются, чтобы гарантировать, что только один поток может инициализировать экземпляр &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">Логарифмы: &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;ln&lt;/code&gt; , &lt;code&gt;ln1p&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">Логотипы можно скачать &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;здесь&lt;/a&gt; . При использовании логотипов соблюдайте простые правила, содержащиеся в &lt;code&gt;guidelines.pdf&lt;/code&gt; внутри архива, и &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;правила использования бренда Kotlin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">Ломбок ( &lt;code&gt;lombok.NonNull&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Длинные позиции помечены заглавной &lt;code&gt;L&lt;/code&gt; : &lt;code&gt;123L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">Ищете другие API? Создать &lt;a href=&quot;../multiplatform-library&quot;&gt;мультиплатформенную библиотеку&lt;/a&gt; и поделиться ею - легко !</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">Ищет функцию &lt;code&gt;inc()&lt;/code&gt; с модификатором &lt;code&gt;operator&lt;/code&gt; и без параметров, применимую к получателю типа &lt;code&gt;T&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;unaryPlus()&lt;/code&gt; функцию unaryPlus () с модификатором &lt;code&gt;operator&lt;/code&gt; и без параметров для получателя &lt;code&gt;T&lt;/code&gt; , т. Е. Функцию- член или функцию расширения;</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">Петли на диапазонах</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">Низкоуровневые строительные блоки для библиотек,предоставляющих коррутинные API.</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">К счастью, в Kotlin есть &lt;em&gt;параметры овеществленного типа&lt;/em&gt; , которые устраняют некоторые из этих проблем. Написав &lt;code&gt;reified&lt;/code&gt; перед параметром универсального типа, он становится доступным во время выполнения, и вы можете написать &lt;code&gt;T::class&lt;/code&gt; для получения &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;метаданных класса&lt;/a&gt; . Вы можете сделать это только в встроенных функциях (так как встроенная функция будет скомпилирована в его callsite, если информация о типе &lt;em&gt;является&lt;/em&gt; доступна во время выполнения), но он все еще проходит долгий путь. Например, вы можете сделать встроенную функцию-оболочку для большой функции, которая имеет менее элегантную подпись.</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="784a46c14fea9ff3fb4d5c790913e2db7292c56e" translate="yes" xml:space="preserve">
          <source>MICROSECONDS</source>
          <target state="translated">MICROSECONDS</target>
        </trans-unit>
        <trans-unit id="370c3ba851aaa71b93e5d791ecaddbf60722fede" translate="yes" xml:space="preserve">
          <source>MILLISECONDS</source>
          <target state="translated">MILLISECONDS</target>
        </trans-unit>
        <trans-unit id="9c200cc936c861cebaa3fc9dbe92407a4a2f6d99" translate="yes" xml:space="preserve">
          <source>MINUTES</source>
          <target state="translated">MINUTES</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">MacOS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="9c574760a1e8c967bc35e78752b8950efd331477" translate="yes" xml:space="preserve">
          <source>Make frameworks static when using rebuild from bitcode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">Убедитесь, что его тип возвращаемого значения - &lt;code&gt;Unit&lt;/code&gt; , в противном случае сообщите об ошибке,</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">Убедитесь , что вы CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;установлены&lt;/a&gt; . Мы рекомендуем использовать CocoaPods 1.6.1 или новее.</target>
        </trans-unit>
        <trans-unit id="4666c5046e05de3ced6688314c5b8b2fdc5e809d" translate="yes" xml:space="preserve">
          <source>Make sure that you import the &lt;code&gt;react.dom.*&lt;/code&gt; and &lt;code&gt;styled.*&lt;/code&gt; packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46d38a6352744d726ba87d5e2a3fe0550a5b018" translate="yes" xml:space="preserve">
          <source>Make sure that you import the package &lt;code&gt;kotlinx.html.js.*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">Убедитесь, что вы &lt;code&gt;kotlin.js&lt;/code&gt; среду выполнения kotlin.js , а затем свое приложение.</target>
        </trans-unit>
        <trans-unit id="5aa48b84880f06c505b8b4e3340f284931cef8e6" translate="yes" xml:space="preserve">
          <source>Make sure that your declared annotation has a proper annotation target (Java&amp;rsquo;s &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; or Kotlin&amp;rsquo;s &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt;) and retention (&lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">Сделайте обновление до новых версий удобным для пользователей.</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Делает метод Котлина в классе Objective-C доступным через диспетчерскую Objective-C для использования в качестве действия,посланного управлением в UIKit или AppKit.</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Делает свойство Котлин в классе Объект-С устанавливаемым через диспетчерскую Объект-С для использования в качестве выхода IB.</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Делает подкласс Kotlin класса Objective-C видимым для поиска во время выполнения после вызова &lt;code&gt;main&lt;/code&gt; функции Kotlin .</target>
        </trans-unit>
        <trans-unit id="f35a32ffaf96633b14ae608748f888d188401daf" translate="yes" xml:space="preserve">
          <source>Makes call to the specified &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380302710c7a9c26b7742a1058f704b9bb0ef0a3" translate="yes" xml:space="preserve">
          <source>Makes recursive call to this &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular recursive call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">Делает функцию верхнего уровня доступной из Си/Си++кода с заданным именем.</target>
        </trans-unit>
        <trans-unit id="33733bb607beb4f5ed38e06a91a784c426296320" translate="yes" xml:space="preserve">
          <source>Making busy flow cancellable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">Сделать код вычислений отменяемым</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">Частое проведение нулевых проверок раздражает,поэтому,если вам приходится допускать возможность нулей,в Котлине есть несколько очень полезных операторов,которые облегчают работу со значениями,которые могут быть нулевыми,как описано ниже.</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">Неправильные последовательности байтов заменяются заменой char &lt;code&gt;\uFFFD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">Управление зависимостями</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">Управляющие источники</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">Управляющие цели</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">Ручная настройка</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">Ручная установка</target>
        </trans-unit>
        <trans-unit id="4892a25af3b45967112eda593c6c4ff560c25b52" translate="yes" xml:space="preserve">
          <source>Manually apply an Android Gradle plugin &amp;ndash; &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6d42d1875648e1f154683fe273a941e93a43bb" translate="yes" xml:space="preserve">
          <source>Manually generating external declarations via Gradle task</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">Многие современные IDE поддерживают Kotlin и помогают в написании идиоматического кода Kotlin:</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">Многие из опций также могут быть настроены через свойства:</target>
        </trans-unit>
        <trans-unit id="e10c89b0b0ca5be3c7b04daef4c60db7fc1b6f90" translate="yes" xml:space="preserve">
          <source>Many people already use &lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; for asynchronous programming. But when it came to debugging, working with coroutines before Kotlin 1.4, could be a real pain. Since coroutines jumped between threads, it was difficult to understand what a specific coroutine was doing and check its context. In some cases, tracking steps over breakpoints simply didn&amp;rsquo;t work. As a result, you had to rely on logging or mental effort to debug code that used coroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">Карта конкретных операций</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">Отображать нулевое значение,если не нулевое</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">Операции записи на карту</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()и Map.toMutableMap().</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">Картированные типы</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">Картирование типов функциональных указателей с C</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">Картографические функциональные указатели из C</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">Картирование примитивных типов данных из C</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">Строки отображения из C</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">Картографическая структура и соединительные типы C</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">Картографическая структура и соединительные типы от C</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">Интерфейс маркера, указывающий, что реализация &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; поддерживает быстрый индексированный доступ.</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">Интерфейс маркера, указывающий, что реализация &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; поддерживает быстрый индексированный доступ.</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">Элементы API маркировки</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">Маркировка экспериментального API</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">Правила маркировки:неявный получатель считается помеченным @Ann,если</target>
        </trans-unit>
        <trans-unit id="86bad6d0089ea3bb1c0a2e322f9709163fa38969" translate="yes" xml:space="preserve">
          <source>Marks a point in time on this time source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">Пометка переменной верхнего уровня с полем подложки или объектом как неизменяемой.Можно разделить такой объект на несколько потоков,но он становится глубоко замороженным,поэтому ни в его состояние,ни в состояние объектов,на которые он ссылается,не могут быть внесены никакие изменения.</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">Помечает переменную верхнего уровня полем поддержки или объектом как нитевую локальную.Объект остается мутируемым,и можно изменить его состояние,но каждая нить будет иметь отдельную копию этого объекта,поэтому изменения в одной нити не отражаются на другой.</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">Обозначает ожидаемый класс аннотаций,что не обязательно иметь реальных аналогов на всех платформах.</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">Обозначает API,который зависит от экспериментальных беззнаковых типов,включая сами эти типы.</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">Помечает поле поддержки JVM аннотированного свойства как &lt;code&gt;transient&lt;/code&gt; , что означает, что оно не является частью сериализованной формы объекта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">Помечает поле поддержки JVM аннотированного свойства как &lt;code&gt;volatile&lt;/code&gt; , что означает, что записи в это поле немедленно становятся видимыми для других потоков.</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">Отмечает JVM-метод, созданный из аннотированной функции, как &lt;code&gt;strictfp&lt;/code&gt; , что означает, что точность операций с плавающей запятой, выполняемых внутри метода, должна быть ограничена для достижения лучшей переносимости.</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">Отмечает JVM-метод, сгенерированный аннотированной функцией, как &lt;code&gt;synchronized&lt;/code&gt; , что означает, что метод будет защищен от одновременного выполнения несколькими потоками монитором экземпляра (или, для статических методов, класса), на котором определен метод.</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">Пометит аннотированную декларацию как устаревшую.</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdea1abd24e2fec8414716149ca5d119c8a1c72d" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">Математические операции в Котлин-Стдлиб</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">Математические функции и константы.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
