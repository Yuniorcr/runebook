<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Преобразование &lt;em&gt;отображения&lt;/em&gt; создает коллекцию из результатов функции на элементах другой коллекции. Основная функция отображения - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; . Он применяет данную лямбда-функцию к каждому последующему элементу и возвращает список результатов лямбда. Порядок результатов такой же, как и исходный порядок элементов. Чтобы применить преобразование, которое дополнительно использует индекс элемента в качестве аргумента, используйте &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">Не &lt;em&gt;нет-Arg&lt;/em&gt; компилятор плагин генерирует дополнительный конструктор без аргументов для классов с определенной аннотацией.</target>
        </trans-unit>
        <trans-unit id="5691855d07c59433c1b89721a503fe2ada65d67c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Circle.draw()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Shape.fill()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;em&gt;Переопределение&lt;/em&gt; модификатора требуется для &lt;code&gt;Derived.v()&lt;/code&gt; . Если бы его не было, компилятор пожаловался бы. Если у функции нет модификатора &lt;em&gt;открытия&lt;/em&gt; , например &lt;code&gt;Base.nv()&lt;/code&gt; , объявление метода с такой же сигнатурой в подклассе является незаконным, как с &lt;em&gt;переопределением, так&lt;/em&gt; и без него. &lt;em&gt;Открытым&lt;/em&gt; модификатор не имеет никакого эффекта при добавлении на членах конечного класса (то есть. Класс, без &lt;em&gt;открытого&lt;/em&gt; модификатора).</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">Эти &lt;em&gt;примитивные типы данных&lt;/em&gt; являются наиболее основными типами в Котлине; все остальные типы состоят из этих типов и их массивов. Их представление очень эффективно (как с точки зрения памяти, так и времени ЦП), поскольку они отображаются на небольшие группы байтов, которыми напрямую управляет ЦП.</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">В &lt;em&gt;обратном&lt;/em&gt; -expression возвращается от ближайшей функции ограждающей, т.е. &lt;code&gt;foo&lt;/code&gt; . (Обратите внимание, что такие нелокальные возвраты поддерживаются только для лямбда-выражений, передаваемых &lt;a href=&quot;inline-functions&quot;&gt;встроенным функциям&lt;/a&gt; .) Если нам нужно вернуться из лямбда-выражения, мы должны пометить его и квалифицировать &lt;em&gt;возврат&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;em&gt;SAM-с-приемником&lt;/em&gt; Компилятор плагин делает первый параметр аннотированной Java &amp;laquo;одного абстрактного метода&amp;raquo; (SAM) метода интерфейса приемника в Котлин. Это преобразование работает только в том случае, если интерфейс SAM передается как лямбда Kotlin, как для адаптеров SAM, так и для конструкторов SAM (подробности см. В &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;документации&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;Это&lt;/em&gt; ключевое слово внутри функции расширения соответствует объекту приемника (тот , который передается перед точкой). Теперь мы можем вызвать такую ​​функцию для любого &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="610610ce4b9c2a06c0d2c740b86b1595d612ed87" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;when&lt;/em&gt; expression replaces the switch statement in C-like languages. In the simplest form it looks like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4474dcb438fb0b1d5730dee1b01c00e81230dea0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Debug&lt;/strong&gt; tool window contains the &lt;strong&gt;Coroutines&lt;/strong&gt; tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">Инструмент &lt;strong&gt;cinterop&lt;/strong&gt; создает оболочки &lt;code&gt;.klib&lt;/code&gt; для собственных библиотек в качестве основного вывода. Например, используя простой &lt;code&gt;libgit2.def&lt;/code&gt; определения собственной библиотеки libgit2.def, предоставленный в вашем дистрибутиве Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">&lt;strong&gt;Klib&lt;/strong&gt; утилита управления библиотекой позволяет проверить и установить библиотеки.</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">&lt;strong&gt;Из&lt;/strong&gt; модификатора называется &lt;strong&gt;дисперсией аннотации&lt;/strong&gt; , а так как это предусмотрено в объявлении параметра типа сайте, мы говорим о &lt;strong&gt;дисперсии декларации участка&lt;/strong&gt; . Это контрастирует с &lt;strong&gt;вариативностью сайта использования&lt;/strong&gt; Java, где подстановочные знаки в использовании типов делают типы ковариантными.</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Подстановочный аргумент типа &lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; указывает, что этот метод принимает набор объектов &lt;code&gt;E&lt;/code&gt; &lt;em&gt;или некоторого подтипа &lt;/em&gt; &lt;code&gt;E&lt;/code&gt; , а не только сам &lt;code&gt;E&lt;/code&gt; . Это означает , что мы можем спокойно &lt;strong&gt;прочитать &lt;/strong&gt; &lt;code&gt;E&lt;/code&gt; &amp;laquo;S из элементов (элементы этой коллекции являются экземплярами подкласса Е), но &lt;strong&gt;не могут писать&lt;/strong&gt; на него , так как мы не знаем , какие объекты соответствуют к этому неизвестному подтипу &lt;code&gt;E&lt;/code&gt; . Взамен этого ограничения у нас есть желаемое поведение: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;является&lt;/em&gt; подтипом &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; . В &amp;laquo;умных словах&amp;raquo;, групповой символ с &lt;strong&gt;простирается&lt;/strong&gt; -связанными ( &lt;strong&gt;верхним&lt;/strong&gt;bound) делает тип &lt;strong&gt;ковариантным&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">В мире Android существует множество популярных фреймворков,упрощающих разработку.Вы можете использовать те же самые фреймворки,если будете разрабатывать в Котлине,так же легко,как и на Java.В данном руководстве приведены примеры и выделены различия в настройках.</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Переменных данных С , содержащую указатель на &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">Переменная данных C,расположенная в памяти.</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">Функция С.</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">Переменная типа С,расположенная в памяти.</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">Переменная типа С,расположенная в памяти.</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">Плагин CocoaPods также позволяет использовать библиотеки CocoaPods без ручной настройки параметров cinterop (см. &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;Соответствующий раздел&lt;/a&gt; документации мультиплатформенного плагина). Блок &lt;code&gt;cocoapods { ... }&lt;/code&gt; позволяет добавлять зависимости от библиотек CocoaPods.</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">Поддержка CocoaPods реализована в отдельном плагине Gradle: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3aa1e3e57f3eb3ef63cd39980df09053647402" translate="yes" xml:space="preserve">
          <source>The Coroutine Debugger of the Kotlin plugin simplifies debugging coroutines in IntelliJ IDEA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOM также предоставляет нам способ получить определенный элемент по идентификатору, имени, имени класса, имени тега и так далее. Все возвращаемые элементы относятся к типу &lt;code&gt;NodeList&lt;/code&gt; , и для доступа к членам нам нужно привести их к определенному типу элемента. В приведенном ниже коде показано, как мы можем получить доступ к элементу ввода на странице:</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">Точка входа</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">Файл Gradle в значительной степени стандартен для Spring Boot. Единственные различия - это структура структуры исходных папок для Kotlin, требуемые зависимости Kotlin и плагин Gradle &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; (прокси CGLIB, используемые, например, для обработки &lt;code&gt;@Configuration&lt;/code&gt; и &lt;code&gt;@Bean&lt;/code&gt; , требуют &lt;code&gt;open&lt;/code&gt; классов).</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Плагин Gradle предоставляет отдельную задачу,которая создает универсальный фреймворк для iOS целей из нескольких обычных.Пример ниже показывает,как использовать эту задачу.Обратите внимание,что толстый фреймворк должен иметь то же базовое имя,что и исходный фреймворк.</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">Поддержка типизированных массивов JS, которая переводит примитивные массивы Kotlin, такие как &lt;code&gt;IntArray&lt;/code&gt; , &lt;code&gt;DoubleArray&lt;/code&gt; , в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;типизированные массивы JavaScript&lt;/a&gt; , которая ранее была функцией выбора, включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">Проверки JSR-305 можно настроить, добавив &lt;code&gt;-Xjsr305&lt;/code&gt; компилятора -Xjsr305 со следующими параметрами (и их комбинацией):</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Плагин Kotlin Android Extensions позволяет нам получить тот же опыт,что и с некоторыми из этих библиотек,без необходимости добавлять дополнительный код.</target>
        </trans-unit>
        <trans-unit id="3fa035c9f4f03b0b989b6313990e3a366a7fc07b" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin 1.4.10 works with Gradle 5.4 and later. The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin requires Gradle 6.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Плагин Kotlin Gradle поддерживает инкрементальную компиляцию.Инкрементная компиляция отслеживает изменения исходных файлов между сборками,поэтому будут скомпилированы только файлы,на которые повлияли эти изменения.</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">На Kotlin Maven Plugin необходимо ссылаться для компиляции источников:</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет исчерпывающий набор инструментов для управления &lt;em&gt;коллекциями&lt;/em&gt; - группами с переменным количеством элементов (возможно, нулевым), которые имеют важное значение для решаемой проблемы и используются обычно.</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет реализации для основных типов коллекций:наборов,списков и карт.Каждый тип коллекции представлен парой интерфейсов:</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет предметы первой необходимости для повседневной работы с Kotlin.Они включают в себя:</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">Код Kotlin превращается в очень похожий на вид код в Swift. Однако есть небольшие отличия. В Котлине любой &lt;code&gt;object&lt;/code&gt; имеет только один экземпляр. &lt;code&gt;object Object&lt;/code&gt; Kotlin Object теперь имеет конструктор в Swift, и мы используем синтаксис &lt;code&gt;Object()&lt;/code&gt; для доступа к единственному его экземпляру. Экземпляр в Swift всегда один и тот же, поэтому &lt;code&gt;Object() === Object()&lt;/code&gt; истинно. Названия методов и свойств переводятся как есть. Котлин &lt;code&gt;String&lt;/code&gt; превращается в Swift &lt;code&gt;String&lt;/code&gt; , тоже. Swift также скрывает от нас бокс &lt;code&gt;NSNumber*&lt;/code&gt; . Мы передаем закрытие Swift в Kotlin и вызываем лямбда-функцию Kotlin из Swift.</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Пакет коллекций Kotlin содержит функции расширения для популярных операций над множествами:поиска пересечений,слияния или вычитания коллекций друг из друга.</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Пакет Kotlin collections предоставляет функции для сортировки коллекций в естественном, произвольном и даже случайном порядке. На этой странице мы опишем функции сортировки, которые применяются к коллекциям &lt;a href=&quot;collections-overview#collection-types&quot;&gt;только&lt;/a&gt; для чтения . Эти функции возвращают свой результат в виде новой коллекции, содержащей элементы исходной коллекции в запрошенном порядке. Чтобы узнать о функциях для сортировки &lt;a href=&quot;collections-overview#collection-types&quot;&gt;изменяемых&lt;/a&gt; коллекций на месте, см. &lt;a href=&quot;list-operations#sorting&quot;&gt;Специальные операции&lt;/a&gt; со списком .</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Компилятор Kotlin теперь может использовать информацию из приведений типов при выводе типов. Если вы вызываете универсальный метод, который возвращает параметр типа &lt;code&gt;T&lt;/code&gt; и приводите возвращаемое значение к определенному типу &lt;code&gt;Foo&lt;/code&gt; , компилятор теперь понимает, что &lt;code&gt;T&lt;/code&gt; для этого вызова должен быть привязан к типу &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Компилятор Kotlin выполняет обширный статический анализ, чтобы выдавать предупреждения и сокращать количество шаблонов. Одна из наиболее примечательных функций - smartcast - с возможностью автоматически выполнять приведение на основе выполненных проверок типов:</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">Компилятор Kotlin предоставляет всю необходимую информацию о &lt;code&gt;prop&lt;/code&gt; в аргументах: первый аргумент &lt;code&gt;this&lt;/code&gt; относится к экземпляру внешнего класса &lt;code&gt;C&lt;/code&gt; , а &lt;code&gt;this::prop&lt;/code&gt; является объектом отражения типа &lt;code&gt;KProperty&lt;/code&gt; , описывающим сам &lt;code&gt;prop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Компилятор Kotlin пытается выполнить следующие задачи:</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Компилятор Kotlin предпочитает использовать типы,лежащие в основе,а не обёртки для получения наиболее производительного и оптимизированного кода.Тем не менее,иногда необходимо держать обёртки под рукой.Как правило,встроенные классы помещаются в коробку всякий раз,когда они используются в качестве другого типа.</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Компилятор Kotlin будет использовать это ограничение для агрессивной оптимизации представления классов inline во время выполнения и заменять их экземпляры значением базового свойства там,где это возможно,удаляя вызовы конструкторов,давление GC и позволяя выполнять другие оптимизации:</target>
        </trans-unit>
        <trans-unit id="d850079f06081665ec514cb65c4f969e8d679814" translate="yes" xml:space="preserve">
          <source>The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as &lt;strong&gt;Stable&lt;/strong&gt; which means that they are evolved in the backward-compatible way following the &lt;a href=&quot;kotlin-evolution&quot;&gt;principles&lt;/a&gt; of &lt;em&gt;Comfortable Updates&lt;/em&gt; and &lt;em&gt;Keeping the Language Modern&lt;/em&gt;. Among such stable components are, for example, the Kotlin compiler for the JVM, the Standard Library, and Coroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Плагин Kotlin также &lt;em&gt;включает&lt;/em&gt; конвертер Java в Kotlin ( &lt;em&gt;J2K&lt;/em&gt; ), который автоматически преобразует файлы Java в Kotlin. Чтобы использовать J2K в файле, щелкните &amp;laquo; &lt;strong&gt;Преобразовать файл Java в файл Kotlin&amp;raquo;&lt;/strong&gt; в его контекстном меню или в меню &amp;laquo; &lt;strong&gt;Код&amp;raquo;&lt;/strong&gt; IntelliJ IDEA.</target>
        </trans-unit>
        <trans-unit id="f2e3c8e9ac9f87a3c6a3c66f4442bdb2dd4de716" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;scratches&lt;/em&gt;&lt;/a&gt; and &lt;em&gt;worksheets.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Плагин Kotlin поддерживает &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (требуется Gradle версии 4.3 и выше; кеширование отключено в более ранних версиях).</target>
        </trans-unit>
        <trans-unit id="bb12e098841b4fa9ff61972654d2907071becf6c" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">&lt;a href=&quot;#configuring-source-sets&quot;&gt;Исходные&lt;/a&gt; коды Kotlin организованы в наборы исходных текстов . Помимо исходных файлов и ресурсов Kotlin, каждый исходный набор может иметь свои собственные зависимости. Исходные наборы образуют иерархию, построенную с отношением &lt;em&gt;&amp;laquo;зависит от&amp;raquo;&lt;/em&gt; . Исходный набор сам по себе не зависит от платформы, но он может содержать специфичный для платформы код и зависимости, если он скомпилирован только для одной платформы.</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Стандартная библиотека Kotlin &lt;code&gt;kotlin-stdlib&lt;/code&gt; нацелена на Java 6 и выше. Существуют расширенные версии стандартной библиотеки, которые добавляют поддержку некоторых функций JDK 7 и JDK 8. Чтобы использовать эти версии, добавьте одну из следующих зависимостей вместо &lt;code&gt;kotlin-stdlib&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Стандартная библиотека Kotlin содержит функции расширения для поиска частей коллекции.Эти функции предоставляют различные способы выбора элементов для результирующей коллекции:явное перечисление их позиций,указание размера результирующей коллекции и другие.</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Стандартная библиотека Kotlin содержит несколько функций, единственной целью которых является выполнение блока кода в контексте объекта. Когда вы вызываете такую ​​функцию для объекта с предоставленным &lt;a href=&quot;lambdas&quot;&gt;лямбда-выражением&lt;/a&gt; , она формирует временную область видимости. В этой области вы можете получить доступ к объекту без его имени. Такие функции называются &lt;em&gt;функциями области видимости&lt;/em&gt; . Их пять: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , а &lt;code&gt;also&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Стандартная библиотека Kotlin доступна на &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm,&lt;/a&gt; и мы можем просто включить ее в наш &lt;code&gt;package.json&lt;/code&gt; в качестве зависимости.</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Стандартная библиотека Kotlin теперь полностью совместима с модульной системой Java 9, которая запрещает разделение пакетов (несколько файлов jar, объявляющих классы в одном пакете). Для поддержки этого представлены новые артефакты &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; , которые заменяют старые &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Стандартная библиотека Kotlin предлагает широкий спектр функций для выполнения операций с коллекциями.Сюда входят как простые операции,такие как получение или добавление элементов,так и более сложные,включающие поиск,сортировку,фильтрацию,трансформации и т.д.</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет ряд оболочек вокруг JavaScript API для взаимодействия с документами. Основной компонент, к которому мы обычно обращаемся, - это переменный &lt;code&gt;document&lt;/code&gt; . Если у нас есть доступ к этому, мы можем просто читать и писать в соответствующие свойства. Например, чтобы установить фон страницы, мы можем сделать</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет набор функций расширения для &lt;em&gt;преобразования&lt;/em&gt; коллекций . Эти функции создают новые коллекции из существующих на основе предоставленных правил преобразования. На этой странице мы дадим обзор доступных функций преобразования коллекции.</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет разработчикам механизм для создания и использования &lt;em&gt;экспериментальных&lt;/em&gt; API. Этот механизм позволяет авторам библиотек информировать пользователей о том, что определенные компоненты их API, такие как классы или функции, нестабильны и могут измениться в будущем. Такие изменения могут потребовать переписывания и перекомпиляции клиентского кода. Чтобы предотвратить потенциальные проблемы совместимости, компилятор предупреждает пользователей об экспериментальном статусе таких API-интерфейсов и может потребовать от них явного согласия на использование API.</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет функции расширения для группировки элементов коллекции. Базовая функция &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt; принимает лямбда-функцию и возвращает &lt;code&gt;Map&lt;/code&gt; . На этой карте каждый ключ представляет собой лямбда-результат, а соответствующее значение - это &lt;code&gt;List&lt;/code&gt; элементов, для которых этот результат возвращается. Эту функцию можно использовать, например, для группировки списка &lt;code&gt;String&lt;/code&gt; по их первой букве.</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Стандартная библиотека Kotlin предоставляет заводские методы для нескольких полезных видов делегатов.</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Команда Котлин предлагает набор инструментов для разработки Android,выходящий за рамки стандартных функций языка:</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Визитные карточки Kotlin нанесены на Java следующим образом:</target>
        </trans-unit>
        <trans-unit id="ed293f7536e6525a4d07d9691dc5108b394e4a3c" translate="yes" xml:space="preserve">
          <source>The Kotlin visibility modifiers map to Java in the following way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f818f7eac72c440d892f7b7bd134c99b2cf031b4" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin handles DCE automatically when you build a &lt;strong&gt;production bundle&lt;/strong&gt;, for example by using the &lt;code&gt;browserProductionWebpack&lt;/code&gt; task. &lt;strong&gt;Development bundling&lt;/strong&gt; tasks (like &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt;) don't include DCE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e48978274145dccf82bae99c2dc2a30b0c91f68" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin includes a &lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;dead code elimination&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;DCE&lt;/em&gt;) tool. Dead code elimination is often also called &lt;em&gt;tree shaking&lt;/em&gt;. It reduces the size or the resulting JavaScript code by removing unused properties, functions, and classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Компилятор Kotlin / Native доступен для macOS, Linux и Windows. Он поддерживает различные цели, включая iOS (arm32, arm64, simulator x86_64), Windows (mingw32 и x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. Полный список целей можно найти в &lt;a href=&quot;../../reference/native-overview&quot;&gt;обзоре Kotlin / Native&lt;/a&gt; . Хотя кроссплатформенная компиляция возможна (т. Е. Использование одной платформы для компиляции для другой), в этом первом руководстве мы выполняем компиляцию только для операционной системы, в которой мы работаем.</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Языковой комитет принимает окончательные решения о том, какие несовместимые изменения будут внесены и какие именно меры следует предпринять, чтобы сделать обновления пользователей удобными. При этом он опирается на набор рекомендаций, доступных &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">Координаты Maven могут быть изменены, а дополнительные файлы артефактов могут быть добавлены к публикациям в блоке &lt;code&gt;targets { ... }&lt;/code&gt; или &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</target>
        </trans-unit>
        <trans-unit id="88e2042b128835939040b35b47b76d2e41113fdc" translate="yes" xml:space="preserve">
          <source>The Node.js target provided by Kotlin/JS enables you to create applications that &lt;strong&gt;run on a server&lt;/strong&gt; or get &lt;strong&gt;executed on serverless infrastructure&lt;/strong&gt;. You benefit from the same advantages as other applications executing in a JavaScript runtime, such as &lt;strong&gt;faster startup speed&lt;/strong&gt; and a &lt;strong&gt;reduced memory footprint&lt;/strong&gt;. With &lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt;&lt;code&gt;kotlinx-nodejs&lt;/code&gt;&lt;/a&gt;, you have typesafe access to the &lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.js API&lt;/a&gt; directly from your Kotlin code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">Тип &quot;Ничего</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">Откроется интерфейс командной строки REPL. Вы можете ввести любой действующий код Kotlin и увидеть результат. Результаты печатаются как переменные с автоматически сгенерированными именами, например &lt;code&gt;res*&lt;/code&gt; . Позже вы можете использовать такие переменные в коде, который вы запускаете в REPL.</target>
        </trans-unit>
        <trans-unit id="8fd3a2d7df046fd886264d64f792856593ec9b52" translate="yes" xml:space="preserve">
          <source>The REPL command line interface will open. You can enter any valid Kotlin code and see the result. The results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">Приведенный выше код компилируется. Однако это приведет к ошибке выполнения, если объект не инициализирован должным образом перед использованием или если &lt;code&gt;callAnything()&lt;/code&gt; не определен во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">Приведенный выше код указывает на то, что функция определяется извне. &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; аннотаций позволяет сопоставить имя во время выполнения до &lt;code&gt;$&lt;/code&gt; . Дополнительные сведения о внешних объявлениях см. В &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;документации взаимодействия JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">Вышеупомянутое также может быть единичной строкой - и обратите внимание, что компилятор знает, что, поскольку &lt;code&gt;throw&lt;/code&gt; предотвратит появление &lt;code&gt;y&lt;/code&gt; , если &lt;code&gt;x&lt;/code&gt; равен нулю, &lt;code&gt;y&lt;/code&gt; должен быть ненулевым, если мы дойдем до строки ниже. Сравните это с &lt;code&gt;x?.importantFunction()&lt;/code&gt; , которая не работает, если &lt;code&gt;x&lt;/code&gt; равен нулю.</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">Вышеизложенное предпочтительнее:</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">Параметр или тип затронутого типа &lt;em&gt;контравариантен&lt;/em&gt; . Обозначаемый тем &lt;code&gt;in&lt;/code&gt; модификаторе в исходном коде.</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">Параметр или тип затронутого типа &lt;em&gt;ковариантны&lt;/em&gt; . Обозначается модификатором &lt;code&gt;out&lt;/code&gt; в исходном коде.</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">Параметр или тип затронутого типа является &lt;em&gt;инвариантным&lt;/em&gt; , что означает, что к нему не применяется вариация.</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">Аннотация также работает для конструкторов,статических методов и так далее.Она не может быть использована для абстрактных методов,в том числе методов,определенных в интерфейсах.</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">Аннотации могут использоваться во внешних объявлениях верхнего уровня (классы, свойства, функции) и файлах. В случае файла (который не может быть &lt;code&gt;external&lt;/code&gt; ) применяется следующее правило: все объявления в файле должны быть &lt;code&gt;external&lt;/code&gt; . Применяя &lt;code&gt;@JsModule(...)&lt;/code&gt; к файлу, вы указываете компилятору импортировать объект JavaScript, содержащий все объявления из файла.</target>
        </trans-unit>
        <trans-unit id="ac7d8e089591134bac44995dadba571525f38003" translate="yes" xml:space="preserve">
          <source>The annotation has effect only in Kotlin/Native platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Аннотации для маркировки и использования экспериментальных API ( &lt;code&gt;@Experimental&lt;/code&gt; и &lt;code&gt;@UseExperimental&lt;/code&gt; ) являются &lt;em&gt;экспериментальными&lt;/em&gt; в Kotlin 1.3. См. Подробности &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">Синтаксис анонимных функций позволяет напрямую указывать тип приемника буквенной функции.Это может быть полезно,если вам нужно объявить переменную типа функции с приемником,и использовать ее позже.</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">Приложение, которое мы собираемся создать, будет просто отображать &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; на Android и &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; на iOS. Идея состоит в том, чтобы поделиться кодом, который генерирует это сообщение.</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">Синтаксис буквального массива ограничен аргументами аннотации.</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">Обозначение стрелок является правоассоциативным, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; эквивалентно предыдущему примеру, но не &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">Автор настоятельно рекомендует использовать IDE с поддержкой Kotlin, поскольку статическая типизация позволяет IDE выполнять надежную навигацию и автозавершение кода. Я рекомендую &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; , созданную той же компанией, что и Kotlin. Community Edition предоставляется бесплатно; см. &lt;a href=&quot;../getting-started&quot;&gt;инструкции по началу работы&lt;/a&gt; (он поставляется в комплекте с Kotlin, и вы можете запускать свою программу из IDE).</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">Доступные варианты сохранения включают прямой доступ JDBC, JPA, а также использование баз данных NoSQL через их драйверы Java. Для JPA &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;плагин компилятора kotlin-jpa&lt;/a&gt; адаптирует классы, скомпилированные в Kotlin, к требованиям фреймворка.</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">Базовый класс для всех ошибок и исключений.Только экземпляры этого класса могут быть брошены или пойманы.</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">Базовым классом исключений является &lt;code&gt;Throwable&lt;/code&gt; (но чаще расширяют его подкласс &lt;code&gt;Exception&lt;/code&gt; ), и существует множество встроенных классов исключений. Если вы не найдете тот, который соответствует вашим потребностям, вы можете создать свой собственный, унаследовав от существующего класса исключений.</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">Базовая функция &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt; создает &lt;code&gt;Map&lt;/code&gt; в которой элементы исходной коллекции являются ключами, а значения производятся из них с помощью данной функции преобразования. Если два элемента равны, на карте остается только последний.</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">Основная функция фильтрации - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; . При вызове с предикатом &lt;code&gt;filter()&lt;/code&gt; возвращает соответствующие ему элементы коллекции. И для &lt;code&gt;List&lt;/code&gt; , и для &lt;code&gt;Set&lt;/code&gt; результирующая коллекция является &lt;code&gt;List&lt;/code&gt; , для &lt;code&gt;Map&lt;/code&gt; это также &lt;code&gt;Map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt; функции sorted &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; и sortedDescending () возвращают элементы коллекции, отсортированные в возрастающей и убывающей последовательности в соответствии с их естественным порядком. Эти функции применяются к коллекциям элементов &lt;code&gt;Comparable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">Лучше всего начать с &lt;a href=&quot;https://kotlinlang.org&quot;&gt;этого веб-сайта&lt;/a&gt; . Оттуда вы можете скачать компилятор, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;попробовать его в Интернете,&lt;/a&gt; а также получить доступ к ресурсам, &lt;a href=&quot;index&quot;&gt;справочной документации&lt;/a&gt; и &lt;a href=&quot;../tutorials/index&quot;&gt;руководствам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">Лучший способ увидеть,какие типы данных C видны в Котлине-это попробовать.</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">Лучший способ понять соответствие между языками C и Kotlin - это попробовать это на небольшом примере. Для этого мы создадим небольшие заголовки библиотеки. Во-первых, нам нужно создать файл &lt;code&gt;lib.h&lt;/code&gt; со следующим объявлением функций, которые работают со строками C:</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">Лучший способ понять картирование между Котлином и С-это попробовать на крошечном примере.Мы объявляем функцию,которая принимает в качестве параметра указатель на функцию,и другую функцию,которая возвращает указатель на функцию.</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">Лучший способ понять картирование между Котлином и С-это попробовать на крошечном примере.Мы объявим структуру и союз на языке С,чтобы посмотреть,как они отображаются в Котлине.</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">Лучший способ понять эти приемы-попробовать их.Давайте создадим первую крошечную библиотеку Kotlin и используем ее из программы на Си.</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">Лучший способ использовать компилятор Kotlin/Native-это система сборки.Она помогает,загружая и кэшируя двоичные файлы и библиотеки Kotlin/Native компилятора с переходными зависимостями,а также запуская компилятор и тесты.Он также кэширует результаты компиляции.Сборочная система также может быть использована IDE для понимания компоновки проекта.</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">Бинарные файлы DSL позволяют не только создавать двоичные файлы, но также получать доступ к уже созданным для их настройки или получения их свойств (например, путь к выходному файлу). Коллекция &lt;code&gt;binaries&lt;/code&gt; реализует интерфейс &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; &lt;/a&gt; и предоставляет такие методы, как &lt;code&gt;all&lt;/code&gt; или &lt;code&gt;matching&lt;/code&gt; позволяющие настраивать группы элементов.</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">Бинарные файлы создаются в папках &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; или &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; соответственно. Файл имеет расширение &lt;code&gt;.kexe&lt;/code&gt; в Linux и macOS и расширение &lt;code&gt;.exe&lt;/code&gt; в Windows. Используйте следующую команду, чтобы заставить сборку создавать двоичные файлы:</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">Блок после &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; - это первый функциональный литерал с получателем, который будет передан &lt;code&gt;tree()&lt;/code&gt; в качестве параметра &lt;code&gt;initialize&lt;/code&gt; . Согласно списку параметров &lt;code&gt;tree()&lt;/code&gt; , получатель относится к типу &lt;code&gt;TreeNode&lt;/code&gt; , и поэтому &lt;code&gt;tree()&lt;/code&gt; может вызывать &lt;code&gt;initialize()&lt;/code&gt; для &lt;code&gt;root&lt;/code&gt; . &lt;code&gt;root&lt;/code&gt; затем становится &lt;code&gt;this&lt;/code&gt; внутри области действия этого лямбда-выражения, поэтому, когда мы вызываем &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; , он неявно говорит &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; , где &lt;code&gt;this&lt;/code&gt; относится к тому же &lt;code&gt;TreeNode&lt;/code&gt; , что и &lt;code&gt;root&lt;/code&gt; , Следующий блок передается в &lt;code&gt;TreeNode.node()&lt;/code&gt; и вызывается для первого дочернего элемента &lt;code&gt;root&lt;/code&gt; узла, а именно &lt;code&gt;math&lt;/code&gt; , и внутри него &lt;code&gt;this&lt;/code&gt; будет относиться к &lt;code&gt;math&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">Тело может быть блоком.</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">Тело объектного выражения может получать доступ к локальным переменным содержащей области видимости и,возможно,изменять их.</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">Классы боксов,используемые для захвата мутирующих переменных закрытия в лямбдах,больше не имеют летучих полей.Это изменение улучшает производительность,но может привести к новым условиям гонки в некоторых редких сценариях использования.Если на вас это влияет,вам необходимо обеспечить собственную синхронизацию для доступа к переменным.</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">&lt;code&gt;build/bin/native/debugShared&lt;/code&gt; создает следующие файлы в папке build / bin / native / debugShared , в зависимости от ОС хоста:</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">Вызов &lt;code&gt;C().foo(1)&lt;/code&gt; напечатает &amp;laquo;extension&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">В вызове &lt;code&gt;execute&lt;/code&gt; используется функция, переданная в качестве второго параметра, для создания подграфа объекта (то есть набора взаимно ссылающихся объектов), который затем передается целиком этому исполнителю, после чего он больше не доступен для потока, инициировавшего запрос. Это свойство проверяется, если первым параметром является &lt;code&gt;TransferMode.SAFE&lt;/code&gt; , при обходе графа, и предполагается, что оно истинно, если это &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; . Последний параметр для &lt;code&gt;execute&lt;/code&gt; - это специальная лямбда Kotlin, которой не разрешено захватывать какое-либо состояние, и которая фактически вызывается в контексте целевого воркера. После обработки результат передается всему, что потребляет его в будущем, и прикрепляется к графу объектов этого рабочего / потока.</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">Обратный вызов,который вызывается после смены объекта недвижимости.Значение свойства уже было изменено при вызове этого свойства.</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">Обратный вызов, который вызывается перед попыткой изменения значения свойства. При вызове этого обратного вызова значение свойства еще не изменилось. Если обратный вызов возвращает &lt;code&gt;true&lt;/code&gt; значение свойства устанавливается на новое значение, а если обратный вызов возвращает &lt;code&gt;false&lt;/code&gt; новое значение отбрасывается, а свойство остается прежним.</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">Вызовы, которые влияют на вывод, являются либо членами типа получателя аннотированного параметра функции, либо расширениями для этого типа. Сами расширения должны быть аннотированы &lt;code&gt;@BuilderInference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">Изменения в зависимостях совместимы с &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; . Например, изменения коснулись только тел методов.</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">Каналы,показанные до сих пор,не имели буфера.Небуферизованные каналы передают элементы,когда отправитель и получатель встречаются друг с другом (так же известны как рандеву).Если отправка вызывается первой,то она приостанавливается до тех пор,пока не будет вызван прием,если приемник вызывается первым,то приостанавливается до тех пор,пока не будет вызван прием.</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">Символ &quot;- кавычки</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">Символ $ - знак доллара</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">Персонаж &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">Символ &amp;amp; - амперсанд</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">Персонаж &amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">Персонаж &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">Персонаж &amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">Персонаж &amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">Персонаж &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">Характер &amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">Персонаж &amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">Персонаж &amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">Персонаж &amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">Знак&amp;gt; - знак больше</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">Персонаж &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">Символ &amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">Персонаж '</target>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">Знак &amp;lt;- знак меньше</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">Персонаж -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">Персонаж &amp;middot;</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">Персонаж -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">Персонаж &amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">Персонаж &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">Характер &amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">Персонаж &amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">Персонаж '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">Персонаж &quot;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">Символ &amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">Персонаж '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">Персонаж ,</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">Персонаж &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">Персонаж &amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">Персонаж &amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">Класс также может объявлять &lt;strong&gt;вторичные конструкторы&lt;/strong&gt; , которые имеют префикс &lt;em&gt;конструктора&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">Декларация класса состоит из имени класса,заголовка класса (с указанием параметров его типа,первичного конструктора и т.д.)и тела класса,окруженного фигурными скобками.И заголовок,и тело являются необязательными;если класс не имеет тела,фигурные скобки могут быть опущены.</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">Файл класса с типом,не указанным здесь,рассматривается как файл,не относящийся к Kotlin.</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">В приведенном выше коде используется &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;ссылка&lt;/a&gt; на связанный класс , который поддерживается начиная с Kotlin 1.1. Вы также можете использовать &lt;code&gt;javaClass&lt;/code&gt; расширения javaClass :</target>
        </trans-unit>
        <trans-unit id="732a1f0dd7bc7add2cc125d4681e9dd3eef05206" translate="yes" xml:space="preserve">
          <source>The code in object expressions can access variables from the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">Рассматриваемый код взят из &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;простого&lt;/a&gt; примера (комментарии удалены для краткости)</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">Код в файле &lt;code&gt;hello.kt&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">Код в окончательном файле &lt;code&gt;hello.kt&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">Код полон атрибутов Objective-C, которые предназначены для помощи в использовании фреймворка как на языках Objective-C, так и на Swift. &lt;code&gt;DemoClazz&lt;/code&gt; , &lt;code&gt;DemoInterface&lt;/code&gt; и &lt;code&gt;DemoObject&lt;/code&gt; созданы для &lt;code&gt;Clazz&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; и &lt;code&gt;Object&lt;/code&gt; соответственно. &lt;code&gt;Interface&lt;/code&gt; превращается в &lt;code&gt;@protocol&lt;/code&gt; , одновременно &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;object&lt;/code&gt; представлены в виде &lt;code&gt;@interface&lt;/code&gt; . &lt;code&gt;Demo&lt;/code&gt; - приставка происходит от &lt;code&gt;-output&lt;/code&gt; параметра &lt;code&gt;kotlinc-native&lt;/code&gt; компилятора и имени рамочного. Здесь мы видим, что возвращаемый тип, допускающий значение NULL &lt;code&gt;ULong?&lt;/code&gt; превращается в &lt;code&gt;DemoLong*&lt;/code&gt; в Objective-C.</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">Код по-прежнему написан так, как если бы мы писали синхронный код сверху вниз, без необходимости в каком-либо специальном синтаксисе, помимо использования функции под названием &lt;code&gt;launch&lt;/code&gt; , которая по существу запускает сопрограмму (описанная в других руководствах).</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">Код или данные,на которые указывает значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">Код выглядит следующим образом. У нас &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; структура libnative_ExportedSymbols , которая определяет все функции, которые Kotlin / Native и наша библиотека предоставляют нам. Он сильно использует вложенные анонимные структуры для имитации пакетов. &lt;code&gt;libnative_&lt;/code&gt; приставка происходит от имени библиотеки.</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">В коде используются объявления анонимной структуры. Код &lt;code&gt;struct { .. } foo&lt;/code&gt; объявляет поле во внешней структуре этого анонимного структурного типа, типа без имени.</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">Интерфейсы коллекции и связанные с ними функции находятся в пакете kotlin.collections.Ознакомимся с его содержимым.</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">Команда создает файл &lt;code&gt;main.exe&lt;/code&gt; , который мы можем запустить.</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">Общий базовый класс для всех классов перечисления. См. &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Документацию&lt;/a&gt; по языку Kotlin для получения дополнительной информации о классах enum.</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">Общий базовый класс для всех классов перечисления. См. &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Документацию&lt;/a&gt; по языку Kotlin для получения дополнительной информации о классах enum.</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">Обычный код - &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; , где &lt;code&gt;platformName()&lt;/code&gt; - это функция, объявленная с использованием ключевого слова &lt;code&gt;expect&lt;/code&gt; . &lt;code&gt;actual&lt;/code&gt; реализация будет относится к платформе.</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">Общие исходные тексты не могут включать исходные тексты Java.</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">Общий супертип для всех вызываемых ссылок - это &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt; , где &lt;code&gt;R&lt;/code&gt; - тип возвращаемого значения, который является типом свойства для свойств и сконструированным типом для конструкторов.</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">Сопутствующий объект &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; является экземпляром &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">Сопутствующий объект является одноэлементным,и доступ к его участникам можно получить непосредственно через имя содержащего класса (хотя вы также можете вставить имя сопровождающего объекта,если вы хотите быть явно выраженным в отношении доступа к сопровождающему объекту):</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">Компилятор автоматически выводит следующие члены из всех свойств,объявленных в первичном конструкторе:</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">Компилятор может вывести типы функций для переменных,если информации достаточно:</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">Компилятор гарантирует,что каждая ожидаемая декларация имеет актуальные декларации во всех модулях платформы,реализующих соответствующий общий модуль,и сообщает об ошибке,если какие-либо актуальные декларации отсутствуют.IDE предоставляет инструменты,которые помогают создавать отсутствующие действительные декларации.</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">Компилятор создает исполняемый файл с именем &lt;code&gt;a.out&lt;/code&gt; . Нам нужно запустить его, чтобы увидеть в действии код Kotlin, выполняемый из библиотеки C. В Linux нам нужно включить &lt;code&gt;.&lt;/code&gt; в &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; , чтобы приложение знало, что нужно загрузить библиотеку &lt;code&gt;libnative.so&lt;/code&gt; из текущей папки.</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">Компилятор достаточно умен,чтобы знать гипс,чтобы быть в безопасности,если отрицательная проверка приводит к возврату:</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">Теперь компилятор вставляет значения свойств &lt;code&gt;const val&lt;/code&gt; в места, где они используются.</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">Компилятор теперь предоставляет возможность обрабатывать все предупреждения как ошибки. Используйте &lt;code&gt;-Werror&lt;/code&gt; в командной строке или следующий фрагмент Gradle:</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">Компилятор выполняет следующие шаги для разрешения оператора в &lt;em&gt;постфиксной&lt;/em&gt; форме, например, &lt;code&gt;a++&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Компилятор выдает предупреждение о приведении в последней строке. Приведение не может быть полностью проверено во время выполнения и не гарантирует, что значения на карте имеют &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">Компилятор создает код, соответствующий целевой модульной системе, например, в случае CommonJS он импортирует объявление через функцию &lt;code&gt;require(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">Компилятор отслеживает информацию о выполненной вами проверке и позволяет вызывать &lt;code&gt;length&lt;/code&gt; внутри &lt;em&gt;if&lt;/em&gt; . Также поддерживаются более сложные условия:</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">Компилятор позволяет вызывать эту функцию, например, как &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; или &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; , но не как &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; или как &lt;code&gt;test(null, null)&lt;/code&gt; . Вызов &lt;code&gt;test(a, b)&lt;/code&gt; разрешен только в том случае, если компилятор может доказать, что &lt;code&gt;a&lt;/code&gt; не может быть нулевым. Внутри &lt;code&gt;test&lt;/code&gt; компилятор не позволит вам сделать что-либо с &lt;code&gt;b&lt;/code&gt; , что приведет к исключению, если &lt;code&gt;b&lt;/code&gt; окажется равным нулю, поэтому вы можете сделать &lt;code&gt;a.length&lt;/code&gt; , но не &lt;code&gt;b.length&lt;/code&gt; . Однако, как только вы находитесь внутри условного оператора, где вы проверили, что &lt;code&gt;b&lt;/code&gt; не равно нулю, вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">Компилятор сгенерирует что-то вроде этого (за исключением того, что &lt;code&gt;start&lt;/code&gt; не будет конфликтовать с другими идентификаторами с тем же именем):</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">Компилятор не позволит вам выполнять проверки, которые не могут быть успешными, потому что объявленный тип переменной - это класс, который находится в несвязанной ветви иерархии классов от класса, который вы проверяете, - если объявленный тип &lt;code&gt;x&lt;/code&gt; равен &lt;code&gt;MotorVehicle&lt;/code&gt; , вы не можете проверить , если &lt;code&gt;x&lt;/code&gt; является &lt;code&gt;Person&lt;/code&gt; . Если правая часть &lt;code&gt;is&lt;/code&gt; это интерфейс, Kotlin разрешит типу левой части быть любым интерфейсом или открытым классом, потому что может быть, что какой-то его подкласс реализует интерфейс.</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Полный список опций для заданий &quot;Колыбели&quot; приведен ниже:</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">Потребителю может понадобиться только добавить атрибут к одной цели,когда возникает двусмысленность.</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">Содержимое нашего &lt;code&gt;main.js&lt;/code&gt; будет таким:</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">Контекст корутины,соответствующий этому продолжению.</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">Описание договора должно быть в начале функции и иметь,по крайней мере,один эффект.</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Параметр контравариантного типа параметра возвращаемого типа с функциональным типом (пользователь вызовет возвращаемую функцию с чем-то, что может потреблять любой &lt;code&gt;Fruit&lt;/code&gt; , поэтому нормально вернуть функцию, которая ожидает получить что-то, что может обрабатывать &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Параметр контравариантного типа для типа параметра (пользователь передает потребителя, который может обрабатывать любой &lt;code&gt;Fruit&lt;/code&gt; , и ему будет предоставлено &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">Параметр контравариантного типа возвращаемого типа параметра с функциональным типом (пользователь передает функцию, которая вернет потребителя любого &lt;code&gt;Fruit&lt;/code&gt; , а возвращенному потребителю будут предоставлены экземпляры &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">Согласно принятому соглашению, каждая библиотека получает свой собственный файл определения, обычно называемый так же, как и библиотека. Дополнительные сведения обо всех параметрах, доступных для &lt;code&gt;cinterop&lt;/code&gt; , см. &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;В документации Interop.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c72d89d38289079cb805c34b2308d4dfa8c2fd72" translate="yes" xml:space="preserve">
          <source>The coroutine context includes a &lt;em&gt;coroutine dispatcher&lt;/em&gt; (see &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcher&lt;/a&gt;) that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">Контекст сопрограммы - это набор различных элементов. Основные элементы являются &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;работой&lt;/a&gt; в сопрограммах, которую мы видели раньше, и его диспетчер, который рассматривается в данном разделе.</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">Сопрограммный запускаются непосредственно в потоке заклинателя без прохождения через &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; , которые могут присутствовать в достройке в &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; . Ответственность за обеспечение правильного контекста вызова лежит на вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="5075509aaa121a034050446e85498c3f79064890" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context, and can be retrieved from it using the &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">Сопрограмм в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Работа&lt;/a&gt; является частью контекста. Сопрограмма может получить его из своего собственного контекста, используя выражение &lt;code&gt;coroutineContext[Job]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5769f42ad3e1d523865b402b5e67bd28e7b20bad" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;sourceSets&lt;/code&gt; property should be updated if not using the default convention:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">Соответствующее свойство &lt;em&gt;sourceSets&lt;/em&gt; должно быть обновлено, если не используется соглашение по умолчанию:</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Параметр ковариантного типа свойства, доступного только для чтения (пользователь ожидает производителя &lt;code&gt;Fruit&lt;/code&gt; и получает производителя &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Параметр ковариантного типа возвращаемого типа (пользователь ожидает, что возвращаемое значение приведет к созданию &lt;code&gt;Fruit&lt;/code&gt; , так что ничего страшного, если оно действительно дает &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">Параметр ковариантного типа типа параметра параметра с функциональным типом (пользователь передает функцию, которая может обрабатывать любого производителя &lt;code&gt;Fruit&lt;/code&gt; , и ей будет предоставлен производитель &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Параметр ковариантного типа возвращаемого типа возвращаемого типа с функциональным типом (пользователь ожидает, что возвращаемая функция вернет что-то, что производит &lt;code&gt;Fruit&lt;/code&gt; , поэтому ничего страшного, если она действительно производит &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">Созданный &lt;code&gt;StableRef&lt;/code&gt; в конечном итоге следует удалить вручную с помощью &lt;code&gt;.dispose()&lt;/code&gt; чтобы предотвратить утечку памяти:</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">Созданное iOS-приложение готово к запуску на эмуляторе iOS или на iOS-устройстве.Для запуска устройства может потребоваться учетная запись разработчика Apple и выдача сертификата разработчика.Xcode делает всё возможное,чтобы помочь нам в этом процессе.</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">Кудрявые фигурные скобки вокруг тела могут быть опущены,если тело является онелинером.Это обескураживает,если только тело не переходит на ту же линию,что и состояние,потому что это позволяет легко ошибиться,особенно когда человек привык к Python:</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">В настоящее время выпущена версия 1.3.41,опубликованная 4 июля 2019 года.</target>
        </trans-unit>
        <trans-unit id="b5744a90420458acc57f96347ae2c3cc6f2d50b3" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.4.10, published on September 10, 2020.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">Объявление классификатора, используемого в этом типе. Например, в типе &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; классификатор будет экземпляром &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; для &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">Объявления в новых артефактах видны под теми же самыми именами пакетов с точки зрения Kotlin,но имеют различные имена пакетов для Java.Поэтому переход на новые артефакты не потребует внесения изменений в исходный код.</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;Кодировка по&lt;/a&gt; умолчанию - UTF-8, но вы можете указать ее, если вам нужно что-то еще:</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">Идентификаторы артефактов по умолчанию следуют шаблону &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; , например &lt;code&gt;sample-lib-nodejs&lt;/code&gt; для цели с именем &lt;code&gt;nodeJs&lt;/code&gt; в проекте &lt;code&gt;sample-lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960beb3d459f57914f0b08a89c8e7a0ae2d213a2" translate="yes" xml:space="preserve">
          <source>The default dispatcher that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses a shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">Диспетчер по умолчанию, который используется при запуске сопрограмм в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; , представлен &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; и использует общий фоновый пул потоков, поэтому &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; использует тот же диспетчер, что и &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">Реализация по умолчанию доступна для классов Java,реализующих интерфейс.</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">Реализация &lt;code&gt;Map&lt;/code&gt; умолчанию - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; - сохраняет порядок вставки элементов при повторении карты. В свою очередь, альтернативная реализация - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; - ничего не говорит о порядке элементов.</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">Реализация &lt;code&gt;Set&lt;/code&gt; по умолчанию - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; - сохраняет порядок вставки элементов. Следовательно, функции, которые полагаются на порядок, такие как &lt;code&gt;first()&lt;/code&gt; или &lt;code&gt;last()&lt;/code&gt; , возвращают предсказуемые результаты для таких наборов.</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">Допустимость значений NULL по умолчанию используется, когда тип сам по себе не аннотируется аннотацией, допускающей значение NULL, а значение по умолчанию определяется самым внутренним охватывающим элементом, аннотированным с помощью аннотации квалификатора типа по умолчанию с &lt;code&gt;ElementType&lt;/code&gt; , соответствующим использованию типа.</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">Генератор случайных чисел по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">Исходный набор по умолчанию &lt;code&gt;commonMain&lt;/code&gt; добавляется к компиляции каждого производственного (приложения или библиотеки) варианта. &lt;code&gt;commonTest&lt;/code&gt; множество источника, аналогично, добавляется к компиляциям модульного тестирования и вариантам инструментальных испытаний.</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">Верхняя граница по умолчанию (если не указана) - &lt;code&gt;Any?&lt;/code&gt; , Внутри угловых скобок можно указать только одну верхнюю границу. Если же параметр типа нуждается в большем количестве, чем одна верхняя граница, нам нужно отдельно &lt;strong&gt;где&lt;/strong&gt; -clause:</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">Значение по умолчанию указывается при объявлении этого параметра.</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">Часть определений показывает, как примитивные типы Kotlin отображаются в примитивные типы C. Мы обсуждали обратное сопоставление в учебнике &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">Класс делегата может реализовывать один из интерфейсов &lt;code&gt;ReadOnlyProperty&lt;/code&gt; и &lt;code&gt;ReadWriteProperty&lt;/code&gt; , содержащих требуемые методы &lt;code&gt;operator&lt;/code&gt; . Эти интерфейсы объявлены в стандартной библиотеке Kotlin:</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">Делегированное свойство можно использовать таким образом для объявления свойства в &lt;code&gt;Person&lt;/code&gt; - обратите внимание на использование &lt;code&gt;by&lt;/code&gt; вместо &lt;code&gt;=&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="898cc738a761dcd3be73120e07ea5697ac2725df" translate="yes" xml:space="preserve">
          <source>The dependencies configuration has been changed; dependencies are now specified separately for each source root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">Объявленные таким образом зависимости добавляются в файл podspec и загружаются во время выполнения &lt;code&gt;pod install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">Описанный механизм маркировки и использования экспериментальных API-интерфейсов сам по себе является экспериментальным в Kotlin 1.3. Это означает, что в будущих выпусках он может быть изменен таким образом, чтобы сделать его несовместимым. Чтобы пользователи аннотаций &lt;code&gt;@Experimental&lt;/code&gt; и &lt;code&gt;UseExperimental&lt;/code&gt; знали об их экспериментальном статусе, компилятор выдает предупреждения при компиляции кода с этими аннотациями:</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">Дизайн встроенных классов является экспериментальным, что означает, что эта функция &lt;em&gt;быстро развивается&lt;/em&gt; и никаких гарантий совместимости не дается. При использовании встроенных классов в Kotlin 1.3+ будет выдано предупреждение, указывающее, что эта функция является экспериментальной.</target>
        </trans-unit>
        <trans-unit id="530e7472ee58bdd7a4958120705547c1d20c1ddf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;, meaning that no compatibility guarantees are given for future versions. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">Конструкция беззнаковых типов является экспериментальной,а это означает,что данная функция движется быстро и не дает никаких гарантий совместимости.При использовании беззнаковой арифметики в Kotlin 1.3+будет выдано предупреждение,указывающее на то,что данная особенность является экспериментальной.Чтобы убрать предупреждение,необходимо выбрать экспериментальное использование типов unsigned.</target>
        </trans-unit>
        <trans-unit id="a2b28866ac37f05ef8569c7d67a02f97e240cc06" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;, meaning that its compatibility is best-effort only and not guaranteed. When using unsigned arithmetics in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable. To remove the warning, you have to opt in for usage of unsigned types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">Разница между двумя функциями заключается в том, что &lt;code&gt;fold()&lt;/code&gt; принимает начальное значение и использует его как накопленное значение на первом шаге, тогда как первый шаг функции &lt;code&gt;reduce()&lt;/code&gt; использует первый и второй элементы в качестве аргументов операции на первом шаге.</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">Каталоги,содержащие исходные файлы для компиляции</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">Динамический тип не поддерживается в коде,ориентированном на JVM</target>
        </trans-unit>
        <trans-unit id="52d4bb2170c55ab0a1a89bfce15477357b84c2db" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">Самый простой способ создать новое приложение,нацеленное на JavaScript,с помощью Maven-это позволить IntelliJ IDEA настроить проект Maven для нас.Просто создайте новый проект Maven в IntelliJ IDEA и,как только проект будет создан,добавьте новую папку для размещения исходного кода Kotlin,удалив Java по умолчанию.В конечном итоге проект должен иметь следующую структуру</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">Эффект вычисления выражения:</target>
        </trans-unit>
        <trans-unit id="ff0a9ac30d7664a4e4282016eea87cab13969066" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a189a8bbd800a60d20579c11365537800d1c5b" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">Элемент инициализируется специальной функцией &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">Элемент инициализируется специальной функцией &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">Элементы добавляются в том порядке, в котором они появляются в коллекции &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;элементов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="544e4fbca97528fef2325c3afe55cace763538a4" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">Элементы добавляются в том порядке, в котором они появляются в коллекции &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;элементов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82095a92897d87f6ce531db50ce0bc12db68723f" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">Элементы сравниваются на равенство с функцией &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;равенства&lt;/a&gt; . Для чисел с плавающей запятой это означает, что &lt;code&gt;NaN&lt;/code&gt; равно самому себе, а &lt;code&gt;-0.0&lt;/code&gt; не равно &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aad20466e5a76028e3397e50e8845f24663b34cf" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">Элементы в результирующем списке расположены в том же порядке,что и в исходном массиве.</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">Элементы в результирующем списке расположены в том же порядке,в каком они были в коллекции источников.</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">Элементы в результирующей последовательности расположены в том же порядке,что и в исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">Элементы других типов сравниваются на равенство с функцией &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; . Для чисел с плавающей запятой это означает, что &lt;code&gt;NaN&lt;/code&gt; равно самому себе, а &lt;code&gt;-0.0&lt;/code&gt; не равно &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="410a7c8a1416b4dffdf86f7b2fb29d1be03e7884" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">Конечный индекс &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;диапазона&lt;/a&gt; включается в удаленную часть.</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">Конечный индекс &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;диапазона&lt;/a&gt; включается в удаленную часть.</target>
        </trans-unit>
        <trans-unit id="67fcbb6ac3e2a5c62cd2e430c9777a067763d923" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa81f1705dd0f516aa78c926061ad0c0bdec167" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">Конечный индекс &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;диапазона&lt;/a&gt; включается в заменяемую часть.</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">Конечный индекс &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;диапазона&lt;/a&gt; включается в заменяемую часть.</target>
        </trans-unit>
        <trans-unit id="265808d7f064c65b3e4484a504c21278573abe5f" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2757b02f416ac5f1c57fe37f28ebb5f19a2beb88" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">Сущность,которая имеет связанный родной указатель.Подтипы должны представлять собой интерпретации указанных данных или кода.</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">Константы перечисления также реализуют интерфейс &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; , причем естественным порядком является порядок, в котором они определены в классе перечисления.</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">Пример выше показывает разницу: &lt;code&gt;fold()&lt;/code&gt; используется для вычисления суммы удвоенных элементов. Если вы передадите ту же функцию в &lt;code&gt;reduce()&lt;/code&gt; , она вернет другой результат, потому что он использует первый и второй элементы списка в качестве аргументов на первом шаге, поэтому первый элемент не будет удвоен.</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше пример будет работать с библиотеками Android без каких-либо продуктов. Для библиотеки с ароматизаторами продуктов имена вариантов также содержат эти вкусы, например &lt;code&gt;fooBarDebug&lt;/code&gt; или &lt;code&gt;fooBazRelease&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">Пример использования &lt;code&gt;convert&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">Исключение,брошенное при ошибке кодирования или декодирования символов.</target>
        </trans-unit>
        <trans-unit id="15573b104c4da364167fd1f5ed5ef94aba8df42c" translate="yes" xml:space="preserve">
          <source>The experimental marker for associated objects API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">Экспериментальный маркер для аннотаций,дополняющих выводы типа.</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">Экспериментальный мультиплатформенный маркер поддержки API.</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">Выражение &lt;code&gt;::x&lt;/code&gt; вычисляет объект свойства типа &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; , что позволяет нам читать его значение с помощью &lt;code&gt;get()&lt;/code&gt; или получать имя свойства с помощью свойства &lt;code&gt;name&lt;/code&gt; . Для получения дополнительной информации обратитесь к &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;документации по классу &lt;code&gt;KProperty&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">В файле отсутствует &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; блок &amp;laquo;C&amp;raquo; , который не нужен для нашего примера, но может быть необходим, если мы используем C ++ и перегруженные функции. В ветке &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;совместимости с C ++&lt;/a&gt; содержится более подробная информация об этом.</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">Расположение файловой системы для источников Java отличается от значений по умолчанию для подключаемого модуля &lt;code&gt;java&lt;/code&gt; . Исходные файлы Java должны быть размещены в дочерних каталогах корней исходного кода Kotlin. Например, если цель JVM имеет имя по умолчанию &lt;code&gt;jvm&lt;/code&gt; , пути следующие:</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">Нас больше всего интересует файл &lt;code&gt;ConsoleOutput.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">Окончательный код в файле &lt;code&gt;hello.kt&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">Окончательный код в файле &lt;code&gt;hello.kt&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">Последним шагом является определение фактической компиляции проекта,использующего стандартный IntelliJ IDEA Runner Type</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">Последний шаг - заставить Xcode вызывать нашу сборку Gradle для подготовки &lt;code&gt;SharedCode&lt;/code&gt; перед каждым запуском. Мы открываем вкладку &lt;em&gt;Build Phases&lt;/em&gt; и нажимаем &lt;code&gt;+&lt;/code&gt; , чтобы добавить &lt;em&gt;New Run Script Phase&lt;/em&gt; и добавить в нее следующий код:</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">Первый &lt;code&gt;this&lt;/code&gt; относится к &lt;code&gt;maybeNull&lt;/code&gt; , второй относится к результату &lt;code&gt;firstFunction()&lt;/code&gt; , а &lt;code&gt;result&lt;/code&gt; будет являться результатом &lt;code&gt;secondFunction()&lt;/code&gt; (или нуль , если &lt;code&gt;maybeNull&lt;/code&gt; или любой из промежуточных результатов было нулевым).</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент в этом примере позволяет установить префикс имени для созданных двоичных файлов, который используется для доступа к ним в скрипте сборки (см. Раздел &lt;a href=&quot;#accessing-binaries&quot;&gt;&amp;laquo;Доступ к двоичным&lt;/a&gt; файлам &amp;raquo; ). Также этот префикс используется как имя по умолчанию для двоичного файла. Например, в Windows из приведенного выше &lt;code&gt;foo.exe&lt;/code&gt; &lt;code&gt;bar.exe&lt;/code&gt; файлы foo.exe и bar.exe .</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">Первый вызов в цепочке обычно должен иметь обрыв строки перед ним,но его можно пропустить,если в коде так больше смысла.</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">Первый элемент в прогрессии.</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">В первом примере в одном коде смешиваются &lt;em&gt;неблокирующая &lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; и &lt;em&gt;блокирующая &lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; . Легко забыть, какой из них блокирует, а какой нет. Давайте определимся с блокировкой с помощью &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;конструктора&lt;/a&gt; сопрограмм runBlocking :</target>
        </trans-unit>
        <trans-unit id="1aa4bbc7c819801ad00e125d4e56e82f4c2f67c5" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">Первое расширение принимает &lt;code&gt;char *&lt;/code&gt; как строку UTF-8 и превращает ее в строку. Вторая функция делает то же самое, но для широких строк UTF-16.</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">Первые четыре элемента добавляются в буфер,а отправитель при попытке отправить пятый элемент приостанавливается.</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">Первая функция - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; . Вы можете вызвать его для коллекции коллекций, например &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; . Функция возвращает единый &lt;code&gt;List&lt;/code&gt; всех элементов вложенных коллекций.</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">Первая строка ввода содержит два целых числа &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">Первый список содержит первые элементы каждой &lt;code&gt;Pair&lt;/code&gt; в исходном списке.</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">Первым шагом использования актора является определение класса сообщений, которые актор будет обрабатывать. &lt;a href=&quot;../sealed-classes&quot;&gt;Запечатанные классы&lt;/a&gt; Kotlin хорошо подходят для этой цели. Определим &lt;code&gt;CounterMsg&lt;/code&gt; запечатанный класс с &lt;code&gt;IncCounter&lt;/code&gt; сообщением , чтобы увеличить счетчик и &lt;code&gt;GetCounter&lt;/code&gt; сообщение , чтобы получить его значение. Последнему нужно отправить ответ. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; связь примитивно, что представляет собой одно значение , которое будет известно (переданное) в будущем, здесь используются для этой цели.</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">Первое, что нам понадобится, это файл Kotlin с именем &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; с определенной в нем функцией &lt;code&gt;main&lt;/code&gt; , а затем перейти к переводу каждой строки.</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">Поддерживаются следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">Следующий код запускает длительную сопрограмму в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope,&lt;/a&gt; которая печатает &amp;laquo;Я сплю&amp;raquo; дважды в секунду, а затем возвращается из основной функции после некоторой задержки:</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">Доступны следующие команды.</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">Следующий пример демонстрирует эту концепцию:</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">В следующем примере печатаются первые десять простых чисел, выполняя весь конвейер в контексте основного потока. Поскольку все сопрограммы запускаются в рамках основной сопрограммы &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking,&lt;/a&gt; нам не нужно вести явный список всех запущенных сопрограмм. Мы используем &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;функцию&lt;/a&gt; расширения cancelChildren, чтобы отменить все дочерние сопрограммы после того, как мы напечатали первые десять простых чисел.</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">Следующий пример показывает,как использовать эти настройки.</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">Следующий пример показывает их использование за пределами корутины:</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">В следующих примерах показаны различные возможности настройки плагина Gradle:</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">Следующие идентификаторы определяются компилятором в конкретных контекстах и могут быть использованы в качестве обычных идентификаторов в других контекстах:</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">Ниже приведен пример интерфейса JDK, реализованного классом &lt;code&gt;StringBuilder&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">Следующий этап трубопровода отфильтровывает входящий поток чисел,удаляя все числа,кратные заданному основному номеру:</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">Следующие поля podspec требуются для CocoaPods:</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">В следующих разделах более подробно объясняются уже упомянутые понятия.</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">Следующие маркеры выступают в качестве ключевых слов в списках модификаторов деклараций и могут использоваться в качестве идентификаторов в других контекстах:</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">Следующие маркеры выступают в качестве ключевых слов в контексте,когда они применимы,и могут использоваться в качестве идентификаторов в других контекстах:</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">Следующие лексемы всегда интерпретируются как ключевые слова и не могут быть использованы в качестве идентификаторов:</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">При взаимодействии с родной библиотекой ожидается следующий рабочий процесс.</target>
        </trans-unit>
        <trans-unit id="41bde8cb095fdaa39e87c44d34bec8992402e368" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7dbd577dd676bd08f82b2f5d51d9ac8e4bfc959" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c24376936f310cfc6a2b02ee789c1ab9c4a079c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ac86b4bcb26b195d587cd10aa019f5e68922bb" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03b953ac3fd08a46517db9b02880729ef0942e5" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f1f7669eb111859c7b969d69798041d2a9b37e" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43741e55696c4613d380e3f315ef0bfbfc2d96be" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd2c9a0fe0f333063fc214dadef0239e9bff9de" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение типа &lt;code&gt;Double&lt;/code&gt; - &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE,&lt;/a&gt; если оно меньше &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение типа &lt;code&gt;Double&lt;/code&gt; - &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE,&lt;/a&gt; если оно меньше &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если значение &lt;code&gt;Double&lt;/code&gt; отрицательное, или &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если значение &lt;code&gt;Double&lt;/code&gt; отрицательное, или &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение типа &lt;code&gt;Float&lt;/code&gt; - &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE,&lt;/a&gt; если оно меньше &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение типа &lt;code&gt;Float&lt;/code&gt; - &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE,&lt;/a&gt; если оно меньше &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение типа &lt;code&gt;Float&lt;/code&gt; отрицательное, или &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">Дробная часть, если есть, округляется в меньшую сторону. Возвращает ноль, если это значение &lt;code&gt;Float&lt;/code&gt; отрицательное, или &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE,&lt;/a&gt; если оно больше &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">Фреймворк, который мы скомпилировал с помощью Kotlin / Native, имеет вспомогательные атрибуты, упрощающие использование со Swift. Давайте преобразуем предыдущий пример Objective-C в Swift. В результате в &lt;code&gt;main.swift&lt;/code&gt; получится следующий код :</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">Полный сценарий сборки для примера проекта можно найти &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;здесь&lt;/a&gt; . Вы также можете посмотреть преобразованный код для &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;образца Android&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">Полный список аргументов, которые можно использовать, отображается при запуске &lt;code&gt;kotlinc -help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">Полный список поддерживаемых целей использования сайта:</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">Полная синтаксическая форма лямбда-выражений выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">Полный синтаксис для декларирования собственности следующий</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">Полный синтаксис объявления свойства, доступного только для чтения, отличается от изменяемого двумя способами: он начинается с &lt;code&gt;val&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt; и не допускает установщика:</target>
        </trans-unit>
        <trans-unit id="776f7d695f882be224aebfaccabd52b1c0591bc5" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or a class of an anonymous object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">Полное имя класса, разделенное точками, или значение &lt;code&gt;null&lt;/code&gt; , если класс локальный или является анонимным литералом объекта.</target>
        </trans-unit>
        <trans-unit id="f6c5b38e497b6843a07b1a8945d528e3c7606264" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7696926a08823163fe79a297a106aabaf3f3d399" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3c35965fc33462a41df8d6c5d69d9f13434071" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfbb507b912e298abe7a785c884c806da178f93" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804f600305f25777086b4066f40ae2670855676b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c90b068891a2e0a90f241b535756a6f3e22982" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">Функция &lt;code&gt;libnative_symbols&lt;/code&gt; позволяет нам открыть путь от нативного кода к библиотеке Kotlin / Native. Это точка входа, которую мы используем. Имя библиотеки используется как префикс для имени функции.</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">Тело функции ограничено фигурными скобками-отступ в Котлине,как правило,не значителен,но,конечно же,отступ должен быть сделан правильно на благо человека-читателя.</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">При необходимости функция выполняет обновление с блокировки чтения на блокировку записи, но это обновление не является атомарным, поскольку такое обновление не поддерживается &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt; . Чтобы выполнить такое обновление, эта функция сначала освобождает все блокировки чтения, удерживаемые этим потоком, затем устанавливает блокировку записи, а после освобождения снова получает блокировки чтения.</target>
        </trans-unit>
        <trans-unit id="41eab38f14ba2d1160f8a85b6cc897eb549e21ad" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c5bbd79a2512e469db0fde4da38bfd3abb594c" translate="yes" xml:space="preserve">
          <source>The function init is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">Сигнатура функции остается точно такой же. Единственная разница в том, что к нему добавляется &lt;code&gt;suspend&lt;/code&gt; . Однако возвращаемый тип - это тот тип, который мы хотим вернуть.</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">Обозначение типа функции может дополнительно включать имена для параметров функции: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; . Эти имена можно использовать для документирования значения параметров.</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">Функции включают тригонометрические,гиперболические,экспоненциальные и силовые,логарифмические,округленные,знаковые и абсолютные.</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Общее правило таково: когда параметр типа &lt;code&gt;T&lt;/code&gt; класса &lt;code&gt;C&lt;/code&gt; объявлен &lt;strong&gt;вне&lt;/strong&gt; , он может встречаться только &lt;strong&gt;вне&lt;/strong&gt; позиции в членах &lt;code&gt;C&lt;/code&gt; , но взамен &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; может безопасно быть супертипом &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">Общее правило:</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">Общее решение, которое работает как для потоков, так и для сопрограмм, заключается в использовании потоковобезопасной (также известной как синхронизированная, линеаризуемая или атомарная) структура данных, которая обеспечивает всю необходимую синхронизацию для соответствующих операций, которые должны выполняться в общем состоянии. В случае простого счетчика мы можем использовать класс &lt;code&gt;AtomicInteger&lt;/code&gt; , который имеет атомарные операции &lt;code&gt;incrementAndGet&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e700b89372f9cc694759aa68e2252618aa967c7" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessary synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">Сгенерированный конструктор является синтетическим, поэтому его нельзя напрямую вызвать из Java или Kotlin, но его можно вызвать с помощью отражения.</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">Получатель этого имущества,используемого для получения стоимости имущества.</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">Эти шарики применяются к путям заголовка по отношению к соответствующему включать в себя элементы пути, например &lt;code&gt;time.h&lt;/code&gt; или &lt;code&gt;curl/curl.h&lt;/code&gt; . Поэтому, если библиотека обычно включается в &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; , то, вероятно, будет правильным фильтровать заголовки с помощью</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">Цель руководства - продемонстрировать повторное использование кода Kotlin между Android и iOS. Начнем с ручного создания &lt;code&gt;SharedCode&lt;/code&gt; в нашем проекте Gradle. Исходный код из проекта &lt;code&gt;SharedCode&lt;/code&gt; будет доступен между платформами. Для этого мы создадим в нашем проекте несколько новых файлов.</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">Заголовочные файлы просто содержат объявления функций для функциональности, которая определяется во время выполнения. Например, мы могли бы определить функцию &lt;code&gt;jQuery&lt;/code&gt; так:</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">Тренажер IOS требует рамок скомпилированных для &lt;code&gt;ios_x64&lt;/code&gt; цели, &lt;code&gt;iOS_sim&lt;/code&gt; папки в нашем случае.</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Идея Rx состоит в том, чтобы перейти к так называемым &lt;code&gt;observable streams&lt;/code&gt; где мы теперь думаем о данных как о потоках (бесконечные объемы данных), и эти потоки можно наблюдать. На практике Rx - это просто &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;шаблон наблюдателя&lt;/a&gt; с рядом расширений, которые позволяют нам работать с данными.</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">Идея фьючерсов или обещаний (есть и другие термины,на которые можно ссылаться в зависимости от языка/платформы)заключается в том,что когда мы делаем звонок,нам обещают,что в какой-то момент он вернется с объектом под названием Обещание,с которым потом можно будет работать.</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">Идея состоит в том, чтобы на каждой платформе отображался похожий текст: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; и &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; , в зависимости от платформы. Мы будем повторно использовать способ создания сообщения. Давайте создадим файл (и отсутствующие каталоги) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; со следующим содержимым в корневом каталоге проекта</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">Реализация интерфейса &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; , поддерживаемая экземпляром &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">Разработчик должен реализовать свойство &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;записей&lt;/a&gt; , которое должно возвращать доступный только для чтения набор записей карты.</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">Разработчик должен реализовать свойство &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;записей&lt;/a&gt; , которое должно возвращать изменяемый набор записей карты и &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;помещать&lt;/a&gt; функцию.</target>
        </trans-unit>
        <trans-unit id="4c2bcd3066d4911e1651a3eb4e73833cb38dc376" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">Разработчик должен реализовать свойство &lt;a href=&quot;entries&quot;&gt;записей&lt;/a&gt; , которое должно возвращать изменяемый набор записей карты и &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;помещать&lt;/a&gt; функцию.</target>
        </trans-unit>
        <trans-unit id="de6f180abcaad3c2e2c4cd19c5f847e641f85c21" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">Функции сортировки на месте имеют имена, похожие на имена функций, которые применяются к спискам только для чтения, но без суффикса &lt;code&gt;ed/d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">Отступ перед аксессуарами объясняется условностью;как и в других местах Котлина,он не имеет синтаксического значения.Компилятор может определить,какие аксессуары к каким свойствам принадлежат,потому что единственное легальное место аксессуара находится сразу после объявления свойства (а может быть и не более одного геттера и одного сеттера)-так что вы не сможете разделить объявление свойства и объявления аксессуара.Однако,порядок аксессуаров не имеет значения.</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">Наследники используются в &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; для описания контракта функции.</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">Инициализатор,геттер и сеттер являются необязательными.Тип свойства является необязательным,если его можно вывести из инициализатора (или из типа возврата геттера,как показано ниже).</target>
        </trans-unit>
        <trans-unit id="df4b9318a341c1f296940189b67832418073c297" translate="yes" xml:space="preserve">
          <source>The inserted characters go in same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; character array, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6b868449af039ece3f79e19a7f1bdef4bb1a01" translate="yes" xml:space="preserve">
          <source>The inserted characters go in the same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; character sequence, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">Порядок вставки сохраняется за счет ведения двусвязного списка всех его записей.</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">Экземпляр объявления объекта или &lt;code&gt;null&lt;/code&gt; , если этот класс не является объявлением объекта.</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">Инструмент интероперабельности анализирует заголовки C и производит &quot;естественное&quot; картирование типов,функций и констант в Котлинском мире.Сгенерированные шлейфы могут быть импортированы в IDE для завершения кода и навигации.</target>
        </trans-unit>
        <trans-unit id="78163206f8e53ce50e1eec86f00b2814cc4b80d9" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. However, annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. If the annotation processors used in the build cannot be properly cached, it is possible to disable caching for kapt entirely by adding the following lines to the build script, in order to avoid false-positive cache hits for the kapt tasks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">По умолчанию задачи обработки аннотаций kapt не &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;кэшируются в Gradle&lt;/a&gt; . Процессоры аннотаций запускают произвольный код, который не обязательно может преобразовывать входные данные задачи в выходы, может получать доступ и изменять файлы, которые не отслеживаются Gradle и т. Д. Чтобы в любом случае включить кеширование для kapt, добавьте следующие строки в сценарий сборки:</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">Ключевое преимущество использования запечатанных классов проявляется, когда вы используете их в &lt;a href=&quot;control-flow#when-expression&quot;&gt;выражении &lt;/a&gt; &lt;code&gt;when&lt;/code&gt; . Если можно убедиться, что оператор охватывает все случаи, вам не нужно добавлять в него предложение &lt;code&gt;else&lt;/code&gt; . Однако это работает, только если вы используете &lt;code&gt;when&lt;/code&gt; как выражение (используя результат), а не как оператор.</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">Ключевые отличия от старой модели:</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">Ключ для каждого элемента предоставляется функцией &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Ключевой новой функцией Kotlin 1.1 являются &lt;em&gt;сопрограммы&lt;/em&gt; , обеспечивающие поддержку &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;yield&lt;/code&gt; и подобных шаблонов программирования. Ключевой особенностью дизайна Kotlin является то, что реализация выполнения сопрограмм является частью библиотек, а не языка, поэтому вы не привязаны к какой-либо конкретной парадигме программирования или библиотеке параллелизма.</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">Ключ , который определяет &lt;em&gt;в&lt;/em&gt; контексте перехватчик.</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ключ к пониманию того, почему этот трюк работает, довольно прост: если вы можете &lt;strong&gt;брать&lt;/strong&gt; только элементы из коллекции, то использование коллекции &lt;code&gt;String&lt;/code&gt; и чтение из нее &lt;code&gt;Object&lt;/code&gt; s - это нормально. И наоборот, если вы можете &lt;em&gt;помещать&lt;/em&gt; только элементы в коллекцию, можно взять коллекцию &lt;code&gt;Object&lt;/code&gt; и поместить в нее &lt;code&gt;String&lt;/code&gt; : в Java у нас есть &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; &lt;strong&gt;супертипом&lt;/strong&gt; из &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72d25f147746520f953f90cd2e72b99d7c03c99" translate="yes" xml:space="preserve">
          <source>The kind of JS module generated by the compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Языковые настройки проверяются на соответствие между исходными наборами в зависимости друг от друга. А именно, если &lt;code&gt;foo&lt;/code&gt; зависит от &lt;code&gt;bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">Языковые настройки для исходного набора можно задать следующим образом:</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">Язык, используемый для документирования кода Kotlin (эквивалент JavaDoc в Java), называется &lt;strong&gt;KDoc&lt;/strong&gt; . По сути, KDoc объединяет синтаксис JavaDoc для блочных тегов (расширенный для поддержки специфических конструкций Kotlin) и Markdown для встроенной разметки.</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">Последний элемент в прогрессии.</target>
        </trans-unit>
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">Последний элемент прогрессии вычисляется для нахождения максимального значения, не превышающего конечное значение для положительного шага, или минимального значения, не меньшего, чем конечное значение для отрицательного шага, так что &lt;code&gt;(last - first) % step == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">Последняя строка вызывает саму функцию и передает в качестве аргумента &lt;code&gt;kotlin&lt;/code&gt; , который относится к стандартной библиотеке. Его можно получить одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Последний список в результирующем списке может иметь меньше элементов, чем заданный &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4c16017113383cfa2553bc4b666ff8af31f35a" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Последний список в результирующей последовательности может иметь меньше элементов, чем заданный &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4ef2ba5891ebf7ffa1b88944ac0282efb5fecf2" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Последняя строка в итоговом списке может содержать меньше символов, чем заданный &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01c80e09f206886b89d00be2fa9ab43305c32874" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Последняя строка в результирующей последовательности может содержать меньше символов, чем заданный &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ebb5e898a1a9ea0d92ef57e7df9d364782eae89" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">LastIndex-это целочисленное свойство регулярных выражений для чтения/записи,которое определяет индекс,с которого будет начинаться следующее совпадение.</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">Последнее называется &lt;strong&gt;контравариантностью&lt;/strong&gt; , и вы можете вызывать только методы, которые принимают String в качестве аргумента в &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (например, вы можете вызвать &lt;code&gt;add(String)&lt;/code&gt; или &lt;code&gt;set(int, String)&lt;/code&gt; ), а если вы вызываете что-то, что возвращает &lt;code&gt;T&lt;/code&gt; в &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; , вы получаете не &lt;code&gt;String&lt;/code&gt; , а &lt;code&gt;Object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Планировка многоплатформенного проекта Котлин построена из следующих строительных блоков:</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">16 младших разрядов результирующего значения &lt;code&gt;Int&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Short&lt;/code&gt; , тогда как 16 старших разрядов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">16 младших разрядов результирующего значения &lt;code&gt;Int&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UShort&lt;/code&gt; , тогда как 16 старших разрядов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">16 младших разрядов результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Short&lt;/code&gt; , тогда как 48 старших разрядов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">&lt;code&gt;UShort&lt;/code&gt; 16 битов результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого значения UShort , тогда как старшие 48 битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">16 младших разрядов результирующего значения &lt;code&gt;UInt&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Short&lt;/code&gt; , тогда как 16 старших разрядов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">16 младших разрядов результирующего значения &lt;code&gt;UInt&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UShort&lt;/code&gt; , тогда как 16 старших разрядов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">16 младших значащих битов результирующего значения &lt;code&gt;ULong&lt;/code&gt; совпадают с битами этого &lt;code&gt;Short&lt;/code&gt; значения, тогда как старшие 48 битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">16 младших битов результирующего значения &lt;code&gt;ULong&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UShort&lt;/code&gt; , тогда как старшие 48 битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">Наименее значащие 32 бита результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Int&lt;/code&gt; , тогда как 32 старших разряда заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">Наименее значащие 32 бита результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UInt&lt;/code&gt; , тогда как 32 старших бита заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">Самые младшие 32 бита результирующего значения &lt;code&gt;ULong&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Int&lt;/code&gt; , тогда как самые старшие 32 бита заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">&lt;code&gt;ULong&lt;/code&gt; 32 бита результирующего значения ULong совпадают с битами этого значения &lt;code&gt;UInt&lt;/code&gt; , тогда как 32 старших разряда заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">Младшие 8 битов результирующего кода &lt;code&gt;Char&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Byte&lt;/code&gt; , тогда как 8 старших битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;Int&lt;/code&gt; совпадают с битами этого &lt;code&gt;Byte&lt;/code&gt; значения, тогда как самые старшие 24 бита заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;Int&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как самые старшие 24 бита заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого &lt;code&gt;Byte&lt;/code&gt; значения, тогда как самые старшие 56 битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">8 младших битов результирующего значения &lt;code&gt;Long&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как старшие 56 битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;Short&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;Byte&lt;/code&gt; , тогда как 8 старших битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;Short&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как 8 старших битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;UInt&lt;/code&gt; совпадают с битами этого &lt;code&gt;Byte&lt;/code&gt; значения, тогда как самые старшие 24 бита заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">&lt;code&gt;UInt&lt;/code&gt; 8 битов результирующего значения UInt совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как самые старшие 24 бита заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;ULong&lt;/code&gt; совпадают с битами этого &lt;code&gt;Byte&lt;/code&gt; значения, тогда как самые старшие 56 битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;ULong&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как старшие 56 битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;UShort&lt;/code&gt; совпадают с битами этого &lt;code&gt;Byte&lt;/code&gt; значения, тогда как старшие 8 битов заполнены битом знака этого значения.</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">8 младших значащих битов результирующего значения &lt;code&gt;UShort&lt;/code&gt; совпадают с битами этого значения &lt;code&gt;UByte&lt;/code&gt; , тогда как самые старшие 8 битов заполнены нулями.</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">К менее очевидным случаям,относящимся к &quot;серой области&quot;,относятся обработка угловых случаев по-другому,бросание исключения иного типа,чем раньше,изменение поведения,наблюдаемое только через отражение,изменения в недокументированном/неопределенном поведении,переименование бинарных артефактов и т.д.Иногда такие изменения очень важны и сильно влияют на опыт миграции,иногда они незначительны.</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">Библиотечный формат</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">Библиотека создана в текущем каталоге:</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">Возвращаемые строки не содержат разделителей прерывающих линий.</target>
        </trans-unit>
        <trans-unit id="0ec3834f8762f850d976d74a3444d0d24d17d417" translate="yes" xml:space="preserve">
          <source>The list is expected to be sorted so that the signs of the &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; function's return values ascend on the list elements, i.e. negative values come before zero and zeroes come before positive values. Otherwise, the result is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">Список ближайших супертипов данного класса,в порядке их перечисления в исходном коде.</target>
        </trans-unit>
        <trans-unit id="37daaa29c5ab04c74e60f96a3c80a72671943c78" translate="yes" xml:space="preserve">
          <source>The list of possible time measurement units, in which a duration can be expressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">Список ближайших подклассов,если этот класс является опечатанным,или пустой список в противном случае.</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">Список типовых параметров этого вызываемого абонента.</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">Список параметров типа этого класса. Этот список &lt;em&gt;не&lt;/em&gt; включает параметры типа внешних классов.</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">Блокировка в этом примере мелкозернистая,поэтому она платит цену.Тем не менее,это хороший выбор для некоторых ситуаций,когда необходимо периодически изменять некоторое общее состояние,но нет естественной нити,ограничивающей это состояние.</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">Переменная цикла (ов), если таковые имеются, должны быть объявлены за пределами в &lt;code&gt;while&lt;/code&gt; цикла, и, следовательно , доступны для проверки впоследствии, после чего они будут содержать значение (ы) , который сделал условие цикла FALSE.</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">Основной код прост:</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">Основной код запускает и соединяет весь трубопровод:</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">Основным недостатком изменения стиля кода в существующем проекте является то, что функция VCS обвинения / аннотирования будет чаще указывать на нерелевантные коммиты. Хотя у каждой VCS есть какой-то способ справиться с этой проблемой ( в IntelliJ IDEA можно использовать &lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&amp;laquo;Аннотировать предыдущую версию&amp;raquo;&lt;/a&gt; ), важно решить, стоит ли новый стиль всех усилий. Практика отделения коммитов переформатирования от значимых изменений может очень помочь в дальнейших исследованиях.</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">Основная функция просто запускает сопрограмму для печати результатов &lt;code&gt;switchMapDeferreds&lt;/code&gt; и отправляет ей некоторые тестовые данные:</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">Основной поток (который запускает функцию &lt;code&gt;main()&lt;/code&gt; ) должен дождаться завершения нашей сопрограммы, в противном случае программа завершится до того, как будет напечатано &lt;code&gt;Hello&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">Максимальное количество возвращаемых подстроек.Ноль по умолчанию означает отсутствие ограничений.</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">Максимальный радиус,доступный для преобразования в струны и от них.</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">Максимальное значение в диапазоне (включительно).</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Максимальное значение точки кода Юникода.Котлин/Отрицательный специфический.</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Максимальное значение единицы высокоуровневого кода Unicode.</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Максимальное значение единицы низкоуровневого кода Unicode.</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">Максимальное значение единицы суррогатного кода Юникода.</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">Максимальное значение единицы символьного кода.</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">Значение модификатора видимости зависит от того,применяется ли он к декларации верхнего уровня или к декларации внутри класса.Для деклараций верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">Сообщение,объясняющее удаление и рекомендующее использовать альтернативный API.</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">Мета-раннер для Kotlin доступен на &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt; . Если вы используете TeamCity 9 или выше, теперь мы можем просто импортировать этот мета-бегун из пользовательского интерфейса TeamCity.</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">Минимальный радиус,доступный для преобразования в струны и от них.</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">Минимальное значение в диапазоне.</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">Минимальное значение точки кода Юникода.Котлин/Отрицательное специфическое.</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">Минимальное значение единицы высокоуровневого кода Unicode.</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">Минимальное значение единицы низкоуровневого кода Юникода.</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">Минимальное значение единицы суррогатного кода Юникода.</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">Минимальное значение единицы символьного кода.</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">Минимальное значение дополнительной кодовой точки &lt;code&gt;\u0x10000&lt;/code&gt; . Котлин / Родной специфический.</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">Модификатор можно использовать для свойств &lt;code&gt;var&lt;/code&gt; , объявленных внутри тела класса (не в основном конструкторе, и только когда свойство не имеет настраиваемого метода получения или установки) и, начиная с Kotlin 1.2, для свойств верхнего уровня и локальных переменных. , Тип свойства или переменной не должен быть нулевым и не должен быть примитивным типом.</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">Наиболее &amp;laquo;естественное&amp;raquo; размещение - в объекте &lt;code&gt;nativeHeap&lt;/code&gt; . Он соответствует выделению собственной памяти с помощью &lt;code&gt;malloc&lt;/code&gt; и предоставляет дополнительную &lt;code&gt;.free()&lt;/code&gt; для освобождения выделенной памяти:</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">Самая основная функция отражения - получение ссылки среды выполнения на класс Kotlin. Чтобы получить ссылку на статически известный класс Kotlin, вы можете использовать синтаксис &lt;em&gt;литерала класса&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">Самым простым использованием enum-классов является реализация безопасных для типов перечислений:</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">Наиболее распространенный вид свойств просто читает из (и,возможно,записывает в)поле подложки.С другой стороны,с помощью пользовательских геттеров и сеттеров можно реализовать любое поведение свойства.Где-то между ними существуют определённые общие закономерности того,как может работать свойство.Несколько примеров:ленивые значения,чтение с карты по заданному ключу,доступ к базе данных,уведомление слушателя о доступе и т.д.</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">Наиболее распространенный тип ограничения - это &lt;strong&gt;верхняя граница&lt;/strong&gt; , соответствующая ключевому слову Java &lt;em&gt;extends&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">Наиболее распространенный способ создания коллекции - использование стандартных библиотечных функций &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; . Если вы предоставляете в качестве аргументов список элементов коллекции, разделенных запятыми, компилятор автоматически определяет тип элемента. При создании пустых коллекций явно указывайте тип.</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">Наиболее заметным изменением является продолжение политики отступов.Приятно использовать двойной отступ,чтобы показать,что многострочное выражение не закончилось на предыдущей строке.Это очень простое и общее правило,но некоторые конструкции Котлина выглядят немного неудобно,когда они форматируются таким образом.В Котлинских конвенциях кодирования рекомендуется использовать один отступ в тех случаях,когда отступ длинной последовательности был вынужден до</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">Наиболее очевидная практическая причина для отмены выполнения сопрограммы заключается в том, что время ее выполнения превысило некоторый тайм-аут. В то время как вы можете вручную отслеживать ссылки на соответствующую &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Работу&lt;/a&gt; и запустить отдельную сопрограмму отменить отслеживаемые один за задержками, есть готовый использовать &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; функцию , которая делает это. Взгляните на следующий пример:</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">Наиболее особенностью &lt;code&gt;dynamic&lt;/code&gt; является то , что мы имеем право называть &lt;strong&gt;любое&lt;/strong&gt; свойство или функцию с любыми параметрами на &lt;code&gt;dynamic&lt;/code&gt; переменной:</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">В &lt;a href=&quot;../../reference/multiplatform&quot;&gt;документации&lt;/a&gt; также обсуждаются мультиплатформенные проекты и мультиплатформенные библиотеки .</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">Название содержит следующие части (некоторые из них могут быть пустыми):</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">Имя класса обычно существительное или именной объяснить , что класс &lt;em&gt;является&lt;/em&gt; : &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;PersonReader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">Имя класса,используемое само по себе (а не как классификатор к другому имени),действует как ссылка на сопутствующий объект класса (независимо от того,назван он или нет):</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">Имя метода обычно представляет собой глагол или глагольную фразу, говорящую о том, что &lt;em&gt;делает&lt;/em&gt; метод : &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;readPersons&lt;/code&gt; . Название также должно указывать на то, изменяет ли метод объект или возвращает новый. Например, &lt;code&gt;sort&lt;/code&gt; сортирует коллекцию на месте, а &lt;code&gt;sorted&lt;/code&gt; возвращает отсортированную копию коллекции.</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">Имя сопутствующего объекта можно не указывать, в этом случае будет использовано имя &lt;code&gt;Companion&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">Название файла должно описывать,что делает код в файле.Поэтому в названиях файлов следует избегать использования бессмысленных слов,таких как &quot;Util&quot;.</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">Имя сгенерированного класса Java можно изменить с &lt;code&gt;@JvmName&lt;/code&gt; аннотации @JvmName :</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">Название цели (если указано)или проекта</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">Имя этого вызываемого абонента,как оно было объявлено в исходном коде.Если у вызываемого абонента нет имени,создается специальное вымышленное имя.Безымянные вызовы включают в себя:</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">Имя такого типового параметра,как оно было объявлено в исходном коде.</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Имена классов и интерфейсов Kotlin префиксуются при импорте в Objective-C.Префикс получается из названия фреймворка.</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Имена задач в Android Projects содержат имена &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;вариантов сборки&lt;/a&gt; и следуют шаблону &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; , например, &lt;code&gt;compileDebugKotlin&lt;/code&gt; , &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">Имена этих задач были созданы по формуле: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; , где &lt;code&gt;target name&lt;/code&gt; - это целевое имя с &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; которое мы указали в файле build.gradle.kts build.gradle вне нашей сборки, &lt;code&gt;&quot;native&quot;&lt;/code&gt; в нашем случае. Запустим задачу в IDE. Для этого откройте окно Gradle Tool Window и найдите задачу в списке:</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">Имена должны давать понять, какова цель сущности, поэтому лучше избегать использования в именах бессмысленных слов ( &lt;code&gt;Manager&lt;/code&gt; , &lt;code&gt;Wrapper&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">Собственная память может быть выделена с &lt;code&gt;NativePlacement&lt;/code&gt; интерфейса NativePlacement , например</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">Следующие строки посвящены предоставлению параметров компоновщика и компилятора, которые могут различаться в зависимости от разных целевых платформ. В нашем случае мы определяем его для macOS ( суффикс &lt;code&gt;.osx&lt;/code&gt; ) и Linux ( суффикс &lt;code&gt;.linux&lt;/code&gt; ). Также возможны параметры без суффикса (например, &lt;code&gt;linkerOpts=&lt;/code&gt; ) и будут применяться ко всем платформам.</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">Следующая часть &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; содержит сопоставления числовых типов между Kotlin / Native и &lt;code&gt;NSNumber&lt;/code&gt; . У нас есть базовый класс &lt;code&gt;DemoNumber&lt;/code&gt; в Objective-C и &lt;code&gt;KotlinNumber&lt;/code&gt; в Swift. Он расширяет &lt;code&gt;NSNumber&lt;/code&gt; . Также существуют дочерние классы для каждого типа числа Котлина:</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">Следующая часть файла &lt;code&gt;libnative_api.h&lt;/code&gt; содержит определения типов, которые используются в библиотеке:</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">Следующим шагом будет запрос на библиотеку времени исполнения Kotlin.По умолчанию плагин выбирает ту,которая связана с текущей установленной версией.Если мы не хотим создать другую версию,мы можем на этом этапе нажать кнопку Finish (Завершить)после ввода имени проекта и его местоположения.</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">Следующим шагом является вызов указателя функции C из указателя C, который у нас есть от &lt;code&gt;supply_fun()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">Следующим шагом будет компиляция нашего приложения. Мы уже рассмотрели основы компиляции приложения Kotlin / Native из командной строки в учебнике по &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;базовому приложению Kotlin / Native&lt;/a&gt; . Единственная разница в этом случае заключается в том, что &lt;code&gt;cinterop&lt;/code&gt; сгенерированная cinterop , неявно включается в сборку: Давайте вызовем следующую команду:</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">Следующим шагом является создание класса данных приветствия, который имеет два свойства: &lt;em&gt;идентификатор&lt;/em&gt; и &lt;em&gt;контент.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">Следующим шагом является создание Run Configuration в IntelliJ IDEA в разделе Tomcat/Local,который развертывает WAR и запускает Tomcat.</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">Следующий шаг-это решить,какие модули нужно сконфигурировать (если в проекте более одного модуля)и хотите ли вы добавить в проект библиотеку времени исполнения или использовать те,которые предоставляются текущим плагином Kotlin.</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">Неабстрактные подклассы должны представлять (полный) тип данных C и, таким образом, определять размер и выравнивание. Каждый такой подкласс должен иметь сопутствующий объект, который является &lt;a href=&quot;-type/index&quot;&gt;Типом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">Неразрывной характер пространства</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">Версия с нулевым значением &lt;code&gt;Nothing?&lt;/code&gt; будет использоваться компилятором, когда что-то инициализируется нулевым значением и нет другой информации о типе. В &lt;code&gt;val x = null&lt;/code&gt; тип &lt;code&gt;x&lt;/code&gt; будет &lt;code&gt;Nothing?&lt;/code&gt; , Этот тип не имеет семантики &amp;laquo;обычно никогда не возвращает&amp;raquo;; вместо этого компилятор знает, что значение всегда будет нулевым.</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">Число преобразуется в строку, а затем строка преобразуется в &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbb7b619e5deab250c82714dad5c6223da422d99" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления Char в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра Байта в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="fc5f8fcea457f48ba61aea0a6c6364e750d35bba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Double in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac96a9235bc1077029c5934186d743a5b00c197" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Float in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра Int в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра Long в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра Short в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра UByte в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра UInt в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра ULong в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">Количество битов,используемых для представления экземпляра UShort в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления Char в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра байта в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="cfb84d55b9d6ee08abf33db55d2a61462dded701" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Double in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080e5eee27bb967010b8c2b300a0c20e8300d7a1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Float in a binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра Int в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра Long в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра Short в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра UByte в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра UInt в двоичном виде.</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра ULong в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">Количество байт,используемых для представления экземпляра UShort в двоичной форме.</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">В официальных документах также есть очень интересный пример с &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;DSL для создания HTML-документов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">Единственная цель, для которой он недоступен, - это &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">Осталось только скомпилировать наше приложение (Build | Build Project), и после того, как файлы JavaScript будут сгенерированы, мы можем открыть файл &lt;code&gt;index.html&lt;/code&gt; в браузере и увидеть результат в окне отладки консоли.</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">Операция не сохраняет атрибуты скопированного файла,такие как дата создания/изменения,права доступа и т.д.</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">Операция &lt;em&gt;промежуточная&lt;/em&gt; и с &lt;em&gt;сохранением состояния&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">Операция &lt;em&gt;промежуточная&lt;/em&gt; и не имеет &lt;em&gt;состояния&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">Операция является &lt;em&gt;промежуточной&lt;/em&gt; для этой последовательности и &lt;em&gt;конечной&lt;/em&gt; и &lt;em&gt;отслеживающей состояние&lt;/em&gt; для последовательности &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;элементов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="790886232e90f42fd32ca4859b4baabd53b9cbd8" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">Операция &lt;em&gt;терминальная&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">Обсуждаемые в этом разделе операции с числами с плавающей точкой-это операции с числами с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">Оператор &lt;code&gt;plus&lt;/code&gt; предоставляет способ добавить пары ключ-значение к карте только для чтения, создавая новую карту, однако не было простого способа сделать обратное: чтобы удалить ключ с карты, вы должны прибегнуть к менее простые способы понравиться &lt;code&gt;Map.filter()&lt;/code&gt; или &lt;code&gt;Map.filterKeys()&lt;/code&gt; . Теперь оператор &lt;code&gt;minus&lt;/code&gt; восполняет этот пробел. Доступны 4 перегрузки: для удаления одного ключа, набора ключей, последовательности ключей и массива ключей.</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">Порядок элементов является важным аспектом определенных типов коллекций.Например,два списка одних и тех же элементов не одинаковы,если их элементы расположены в разном порядке.</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">Также различается порядок выполнения операций: &lt;code&gt;Sequence&lt;/code&gt; выполняет все этапы обработки один за другим для каждого отдельного элемента. В свою очередь, &lt;code&gt;Iterable&lt;/code&gt; завершает каждый шаг для всей коллекции, а затем переходит к следующему шагу.</target>
        </trans-unit>
        <trans-unit id="812e3a1f04f0d82a55115416fefd4d8f871219e6" translate="yes" xml:space="preserve">
          <source>The original exception is handled by the parent only when all its children terminate, which is demonstrated by the following example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">Результат, который он производит с &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM -Dkotlinx.coroutines.debug , похож на:</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">Выходные данные сценария конфигурации с &lt;code&gt;--libs&lt;/code&gt; будут переданы как &lt;code&gt;kotlinc&lt;/code&gt; флага &lt;code&gt;-linkedArgs&lt;/code&gt; kotlinc ( заключенное в кавычки) при компиляции.</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">Вывод этого кода (с &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;отладкой&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">Вывод этого кода:</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">Вывод этого кода показывает, что функции &lt;code&gt;filter()&lt;/code&gt; и &lt;code&gt;map()&lt;/code&gt; вызываются только при построении списка результатов. Итак, вы сначала видите строку текста &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; а затем начинается обработка последовательности. Обратите внимание, что для элементов, оставшихся после фильтрации, карта выполняется до фильтрации следующего элемента. Когда размер результата достигает 4, обработка останавливается, потому что это максимально возможный размер, который может вернуть &lt;code&gt;take(4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">Вывод этого кода с &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM -Dkotlinx.coroutines.debug :</target>
        </trans-unit>
        <trans-unit id="ef205ce911c3cb52ce12493307210d6d78d5dcb8" translate="yes" xml:space="preserve">
          <source>The output of this code with the &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">Вывод этого примера:</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">Результатом этого является пустая страница, на которой печатается &lt;code&gt;Hello JavaScript!&lt;/code&gt; к консоли.</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">Выход должен быть:</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">Вывод будет аналогичен следующему,хотя идентификаторы процессоров,которые получают каждое конкретное целое число,могут отличаться:</target>
        </trans-unit>
        <trans-unit id="dacb06aada01cf9353bf2a419b476781dd3c13a9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa46c20aa677e08c4fbabd2c01f13037e7e1a67" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d95d1d469be2176ebbc72a21468acef591255ad" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76acc76cfe7700de42074cf269fd6d05489f7e96" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">Переопределяющий конструктор должен иметь те же имена и типы параметров,что и переопределяемый.</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">Пакеты из библиотек платформы доступны по умолчанию. Для их использования не нужно указывать специальные флаги ссылок. Компилятор &lt;code&gt;Kotlin/Native&lt;/code&gt; автоматически определяет, к каким библиотекам платформы был осуществлен доступ, и автоматически связывает необходимые библиотеки.</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">Параметр объявляется в членской функции,а один из соответствующих параметров в суперфункции является необязательным.</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">Параметр не должен &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;принимать переменное количество аргументов&lt;/a&gt; и не должен иметь &lt;a href=&quot;#default-arguments&quot;&gt;значения по умолчанию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">Параметр &lt;code&gt;@JsName&lt;/code&gt; должен быть константным строковым литералом, который является допустимым идентификатором. Компилятор сообщит об ошибке при любой попытке передать строку, не &lt;code&gt;@JsName&lt;/code&gt; идентификатором, в @JsName . В следующем примере возникает ошибка времени компиляции:</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">Параметр &lt;code&gt;js&lt;/code&gt; должен быть строковой константой. Итак, следующий код неверен:</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Тип параметра для параметра с функциональным типом (пользователь передает функцию, которая может обрабатывать любой &lt;code&gt;Fruit&lt;/code&gt; , и ей будет присвоено &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">Параметры и тип возврата задаются так же,как и для обычных функций,за исключением того,что типы параметров могут быть опущены,если их можно вывести из контекста:</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">Параметры &lt;code&gt;provideDelegate&lt;/code&gt; такие же, как и у &lt;code&gt;getValue&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">Переданный тип должен одновременно удовлетворять всем условиям предложения &lt;code&gt;where&lt;/code&gt; . В приведенном выше примере, то &lt;code&gt;T&lt;/code&gt; типа должен реализовать &lt;em&gt;как &lt;/em&gt; &lt;code&gt;CharSequence&lt;/code&gt; и &lt;code&gt;Comparable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">Путь указывает на место вывода по умолчанию,которое IntelliJ IDEA использует при компиляции приложения.Ниже мы посмотрим,как это изменить.</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">Строка шаблона этого регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">Паттерн, в котором сопрограмма создает последовательность элементов, довольно распространен. Это часть паттерна &lt;em&gt;производитель-потребитель&lt;/em&gt; , который часто встречается в параллельном коде. Вы можете абстрагировать такого производителя в функцию, которая принимает канал в качестве параметра, но это противоречит здравому смыслу, согласно которому результаты должны возвращаться из функций.</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">Заполнитель &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; следует заменить на одно из имен плагинов, которые можно найти в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">Плагин позволяет вам настроить pom, сгенерированный для публикации, с блоком кода &lt;code&gt;pom&lt;/code&gt; , доступным для каждого компонента:</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">Плагин позволяет объявлять зависимости для файлов и других проектов, используя традиционный механизм конфигураций Gradle. Плагин поддерживает мультиплатформенные проекты Kotlin, позволяя объявлять зависимости от &lt;code&gt;expectedBy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">Плагин создает исполняемый файл теста для всех целей, указанных для &lt;code&gt;test&lt;/code&gt; компонента. Если текущая хост-платформа включена в этот список, также создаются задачи запуска теста. Чтобы запустить тесты, выполните стандартную задачу &lt;code&gt;check&lt;/code&gt; жизненного цикла :</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">Плагин создает компиляционную задачу для каждой комбинации цели,типа вывода и типа сборки.У задач есть следующее соглашение об именовании:</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">Плагин поставляется с настроенной версией плагина &lt;code&gt;kotlinx.serialization&lt;/code&gt; . Чтобы использовать его, вам не нужно добавлять новые зависимости buildscript, просто примените плагины и добавьте зависимость от библиотеки сериализации:</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">Формат опции плагина: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; . Варианты можно повторять.</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Плагин определяет следующие аннотации: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; &lt;/a&gt; . Благодаря поддержке мета-аннотаций классы, аннотированные с помощью &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt; открываются автоматически, поскольку эти аннотации &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; с помощью @Component .</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">Плагин использует ту же нотацию,что и компилятор.По умолчанию тестовый компонент использует те же цели,что и основной.</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">Сгенерированный podspec включает путь к выходной структуре и этапы сценария, которые автоматизируют построение этой структуры во время процесса сборки проекта Xcode. Некоторые поля файла podspec можно настроить с помощью блока кода &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">Указатель с непрозрачным шрифтом.</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Возможные значения &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; ограничены до &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2c8804ee232db23ae3d579f25ad98024549ce9" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">Предикаты в &lt;code&gt;filter()&lt;/code&gt; могут проверять только значения элементов. Если вы хотите использовать позиции элементов в фильтре, используйте &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; &lt;/a&gt; . Он принимает предикат с двумя аргументами: индекс и значение элемента.</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">Подготовленные исходники проекта можно скачать прямо с &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">Подготовленные исходники проекта можно скачать прямо с &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">Подготовленные исходники проекта можно скачать прямо с &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">Подготовленные исходники проекта можно скачать прямо с &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">Функции предварительной настройки возвращают существующую цель,если она есть.Это может быть использовано для настройки существующей цели:</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">Основной конструктор не может содержать никакого кода. Код инициализации может быть помещен в &lt;strong&gt;блоки инициализатора&lt;/strong&gt; , которые имеют префикс с ключевым словом &lt;em&gt;init&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">Первичный конструктор должен иметь хотя бы один параметр;</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">Принципы &quot;Сохранить язык современным&quot; и &quot;Удобные обновления&quot; предполагают,что иногда необходимы несовместимые изменения,но их следует внедрять с осторожностью.Нашей целью является заблаговременное информирование пользователей о предстоящих изменениях,чтобы они могли комфортно переносить свой код.</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">Проблема заключается в том, что в Котлин можно сказать &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; , но в Java , что было бы невозможно, так как в Java класс &lt;code&gt;Box&lt;/code&gt; является &lt;em&gt;инвариантом&lt;/em&gt; в параметре &lt;code&gt;T&lt;/code&gt; , и , таким образом , &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; не является подтипом в &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; . Чтобы заставить его работать на Java, нам нужно определить &lt;code&gt;unboxBase&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">Процесс сборки и запуска приложения Kotlin в Android Studio точно такой же,как и в Java.</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">Модель программирования и API остаются неизменными.Мы можем продолжать использовать циклы,обработку исключений и т.д.,и нет необходимости изучать полный набор новых API.</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">Последовательность начинается со значения &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; и идет к значению &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd,&lt;/a&gt; не исключая его, с указанным &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;шагом&lt;/a&gt; . Чтобы вернуться назад, &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;шаг&lt;/a&gt; должен быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="3cfecf27df2864c65a3a1ce3c515f4f228c95a52" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">Последовательность начинается со значения &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; и идет к значению &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd,&lt;/a&gt; не исключая его, с указанным &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;шагом&lt;/a&gt; . Чтобы вернуться назад, &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;шаг&lt;/a&gt; должен быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="2c4a6206c951ddbe8fde808b1243da3bfe938dbc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">Последовательность начинается со значения &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; и идет к значению &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd,&lt;/a&gt; не исключая его, с указанным &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;шагом&lt;/a&gt; . Чтобы вернуться назад, &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;шаг&lt;/a&gt; должен быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="d9d863d5adbc27747b9056e74161d14934d72f8c" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">Последовательность начинается со значения &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; и идет к значению &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd,&lt;/a&gt; не исключая его, с указанным &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;шагом&lt;/a&gt; . Чтобы вернуться назад, &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;шаг&lt;/a&gt; должен быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="890067d4bb4a41e1198a024fd7c7c538b8728df3" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">Последовательность начинается со значения &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; и идет к значению &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd,&lt;/a&gt; не исключая его, с указанным &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;шагом&lt;/a&gt; . Чтобы вернуться назад, &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;шаг&lt;/a&gt; должен быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="cfd566a721eacfbba5c78dd8988340e1f6d111e0" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">Файл проекта настраивает взаимодействие C как дополнительный шаг сборки. Давайте переместим файл &lt;code&gt;interop.def&lt;/code&gt; в каталог &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; . Gradle рекомендует использовать соглашения вместо конфигураций, например, исходные файлы должны находиться в папке &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; . По умолчанию все символы из C импортируются в пакет &lt;code&gt;interop&lt;/code&gt; , мы можем захотеть импортировать весь пакет в наши файлы &lt;code&gt;.kt&lt;/code&gt; . Ознакомьтесь с документацией плагина &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform,&lt;/a&gt; чтобы узнать обо всех различных способах его настройки.</target>
        </trans-unit>
        <trans-unit id="c7f7aa55f08a335c3d3db3f646f14c719c538320" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">Проект готов. Следующим шагом будет его открытие в IntelliJ IDEA. Для расширенных сценариев сборки рекомендуется обращаться к &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;более подробной&lt;/a&gt; документации.</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">Источники проекта</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">Структура проекта выглядит так:</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">Исходные файлы проекта остались без изменений.</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">Свойство,которое может быть использовано в качестве замещения для утверждений и значений,которые определены в JavaScript.</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">Недвижимость,откуда происходит этот аксессуар.</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">Положения политики развития &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin&lt;/a&gt; полностью применимы только к компонентам, достигшим полной стабильности (FS). С этого момента несовместимые изменения должны быть одобрены языковым комитетом.</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">Публикация этой цели обрабатывается подключаемым модулем Kotlin и не требует действий, характерных для подключаемого модуля Java, таких как создание публикации вручную и ее настройка &lt;code&gt;from(components.java)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">Назначение этого кода-выписать какой-то текст в консоли.Для того,чтобы использовать его из браузера,загрузите его,желательно изнутри HTML-страницы:</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Самый быстрый способ опробовать сопоставление C API - иметь все объявления C в файле &lt;code&gt;interop.def&lt;/code&gt; , вообще не создавая никаких файлов &lt;code&gt;.h&lt;/code&gt; или &lt;code&gt;.c&lt;/code&gt; . Затем поместите объявления C в файл &lt;code&gt;.def&lt;/code&gt; после специальной строки разделителя &lt;code&gt;---&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">Диапазон индексов во входной строке,где была захвачена группа.</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">Диапазон индексов в исходной строке,где было зафиксировано совпадение.</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">Типы коллекций только для чтения &lt;a href=&quot;generics#variance&quot;&gt;ковариантны&lt;/a&gt; . Это означает, что если класс &lt;code&gt;Rectangle&lt;/code&gt; наследуется от &lt;code&gt;Shape&lt;/code&gt; , вы можете использовать &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; везде, где требуется &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; . Другими словами, типы коллекций имеют такое же отношение подтипов, что и типы элементов. Карты ковариантны по типу значения, но не по типу ключа.</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">Причина, по которой мы видим фактический вывод, заключается в том, что вызов &lt;code&gt;curl_easy_perform&lt;/code&gt; выводит результат на стандартный вывод. Мы могли бы скрыть это с помощью &lt;code&gt;curl_easy_setopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4670c1839cea0120059e336f30de1dda186179ab" translate="yes" xml:space="preserve">
          <source>The recommended way to use Kotlin/JS is via the &lt;code&gt;kotlin.js&lt;/code&gt; and &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradle plugins. They provide a central and convenient way to set up and control Kotlin projects targeting JavaScript. This includes essential functionality such as controlling the bundling of your application, adding JavaScript dependencies directly from npm, and more. To get an overview of the available options, check out the &lt;a href=&quot;js-project-setup&quot;&gt;Kotlin/JS project setup&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">Ссылка - это значение типа &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">Указанное значение. Получает значение или задает новое значение. Если новое значение не равно нулю, и &lt;code&gt;this&lt;/code&gt; заморожено - это должен быть замороженный или постоянный объект.</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">Назначенное значение.Получает значение или устанавливает новое значение.Если новое значение не является нулевым,оно должно быть замороженным или постоянным объектом.</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">Репозитории, в которых будет опубликована библиотека, добавляются через блок &lt;code&gt;repositories&lt;/code&gt; в &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, как описано в &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Репозитории&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">Остальная процедура работает точно так же,как и на Java.</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">Результатом является объект, который представляет ссылку на свойство (свойство &amp;laquo;Платонический идеал&amp;raquo;, а не свойство в конкретном экземпляре). Для объектов свойств существует иерархия типов: базовым интерфейсом является &lt;code&gt;KProperty&lt;/code&gt; , который позволяет получать метаданные о свойстве, такие как его имя и тип. Если вы хотите использовать объект свойства для чтения или изменения значения свойства в объекте, вам необходимо использовать подинтерфейс, который указывает, что это за свойство. Неизменяемыми свойствами обычно являются &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; , а изменяемыми свойствами обычно являются &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; . Оба они являются универсальными интерфейсами, где &lt;code&gt;R&lt;/code&gt; является типом получателя (тип, для которого объявлено свойство, в данном случае &lt;code&gt;Person&lt;/code&gt; ), а &lt;code&gt;V&lt;/code&gt; - тип значения свойства.</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">Результат вычисляется как &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; где &lt;code&gt;q&lt;/code&gt; - частное от деления, округленное до ближайшего целого числа, &lt;code&gt;q = round(this / other)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">Результат будет:</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">Результат тот же, но в этом коде используется только неблокирующая &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;задержка&lt;/a&gt; . Основной поток, вызывающий &lt;code&gt;runBlocking&lt;/code&gt; ,&lt;em&gt;блокируется&lt;/em&gt; до завершения сопрограммы внутри &lt;code&gt;runBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">Результат &lt;code&gt;minus&lt;/code&gt; содержит элементы исходной коллекции, &lt;em&gt;кроме&lt;/em&gt; элементов из второго операнда. Если это элемент, &lt;code&gt;minus&lt;/code&gt; удаляет его &lt;em&gt;первое&lt;/em&gt; вхождение; если это коллекция, &lt;em&gt;все&lt;/em&gt; вхождения ее элементов удаляются.</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">Результат &lt;code&gt;plus&lt;/code&gt; содержит элементы из исходной коллекции &lt;em&gt;и&lt;/em&gt; из второго операнда.</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">Результат будущих вычислений.Блокирует выполнение до тех пор,пока будущее не будет готово.Вторая попытка получения приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">Результат этого кода достаточно интересен,поэтому мы подробно рассмотрим его в режиме:</target>
        </trans-unit>
        <trans-unit id="4a889b01b76fad01cdae52fa6c7d371792173b90" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in more detail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">Результат этого кода:</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">Результат этого кода:</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">Результирующий &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; определяет равенство и порядок ключей в соответствии с их естественным порядком сортировки.</target>
        </trans-unit>
        <trans-unit id="e25355ad3b686053cc1bc487b49186167f01eccb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to the sorting order provided by the given &lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634514a1676e5366bef12944cb3543ffee02d086" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; имеет то же двоичное представление, что и это значение &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; равно &lt;code&gt;this.toInt().toByte()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 &lt;code&gt;UInt&lt;/code&gt; битами этого значения UInt . Обратите внимание, что результирующее значение &lt;code&gt;Byte&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong . Обратите внимание, что результирующее значение &lt;code&gt;Byte&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Byte&lt;/code&gt; представлено 8 &lt;code&gt;UShort&lt;/code&gt; битами этого значения UShort . Обратите внимание, что результирующее значение &lt;code&gt;Byte&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">Результирующий код &lt;code&gt;Char&lt;/code&gt; равен этому значению, переинтерпретированному как беззнаковое число, т.е. он имеет то же двоичное представление, что и этот &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующий код &lt;code&gt;Char&lt;/code&gt; представлен 16 младшими битами этого значения &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующий код &lt;code&gt;Char&lt;/code&gt; представлен 16 младшими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Char&lt;/code&gt; равно &lt;code&gt;this.toInt().toChar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Double&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Float&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Float&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Float&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Float&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; имеет то же двоичное представление, что и значение &lt;code&gt;UInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; представлено 32 младшими значащими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; представлено 32 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong . Обратите внимание, что результирующее значение &lt;code&gt;Int&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение типа &lt;code&gt;Int&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Int&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; имеет то же двоичное представление, что и значение &lt;code&gt;ULong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и значение &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Long&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; имеет то же двоичное представление, что и значение &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; равно &lt;code&gt;this.toInt().toShort()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представлено 16 младшими битами этого значения &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представлено 16 младшими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представлено 16 &lt;code&gt;UInt&lt;/code&gt; битами этого значения UInt . Обратите внимание, что результирующее значение &lt;code&gt;Short&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представлено 16 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong . Обратите внимание, что результирующее значение &lt;code&gt;Short&lt;/code&gt; может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;Short&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; имеет то же двоичное представление, что и это значение &lt;code&gt;Byte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 младшими битами этого значения &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 &lt;code&gt;UInt&lt;/code&gt; битами этого значения UInt .</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong .</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UByte&lt;/code&gt; представлено 8 &lt;code&gt;UShort&lt;/code&gt; битами этого значения UShort .</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UInt&lt;/code&gt; имеет то же двоичное представление, что и это значение &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UInt&lt;/code&gt; представлено 32 младшими значащими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UInt&lt;/code&gt; представлено 32 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong .</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UInt&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UInt&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;ULong&lt;/code&gt; имеет то же двоичное представление, что и это значение &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;ULong&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;ULong&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;ULong&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UShort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; имеет то же двоичное представление, что и это значение &lt;code&gt;Short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; представлено 16 младшими битами этого значения &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; представлено 16 младшими битами этого значения &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; представлено 16 &lt;code&gt;UInt&lt;/code&gt; битами этого значения UInt .</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; представлено 16 &lt;code&gt;ULong&lt;/code&gt; битами этого значения ULong .</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">Результирующее значение &lt;code&gt;UShort&lt;/code&gt; представляет то же числовое значение, что и этот &lt;code&gt;UByte&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшей &lt;code&gt;Double&lt;/code&gt; к этому &lt;code&gt;Long&lt;/code&gt; значению. В случае, когда это значение &lt;code&gt;Long&lt;/code&gt; находится точно между двумя &lt;code&gt;Double&lt;/code&gt; s, выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшей &lt;code&gt;Double&lt;/code&gt; к этому &lt;code&gt;ULong&lt;/code&gt; значению. В случае, когда это значение &lt;code&gt;ULong&lt;/code&gt; находится точно между двумя &lt;code&gt;Double&lt;/code&gt; s, выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшим &lt;code&gt;Float&lt;/code&gt; к этому &lt;code&gt;Double&lt;/code&gt; значению. В случае, когда значение &lt;code&gt;Double&lt;/code&gt; находится точно между двумя значениями &lt;code&gt;Float&lt;/code&gt; , выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшим &lt;code&gt;Float&lt;/code&gt; к этому &lt;code&gt;Int&lt;/code&gt; значение. В случае, когда это значение &lt;code&gt;Int&lt;/code&gt; находится точно между двумя значениями типа &lt;code&gt;Float&lt;/code&gt; , выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшим &lt;code&gt;Float&lt;/code&gt; к этому &lt;code&gt;Long&lt;/code&gt; значение. В случае, когда это значение &lt;code&gt;Long&lt;/code&gt; находится точно между двумя значениями типа &lt;code&gt;Float&lt;/code&gt; , выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшим &lt;code&gt;Float&lt;/code&gt; к этому &lt;code&gt;UInt&lt;/code&gt; значению. В случае, когда это значение &lt;code&gt;UInt&lt;/code&gt; находится точно между двумя значениями &lt;code&gt;Float&lt;/code&gt; , выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">Полученное значение является ближайшим &lt;code&gt;Float&lt;/code&gt; к этому &lt;code&gt;ULong&lt;/code&gt; значению. В случае, когда это значение &lt;code&gt;ULong&lt;/code&gt; находится точно между двумя значениями &lt;code&gt;Float&lt;/code&gt; , выбирается значение с нулевым хотя бы значащим битом мантиссы.</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">Вывод типа возвращаемого значения для анонимных функций работает так же, как и для обычных функций: тип возвращаемого значения выводится автоматически для анонимных функций с телом выражения и должен быть указан явно (или предполагается, что это &lt;code&gt;Unit&lt;/code&gt; ) для анонимных функций с телом блока.</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">Тип возврата функционально-типизированного типа возврата (пользователь ожидает, что возвращаемая функция вернет &lt;code&gt;Fruit&lt;/code&gt; , поэтому ничего страшного, если она действительно возвращает &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">Тип возвращаемого выражения лямбда выводится из типа последнего выражения внутри него (или из типа функции переменной/параметра,которому присваивается выражение лямбда).Если выражение лямбда передается в качестве параметра функции (что является обычным использованием)или присваивается переменной с объявленным типом,Котлин тоже может вывести типы параметров,и нужно только указать их названия:</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;apply&lt;/code&gt; , а &lt;code&gt;also&lt;/code&gt; сам объект контекста. Следовательно, они могут быть включены в цепочки вызовов в качестве &lt;em&gt;побочных шагов&lt;/em&gt; : вы можете продолжить связывание вызовов функций на том же объекте после них.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">Возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">Возвращенный экземпляр использует указанный объект &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;блокировки&lt;/a&gt; для синхронизации. Если &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;блокировка&lt;/a&gt; не указана, экземпляр использует себя для синхронизации, в этом случае не выполняйте синхронизацию из внешнего кода в возвращенном экземпляре, так как это может вызвать случайную взаимоблокировку. Также это поведение может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">Возвращаемый список пуст,если эта последовательность символов char содержит менее двух символов.</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">Возвращаемый список пуст,если эта коллекция содержит менее двух элементов.</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">Возвращаемая карта сериализуема (JVM).</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">Возвращаемая карта сериализуема.</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода ключей,полученных из исходного массива.</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода ключей,полученных из исходной последовательности графиков.</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">На возвращаемой карте сохраняется порядок итераций ввода ключей,изготовленных из оригинальной коллекции.</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода ключей,полученных из исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходного массива.</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходного массива.Если любая из двух пар будет иметь один и тот же ключ,то последняя будет добавлена на карту.</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходной последовательности графиков.</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">На возвращаемой карте сохраняется порядок итераций ввода оригинальной коллекции.</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">На возвращаемой карте сохраняется порядок итераций ввода оригинальной коллекции.Если любая из двух пар будет иметь один и тот же ключ,то последняя будет добавлена на карту.</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходной карты.</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">Возвращенная карта сохраняет порядок итераций входа исходной карты. &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;Пара&lt;/a&gt; повторяется в конце концов , если он имеет уникальный ключ.</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">Возвращенная карта сохраняет порядок итераций входа исходной карты. Эти &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пары&lt;/a&gt; с уникальными ключами повторяются в конце в порядке массива &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пар&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">Возвращенная карта сохраняет порядок итераций входа исходной карты. Эти &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пары&lt;/a&gt; с уникальными ключами повторяются в конце в порядке сбора &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пар&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">Возвращенная карта сохраняет порядок итераций входа исходной карты. Эти &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пары&lt;/a&gt; с уникальными ключами повторяются в конце в порядке последовательности &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;пар&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">Возвращенная карта сохраняет порядок итераций входа исходной карты. Те записи другой &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;карты&lt;/a&gt; , которые отсутствуют на этой карте, повторяются в конце в порядке этой &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;карты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода исходной последовательности.Если любая из двух пар будет иметь один и тот же ключ,то последняя будет добавлена на карту.</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">Возвращаемая карта сохраняет порядок итераций ввода.</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">Возвращаемая последовательность ограничена итерацией только один раз.</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">Возвращаемая последовательность пуста,если она содержит менее двух элементов.</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">Возвращаемый набор сохраняет порядок итераций элементов исходного массива.</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">Возвращенный набор сохраняет порядок итерации элементов исходного массива. Те элементы &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;другой&lt;/a&gt; коллекции, которые являются уникальными, повторяются в конце в порядке, установленном в &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;другой&lt;/a&gt; коллекции.</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">Возвращаемый набор сохраняет порядок итераций элементов исходной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">Возвращаемый комплект сохраняет порядок итераций элементов оригинальной коллекции.</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">Возвращенный набор сохраняет порядок итерации элементов исходной коллекции. Те элементы &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;другой&lt;/a&gt; коллекции, которые являются уникальными, повторяются в конце в порядке, установленном в &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;другой&lt;/a&gt; коллекции.</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">Возвращаемый набор сохраняет порядок итераций элементов исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">Возвращаемый набор сохраняет порядок итераций элементов оригинального набора.</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">Возвращаемый набор сохраняет порядок итераций элементов.</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;y&lt;/code&gt; такое, что &lt;code&gt;sinh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;y&lt;/code&gt; такое, что &lt;code&gt;tanh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение положительное &lt;code&gt;y&lt;/code&gt; такое, что &lt;code&gt;cosh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">Возвращаемое значение &lt;em&gt;try&lt;/em&gt; -expression - это либо последнее выражение в блоке &lt;em&gt;try,&lt;/em&gt; либо последнее выражение в блоке (или блоках) &lt;em&gt;catch&lt;/em&gt; . Содержимое блока &lt;em&gt;finally&lt;/em&gt; не влияет на результат выражения.</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Корень иерархии классов Kotlin. Каждый класс Kotlin имеет &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; в качестве суперкласса.</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Корень иерархии классов Kotlin. Каждый класс Kotlin имеет &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; в качестве суперкласса.</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">Бегунок установит значение свойства system.path.macro.KOTLIN.BUNDLED в правильное,основываясь на настройках пути из проекта IntelliJ IDEA.Однако это значение должно быть определено в TeamCity (и может быть установлено в любое значение).Поэтому нам нужно определить его как системную переменную.</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">То же самое доступно для карт с функциями &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt; . Ключи и значения карты передаются как объекты &lt;code&gt;Pair&lt;/code&gt; (обычно создаются с помощью функции &lt;code&gt;to&lt;/code&gt; infix).</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Те же правила используются компилятором Kotlin / Native для создания файла &lt;code&gt;.h&lt;/code&gt; для всех платформ.</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">Тот же набор функций (но без констант) также доступен для аргументов типа &lt;code&gt;Float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">Тот же синтаксис можно использовать для аннотирования всего файла. Для этого поместите аннотацию с целевым &lt;code&gt;file&lt;/code&gt; на верхнем уровне файла, перед директивой пакета или перед всем импортом, если файл находится в пакете по умолчанию:</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">Тот же синтаксис с опущенными аргументами типа может использоваться для приведения типов, которые не принимают во внимание аргументы типа: &lt;code&gt;list as ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">Тот же трюк применяется, когда нам нужно иметь свойство &lt;code&gt;x&lt;/code&gt; вместе с функцией &lt;code&gt;getX()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">Один и тот же тип параметра может быть использован как в ковариантной,так и в противопоставляемой проекции (потому что именно общие классы проектируются,а не типовой параметр):</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">Масштаб результата такой же , как в масштабе &lt;code&gt;this&lt;/code&gt; (divident), так и для округления &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; режим округления используется.</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">Объем для получения значений &lt;a href=&quot;-sequence/index&quot;&gt;последовательности&lt;/a&gt; или &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;итератора&lt;/a&gt; предоставляет &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;функции&lt;/a&gt; приостановки &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; и yieldAll .</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">Объем для получения значений &lt;a href=&quot;../-sequence/index&quot;&gt;последовательности&lt;/a&gt; или &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;итератора&lt;/a&gt; предоставляет &lt;a href=&quot;yield-all&quot;&gt;функции&lt;/a&gt; приостановки &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; и yieldAll .</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">Объем для получения значений &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;последовательности&lt;/a&gt; или &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;итератора&lt;/a&gt; предоставляет &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;функции&lt;/a&gt; приостановки &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; и yieldAll .</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">Функции диапазона отличаются в зависимости от результата,который они возвращают:</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">Функции scope не вводят никаких новых технических возможностей,но они могут сделать ваш код более лаконичным и читабельным.</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">Вторая строка - &lt;code&gt;headerFilter&lt;/code&gt; . Это используется для обозначения того, что именно мы хотим включить. В C, когда один файл ссылается на другой файл с помощью директивы &lt;code&gt;#include&lt;/code&gt; , все заголовки также включаются. Иногда это может не понадобиться, и мы можем использовать этот параметр, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;используя шаблоны глобусов&lt;/a&gt; , для точной настройки. Обратите внимание, что &lt;code&gt;headerFilter&lt;/code&gt; является необязательным аргументом и в основном используется только тогда, когда используемая нами библиотека устанавливается как системная, и мы не хотим извлекать внешние зависимости (например, системный заголовок &lt;code&gt;stdint.h&lt;/code&gt; ) в нашу библиотеку взаимодействия. Это может быть важно как для оптимизации размера библиотеки, так и для устранения потенциальных конфликтов между системой и средой компиляции, предоставляемой Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">Второй список содержит вторые элементы.</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">Второе наблюдение: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; сразу же выбирается, когда канал уже закрыт.</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">Второй шаг - настроить путь поиска фреймворка для созданного двоичного файла. Он также известен как &lt;code&gt;rpath&lt;/code&gt; или &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;путь поиска во время выполнения&lt;/a&gt; . Бинарный файл использует путь для поиска необходимых фреймворков. Мы не рекомендуем устанавливать в ОС дополнительные фреймворки, если они не нужны. Мы должны понимать структуру нашего будущего приложения, например, у нас может быть папка &lt;code&gt;Frameworks&lt;/code&gt; в комплекте приложения со всеми используемыми инфраструктурами. Параметр &lt;code&gt;@rpath&lt;/code&gt; можно настроить в Xcode. Нам нужно открыть конфигурацию &lt;em&gt;проекта&lt;/em&gt; и найти &lt;code&gt;Runpath Search Paths&lt;/code&gt; . Здесь мы указываем относительный путь к скомпилированному фреймворку.</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">Второй шаг - включить путь к &lt;code&gt;Framework Search Paths&lt;/code&gt; блок &amp;laquo; Пути поиска платформы&amp;raquo; в разделе &amp;laquo; &lt;code&gt;Build Settings&lt;/code&gt; &amp;raquo; на &lt;em&gt;целевой&lt;/em&gt; странице конфигурации. Можно использовать макрос &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; для упрощения настройки.</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">Второй способ-использование печатных геттеров.Эти геттеры позволяют получить доступ к двоичному файлу определенного типа по префиксу его имени и типу сборки.</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">Последовательность может повторяться несколько раз, каждый раз начиная с &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;начального числа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">Последовательность может повторяться несколько раз.</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">Последовательность может быть потенциально бесконечной.</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">Последовательность значений,возвращаемых данным итератором,может быть потенциально бесконечной.</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">Операции с последовательностью можно разделить на следующие группы в зависимости от их государственных требований:</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">Обработка последовательности идет вот так:</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">Последовательность производит значения, пока не встретит первое &lt;code&gt;null&lt;/code&gt; значение. Если &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; возвращает &lt;code&gt;null&lt;/code&gt; , создается пустая последовательность.</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">Последовательность производит значения, пока не встретит первое &lt;code&gt;null&lt;/code&gt; значение. Если &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;начальное значение&lt;/a&gt; равно &lt;code&gt;null&lt;/code&gt; , создается пустая последовательность.</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">Набор всех возможных типов, которые могут быть заменены параметром данного типа, может быть ограничен &lt;strong&gt;общими ограничениями&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">Набор опций,которые использовались для создания этого регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">Набор целевых платформ определяется автором мультиплатформенной библиотеки,и они должны обеспечивать все специфические для платформы реализации библиотеки.Добавление новых целей для мультиплатформенной библиотеки со стороны потребителя не поддерживается.</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">Сеттер этого мутирующего свойства,используемый для изменения значения свойства.</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Подпись &lt;code&gt;greet()&lt;/code&gt; - &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; потому что это функция для &lt;code&gt;Person&lt;/code&gt; , которая принимает &lt;code&gt;String&lt;/code&gt; и возвращает &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">Сигнатура функции-члена или функции &lt;a href=&quot;extension-functionsproperties&quot;&gt;расширения&lt;/a&gt; начинается с &lt;em&gt;получателя&lt;/em&gt; : типа, для которого функция может быть вызвана. Например, сигнатура &lt;code&gt;toString()&lt;/code&gt; - &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - она ​​может быть вызвана для любого ненулевого объекта (получателя), она не принимает никаких параметров и возвращает &lt;code&gt;String&lt;/code&gt; . Можно написать лямбда-функцию с такой сигнатурой - это называется &lt;em&gt;литералом функции с получателем&lt;/em&gt; и чрезвычайно полезно для построения DSL.</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">Сигнатура переопределяющей функции должна точно совпадать с сигнатурой переопределяемой,за исключением того,что тип возврата в переопределяемой функции может быть подтипом типа возврата переопределяемой функции.</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">Простое имя класса, как оно было объявлено в исходном коде, или &lt;code&gt;null&lt;/code&gt; , если у класса нет имени (если, например, это литерал анонимного объекта).</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">Самая простая версия не требует дополнительных параметров и создает по одному двоичному файлу для каждого типа сборки. В настоящее время доступны два типа сборки: &lt;code&gt;DEBUG&lt;/code&gt; (создает не оптимизированный двоичный файл с отладочной информацией) и &lt;code&gt;RELEASE&lt;/code&gt; (создает оптимизированный двоичный файл без отладочной информации). Следовательно, следующий фрагмент кода создает два исполняемых двоичных файла: отладку и выпуск.</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">Единственное неизменяемое значение С.Оно автономно и не зависит от родной памяти.</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">Правило единственного родителя часто становится слишком ограничивающим, поскольку вы часто обнаруживаете общие черты между классами в разных ветвях иерархии классов. Эти общие черты могут быть выражены в &lt;em&gt;интерфейсах&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">Решением является &lt;em&gt;делегированное свойство&lt;/em&gt; , которое позволяет вам определять поведение получения и установки свойства (что-то вроде реализации &lt;code&gt;__getattribute__()&lt;/code&gt; и &lt;code&gt;__setattribute__()&lt;/code&gt; в Python, но для одного свойства за раз).</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">Решение заключается в том,чтобы отмечать цели с помощью пользовательского атрибута,который учитывается Gradle при разрешении зависимостей.Это,однако,должно быть сделано как со стороны автора библиотеки,так и со стороны потребителя,и ответственность автора библиотеки заключается в том,чтобы донести атрибут и его возможные значения до потребителей.</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">Сорт &lt;em&gt;стабильный&lt;/em&gt; . Это означает, что одинаковые элементы сохраняют свой порядок относительно друг друга после сортировки.</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">Имена исходных наборов чувствительны к регистру. При обращении к источнику по умолчанию, установленному по его имени, убедитесь, что префикс имени соответствует имени цели, например, исходный набор &lt;code&gt;iosX64Main&lt;/code&gt; для целевого &lt;code&gt;iosX64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">Исходные наборы DSL могут быть использованы для определения этих соединений между исходными наборами:</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">Наборы источников выполнены в &lt;code&gt;sourceSets { ... }&lt;/code&gt; блока &lt;code&gt;kotlin { ... }&lt;/code&gt; расширение:</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Спецификацию требований к делегированному объекту можно найти &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">Стандартный плагин создания JavaDoc ( &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; ) не поддерживает код Kotlin. Для создания документации для проектов Kotlin используйте &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; ; пожалуйста, обратитесь к &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; за инструкциями по настройке. Dokka поддерживает проекты на разных языках и может генерировать вывод в нескольких форматах, включая стандартный JavaDoc.</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">Стандартная библиотека содержит группу функций расширения, которые позволяют фильтровать коллекции за один вызов. Эти функции оставляют исходную коллекцию без изменений, поэтому они доступны как для &lt;a href=&quot;collections-overview#collection-types&quot;&gt;изменяемых&lt;/a&gt; коллекций, так и для коллекций только для чтения . Чтобы обработать результат фильтрации, вы должны присвоить его переменной или связать функции после фильтрации.</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">Стандартная библиотека определяет функцию с именем &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt; которая приводит значение к динамическому типу. Учитывая наш предыдущий пример, в котором мы использовали jQuery для работы с элементами DOM, теперь мы можем объединить это с &lt;code&gt;asDynamic()&lt;/code&gt; чтобы затем вызвать &lt;code&gt;dataTable()&lt;/code&gt; для результата:</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">Стандартной библиотеки в настоящее время предоставляет набор функций для элемента-по-элементу операций с массивами: сравнения ( &lt;code&gt;contentEquals&lt;/code&gt; и &lt;code&gt;contentDeepEquals&lt;/code&gt; ), вычисление хэш - кода ( &lt;code&gt;contentHashCode&lt;/code&gt; и &lt;code&gt;contentDeepHashCode&lt;/code&gt; ), и преобразования в строку ( &lt;code&gt;contentToString&lt;/code&gt; и &lt;code&gt;contentDeepToString&lt;/code&gt; ). Они поддерживаются как для JVM (где они действуют как псевдонимы для соответствующих функций в &lt;code&gt;java.util.Arrays&lt;/code&gt; ), так и для JS (где реализация предоставляется в стандартной библиотеке Kotlin).</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">В стандартной библиотеке есть &lt;code&gt;Pair&lt;/code&gt; и &lt;code&gt;Triple&lt;/code&gt; . Однако в большинстве случаев именованные классы данных являются лучшим выбором для проектирования, поскольку они делают код более читабельным, предоставляя значимые имена для свойств.</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">Стандартная библиотека предоставляет нам ряд оболочек вокруг DOM, а также функции для работы с JavaScript с использованием статической типизации. Однако что происходит, когда мы хотим использовать такую ​​библиотеку, как jQuery? Kotlin не имеет собственных файлов &amp;laquo;заголовков&amp;raquo; для всех различных библиотек, доступных в экосистеме JavaScript, однако у TypeScript есть. &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Определенно типизированных хранилище&lt;/a&gt; дает нам очень большой выбор файлов заголовков.</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">Стандартная библиотека использует сопрограммы для поддержки &lt;em&gt;лениво генерируемых последовательностей&lt;/em&gt; с функциями &lt;code&gt;yield&lt;/code&gt; и &lt;code&gt;yieldAll&lt;/code&gt; . В такой последовательности блок кода, который возвращает элементы последовательности, приостанавливается после извлечения каждого элемента и возобновляется при запросе следующего элемента. Вот пример:</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">Значение статуса в &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; указывает, как компилятор обрабатывает несоответствующее использование аннотированных типов в Kotlin (например, используя значение типа &lt;code&gt;@MyNullable&lt;/code&gt; -annotated как ненулевое):</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">Шаг прогресса.</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">Значение шага должно быть положительным. Если вам нужно считать вниз, используйте включительное &lt;code&gt;downTo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">Подкласс &lt;em&gt;наследует&lt;/em&gt; все члены, существующие в его суперклассе - как те, которые непосредственно определены в суперклассе, так и те, которые унаследовал сам суперкласс. В этом примере &lt;code&gt;Car&lt;/code&gt; содержит следующие элементы:</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">Подстрока из входной строки,захваченной этим совпадением.</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">Синтаксис: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; . Выражение после &lt;em&gt;by&lt;/em&gt; является &lt;em&gt;делегатом&lt;/em&gt; , потому что &lt;code&gt;get()&lt;/code&gt; (и &lt;code&gt;set()&lt;/code&gt; ), соответствующие свойству, будут делегированы его &lt;code&gt;getValue()&lt;/code&gt; и &lt;code&gt;setValue()&lt;/code&gt; . Делегаты свойств не должны реализовывать какой-либо интерфейс, но они должны предоставлять функцию &lt;code&gt;getValue()&lt;/code&gt; (и &lt;code&gt;setValue()&lt;/code&gt; - для &lt;em&gt;var&lt;/em&gt; s). Например:</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">В таблице ниже показано,как концепции Котлина сопоставляются с концепциями Свифт/Объект-С и наоборот.</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">Цели, созданные из предустановок, добавляются в &lt;code&gt;kotlin.targets&lt;/code&gt; объектов домена kotlin.targets , которую можно использовать для доступа к ним по их именам или настройки всех целей:</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">Терминология такова, что &lt;code&gt;var&lt;/code&gt; объявляет &lt;em&gt;изменяемую&lt;/em&gt; переменную, а &lt;code&gt;val&lt;/code&gt; объявляет переменную &lt;em&gt;только&lt;/em&gt; для &lt;em&gt;чтения&lt;/em&gt; или переменную с &lt;em&gt;однократным назначением,&lt;/em&gt; поэтому оба вида называются &lt;em&gt;переменными&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">Подробнее см. В &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;примере проекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">Третий вариант предназначен для любителей NPE: оператор утверждения ненулевого значения ( &lt;code&gt;!!&lt;/code&gt; ) преобразует любое значение в ненулевой тип и выдает исключение, если значение равно нулю. Мы можем написать &lt;code&gt;b!!&lt;/code&gt; , и это вернет ненулевое значение &lt;code&gt;b&lt;/code&gt; (например, &lt;code&gt;String&lt;/code&gt; в нашем примере) или выдаст NPE, если &lt;code&gt;b&lt;/code&gt; равно null:</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">Три цели создаются с помощью предустановленных функций &lt;code&gt;jvm()&lt;/code&gt; , &lt;code&gt;js()&lt;/code&gt; и &lt;code&gt;mingwX64()&lt;/code&gt; которые обеспечивают некоторую &lt;a href=&quot;#default-project-layout&quot;&gt;конфигурацию по умолчанию&lt;/a&gt; . Есть предустановки для каждой из &lt;a href=&quot;#supported-platforms&quot;&gt;поддерживаемых платформ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">Два одинаковых символа (по сравнению с оператором ==)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">Тип &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; является особенным, поскольку в Java ему нет аналогов. Действительно, каждый ссылочный тип Java, включая &lt;code&gt;java.lang.Void&lt;/code&gt; , принимает в качестве значения &lt;code&gt;null&lt;/code&gt; , а &lt;code&gt;Nothing&lt;/code&gt; не принимает даже этого. Таким образом, этот тип не может быть точно представлен в мире Java. Вот почему Kotlin генерирует необработанный тип, в котором используется аргумент типа &lt;code&gt;Nothing&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">Тип &lt;code&gt;Boolean&lt;/code&gt; представляет логические значения и имеет два значения: &lt;em&gt;true&lt;/em&gt; и &lt;em&gt;false&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Аргумент типа &lt;code&gt;T&lt;/code&gt; из &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; должен быть одним из типов &amp;laquo;именующих&amp;raquo; была описано выше, например, типа С &lt;code&gt;struct S*&lt;/code&gt; отображается на &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; , &lt;code&gt;int8_t*&lt;/code&gt; отображается на &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; и &lt;code&gt;char**&lt;/code&gt; отображается на &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">Аргументы типа вызовов универсальных функций также проверяются только во время компиляции. Внутри тела функции параметры типа не могут использоваться для проверки типов, а приведение типов к параметрам типа ( &lt;code&gt;foo as T&lt;/code&gt; ) не отмечено. Однако &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;параметры овеществленного типа&lt;/a&gt; встроенных функций заменяются аргументами фактического типа во встроенном теле функции на сайтах вызовов и, таким образом, могут использоваться для проверки и преобразования типов с теми же ограничениями для экземпляров универсальных типов, как описано выше.</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">Тип &lt;code&gt;safeDivide&lt;/code&gt; - &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; . Обратите внимание, что в отличие от объявлений типов функций, список параметров лямбда-выражения не должен заключаться в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">Тип свойства,а также типы,используемые для параметров и возвращаемый тип функции,должны быть &quot;по крайней мере,так же заметны&quot;,как и само свойство/функция.Например,публичная функция не может принимать за параметр приватный тип.</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">Типом выражения &lt;code&gt;throw&lt;/code&gt; является специальный тип &lt;code&gt;Nothing&lt;/code&gt; . Тип не имеет значений и используется для обозначения участков кода, которые никогда не будут достигнуты. В вашем собственном коде вы можете использовать &lt;code&gt;Nothing&lt;/code&gt; , чтобы отметить функцию, которая никогда не возвращает:</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">Тип этих выражений - &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;тип Nothing&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">Тип возвращаемых значений.</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Проверки безопасности типов, которые Kotlin выполняет для общих объявлений, выполняются только во время компиляции. Во время выполнения экземпляры универсальных типов не содержат никакой информации об их фактических аргументах типа. Считается, что информация о типе &lt;em&gt;стерта&lt;/em&gt; . Например, экземпляры &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; Удаляются только до &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">Тип указан после двоеточия является &lt;strong&gt;верхней границей&lt;/strong&gt; : только подтипом &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; может быть заменен на &lt;code&gt;T&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">Тип, указанный в проекции, или &lt;code&gt;null&lt;/code&gt; , если это проекция звезды.</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">Тип только с одним значением: объект &lt;code&gt;Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">Тип только с одним значением: объект &lt;code&gt;Unit&lt;/code&gt; . Этот тип соответствует типу &lt;code&gt;void&lt;/code&gt; в Java.</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">Типы внутри угловых скобок называются &lt;em&gt;параметрами универсального типа&lt;/em&gt; , о которых мы поговорим позже. Короче говоря, это полезный метод, позволяющий сделать класс, привязанный к другому классу (например, класс контейнера, связанный с его классом элемента), применимым ко многим различным классам.</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">Использование из C прямое и несложное. Мы создаем файл &lt;code&gt;main.c&lt;/code&gt; со следующим кодом:</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">Использование довольно похоже на полное открытие.</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">Использование одинаково для all-open и no-arg,за исключением того,что sam-with-receiver не имеет встроенных пресетов,и вам необходимо указать свой собственный список специально обработанных аннотаций.</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">Случаи использования различных функций накладываются друг на друга,так что вы можете выбрать функции на основе конкретных соглашений,используемых в вашем проекте или команде.</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">Дисперсия места использования, указанная в проекции, или &lt;code&gt;null&lt;/code&gt; если это проекция звезды.</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">Значение,удерживаемое этим классом.</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">Значение должно быть положительным, а &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; используется для указания неограниченной глубины.</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">Значение захваченной группы.</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">Значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">Переменная, содержащая &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">Версия интерфейса байткода (соглашения об именовании,подписи)файла класса,аннотированная этой аннотацией.</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">Версия метаданных,представленная в аргументах данной аннотации.</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">Самая первая часть содержит стандартный заголовок и нижний колонтитул на C/C++:</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">Уровень видимости влияет только на &lt;em&gt;лексическую видимость&lt;/em&gt; в &lt;em&gt;символе&lt;/em&gt; - то есть, где компилятор позволяет впечатать символ. Это не влияет на то, где используются &lt;em&gt;экземпляры&lt;/em&gt; : например, общедоступная функция верхнего уровня вполне может возвращать экземпляр частного класса, если в возвращаемом типе не упоминается имя частного класса, а вместо этого является общедоступным базовым классом частный класс (возможно, &lt;code&gt;Any&lt;/code&gt; ) или открытый интерфейс, который реализует частный класс. Когда вы создаете &lt;a href=&quot;inheritance#subclassing&quot;&gt;подкласс&lt;/a&gt; класса, его частные члены также наследуются подклассом, но не доступны там напрямую, однако, если вы вызываете унаследованную общедоступную функцию, которая обращается к частному члену, это нормально.</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">Мы бы использовали это из JavaScript, чтобы вызвать &lt;code&gt;dataTable()&lt;/code&gt; для соответствующего элемента &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">Способ обращения к объекту контекста</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">На веб-сайте есть множество &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;онлайн-ресурсов&lt;/a&gt; , в том числе &lt;a href=&quot;https://kotlin.link&quot;&gt;дайджесты Kotlin&lt;/a&gt; от членов сообщества, &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;информационный бюллетень&lt;/a&gt; , &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;подкаст&lt;/a&gt; и многое другое.</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">Затем добавьте соответствующие зависимости, используя конфигурацию &lt;code&gt;kapt&lt;/code&gt; в блоке &lt;code&gt;dependencies&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">Затем следуйте инструкциям мастера. У вас будет файл &lt;code&gt;build.gradle&lt;/code&gt; , созданный с помощью Kotlin, настроенного в соответствии с &lt;a href=&quot;../../reference/using-gradle&quot;&gt;этим документом&lt;/a&gt; . Убедитесь, что он настроен для Kotlin 1.3 или выше.</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">Затем следуйте инструкциям мастера. У вас будет файл &lt;code&gt;pom.xml&lt;/code&gt; , созданный с помощью Kotlin, настроенного в соответствии с &lt;a href=&quot;../../reference/using-maven&quot;&gt;этим документом&lt;/a&gt; . Убедитесь, что он настроен для Kotlin 1.3 или выше.</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">Затем запустите инструмент &lt;code&gt;cinterop&lt;/code&gt; с чем-то вроде этого (обратите внимание, что для хост-библиотек, которые не включены в пути поиска sysroot, могут потребоваться заголовки):</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">Затем укажите список аннотаций SAM-приемника:</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">Затем укажите список аннотаций,которые сделают классы открытыми:</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">После этого укажите список ненаглядных аннотаций:</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">Тогда мы сможем получить несколько процессорных коробок.В данном примере они просто распечатывают свой идентификатор и получают номер:</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">Затем мы определяем функцию, которая запускает актера, используя построитель сопрограмм &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;актера&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">Затем для каждого &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;исходного набора Android,&lt;/a&gt; скомпилированного вариантами, создается исходный набор Kotlin под этим именем исходного набора, к которому добавляется имя цели, например исходный набор Kotlin &lt;code&gt;androidDebug&lt;/code&gt; для &lt;code&gt;debug&lt;/code&gt; исходного набора Android и цель Kotlin с именем &lt;code&gt;android&lt;/code&gt; . Эти исходные наборы Kotlin добавляются в компиляции вариантов соответственно.</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">Тогда было бы совершенно безопасно сохранить ссылку на экземпляр &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; в переменной типа &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; - нет никаких методов-потребителей для вызова. Но Java этого не знает и до сих пор запрещает:</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">Затем,после добавления мишени,для нее создаются компиляции по умолчанию:</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">Затем, через некоторое время уровень устаревания повышается до &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; , так что новый код Kotlin не может быть скомпилирован с использованием устаревшего API.</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">Тогда единственное, что мы хотим убедиться, это то, что &lt;code&gt;copy()&lt;/code&gt; не будет делать ничего плохого. Мы хотим , чтобы запретить его от &lt;strong&gt;написания&lt;/strong&gt; до &lt;code&gt;from&lt;/code&gt; , и мы можем:</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Для Kotlin доступно несколько курсов, в том числе &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;курс Pluralsight Kotlin&lt;/a&gt; от Кевина Джонса, &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;курс O'Reilly&lt;/a&gt; от Хади Харири и &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;курс Udemy Kotlin&lt;/a&gt; от Питера Соммерхоффа.</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">В Kotlin есть множество встроенных функций / свойств расширения - например, &lt;code&gt;map()&lt;/code&gt; , &lt;code&gt;filter()&lt;/code&gt; и остальная часть фреймворка для функциональной обработки коллекций построена с использованием функций расширения.</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">По Kotlin уже доступен &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;ряд книг&lt;/a&gt; , в том числе &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action,&lt;/a&gt; написанная членами команды Kotlin Дмитрием Емеровым и Светланой Исаковой, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers,&lt;/a&gt; ориентированными на разработчиков Android.</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">Также существуют функции для создания коллекций без каких-либо элементов: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt; . При создании пустых коллекций вы должны указать тип элементов, которые будет содержать коллекция.</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Также существуют функции для получения наименьшего и наибольшего элементов с помощью определенной функции селектора или настраиваемого &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">Существуют также функции,сужающие тип элемента путем фильтрации элементов данного типа:</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">На YouTube и Vimeo также есть много записей &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;разговоров&lt;/a&gt; на Котлине .</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">Существуют также более специфические типы:</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">Есть также некоторые инструменты для ручной конвертации между Котлином и C-строками:</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">В языке C также есть следующие квалификаторы типов: &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restruct&lt;/code&gt; , &lt;code&gt;atomic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">Также есть два конкретных способа фильтрации карт: по ключам и по значениям. Для каждого способа существует функция &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt; . Оба возвращают новую карту записей, соответствующих данному предикату. Предикат для &lt;code&gt;filterKeys()&lt;/code&gt; проверяет только ключи элементов, &lt;code&gt;filterValues()&lt;/code&gt; для filterValues ​​() проверяет только значения.</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Также существуют полезные псевдонимы для получения первого и последнего элемента коллекции: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">Есть определенные общие виды свойств,которые,хотя мы и можем реализовать вручную каждый раз,когда они нам нужны,было бы очень приятно реализовать раз и навсегда,и поместить в библиотеку.Примеры включают в себя:</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">Существуют определенные правила,определяющие операции записи на карты:</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">Есть пара наблюдений.</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">Есть ровно четыре экземпляра этого класса с именем &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; и так далее. Экземпляры этого класса можно сравнивать друг с другом с помощью &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; , И вы можете получить все допустимые значения с помощью &lt;code&gt;ContentKind.values()&lt;/code&gt; . Вы также можете добавить дополнительную информацию к каждому экземпляру, если вам нужно:</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">Есть много подходов к этой проблеме, и в Kotlin мы используем очень гибкий подход, предоставляя поддержку &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; на уровне языка и делегируя большую часть функций библиотекам, что во многом соответствует философии Kotlin.</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">Для хоста и целей кросс-компиляции доступно гораздо больше библиотек платформ. Дистрибутив &lt;code&gt;Kotlin/Native&lt;/code&gt; обеспечивает доступ к &lt;code&gt;OpenGL&lt;/code&gt; , &lt;code&gt;zlib&lt;/code&gt; и другим популярным нативным библиотекам на соответствующих платформах.</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">Есть несколько способов скомпилировать Kotlin с JavaScript.Рекомендуемый подход-использование Gradle;при желании вы можете скомпилировать JavaScript-проекты непосредственно из IntelliJ IDEA,использовать Maven или скомпилировать код вручную из командной строки.Подробнее о том,как скомпилировать на JavaScript,читайте в соответствующих учебниках:</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">В Kotlin нет &lt;code&gt;**kwargs&lt;/code&gt; , но вы можете определить дополнительные параметры со значениями по умолчанию, и вы можете указать имена некоторых или всех параметров при вызове функции (независимо от того, имеют ли они значения по умолчанию или нет). Параметр со значением по умолчанию все равно должен явно указывать свой тип. Как и в Python, именованные аргументы могут быть по желанию переупорядочены на месте вызова:</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">Нет никаких автоматических преобразований в логическое значение и, следовательно, нет концепции правдивости и ложности: проверка нуля, пустоты или нуля должна выполняться явно с помощью &lt;code&gt;==&lt;/code&gt; или &lt;code&gt;!=&lt;/code&gt; . Большинство типов коллекций имеют функции &lt;code&gt;isEmpty()&lt;/code&gt; и &lt;code&gt;isNotEmpty()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">Теперь существуют отдельные версии стандартной библиотеки, поддерживающие новые API-интерфейсы JDK, добавленные в Java 7 и 8. Если вам нужен доступ к новым API-интерфейсам, используйте &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts вместо стандартных &lt;code&gt;kotlin-stdlib&lt;/code&gt; . Эти артефакты представляют собой крошечные расширения поверх &lt;code&gt;kotlin-stdlib&lt;/code&gt; , и они переносят его в ваш проект в качестве транзитивной зависимости.</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">Существует несколько способов получения экземпляра типа функции:</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">Существует несколько способов переопределения параметра по умолчанию:</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">Есть некоторые ограничения:</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">Существуют целевые предустановки,которые можно применять с помощью функций предварительной настройки,как показано выше,для следующих целевых платформ:</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">Существуют следующие виды буквальных констант для интегральных значений:</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">Есть три сопрограммы. Основная сопрограмма (# 1) - одна &lt;code&gt;runBlocking&lt;/code&gt; и две сопрограммы, вычисляющие отложенные значения &lt;code&gt;a&lt;/code&gt; (# 2) и &lt;code&gt;b&lt;/code&gt; (# 3). Все они выполняются в контексте &lt;code&gt;runBlocking&lt;/code&gt; и ограничены основным потоком. Вывод этого кода:</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">Слишком много компаний, использующих Kotlin, чтобы перечислить, но некоторые более заметные компании, которые публично заявили об использовании Kotlin, будь то сообщения в блогах, репозитории GitHub или переговоры, включают &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt; , &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt; , &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; или &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">Есть два подхода к отмене вычислительного кода. Первый - периодически вызывать функцию приостановки, которая проверяет отмену. Существует функция &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;доходности,&lt;/a&gt; которая является хорошим выбором для этой цели. Другой - явно проверить статус отмены. Попробуем второй подход.</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">Есть две функции, для которых компилятор дает одинаковое имя в JavaScript, вы можете пометить одну с помощью &lt;code&gt;@JsName(...)&lt;/code&gt; чтобы компилятор не сообщал об ошибке.</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">Есть два возможных способа выбрать беззнаковые типы:с разметкой вашего API как экспериментального или без этого.</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">В зависимости от того,насколько быстро компонент развивается,могут существовать различные режимы стабильности:</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">Существует множество подходов к решению этой проблемы,в том числе:</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">Существует поле &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; , которое представляет &lt;code&gt;Clazz&lt;/code&gt; из Kotlin. &lt;code&gt;Clazz#memberFunction&lt;/code&gt; доступен с &lt;code&gt;memberFunction&lt;/code&gt; поле. Единственное отличие состоит в том, что &lt;code&gt;memberFunction&lt;/code&gt; принимает ссылку &lt;code&gt;this&lt;/code&gt; в качестве первого параметра. Язык C не поддерживает объекты, и это причина для явной передачи указателя &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">Есть лучшее решение. В нашем коде можно использовать структурированный параллелизм. Вместо запуска сопрограмм в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; , как мы обычно делаем с потоками (потоки всегда являются глобальными), мы можем запускать сопрограммы в определенной области выполняемой операции.</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">В классе String есть множество новых расширений для преобразования его в число без &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; исключения для недопустимого числа: String.toIntOrNull (): Int? , &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; и т.п.</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">Существует конструктор в &lt;code&gt;Clazz&lt;/code&gt; поле ( так называемый &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; ), которая является функцией конструктора для создания экземпляра &lt;code&gt;Clazz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">Существует удобный сопрограммная строитель по имени &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;продукции&lt;/a&gt; , что делает его легко сделать это прямо на стороне производителя, а также функция расширения &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt; , что заменяет &lt;code&gt;for&lt;/code&gt; петли на стороне потребителя:</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">Существует вариант &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;асинхронности&lt;/a&gt; с использованием необязательного &lt;code&gt;start&lt;/code&gt; параметра со значением &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt; . Он запускает сопрограмму только тогда, когда ее результат нужен для некоторого &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;ожидания&lt;/a&gt; или если вызывается функция &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;запуска&lt;/a&gt; . Выполните следующий пример:</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">Существует хороший кусок синтаксического сахара , который позволяет сделать это: &lt;em&gt;функции расширения&lt;/em&gt; и &lt;em&gt;свойство расширения&lt;/em&gt; . Они выглядят как обычные функции - члены / свойства, но они определяются вне любого класса - все же они ссылаются на имя класса и может использовать &lt;code&gt;this&lt;/code&gt; . Однако они могут использовать только видимые члены класса (обычно только общедоступные). За кулисами они компилируются в обычные функции, которые принимают целевой экземпляр в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">Также существует &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;функция&lt;/a&gt; расширения withLock, которая удобно представляет &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; шаблон {...} finally {mutex.unlock ()} :</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">Существует также пара функций,которые берут предикат и ищут соответствующие ему элементы:</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">Существует конструктор сопрограмм &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;актора,&lt;/a&gt; который удобно объединяет канал почтового ящика актора в свою область действия для получения сообщений и объединяет канал отправки в результирующий объект задания, так что единственная ссылка на актера может переноситься как его дескриптор.</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">Существует оптимизация,которая удаляет избыточные массивы,создаваемые в таких случаях,что предотвращает снижение производительности.Однопамятная форма выдает предупреждения в Kotlin 1.2 и должна быть сброшена в Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">Существует возможность публиковать варианты,сгруппированные по вкусу продукта,так,чтобы выходы различных типов сборки размещались в одном модуле,при этом тип сборки становился классификатором артефактов (тип сборки выпуска все равно публикуется без классификатора).Этот режим отключен по умолчанию и может быть включен следующим образом:</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">Существует распространенное заблуждение, что создание переменной &lt;code&gt;volatile&lt;/code&gt; решает проблему параллелизма. Давайте попробуем:</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">В языке C нет специального типа для строк. Разработчик знает из сигнатуры метода или документации, означает ли данный &lt;code&gt;char *&lt;/code&gt; строку C в контексте. Строки в языке C заканчиваются нулем, завершающий нулевой символ &lt;code&gt;\0&lt;/code&gt; добавляется в конце последовательности байтов, чтобы отметить завершение строки. Обычно используются &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;строки в кодировке UTF-8&lt;/a&gt; . Кодировка UTF-8 использует символы переменной ширины и обратно совместима с &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; . Kotlin / Native по умолчанию использует кодировку символов UTF-8.</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">Больше нет исключений при выполнении этого кода:</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">Значения в этом классе не имеют никакого значения,его можно использовать для любых целей.Пара проявляет стоимостную семантику,т.е.две пары равны,если обе компоненты равны.</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">Значения в этом классе не имеют никакого значения,его можно использовать для любых целей.Тройка показывает семантику значений,т.е.две тройки равны,если все три составляющие равны.Пример разложения на значения:</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">В C нет поддержки пространств имен,поэтому компилятор Kotlin/Native генерирует длинные имена,чтобы избежать любых возможных столкновений с другими символами в существующем родном проекте.</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">В соревновательном программировании нет необходимости обрабатывать случай искаженного ввода. В соревновательном программировании формат ввода всегда точно указывается, и фактический ввод не может отклоняться от спецификации ввода в постановке задачи. Вот что такое оператор нулевого утверждения &lt;code&gt;!!&lt;/code&gt; по сути, делает - он утверждает, что входная строка присутствует, и в противном случае выдает исключение. Аналогично, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;функция String.toInt ()&lt;/a&gt; вызывает исключение, если входная строка не является целым числом.</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">Сейчас существует большое количество &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;предустановленных конфигураций платформы&lt;/a&gt; для различных поддерживаемых платформ.</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">Существует одно важное семантическое различие между выражениями объектов и объявлениями объектов:</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">Есть еще один способ поиска элементов в списках - &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;бинарный поиск&lt;/a&gt; . Он работает значительно быстрее, чем другие встроенные функции поиска, но &lt;em&gt;требует, чтобы список был &lt;a href=&quot;collection-ordering&quot;&gt;отсортирован&lt;/a&gt;&lt;/em&gt; в порядке возрастания в соответствии с определенным порядком: естественным или другим, указанным в параметре функции. В противном случае результат не определен.</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">Для практического использования сопрограмм еще есть что пожелать. Когда мы используем &lt;code&gt;GlobalScope.launch&lt;/code&gt; , мы создаем сопрограмму верхнего уровня. Несмотря на то, что он легкий, он все же потребляет некоторые ресурсы памяти во время работы. Если мы забудем сохранить ссылку на только что запущенную сопрограмму, она все равно будет работать. Что, если код в сопрограмме зависает (например, мы ошибочно задерживаем слишком долго), что, если мы запустили слишком много сопрограмм и исчерпали память? Необходимость вручную сохранять ссылки на все запущенные сопрограммы и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;присоединяться к&lt;/a&gt; ним чревата ошибками.</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">Может быть ноль или более блоков &lt;em&gt;catch&lt;/em&gt; . блок &lt;em&gt;finally&lt;/em&gt; можно опустить. Однако должен присутствовать хотя бы один &lt;em&gt;улов&lt;/em&gt; или &lt;em&gt;окончательный&lt;/em&gt; блок.</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">Будет свойство с именем &lt;code&gt;hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">Будет только один экземпляр этого класса,и этот экземпляр (который создается при первом обращении,в потокобезопасной манере)имеет то же имя,что и класс:</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">С лямбда-функциями связаны небольшие накладные расходы времени выполнения: они на самом деле являются объектами, поэтому их нужно создавать, и (как и другие функции) их вызов также занимает немного времени. Если мы используем ключевое слово &lt;code&gt;inline&lt;/code&gt; для функции, мы говорим компилятору &lt;em&gt;встроить&lt;/em&gt; и функцию, и ее лямбда-параметры (если есть), то есть компилятор скопирует код функции (и ее лямбда-параметры) в &lt;em&gt;каждый сайт&lt;/em&gt; вызова, таким образом устраняются накладные расходы как на создание лямбда-выражения, так и на вызов функции и лямбда-выражений. Это произойдет безоговорочно, в отличие от C и C ++, где &lt;code&gt;inline&lt;/code&gt; это скорее подсказка для компилятора. Это приведет к увеличению размера скомпилированного кода, но это может окупиться для некоторых небольших, но часто вызываемых функций.</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;пакете &lt;/a&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; имеется обширная коллекция операций в стиле функционального программирования .</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">В JavaScript нет 64-битного целого числа, поэтому &lt;code&gt;kotlin.Long&lt;/code&gt; не сопоставляется ни с одним объектом JavaScript, он эмулируется классом Kotlin.</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">В Котлине такого синтаксиса нет. Однако в Котлине есть объекты- &lt;code&gt;companion&lt;/code&gt; . Kotlin особым образом обрабатывает сопутствующие объекты &lt;code&gt;external&lt;/code&gt; класса: вместо ожидания объекта он предполагает, что члены сопутствующих объектов являются членами самого класса. Чтобы описать &lt;code&gt;MyClass&lt;/code&gt; из приведенного выше примера, вы можете написать:</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">Есть две формы использования &lt;code&gt;definedExternally&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">Следовательно, если &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;действие&lt;/a&gt; внутри блокировки записи было инициировано проверкой какого-либо условия, условие должно быть повторно проверено внутри &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;действия,&lt;/a&gt; чтобы избежать возможных гонок.</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">Поэтому два следующих отрывка эквивалентны:</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">Таким образом, нет никакого общего способа проверить , был ли создан экземпляр универсального типа с определенными аргументами типа во время выполнения, и компилятор &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;запрещает такое &lt;em&gt;это&lt;/em&gt; -Проверяет&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Эти &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;непроверенные преобразования&lt;/a&gt; могут использоваться, когда безопасность типов подразумевается логикой программы высокого уровня, но не может быть выведена непосредственно компилятором. Компилятор выдает предупреждение о непроверенных приведениях, а во время выполнения проверяется только неуниверсальная часть (эквивалент &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">Эти абстрактные классы могут использоваться как базовые классы при реализации классов коллекции Kotlin. Для реализации коллекций только для чтения существуют &lt;code&gt;AbstractCollection&lt;/code&gt; , &lt;code&gt;AbstractList&lt;/code&gt; , &lt;code&gt;AbstractSet&lt;/code&gt; и &lt;code&gt;AbstractMap&lt;/code&gt; , а для изменяемых коллекций - &lt;code&gt;AbstractMutableCollection&lt;/code&gt; , &lt;code&gt;AbstractMutableList&lt;/code&gt; , &lt;code&gt;AbstractMutableSet&lt;/code&gt; и &lt;code&gt;AbstractMutableMap&lt;/code&gt; . В JVM эти абстрактные изменяемые коллекции наследуют большую часть своей функциональности от абстрактных коллекций JDK.</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">Это &lt;a href=&quot;#default-project-layout&quot;&gt;имена наборов источников&lt;/a&gt; по умолчанию для производственных и тестовых источников для целей, настроенных выше. Исходные наборы &lt;code&gt;commonMain&lt;/code&gt; и &lt;code&gt;commonTest&lt;/code&gt; включены в производственную и тестовую компиляции, соответственно, всех целей. Обратите внимание, что зависимости для общих исходных наборов &lt;code&gt;commonMain&lt;/code&gt; и &lt;code&gt;commonTest&lt;/code&gt; являются общими артефактами, а библиотеки платформы переходят к исходным наборам конкретных целей.</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">Это три функции расширения общего назначения,применимые к любому приемнику.</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">Эти соображения приводят к следующим правилам. Параметр ковариантного типа &lt;code&gt;T&lt;/code&gt; (который пользователь объекта может подумать как &lt;code&gt;Fruit&lt;/code&gt; , в то время как объект в действительности привязан к &lt;code&gt;Apple&lt;/code&gt; ) может использоваться как:</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">Эти заявления выглядят ясными. Все указатели &lt;code&gt;char *&lt;/code&gt; превращаются в &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; для параметров и в &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; в обратных типах. Kotlin превращает тип &lt;code&gt;char&lt;/code&gt; в тип &lt;code&gt;kotlin.Byte&lt;/code&gt; , поскольку обычно это 8-битное значение со знаком .</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">Эти функции еще не считаются готовыми к производству, поэтому вам необходимо включить &lt;em&gt;экспериментальный режим&lt;/em&gt; в &lt;code&gt;build.gradle&lt;/code&gt; , чтобы использовать их:</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">Эти функции также могут быть использованы для преобразования коллекций в другие типы,например,построить набор из списка или наоборот.</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">Эти функции могут быть использованы для простого копирования карт:</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">Эти функции могут использоваться для поиска наименьшего и наибольшего из двух или трех заданных значений, где значения являются примитивными числами или объектами &lt;code&gt;Comparable&lt;/code&gt; . Также существует перегрузка каждой функции, которая принимает дополнительный экземпляр &lt;code&gt;Comparator&lt;/code&gt; , если вы хотите сравнить объекты, которые сами по себе не сопоставимы.</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">Эти функции имеют дело с объектами Kotlin / Native. Вызовите &lt;code&gt;DisposeStablePointer&lt;/code&gt; , чтобы освободить объект Kotlin, и &lt;code&gt;DisposeString&lt;/code&gt; , чтобы освободить строку Kotlin, которая имеет тип &lt;code&gt;char*&lt;/code&gt; в C. Можно использовать функцию &lt;code&gt;IsInstance&lt;/code&gt; , чтобы проверить, является ли тип Kotlin или &lt;code&gt;libnative_KNativePtr&lt;/code&gt; экземпляром другого типа. Фактический набор сгенерированных операций зависит от фактического использования.</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">К ним относятся &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;связанные вызываемые ссылки,&lt;/a&gt; которые указывают на член определенного экземпляра: &lt;code&gt;foo::toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">Эти операторы работают только с функцией &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; , которую можно переопределить, чтобы обеспечить реализацию пользовательской проверки равенства. Любая другая функция с таким же именем (например, &lt;code&gt;equals(other: Foo)&lt;/code&gt; ) не будет вызываться.</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">Эти варианты имеют почти такой же эффект , как лязг в &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; и swiftc - х &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">Эти задачи определены в библиотеке &lt;em&gt;kotlin-ant.jar,&lt;/em&gt; которая находится в папке &lt;em&gt;lib&lt;/em&gt; для &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;компилятора Kotlin&lt;/a&gt; Требуется Ant версии 1.8.2+.</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">Эти преобразования также могут применяться к &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; , который похож на генераторы Python и допускает ленивую оценку. Если у вас огромный список и вы хотите его лениво обработать, вы можете вызвать для него &lt;code&gt;asSequence()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">Эти две функции не могут быть определены бок о бок, потому что их подписи JVM одинаковы: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; , Если мы действительно хотим, чтобы у них было одинаковое имя в Kotlin, мы можем аннотировать один (или оба) из них с помощью &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt; и указать другое имя в качестве аргумента:</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">Эти два варианта позволяют выбрать подходящую функцию в зависимости от того,что вы будете делать дальше в своем коде.</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">Эти типы используются для сопоставления упакованных типов чисел Kotlin в Objective-C и Swift. В Swift мы можем просто вызвать конструктор для создания экземпляра, например &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">Эти типы имеют специальную нотацию,которая соответствует сигнатурам функций,т.е.их параметрам и возвращаемым значениям:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
