<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">Если вам нужен &lt;em&gt;синглтон&lt;/em&gt; - класс, у которого есть только один экземпляр - вы можете объявить класс обычным способом, но использовать ключевое слово &lt;code&gt;object&lt;/code&gt; вместо &lt;code&gt;class&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">Если вам нужен более изящный способ чтения или записи файловых данных, у вас есть доступ к полному набору классов ввода-вывода Java - в частности, &lt;code&gt;Scanner&lt;/code&gt; , который может анализировать числа и другие типы данных из файлов или других потоков, и &lt;code&gt;BufferedReader&lt;/code&gt; (который подходит для эффективного чтения больших объемов данных), которые можно получить, вызвав &lt;code&gt;bufferedReader()&lt;/code&gt; для файла или потока. См. Любое руководство по Java, чтобы узнать, как их использовать.</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">Если вам нужно привязать функцию или свойство к классу, а не к его экземплярам (аналогично &lt;code&gt;@staticmethod&lt;/code&gt; в Python), вы можете объявить их внутри &lt;em&gt;сопутствующего объекта&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">Если вам нужно несколько способов инициализировать класс, вы можете создать &lt;em&gt;вторичные конструкторы&lt;/em&gt; , каждый из которых выглядит как функция с именем &lt;code&gt;constructor&lt;/code&gt; . Каждый вторичный конструктор должен вызывать другой (первичный или вторичный) конструктор с помощью ключевого слова &lt;code&gt;this&lt;/code&gt; , как если бы это была функция (так, чтобы каждая конструкция экземпляра в конечном итоге вызывала первичный конструктор).</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">Если вам нужно получить доступ к классу, реализованному в JavaScript, из Kotlin безопасным способом, вы можете написать объявление Kotlin, используя &lt;code&gt;external&lt;/code&gt; модификатор. (В Kotlin 1.0 вместо этого использовалась аннотация &lt;code&gt;@native&lt;/code&gt; .) В отличие от целевой JVM, JS-аннотация позволяет использовать внешний модификатор с классами и свойствами. Например, вот как вы можете объявить класс DOM &lt;code&gt;Node&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">Если вам нужно аннотировать первичный конструктор класса, необходимо добавить &lt;em&gt;конструктор&lt;/em&gt; ключевое слово в объявлении конструктора, а также добавлять аннотации перед ним:</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">Если вам нужно изменить видимость аксессуара или аннотировать его,но не нужно менять реализацию по умолчанию,вы можете определить аксессуар без определения его тела:</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">Если вам нужно предоставить свойство Kotlin как поле в Java, аннотируйте его аннотацией &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt; . Поле будет иметь такую ​​же видимость, как и базовое свойство. Вы можете аннотировать свойство с помощью &lt;code&gt;@JvmField&lt;/code&gt; , если оно имеет резервное поле, не является частным, не имеет модификаторов &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;override&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; и не является делегированным свойством.</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">Если вам нужно знать индекс текущего элемента, когда вы что-то &lt;code&gt;withIndex()&lt;/code&gt; , вы можете использовать withIndex () , что соответствует &lt;code&gt;enumerate()&lt;/code&gt; . Он создает последовательность объектов, которые имеют два свойства (индекс и значение) и две специально названные функции доступа, называемые &lt;code&gt;component1()&lt;/code&gt; и &lt;code&gt;component2()&lt;/code&gt; ; Kotlin позволяет вам преобразовать такой объект в объявление:</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">Если вам также необходимо найти класс динамически, вы можете использовать &lt;code&gt;Class.forName()&lt;/code&gt; и указать полное имя класса.</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">Если вам нужно получить произвольный элемент коллекции, вызовите функцию &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; . Вы можете вызвать его без аргументов или с объектом &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt; в качестве источника случайности.</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно получить содержимое коллекции в читаемом формате, используйте функции, преобразующие коллекции в строки: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">Если вам нужно указать класс в качестве аргумента аннотации, используйте класс Kotlin ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; ). Компилятор Kotlin автоматически преобразует его в класс Java, чтобы код Java мог нормально видеть аннотации и аргументы.</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">Если вам нужно использовать в условном операторе &lt;code&gt;Boolean&lt;/code&gt; значение, допускающее значение NULL , используйте проверки &lt;code&gt;if (value == true)&lt;/code&gt; или &lt;code&gt;if (value == false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">Если вам нужно написать функцию, которая может быть вызвана без экземпляра класса, но нуждается в доступе к внутренним компонентам класса (например, к фабричному методу), вы можете записать ее как член &lt;a href=&quot;object-declarations&quot;&gt;объявления объекта&lt;/a&gt; внутри этого класса.</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">Если вы хотите вызвать только функцию и не заботитесь о метаданных, используйте тип функции, например &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; для обычной ссылки на функцию или ссылки на связанную функцию-член, или &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; для несвязанного ссылки функции на член &lt;code&gt;A&lt;/code&gt; . Обратите внимание, что &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; и его подынтерфейсы доступны только для объявленных функций (полученных либо путем явной ссылки на него в коде, либо посредством отражения, как показано ниже) - для функциональных литералов доступны только типы функций (лямбда-выражения или анонимные функции) ,</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">Если вы управляете вложенными коллекциями,то вам могут оказаться полезными стандартные библиотечные функции,обеспечивающие плоский доступ к вложенным элементам коллекции.</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">Если вы переопределите &lt;code&gt;protected&lt;/code&gt; член и не укажете видимость явно, переопределяющий член также будет иметь &lt;code&gt;protected&lt;/code&gt; видимость.</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">Если вы ранее использовали &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;поддержку Android&lt;/a&gt; для процессоров аннотаций, замените использование конфигурации &lt;code&gt;annotationProcessor&lt;/code&gt; на &lt;code&gt;kapt&lt;/code&gt; . Если ваш проект содержит классы Java, &lt;code&gt;kapt&lt;/code&gt; позаботится и о них.</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">Если вы публикуете несколько функций в экспериментальном состоянии,объявите маркер для каждой из них.Отдельные маркеры делают использование экспериментальных возможностей более безопасным для ваших клиентов:они смогут использовать только те возможности,которые они явно принимают.Это также позволяет вам выпускать функции в стабильное независимое состояние.</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">Если вам действительно нужна коллекция смешанного типа, вы можете использовать тип элемента &lt;code&gt;Any&lt;/code&gt; , но вам потребуется приведение типов, чтобы снова вернуть элементы к их правильному типу, поэтому, если вы хотите, чтобы функция возвращала несколько значений , пожалуйста, используйте вместо этого типизированную для каждого элемента &lt;code&gt;Pair&lt;/code&gt; или &lt;code&gt;Triple&lt;/code&gt; . Если вам нужно четыре или более элементов, подумайте о создании вместо этого &lt;a href=&quot;classes#data-classes&quot;&gt;класса данных&lt;/a&gt; для возвращаемого типа (что в идеале вы должны сделать и для двух или трех элементов, особенно если это общедоступная функция, поскольку она дает вам собственные имена для элементов) - это очень просто и, как правило, несложно.</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">Если вы действительно хотите,вы можете инициализировать и указать тип в одной строке.Это особенно полезно,если вы имеете дело с иерархией классов (подробнее об этом позже)и хотите,чтобы тип переменной был базовым типом класса значения:</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">Если начать с замены &lt;code&gt;GlobalScope.launch&lt;/code&gt; по &lt;code&gt;thread&lt;/code&gt; , компилятор выдаст следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">Если вы нацеливаетесь на JavaScript, используйте зависимость &lt;code&gt;stdlib-js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">Если вы используете &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt; , обратите внимание, что задачи обработки аннотаций kapt по умолчанию не кэшируются. Однако вы можете включить для них кеширование вручную. См. Подробности на &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;странице kapt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">Если вы используете Spring, вы можете включить плагин компилятора &lt;em&gt;kotlin-spring&lt;/em&gt; вместо того, чтобы указывать аннотации Spring вручную. Котлин-пружина - это обертка поверх полностью открытой, и она ведет себя точно так же.</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">Если вы используете процессоры аннотаций для &lt;code&gt;androidTest&lt;/code&gt; или &lt;code&gt;test&lt;/code&gt; источников, соответствующие конфигурации &lt;code&gt;kapt&lt;/code&gt; называются &lt;code&gt;kaptAndroidTest&lt;/code&gt; и &lt;code&gt;kaptTest&lt;/code&gt; . Обратите внимание, что &lt;code&gt;kaptAndroidTest&lt;/code&gt; и &lt;code&gt;kaptTest&lt;/code&gt; расширяют &lt;code&gt;kapt&lt;/code&gt; , поэтому вы можете просто &lt;code&gt;kapt&lt;/code&gt; зависимость kapt, и она будет доступна как для производственных источников, так и для тестов.</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">Если вы используете компилятор NV Kotlin и имеете стандартную библиотеку OV или библиотеку отражения OV в classpath,это может быть признаком того,что проект неправильно настроен.Чтобы предотвратить непредвиденные проблемы во время компиляции или во время выполнения,мы предлагаем либо обновить зависимости до NV,либо явно указать аргументы версии API/языковой версии.В противном случае компилятор обнаруживает,что что-то может пойти не так и выдает предупреждение.</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">Если вам нужен буквальный символ &lt;code&gt;$&lt;/code&gt; , вам нужно его избежать: &lt;code&gt;\$&lt;/code&gt; . Экранирование обычно работает так же, как в Python, с аналогичным набором стандартных управляющих последовательностей.</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">Если вы хотите иметь возможность перехватывать назначение и &amp;laquo;наложить вето&amp;raquo; на него, используйте &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt; вместо &lt;code&gt;observable()&lt;/code&gt; . Обработчик, переданный в &lt;code&gt;vetoable&lt;/code&gt; вызывается &lt;em&gt;до&lt;/em&gt; того, &lt;em&gt;как будет&lt;/em&gt; выполнено присвоение нового значения свойства.</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">Если вы хотите более четко указать, что вы создаете функцию, вы можете создать &lt;em&gt;анонимную функцию&lt;/em&gt; , которая по-прежнему является выражением, а не объявлением:</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">Если вы хотите проверить, &lt;em&gt;не&lt;/em&gt; является ли он экземпляром типа, используйте &lt;code&gt;!is&lt;/code&gt; . Обратите внимание, что &lt;code&gt;null&lt;/code&gt; никогда не является экземпляром какого-либо типа, не допускающего значения NULL, но всегда является &amp;laquo;экземпляром&amp;raquo; любого типа, допускающего значение NULL (даже если технически это не экземпляр, а отсутствие какого-либо экземпляра).</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите настроить свои сборки или запустить конфигурацию, обратитесь к &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;документации&lt;/a&gt; Android Studio .</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">Если вы хотите объявить API вашего модуля экспериментальным, создайте класс аннотации, который будет использоваться в качестве его &lt;em&gt;экспериментального маркера&lt;/em&gt; . Этот класс должен быть аннотирован &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">Если вы хотите сделать что-то, что не вписывается в эту схему &amp;laquo;неявного резервного поля&amp;raquo;, вы всегда можете вернуться к наличию &lt;em&gt;свойства поддержки&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите исключить последнее значение, используйте &lt;code&gt;until&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">Если вы хотите сгруппировать элементы, а затем применить операцию ко всем группам одновременно, используйте функцию &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt; . Он возвращает экземпляр типа &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;Grouping&lt;/code&gt; экземпляр позволяет применять операции по всем группам ленивым образом: группы фактически встроены непосредственно перед выполнением операции.</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите наложить дополнительные ограничения, вы должны использовать отдельное предложение &lt;code&gt;where&lt;/code&gt; , и в этом случае параметр типа должен быть подклассом данного класса (если вы указываете класс, и вы можете указать не более одного) &lt;em&gt;и&lt;/em&gt; реализовать все данные интерфейсы. Затем вы можете получить доступ ко всем открытым членам всех данных типов всякий раз, когда у вас есть значение типа &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">Если вы хотите выполнить итерацию через массив или список с индексом,вы можете сделать это таким образом:</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите, чтобы ваш код был совместим со стандартной библиотекой 1.0, вы можете передать &lt;code&gt;-api-version 1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите изучить различные функции Kotlin, попробуйте &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">Если вы хотите просмотреть метаданные функции (например, ее имя), используйте &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; или один из его подынтерфейсов, где &lt;code&gt;V&lt;/code&gt; - тип возвращаемого значения функции. Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">Если вы хотите ограничить набор подклассов базового класса, вы можете объявить базовый класс &lt;code&gt;sealed&lt;/code&gt; (что также делает его абстрактным), и в этом случае вы можете объявлять подклассы только в том же файле. Затем компилятор знает полный набор возможных подклассов, что позволит вам выполнять исчерпывающее выражение &lt;code&gt;when&lt;/code&gt; для всех возможных подтипов без необходимости в предложении &lt;code&gt;else&lt;/code&gt; (и если вы добавите еще один подкласс в будущем и забудете обновить &lt;code&gt;when&lt;/code&gt; , компилятор дам вам знать).</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">Если вы хотите,чтобы все доступные опции были запущены</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">Если вы хотите увидеть, как ваша задача будет выглядеть для учащегося, щелкните правой кнопкой &lt;code&gt;Task.kt&lt;/code&gt; файл Task.kt в окне инструмента &amp;laquo; &lt;strong&gt;Проект&amp;raquo;&lt;/strong&gt; и выберите &amp;laquo; &lt;strong&gt;Создатель курса&amp;raquo; -&amp;gt; &amp;laquo;Показать предварительный просмотр&amp;raquo;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">Если вы хотите указать пользовательскую метку для ссылки,используйте синтаксис Markdown в стиле ссылки:</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">Если вы хотите начать с нуля с задачей, используйте значок &lt;strong&gt;Сброс&lt;/strong&gt; в верхней части панели &lt;strong&gt;описания задачи&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">Если вы хотите использовать значение, только если оно удовлетворяет определенному условию, попробуйте &lt;code&gt;takeIf()&lt;/code&gt; , который возвращает вызываемое значение, если оно удовлетворяет заданному предикату, и null в противном случае. Также есть &lt;code&gt;takeUnless()&lt;/code&gt; , который меняет логику. Вы можете продолжить это с помощью &lt;code&gt;?.&lt;/code&gt; для выполнения операции над значением, только если оно удовлетворяет предикату. Ниже мы вычисляем квадрат некоторого выражения, но только если значение выражения не менее 42:</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">Если вы хотите писать строки постепенно, вам нужно создать &lt;code&gt;OutputStreamWriter&lt;/code&gt; , вызвав &lt;code&gt;writer()&lt;/code&gt; для файлового объекта. Вы можете записать двоичные данные в файл, вызвав &lt;code&gt;outputStream()&lt;/code&gt; для файлового объекта и используя полученный &lt;code&gt;OutputStream&lt;/code&gt; для записи байтов.</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">Если вы напишете то же самое без &lt;code&gt;let&lt;/code&gt; , вам придется вводить новую переменную и повторять ее имя всякий раз, когда вы ее используете.</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">Если вы используете Ubuntu 16.04 или новее, вы можете установить компилятор из командной строки:</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">Если вы предпочитаете &lt;code&gt;x.unsigned&lt;/code&gt; , вы можете определить свойство расширения:</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">Если вы пользователь &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; , вы можете установить компилятор с помощью:</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">Если вы разрабатываете библиотеку для использования другими приложениями Kotlin,вы можете создать файл .jar без включения в него времени выполнения Kotlin.</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">Если вы ориентируетесь на JDK 7 или JDK 8, вы можете использовать расширенные версии стандартной библиотеки Kotlin, которые содержат дополнительные функции расширения для API, добавленных в новые версии JDK. Вместо &lt;code&gt;kotlin-stdlib&lt;/code&gt; используйте &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; или &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; , в зависимости от вашей версии JDK (для Kotlin 1.1.x используйте &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; , поскольку аналоги &lt;code&gt;jdk&lt;/code&gt; были представлены в 1.2. +0,0).</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">Если вы ориентируетесь на платформу JVM, вы также можете напрямую использовать систему отражения Java. В этом примере мы берем ссылку на функцию из класса объекта, указывая имя функции в виде строки (если функция принимает параметры, вам также необходимо указать их типы), а затем мы вызываем ее. Обратите внимание, что мы нигде не упоминали &lt;code&gt;String&lt;/code&gt; - этот метод работает, не зная, что такое класс объекта, но он вызовет исключение, если класс объекта не имеет запрошенной функции. Однако ссылки на функции в стиле Java не содержат информации о типе, поэтому вы не получите подтверждения типов параметров, и вы должны привести возвращаемое значение:</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">Если вы используете &lt;em&gt;if&lt;/em&gt; как выражение, а не как инструкцию (например, возвращаете его значение или присваиваете его переменной), выражение должно иметь ветвь &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">Если вы используете универсальный класс, параметры типа которого не были объявлены вариантным способом (либо потому, что его авторы не думали об этом, либо потому, что параметры типа не могут иметь ни один из видов дисперсии, потому что они используются как типы параметров и возвращаемые типы), вы по-прежнему можете использовать его как вариант благодаря &lt;em&gt;проекции типов&lt;/em&gt; . Термин &amp;laquo;проекция&amp;raquo; относится к тому факту, что, когда вы делаете это, вы можете ограничить себя использованием только некоторых из его членов - так что вы в некотором смысле видите только частичную или &amp;laquo;спроецированную&amp;raquo; версию класса. Давайте еще раз посмотрим на наш класс &lt;code&gt;Bowl&lt;/code&gt; , но на этот раз без вариантов интерфейсов:</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">Если у вас есть одна строка,которую вы хотите записать в файл,перезаписывая существующее содержимое,если файл уже существует,сделайте это (опять же,UTF-8-кодировка по умолчанию):</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">Если вы только что обновились до Kotlin 1.1, но пока не можете использовать новые языковые функции (например, потому что некоторые из ваших товарищей по команде, возможно, не обновились), вы можете передать &lt;code&gt;-language-version 1.0&lt;/code&gt; , что ограничит все API и языковые функции до 1.0.</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">Если ваше приложение уже использует DBFlow,вы можете безопасно внедрить Kotlin в ваш проект.Вы можете постепенно преобразовывать существующий код в Kotlin (гарантируя,что все компилируется в процессе работы).Преобразованный код мало чем отличается от Java.Например,объявление таблицы похоже на Java с той небольшой разницей,что значения по умолчанию для свойств должны быть указаны явно:</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">Если ваш класс требует более продвинутой логики сериализации,вы можете записать его внутри класса-компаньона:</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">Если ваш код слишком умный для компилятора, и вы знаете , без помощи &lt;code&gt;is&lt;/code&gt; , что &lt;code&gt;x&lt;/code&gt; является экземпляром &lt;code&gt;Person&lt;/code&gt; , но компилятор не, вы можете &lt;em&gt;бросить&lt;/em&gt; свою ценность с , &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">Если ваш проект использует средства &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;отражения&lt;/a&gt; или тестирования Kotlin , вам также необходимо добавить соответствующие зависимости. Идентификаторы артефактов: &lt;code&gt;kotlin-reflect&lt;/code&gt; reflection для библиотеки отражения и &lt;code&gt;kotlin-test&lt;/code&gt; и &lt;code&gt;kotlin-test-junit&lt;/code&gt; для библиотек тестирования.</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">Если ваш проект использует средства &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;отражения&lt;/a&gt; или тестирования Kotlin , вам также необходимо добавить соответствующие зависимости:</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">Если,случайно,нам нужен &quot;просто объект&quot;,без нетривиальных супертипов,можно просто сказать:</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">Если при обновлении с одной версии на другую какой-то код, который раньше работал, больше не работает, это &lt;em&gt;несовместимое изменение&lt;/em&gt; языка (иногда называемое &amp;laquo;критическим изменением&amp;raquo;). В некоторых случаях могут возникать споры о том, что именно означает &amp;laquo;больше не работает&amp;raquo;, но это определенно включает следующее:</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">Непосредственные суперклассы этого класса,в порядке их перечисления в исходном коде.Включает суперклассы и суперинтерфейсы класса,но не включает сам класс.</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">Непреложность в Котлине/Отрицательная</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">Неизменяемость - это свойство времени выполнения в Kotlin / Native, и его можно применить к произвольному подграфу объекта с &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; функции kotlin.native.concurrent.freeze . Он делает все объекты доступными из данного объекта неизменяемыми, такой переход является односторонней операцией (т.е. объекты не могут быть разморожены позже). Некоторые естественно неизменяемые объекты, такие как &lt;code&gt;kotlin.String&lt;/code&gt; , &lt;code&gt;kotlin.Int&lt;/code&gt; и другие примитивные типы, а также &lt;code&gt;AtomicInt&lt;/code&gt; и &lt;code&gt;AtomicReference&lt;/code&gt; по умолчанию заморожены. Если к замороженному объекту применяется операция изменения, создается &lt;code&gt;InvalidMutabilityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">Реализация по делегации</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">Введение интерфейса может переопределить методы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">Интерфейсы реализации</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">Реализация интерфейсов в классах Enum</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">Вводит основную логику делегирования свойства для свойства чтения/записи,которое вызывает функции обратного вызова при изменении.</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">Важно: файлы, отмеченные аннотацией &lt;code&gt;@file:JsModule&lt;/code&gt; , не могут объявлять не внешние члены. В приведенном ниже примере возникает ошибка времени компиляции:</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">Импорт более глубоких пакетных иерархий</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">Импорт синтетических свойств</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">Улучшение обработки импорта</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">Улучшение анализа smartcasts путем объявления связи между результатом вызова функции и передаваемыми значениями аргументов:</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">Совершенствование анализа инициализации переменных при наличии функций высокого порядка:</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">В &amp;laquo;умных словах&amp;raquo; они говорят , что класс &lt;code&gt;C&lt;/code&gt; являются &lt;strong&gt;ковариантным&lt;/strong&gt; в параметре &lt;code&gt;T&lt;/code&gt; , или &lt;code&gt;T&lt;/code&gt; представляет собой &lt;strong&gt;ковариантный&lt;/strong&gt; параметр типа. Вы можете думать о &lt;code&gt;C&lt;/code&gt; , как будучи &lt;strong&gt;продюсером&lt;/strong&gt; из &lt;code&gt;T&lt;/code&gt; &amp;laquo;s, а не &lt;strong&gt;потребитель&lt;/strong&gt; из &lt;code&gt;T&lt;/code&gt; &amp;raquo; с.</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">В версии 1.3 мы переработали всю мультиплатформенную модель. &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Новый DSL&lt;/a&gt; у нас есть для описания мультиплатформенных проектов Gradle является гораздо более гибким, и мы будем продолжать работать над этим , чтобы сделать конфигурации проекта проста.</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">В 1.3 мы полностью переработали модель мультиплатформенных проектов,чтобы улучшить выразительность и гибкость,а также облегчить обмен общим кодом.Кроме того,Kotlin/Native теперь поддерживается как одна из целей!</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">В &lt;a href=&quot;collection-ordering&quot;&gt;разделе &amp;laquo;Упорядочивание коллекций&amp;raquo;&lt;/a&gt; мы описываем операции, которые извлекают элементы коллекции в определенном порядке. Для изменяемых списков стандартная библиотека предлагает аналогичные функции расширения, которые выполняют те же операции упорядочивания на месте. Когда вы применяете такую ​​операцию к экземпляру списка, она изменяет порядок элементов в этом конкретном экземпляре.</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">На &lt;a href=&quot;collections-overview#map&quot;&gt;картах&lt;/a&gt; типы ключей и значений определяются пользователем. Доступ к записям карты на основе ключей позволяет использовать различные возможности обработки, зависящие от карты, от получения значения по ключу до отдельной фильтрации ключей и значений. На этой странице мы предоставляем описания функций обработки карт из стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">В &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;предыдущем уроке&lt;/a&gt; мы создали файл &lt;code&gt;lib.h&lt;/code&gt; .На этот раз мы собираемся включить эти объявления непосредственно в файл &lt;code&gt;interop.def&lt;/code&gt; после строки разделителя &lt;code&gt;---&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">В проектах Android дополнительные исходные наборы Kotlin создаются для каждого &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;исходного набора Android&lt;/a&gt; . Если цель Android имеет имя &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; исходного набора Android получает аналог набора исходного кода Kotlin &lt;code&gt;fooBar&lt;/code&gt; . Однако компиляции Kotlin могут использовать исходные &lt;code&gt;src/bar/kotlin&lt;/code&gt; Kotlin из всех каталогов &lt;code&gt;src/bar/java&lt;/code&gt; , src / bar / kotlin и &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; . Исходники Java читаются только из первого из этих каталогов.</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">В Колыбели</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">В Gradle 5.3 и выше метаданные модуля всегда используются во время разрешения зависимостей, но публикации по умолчанию не включают никаких метаданных модуля. Чтобы включить публикацию метаданных модуля, добавьте &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; в файл &lt;code&gt;settings.gradle&lt;/code&gt; корневого проекта . В более старых версиях Gradle это также требуется для использования метаданных модуля.</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">В параметрах командной строки Gradle: добавьте параметр &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; или &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; с логическим значением, отражающим использование инкрементной компиляции. Обратите внимание, что в этом случае параметр следует добавлять в каждую последующую сборку, и любая сборка с отключенной инкрементной компиляцией делает недействительными инкрементные кеши.</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">В файлах конфигурации Gradle: добавьте строку &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; для Kotlin / JVM или &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; для проектов Kotlin / JS либо в &lt;code&gt;gradle.properties&lt;/code&gt; , либо в файл &lt;code&gt;local.properties&lt;/code&gt; . &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; - логическое значение, отражающее использование инкрементной компиляции.</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">В IntelliJ IDEA перейдите в &lt;em&gt;File -&amp;gt; New&amp;gt; Project&amp;hellip;&lt;/em&gt; и установите флажок &lt;em&gt;Create from archetype&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">В IntelliJ IDEA перейдите в &lt;em&gt;Файл -&amp;gt; Создать&amp;gt; Проект&amp;hellip;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">В коде платформы JVM:</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">В Java вы указываете &lt;code&gt;Dagger&lt;/code&gt; как зависимость &lt;code&gt;annotationProcessor&lt;/code&gt; (или &lt;code&gt;apt&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">В Java мы привыкли к классам с именем &amp;laquo;* Utils&amp;raquo;: &lt;code&gt;FileUtils&lt;/code&gt; , &lt;code&gt;StringUtils&lt;/code&gt; и так далее. Знаменитый &lt;code&gt;java.util.Collections&lt;/code&gt; принадлежит к той же породе. И неприятная часть этих Utils-классов заключается в том, что код, который их использует, выглядит так:</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">На Яве:</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">В JavaScript можно определить членов либо по прототипу,либо по самому классу.т.е:</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В Kotlin 1.0 код лямбда-выражения, переданный в &lt;code&gt;td&lt;/code&gt; , имеет доступ к трем неявным получателям: тот, который передается в &lt;code&gt;table&lt;/code&gt; , в &lt;code&gt;tr&lt;/code&gt; и в &lt;code&gt;td&lt;/code&gt; . Это позволяет вам вызывать методы, которые не имеют смысла в контексте - например, вызывать &lt;code&gt;tr&lt;/code&gt; внутри &lt;code&gt;td&lt;/code&gt; и, таким образом, помещать &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; в &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">В Kotlin 1.1 вы можете ограничить это, чтобы внутри лямбды, переданной &lt;code&gt;td&lt;/code&gt; , были доступны только методы, определенные в неявном получателе &lt;code&gt;td&lt;/code&gt; . Вы делаете это, определяя аннотацию, помеченную &lt;code&gt;@DslMarker&lt;/code&gt; и применяя ее к базовому классу классов тегов.</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">В Kotlin 1.1.x используйте &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; и &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">В Kotlin 1.3 аннотации могут иметь вложенные классы,интерфейсы,объекты и спутники:</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">В Kotlin 1.3 теперь можно записать объект &lt;code&gt;when&lt;/code&gt; в переменную:</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">В Котлине функции могут быть объявлены на верхнем уровне в файле,что означает,что вам не нужно создавать класс для хранения функции,что вы должны сделать на таких языках,как Java,C#или Scala.В дополнение к функциям верхнего уровня,функции Котлина могут быть объявлены локальными,как функции-членства и функции расширения.</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">В Котлине есть два типа равенства:</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">В Kotlin эту строку можно кратко проанализировать с помощью следующего оператора, используя &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;объявление деструктуризации&lt;/a&gt; из списка целых чисел:</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">В Kotlin вы можете предоставить верхние границы для общего типа.Objective-C также поддерживает это,но эта поддержка недоступна в более сложных случаях,и в настоящее время не поддерживается в Kotlin-Objective-C interop.Исключение здесь-ненулевая верхняя граница-сделает методы/свойства Objective-C ненулевыми.</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">В Kotlin нельзя работать напрямую с полями, вы работаете со &lt;a href=&quot;../reference/properties&quot;&gt;свойствами&lt;/a&gt; . Вы комментируете свойство:</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">В Kotlin вам нужно добавить плагин &lt;code&gt;kotlin-kapt&lt;/code&gt; , чтобы включить &lt;code&gt;kapt&lt;/code&gt; , а затем заменить &lt;code&gt;annotationProcessor&lt;/code&gt; на &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">В Kotlin вы указываете зависимости аналогично Java, используя &lt;a href=&quot;../reference/kapt&quot;&gt;инструмент обработки аннотаций Kotlin&lt;/a&gt; ( &lt;code&gt;kapt&lt;/code&gt; ) вместо &lt;code&gt;annotationProcessor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">В Kotlin для коллекций определены операторы &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; ) и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;-&lt;/code&gt; ). Они принимают коллекцию в качестве первого операнда; второй операнд может быть элементом или другой коллекцией. Возвращаемое значение - новая коллекция, доступная только для чтения:</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">В Kotlin &lt;em&gt;if&lt;/em&gt; является выражением, то есть возвращает значение. Следовательно, нет тернарного оператора (условие? Then: else), потому что обычный &lt;em&gt;if&lt;/em&gt; отлично работает в этой роли.</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">В Котлине все исключения не проверяются,а это значит,что компилятор не заставляет вас поймать ни одно из них.Таким образом,когда вы вызываете метод Java,который объявляет проверенное исключение,Котлин не заставляет вас ничего делать:</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">В Котлине все является объектом в том смысле,что мы можем вызывать функции-члены и свойства по любой переменной.Некоторые типы могут иметь специальное внутреннее представление-например,числа,символы и булеаны могут быть представлены в виде примитивных значений во время выполнения,но для пользователя они выглядят как обычные классы.В этом разделе мы опишем основные типы,используемые в Котлине:числа,символы,булеаны,массивы и строки.</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">В Kotlin функциональные типы представлены в виде универсальных классов, принимающих разное количество параметров: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; ,&amp;hellip; У этого подхода есть проблема в том, что этот список является конечным. , и в настоящее время заканчивается на &lt;code&gt;Function22&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">В Kotlin наследование реализаций регулируется следующим правилом: если класс наследует множество реализаций одного и того же члена от своих непосредственных суперклассов, он должен переопределить этот член и предоставить свою собственную реализацию (возможно, используя одну из унаследованных). Чтобы обозначить супертип, от которого взята унаследованная реализация, мы используем &lt;em&gt;супер-&lt;/em&gt; квалификацию именем супертипа в угловых скобках, например &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">В Kotlin импорт - это концепция времени компиляции - импорт чего-либо фактически не вызывает запуска какого-либо кода (в отличие от Python, где все операторы верхнего уровня в файле выполняются во время импорта). Следовательно, циклический импорт разрешен, но он может указывать на проблему дизайна в вашем коде. Однако во время выполнения класс будет загружен при первом обращении к нему (или любому из его свойств или функций), а загрузка класса вызывает инициализацию &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;сопутствующих объектов&lt;/a&gt; - это может привести к исключениям времени выполнения, если у вас есть циклические зависимости.</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">В Kotlin полиморфизм достигается через иерархию классов таким образом, что невозможно столкнуться с ситуацией, когда свойство или функция отсутствуют. Основное правило состоит в том , что / Свойстве / параметр переменного, объявленный типа может относиться к экземпляру класса &lt;code&gt;B&lt;/code&gt; , если и только если &lt;code&gt;B&lt;/code&gt; является подтипом &lt;code&gt;A&lt;/code&gt; . Это означает, что либо &lt;code&gt;A&lt;/code&gt; должен быть классом, а &lt;code&gt;B&lt;/code&gt; должен быть подклассом &lt;code&gt;A&lt;/code&gt; , либо &lt;code&gt;A&lt;/code&gt; должен быть интерфейсом, а &lt;code&gt;B&lt;/code&gt; должен быть классом, который реализует этот интерфейс, или быть подклассом класса, который это делает. С помощью наших классов и интерфейсов из предыдущих разделов мы можем определить эти функции: &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">В Kotlin реализацией &lt;code&gt;List&lt;/code&gt; по умолчанию является &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; ,&lt;/a&gt; который можно рассматривать как массив с изменяемым размером.</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">В Котлине выражение для значения по умолчанию вычисляется каждый раз при вызове функции.Таким образом,вы избежите описанной выше ловушки до тех пор,пока будете использовать выражение,которое создает новый список при каждом его вычислении:</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">В Котлине порядок следования объектов может быть определен несколькими способами.</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">В Kotlin система типов различает ссылки, которые могут содержать &lt;em&gt;null&lt;/em&gt; (ссылки, допускающие значение NULL), и ссылки, которые не могут содержать (ненулевые ссылки). Например, обычная переменная типа &lt;code&gt;String&lt;/code&gt; не может содержать &lt;em&gt;null&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">В Котлине существует соглашение:если последним параметром функции является функция,то выражение лямбда,переданное в качестве соответствующего аргумента,может быть помещено вне круглых скобок:</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">В Kotlin есть способ объяснить компилятору такие вещи. Это называется &lt;strong&gt;вариацией на объекте объявления&lt;/strong&gt; : мы можем аннотировать &lt;strong&gt;параметр типа &lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; для Source, чтобы убедиться, что он только &lt;strong&gt;возвращается&lt;/strong&gt; (создается) из членов &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; и никогда не используется. Для этого мы предоставляем модификатор &lt;strong&gt;out&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">В Котлине,в отличие от Java или C#,классы не имеют статических методов.В большинстве случаев рекомендуется просто использовать функции на уровне пакетов.</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">В Kotlin мы можем использовать только обычный, неквалифицированный &lt;code&gt;return&lt;/code&gt; для выхода из именованной функции или анонимной функции. Это означает, что для выхода из лямбды мы должны использовать &lt;a href=&quot;returns#return-at-labels&quot;&gt;метку&lt;/a&gt; , а простой &lt;code&gt;return&lt;/code&gt; запрещен внутри лямбда, потому что лямбда не может вернуть возвращающую функцию:</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">В Мавене</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">В Maven включите плагин &lt;code&gt;jpa&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">В Maven включите плагин &lt;code&gt;spring&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">В Python имена функций должны быть уникальными в пределах модуля или класса. В Kotlin мы можем &lt;em&gt;перегружать&lt;/em&gt; функции: может быть несколько объявлений функций с одинаковыми именами. Перегруженные функции должны отличаться друг от друга по спискам параметров. (Типы списка параметров вместе с типом возвращаемого значения известны как &lt;em&gt;сигнатура&lt;/em&gt; функции , но тип возвращаемого значения не может использоваться для устранения неоднозначности перегруженных функций.) Например, мы можем иметь обе эти функции в одном файле:</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">В Python выражение для значения по умолчанию оценивается один раз во время определения функции. Это приводит к этой классической ловушке, когда разработчик надеется получать новый пустой список каждый раз, когда функция вызывается без значения для &lt;code&gt;numbers&lt;/code&gt; , но вместо этого каждый раз используется один и тот же список:</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">В операторе &lt;code&gt;when&lt;/code&gt; , если ветвь состоит более чем из одной строки, рассмотрите возможность отделения ее от соседних блоков case пустой строкой:</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">В долго работающем приложении вам может потребоваться детальный контроль над фоновыми сопрограммами. Например, пользователь мог закрыть страницу, на которой была запущена сопрограмма, и теперь ее результат больше не нужен, и ее работу можно отменить. Функция &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;запуска&lt;/a&gt; возвращает &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;задание,&lt;/a&gt; которое можно использовать для отмены работающей сопрограммы:</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">В члене &lt;a href=&quot;classes#inheritance&quot;&gt;класса&lt;/a&gt; , &lt;em&gt;это&lt;/em&gt; относится к текущему объекту этого класса.</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">Короче говоря, вы можете использовать такие библиотеки, как &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; или &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding,&lt;/a&gt; в своих проектах Kotlin.</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">В дополнение к &lt;strong&gt;out&lt;/strong&gt; , Kotlin предоставляет дополнительную аннотацию дисперсии: &lt;strong&gt;in&lt;/strong&gt; . Это делает параметр типа &lt;strong&gt;контравариантным&lt;/strong&gt; : его можно только потреблять, но не производить. Хороший пример контравариантного типа - &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">В дополнение к обычным операциям для получения &lt;a href=&quot;collection-parts&quot;&gt;частей коллекции&lt;/a&gt; , списки предоставляют &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt; которая возвращает представление указанного диапазона элементов в виде списка. Таким образом, если элемент исходной коллекции изменяется, он также изменяется в ранее созданных подсписках и наоборот.</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">Помимо удаления элементов, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt; также может вставлять и заменять элементы во время итерации списка.</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">В дополнение к функциям области видимости стандартная библиотека содержит функции &lt;code&gt;takeIf&lt;/code&gt; и &lt;code&gt;takeUnless&lt;/code&gt; . Эти функции позволяют встраивать проверки состояния объекта в цепочки вызовов.</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">В дополнение к этому вы можете использовать &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; для доступа к экземпляру &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass,&lt;/a&gt; соответствующему классу. Сам экземпляр &lt;code&gt;JsClass&lt;/code&gt; является ссылкой на функцию-конструктор. Это можно использовать для взаимодействия с функциями JS, которые ожидают ссылки на конструктор.</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">В дополнение к &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; показанной выше, вам необходимо добавить зависимость от стандартной библиотеки Kotlin:</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">В дополнение к задачам сборки сборка Gradle включает полезные задачи для запуска приложения напрямую через &lt;code&gt;runDebugExecutableNative&lt;/code&gt; и &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">В дополнение к операциям изменения коллекции, описанным в разделе &amp;laquo;Операции записи в &lt;a href=&quot;collection-write&quot;&gt;коллекцию&amp;raquo;&lt;/a&gt; , &lt;a href=&quot;collections-overview#collection-types&quot;&gt;изменяемые&lt;/a&gt; списки поддерживают определенные операции записи. Такие операции используют индекс для доступа к элементам, чтобы расширить возможности изменения списка.</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">Кроме компилятора командной строки и IntelliJ IDEA,вы также можете собирать проекты Kotlin с помощью Ant,Maven и Gradle.</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">В дополнение к области сопрограмм, предоставляемой разными конструкторами, можно объявить свою собственную область действия с помощью построителя &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; . Он создает область сопрограммы и не завершается, пока не завершатся все запущенные дочерние элементы. Основное различие между &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; заключается в том, что последний не блокирует текущий поток, ожидая завершения всех дочерних элементов .</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">В дополнение к выходному файлу JavaScript плагин по умолчанию создает дополнительный файл JS с двоичными дескрипторами. Этот файл необходим, если вы создаете повторно используемую библиотеку, от которой могут зависеть другие модули Kotlin, и должен распространяться вместе с результатом перевода. Генерация контролируется опцией &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">Кроме того,Rx внедряет несколько более приятный подход к обработке ошибок.</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">Кроме того, каждый из них также имеет соответствующий &lt;code&gt;{file}.meta.js&lt;/code&gt; который будет использоваться для отражения и других функций.</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">Во всех случаях строка на C должна быть закодирована как UTF-8.</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">Во всех отношениях это то же самое,что и в Java,так как доступ к приватным свойствам с установленными по умолчанию геттерами и сеттерами оптимизирован таким образом,чтобы не возникало никаких накладных расходов на вызов функций.</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">В &lt;a href=&quot;extensions&quot;&gt;функции расширения&lt;/a&gt; или &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;функциональном литерале с получателем &lt;/a&gt;&lt;em&gt;это&lt;/em&gt; обозначает параметр &lt;em&gt;получателя,&lt;/em&gt; который передается в левой части точки.</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">В определении встроенной функции вы можете использовать &lt;code&gt;noinline&lt;/code&gt; перед любым параметром, типизированным для функции, чтобы предотвратить встраивание лямбда-выражения, которое будет передано ему.</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">В любых списках вы можете найти позицию элемента с помощью функций &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt; . Они возвращают первую и последнюю позицию элемента, равного заданному аргументу в списке. Если таких элементов нет, обе функции возвращают &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">В подходе это довольно похоже на фьючерсы,но можно думать о будущем,как о возвращении дискретного элемента,при котором Rx возвращает поток.Однако,подобно предыдущему,он также вводит совершенно новый способ мышления о нашей модели программирования,известный как</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">В случае,если любые две записи привязаны к равным клавишам,значение последней перезапишет значение,связанное с первой.</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">В случае, если ресурс закрывается из-за исключения, возникшего в &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;блоке&lt;/a&gt; , и закрытие также не удается с исключением, последнее добавляется к &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;подавленным&lt;/a&gt; исключениям первого.</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">В случае,если есть непустые строки без лидирующих пробельных символов (без отступа вообще),то общий отступ равен 0,и поэтому данная функция не изменяет отступ.</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">В случае конфликта имен между членами получателя отправки и получателя расширения приоритет имеет получатель расширения. Чтобы обратиться к члену получателя отправки, вы можете использовать &lt;a href=&quot;this-expressions#qualified&quot;&gt;уточненный синтаксис &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">В случае свойства расширения в классе,первым должен быть передан экземпляр класса,а вторым-экземпляр приемника расширения.</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">В случае, если этот тип основан на внутреннем классе, возвращаемый список содержит аргументы типа, предоставленные сначала для самого внутреннего класса, затем его внешнего класса и так далее. Например, для типа &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; возвращаемый список будет &lt;code&gt;[C, D, A, B]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">Если вы хотите, чтобы во встроенную функцию была встроена только часть лямбда-выражений, вы можете пометить некоторые параметры функции с &lt;code&gt;noinline&lt;/code&gt; модификатора noinline :</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">Если вам интересно, как после &lt;code&gt;use&lt;/code&gt; , то есть функции, может следовать такой блок, см. Раздел о &lt;a href=&quot;functional-programming#receivers&quot;&gt;поддержке DSL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">В общем коде:</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">По сути,это позволяет использовать следующий код:</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">Фактически,для декларирования свойств и их инициализации из первичного конструктора Котлин имеет лаконичный синтаксис:</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">В последующих разделах эти концепции более подробно описываются вместе с DSL для их настройки в проекте.</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">В общем,для небольших проектов мы рекомендуем конвертировать все файлы сразу.</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">Как правило, идентификаторы могут состоять из букв, цифр и знаков подчеркивания и не могут начинаться с цифры. Однако, если вы пишете код, который, например, автоматически генерирует JSON на основе идентификаторов, и вы хотите, чтобы ключ JSON был строкой, которая не соответствует этим правилам или конфликтует с ключевым словом, вы можете заключить его в обратные кавычки: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; - допустимый идентификатор.</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">В общем случае,если определенная синтаксическая конструкция в Kotlin является необязательной и выделена IDE как избыточная,ее следует опустить в коде.Не оставляйте лишних синтаксических элементов в коде просто &quot;для наглядности&quot;.</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">В общем случае,для создания экземпляра такого класса необходимо указать аргументы типа:</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">В сгенерированном коде компилятор Kotlin хранит &lt;em&gt;оболочку&lt;/em&gt; для каждого встроенного класса. Встроенные экземпляры классов могут быть представлены во время выполнения либо как оболочки, либо как базовый тип. Это похоже на то, как &lt;code&gt;Int&lt;/code&gt; может быть &lt;a href=&quot;basic-types#representation&quot;&gt;представлен&lt;/a&gt; либо как примитив &lt;code&gt;int&lt;/code&gt; , либо как &lt;code&gt;Integer&lt;/code&gt; - оболочка .</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">В лямбда-выражениях следует использовать пробелы вокруг фигурных скобок,а также вокруг стрелки,которая отделяет параметры от тела.Если вызов принимает одну лямбду,она должна быть по возможности передана за пределами круглых скобок.</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">В коротких и не вложенных лямбдах рекомендуется использовать соглашение &lt;code&gt;it&lt;/code&gt; вместо явного объявления параметра. Во вложенных лямбдах с параметрами параметры всегда следует объявлять явно.</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">В длинных списках аргументов поставьте перенос строки после открывающей круглой скобки.Аргументы отступать на 4 пробела.Группировать несколько тесно связанных аргументов в одну строку.</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">Во многих случаях нет необходимости использовать явные операторы приведения в Kotlin, потому что компилятор отслеживает &lt;code&gt;is&lt;/code&gt; -checks и &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;явные приведения&lt;/a&gt; для неизменяемых значений и автоматически вставляет (безопасные) приведения при необходимости:</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">В проектах со смешанными языками исходные файлы Kotlin должны находиться в том же корневом каталоге,что и исходные файлы Java,и иметь ту же структуру каталогов (каждый файл должен храниться в каталоге,соответствующем каждому оператору пакета).</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">В модулях, которые не предоставляют свой собственный API, например в модулях приложений, вы можете использовать экспериментальные API, не передавая экспериментальный статус вашему коду. В этом случае отметьте свой код &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;аннотацией @UseExperimental (Marker :: class),&lt;/a&gt; указав аннотацию маркера экспериментального API:</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">В большинстве случаев Котлин следует конвенциям о кодировании на Java.</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">В многострочном режиме выражения &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; соответствуют сразу после или непосредственно перед символом конца строки или концом входной последовательности.</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">Чтобы собрать приложение, нам также необходимо включить стандартную библиотеку Kotlin, то есть &lt;code&gt;kotlin.js&lt;/code&gt; , которая была включена в качестве зависимости, и другие библиотеки, если таковые имеются.</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Чтобы избежать проблем с совместимостью во время сборки Xcode, плагину требуется использовать &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;оболочку Gradle&lt;/a&gt; . Чтобы автоматически сгенерировать оболочку во время выполнения задачи &lt;code&gt;podspec&lt;/code&gt; , запустите ее с параметром &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">Чтобы создать проект Kotlin с помощью Gradle, вы должны &lt;a href=&quot;#plugin-and-versions&quot;&gt;настроить плагин &lt;em&gt;kotlin-gradle&lt;/em&gt;&lt;/a&gt; , &lt;a href=&quot;#targeting-the-jvm&quot;&gt;применить его&lt;/a&gt; к своему проекту и &lt;a href=&quot;#configuring-dependencies&quot;&gt;добавить зависимости &lt;em&gt;kotlin-stdlib&lt;/em&gt;&lt;/a&gt; . Эти действия также могут выполняться автоматически в IntelliJ IDEA путем вызова &lt;strong&gt;Tools | Котлин | Настройте Kotlin&lt;/strong&gt; в действии &lt;strong&gt;Project&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">Чтобы скомпилировать код JavaScript, вам необходимо использовать цели &lt;code&gt;js&lt;/code&gt; и &lt;code&gt;test-js&lt;/code&gt; для выполнения &lt;code&gt;compile&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">Для отладки приложения с помощью IntelliJ IDEA нам необходимо выполнить два шага:</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">Чтобы сгенерировать эти привязки, нам нужно создать файл определения библиотеки &lt;code&gt;.def&lt;/code&gt; , который содержит некоторую информацию о заголовках, которые нам нужно сгенерировать. В нашем случае мы хотим использовать знаменитую библиотеку &lt;code&gt;libcurl&lt;/code&gt; для выполнения некоторых HTTP-вызовов, поэтому мы создадим файл с именем &lt;code&gt;libcurl.def&lt;/code&gt; со следующим содержимым</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">Для запуска нам нужны соответствующие WAR для развертывания. Мы можем сгенерировать их, используя &lt;em&gt;военную&lt;/em&gt; задачу в Gradle, которую можно легко выполнить через окно инструмента Gradle в IntelliJ IDEA.</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">Чтобы поделиться изменениями в папке &lt;code&gt;.idea/codeStyle&lt;/code&gt; разработчиков проекта , ее необходимо зафиксировать в VCS. В качестве альтернативы &lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;obsolete&lt;/strong&gt; можно использовать для проектов, настроенных с помощью Gradle или Maven.</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">Чтобы поделиться этими изменениями со всеми разработчиками &lt;code&gt;.idea/codeStyle&lt;/code&gt; папку .idea / codeStyle необходимо привязать к VCS.</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">Для того,чтобы указать тип модуля,мы можем добавить конфигурацию в наш плагин,как показано ниже</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">Для поддержки потенциально обнуляемого типа заголовок Objc должен определять &lt;code&gt;myVal&lt;/code&gt; с возвращаемым значением, допускающим обнуление .</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">Чтобы использовать Gradle для таргетинга на JavaScript, нам нужно использовать плагин &lt;code&gt;kotlin2js&lt;/code&gt; , а не плагин &lt;code&gt;kotlin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">Для того,чтобы использовать Kotlin с node.js,необходимо задать компилятору опцию использования CommonJS.После этого выход приложения должен быть доступен через систему модулей узлов.</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">Чтобы использовать сопрограммы, а также следовать примерам в этом руководстве, вам необходимо добавить зависимость от &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; как описано &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;в проекте README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">Для того,чтобы использовать что-то из пакета,достаточно использовать имя пакета,чтобы полностью квалифицировать имя символа в том месте,где вы используете символ:</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">Чтобы использовать это, нам также необходимо включить стандартную библиотеку Kotlin в наше приложение, то есть &lt;code&gt;kotlin.js&lt;/code&gt; , которая была включена в качестве зависимости. По умолчанию Maven не расширяет JAR как часть процесса сборки, поэтому для этого нам нужно будет добавить дополнительный шаг в нашу сборку.</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">Другими словами, встроенные классы представляют действительно &lt;em&gt;новый&lt;/em&gt; тип, в отличие от псевдонимов типов, которые вводят только альтернативное имя (псевдоним) для существующего типа:</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">В нашем DSL все классы тегов расширяют один и тот же суперкласс &lt;code&gt;Tag&lt;/code&gt; . Достаточно аннотировать только суперкласс с помощью &lt;code&gt;@HtmlTagMarker&lt;/code&gt; , и после этого компилятор Kotlin будет обрабатывать все унаследованные классы как аннотированные:</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">В нашем примере у нас есть функция &lt;code&gt;main&lt;/code&gt; , которая превращается в сопрограмму с помощью &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;конструктора&lt;/a&gt; сопрограмм runBlocking . Каждый построитель сопрограмм, включая &lt;code&gt;runBlocking&lt;/code&gt; , добавляет экземпляр &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; в область своего блока кода. Мы можем запускать сопрограммы в этой области без явного &lt;code&gt;join&lt;/code&gt; ним, потому что внешняя сопрограмма ( &lt;code&gt;runBlocking&lt;/code&gt; в нашем примере) не завершается, пока не будут выполнены все сопрограммы, запущенные в ее области. Таким образом, мы можем упростить наш пример:</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">В нашей основной функции мы создаем активность, вызываем нашу тестовую функцию &lt;code&gt;doSomething&lt;/code&gt; и уничтожаем активность через 500 мс. Это отменяет все запущенные сопрограммы, что мы можем подтвердить, отметив, что они больше не выводятся на экран, если мы подождем:</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">В частности,при определении функций расширения для класса,которые актуальны для всех клиентов этого класса,поместите их в тот же файл,где определяется сам класс.При определении функций расширения,которые имеют смысл только для конкретного клиента,поместите их рядом с кодом этого клиента.Не создавайте файлы только для хранения &quot;всех расширений Foo&quot;.</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">На практике некоторые изменения не могут быть точно обнаружены во время компиляции,поэтому о них нельзя сообщать,но,по крайней мере,пользователи будут уведомлены через Release notes версии A о том,что в версии B происходят изменения.</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">На практике затрагивается довольно много кода,поэтому это можно считать основным обновлением стиля кода.</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">На практике ограничение нити осуществляется большими кусками,например,большие куски модернизирующей состояние бизнес-логики ограничиваются одной нитью.В следующем примере так и происходит,запуская каждую коруэтину в однопоточном контексте для начала.</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">В прогрессивном режиме некоторые исправления в семантике языка могут поступить немедленно.Все эти исправления имеют два важных свойства:</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">В чистых проектах Kotlin рекомендуемая структура каталогов должна следовать структуре пакетов с пропущенным общим корневым пакетом (например,если весь код в проекте находится в пакете &quot;org.example.kotlin&quot; и его подпакетах,файлы с пакетом &quot;org.example.kotlin&quot; должны быть помещены непосредственно под корень исходных текстов,а файлы в &quot;org.example.kotlin.foo.bar&quot; должны быть в подкаталоге &quot;foo/bar&quot; корня исходных текстов).</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">Вкратце: &lt;em&gt;тщательно продумайте свои объявления целых чисел и будьте абсолютно уверены, что значение никогда не должно быть больше, чем пределы типа! &lt;/em&gt;Если вам нужно целое число неограниченного размера, используйте непримитивный тип &lt;code&gt;BigInteger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">В подобных ситуациях мы можем использовать &lt;code&gt;dynamic&lt;/code&gt; тип, который позволяет нам работать с динамическими типами при нацеливании на JavaScript. Следующая переменная объявлена ​​как &lt;code&gt;dynamic&lt;/code&gt; что означает, что все, что мы вызываем для нее, не приведет к ошибке времени компиляции:</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">В некоторых случаях (например, для поддержки перегрузок) компилятор Kotlin изменяет имена сгенерированных функций и атрибутов в коде JavaScript. Для управления сгенерированными именами вы можете использовать аннотацию &lt;code&gt;@JsName&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">В некоторых случаях функции без аргументов могут быть взаимозаменяемы со свойствами,доступными только для чтения.Несмотря на сходство семантики,существуют некоторые стилистические соглашения о том,когда предпочитать друг другу.</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">В некотором смысле это легче читать, потому что операции указываются в том порядке, в котором они применяются к значениям. Результатом будет неизменяемый &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; , где &lt;code&gt;T&lt;/code&gt; - это тот тип, который создается используемыми вами преобразованиями (в данном случае &lt;code&gt;String&lt;/code&gt; ). Если вам нужен изменяемый список, вызовите &lt;code&gt;toMutableList()&lt;/code&gt; в конце. Если вам нужен набор, вызовите &lt;code&gt;toSet()&lt;/code&gt; или &lt;code&gt;toMutableSet()&lt;/code&gt; в конце. Если вы хотите преобразовать коллекцию в карту, вызовите &lt;code&gt;associateBy()&lt;/code&gt; , которая принимает две лямбда-выражения, указывающие, как извлечь ключ и значение из каждого элемента: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (вы можете опустить вторую лямбду, если хотите, чтобы весь элемент был значением, и вы можете вызвать &lt;code&gt;toMutableMap()&lt;/code&gt; в конце, если хотите, чтобы результат был изменяемым).</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">Несмотря на использование ключевого слова &lt;code&gt;object&lt;/code&gt; , новый экземпляр анонимного класса будет создаваться всякий раз, когда вычисляется выражение объекта.</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">Несмотря на это синтаксическое удобство, сопутствующий объект сам по себе является подходящим объектом и может иметь свои собственные супертипы, и вы можете назначить его переменной и передавать ее. Если вы интегрируетесь с кодом Java и вам нужен настоящий &lt;code&gt;static&lt;/code&gt; член, вы можете &lt;a href=&quot;annotations&quot;&gt;аннотировать&lt;/a&gt; член внутри сопутствующего объекта с помощью &lt;code&gt;@JvmStatic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">В последующих уроках мы покажем,как можно влиять на генерируемые файлы,например,изменять местоположение,префиксы и суффиксы,а также как работать с модулями.</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">В тестах (и только в тестах)допустимо использовать названия методов с пробелами,заключенными в черные метки.(Обратите внимание,что такие имена методов в настоящее время не поддерживаются во время выполнения Android).Подчеркивания в именах методов также допустимы в тестовом коде.</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">В этом случае вам нужно использовать оператор распространения &lt;code&gt;*&lt;/code&gt; для передачи &lt;code&gt;IntArray&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">В &lt;a href=&quot;#enabling-experimental-features&quot;&gt;экспериментальном режиме&lt;/a&gt; вы можете указать любое имя варианта (не только разновидность), например, &lt;code&gt;freeDebug&lt;/code&gt; или &lt;code&gt;freeRelease&lt;/code&gt; также будут работать.</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">В &lt;code&gt;libnative_api.h&lt;/code&gt; мы найдем следующий код. Мы будем обсуждать код по частям, чтобы его было легче понять.</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">В зависимости Gradle, которые вы используете, добавьте плагин &lt;code&gt;kotlin-kapt&lt;/code&gt; и замените &lt;code&gt;annotationProcessor&lt;/code&gt; на &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">В мире JavaScript доступен совершенно другой набор API,поэтому можно было бы вместо этого реализовать протоколирование в консоли:</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше коде, параметр &lt;code&gt;combine&lt;/code&gt; имеет &lt;a href=&quot;#function-types&quot;&gt;тип функции &lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; , так что она принимает функция , которая принимает два аргумента типов &lt;code&gt;R&lt;/code&gt; и &lt;code&gt;T&lt;/code&gt; , и возвращает значение типа &lt;code&gt;R&lt;/code&gt; . Он &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;вызывается&lt;/a&gt; внутри цикла &lt;em&gt;for&lt;/em&gt; , а затем возвращаемое значение присваивается &lt;code&gt;accumulator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">В приведенном выше примере производственные источники для целевой JVM компилируются посредством ее &lt;code&gt;main&lt;/code&gt; компиляции и, следовательно, включают источники и зависимости из исходных наборов &lt;code&gt;jvmMain&lt;/code&gt; и &lt;code&gt;commonMain&lt;/code&gt; (из-за &lt;em&gt;зависимости от&lt;/em&gt; отношения):</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">В приведенном ниже примере мы предполагаем, что существует базовый класс &lt;code&gt;DbModel&lt;/code&gt; и что каждый подкласс имеет первичный конструктор без параметров. Во встроенной функции &lt;code&gt;T&lt;/code&gt; реифицируется, поэтому мы можем получить метаданные класса. Мы передаем это функции, которая выполняет реальную работу по общению с базой данных.</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">В этом примере у нас есть наиболее популярные способы передать или получить строку на языке C. Мы должны осторожно относиться к возврату &lt;code&gt;return_string&lt;/code&gt; . В общем, лучше убедиться, что мы используем правильную функцию для удаления возвращенного &lt;code&gt;char*&lt;/code&gt; с правильным вызовом функции &lt;code&gt;free(..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">В следующем примере &lt;code&gt;findViewById()&lt;/code&gt; вызывается только один раз:</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">В сгенерированных объявлениях Kotlin мы видим, что &lt;code&gt;str&lt;/code&gt; представлена ​​как &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; , Тип допускает значение NULL, и мы можем просто передать Kotlin &lt;code&gt;null&lt;/code&gt; в качестве значения параметра.</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">В сгенерированном коде &lt;code&gt;provideDelegate&lt;/code&gt; метод provideDelegate для инициализации вспомогательного свойства &lt;code&gt;prop$delegate&lt;/code&gt; . Сравните сгенерированный код для объявления свойства &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; со сгенерированным кодом &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;выше&lt;/a&gt; (когда метод &lt;code&gt;provideDelegate&lt;/code&gt; отсутствует):</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">В последней строке на &lt;code&gt;button&lt;/code&gt; ссылается &lt;code&gt;id&lt;/code&gt; с использованием плагина &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; . Рассмотрите возможность использования этого плагина в качестве альтернативы, которая позволяет сохранить логику привязки в коде и в то же время иметь краткий синтаксис.</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">В последней строке есть неявное &lt;code&gt;this.&lt;/code&gt; перед &lt;code&gt;memberFunction()&lt;/code&gt; и &lt;code&gt;memberProperty&lt;/code&gt; (если они существуют в типе &lt;code&gt;someExpression&lt;/code&gt; ). Возвращаемое значение - это последнее выражение.</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">В следующем диалоге укажите детали проекта:</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">В старой модели общий и зависящий от платформы код нужно было разместить в отдельных модулях, связанных зависимостями &lt;code&gt;expectedBy&lt;/code&gt; . Теперь общий и зависящий от платформы код помещается в разные исходные корни одного модуля, что упрощает настройку проектов.</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">При наличии плагина &lt;code&gt;maven-publish&lt;/code&gt; создаются публикации для всех собранных двоичных файлов. Плагин использует метаданные Gradle для публикации артефактов, поэтому эта функция должна быть включена (см. Раздел о &lt;a href=&quot;#dependencies&quot;&gt;зависимостях&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">В предыдущем примере модуль JavaScript экспортирует один пакет. Однако некоторые библиотеки JavaScript экспортируют несколько пакетов из модуля. Этот случай также поддерживается Kotlin, хотя вы должны объявлять новый файл &lt;code&gt;.kt&lt;/code&gt; для каждого импортируемого пакета.</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">В учебнике мы узнаем:</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">В учебнике мы:</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">В этом случае компилятор не будет загружен плагином.</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">В этом случае JQuery будет импортирован как модуль с именем &lt;code&gt;jquery&lt;/code&gt; . В качестве альтернативы его можно использовать как $ -объект, в зависимости от того, для какой модульной системы настроен компилятор Kotlin.</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">В этом случае мы установили вывод нашей компиляции в папку &lt;code&gt;scripts&lt;/code&gt; . При запуске приложения мы должны увидеть следующий вывод:</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">В этом плотном коде, в дополнение к преобразованиям коллекций, вы можете увидеть такие удобные функции Kotlin, как локальные функции и &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;оператор elvis &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; , Которые позволяют выражать &lt;a href=&quot;../reference/idioms&quot;&gt;идиомы,&lt;/a&gt; такие как &amp;laquo;принять значение, если оно положительное, или использовать длину&amp;raquo; с кратким и читаемые выражения, такие как &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; , но Kotlin прекрасно умеет создавать дополнительные изменяемые переменные и выражать тот же код в императивном стиле.</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">В этой док-станции мы иногда будем без необходимости указывать тип,чтобы выделить,какой тип производится выражением.(Также,хорошая IDE сможет показать вам результирующий тип).</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">В этом документе мы вводим несколько видов совместимости:</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">В этом примере должны быть доступны только члены ближайшего неявного получателя &lt;code&gt;this@head&lt;/code&gt; ; &lt;code&gt;head()&lt;/code&gt; является членом внешнего получателя &lt;code&gt;this@html&lt;/code&gt; , поэтому его вызов должен быть незаконным.</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">В этом примере мы запускаем новую сопрограмму в фоновом пуле потоков с помощью &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; , поэтому она работает с потоками, отличными от пула потоков, но по-прежнему имеет значение локальной переменной потока, которое мы указали с помощью &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; независимо от того, в каком потоке выполняется сопрограмма. Таким образом, вывод (с &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;отладкой&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">В этом примере все значения, переданные в C API &lt;code&gt;new_menu()&lt;/code&gt; имеют время жизни самого внутреннего &lt;code&gt;memScope&lt;/code&gt; ,которому оно принадлежит. Как только поток управления покидает область &lt;code&gt;memScoped&lt;/code&gt; , указатели C становятся недействительными.</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">В этом примере конструктор берет карту:</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">В данном примере обработка последовательности выполняет 18 шагов вместо 23 шагов для того,чтобы делать то же самое со списками.</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">В этом примере, используя &lt;code&gt;Person&lt;/code&gt; и &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; из предыдущего раздела, мы находим ссылку на функцию-член по имени и вызываем ее:</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">В этой функции и &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume,&lt;/a&gt; и &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; могут использоваться либо синхронно в одном стековом кадре, где выполняется функция приостановки, либо асинхронно позже в том же потоке или из другого потока выполнения. Повторный вызов любой функции возобновления вызывает &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключение IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">В этой функции и &lt;a href=&quot;resume&quot;&gt;Continuation.resume,&lt;/a&gt; и &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; могут использоваться либо синхронно в том же стеке, где выполняется функция приостановки, либо асинхронно позже в том же потоке или из другого потока выполнения. Последующий вызов любой функции возобновления вызовет &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключение IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">В этом разделе показан комментированный DSL. См. Также примеры проектов, в которых используется этот плагин, например &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt; , &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;http-клиент MPP.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">В этом учебнике мы научимся:</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">Однако в этом руководстве мы увидим, как использовать некоторые конкретные библиотеки, такие как &lt;code&gt;libcurl&lt;/code&gt; . Мы научимся</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">В этом учебнике,который у нас есть:</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">В этом учебнике мы посмотрим,как работать со струнами на C в Котлине/Натив.Мы научимся:</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">В этом учебнике мы создадим приложение для iOS и Android,используя возможности Kotlin по совместному использованию кода.Для Android мы будем использовать Kotlin/JVM,в то время как для iOS это будет Kotlin/Native.</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">В этом учебнике мы посмотрим,как</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">В этом уроке мы рассмотрим шаги,необходимые для использования плагина Kotlin Android Extensions,расширяющего опыт разработки Android.</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">В этом уроке мы рассмотрим необходимые шаги. Более подробное объяснение Spring Boot и Kotlin см. В разделе &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Создание веб-приложений с помощью Spring Boot и Kotlin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">В этом учебнике мы будем:</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">В этом руководстве мы собираемся использовать IntelliJ IDEA. Инструкции о том, как компилировать и выполнять приложения Kotlin с помощью компилятора командной строки, см. В разделе &lt;a href=&quot;command-line&quot;&gt;Работа с компилятором командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">В этом уроке мы увидели,как создать Kotlin-приложение,ориентированное на JavaScript,отладить его,а также установить опции компилятора.В других учебниках мы рассмотрим более подробно такие темы,как взаимодействие с DOM и др.</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">В этом уроке мы узнаем,какие типы данных C видны в Котлине/Отрицательном и наоборот.Мы узнаем:</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">В этом руководстве мы рассмотрим, как мы можем использовать код Kotlin / Native из существующих собственных приложений или библиотек. Для этого нам нужно скомпилировать наш код Kotlin в динамическую библиотеку, &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; и &lt;code&gt;.dll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">В этом учебнике мы создадим небольшую библиотеку,доступную из миров JVM,JS и коренного населения.Вы научитесь шаг за шагом создавать мультиплатформенную библиотеку,которая может быть использована из любого другого распространенного кода (например,общего с Android и iOS),а также писать тесты,которые будут выполняться на всех платформах и использовать эффективную реализацию,предоставляемую конкретной платформой.</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">В этом уроке мы рассмотрим,как использовать Kotlin/Native код из приложений Objective-C и Swift на макросах и iOS.Мы построим фреймворк из кода Kotlin.</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">В этом учебнике мы это сделаем:</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">В этом учебном пособии мы рассмотрим,как</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">В этом руководстве мы собираемся использовать Gradle, но то же самое можно сделать, используя структуру проекта IntelliJ IDEA или Maven. Подробнее о настройке Gradle для работы с Kotlin см. &lt;a href=&quot;../reference/using-gradle&quot;&gt;Использование Gradle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">В этом руководстве мы собираемся использовать Gradle, но то же самое можно сделать, используя структуру проекта IntelliJ IDEA или Maven. Подробнее о настройке Gradle для работы с Kotlin см. &lt;a href=&quot;../reference/using-gradle&quot;&gt;Использование Gradle&lt;/a&gt; . Основная зависимость, необходимая для использования HTTP-сервлетов, - это API JavaEE:</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">В свою очередь, &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;also&lt;/code&gt; иметь объект контекста в качестве лямбда-аргумента. Если имя аргумента не указано, доступ к объекту осуществляется по неявному имени по умолчанию &lt;code&gt;it&lt;/code&gt; . &lt;code&gt;it&lt;/code&gt; короче , чем &lt;code&gt;this&lt;/code&gt; и выражение с &lt;code&gt;it&lt;/code&gt; , как правило , легче для чтения. Однако, при вызове функции объекта или свойства , которые не имеют объект доступного неявно , как &lt;code&gt;this&lt;/code&gt; . Следовательно, имея объект контекста , как &lt;code&gt;it&lt;/code&gt; лучше , когда объект в основном используется в качестве аргумента в вызовах функций. &lt;code&gt;it&lt;/code&gt; также лучше , если вы используете несколько переменных в блоке кода.</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">В свою очередь, изменяемые коллекции не ковариантны; в противном случае это привело бы к сбоям во время выполнения. Если &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; был подтипом &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; , вы могли бы вставить в него других наследников &lt;code&gt;Shape&lt;/code&gt; (например, &lt;code&gt;Circle&lt;/code&gt; ), тем самым нарушив его аргумент типа &lt;code&gt;Rectangle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">В свою очередь, множество не упорядоченная коллекция по &lt;a href=&quot;collections-overview&quot;&gt;определению&lt;/a&gt; . Однако в Kotlin &lt;code&gt;Set&lt;/code&gt; элементы хранятся в определенном порядке. Это может быть порядок вставки (в &lt;code&gt;LinkedHashSet&lt;/code&gt; ), естественный порядок сортировки (в &lt;code&gt;SortedSet&lt;/code&gt; ) или другой порядок. Порядок набора элементов также может быть неизвестен. В таких случаях элементы все равно каким-то образом упорядочены, поэтому функции, которые полагаются на позиции элементов, по-прежнему возвращают свои результаты. Однако такие результаты непредсказуемы для вызывающего, если они не знают конкретную реализацию используемого &lt;code&gt;Set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">В вашем царапине вы можете написать любой действительный код Kotlin,включая новые функции и классы.Подсветка синтаксиса,автозавершение и другие функции редактирования кода IntelliJ IDEA поддерживаются с нуля.</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">Включая статическую библиотеку в ваш клиб</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">Несовместимые изменения</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">Инкрементальная компиляция</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">Дополнительная обработка аннотаций (с 1.3.30)</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">Инкрементная компиляция</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Поддерживается дополнительная компиляция для проектов Kotlin/JVM и Kotlin/JS.По умолчанию она включена с версии 1.1.1 для Kotlin/JVM и 1.3.20 для Kotlin/JS.</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">Инкрементные выпуски приносят обновления в инструментарии (часто с функциями),улучшения производительности и исправления ошибок.Мы стараемся поддерживать совместимость таких версий друг с другом,поэтому изменения в компиляторе в основном являются оптимизациями и дополнениями/удалениями с предупреждениями.Экспериментальные возможности,конечно,могут быть добавлены,удалены или изменены в любое время.</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">Увеличения и декреты</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Увеличивает значение на &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;дельту&lt;/a&gt; и возвращает новое значение.</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Увеличивает значение на &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;дельту&lt;/a&gt; и возвращает новое значение.</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">Увеличивает это значение.</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">Увеличивает значение на единицу.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">Оператор индексированного доступа</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">Указывает на то,что какой-то другой объект &quot;равен&quot; этому.Введение должно отвечать следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Указывает, может ли регулярное выражение найти хотя бы одно совпадение в указанном &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;вводе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Указывает, соответствует ли регулярное выражение всему &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;вводу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">Исправление вызовов именованных функций</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">Вызовы инфиксных функций имеют более низкий приоритет, чем арифметические операторы, приведение типов и оператор &lt;code&gt;rangeTo&lt;/code&gt; . Следующие выражения эквивалентны:</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">Функции добавления</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">Инфекционная запись</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">Информация из явных каст используется для вывода типа</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">Наследование от классов Java</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">Наследование, приводящее к конфликту &lt;code&gt;copy&lt;/code&gt; , устарело с предупреждением в Kotlin 1.2 и будет ошибкой в ​​Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">Унаследованные функции</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">Унаследованная собственность</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">Унаследованные встроенные функции</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">Инициализируется значением типа &lt;code&gt;String&lt;/code&gt; или примитивным типом</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">Функция инициализатора может быть вызвана несколько раз при одновременном доступе к неинициализированному значению экземпляра &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; , но только первое возвращенное значение будет использоваться в качестве значения экземпляра &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">Функции инициализатора для списков</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">Инициализирует время выполнения Kotlin для текущего потока,если он еще не включен.</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">Встраиваемые лямбды могут вызываться только внутри встроенных функций или передаваться как встроенные аргументы, но без &lt;code&gt;noinline&lt;/code&gt; можно манипулировать любым способом: хранить в полях, передавать и т. Д.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">Онлайн-функции</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">JavaScript онлайн</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">Интернет-разметка</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">онлайн-классы</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">Онлайн-классы разрешено наследовать от интерфейсов:</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Встроенные классы доступны только с Kotlin 1.3 и в настоящее время являются &lt;em&gt;экспериментальными&lt;/em&gt; . См. Подробности &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;ниже&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Встроенные классы доступны только с Kotlin 1.3 и в настоящее время являются &lt;em&gt;экспериментальными&lt;/em&gt; . Подробности смотрите в &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;ссылке&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">Онлайн-классы поддерживают некоторые функциональные возможности обычных классов.В частности,им разрешено объявлять свойства и функции:</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">Онлайн-классы против псевдонимов типа</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">Встроенные функции расширения,которые вызывались на нулевом значении типа платформы,не проверяли приемник на нуль и,таким образом,позволяли нулю ускользнуть в другой код.Kotlin 1.2 заставляет эту проверку на сайтах звонков,бросая исключение,если приемник равен нулю.</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">Интернет-функции</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Встроенные функции описаны &lt;a href=&quot;inline-functions&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">Встроенные функции теперь могут иметь значения по умолчанию для своих встроенных функциональных параметров:</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">Встроенные функции с &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;параметрами&lt;/a&gt; типа reified имеют свои фактические аргументы типа, встроенные в каждый сайт вызова, что позволяет &lt;code&gt;arg is T&lt;/code&gt; проверять параметры типа, но если &lt;code&gt;arg&lt;/code&gt; является экземпляром самого универсального типа, &lt;em&gt;его&lt;/em&gt; аргументы типа все равно стираются. Пример:</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">Встроенные функции с функциональными параметрами по умолчанию</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">Свойства онлайн (с 1.1)</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">Инлайн аксессуары для недвижимости</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">Расширение может привести к росту сгенерированного кода,однако,если мы сделаем это разумным способом (т.е.избежим встраивания больших функций),то это окупится по производительности,особенно на &quot;мегаморфных&quot; колл-сайтах внутри циклов.</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">Внутренние классы</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">Внутренние классы, наследующие &lt;code&gt;Throwable&lt;/code&gt; , которые захватывают общие параметры из внешнего класса</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">Внутренние классы универсальных типов, которые наследуются от &lt;code&gt;Throwable&lt;/code&gt; , могут нарушать безопасность типов в сценарии throw-catch и, таким образом, устарели с предупреждением в Kotlin 1.2 и ошибкой в ​​Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Вставляет все элементы указанных &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;элементов&lt;/a&gt; коллекции в этот список по указанному &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;индексу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Вставляет все элементы указанных &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;элементов&lt;/a&gt; коллекции в этот список по указанному &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;индексу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Вставляет элемент в список по указанному &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;индексу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Вставляет элемент в список по указанному &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;индексу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Вставляет элемент в список по указанному &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;индексу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">Внутри класса вы можете объявлять расширения для другого класса. Внутри такого расширения есть несколько &lt;em&gt;неявных получателей&lt;/em&gt; - объектов, к членам которых можно получить доступ без квалификатора. Экземпляр класса, в котором объявлено расширение, называется &lt;em&gt;получателем отправки&lt;/em&gt; , а экземпляр типа получателя метода &lt;em&gt;расширения&lt;/em&gt; называется &lt;em&gt;получателем расширения&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Внутри функции параметр &lt;code&gt;vararg&lt;/code&gt; типа &lt;code&gt;T&lt;/code&gt; отображается как массив &lt;code&gt;T&lt;/code&gt; , то есть переменная &lt;code&gt;ts&lt;/code&gt; в приведенном выше примере имеет тип &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">Внутри лямбда-выражения с получателем вы можете использовать &lt;code&gt;this&lt;/code&gt; для ссылки на объект-получатель (в данном случае &lt;code&gt;car&lt;/code&gt; ). Как обычно, вы можете опустить &lt;code&gt;this&lt;/code&gt; если нет конфликтов имен, поэтому мы можем просто сказать &lt;code&gt;$horsepowers&lt;/code&gt; вместо &lt;code&gt;${this.horsepowers}&lt;/code&gt; . Поэтому имейте в виду, что в Kotlin &lt;code&gt;this&lt;/code&gt; может иметь разные значения в зависимости от контекста: если оно используется внутри (возможно, вложенных) лямбда-выражений с приемниками, оно относится к объекту-получателю самого внутреннего включающего лямбда-выражения с приемником. Если вам нужно &amp;laquo;вырваться&amp;raquo; из функционального литерала и получить &amp;laquo;оригинал&amp;raquo;, &lt;code&gt;this&lt;/code&gt; (экземпляр, в котором выполняется функция-член, внутри которой вы находитесь), укажите имя содержащего класса после &lt;code&gt;this@&lt;/code&gt; - поэтому, если вы находитесь внутри литерала функции с приемником внутри функции-члена Car, используйте &lt;code&gt;this@Car&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">Внутри внутреннего класса доступ к суперклассу внешнего класса осуществляется с помощью ключевого слова &lt;em&gt;super&lt;/em&gt; с именем внешнего класса: &lt;code&gt;super@Outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">Внутри записей перечисления определение вложенного типа, который не является &lt;code&gt;inner class&lt;/code&gt; , устарело из-за проблем в логике инициализации. Это вызывает предупреждение в Kotlin 1.2 и становится ошибкой в ​​Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">Внутри блока &lt;code&gt;apply&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; относится к &lt;code&gt;maybeNull&lt;/code&gt; . Там в неявном &lt;code&gt;this&lt;/code&gt; перед &lt;code&gt;memberPropertyA&lt;/code&gt; , &lt;code&gt;memberPropertyB&lt;/code&gt; и &lt;code&gt;memberFunctionA&lt;/code&gt; (если они не не существует на &lt;code&gt;maybeNull&lt;/code&gt; , в этом случае они будут искать в областях , содержащих). После этого &lt;code&gt;memberFunctionB()&lt;/code&gt; также вызывается для &lt;code&gt;maybeNull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">Внутри тела функционального литерала объект-получатель, переданный вызову, становится &lt;em&gt;неявным &lt;/em&gt;&lt;em&gt;this&lt;/em&gt; , так что вы можете получить доступ к членам этого объекта-получателя без каких-либо дополнительных квалификаторов или получить доступ к объекту-получателю с помощью &lt;a href=&quot;this-expressions&quot;&gt;выражения &lt;/a&gt; &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">Внутри класса,который объявляет свойство lateinit,можно проверить,было ли оно инициализировано:</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">Внутри файла документация для модуля в целом и для отдельных пакетов представлена ​​соответствующими заголовками первого уровня. Текст заголовка должен быть &amp;laquo;Модуль &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &amp;raquo; для модуля и &amp;laquo;Пакет &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &amp;raquo; для пакета.</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">Внутри лямбда функции области видимости объект контекста доступен по короткой ссылке вместо его фактического имени. Каждая функция области видимости использует один из двух способов доступа к объекту контекста: как лямбда- &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;приемник&lt;/a&gt; ( &lt;code&gt;this&lt;/code&gt; ) или как лямбда-аргумент ( &lt;code&gt;it&lt;/code&gt; ). Оба предоставляют одинаковые возможности, поэтому мы опишем плюсы и минусы каждого для разных случаев и дадим рекомендации по их использованию.</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">Посмотреть сгенерированные API Kotlin из библиотеки C</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">Для получения подробной информации проверьте содержимое &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; дистрибутива.</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">Проверка сгенерированных API Kotlin для C-библиотеки</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">Установите пользовательский неуправляемый крюк для исключений.Возвращает старый крюк,или нулевой,если он не был указан.Крюк вызывается всякий раз,когда есть неисправленное исключение,достигающее границ мира Котлина,т.е.верхнего уровня main(),или когда вызов Objective-C к Котлину,не помеченный @Throws,бросает исключение.Крюк должен быть замороженной лямбдой,чтобы его можно было вызвать из любого потока/работника.Крючок вызывается один раз,а затем очищается,так что обнаружение утечки памяти работает,как и ожидалось,даже при использовании пользовательских крючков исключений.</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">Установите libgit2 и подготовьте корешки для git-библиотеки:</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">Установите &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;расширение JetBrains для Chrome,&lt;/a&gt; которое позволяет выполнять отладку внутри IntelliJ IDEA через Chrome. Это полезно для любого типа веб-приложений, разработанных с помощью IntelliJ IDEA, а не только для Kotlin.</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">Установка плагина EduTools</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">Бытовые проверки</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">Поля Экземпляра</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">Экземпляр,требуемый для вызова члена,или внешний экземпляр класса для внутреннего конструктора класса.</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">инстанцирование типа функции</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">Вместо непосредственного вызова метода, &lt;code&gt;matches&lt;/code&gt; мы сохраняем ссылку на него. Такая ссылка привязывается к получателю. Его можно вызвать напрямую (как в примере выше) или использовать всякий раз, когда ожидается выражение типа функции:</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">Вместо того,чтобы создавать объект функции для параметра и генерировать вызов,компилятор мог бы выдать следующий код:</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">Вместо потоков среда исполнения Kotlin / Native предлагает концепцию рабочих: одновременно выполняемые потоки потока управления со связанной очередью запросов. Рабочие очень похожи на актеров в модели актера. Рабочий может обмениваться объектами Kotlin с другим воркером, так что в любой момент каждый изменяемый объект принадлежит одному воркеру, но право собственности может быть передано. См. Раздел &amp;laquo; &lt;a href=&quot;#transfer&quot;&gt;Перенос объектов и замораживание&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">Указывает компилятору сгенерировать или опустить подстановочные знаки для аргументов типа, соответствующих параметрам с отклонением от места объявления, например таким, как &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">Инструктирует компилятор генерировать подстановочный символ для аннотированных аргументов типа,соответствующих параметрам с дисперсией объявление-сайт.</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Инструктирует компилятор Kotlin не генерировать геттеры/установки для данного свойства и выставлять его в виде поля.</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Указывает компилятору Kotlin создать многофайловый класс с функциями и свойствами верхнего уровня, объявленными в этом файле как одна из его частей. Имя соответствующего многофайлового класса предоставляется аннотацией &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">Инструктирует компилятор Kotlin генерировать перегрузки для этой функции,которые подставляют значения параметров по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">Инструктирует компилятор Kotlin относиться к аннотированному классу Java как к чистой реализации заданного интерфейса Kotlin.&quot;Чисто&quot; здесь означает,что каждый тип параметра класса становится не-платформенным типом аргумента этого интерфейса.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">Целочисленные типы</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Целочисленные типы в Kotlin имеют &lt;em&gt;ограниченный размер&lt;/em&gt; , в отличие от произвольно больших целых чисел в Python. Предел зависит от типа, который определяет, сколько бит занимает число в памяти:</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">Диапазоны интегральных типов ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt; ) имеют дополнительную функцию: их можно перебирать. Эти диапазоны также являются &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;прогрессиями&lt;/a&gt; соответствующих интегральных типов. Такие диапазоны обычно используются для итерации в &lt;code&gt;for&lt;/code&gt; петель.</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA может запускать ваши царапины автоматически. Чтобы получить результаты выполнения после того, как вы перестанете печатать на короткое время, включите &lt;strong&gt;интерактивный режим&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA добавит нам соответствующие записи в &lt;a href=&quot;#maven-configuration&quot;&gt;конфигурацию Maven&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">Взаимодействовать с МДМ</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">Взаимодействие с МЗУ</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Продолжение перехвата с помощью &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Продолжение перехвата с помощью &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">Перехват переданного имущества,имеющего обязательную силу</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">Перехватывает это продолжение с помощью &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">Схема реализации интерфейса</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Интерфейс , представляющие собой продолжение после точки подвеса , которая возвращает значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Интерфейс , представляющие собой продолжение после точки подвеса , которая возвращает значение типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">Оба интерфейса &lt;em&gt;A&lt;/em&gt; и &lt;em&gt;B&lt;/em&gt; объявляют функции &lt;em&gt;foo ()&lt;/em&gt; и &lt;em&gt;bar ()&lt;/em&gt; . Оба они реализуют &lt;em&gt;foo ()&lt;/em&gt; , но только &lt;em&gt;B&lt;/em&gt; реализует &lt;em&gt;bar ()&lt;/em&gt; ( &lt;em&gt;bar ()&lt;/em&gt; не помечен как абстрактный в &lt;em&gt;A&lt;/em&gt; , потому что это значение по умолчанию для интерфейсов, если функция не имеет тела). Теперь, если мы получим конкретный класс &lt;em&gt;C&lt;/em&gt; от &lt;em&gt;A&lt;/em&gt; , мы, очевидно, должны переопределить &lt;em&gt;bar ()&lt;/em&gt; и предоставить реализацию.</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">Наследование интерфейсов</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Интерфейсы в Котлине очень похожи на Java 8.Они могут содержать декларации абстрактных методов,а также реализации методов.Их отличие от абстрактных классов состоит в том,что интерфейсы не могут хранить состояние.Они могут иметь свойства,но они должны быть абстрактными или предоставлять реализации доступа.</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">Интерфейс с Java</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Интероперабельность с отражением Java</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Совместимость со Swift / Objective-C также обеспечивается и рассматривается в отдельном документе &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">Представляем выражение как переменную в локальной области видимости: &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">Введение в Котлин (на русском языке)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">Введение в программирование Kotlin</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">Инвертирует биты в это значение.</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">Инвертирует биты,включая знаковый бит в это значение.</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">Вызов &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; возобновляет сопрограмму непосредственно в потоке вызывающего, не проходя через &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor,&lt;/a&gt; который может присутствовать в CoroutineContext &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;сопрограммы&lt;/a&gt; . Ответственность за обеспечение правильного контекста вызова лежит на вызывающей стороне. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; можно использовать для получения перехваченного продолжения.</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">провоцирующий оператор</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">Вызывается для экземпляра продолжения, возвращаемого функцией &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation,&lt;/a&gt; когда исходное продолжение завершается и больше не будет использоваться. Эта функция вызывается только в том случае, если &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; вернул экземпляр продолжения, отличный от того, с которым она была вызвана.</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">Вызов &lt;code&gt;call()&lt;/code&gt; для объекта функции вызовет функцию. Если это функция-член, первым параметром должен быть &lt;em&gt;получатель&lt;/em&gt; (объект, для которого функция должна быть вызвана, в данном случае &lt;code&gt;person&lt;/code&gt; ), а остальные параметры должны быть обычными параметрами функции (в данном случае &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ). ,</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">Вызов &lt;code&gt;findViewById()&lt;/code&gt; может быть медленным, особенно в случае огромных иерархий представлений, поэтому Android Extensions пытается минимизировать вызовы &lt;code&gt;findViewById()&lt;/code&gt; путем кэширования представлений в контейнерах.</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">Призыв к экземпляру типа функции</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">Призывные функции на других коллекциях</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">Является ли Котлин объектно-ориентированным языком или функциональным?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Совместима ли Kotlin с языком программирования Java?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">Котлин свободен?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">Котлин трудный?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">Котлин в социальных сетях?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">Функция расширения</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">Есть ли конференция в Котлине?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">Разве это не то,чего мы хотели с самого начала?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">Изоляция деклараций в отдельном объекте JavaScript</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">Он также работает с мета-аннотациями:</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">Это можно продемонстрировать на простом примере создания сопрограмм в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">Конечно, это можно сделать одним выражением: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">Он демонстрирует несколько новых техник. Один использует &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; с явно указанным контекстом, а другой использует функцию &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; для изменения контекста сопрограммы, оставаясь при этом в той же сопрограмме, как вы можете видеть в выводе ниже:</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">Не имеет значения (для корректности),в каком контексте выполняется сам агент.Актор-это корутин,а корутин выполняется последовательно,поэтому привязка состояния к конкретной корутине работает как решение проблемы общего мутируемого состояния.Действительно,агенты могут изменять свое собственное частное состояние,но могут влиять друг на друга только через сообщения (избегая необходимости в каких-либо блокировках).</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">&lt;code&gt;writeLogMessage&lt;/code&gt; , что целевые объекты предоставят реализации writeLogMessage для конкретной платформы , и теперь общий код может использовать это объявление без какого-либо рассмотрения того, как оно реализовано.</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">Его также удобно использовать,когда вместо лямбды у вас есть ссылка на звонок:</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">Также возможно настроить все задачи компиляции Kotlin в проекте:</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">Также возможна отладка приложений Kotlin с помощью стандартного отладчика Chrome.Просто убедитесь,что вы действительно генерируете исходные карты.</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Также можно перебирать числа с произвольным шагом (не обязательно с 1). Это делается с помощью &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; функции.</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">Удобно импортировать все свойства виджета для конкретного макета за один заход:</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">Он создается путем присоединения функции &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; к источнику элементов. Чтобы получить экземпляр &lt;a href=&quot;index&quot;&gt;Grouping,&lt;/a&gt; используйте одну из функций расширения &lt;code&gt;groupingBy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">Это легко продемонстрировать в действии:</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">Скомпилированный код Kotlin легко включить в существующие проекты, написанные на C, C ++, Swift, Objective-C и других языках. Также легко использовать существующий собственный код, статические или динамические &lt;a href=&quot;native/c_interop&quot;&gt;библиотеки&lt;/a&gt; C, &lt;a href=&quot;native/objc_interop&quot;&gt;фреймворки&lt;/a&gt; Swift / Objective-C , графические движки и все остальное прямо из Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">Сгенерированные классы-оболочки для &lt;code&gt;struct&lt;/code&gt; C и типов &lt;code&gt;union&lt;/code&gt; из Kotlin легко использовать . Благодаря сгенерированным свойствам кажется естественным использовать их в коде Kotlin. На данный момент единственный вопрос заключается в том, как создать новый экземпляр для этих классов. Как видно из объявлений &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; , их конструкторам требуется &lt;code&gt;NativePtr&lt;/code&gt; . Конечно, мы не хотим иметь дело с указателями вручную. Вместо этого мы можем использовать Kotlin API для создания экземпляров этих объектов для нас.</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">Он эквивалентен этому Java-коду:</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">Встроенным классам запрещено участвовать в иерархии классов. Это означает, что встроенные классы не могут расширять другие классы и должны быть &lt;em&gt;окончательными&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">Важно отметить, что некоторые из &lt;a href=&quot;#supported-platforms&quot;&gt;целевых объектов Kotlin / Native&lt;/a&gt; могут быть созданы только с помощью соответствующего хост-компьютера:</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">Важно понимать, что, как и в случае с &lt;code&gt;callAnything()&lt;/code&gt; , &lt;code&gt;dataTable()&lt;/code&gt; должна существовать во время выполнения. В нашем случае нам нужно убедиться, что соответствующий файл скрипта для нашего плагина включен:</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">Не рекомендуется публиковать варианты,сгруппированные по вкусу продукта,если они имеют различные зависимости,так как они будут объединены в один список зависимостей.</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">Необязательно сопоставлять директории и пакеты:исходные файлы могут быть произвольно помещены в файловую систему.</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">Теперь можно перечислить значения класса перечисления в общем виде.</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">Он не зависит от платформы.Независимо от того,нацелены ли мы на JVM,JavaScript или любую другую платформу,код,который мы пишем,тот же самый.Под обложками компилятор заботится об адаптации его к каждой платформе.</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">Класс может реализовать тип функции, как если бы он был интерфейсом. Затем он должен предоставить операторную функцию, называемую &lt;code&gt;invoke&lt;/code&gt; , с данной сигнатурой, и затем экземпляры этого класса могут быть назначены переменной этого типа функции:</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">Можно аннотировать аргументы типов общих типов,чтобы предоставить информацию об их недействительности.Например,рассмотрим эти аннотации на Java-декларации:</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">Можно настроить языковые параметры всех исходных наборов одновременно:</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">Можно создать указатель со стабильной областью видимости C-представления &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; используя свойство расширения &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; , доступное в &lt;code&gt;memScoped { ... }&lt;/code&gt; . Это позволяет использовать API-интерфейсы, для которых требуются указатели C со временем жизни, привязанным к определенному &lt;code&gt;MemScope&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">Можно объявлять контракты для ваших собственных функций, но это &lt;strong&gt;экспериментальная&lt;/strong&gt; функция &lt;strong&gt;,&lt;/strong&gt; поскольку текущий синтаксис находится в состоянии раннего прототипа и, скорее всего, будет изменен. Также обратите внимание, что в настоящее время компилятор Kotlin не проверяет контракты, поэтому ответственность за написание правильных и надежных контрактов лежит на программисте.</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">Можно фильтровать заголовки по глобусам. &lt;code&gt;headerFilter&lt;/code&gt; значение свойства из &lt;code&gt;.def&lt;/code&gt; файла обрабатываются как разделенные пробелами списка комков. Если включенный заголовок совпадает с каким-либо из глобусов, то объявления из этого заголовка включаются в привязки.</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">В многоплатформенной библиотеке можно иметь несколько целей для одной платформы.Например,эти мишени могут предоставлять один и тот же API и различаться в библиотеках,с которыми они сотрудничают во время выполнения,таких как тестирующие фреймворки или решения для протоколирования.</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">Можно указать,какие типы сборки будут использоваться для создания двоичных файлов,а какие нет.В следующем примере создается только отладочный исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">Это довольно распространенная ситуация, когда у вас есть список ключей и вы хотите построить карту, связывая каждый из этих ключей с некоторым значением. &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; можно было сделать с помощью функции associate {it to getValue (it)} , но теперь мы представляем более эффективную и простую в использовании альтернативу: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">Можно безопасно рассматривать &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; как &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - тогда вы ограничены только добавлением к нему экземпляров &lt;code&gt;Apple&lt;/code&gt; , но это нормально, потому что он способен получать любые &lt;code&gt;Fruit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">Можно безопасно обращаться с &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; как с &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - единственное, что он когда-либо будет производить, - это экземпляры &lt;code&gt;Apple&lt;/code&gt; , но это нормально, потому что &lt;code&gt;Apple&lt;/code&gt; - это &lt;code&gt;Fruit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">Это то же самое, что и установленный хэш-код &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;записей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">Пришло время попробовать использовать функции C из нашей программы Kotlin. Давайте &lt;code&gt;accept_fun&lt;/code&gt; функцию accept_fun и передадим указатель функции C лямбда- выражению Kotlin:</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">Очень удобно объявить параметр типа T как &lt;em&gt;out&lt;/em&gt; и избежать проблем с выделением подтипов на сайте использования, но некоторые классы фактически &lt;strong&gt;не могут&lt;/strong&gt; быть ограничены только возвратом &lt;code&gt;T&lt;/code&gt; ! Хорошим примером этого является Array:</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">Он запускает 100K корутины и через секунду каждая корутина печатает точку.Теперь попробуй это с нитками.Что случится? (Скорее всего,ваш код выдаст какую-нибудь ошибку вне памяти).</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">Это приводит к тому,что в Котлине видна следующая подпись:</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">Это может быть полезно только в том случае,если объявление кажется неудобным для использования из Java без подстановочного символа.</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">Это может быть полезно только в том случае,если объявление кажется неудобным для использования из Java.</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">Следующим логичным шагом может показаться устранение этой неясности путем переключения значений по умолчанию в IntelliJ IDEA и приведение форматирования в соответствие с Котлинскими конвенциями по кодированию.Но это будет означать,что все существующие проекты Kotlin будут иметь новый стиль кода,включенный в момент установки плагина Kotlin.Не совсем ожидаемый результат для обновления плагина,не так ли?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">Это означает, что к моменту выполнения конструктора базового класса свойства, объявленные или переопределенные в производном классе, еще не инициализированы. Если какое-либо из этих свойств используется в логике инициализации базового класса (прямо или косвенно, через другую переопределенную реализацию &lt;em&gt;открытого&lt;/em&gt; члена), это может привести к неправильному поведению или сбою во время выполнения. Поэтому при разработке базового класса следует избегать использования &lt;em&gt;открытых&lt;/em&gt; членов в конструкторах, инициализаторах свойств и блоках &lt;em&gt;инициализации&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">Может возникнуть соблазн использовать класс JVM &lt;code&gt;java.util.Scanner&lt;/code&gt; для анализа менее структурированных форматов ввода. Kotlin разработан так, чтобы хорошо взаимодействовать с библиотеками JVM, поэтому их использование в Kotlin кажется вполне естественным. Однако учтите, что &lt;code&gt;java.util.Scanner&lt;/code&gt; работает очень медленно. На самом деле настолько медленным, что анализ 10 &lt;sup&gt;5&lt;/sup&gt; или более целых чисел с ним может не укладываться в типичный 2-секундный временной лимит, который будет обрабатывать простой Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">Он печатает &amp;laquo;отправка&amp;raquo; &lt;em&gt;пять&lt;/em&gt; раз, используя буферный канал с пропускной способностью &lt;em&gt;четыре&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">Он печатает следующие строки:</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">При работе в &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;режиме отладки&lt;/a&gt; он производит что-то подобное :</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">Она производит нечто подобное:</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">Он производит следующий вывод (возможно,в другом порядке):</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">Он производит следующий результат:</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">Он возвращает композицию из двух переданных ему функций: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; . Теперь вы можете применить его к вызываемым ссылкам:</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">Он принимает два параметра типа &lt;code&gt;Int&lt;/code&gt; и возвращает значение типа &lt;code&gt;Double&lt;/code&gt; , поэтому его тип - &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; . Мы можем ссылаться на саму функцию, добавив к ее имени префикса &lt;code&gt;::&lt;/code&gt; , и мы можем присвоить ее переменной (тип которой обычно определяется, но мы показываем сигнатуру типа для демонстрации):</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">Он создаст общий объект для конкретной платформы (.so в Linux, .dylib в macOS и .dll в целях Windows) и заголовок языка C, что позволит использовать все общедоступные API, доступные в вашей программе Kotlin / Native с C / Код на C ++. См. &lt;code&gt;samples/python_extension&lt;/code&gt; для примера использования такого общего объекта для обеспечения моста между Python и Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">Он создаст статический объект,специфичный для платформы (.a библиотечный формат)и заголовок языка Си,позволяющий использовать все публичные API,доступные в вашей программе Kotlin/Native из Си/Си++кода.</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">Начать использовать Kotlin для разработки под Android очень просто. В этом руководстве мы проследим за процессом разогрева с помощью Android Studio. Если вы используете Intellij IDEA с Android, процесс почти такой же.</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">Разрешено передавать тот же массив в место &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;назначения&lt;/a&gt; и даже указывать поддиапазон, чтобы он перекрывался с диапазоном назначения.</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">Разрешено передавать тот же массив в место &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;назначения&lt;/a&gt; и даже указывать поддиапазон, чтобы он перекрывался с диапазоном назначения.</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">Всегда можно явно указать стиль кода IntelliJ IDEA как правильный стиль кода для проекта. Для этого переключитесь на схему &amp;laquo; &lt;em&gt;Проект&amp;raquo;&lt;/em&gt; в &amp;laquo; &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; и выберите &lt;em&gt;&amp;laquo;Kotlin obsolete IntelliJ IDEA codestyle&amp;raquo;&lt;/em&gt; в &lt;em&gt;&amp;laquo;Использовать значения по умолчанию из:&amp;raquo;&lt;/em&gt; на вкладке &amp;laquo; &lt;em&gt;Загрузка&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">В настоящее время невозможно передать &lt;em&gt;null&lt;/em&gt; методу, объявленному как varargs.</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">Наследование от &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; нормально , и у нас нет проблем с &lt;code&gt;a()&lt;/code&gt; и &lt;code&gt;b()&lt;/code&gt; поскольку &lt;code&gt;C&lt;/code&gt; наследует только одну реализацию каждой из этих функций. Но для &lt;code&gt;f()&lt;/code&gt; у нас есть две реализации, унаследованные от &lt;code&gt;C&lt;/code&gt; , и поэтому мы должны переопределить &lt;code&gt;f()&lt;/code&gt; в &lt;code&gt;C&lt;/code&gt; и предоставить нашу собственную реализацию, которая устраняет двусмысленность.</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">Важно закрыть поток,когда вы закончили с ним,в противном случае ваша программа утечет обработчик файла.Смотрите следующий раздел о том,как это сделать красиво.</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">Важно убедиться, что установлен флажок &lt;em&gt;Включить поддержку Kotlin&lt;/em&gt; . А пока мы можем оставить настройки по умолчанию на следующем шаге мастера. Затем мы переходим к выбору опции &amp;laquo; &lt;em&gt;Пустое действие&amp;raquo;&lt;/em&gt; и нажимаем &amp;laquo; &lt;em&gt;Далее&amp;raquo;&lt;/em&gt; , наконец, нажимаем &amp;laquo; &lt;em&gt;Готово&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">Важно понимать,что теперь это родное приложение,и для его работы не требуется ни время выполнения,ни виртуальная машина.Теперь мы можем запустить скомпилированный двоичный файл из консоли:</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Не рекомендуется применять плагины Kotlin с помощью &lt;code&gt;apply&lt;/code&gt; в Gradle Kotlin DSL. Подробности представлены &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">Часто бывает так, что нам нужно скопировать объект, изменив &lt;em&gt;некоторые&lt;/em&gt; его свойства, но оставив остальные без изменений. Для этого и создается функция &lt;code&gt;copy()&lt;/code&gt; . Для указанного выше класса &lt;code&gt;User&lt;/code&gt; его реализация будет следующей:</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">Для компонента можно объявить зависимость от кинтеропа:</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">Можно зависеть от библиотеки Kotlin / Native, опубликованной ранее в репозитории maven. Плагин полагается на поддержку &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;метаданных&lt;/a&gt; Gradle, поэтому соответствующая функция должна быть включена. Добавьте следующую строку в свой &lt;code&gt;settings.gradle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">Рекомендуется распространять экспериментальный статус на API,зависящий от беззнаковых типов,снабжая его этой аннотацией.</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">Вы сами решаете,должны ли ваши клиенты явно согласиться на использование вашего API,но имейте в виду,что беззнаковые типы являются экспериментальной функцией,поэтому API,использующий их,может внезапно сломаться из-за изменений в языке.</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">Полезно укорачивать длинные типовые.Например,часто бывает заманчиво укоротить коллекционные типы:</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">Очень часто выражение лямбда имеет только один параметр.</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">Итерирует каждую строку этого читателя, вызывает &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;действие&lt;/a&gt; для каждой прочитанной строки и закрывает &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Ридер,&lt;/a&gt; когда оно завершено.</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">Интригуя по коллекции:</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">Итерация на расстоянии:</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">Итератор для символов заданной последовательности символов.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Итераторы могут быть получены для наследников интерфейса &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , включая &lt;code&gt;Set&lt;/code&gt; и &lt;code&gt;List&lt;/code&gt; , путем вызова функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; . После получения итератора он указывает на первый элемент коллекции; вызов функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; возвращает этот элемент и перемещает позицию итератора на следующий элемент, если он существует. Как только итератор проходит через последний элемент, он больше не может использоваться для получения элементов; его также нельзя вернуть в предыдущее положение. Чтобы снова пройти по коллекции, создайте новый итератор.</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">JAR-файл для проекта Android из исходного набора &lt;code&gt;androidMain&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">поддержка JPA</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305 ( &lt;code&gt;javax.annotation&lt;/code&gt; , подробнее ниже)</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 Поддержка</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">СПС 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM Бэкэнд</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">бэкэнд СПМ</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">баночное дело</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">попытка Java 7 с использованием ресурсов</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">поддержка Java 8 байткодов</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Поддержка стандартной библиотеки Java 8</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">Java-аннотации</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">Java-массивы</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http сервлеты могут использоваться в Kotlin так же,как и любая другая библиотека или фреймворк Java.Мы посмотрим,как сделать простой контроллер,который возвращает &quot;Привет,мир!&quot;.</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">Java-интероперабельность</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">Отражение Java</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">Поддержка Java в JVM Targets</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">Ява Варрагс</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java аннотации на 100% совместимы с Kotlin:</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">В классах Java иногда используется объявление метода для индексов с переменным количеством аргументов (varargs):</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">параметры Java-компилятора</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">ява дженерики в Котлине</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">Java-взаимодействие:</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java получила поддержку типов функций и лямбда-выражений только несколько лет назад.Ранее Java работала над этим,используя интерфейс для определения сигнатуры функции и разрешая встроенное анонимное определение класса,реализующего интерфейс.Это также доступно в Kotlin,отчасти для совместимости с библиотеками Java,а отчасти потому,что это может быть удобно для указания обработчиков событий (в частности,если есть более одного типа событий,которые должны быть прослушаны одним и тем же объектом слушателя).Рассмотрим интерфейс или (возможно,абстрактный)класс,а также функцию,которая берет его экземпляр:</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Отражение Java работает с классами Kotlin и наоборот. Как упоминалось выше, вы можете использовать &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; или &lt;code&gt;instance.javaClass&lt;/code&gt; для входа в отражение Java через &lt;code&gt;java.lang.Class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">Java-типы,которые имеют аннотации обнуления,представлены не в виде платформенных типов,а в виде действительных нулевых или ненулевых типов Котлина.Компилятор поддерживает несколько вкусов аннотаций обнуляемости,в том числе:</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Массивы Java отображаются, как указано &lt;a href=&quot;java-interop#java-arrays&quot;&gt;ниже&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">Примитивные типы Java в ячейках сопоставляются с нулевыми типами Kotlin:</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Сырые типы Java преобразуются в звездные проекции,</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Подстановочные знаки Java преобразуются в типовые проекции,</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">вызовы Java-метода по умолчанию</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">Java-отражение</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">конвертер Java2Kotlin</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">JavaScript Бэкэнд</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">JavaScript DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">модули JavaScript</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">отражение JavaScript</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">JavaScript-бэкэнд</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">Бэкэнд JavaScript теперь генерирует более статически проверяемый код,который более дружественен к инструментам обработки JS-кода,таким как минификаторы,оптимизаторы,подложки и т.д.</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">В JavaScript нет концепции пакетов (пространств имен). Обычно они эмулируются вложенными объектами. Компилятор превращает ссылки на &lt;code&gt;external&lt;/code&gt; объявления либо в простые имена без префикса (в случае &lt;em&gt;простых&lt;/em&gt; модулей), либо в простой импорт. Однако, если библиотека JavaScript предоставляет свои объявления в пакетах, вас это не удовлетворит. Вы можете указать компилятору сгенерировать дополнительный префикс перед ссылками на &lt;code&gt;external&lt;/code&gt; объявления с помощью &lt;code&gt;@JsQualifier(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">В JavaScript нет концепции интерфейсов. Когда функция ожидает, что ее параметр будет поддерживать методы &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; , вы просто передаете объекты, которые действительно имеют эти методы. Вы можете использовать интерфейсы, чтобы выразить это для статически типизированного Котлина, например:</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains разрабатывает и поддерживает несколько инструментов специально для сообщества &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React&lt;/a&gt; : привязки React, а также приложение &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin&lt;/a&gt; . Последний поможет вам начать создавать приложения React с Kotlin без конфигурации сборки.</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">Работа в контексте</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">Присоединяйтесь к нам,чтобы продолжить изучение языковых типов C и их представление в Kotlin/Native в соответствующих учебниках:</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">Присоединение к курсу</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">Джошуа Блох называет те объекты, которые вы &lt;strong&gt;читаете&lt;/strong&gt; только от &lt;strong&gt;производителей&lt;/strong&gt; , а те, которые вы &lt;strong&gt;пишете,&lt;/strong&gt; - &lt;strong&gt;потребителям&lt;/strong&gt; . Он рекомендует: &amp;laquo; &lt;em&gt;Для максимальной гибкости используйте типы подстановочных знаков для входных параметров, которые представляют производителей или потребителей&lt;/em&gt; &amp;raquo;, и предлагает следующую мнемонику:</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">Прыжки между резьбами</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">Просто добавьте JAR-файл плагина в плагин Classpath компилятора и укажите список аннотаций sam-with-receiver:</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Как и в Java 8,Kotlin теперь позволяет использовать подчёркивания в числовых буквах для разделения групп цифр:</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Как и Java 8,Котлин поддерживает преобразование SAM.Это означает,что функциональные литералы Котлина могут быть автоматически преобразованы в реализации Java-интерфейсов одним ненарушимым методом,если типы параметров метода интерфейса соответствуют типам параметров функции Котлина.</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">Так же,как и Java и JavaScript,Kotlin поддерживает комментарии в конце строки и блокировку.</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Подобно анонимным внутренним классам Java,код в объектных выражениях может получать доступ к переменным из закрывающейся области видимости.(В отличие от Java,это не ограничивается конечными или фактически конечными переменными).</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Как и в Java, особый случай - параметр &lt;code&gt;value&lt;/code&gt; ; его значение можно указать без явного имени:</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Как и в Java, классы перечисления в Kotlin имеют синтетические методы, позволяющие перечислить определенные константы перечисления и получить константу перечисления по их имени. Сигнатуры этих методов следующие (при условии, что имя класса enum - &lt;code&gt;EnumClass&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">Как и обычные члены объекта-сопутника,их можно вызывать,используя в качестве классификатора только имя класса:</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">Как и в случае с JavaDoc, комментарии KDoc начинаются с &lt;code&gt;/**&lt;/code&gt; и заканчиваются &lt;code&gt;*/&lt;/code&gt; . Каждая строка комментария может начинаться со звездочки, которая не считается частью содержания комментария.</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">синтаксис KDoc</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">В настоящее время KDoc поддерживает следующие теги блоков:</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc не поддерживает тег &lt;code&gt;@deprecated&lt;/code&gt; . Вместо этого используйте аннотацию &lt;code&gt;@Deprecated&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">синтаксис KDoc</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt может генерировать исходники Kotlin. Просто запишите сгенерированные исходные файлы Kotlin в каталог, указанный в &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; , и эти файлы будут скомпилированы вместе с основными исходными кодами .</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Плагин компилятора Kapt доступен в бинарном дистрибутиве компилятора Kotlin.</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt использует компилятор Java для запуска процессоров аннотаций.</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">Имейте в виду, что это всего лишь синтаксический сахар - на самом деле вы не изменяете класс или его экземпляры. Следовательно, вам необходимо импортировать функцию / свойство расширения везде, где вы хотите их использовать (поскольку они не переносятся вместе с экземплярами класса). По той же причине вы не можете переопределить члены расширения - вы можете переопределить их для подтипов, но разрешение происходит во время компиляции на основе статического типа выражения, для которого вы его вызываете. Итак, если вы объявляете функцию расширения для &lt;code&gt;Vehicle&lt;/code&gt; и функцию с тем же именем и подписью для ее подкласса &lt;code&gt;Car&lt;/code&gt; , и вы делаете следующее, будет вызываться функция расширения для &lt;code&gt;Vehicle&lt;/code&gt; , даже если &lt;code&gt;v&lt;/code&gt; на самом деле является &lt;code&gt;Car&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">Сохраните язык современным на протяжении многих лет.</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Приложение Keepsafe App Lock также было &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;преобразовано в 100% Kotlin&lt;/a&gt; , что привело к уменьшению количества исходных строк на 30% и уменьшению количества методов на 10%.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">Ключ для элементов &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; - это тип элемента с этим ключом.</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">Ключ для элементов &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; - это тип элемента с этим ключом. Ключи в контексте сравниваются &lt;em&gt;по ссылке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">Ключевые слова и операторы</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">Вид модуля,сгенерированного компилятором</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">Вроде этого параметра.</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind представляет собой конкретную позицию объявления параметра в исходном коде,например,экземпляр,параметр приемника-расширителя или параметр значения.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">Известные проблемы</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1 представил сопрограммы, новый способ написания асинхронного, неблокирующего кода (и многое другое). В этом руководстве мы рассмотрим некоторые основы использования сопрограмм Kotlin с помощью библиотеки &lt;code&gt;kotlinx.coroutines&lt;/code&gt; , которая представляет собой набор помощников и оберток для существующих библиотек Java.</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1 снимает некоторые из ограничений на герметичность и классы данных,которые присутствовали в Kotlin 1.0.Теперь в том же файле можно определить подклассы класса опечатанных данных верхнего уровня,а не только вложенные классы класса опечатанных данных.Классы данных теперь могут расширять другие классы.Это можно использовать для красивого и чистого определения иерархии классов выражений:</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2 представляет набор функций для работы с &lt;code&gt;BigInteger&lt;/code&gt; и &lt;code&gt;BigDecimal&lt;/code&gt; и их создания из других числовых типов. Эти:</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3 продолжает развиваться и совершенствовать API для скриптов,внедряя некоторые экспериментальные средства для настройки скриптов,такие как добавление внешних свойств,обеспечение статических или динамических зависимостей и так далее.</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3 продолжает улучшать и совершенствовать родную цель. См. Подробности в &lt;a href=&quot;native-overview&quot;&gt;обзоре Kotlin / Native&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3 представил более простую форму &lt;code&gt;main&lt;/code&gt; , которая не принимает параметров. Теперь &amp;laquo;Hello, World&amp;raquo; в Котлине на 19 символов короче!</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3 вводит новый вид объявления - &lt;code&gt;inline class&lt;/code&gt; . Встроенные классы можно рассматривать как ограниченную версию обычных классов, в частности, встроенные классы должны иметь ровно одно свойство:</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">В Kotlin 1.3 введены вызываемые ссылки на функции приостановки и поддержку Coroutines в Reflection API.</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">В Kotlin 1.3 появилась поддержка рабочих &lt;em&gt;файлов&lt;/em&gt; Kotlin с &lt;em&gt;нуля&lt;/em&gt; . &lt;em&gt;Скретч-файл&lt;/em&gt; - это файл сценария kotlin с расширением .kts, который вы можете запустить и получить результаты оценки прямо в редакторе.</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3 вводит поддержку &lt;a href=&quot;coding-conventions&quot;&gt;рекомендуемого стиля кода&lt;/a&gt; в IDE. Ознакомьтесь с инструкциями по миграции на &lt;a href=&quot;code-style-migration-guide&quot;&gt;этой странице&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">В Kotlin 1.3 введены беззнаковые целочисленные типы:</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3 ослабляет это ограничение и добавляет поддержку функций с большей арсеналностью:</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">&lt;code&gt;object Object&lt;/code&gt; Kotlin Объект доступен как &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; . Есть функция &lt;code&gt;_instance&lt;/code&gt; для получения единственного экземпляра объекта.</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">Расширения для Android Котлин</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">Котлинские конвенции по кодированию и форматер IntelliJ IDEA</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">Обзор коллекций Котлин</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">Котлин Определение</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">Образовательный модуль Котлина</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">Эволюция Котлина</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">Котлин Примеры</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Плагин Kotlin Gradle 1.3.41 работает с Android Gradle Plugin 3.0 и выше.</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">Kotlin JavaScript Обзор</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;API выборки W3C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">Kotlin JavaScript-оболочки для &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;файлового API W3C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;API XMLHttpRequest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">Обертки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;API времени навигации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">Оболочки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;API веб-уведомлений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">Оболочки Kotlin JavaScript для &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM API.</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM CSS API.</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">Обертки Kotlin JavaScript для DOM SVG API.</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">Котлин JavaScript-обертки для DOM URL API.</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">Котлин JavaScript обертки для DOM событий API.</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">Котлин JavaScript-обертки для API разбора DOM.</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">Котлин JavaScript-обертки для WebGL API.</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">Котлин Коанс</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Котлин Коанс-это серия упражнений,которые познакомят вас с синтаксисом Котлина.Каждое упражнение создается как неудачный юнит-тест,и ваша задача-заставить его пройти.Вы можете работать с Котлинским Коаном одним из следующих двух способов:</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Для многоплатформенных проектов Котлин требуются версии Gradle 4.7 и выше,более старые версии Gradle не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">Многоплатформенные проекты Kotlin поддерживают платформу Android, предоставляя предустановку &lt;code&gt;android&lt;/code&gt; . Для создания цели Android требуется, чтобы к проекту вручную был применен один из плагинов Android Gradle, например &lt;code&gt;com.android.application&lt;/code&gt; или &lt;code&gt;com.android.library&lt;/code&gt; . Для каждого подпроекта Gradle может быть создана только одна цель Android:</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">Котлинские номера и NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">Котлин Программирование:Путеводитель по Большому Ранчо Ботаников</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">API сценариев Котлин</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">Котлин Скриптс (*.kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">Стандартная библиотека Котлина</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin позволяет нам предоставлять реализации для предопределенного набора операторов наших типов. Эти операторы имеют фиксированное символическое представление (например, &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;*&lt;/code&gt; ) и фиксированный &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;приоритет&lt;/a&gt; . Для реализации оператора мы предоставляем функцию- &lt;a href=&quot;functions#member-functions&quot;&gt;член&lt;/a&gt; или функцию &lt;a href=&quot;extensions&quot;&gt;расширения&lt;/a&gt; с фиксированным именем для соответствующего типа, то есть левосторонний тип для бинарных операций и тип аргумента для унарных. Функции, которые перегружают операторы, должны быть помечены модификатором &lt;code&gt;operator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin позволяет компилировать ваши проекты Kotlin в модули JavaScript для популярных модульных систем.Вот список доступных опций:</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin позволяет вам обеспечить видимость символов (что Python делает только с помощью соглашений о подчеркивании) с помощью &lt;em&gt;модификаторов видимости&lt;/em&gt; , которые могут быть помещены в объявления символов. Если вы не предоставите модификатор видимости, вы получите уровень видимости по умолчанию, который является &lt;em&gt;общедоступным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">В Kotlin также есть специализированные классы для представления массивов примитивных типов без накладных расходов: &lt;code&gt;ByteArray&lt;/code&gt; , &lt;code&gt;ShortArray&lt;/code&gt; , &lt;code&gt;IntArray&lt;/code&gt; и так далее. Эти классы не имеют отношения наследования к классу &lt;code&gt;Array&lt;/code&gt; , но имеют одинаковый набор методов и свойств. У каждого из них также есть соответствующая фабричная функция:</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin также поддерживает обычную нотацию для чисел с плавающей точкой:</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Котлин и непрерывная интеграция с TeamCity</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">Котлин и OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Котлин и Свифт определяют nullability как часть спецификации типа,в то время как Objc определяет nullability по методам и свойствам типа.Таким образом,следующее:</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Приложения Kotlin могут быть развернуты на любом хосте,поддерживающем Java-приложения,включая Amazon Web Services,Google Cloud Platform и другие.</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">Котлин как статически типизированный язык программирования хорошо подходит для написания скриптов Gradle build.Благодаря статическому выводу типа,компилятор Kotlin обнаруживает ошибки раньше и выдает важные сообщения об ошибках компиляции и предупреждения.Как IDE,так и компилятор могут использовать информацию о типах для вывода доступных функций и свойств в заданном диапазоне.</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Котлин также может быть использован в качестве скриптового языка.Скрипт-это исходный файл Kotlin (.kts)с исполняемым кодом верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin может быть скомпилирован для нескольких различных платформ.В данном документе мы предполагаем,что целевой платформой является виртуальная машина Java,которая предоставляет некоторые дополнительные возможности-в частности,ваш код будет скомпилирован в байткод Java и,следовательно,будет взаимодействовать с большой экосистемой библиотек Java.</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Котлин может быть использован для любых разработок,будь то серверная часть,клиентская часть,веб или Android.В настоящее время Kotlin/Native работает над поддержкой других платформ,таких как встраиваемые системы,макросы и iOS.Люди используют Kotlin для мобильных и серверных приложений,клиентской стороны с JavaScript или JavaFX,и науки о данных,просто чтобы назвать несколько возможностей.</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin можно использовать вместе с существующими сторонними библиотеками и фреймворками, такими как jQuery или React. Для доступа рамок третьей стороны с сильно типизированным API, вы можете преобразовать определения Машинописи Из &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Определенно Введенные&lt;/a&gt; определений типа хранилище для Котлина с помощью &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; инструмента. В качестве альтернативы вы можете использовать &lt;a href=&quot;dynamic-type&quot;&gt;динамический тип&lt;/a&gt; для доступа к любой структуре без строгой типизации.</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin может быть довольно близок к компактности понимания Python &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; . Предполагая, что &lt;code&gt;people&lt;/code&gt; - это коллекция объектов &lt;code&gt;Person&lt;/code&gt; со свойством &lt;code&gt;name&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin не может различать числовые типы во время выполнения (кроме &lt;code&gt;kotlin.Long&lt;/code&gt; ), т.е. работает следующий код:</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Котлин заботится о стабильности и обратной совместимости кода:Политика совместимости Kotlin гласит,что &quot;прерывание изменений&quot; (например,изменение,которое делает код,который раньше компилировался хорошо,больше не компилируется)может быть введено только в мажорных релизах (1.2,1.3 и т.д.).</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">Классы и интерфейсы Kotlin могут быть разделены на подклассы и протоколы Swift/Objective-C.</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Классы Kotlin имеют базовый класс &lt;code&gt;KotlinBase&lt;/code&gt; в Objective-C, класс расширяет там класс &lt;code&gt;NSObject&lt;/code&gt; . У нас также есть оболочки для коллекций и исключений. Большинство типов коллекций сопоставляются с аналогичными типами коллекций с другой стороны:</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Котлинский код можно легко вызвать с Java.Например,экземпляры класса Kotlin могут быть легко созданы и работать в методах Java.Тем не менее,существуют определенные различия между Java и Котлином,которые требуют внимания при интеграции кода Котлин в Java.На этой странице мы расскажем о том,как настроить взаимодействие вашего кода Котлин с его Java-клиентами.</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Коллекции Kotlin (например, &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; и т. Д.) Не сопоставляются ни с каким конкретным типом JavaScript.</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Коллекции Kotlin конвертируются в коллекции Swift / Objective-C, как описано в таблице выше. Коллекции Swift / Objective-C сопоставляются с Kotlin таким же образом, за исключением &lt;code&gt;NSMutableSet&lt;/code&gt; и &lt;code&gt;NSMutableDictionary&lt;/code&gt; . &lt;code&gt;NSMutableSet&lt;/code&gt; не преобразуется в Kotlin &lt;code&gt;MutableSet&lt;/code&gt; . Чтобы передать объект для Kotlin &lt;code&gt;MutableSet&lt;/code&gt; , вы можете создать такую ​​коллекцию Kotlin явно, создав ее в Kotlin с помощью, например, &lt;code&gt;mutableSetOf()&lt;/code&gt; , или используя класс &lt;code&gt;KotlinMutableSet&lt;/code&gt; в Swift (или &lt;code&gt;${prefix}MutableSet&lt;/code&gt; в Objective-C, где &lt;code&gt;prefix&lt;/code&gt; префикс имен фреймворков). То же самое и с &lt;code&gt;MutableMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Коллекции Kotlin содержат функции для часто используемых &lt;em&gt;агрегатных операций&lt;/em&gt; - операций, которые возвращают одно значение на основе содержимого коллекции. Большинство из них хорошо известны и работают так же, как и на других языках:</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Коллекции Котлина предоставляют набор функций для извлечения отдельных элементов из коллекций.Функции,описанные на этой странице,применимы как к спискам,так и к наборам.</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">Котлинское сообщество открыто,полезно и гостеприимно.Не стесняйтесь присоединяться и спрашивайте на любой понравившейся вам платформе:</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Компилятор Kotlin генерирует обычные JavaScript-классы,функции и свойства,которые вы можете свободно использовать из JavaScript-кода.Тем не менее,есть некоторые тонкости,которые следует помнить.</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Компилятор Kotlin выдает байт-код,таким образом,действительно нет никакой разницы во внешнем виде и ощущении Kotlin-приложений по сравнению с приложениями,написанными на Java.</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">особенности компилятора Kotlin</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Компилятор Kotlin сгенерирует следующий вывод</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Котлинские конструкторы импортируются в качестве инициализаторов в Свифт/Объект-С.</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Котлин документации является хорошим местом,чтобы начать,проверьте эти ссылки,чтобы намочить ноги:</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">В Kotlin нет &lt;em&gt;диспетчеров ресурсов&lt;/em&gt; Python или &lt;em&gt;try-with-resources&lt;/em&gt; Java , но благодаря функциям расширения можно &lt;code&gt;use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">В Kotlin нет проверенных &lt;a href=&quot;exceptions&quot;&gt;исключений&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">Котлин не проверяет исключения.Причин для этого много,но мы приведем простой пример.</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Котлин не реализует ленивую инициализацию свойств верхнего уровня в JavaScript.</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Котлин обеспечивает тип безопасности операций , связанных с &lt;a href=&quot;generics&quot;&gt;дженерики&lt;/a&gt; во время компиляции, в то время, во время выполнения, экземпляры общих типов не держат информацию о своих действительных аргументов типа. Например, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; стирается до &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; . В общем, во время выполнения невозможно проверить, принадлежит ли экземпляр универсальному типу с определенными аргументами типа.</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin подвергает свою структуру пакета JavaScript,поэтому,если вы не определяете свои объявления в корневом пакете,вы должны использовать полностью квалифицированные имена в JavaScript.Например:</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Котлин исправляет ряд проблем,от которых страдает Java:</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Котлин следует конвенциям по наименованию Java.В частности:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Котлин для Android Case Studies</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">Котлин для разработчиков Android</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Котлин для Java-разработчиков</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Объекты с функциональным типом Kotlin (например, лямбды) преобразуются в блоки функций Swift / Objective-C. Однако существует разница в том, как типы параметров и возвращаемые значения отображаются при преобразовании функции и типа функции. В последнем случае примитивные типы отображаются в их коробочное представление. Возвращаемое значение Kotlin &lt;code&gt;Unit&lt;/code&gt; представлено как соответствующий синглтон &lt;code&gt;Unit&lt;/code&gt; в Swift / Objective-C. Значение этого синглтона можно получить так же, как и для любого другого &lt;code&gt;object&lt;/code&gt; Kotlin (см. Синглтоны в таблице выше). Подводя итог:</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Функции Kotlin являются &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;первоклассными&lt;/em&gt;&lt;/a&gt; , что означает, что они могут храниться в переменных и структурах данных, передаваться в качестве аргументов и возвращаться из других &lt;a href=&quot;#higher-order-functions&quot;&gt;функций более высокого порядка&lt;/a&gt; . Вы можете работать с функциями любым способом, который возможен для других нефункциональных значений.</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin генерирует JavaScript код,совместимый с Asynchronous Module Definition (AMD),CommonJS и Universal Model Definition (UMD).</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin обрабатывает номера в некотором роде близко к Java,но не точно так же.Например,для чисел нет неявных расширенных преобразований,а литералы в некоторых случаях немного отличаются.</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Котлин имеет довольно небольшой размер исполняемого файла:библиотека составляет примерно 964КБ (на 1.3.41).Это означает,что Kotlin добавляет немного к размеру .apk файла.</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin располагает обширной стандартной библиотекой,которая может быть использована в ваших приложениях.Настройте следующую зависимость в файле pom:</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Котлин был успешно принят крупными компаниями,и некоторые из них поделились своим опытом:</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin имеет как объектно-ориентированные, так и функциональные конструкции. Вы можете использовать его как в OO, так и в FP-стилях или смешивать их элементы. Благодаря первоклассной поддержке таких функций, как функции высшего порядка, типы функций и лямбда-выражения, Kotlin - отличный выбор, если вы занимаетесь или изучаете функциональное программирование.</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin имеет классы и их члены по умолчанию &lt;code&gt;final&lt;/code&gt; , что делает неудобным использование фреймворков и библиотек, таких как Spring AOP, которые требуют, чтобы классы были &lt;code&gt;open&lt;/code&gt; . &lt;em&gt;Все открытый&lt;/em&gt; плагин компилятора приспосабливается Котлин требований этих рамок и делает классы аннотированные с конкретными аннотациями и их члены открыть без явного &lt;code&gt;open&lt;/code&gt; ключевого слова.</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">У Kotlin есть собственная библиотека отражений (в &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; должен быть включен kotlin-reflection.jar ). При ориентации на JVM вы также можете использовать средства отражения Java. Обратите внимание, что отражение Kotlin еще не совсем полнофункционально - в частности, вы не можете использовать его для проверки встроенных классов, таких как &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">Kotlin унаследовал от Java суетливый (но очень гибкий) способ выполнения ввода-вывода, но с некоторыми упрощающими дополнительными функциями. Мы не будем вдаваться во все это здесь, поэтому для начала вот как перебирать все строки файла (вам понадобится &lt;code&gt;import java.io.File&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin унаследовал систему массивных массивов Java, поэтому у примитивных типов есть свои собственные типы массивов и функции преобразования, в то время как любой другой тип использует общий тип &lt;code&gt;Array&lt;/code&gt; , в который вы можете преобразовать с помощью &lt;code&gt;.toTypedArray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">В Kotlin нет концепции проверенных исключений, все исключения Kotlin не отмечены. Swift только проверял ошибки. Поэтому, если код Swift или Objective-C вызывает метод Kotlin, который генерирует исключение для обработки, тогда метод Kotlin должен быть помечен аннотацией &lt;code&gt;@Throws&lt;/code&gt; . В этом случае все исключения Kotlin (кроме экземпляров &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;RuntimeException&lt;/code&gt; и подклассов) переводятся в Swift error / &lt;code&gt;NSError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin теперь имеет возможность генерировать байт-код Java 8 ( &lt;code&gt;-jvm-target 1.8&lt;/code&gt; командной строки -jvm-target 1.8 или соответствующие параметры в Ant / Maven / Gradle). На данный момент это не меняет семантику байт-кода (в частности, методы по умолчанию в интерфейсах и лямбдах генерируются точно так же, как в Kotlin 1.0), но мы планируем использовать это позже.</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">Kotlin имеет правильные &lt;a href=&quot;lambdas#function-types&quot;&gt;типы функций&lt;/a&gt; , в отличие от Java-преобразований SAM.</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">У Котлина есть три структурных прыжковых выражения:</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Котлин имеет два типа строковых литералов:экранированные строки,в которых могут быть экранированные символы,и сырые строки,которые могут содержать новые строки и произвольный текст.Экрапированная строка очень похожа на Java-строку:</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">Котлин в действии</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Котлин вводит следующие типы для беззнаковых целых чисел:</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">Kotlin-это скомпилированный,статически типизированный язык,который может предоставить некоторые начальные трудности для людей,привыкших к интерпретируемому,динамически типизированному Python.Цель этого документа-объяснить существенную часть синтаксиса Котлина и его концепций с точки зрения того,как они сравниваются с соответствующими концепциями на Python.</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Котлин отлично подходит для разработки Android-приложений,перенося все преимущества современного языка на платформу Android без введения каких-либо новых ограничений:</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin отлично подходит для разработки серверных приложений,позволяя писать лаконичный и выразительный код,сохраняя при этом полную совместимость с существующими стеками технологий на основе Java и плавный ход обучения:</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">Kotlin - это прагматичный и малоизвестный язык, поддерживающий как императивные, так и функциональные стили программирования, не подталкивая разработчика ни к одному из них. Мы можем реализовать функцию &lt;code&gt;f&lt;/code&gt; в функциональном стиле, используя такие функции Kotlin, как &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;хвостовая рекурсия&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin - это статически типизированный язык программирования OSS, предназначенный для JVM, Android, JavaScript и Native. Он разработан &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; . Проект стартовал в 2010 году и с самого начала был открытым. Первый официальный выпуск 1.0 был в феврале 2016 года.</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin совместим с CommonJS, AMD и UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;что упрощает взаимодействие с различными&lt;/a&gt; модульными системами.</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin разработан как прагматичный инструмент для программистов.Когда речь заходит об эволюции языка,его прагматичность определяется следующими принципами:</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin разработан, чтобы его было легко изучить для людей, которые уже знают Java. Краткий обзор различий представлен на &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;официальной странице сравнения&lt;/a&gt; . Краткое введение в базовый синтаксис Kotlin для разработчиков программного обеспечения можно найти прямо в справочном разделе веб-сайта, начиная с &lt;a href=&quot;../reference/basic-syntax&quot;&gt;базового синтаксиса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Котлин разработан с учетом Java-интероперабельности.Существующий Java-код может быть вызван из Котлина естественным образом,а Kotlin-код также может быть использован из Java довольно гладко.В этом разделе мы опишем некоторые детали вызова Java кода из Котлина.</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin распространяется вместе &lt;code&gt;kotlin.js&lt;/code&gt; стандартной библиотекой kotlin.js в виде одного файла, который сам скомпилирован как модуль UMD, поэтому вы можете использовать его с любой системой модулей, описанной выше. Также он доступен на NPM как &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;пакет &lt;/a&gt; &lt;code&gt;kotlin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Котлин вдохновлен существующими языками,такими как Java,C#,JavaScript,Scala и Groovy.Мы постарались сделать так,чтобы Котлин был легким для изучения,чтобы люди могли легко прыгать на борт,читать и писать Котлин в течение нескольких дней.Изучение идиоматического Kotlin и использование некоторых дополнительных функций может занять немного больше времени,но в целом это не сложный язык.</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">Котлин более лаконичен. По приблизительным оценкам, количество строк кода сократилось примерно на 40%. Он также более безопасен для типов, например, поддержка типов, не допускающих значения NULL, делает приложения менее уязвимыми для NPE. Другие функции, включая интеллектуальное преобразование, функции высшего порядка, функции расширения и лямбда-выражения с приемниками, обеспечивают возможность написания выразительного кода, а также упрощают создание DSL.</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin в основном разрабатывается командой инженеров JetBrains (текущий размер команды составляет 50+). Ведущий дизайнер языка - &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Андрей Бреслав&lt;/a&gt; . Помимо основной команды, на GitHub также есть более 250 внешних участников.</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin поддерживается всеми основными IDE Java, включая &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; и &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt; . Кроме того, доступен &lt;a href=&quot;../tutorials/command-line&quot;&gt;компилятор командной строки,&lt;/a&gt; обеспечивающий прямую поддержку компиляции и запуска приложений.</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Котлин хорошо охвачен онлайн-курсами,посмотрите рекомендуемые курсы здесь:</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">Котлин позволяет легко создавать диапазоны значений с помощью &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt; функции из &lt;code&gt;kotlin.ranges&lt;/code&gt; пакета и его оператор формы &lt;code&gt;..&lt;/code&gt; . Обычно &lt;code&gt;rangeTo()&lt;/code&gt; дополняется функциями &lt;code&gt;in&lt;/code&gt; или &lt;code&gt;!in&lt;/code&gt; In .</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin позволяет управлять коллекциями независимо от того, какой именно тип объектов в них хранится. Другими словами, вы добавляете &lt;code&gt;String&lt;/code&gt; в список &lt;code&gt;String&lt;/code&gt; таким же образом, как и с &lt;code&gt;Int&lt;/code&gt; или определяемым пользователем классом. Итак, Стандартная библиотека Kotlin предлагает общие интерфейсы, классы и функции для создания, наполнения и управления коллекциями любого типа.</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">метаданные Котлина</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Модули Kotlin можно использовать в коде Swift / Objective-C, если они скомпилированы в фреймворк (см. Раздел &amp;laquo;Цели и типы вывода&amp;raquo; в &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;документации плагина Gradle&lt;/a&gt; ). См. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;Пример калькулятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin теперь интегрируется с &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;API javax.script&lt;/a&gt; (JSR-223). API позволяет оценивать фрагменты кода во время выполнения:</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin теперь поддерживает сохранение имен параметров в байт-коде. Это можно включить с помощью &lt;code&gt;-java-parameters&lt;/code&gt; командной строки -java-parameters .</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; типы Kotlin, за исключением kotlin.Long , отображаются в JavaScript Number.</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Объекты Котлина могут быть пиннингованы,т.е.их положение в памяти гарантированно будет стабильным до тех пор,пока они не будут пиннингованы,а указатели на такие объекты внутренние данные могут быть переданы в функции С.Например</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">Плагин Kotlin 1.3.21 или выше должен быть установлен в среде IDE. Это можно проверить с помощью &lt;em&gt;Language &amp;amp; Frameworks | &lt;/em&gt;Раздел &quot; &lt;em&gt;Обновления Kotlin&quot;&lt;/em&gt; в &lt;em&gt;настройках&lt;/em&gt; (или &lt;em&gt;предпочтениях&lt;/em&gt; ) среды IDE.</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">Плагин Kotlin для IntelliJ IDEA поддерживает &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;царапины&lt;/a&gt; . Scratches позволяют создавать черновики кода в том же окне IDE, что и ваш проект, и запускать их на лету. Царапины не привязаны к проектам; вы можете получить доступ и запустить все свои царапины из любого окна IntelliJ IDEA в вашей ОС.</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Котлин сохраняет ленивую инициализацию объекта в JavaScript.</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin сохраняет семантику переполнения для &lt;code&gt;kotlin.Int&lt;/code&gt; , &lt;code&gt;kotlin.Byte&lt;/code&gt; , &lt;code&gt;kotlin.Short&lt;/code&gt; , &lt;code&gt;kotlin.Char&lt;/code&gt; и &lt;code&gt;kotlin.Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Коробки примитивных типов Kotlin отображаются в специальные классы Swift / Objective-C. Например, поле &lt;code&gt;kotlin.Int&lt;/code&gt; представлено как &lt;code&gt;KotlinInt&lt;/code&gt; класса KotlinInt в Swift (или экземпляр &lt;code&gt;${prefix}Int&lt;/code&gt; в Objective-C, где &lt;code&gt;prefix&lt;/code&gt; - это префикс имен фреймворков). Эти классы являются производными от &lt;code&gt;NSNumber&lt;/code&gt; , поэтому экземпляры являются собственными &lt;code&gt;NSNumber&lt;/code&gt; , поддерживающими все соответствующие операции.</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">Свойства Kotlin,объявленные в именованном объекте или в качестве объекта-сопутника,будут иметь статические поля подложки либо в этом именованном объекте,либо в классе,содержащем объект-сопутник.</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin предоставляет ряд опций компилятора,которые доступны и в IntelliJ IDEA.В дополнение к тому,что мы только что видели для генерации исходных карт,у нас также есть возможность установить</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">Kotlin предоставляет множество функций для выполнения блока кода в контексте заданного объекта: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , а &lt;code&gt;also&lt;/code&gt; . Инструкции по выбору подходящей функции осциллографа для вашего случая см. В &lt;a href=&quot;scope-functions&quot;&gt;разделе Функции осциллографа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin предоставляет для этого так называемый синтаксис &lt;strong&gt;звездной проекции&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin предоставляет возможность нацеливания на JavaScript.Это делается путем переноса Kotlin на JavaScript.Текущая реализация нацелена на ECMAScript 5.1,но есть планы,что в конце концов она будет нацелена и на ECMAScript 2015.</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin предоставляет следующие встроенные типы представления чисел (это близко к Java):</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Котлин выполняет три задания для муравья:</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin требует, чтобы каждое свойство-член инициализировалось во время создания экземпляра. Иногда класс предназначен для использования таким образом, что у конструктора недостаточно информации для инициализации всех свойств (например, при создании класса построителя или при использовании внедрения зависимостей на основе свойств). Чтобы не делать эти свойства обнуляемыми, вы можете использовать &lt;em&gt;свойство&lt;/em&gt; с &lt;em&gt;поздней инициализацией&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">Скрипты Kotlin в файлах &lt;code&gt;build.gradle.kts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">Синглтон Kotlin (сделанный с объявлением &lt;code&gt;object&lt;/code&gt; , включая &lt;code&gt;companion object&lt;/code&gt; ) импортируется в Swift / Objective-C как класс с одним экземпляром. Экземпляр доступен через фабричный метод, то есть как &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; в Objective-C и &lt;code&gt;MySingleton()&lt;/code&gt; в Swift.</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">котлинские синглоны</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">Kotlin исходный файл или каталог для компиляции</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Исходные наборы Kotlin могут быть связаны с отношением &lt;em&gt;&amp;laquo;зависит от&amp;raquo;&lt;/em&gt; , так что если исходный набор &lt;code&gt;foo&lt;/code&gt; зависит от &lt;code&gt;bar&lt;/code&gt; исходного набора, то:</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Исходные тексты Kotlin могут смешиваться с исходными текстами Java в одной и той же папке или в разных папках.По умолчанию используются разные папки:</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Артефакты стандартной библиотеки Kotlin и сплит-пакеты</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin поддерживает стиль функционального программирования, известный как &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;хвостовая рекурсия&lt;/a&gt; . Это позволяет записывать некоторые алгоритмы, которые обычно пишутся с использованием циклов, с использованием рекурсивной функции, но без риска переполнения стека. Когда функция помечена модификатором &lt;code&gt;tailrec&lt;/code&gt; и соответствует требуемой форме, компилятор оптимизирует рекурсию, оставляя вместо этого быструю и эффективную версию на основе цикла:</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает обработку &lt;em&gt;аннотаций с помощью инструмента обработки аннотаций Kotlin&lt;/em&gt; ( &lt;code&gt;kapt&lt;/code&gt; ). Использование kapt с Gradle описано на &lt;a href=&quot;kapt&quot;&gt;странице kapt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin поддерживает локальные функции,т.е.функцию внутри другой функции:</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin поддерживает наследование классов с одним родителем - поэтому каждый класс (кроме корневого класса &lt;code&gt;Any&lt;/code&gt; ) имеет ровно один родительский класс, называемый &lt;em&gt;суперклассом&lt;/em&gt; . Kotlin хочет, чтобы вы продумали дизайн своего класса, чтобы убедиться, что его действительно безопасно создавать &lt;em&gt;подклассы&lt;/em&gt; , поэтому классы по умолчанию &lt;em&gt;закрыты&lt;/em&gt; и не могут быть унаследованы, если вы явно не объявите класс &lt;em&gt;открытым&lt;/em&gt; или &lt;em&gt;абстрактным&lt;/em&gt; . Затем вы можете создать подкласс от этого класса, объявив новый класс, который упоминает свой родительский класс после двоеточия:</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin поддерживает следующие операторы и специальные символы:</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает стандартный набор арифметических операций с числами, которые объявлены как члены соответствующих классов (но компилятор оптимизирует вызовы до соответствующих инструкций). См. &lt;a href=&quot;operator-overloading&quot;&gt;Перегрузка оператора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">Kotlin поддерживает традиционные операторы &lt;em&gt;break&lt;/em&gt; и &lt;em&gt;continue&lt;/em&gt; в циклах. См. &lt;a href=&quot;returns&quot;&gt;Возвраты и прыжки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin нацелен на широкий спектр версий Java, включая Java 6 и Java 7, где методы по умолчанию в интерфейсах не разрешены. Для вашего удобства компилятор Kotlin обходит это ограничение, но этот обходной путь несовместим с методами по &lt;code&gt;default&lt;/code&gt; , представленными в Java 8.</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">Котлин на JavaScript</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin специально обрабатывает некоторые типы Java. Такие типы не загружаются из Java &amp;laquo;как есть&amp;raquo;, а &lt;em&gt;отображаются&lt;/em&gt; на соответствующие типы Kotlin. Отображение имеет значение только во время компиляции, представление времени выполнения остается неизменным. Примитивные типы Java сопоставляются с соответствующими типами Kotlin (имея в виду &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;типы платформ&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin превращает возвращаемый тип указателя функции в объект &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; допускающий значение NULL . Сначала необходимо явно проверить значение &lt;code&gt;null&lt;/code&gt; . Для этого мы используем &lt;a href=&quot;../../reference/null-safety&quot;&gt;оператор elvis&lt;/a&gt; . Инструмент &lt;code&gt;cinterop&lt;/code&gt; помогает нам превратить указатель функции C в легко вызываемый объект в Kotlin. Это то, что мы сделали в последней строке.</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">Котлин использует семейство типов функций , таких как &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; для объявлений , которые имеют дело с функциями: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin использует префикс &lt;code&gt;libnative_&lt;/code&gt; для всех объявлений в созданном файле &lt;code&gt;libnative_api.h&lt;/code&gt; . Представим отображение типов более наглядно:</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin был разработан для удобного взаимодействия с платформой Java. Он видит классы Java как классы Kotlin, а Java видит классы Kotlin как классы Java. Однако JavaScript - это язык с динамической типизацией, что означает, что он не проверяет типы во время компиляции. Вы можете свободно общаться с JavaScript из Kotlin через &lt;a href=&quot;dynamic-type&quot;&gt;динамические&lt;/a&gt; типы, но если вам нужна вся мощь системы типов Kotlin, вы можете создавать заголовки Kotlin для библиотек JavaScript.</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin позволит вам объявить это свойство без его инициализации, и вы можете установить значение свойства в какой-то момент после построения (напрямую или через функцию). Сам класс, а также его пользователи обязаны позаботиться о том, чтобы не читать свойство до того, как оно было установлено, и Kotlin позволяет вам писать код, который считывает &lt;code&gt;name&lt;/code&gt; как если бы это было обычное свойство, не допускающее значения NULL. Однако компилятор не может обеспечить правильное использование, поэтому, если свойство читается до того, как оно было установлено, во время выполнения будет &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin довольно гладко работает с Spring Boot, и многие шаги, описанные в &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; по созданию службы RESTful, можно дословно выполнить для Kotlin. Однако есть некоторые незначительные различия, когда дело доходит до определения конфигурации Gradle и структуры макета проекта, а также кода инициализации.</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin работает с различными &lt;a href=&quot;build-tools&quot;&gt;инструментами сборки&lt;/a&gt; , поэтому, если мы используем стандартный инструмент, такой как Ant, Maven или Gradle, процесс настройки проекта Kotlin ничем не отличается от любого другого языка или библиотеки, которые интегрируются с этими инструментами. Там, где есть некоторые незначительные требования и различия, - это использование JBS, внутренней системы сборки, которую использует IntelliJ IDEA, которая также поддерживается в TeamCity.</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Подход Котлина к работе с асинхронным кодом заключается в использовании коруселей,то есть в идее приостановки вычислений,т.е.в идее,что функция может в какой-то момент приостановить свое выполнение,а потом возобновить его.</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Инструмент создания документации Kotlin называется &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; . Инструкции по использованию см. В &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Синтаксис документации Kotlin называется &lt;em&gt;KDoc&lt;/em&gt; . Блок KDoc помещается над конструкцией, которую он описывает, и начинается с &lt;code&gt;/**&lt;/code&gt; и заканчивается &lt;code&gt;*/&lt;/code&gt; (возможно, на одной строке; в противном случае каждая промежуточная строка должна начинаться с выровненной звездочки). Первый блок текста - это резюме; затем вы можете использовать &lt;em&gt;блочные теги&lt;/em&gt; для предоставления информации о конкретных частях конструкции. Некоторые теги блоков - это &lt;code&gt;@param&lt;/code&gt; для параметров функции и параметров универсального типа и &lt;code&gt;@return&lt;/code&gt; для возвращаемого значения. Вы можете ссылаться на идентификаторы внутри скобок. Весь текст за пределами ссылок и имен тегов блоков находится в формате Markdown.</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Дженерики Kotlin немного отличаются от Java (см. &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt; ). При импорте типов Java в Kotlin мы выполняем некоторые преобразования:</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Циклы Kotlin похожи на циклы Python. &lt;code&gt;for&lt;/code&gt; выполняет &lt;em&gt;итерацию&lt;/em&gt; по всему, что является &lt;em&gt;итератором&lt;/em&gt; (все, что имеет функцию &lt;code&gt;iterator()&lt;/code&gt; которая предоставляет объект &lt;code&gt;Iterator&lt;/code&gt; ), или все, что само является итератором:</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">Объектная модель Kotlin существенно отличается от модели Python. Самое главное, классы &lt;em&gt;не&lt;/em&gt; могут &lt;em&gt;быть&lt;/em&gt; изменены динамически во время выполнения! (Есть некоторые ограниченные исключения из этого, но вы вообще не должны делать это , однако,. &lt;em&gt;Есть&lt;/em&gt; возможность динамически &lt;em&gt;проверять&lt;/em&gt; классы и объекты во время выполнения с помощью функции , называемой &lt;em&gt;рефлексии&lt;/em&gt; . - это может быть полезно, но должны быть разумно использованы) Все свойства (атрибуты) и функции, которые могут когда-либо понадобиться в классе, должны быть объявлены либо непосредственно в теле класса, либо как &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;функции расширения&lt;/em&gt;&lt;/a&gt; , поэтому вам следует тщательно продумать дизайн своего класса.</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Система типов Kotlin направлена ​​на устранение опасности нулевых ссылок из кода, также известной как &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;ошибка&lt;/a&gt; на миллиард долларов .</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Система типов Kotlin направлена ​​на устранение исключений &lt;code&gt;NullPointerException&lt;/code&gt; из нашего кода. Единственными возможными причинами НПЭ могут быть:</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin, как язык, предоставляет только минимальные низкоуровневые API в своей стандартной библиотеке, чтобы позволить другим библиотекам использовать сопрограммы. В отличие от многих других языков с аналогичными возможностями, &lt;code&gt;async&lt;/code&gt; и &lt;code&gt;await&lt;/code&gt; не являются ключевыми словами в Kotlin и даже не являются частью его стандартной библиотеки. Более того, концепция &lt;em&gt;приостановки функции&lt;/em&gt; Kotlin обеспечивает более безопасную и менее подверженную ошибкам абстракцию для асинхронных операций, чем Futures и Promises.</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">Kotlin, подобно C # и Gosu, предоставляет возможность расширять класс с помощью новых функций без необходимости наследовать от класса или использовать какой-либо тип шаблона проектирования, такой как Decorator. Это делается с помощью специальных объявлений, называемых &lt;em&gt;расширениями&lt;/em&gt; . Котлин поддерживает &lt;em&gt;функцию расширения&lt;/em&gt; и &lt;em&gt;свойство расширения&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
