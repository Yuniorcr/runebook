<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="2e3cf95b689244eb673190f3f6791a8430eef505" translate="yes" xml:space="preserve">
          <source>To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">Чтобы запустить приложение, щелкните правой кнопкой мыши где-нибудь в главном файле и выберите &amp;laquo; &lt;strong&gt;Запуск от имени&amp;raquo; | Приложение Kotlin&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="307aa135f670640b026c3a84d1ad04d1025f9beb" translate="yes" xml:space="preserve">
          <source>To run the tests in the browser, we can execute the &lt;code&gt;browserTest&lt;/code&gt; task via IntelliJ IDEA, or use the gutter icons to execute all or individual tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">Чтобы сохранить курс в виде zip-файла, выберите &amp;laquo; &lt;strong&gt;Создатель курса&amp;raquo; -&amp;gt; &amp;laquo;Создать архив курса&amp;raquo;&lt;/strong&gt; . Созданный архив можно открыть через &lt;strong&gt;Обзор курсов,&lt;/strong&gt; доступный на &lt;strong&gt;экране приветствия,&lt;/strong&gt; и в &lt;strong&gt;меню &amp;laquo;Файл&amp;raquo;&lt;/strong&gt; с помощью значка &amp;laquo; &lt;strong&gt;Импорт курса&amp;raquo;&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">Чтобы найти элемент в отсортированном списке, вызовите &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt; передав значение в качестве аргумента. Если такой элемент существует, функция возвращает его индекс; в противном случае он возвращает &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; где точка &lt;code&gt;insertionPoint&lt;/code&gt; - это индекс, в который следует вставить этот элемент, чтобы список оставался отсортированным. Если имеется более одного элемента с данным значением, поиск может вернуть любой из их индексов.</target>
        </trans-unit>
        <trans-unit id="bf705e6bade184c44c4ccccae5cda8a8acf3a41e" translate="yes" xml:space="preserve">
          <source>To see how we can express how elements in the DOM can be created and structured in a concise way, check out the the &lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">Чтобы увидеть полный скрипт Gradle,проверьте источник проекта на GitHub.</target>
        </trans-unit>
        <trans-unit id="6bc22d1c45afda0ba0e9856d43874792a674530d" translate="yes" xml:space="preserve">
          <source>To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">Чтобы выбрать модульную систему при компиляции через Gradle, вы должны установить свойство &lt;code&gt;moduleKind&lt;/code&gt; , т.е.</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">Чтобы выбрать модульную систему при компиляции через Maven, вы должны установить &lt;code&gt;moduleKind&lt;/code&gt; конфигурации moduleKind , т.е. ваш &lt;code&gt;pom.xml&lt;/code&gt; должен выглядеть так:</target>
        </trans-unit>
        <trans-unit id="45e994b1f4d37b99eaddc699cd613274dee03180" translate="yes" xml:space="preserve">
          <source>To set another location for project distribution files, add the &lt;code&gt;distribution&lt;/code&gt; block inside &lt;code&gt;browser&lt;/code&gt; in the build script and assign a value to the &lt;code&gt;directory&lt;/code&gt; property. Once you run a project build task, Gradle will save the output bundle in this location together with project resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269c5e540e50596c2266b2737868df5485939c07" translate="yes" xml:space="preserve">
          <source>To set the desired level, specify the &lt;code&gt;level&lt;/code&gt; parameter of the &lt;code&gt;@RequiresOptIn&lt;/code&gt; annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">Чтобы настроить многоплатформенный проект с нуля в проекте Gradle, сначала примените к &lt;code&gt;kotlin-multiplatform&lt;/code&gt; плагин kotlin-multiplatform , добавив следующее в начало файла &lt;code&gt;build.gradle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">Для того, чтобы пропустить автоматическое преобразование и обеспечить сырые указатели используются в переплетах, &lt;code&gt;noStringConversion&lt;/code&gt; заявление в &lt;code&gt;.def&lt;/code&gt; файл может быть использовано, т.е.</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">Чтобы решить такие проблемы, Kotlin вводит особый вид класса, называемый &lt;code&gt;inline class&lt;/code&gt; , который объявляется путем размещения &lt;code&gt;inline&lt;/code&gt; модификатора перед именем класса:</target>
        </trans-unit>
        <trans-unit id="885ff03b6c597841318a22240c06f643cf1cd5fb" translate="yes" xml:space="preserve">
          <source>To solve this, mark the targets on both the library author and consumer sides with a custom attribute, which Gradle uses during dependency resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">Чтобы указать видимость основного конструктора класса, используйте следующий синтаксис (обратите внимание, что вам нужно добавить явное ключевое слово &lt;em&gt;конструктора&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">Чтобы указать дополнительные параметры компиляции, используйте свойство &lt;code&gt;kotlinOptions&lt;/code&gt; задачи компиляции Kotlin.</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">Чтобы указать, что тип функции допускает &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;значение NULL&lt;/a&gt; , используйте круглые скобки: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="fa582abf300c214133b85270789a22565f82393f" translate="yes" xml:space="preserve">
          <source>To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда завершается сопрограмма с результатом или исключением. Последующий вызов любой функции возобновления в результирующем продолжении вызовет &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключение IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда завершается сопрограмма с результатом или исключением. Последующий вызов любой функции возобновления в результирующем продолжении вызовет &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключение IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93a4c159e45ae9b13567d12cfe549a89c643e81c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03689575e5ce0d05cb5875c63b25386ef2dc70ce" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением. Повторный вызов любой функции возобновления в результирующем продолжении приводит к &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключению IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением. Повторный вызов любой функции возобновления в результирующем продолжении приводит к &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;исключению IllegalStateException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре Continuation. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением.</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре Continuation. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением.</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре Continuation. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением.</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">Чтобы начать выполнение созданной сопрограммы, вызовите &lt;code&gt;resume(Unit)&lt;/code&gt; в возвращенном экземпляре Continuation. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;Завершение&lt;/a&gt; продолжение вызывается , когда сопрограмма завершается с результатом или исключением.</target>
        </trans-unit>
        <trans-unit id="107268b53cdccea4df633455aa08e9eb59213796" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c18083bec73d38fe935b18a61bfb26719f41fa" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">Чтобы начать курс, перейдите в &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt; . Вы найдете план курса, список уроков. В каждом уроке есть набор задач и упражнений по коду, которые вам нужно решить. Начнем с самого первого:</target>
        </trans-unit>
        <trans-unit id="af4a3359bcc2d8aaecee721a7eaa5358429907bb" translate="yes" xml:space="preserve">
          <source>To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">Для начала нам понадобится установленный компилятор Microsoft Visual C++,поддерживающий цель x64_64.Проще всего это сделать,установив версию Microsoft Visual Studio на Windows-машину.</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">Чтобы переключиться на старое поведение, передайте &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; флаг возврата -Xno-Receiver-assertions .</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">Чтобы переключиться на старое поведение интеллектуального приведения, передайте резервный флаг &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; в качестве аргумента компилятора. Он станет устаревшим в Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="526447430819405af6d133c6984847835417ebe8" translate="yes" xml:space="preserve">
          <source>To symbolicate addresses in Kotlin code (e.g. for stack trace elements corresponding to Kotlin code) &lt;code&gt;.dSYM&lt;/code&gt; bundle for Kotlin code is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">Чтобы взять все элементы, кроме заданного количества первых или последних элементов, вызовите функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="27b36af5861b299fc805f783568e62a3fc319e12" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">Чтобы настроить таргетинг на JVM, примените плагин Kotlin JVM. Начиная с Kotlin 1.1.1, плагин можно применять с помощью &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;DSL плагинов Gradle&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">Чтобы сообщить Kotlin, что определенное объявление написано на чистом JavaScript, вы должны пометить его &lt;code&gt;external&lt;/code&gt; модификатором. Когда компилятор видит такое объявление, он предполагает, что реализация для соответствующего класса, функции или свойства предоставляется разработчиком, и поэтому не пытается сгенерировать какой-либо код JavaScript из объявления. Это означает, что вы должны опускать тела &lt;code&gt;external&lt;/code&gt; объявлений. Например:</target>
        </trans-unit>
        <trans-unit id="c054ec329a7a56272832fde51ee7e82f8f4336b8" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">Чтобы сообщить Kotlin, что &lt;code&gt;external&lt;/code&gt; класс, пакет, функция или свойство является модулем JavaScript, вы можете использовать аннотацию &lt;code&gt;@JsModule&lt;/code&gt; . Предположим, у вас есть следующий модуль CommonJS с именем &quot;hello&quot;:</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">Для тестирования будем использовать простую асинхронную функцию,которая по истечении заданного времени разрешается на указанную строку:</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">Чтобы создать объект исключения, используйте выражение &lt;em&gt;throw&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="c7a0e8b8a829212ce4bf38fa9f7e144c221c0093" translate="yes" xml:space="preserve">
          <source>To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d84f46ddf483c214d924898fdd70375c5841ef" translate="yes" xml:space="preserve">
          <source>To turn on CSS support in your project, set the &lt;code&gt;cssSupport.enabled&lt;/code&gt; flag in the Gradle build file for &lt;code&gt;webpackTask&lt;/code&gt;, &lt;code&gt;runTask&lt;/code&gt;, and &lt;code&gt;testTask&lt;/code&gt; respectively. This configuration is also enabled by default when creating a new project using the wizard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">Чтобы развернуть ссылку:</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы распаковать список пар, вызовите &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0e0cb040b2c181af6e3ea61de668187d10e532" translate="yes" xml:space="preserve">
          <source>To use a property, simply refer to it by name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">Чтобы использовать свойство,мы просто ссылаемся на него по имени,как на поле в Java:</target>
        </trans-unit>
        <trans-unit id="f72769e7770abb5ce6cba411b555a198f8e3b8fb" translate="yes" xml:space="preserve">
          <source>To use an API that requires opt-in in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:OptIn&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">Чтобы вместо этого использовать сборку EAP, нам нужно указать ее версию в &lt;code&gt;ext.kotlin_version&lt;/code&gt; и добавить соответствующий репозиторий в раздел &lt;code&gt;buildscript&lt;/code&gt; (обычно сборки EAP находятся на &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">Чтобы использовать экспериментальный API во всех функциях и классах в файле, добавьте аннотацию на уровне файла &lt;code&gt;@file:UseExperimental&lt;/code&gt; в начало файла перед спецификацией пакета и импортом.</target>
        </trans-unit>
        <trans-unit id="c7911ada2a93fd834ce5409496ee220d5914c628" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">Чтобы использовать классы или функции из проекта в рабочем состоянии, импортируйте их в рабочий файл, как обычно, с помощью оператора &lt;code&gt;import&lt;/code&gt; . Затем напишите свой код и запустите его с соответствующим модулем, выбранным в поле &amp;laquo; &lt;strong&gt;Использовать путь к классам&amp;raquo; в&lt;/strong&gt; списке &lt;strong&gt;модулей&lt;/strong&gt; . Чтобы автоматически перестроить модуль перед запуском нуля, выберите &amp;laquo; &lt;strong&gt;Сделать перед&lt;/strong&gt; запуском&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="5befb1fd889ec3d540fc6857e1cc44328178daf4" translate="yes" xml:space="preserve">
          <source>To use different modes for the same project, use &lt;code&gt;cssSupport.rules&lt;/code&gt;. Here, you can specify a list of &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt;, each of which define a mode, as well as &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;include&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;exclude&lt;/a&gt; patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать его с Kotlin, настройте зависимость обработки аннотаций с помощью &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6b18f46b3a0f449d7eb395f93e2e99d2ceb07f22" translate="yes" xml:space="preserve">
          <source>To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">Чтобы использовать такое расширение вне декларирующего пакета,необходимо импортировать его на сайте звонка:</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">Чтобы использовать Gradle worker API для параллельного выполнения задач kapt, добавьте эту строку в свой файл &lt;code&gt;gradle.properties&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">Чтобы пользоваться библиотекой просто</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">Чтобы использовать эти зависимости из кода Kotlin, импортируйте пакет &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; . В приведенном выше примере это &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc228ddfd7202033ce71a7fc317732c5e0b0cb8d" translate="yes" xml:space="preserve">
          <source>To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f56a6a1ece973c1e685039b7b24f3bed65f0bb" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">Чтобы проверить,что ваш код отформатирован в соответствии с руководством по стилю,перейдите к настройкам проверки и включите проверку &quot;Kotlin | Вопросы стиля | Файл не отформатирован в соответствии с настройками проекта&quot;.Дополнительные проверки,которые проверяют другие проблемы,описанные в руководстве по стилю (например,соглашения о названиях),включены по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a4960c3af648de37ee9fc988a1b8a755e743e505" translate="yes" xml:space="preserve">
          <source>To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">Завернуть ссылку:</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">Инструменты для разработки Android</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">Переменные верхнего уровня / глобальные переменные непримитивных типов по умолчанию доступны только в основном потоке (т. &lt;em&gt;Е.&lt;/em&gt; Потоке, который первым инициализировал среду выполнения &lt;em&gt;Kotlin / Native&lt;/em&gt; ). Доступ из другого потока приведет к возникновению &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; . Чтобы сделать такие переменные доступными в других потоках, вы можете использовать аннотацию &lt;code&gt;@ThreadLocal&lt;/code&gt; и отметить значение потока local или &lt;code&gt;@SharedImmutable&lt;/code&gt; , что сделает значение замороженным и доступным из других потоков.</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">Функции и свойства Kotlin верхнего уровня доступны как члены специальных классов.Каждый файл Kotlin переводится в такой класс.например</target>
        </trans-unit>
        <trans-unit id="72f832e9bb11ffaf0e6dadede4c2d82d643da82d" translate="yes" xml:space="preserve">
          <source>Top-level blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">Функции и свойства верхнего уровня</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">Переменные верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Верхний уровень, или член &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;объекта&lt;/em&gt; декларации&lt;/a&gt; или &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;в &lt;em&gt;объекте компаньона&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="1efa29eabe3ababde0e86df3b6d2edc46db3122e" translate="yes" xml:space="preserve">
          <source>TouchList</source>
          <target state="translated">TouchList</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="04a727b8d4352f2bb05170808566a662370f1470" translate="yes" xml:space="preserve">
          <source>Trailing comma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5b3a2e5f602edd973d6bc7c27d9b7106a52ef4" translate="yes" xml:space="preserve">
          <source>Trailing commas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b9c6cd7256580987215cb5bd31fae33f7491a8" translate="yes" xml:space="preserve">
          <source>Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">Партнеры по обучению</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="5493525620b201e4aeb2e3e266e9b2a0148f6e9a" translate="yes" xml:space="preserve">
          <source>Transform operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e58ba5ae9c3b287bdcbf2771b01865f2bca67751" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Iterable&lt;/code&gt; on &lt;code&gt;Sequence&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c5e51e91e71b63dc5528985dabb38605c21cee" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Sequence&lt;/code&gt; on &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Map&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d5bc5a6500f8488347501d41f5194f063eae68" translate="yes" xml:space="preserve">
          <source>Transient</source>
          <target state="translated">Transient</target>
        </trans-unit>
        <trans-unit id="ba8d3f89d630067e3ad00c3e459e314bd98fb9a0" translate="yes" xml:space="preserve">
          <source>Transitive: for any non-null values &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if &lt;code&gt;x.equals(y)&lt;/code&gt; returns true and &lt;code&gt;y.equals(z)&lt;/code&gt; returns true, then &lt;code&gt;x.equals(z)&lt;/code&gt; should return true.</source>
          <target state="translated">Транзитивный: для любых ненулевых значений &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; , если &lt;code&gt;x.equals(y)&lt;/code&gt; возвращает true, а &lt;code&gt;y.equals(z)&lt;/code&gt; возвращает true, то &lt;code&gt;x.equals(z)&lt;/code&gt; должен возвращать true.</target>
        </trans-unit>
        <trans-unit id="a3b98ac58ac04384390fe968f8d17e1762075dcc" translate="yes" xml:space="preserve">
          <source>Translate primitive arrays to JS typed arrays</source>
          <target state="translated">Перевести примитивные массивы в массивы,набранные в формате JS</target>
        </trans-unit>
        <trans-unit id="a1e378439cd6792c22e6754f9de426ee92e8887a" translate="yes" xml:space="preserve">
          <source>Translated to</source>
          <target state="translated">Переведено на</target>
        </trans-unit>
        <trans-unit id="bd2fa02487c23403447e0670b33275ea05db6a74" translate="yes" xml:space="preserve">
          <source>Translation Rules</source>
          <target state="translated">Правила перевода</target>
        </trans-unit>
        <trans-unit id="ab6dfa598f3ee1889c506fcb09d74fa1777c572b" translate="yes" xml:space="preserve">
          <source>Translation of type &lt;code&gt;Nothing&lt;/code&gt;</source>
          <target state="translated">Перевод типа &lt;code&gt;Nothing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6aceb57c8bb80570e896470165c635c1ee57a688" translate="yes" xml:space="preserve">
          <source>Translation rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d92e703a622ed46d6e27f0f0f77397beeb3e132" translate="yes" xml:space="preserve">
          <source>Transparent catch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15aca388afb19d901171e68fd72afd431d071e5" translate="yes" xml:space="preserve">
          <source>Traversing a map/list of pairs</source>
          <target state="translated">Путешествие по карте/списку пар</target>
        </trans-unit>
        <trans-unit id="c5549ac8b888e22b01fa637b7351d8e5201d7fba" translate="yes" xml:space="preserve">
          <source>TreeWalker</source>
          <target state="translated">TreeWalker</target>
        </trans-unit>
        <trans-unit id="bf7930508d19dc53b19991f963b30e949ffffae4" translate="yes" xml:space="preserve">
          <source>Trigonometric: &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; and inverse of them: &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;</source>
          <target state="translated">Тригонометрические: &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; и обратные им: &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b9283be1760ffff3d2b71a4bf3400fc0c777b4fb" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Обрезает начальные пробельные символы, за которыми следует &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix,&lt;/a&gt; из каждой строки исходной строки и удаляет первую и последнюю строки, если они пустые (обратите внимание на разницу между пустыми и пустыми).</target>
        </trans-unit>
        <trans-unit id="5480c14a1f35b84e453f6cd73b5a2004a2f5d464" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35e61d912f4e00490fababb98d899c86bab87f9" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Обрезает начальные пробельные символы, за которыми следует &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix,&lt;/a&gt; из каждой строки исходной строки и удаляет первую и последнюю строки, если они пустые (обратите внимание на разницу между пустыми и пустыми).</target>
        </trans-unit>
        <trans-unit id="84a97aca5ec5480f19364dafde3094ff54f3e81a" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1a12e0ad64ac32c1b6bcc5a4f65c861d2ccdb6" translate="yes" xml:space="preserve">
          <source>Triple</source>
          <target state="translated">Triple</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="dd25f60abb02d8a8fead2fd0c632ac71f7dc7572" translate="yes" xml:space="preserve">
          <source>True if this BitSet contains no bits set to true.</source>
          <target state="translated">Верно,если этот BitSet не содержит битов,установленных в true.</target>
        </trans-unit>
        <trans-unit id="ebadece2244cd8c3930af24f6efed50ba5303aeb" translate="yes" xml:space="preserve">
          <source>Try is an expression</source>
          <target state="translated">Попробуй-это выражение</target>
        </trans-unit>
        <trans-unit id="76626410fd299e2579daa03a6a8e059a7c331dac" translate="yes" xml:space="preserve">
          <source>Try running the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab16b9ed40416d31269e0f90879c02e2beaffb5d" translate="yes" xml:space="preserve">
          <source>Try the following example:</source>
          <target state="translated">Попробуйте следующий пример:</target>
        </trans-unit>
        <trans-unit id="6598cd1f03cde7303010f8b82688f8cd83e05fd7" translate="yes" xml:space="preserve">
          <source>Try the hierarchical project structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8975e856a765f6b65172a38acea83accc861c3" translate="yes" xml:space="preserve">
          <source>Tuning the Gradle Build Script</source>
          <target state="translated">Настройка сценария строительства колыбели</target>
        </trans-unit>
        <trans-unit id="ea1b6a2e19cb07b905a5f8a640d896e87bcec9bf" translate="yes" xml:space="preserve">
          <source>Turn any warnings into a compilation error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486df8c49f3484e79ec93676a1d2d32e3c21544f" translate="yes" xml:space="preserve">
          <source>Turn off the discovery of annotation processors in the compile classpath by adding this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">Отключите обнаружение обработчиков аннотаций в пути к классам компиляции, добавив эту строку в свой файл &lt;code&gt;gradle.properties&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a8a70d82aa05be09e708b91e7f3e4c134d89ffcd" translate="yes" xml:space="preserve">
          <source>Two characters are considered the same ignoring case if at least one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Два символа считаются одинаковыми , игнорируя случай , если хотя бы один из следующих является &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab472c51dfbccf051740af19176dfafb00b61af8" translate="yes" xml:space="preserve">
          <source>Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.</source>
          <target state="translated">Два генератора с одним и тем же посевным материалом производят одну и ту же последовательность значений в пределах одной и той же версии рабочего времени Kotlin.</target>
        </trans-unit>
        <trans-unit id="d137720f3328e5a478b178126ce3903c8817736d" translate="yes" xml:space="preserve">
          <source>Two maps containing the equal pairs are equal regardless of the pair order.</source>
          <target state="translated">Две карты,содержащие равные пары,равны вне зависимости от порядка следования пар.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="5f6616a8e5da9fee3d521ed755f2bea54b08215a" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: &amp;#x27;is&amp;#x27; and &amp;#x27;as&amp;#x27;</source>
          <target state="translated">Проверка типов и приведение типов: 'is' и 'as'</target>
        </trans-unit>
        <trans-unit id="d6cc07866d5f06f3719a56316deb52a9dd1a6362" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: 'is' and 'as'</source>
          <target state="translated">Введите Checks and Casts:'is' и 'as'.</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">Псевдоним типа</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">Псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="723718d194ac3a64c7f264ffc4d4f72b344ce07d" translate="yes" xml:space="preserve">
          <source>Type aliases can have only one member, while functional interfaces can have multiple non-abstract members and one abstract member. Functional interfaces can also implement and extend other interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c8e849ce31321a314a70ac8ad4ed39beff1378" translate="yes" xml:space="preserve">
          <source>Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; in your code, the Kotlin compiler always expands it to &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt;. Thus you can pass a variable of your type whenever a general function type is required and vice versa:</source>
          <target state="translated">Псевдонимы типов не вводят новых типов. Они эквивалентны соответствующим базовым типам. Когда вы добавляете &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; и используете &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; в своем коде, компилятор Kotlin всегда расширяет его до &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt; . Таким образом, вы можете передавать переменную своего типа всякий раз, когда требуется общий тип функции, и наоборот:</target>
        </trans-unit>
        <trans-unit id="63f9c00fb5f4cc41a0eed5075c935b736c6b9723" translate="yes" xml:space="preserve">
          <source>Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.</source>
          <target state="translated">Псевдонимы типов обеспечивают альтернативные имена для существующих типов.Если имя типа слишком длинное,вы можете ввести другое короткое имя и использовать вместо него новое.</target>
        </trans-unit>
        <trans-unit id="a2a8d10c5940641abcd5ce54fb8bcd8a1818a8ed" translate="yes" xml:space="preserve">
          <source>Type annotations in the JVM bytecode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c296bfc3cf8da18578c109dce183097398bf868c" translate="yes" xml:space="preserve">
          <source>Type annotations on method parameters, method return types and property types;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35e3a28b52f56ce98adcccb56e038088090c61a" translate="yes" xml:space="preserve">
          <source>Type arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97f977bc0dba85c3cc52fd08f6033a3696be06a" translate="yes" xml:space="preserve">
          <source>Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</source>
          <target state="translated">Аргументы типа могут быть опущены,если их можно вывести из контекста,поэтому следующий пример тоже работает:</target>
        </trans-unit>
        <trans-unit id="c98c974ad55a448f7905288ae79a3c29e3dafc00" translate="yes" xml:space="preserve">
          <source>Type arguments passed for the parameters of the classifier in this type. For example, in the type &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; the only type argument is &lt;code&gt;out Number&lt;/code&gt;.</source>
          <target state="translated">Аргументы типа, передаваемые для параметров классификатора в этом типе. Например, в типе &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; единственный аргумент типа &lt;code&gt;out Number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17f4a34465afc16c831c4800dd92a48a4229a238" translate="yes" xml:space="preserve">
          <source>Type casts to generic types with concrete type arguments, e.g. &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt;, cannot be checked at runtime.</source>
          <target state="translated">Приведение типов к универсальным типам с конкретными аргументами типа, например &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt; , не может быть проверено во время выполнения.</target>
        </trans-unit>
        <trans-unit id="73156460a89d705ba62bd534bd81f39c8db2596a" translate="yes" xml:space="preserve">
          <source>Type checks and automatic casts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793f10e89d89960ec6635302ed647f148619a822" translate="yes" xml:space="preserve">
          <source>Type erasure</source>
          <target state="translated">Стирание с клавиатуры</target>
        </trans-unit>
        <trans-unit id="40dc0a7305bb05f3cc921959233fc31aff814e2e" translate="yes" xml:space="preserve">
          <source>Type erasure and generic type checks</source>
          <target state="translated">Стирание типа и проверка общего типа</target>
        </trans-unit>
        <trans-unit id="3a57e7033772e15f6c935d00cab613d6b63a13b4" translate="yes" xml:space="preserve">
          <source>Type inference for variable and property types</source>
          <target state="translated">Типовой вывод для переменных и типов свойств</target>
        </trans-unit>
        <trans-unit id="6468c2c68f3a4de506104359dc49acb341f7ce4b" translate="yes" xml:space="preserve">
          <source>Type of this parameter. For a &lt;code&gt;vararg&lt;/code&gt; parameter, this is the type of the corresponding array, not the individual element.</source>
          <target state="translated">Тип этого параметра. Для параметра &lt;code&gt;vararg&lt;/code&gt; это тип соответствующего массива, а не отдельного элемента.</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67db91aa392a58df5790c33c41ae1990e5a33a95" translate="yes" xml:space="preserve">
          <source>Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.</source>
          <target state="translated">Проекция типа-это либо звездная проекция,либо сущность,состоящая из определенного типа плюс необязательная дисперсия.</target>
        </trans-unit>
        <trans-unit id="a1c1994c749574f626726569018d7132330feb4f" translate="yes" xml:space="preserve">
          <source>Type projections</source>
          <target state="translated">Типовые проекции</target>
        </trans-unit>
        <trans-unit id="390df132c9a4d4db52e48418904c22311abcfb25" translate="yes" xml:space="preserve">
          <source>Type projections (use-site covariance and contravariance)</source>
          <target state="translated">Прогнозы типа (ковариативность и контравариантность использования сайта)</target>
        </trans-unit>
        <trans-unit id="abe0a5c2d281fcb1877a803065e24a61b33d5485" translate="yes" xml:space="preserve">
          <source>Type qualifier defaults (since 1.1.50)</source>
          <target state="translated">По умолчанию классификатор типа (с 1.1.50)</target>
        </trans-unit>
        <trans-unit id="7774fb35aa4a81a2d582ed079ba64fde2c6c6958" translate="yes" xml:space="preserve">
          <source>Type qualifier nicknames (since 1.1.50)</source>
          <target state="translated">Клички-квалификаторы типа (начиная с 1.1.50)</target>
        </trans-unit>
        <trans-unit id="acbd0130304bd83955856731709666b221130b62" translate="yes" xml:space="preserve">
          <source>Type safety problem because of incorrect subtyping for intersection types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9199f1fd6ec494778d67bf415e37aa0839ac622f" translate="yes" xml:space="preserve">
          <source>Type safety problem because of lack of captured conversion against nullable type argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb995680367f27e40ce4ad1d6abb4c604f7187b7" translate="yes" xml:space="preserve">
          <source>Type safety problem because several equal type variables are instantiated with a different types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40de16300b7ec7ebb7fd5b46ebfe06fa7442e5d2" translate="yes" xml:space="preserve">
          <source>Type usage</source>
          <target state="translated">Использование типа</target>
        </trans-unit>
        <trans-unit id="4903c79122878e4bb6246343ee54954a9e90d953" translate="yes" xml:space="preserve">
          <source>Type variable leaks from builder inference because of using &lt;code&gt;this&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302ec0e139d68906dc0b295bb935fe896afa1e82" translate="yes" xml:space="preserve">
          <source>Type-Safe Builders</source>
          <target state="translated">Типовые безопасные строители</target>
        </trans-unit>
        <trans-unit id="1c6379917dd2967a0cd2179d5b9d494b8ce1b4e8" translate="yes" xml:space="preserve">
          <source>Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:</source>
          <target state="translated">Безопасные для типов конструкторы позволяют создавать доменные языки (DSL)на основе Kotlin,подходящие для построения сложных иерархических структур данных полудекларативным способом.Некоторые примеры использования для строителей:</target>
        </trans-unit>
        <trans-unit id="5c15b26d8e7df3e3ffb8c17df0302ea2aa484921" translate="yes" xml:space="preserve">
          <source>TypeCastException</source>
          <target state="translated">TypeCastException</target>
        </trans-unit>
        <trans-unit id="5f0d1a781a66df1f72742486a55df1e5b04f2308" translate="yes" xml:space="preserve">
          <source>Typealias describing custom exception reporting hook.</source>
          <target state="translated">Печати,описывающие пользовательские крючок для сообщений об исключениях.</target>
        </trans-unit>
        <trans-unit id="f3f4c434904369ad0a9f93c33f4c9768b4547a37" translate="yes" xml:space="preserve">
          <source>TypedArrays support enabled by default</source>
          <target state="translated">Поддержка TypedArrays включена по умолчанию</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5ee39ed12bcc53f39d2691296714b602c56e8452" translate="yes" xml:space="preserve">
          <source>Types in C Language</source>
          <target state="translated">Типы на языке C</target>
        </trans-unit>
        <trans-unit id="9082e24429af3d96afc6c792bd53d243c13fe913" translate="yes" xml:space="preserve">
          <source>Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</source>
          <target state="translated">Типы в Котлине во многих местах являются необязательными из-за повсеместного использования типового вывода,но каждое объявление все еще имеет четко определенный статический тип,который известен при компиляции.</target>
        </trans-unit>
        <trans-unit id="629a9e78a0114f36f48645e6ead99e73e5226592" translate="yes" xml:space="preserve">
          <source>Types mapping between C and Kotlin/Native</source>
          <target state="translated">Типы отображения между С и Котлин/Отрицательный</target>
        </trans-unit>
        <trans-unit id="23a10fa48ff804faeadfa8169422520460b61a41" translate="yes" xml:space="preserve">
          <source>Typesafe HTML DSL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4beb9af58f792082d8857ce30b4be1bdbe9b57a" translate="yes" xml:space="preserve">
          <source>Typography</source>
          <target state="translated">Typography</target>
        </trans-unit>
        <trans-unit id="4ae5c7578750deca68bcc325a7a71916e13eb9f0" translate="yes" xml:space="preserve">
          <source>UArraysKt</source>
          <target state="translated">UArraysKt</target>
        </trans-unit>
        <trans-unit id="bf674fff56341390c001cb60679614bd8b320e06" translate="yes" xml:space="preserve">
          <source>UByte</source>
          <target state="translated">UByte</target>
        </trans-unit>
        <trans-unit id="ffb6040505a41eac67ecae4d97b182ca73c78ec7" translate="yes" xml:space="preserve">
          <source>UByteArray</source>
          <target state="translated">UByteArray</target>
        </trans-unit>
        <trans-unit id="d70700d1cf06666209f322639803c081fb20d34b" translate="yes" xml:space="preserve">
          <source>UByteIterator</source>
          <target state="translated">UByteIterator</target>
        </trans-unit>
        <trans-unit id="5c472b4b939131094e43f08559b073c75fc2a028" translate="yes" xml:space="preserve">
          <source>UByteVar</source>
          <target state="translated">UByteVar</target>
        </trans-unit>
        <trans-unit id="f25071b42b8c8e395a2b2b3981b7f23745b87556" translate="yes" xml:space="preserve">
          <source>UByteVarOf</source>
          <target state="translated">UByteVarOf</target>
        </trans-unit>
        <trans-unit id="7df33eb953a0db74ecea7bf713e814fb3abc743c" translate="yes" xml:space="preserve">
          <source>UIEventInit</source>
          <target state="translated">UIEventInit</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="e8203a992b0218cb4341f1de99192c75977adf66" translate="yes" xml:space="preserve">
          <source>UIntArray</source>
          <target state="translated">UIntArray</target>
        </trans-unit>
        <trans-unit id="107a5f6058e02cbfca8e781b5a2a6f523ad395cb" translate="yes" xml:space="preserve">
          <source>UIntIterator</source>
          <target state="translated">UIntIterator</target>
        </trans-unit>
        <trans-unit id="b426f73d819457b44ee2c1f6127ae0354bab9219" translate="yes" xml:space="preserve">
          <source>UIntProgression</source>
          <target state="translated">UIntProgression</target>
        </trans-unit>
        <trans-unit id="733f5415b770d705f77b9612bf3ea932f2bce7d0" translate="yes" xml:space="preserve">
          <source>UIntRange</source>
          <target state="translated">UIntRange</target>
        </trans-unit>
        <trans-unit id="c9533b600e74bcc2cae112123bf64c63ddcac0d1" translate="yes" xml:space="preserve">
          <source>UIntVar</source>
          <target state="translated">UIntVar</target>
        </trans-unit>
        <trans-unit id="77c6c1f150c9389635fa7924b4f92a8549cf352c" translate="yes" xml:space="preserve">
          <source>UIntVarOf</source>
          <target state="translated">UIntVarOf</target>
        </trans-unit>
        <trans-unit id="89e5acbaebf4cf3fe914f8e97ce3365330718921" translate="yes" xml:space="preserve">
          <source>ULong</source>
          <target state="translated">ULong</target>
        </trans-unit>
        <trans-unit id="0aede794cd54bbb254cbbba847a9015fdedd384b" translate="yes" xml:space="preserve">
          <source>ULongArray</source>
          <target state="translated">ULongArray</target>
        </trans-unit>
        <trans-unit id="f83610c14f64002be2365b4b214aea8d4eb7c555" translate="yes" xml:space="preserve">
          <source>ULongIterator</source>
          <target state="translated">ULongIterator</target>
        </trans-unit>
        <trans-unit id="7f4860e3cc03b10b3ed8b10361499545cea0082e" translate="yes" xml:space="preserve">
          <source>ULongProgression</source>
          <target state="translated">ULongProgression</target>
        </trans-unit>
        <trans-unit id="904eba861b0907dd0e83aefaefd037f230269422" translate="yes" xml:space="preserve">
          <source>ULongRange</source>
          <target state="translated">ULongRange</target>
        </trans-unit>
        <trans-unit id="c10238514adfeb120f1beff5e873dea7b5ed95a8" translate="yes" xml:space="preserve">
          <source>ULongVar</source>
          <target state="translated">ULongVar</target>
        </trans-unit>
        <trans-unit id="f9dbd48fa2388e1f99c73bab257c97f132eb1089" translate="yes" xml:space="preserve">
          <source>ULongVarOf</source>
          <target state="translated">ULongVarOf</target>
        </trans-unit>
        <trans-unit id="b9a5671fcf84e88d78fc3704de6f9b452eff55a8" translate="yes" xml:space="preserve">
          <source>UNASSIGNED</source>
          <target state="translated">UNASSIGNED</target>
        </trans-unit>
        <trans-unit id="67a492265c45012bb305d1d916be6fecf6ea8e3e" translate="yes" xml:space="preserve">
          <source>UNDEFINED</source>
          <target state="translated">UNDEFINED</target>
        </trans-unit>
        <trans-unit id="a7864204909e345af29e9c794841c9fe894997a9" translate="yes" xml:space="preserve">
          <source>UNIX_LINES</source>
          <target state="translated">UNIX_LINES</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="c12e2347be0a8619c1d9ecacaec292e6f681ff3c" translate="yes" xml:space="preserve">
          <source>UNSAFE</source>
          <target state="translated">UNSAFE</target>
        </trans-unit>
        <trans-unit id="260ff90ffb9b1a7afc1635ad4eeec327ff83ec80" translate="yes" xml:space="preserve">
          <source>UPPERCASE_LETTER</source>
          <target state="translated">UPPERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="91e7bf3c4d0ab9784e0c43761883c8268e94bc3e" translate="yes" xml:space="preserve">
          <source>US_ASCII</source>
          <target state="translated">US_ASCII</target>
        </trans-unit>
        <trans-unit id="3f4264aca0374d417f001d13663bbf89f0617103" translate="yes" xml:space="preserve">
          <source>UShort</source>
          <target state="translated">UShort</target>
        </trans-unit>
        <trans-unit id="c9c0b8b91e36fe7c1c4c0418920e6f5691e8c55a" translate="yes" xml:space="preserve">
          <source>UShortArray</source>
          <target state="translated">UShortArray</target>
        </trans-unit>
        <trans-unit id="6c3a83167054246ea25835255ce7b0e018316b2a" translate="yes" xml:space="preserve">
          <source>UShortIterator</source>
          <target state="translated">UShortIterator</target>
        </trans-unit>
        <trans-unit id="a33eeb13596790b08a6df8799ea234e412c8c47b" translate="yes" xml:space="preserve">
          <source>UShortVar</source>
          <target state="translated">UShortVar</target>
        </trans-unit>
        <trans-unit id="282cb40f96ea3b82ef408a23ef69ab3812e1c45c" translate="yes" xml:space="preserve">
          <source>UShortVarOf</source>
          <target state="translated">UShortVarOf</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="f0217f65f3e1f538b0d8cda26e80a2285c43df22" translate="yes" xml:space="preserve">
          <source>UTF-16 code unit (see the section on &lt;a href=&quot;strings&quot;&gt;strings&lt;/a&gt; - in most cases, this is one Unicode character, but it might be just one half of a Unicode character)</source>
          <target state="translated">Кодовый блок UTF-16 (см. Раздел о &lt;a href=&quot;strings&quot;&gt;строках&lt;/a&gt; - в большинстве случаев это один символ Unicode, но это может быть всего лишь половина символа Unicode)</target>
        </trans-unit>
        <trans-unit id="3133dd8458a32c8b5ce4a722caa62b68748d9288" translate="yes" xml:space="preserve">
          <source>UTF_16</source>
          <target state="translated">UTF_16</target>
        </trans-unit>
        <trans-unit id="6ca2e2b19e1ecda564482fabe6d3670b269a5872" translate="yes" xml:space="preserve">
          <source>UTF_16BE</source>
          <target state="translated">UTF_16BE</target>
        </trans-unit>
        <trans-unit id="9754e677d06d03c4582e2dcf98147ca46f84d72e" translate="yes" xml:space="preserve">
          <source>UTF_16LE</source>
          <target state="translated">UTF_16LE</target>
        </trans-unit>
        <trans-unit id="447ed343c0ab25980389215d35f14db291c88450" translate="yes" xml:space="preserve">
          <source>UTF_32</source>
          <target state="translated">UTF_32</target>
        </trans-unit>
        <trans-unit id="92586032892e03cbec5d2f808289d67c3e5fe454" translate="yes" xml:space="preserve">
          <source>UTF_32BE</source>
          <target state="translated">UTF_32BE</target>
        </trans-unit>
        <trans-unit id="cbf0128f0e447f51c74b68507c6628894645216c" translate="yes" xml:space="preserve">
          <source>UTF_32LE</source>
          <target state="translated">UTF_32LE</target>
        </trans-unit>
        <trans-unit id="444b32f7d1774bb52a894fb896e3e3f1afe43c1f" translate="yes" xml:space="preserve">
          <source>UTF_8</source>
          <target state="translated">UTF_8</target>
        </trans-unit>
        <trans-unit id="ee17a2d4842b1562f38fb267817829d58a3dedfb" translate="yes" xml:space="preserve">
          <source>Uint16Array</source>
          <target state="translated">Uint16Array</target>
        </trans-unit>
        <trans-unit id="633c2aa79d88322b5d53222bfe0bb765531ece57" translate="yes" xml:space="preserve">
          <source>Uint32Array</source>
          <target state="translated">Uint32Array</target>
        </trans-unit>
        <trans-unit id="9dafd0a91ea1eadf5a4b323d71716a37f430543c" translate="yes" xml:space="preserve">
          <source>Uint8Array</source>
          <target state="translated">Uint8Array</target>
        </trans-unit>
        <trans-unit id="80d3d1902630c787d741b39af0ddaba8dab6c5b7" translate="yes" xml:space="preserve">
          <source>Uint8ClampedArray</source>
          <target state="translated">Uint8ClampedArray</target>
        </trans-unit>
        <trans-unit id="dbab18f3ded2bfe1f1beae0998ec97e669719cb0" translate="yes" xml:space="preserve">
          <source>Unary operations</source>
          <target state="translated">Унарные операции</target>
        </trans-unit>
        <trans-unit id="700a41ed5d6a21b389d3a06a552007f7d4970e83" translate="yes" xml:space="preserve">
          <source>Unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, and a function &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">Унарные операторы &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; и функция &lt;code&gt;inv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7af4b44086924bef8511e74a06dc5652e98b37f" translate="yes" xml:space="preserve">
          <source>Unary prefix operators</source>
          <target state="translated">Унарные префиксные операторы</target>
        </trans-unit>
        <trans-unit id="71f09f8fe1dde2289c868a03cb103ae030625690" translate="yes" xml:space="preserve">
          <source>Unchecked casts</source>
          <target state="translated">бесконтрольные слепки</target>
        </trans-unit>
        <trans-unit id="b8d5b81db1752990f9a00626b0f1fe949182953e" translate="yes" xml:space="preserve">
          <source>Unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. Unconfined dispatcher should not be used in general code.</source>
          <target state="translated">Нерафинированный диспетчер-это продвинутый механизм,который может быть полезен в определенных угловых случаях,когда отправка коруэтины на ее выполнение позже не нужна или приводит к нежелательным побочным эффектам,так как некоторая операция в коруэтине должна быть выполнена сразу же.Необработанный диспетчер не должен использоваться в общем коде.</target>
        </trans-unit>
        <trans-unit id="1ad54c8520658fa2b0366caffc5901ab7a388736" translate="yes" xml:space="preserve">
          <source>Unconfined vs confined dispatcher</source>
          <target state="translated">Неограниченный против замкнутого диспетчера</target>
        </trans-unit>
        <trans-unit id="a2570f4d995169cd25ade0e53aebb8dd50e4a603" translate="yes" xml:space="preserve">
          <source>Undefined bidirectional character type. Undefined &lt;code&gt;char&lt;/code&gt; values have undefined directionality in the Unicode specification.</source>
          <target state="translated">Неопределенный двунаправленный символьный тип. Неопределенные значения &lt;code&gt;char&lt;/code&gt; имеют неопределенную направленность в спецификации Unicode.</target>
        </trans-unit>
        <trans-unit id="36bdd28a04792d2d0be5dfb8e33b3534b2fbd55b" translate="yes" xml:space="preserve">
          <source>Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">Под капотом для каждого делегированного свойства компилятор Kotlin генерирует вспомогательное свойство и делегирует ему. Например, для свойства &lt;code&gt;prop&lt;/code&gt; создается скрытое свойство &lt;code&gt;prop$delegate&lt;/code&gt; , а код аксессоров просто делегирует это дополнительное свойство:</target>
        </trans-unit>
        <trans-unit id="dd8b30eeb866c4439bd48cb8b3176d8c5f111d35" translate="yes" xml:space="preserve">
          <source>Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3488dca90e45f8e2402977d7d251d68f390541e0" translate="yes" xml:space="preserve">
          <source>Underscore for unused variables (since 1.1)</source>
          <target state="translated">Подчеркивание для неиспользуемых переменных (начиная с 1.1)</target>
        </trans-unit>
        <trans-unit id="fb79a41a5516422da2e439b9cf71e40fb6fb14d4" translate="yes" xml:space="preserve">
          <source>Underscores for unused parameters</source>
          <target state="translated">Подчеркивает неиспользуемые параметры</target>
        </trans-unit>
        <trans-unit id="c1313f733bf8697e7ec5cdf78f97cfd84d52c63d" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals</source>
          <target state="translated">Подчеркивает числовыми буквами</target>
        </trans-unit>
        <trans-unit id="a32a8ccb60d72fd24a8aa497590c0bf8ba9cd8dc" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals (since 1.1)</source>
          <target state="translated">Подчеркивает числовыми буквами (начиная с 1.1)</target>
        </trans-unit>
        <trans-unit id="796b398098842ca0559820831bbb74bc385b8a80" translate="yes" xml:space="preserve">
          <source>Unexpected behavior with &lt;code&gt;in&lt;/code&gt; infix operator and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d199ddedf7802afc54d34deabe810e8a6bf5c4f" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you want an empty collection, you need to either declare the resulting collection type explicitly, or supply the element type(s) to the function that constructs the collection:</source>
          <target state="translated">К сожалению,если вы хотите пустую коллекцию,вам нужно либо явным образом объявить результирующий тип коллекции,либо указать тип(ы)элемента в функции,которая создает коллекцию:</target>
        </trans-unit>
        <trans-unit id="e40bf9bbf42c1f6fc0258d8c13f458aad30b49f2" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code formatter built into IntelliJ IDEA had to work long before this document was released and now has a default setup that produces different formatting from what is now recommended.</source>
          <target state="translated">К сожалению,встроенный в IntelliJ IDEA форматизатор кода работал задолго до выхода этого документа и теперь имеет настройку по умолчанию,отличающуюся от рекомендованной в настоящее время.</target>
        </trans-unit>
        <trans-unit id="12945de7af176c634a0d8ce8b70c82d42353176c" translate="yes" xml:space="preserve">
          <source>Unfortunately, using this would require us to type &lt;code&gt;p.name.value&lt;/code&gt; every time we wanted to use the property. We could do the following, but that's also not great since it introduces an extra property:</source>
          <target state="translated">К сожалению, это потребовало бы от нас ввода &lt;code&gt;p.name.value&lt;/code&gt; каждый раз, когда мы хотели бы использовать свойство. Мы могли бы сделать следующее, но это тоже не очень хорошо, поскольку вводит дополнительное свойство:</target>
        </trans-unit>
        <trans-unit id="8837f610cd63014d412facb51aa6f98460391f9a" translate="yes" xml:space="preserve">
          <source>Unicode correctness can be onerous in Python 2, since the &quot;default&quot; string type &lt;code&gt;str&lt;/code&gt; is really just a byte array, while &lt;code&gt;unicode&lt;/code&gt; is actually a sequence of &lt;em&gt;code units&lt;/em&gt; (see below) - and whether the code units are 16 or 32 bits wide depends on how your Python distribution was built. In Kotlin, there's no such confusion: &lt;code&gt;String&lt;/code&gt;, which is what you get when you make a string literal (which you can only do with double quotes), is an immutable sequence of UTF-16 code units. &lt;code&gt;ByteArray&lt;/code&gt; is a fixed-size (but otherwise mutable) byte array (and &lt;code&gt;String&lt;/code&gt; can specifically &lt;em&gt;not&lt;/em&gt; be used as a byte array).</source>
          <target state="translated">Корректность Unicode может быть обременительной в Python 2, поскольку строковый тип &lt;code&gt;str&lt;/code&gt; &quot;по умолчанию&quot; на самом деле является просто байтовым массивом, тогда как &lt;code&gt;unicode&lt;/code&gt; на самом деле представляет собой последовательность &lt;em&gt;кодовых единиц&lt;/em&gt; (см. Ниже) - и будет ли кодовая единица шириной 16 или 32 бита, зависит о том, как был построен ваш дистрибутив Python. В Kotlin такой путаницы нет: &lt;code&gt;String&lt;/code&gt; , которую вы получаете, когда создаете строковый литерал (что можно делать только с двойными кавычками), представляет собой неизменяемую последовательность единиц кода UTF-16. &lt;code&gt;ByteArray&lt;/code&gt; - это массив байтов фиксированного размера (но в остальном изменяемый) (а &lt;code&gt;String&lt;/code&gt; специально &lt;em&gt;не&lt;/em&gt; может использоваться как массив байтов).</target>
        </trans-unit>
        <trans-unit id="505d5c38054a74d4b2175415322819ae4849fcad" translate="yes" xml:space="preserve">
          <source>Unified Module Definitions (UMD), which is compatible with both &lt;em&gt;AMD&lt;/em&gt; and &lt;em&gt;CommonJS&lt;/em&gt;, and works as &quot;plain&quot; when neither &lt;em&gt;AMD&lt;/em&gt; nor &lt;em&gt;CommonJS&lt;/em&gt; is available at runtime.</source>
          <target state="translated">Unified Module Definitions (UMD), который совместим как с &lt;em&gt;AMD, так&lt;/em&gt; и с &lt;em&gt;CommonJS&lt;/em&gt; , и работает как &quot;простой&quot;, когда ни &lt;em&gt;AMD,&lt;/em&gt; ни &lt;em&gt;CommonJS&lt;/em&gt; не доступны во время выполнения.</target>
        </trans-unit>
        <trans-unit id="de5d8b50b3695e8d25f732afc1acabb23472bc08" translate="yes" xml:space="preserve">
          <source>Unified backends and extensibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb8c9c639d9b52130075c5077a53018a3b076842" translate="yes" xml:space="preserve">
          <source>Unified exception type for null checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0e76a89bd66d41a17ed421fa008af6ae14f66f" translate="yes" xml:space="preserve">
          <source>Unified standard library</source>
          <target state="translated">Единая стандартная библиотека</target>
        </trans-unit>
        <trans-unit id="c4aff5fbbb595afd545658cb39aa6df5dcca07e6" translate="yes" xml:space="preserve">
          <source>Unify exceptions from null checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f58ff59e65d2d98ffef40514cadc0e589f2165" translate="yes" xml:space="preserve">
          <source>Unify split by an empty match regex result across the platforms</source>
          <target state="translated">Унифицировать разделить на пустые результаты матча регрессом по платформам</target>
        </trans-unit>
        <trans-unit id="370ce5f1a9eb1b7143f06590af17c7841cb70b8d" translate="yes" xml:space="preserve">
          <source>UninitializedPropertyAccessException</source>
          <target state="translated">UninitializedPropertyAccessException</target>
        </trans-unit>
        <trans-unit id="a91e29c6a18b3d46ad21babc72fbe12a2806e9d6" translate="yes" xml:space="preserve">
          <source>UnionAudioTrackOrTextTrackOrVideoTrack</source>
          <target state="translated">UnionAudioTrackOrTextTrackOrVideoTrack</target>
        </trans-unit>
        <trans-unit id="b427069e00bef5cd6617471fa2f1c76d7e94c1b0" translate="yes" xml:space="preserve">
          <source>UnionClientOrMessagePortOrServiceWorker</source>
          <target state="translated">UnionClientOrMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="10052a20073fd80351eaa98a0618cc05908c3fe2" translate="yes" xml:space="preserve">
          <source>UnionElementOrHTMLCollection</source>
          <target state="translated">UnionElementOrHTMLCollection</target>
        </trans-unit>
        <trans-unit id="64df693fc6248e2d4b802ced57f664db2486df1a" translate="yes" xml:space="preserve">
          <source>UnionElementOrMouseEvent</source>
          <target state="translated">UnionElementOrMouseEvent</target>
        </trans-unit>
        <trans-unit id="5d95156c593ab4f5a1d6aa9b7adaaae5b5072eee" translate="yes" xml:space="preserve">
          <source>UnionElementOrProcessingInstruction</source>
          <target state="translated">UnionElementOrProcessingInstruction</target>
        </trans-unit>
        <trans-unit id="cb794bdbfe712bfdef6a341eb0ffeda3e61df94b" translate="yes" xml:space="preserve">
          <source>UnionElementOrRadioNodeList</source>
          <target state="translated">UnionElementOrRadioNodeList</target>
        </trans-unit>
        <trans-unit id="55e9b0c8b2893c068d7bad4f687cd74e04c97fae" translate="yes" xml:space="preserve">
          <source>UnionHTMLOptGroupElementOrHTMLOptionElement</source>
          <target state="translated">UnionHTMLOptGroupElementOrHTMLOptionElement</target>
        </trans-unit>
        <trans-unit id="9914d6bd1e51362b2ae64dd4e4f0c81df753f3a5" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrServiceWorker</source>
          <target state="translated">UnionMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="9f29b0aeda2c26ba869f1da1baf112b08de48285" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindow</source>
          <target state="translated">UnionMessagePortOrWindow</target>
        </trans-unit>
        <trans-unit id="0bdbd6bc95c6e23b6042a486f6d277c7a15fc86a" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindowProxy</source>
          <target state="translated">UnionMessagePortOrWindowProxy</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="6e47e918985f3919c21cc4a5d827ef9eada3d607" translate="yes" xml:space="preserve">
          <source>Unit return type. Must not be nullable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc244abccf5ca3308a1494c12878b0d0e26feea" translate="yes" xml:space="preserve">
          <source>Unit-returning functions</source>
          <target state="translated">Функции возврата единиц измерения</target>
        </trans-unit>
        <trans-unit id="4e0950ee26dcc7da4ca806b4b340177a815e5066" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e885d6886100fb26b71f7747ee932dbb05e71ce7" translate="yes" xml:space="preserve">
          <source>Unless you're working on a library, omit redundant modifiers (e.g. &lt;code&gt;public&lt;/code&gt;).</source>
          <target state="translated">Если вы не работаете над библиотекой, не используйте избыточные модификаторы (например, &lt;code&gt;public&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8feafcdb2005e6ef556074da45e878f1b7bc1d3a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; it does not intercept continuation.</source>
          <target state="translated">В отличие от &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn,&lt;/a&gt; он не перехватывает продолжение.</target>
        </trans-unit>
        <trans-unit id="b5baaedd3e64f7be16b02c01618d1a48a2f53082" translate="yes" xml:space="preserve">
          <source>Unlike Java, Kotlin does not have a separate &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; syntax; all of these declarations are imported using the regular &lt;code&gt;import&lt;/code&gt; keyword.</source>
          <target state="translated">В отличие от Java, Kotlin не имеет отдельного синтаксиса &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&amp;laquo;статического импорта&amp;raquo;&lt;/a&gt; ; все эти объявления импортируются с использованием обычного ключевого слова &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e26e1701ff3fbdbd8ab214ddee2ab24ae9fb3e0" translate="yes" xml:space="preserve">
          <source>Unlike Java, block comments in Kotlin can be nested.</source>
          <target state="translated">В отличие от Java,блочные комментарии в Котлине могут быть вложены.</target>
        </trans-unit>
        <trans-unit id="d71d4e303da5f24db04f06a7b993b10b6d2cf202" translate="yes" xml:space="preserve">
          <source>Unlike Python, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; is an expression: the last expression of the &lt;code&gt;try&lt;/code&gt; block (if it succeeds) or the chosen &lt;code&gt;catch&lt;/code&gt; block becomes the result value (&lt;code&gt;finally&lt;/code&gt; doesn't affect the result), so we can refactor the function body above to:</source>
          <target state="translated">В отличие от Python, &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; является выражением: последнее выражение блока &lt;code&gt;try&lt;/code&gt; (в случае успеха) или выбранный блок &lt;code&gt;catch&lt;/code&gt; становится значением результата ( &lt;code&gt;finally&lt;/code&gt; не влияет на результат), поэтому мы можем реорганизовать тело функции выше, чтобы :</target>
        </trans-unit>
        <trans-unit id="9ffcb8e6d8c0e1886c9139362bf8a80448f390b9" translate="yes" xml:space="preserve">
          <source>Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular &lt;code&gt;for&lt;/code&gt; loop to receive elements from the channel.</source>
          <target state="translated">В отличие от очереди, канал может быть закрыт, чтобы указать, что больше не поступают элементы. На стороне приемника удобно использовать обычный цикл &lt;code&gt;for&lt;/code&gt; для приема элементов из канала.</target>
        </trans-unit>
        <trans-unit id="79736268c87ef812b5a0caf77be57b249d138010" translate="yes" xml:space="preserve">
          <source>Unlike docstrings, KDoc blocks are not available to the program at runtime.</source>
          <target state="translated">В отличие от док-строк,блоки KDoc недоступны программе во время выполнения.</target>
        </trans-unit>
        <trans-unit id="9e77ba9444bad622fec50b4242ad0088f476d99f" translate="yes" xml:space="preserve">
          <source>Unlike other pointers, the parameters of type &lt;code&gt;const char*&lt;/code&gt; are represented as a Kotlin &lt;code&gt;String&lt;/code&gt;. So it is possible to pass any Kotlin string to a binding expecting a C string.</source>
          <target state="translated">В отличие от других указателей, параметры типа &lt;code&gt;const char*&lt;/code&gt; представлены как Kotlin &lt;code&gt;String&lt;/code&gt; . Таким образом, можно передать любую строку Kotlin привязке, ожидающей строку C.</target>
        </trans-unit>
        <trans-unit id="cd3405f910e07d811413c0ab883fbacf2fe2d5fb" translate="yes" xml:space="preserve">
          <source>Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility very important in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</source>
          <target state="translated">В отличие от исходных текстов,которые в худшем случае могут быть исправлены вручную,двоичные файлы гораздо сложнее переносить,и это делает обратную совместимость очень важной в случае двоичных файлов.Несовместимые изменения в двоичных файлах могут сделать обновления очень неудобными,и поэтому их следует вносить с ещё большей осторожностью,чем изменения в синтаксисе исходных текстов.</target>
        </trans-unit>
        <trans-unit id="71ea4413722e85a3b020d9ed01e939aac7d2c7c0" translate="yes" xml:space="preserve">
          <source>Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418fd8181d764c26cb6aebed80be5ec76fed83e8" translate="yes" xml:space="preserve">
          <source>Unsafe mode is intended for most performance critical operations, where object graph ownership is expected to be correct (such as application debugged earlier in &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; mode), just transfers ownership without further checks.</source>
          <target state="translated">Небезопасный режим предназначен для большинства операций, критичных к производительности, когда ожидается, что владение графом объектов будет правильным (например, приложение, отлаженное ранее в &lt;a href=&quot;-s-a-f-e&quot;&gt;безопасном&lt;/a&gt; режиме), просто передает владение без дальнейших проверок.</target>
        </trans-unit>
        <trans-unit id="eb25c274c554703f1d6ac7eff8cabedc73b12953" translate="yes" xml:space="preserve">
          <source>UnsafeVariance</source>
          <target state="translated">UnsafeVariance</target>
        </trans-unit>
        <trans-unit id="cfba46d6859cfbbcea2df0d333b94927ce585d13" translate="yes" xml:space="preserve">
          <source>Unsigned arithmetics</source>
          <target state="translated">неподписанная арифметика</target>
        </trans-unit>
        <trans-unit id="5c5289ec1ae0731b7a3321d477acd024a60473b2" translate="yes" xml:space="preserve">
          <source>Unsigned integers</source>
          <target state="translated">неподписанные целые числа</target>
        </trans-unit>
        <trans-unit id="5b676d18e8ccf61f5e227df4adab6b4ac25f32fd" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Целые числа без знака доступны только начиная с Kotlin 1.3 и в настоящее время являются &lt;em&gt;экспериментальными&lt;/em&gt; . Подробности смотрите в &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;ссылке&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f300d5a964ee1dfe6f01eeb8815de2c1adedd0" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747e738f03e7ea5b53d3e97fc3d06bb2fdd5460" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Типы без знака доступны только начиная с Kotlin 1.3 и в настоящее время являются &lt;em&gt;экспериментальными&lt;/em&gt; . См. Подробности &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;ниже&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d65bd8aeb4b2e88a04a2f25ed0b812fa94ab0cb" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69f19b70030748472412cf013c7f8262fa5cc73" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another experimental feature, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">Беззнаковые типы реализуются с помощью другой экспериментальной функции, а именно &lt;a href=&quot;inline-classes&quot;&gt;встроенных классов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963c1b3d4bd7cb3c897cb1ca5167eb9af57242de" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22647f2117d5ec2026da9b7edc1161d8603f0593" translate="yes" xml:space="preserve">
          <source>Unsigned types support most of the operations of their signed counterparts.</source>
          <target state="translated">Безподписные типы поддерживают большинство операций своих подписанных контрагентов.</target>
        </trans-unit>
        <trans-unit id="a84f8397c523a0f7323640840daf25c5d28f242d" translate="yes" xml:space="preserve">
          <source>Unsound smartcasts on enum members</source>
          <target state="translated">Необычные смарт-аудио на членов переписной группы</target>
        </trans-unit>
        <trans-unit id="fb52c13a5d3c511932c9721a05a0f30bebc8f773" translate="yes" xml:space="preserve">
          <source>Unsupported</source>
          <target state="translated">Unsupported</target>
        </trans-unit>
        <trans-unit id="d6b9cc70af4626956ac004db8653f110603b7231" translate="yes" xml:space="preserve">
          <source>UnsupportedOperationException</source>
          <target state="translated">UnsupportedOperationException</target>
        </trans-unit>
        <trans-unit id="2ce01f081a0318f94ee11d34764838aaa22a8009" translate="yes" xml:space="preserve">
          <source>Unused declarations can appear in cases like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d866719de20162a43b046be2b1dd937f0e0c8b0" translate="yes" xml:space="preserve">
          <source>Unzip the standalone compiler into a directory and optionally add the &lt;code&gt;bin&lt;/code&gt; directory to the system path. The &lt;code&gt;bin&lt;/code&gt; directory contains the scripts needed to compile and run Kotlin on Windows, OS X and Linux.</source>
          <target state="translated">Разархивируйте автономный компилятор в каталог и при необходимости добавьте каталог &lt;code&gt;bin&lt;/code&gt; в системный путь. &lt;code&gt;bin&lt;/code&gt; каталог содержит сценарии , необходимые для компиляции и запуска Котлин на Windows, OS X и Linux.</target>
        </trans-unit>
        <trans-unit id="ab7b8830d7d19c631f4db7f0e7cccdc5fc99c4ae" translate="yes" xml:space="preserve">
          <source>Update Gradle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd35499f667636f0205aff356fc79aa271c4a159" translate="yes" xml:space="preserve">
          <source>Update the application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756c6de970516b187b891362c635541de1071978" translate="yes" xml:space="preserve">
          <source>Update to version A (where the change is announced)</source>
          <target state="translated">Обновление до версии A (где объявлено об изменении)</target>
        </trans-unit>
        <trans-unit id="a8909313fb96928caf2b3605836e51265cd9382c" translate="yes" xml:space="preserve">
          <source>Update to version B (where the change happens)</source>
          <target state="translated">Обновление до версии B (где происходит изменение)</target>
        </trans-unit>
        <trans-unit id="bc69b0f01bd4bf2a5762f9802698425322ca8ecc" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Обновляет эту карту парами ключ / значение из указанной карты &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;из&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb9919809e0edbf2ce222896374072b2a1f62288" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9592e59ae4a1ea78ffeef819217ff2d297efc8bf" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Обновляет эту карту парами ключ / значение из указанной карты &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;из&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea39222df240b93c342df8ff54a9cb5e6582800" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="d63c48198d515b24d1b1b235598c3c48c2a4be5a" translate="yes" xml:space="preserve">
          <source>Updating Gradle Scripts</source>
          <target state="translated">Обновление скриптов колыбели</target>
        </trans-unit>
        <trans-unit id="408c0db23a4308cddf6a6e9ce2a0a6679db93544" translate="yes" xml:space="preserve">
          <source>Updating elements</source>
          <target state="translated">Обновляющие элементы</target>
        </trans-unit>
        <trans-unit id="5db2b695ba29ebd7f0ca8dec803b6b54c73ec2a6" translate="yes" xml:space="preserve">
          <source>Upper bounds</source>
          <target state="translated">Верхние границы</target>
        </trans-unit>
        <trans-unit id="6fe7e1ccf58a63e3bc126e60c26bcc1a9fac8e17" translate="yes" xml:space="preserve">
          <source>Upper bounds, or generic constraints imposed on this type parameter. See the &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">Верхние границы или общие ограничения, наложенные на этот параметр типа. См. &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Документацию&lt;/a&gt; по языку Kotlin для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="034e0e826c171bc69a42734bf5f512ba3665a32d" translate="yes" xml:space="preserve">
          <source>Usage of the &lt;code&gt;!!&lt;/code&gt; operator that is described below;</source>
          <target state="translated">Использование &lt;code&gt;!!&lt;/code&gt; оператор, описанный ниже;</target>
        </trans-unit>
        <trans-unit id="e1820bd9f032e11eff310c40682c9835a9eb3203" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as a warning.</source>
          <target state="translated">Использование устаревшего элемента будет сообщено в качестве предупреждения.</target>
        </trans-unit>
        <trans-unit id="8a6da2a0224bff4d0cdbf931eb3f79ea3c663d17" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as an error.</source>
          <target state="translated">Использование устаревшего элемента будет сообщено как ошибка.</target>
        </trans-unit>
        <trans-unit id="2f2278b9118c021e0836f33b45c4b344bc07faf3" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2bd12dd174680813870a73e531a53b2704ad9f" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; annotation, e.g. &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">Об использовании такого API будет сообщаться как предупреждение, если не указано явное &lt;a href=&quot;../-use-experimental/index&quot;&gt;согласие с&lt;/a&gt; аннотацией UseExperimental , например, &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt; , или с параметром &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a2b4afa5d97d07993ae00f2065c3a2c91e4e36" translate="yes" xml:space="preserve">
          <source>Usages of such annotations will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; compiler option is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5461bf95a53302a7c5df48274f6a4f3517903597" translate="yes" xml:space="preserve">
          <source>Usages of this annotation require an explicit compilation argument to be specified: either &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; or &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt;.</source>
          <target state="translated">Использование этой аннотации требует указания явного аргумента компиляции: либо &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; , либо &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="070afea0c959ac4ab2122b78be879a1236b7d5f2" translate="yes" xml:space="preserve">
          <source>Use 4 spaces for indentation. Do not use tabs.</source>
          <target state="translated">Используйте 4 пространства для вдавливания.Не используйте закладки.</target>
        </trans-unit>
        <trans-unit id="505b02e2c68810a100167ed2394b7b09d07536b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin from Swift&lt;/a&gt;</source>
          <target state="translated">Используйте &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin от Swift&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="259f61d0fe4d9980f69dcb9a143f67a783be3566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; function to describe a conditional effect that happens in such case.</source>
          <target state="translated">Используйте функцию &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; для описания условного эффекта, который происходит в таком случае.</target>
        </trans-unit>
        <trans-unit id="7b3d7f2e06019f3ce17f9b7609b4e12a0a852225" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;, &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; or &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; extension functions to instantiate a &lt;code&gt;FileTreeWalk&lt;/code&gt; instance.</source>
          <target state="translated">Используйте функции расширения &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt; , &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; или &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; для создания экземпляра &lt;code&gt;FileTreeWalk&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24479d1c98fbbe2aeb0187678fa3eb554ac97484" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;a workaround for the Bintray plugin&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855c22b8caa56aad8a88d87618784ee61265712d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;apply&lt;/code&gt; for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for &lt;code&gt;apply&lt;/code&gt; is the object configuration. Such calls can be read as &amp;ldquo;&lt;em&gt;apply the following assignments to the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">Используйте &lt;code&gt;apply&lt;/code&gt; для блоков кода, которые не возвращают значение и в основном работают с членами объекта-получателя. Обычным случаем &lt;code&gt;apply&lt;/code&gt; является конфигурация объекта. Такие призывы можно прочитать как &amp;laquo; &lt;em&gt;применить к объекту следующие назначения. &lt;/em&gt;&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="6ba975b0b8793e55988fa1e5cd1c3f8baae89326" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;arguments {}&lt;/code&gt; block to pass arguments to annotation processors:</source>
          <target state="translated">Используйте блок &lt;code&gt;arguments {}&lt;/code&gt; для передачи аргументов обработчикам аннотаций:</target>
        </trans-unit>
        <trans-unit id="9068946a50ad967859350bf76f77d127a3ad6ba3" translate="yes" xml:space="preserve">
          <source>Use C function pointer from Kotlin</source>
          <target state="translated">Используйте указатель функции C из Котлина</target>
        </trans-unit>
        <trans-unit id="8d59d0d06987ce05b43d207e59345cd58bf6234b" translate="yes" xml:space="preserve">
          <source>Use Gradle 6.0 and above to generate wrapper (&lt;code&gt;gradle wrapper&lt;/code&gt;) in the project root directory to generate &lt;code&gt;gradlew&lt;/code&gt;, &lt;code&gt;gradlew.bat&lt;/code&gt;, and &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f14c4d527695edd872c7fe2172a6db2f31e9728" translate="yes" xml:space="preserve">
          <source>Use Kotlin from node.js with CommonJS</source>
          <target state="translated">Используйте Kotlin из node.js с CommonJS</target>
        </trans-unit>
        <trans-unit id="7955d34ca487ac99a425deedc1ddb62d16416242" translate="yes" xml:space="preserve">
          <source>Use Kotlin in the browser with AMD</source>
          <target state="translated">Используйте Kotlin в браузере с AMD</target>
        </trans-unit>
        <trans-unit id="80ebd15dbf9fc53c163f2e8494fee09225815763" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; for your reversed name by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${state.name.reversed()}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2449126f023eebada4dc8166f2d086abc1f70c85" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; to insert your name length into the string by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${it.length}&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is the default name of a &lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;lambda parameter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567ed77b3fedba236234b46ed9dd13b2639d5a1d" translate="yes" xml:space="preserve">
          <source>Use a Kotlin Gradle project as a CocoaPods dependency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad9d5856fb71823437fdf612d7806d4ef4bcde8" translate="yes" xml:space="preserve">
          <source>Use a custom JDK home directory to include into the classpath if it differs from the default &lt;code&gt;JAVA_HOME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dafba398135044480a3e13e8cf827e6d5239bcb" translate="yes" xml:space="preserve">
          <source>Use a function returning nullable value:</source>
          <target state="translated">Используйте функцию,возвращающую нулевое значение:</target>
        </trans-unit>
        <trans-unit id="09ab22034a8c650e65b27de7b44cb4d61caf9b2b" translate="yes" xml:space="preserve">
          <source>Use a string template by adding a dollar sign &lt;code&gt;$&lt;/code&gt; before this variable name directly in the text output like this &amp;ndash; &lt;code&gt;$name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6761a777f295b6258dc7a19c0a25a2a4cc06a051" translate="yes" xml:space="preserve">
          <source>Use any members that don't mention the star-projected type parameter(s) at all</source>
          <target state="translated">Используйте любые члены,которые вообще не упоминают параметр(ы)типа &quot;звездообразный&quot;.</target>
        </trans-unit>
        <trans-unit id="02c711d6a5cfe540ce71589b8b208d49d3883457" translate="yes" xml:space="preserve">
          <source>Use any members that return the star-projected type parameter(s), but the return type will appear to be &lt;code&gt;Any?&lt;/code&gt; (unless the type parameter is constrained, in which case you'll get the type mentioned in the constraint)</source>
          <target state="translated">Используйте любые члены, которые возвращают параметр (ы) типа звездной проекции, но тип возвращаемого значения будет иметь значение &lt;code&gt;Any?&lt;/code&gt; (если параметр типа не ограничен, и в этом случае вы получите тип, указанный в ограничении)</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">Случаи использования</target>
        </trans-unit>
        <trans-unit id="6914afc57d4eceefab3ce74c4e34c13830de00b1" translate="yes" xml:space="preserve">
          <source>Use dynamic to interact with libraries</source>
          <target state="translated">Использовать динамику для взаимодействия с библиотеками</target>
        </trans-unit>
        <trans-unit id="a696c211088879b039bc564a3a89ee0e5d5cf819" translate="yes" xml:space="preserve">
          <source>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</source>
          <target state="translated">Используйте функции расширения либерально.Каждый раз,когда у вас есть функция,которая работает в первую очередь на объекте,подумайте о том,чтобы сделать ее функцией расширения,принимающей этот объект в качестве приемника.Чтобы минимизировать загрязнение API,ограничивайте видимость функций расширения настолько,насколько это имеет смысл.По мере необходимости используйте функции локального расширения,функции расширения членов или функции расширения верхнего уровня с приватной видимостью.</target>
        </trans-unit>
        <trans-unit id="d507109a798498dbaa1e633727d124b6d6bc26b0" translate="yes" xml:space="preserve">
          <source>Use for APIs which have a third-party implementation available at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1d8d5003fdff477f08dfe445e9b40450048a1d" translate="yes" xml:space="preserve">
          <source>Use for dependencies needed for the internal logic of a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46a150eeba438f84a49eada07a259f489c6609a" translate="yes" xml:space="preserve">
          <source>Use four spaces for indentation. Do not use tabs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce69d8e8477848e488f670533689cb83c9f8c099" translate="yes" xml:space="preserve">
          <source>Use it &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;from Android app&lt;/a&gt;</source>
          <target state="translated">Используйте его &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;из приложения для Android&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62f9973d0d21db3635e8a7ac730a624b82c527d3" translate="yes" xml:space="preserve">
          <source>Use kotlinx.html to generate HTML</source>
          <target state="translated">Для генерации HTML используйте kotlinx.html.</target>
        </trans-unit>
        <trans-unit id="c9f5118d1f54f80362016bfd5b442c56f51dfc9b" translate="yes" xml:space="preserve">
          <source>Use native libraries in the hierarchical structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f896877d7535f3235fee51d8eb8bb2fc4692498" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for constructor parameters.</source>
          <target state="translated">Используйте регулярные отступы (4 пробела)для параметров конструктора.</target>
        </trans-unit>
        <trans-unit id="8e22c1db7346b432b927919ebe9e716628c63ef8" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for function parameters.</source>
          <target state="translated">Используйте обычные отступы (4 пробела)для параметров функции.</target>
        </trans-unit>
        <trans-unit id="b28f6c3f00f4a4b985821c624ebe6f5d2ab53f74" translate="yes" xml:space="preserve">
          <source>Use regular indent (four spaces) for constructor parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f39c73e1f23d3754cec94f86de325d9e4b9a4f1" translate="yes" xml:space="preserve">
          <source>Use target shortcuts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6356c2b337336539cb098b460ea9fc43a2a742aa" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; function to remove the empty spaces in the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72171ae8b75ba095394479592bf8ca1cc4cab18c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt;&lt;code&gt;println()&lt;/code&gt;&lt;/a&gt; function to print computing status and the result of multiplication to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7280e72c76af98308a3c66e2b7e24f9cc56702" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; function to await the computation result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0461db73580d6d4278fffb255e74938d931ed12e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;&lt;code&gt;async()&lt;/code&gt;&lt;/a&gt; function to create coroutines that compute deferred values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6065d1c978fbee3b2ff226845a77482cccebc712" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming blocking code. It suspends the coroutine for 100 ms without blocking the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b591373cb35b1a0f6e2219e8ca5964a4f1c5a083" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming code. It suspends the coroutine for 300 ms without blocking the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33adc7173a74761298cf96415d2790cf72a0ec3" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;&lt;code&gt;runBlocking()&lt;/code&gt;&lt;/a&gt; block to wrap a coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50099ad72d8ea21daa614b797c104f31da58f3d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;countDistinctCharacters()&lt;/code&gt; function to count the unique letters in your name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a252bcad831096a6694a845390d272ffaa5046b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2153a3c57b5ac237e2457368e65faee188870aa7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;until&lt;/code&gt; function to loop over an open range:</source>
          <target state="translated">Используйте функцию до тех &lt;code&gt;until&lt;/code&gt; выполните цикл по открытому диапазону:</target>
        </trans-unit>
        <trans-unit id="0bd4c99e44de0d3ffdb3c45eb15b74d7b4c2b386" translate="yes" xml:space="preserve">
          <source>Use the IR backend</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e774b3c689a7ceab89fb14ac0440aed57436890" translate="yes" xml:space="preserve">
          <source>Use the Kotlin dynamic library from C</source>
          <target state="translated">Используйте динамическую библиотеку Котлин из C</target>
        </trans-unit>
        <trans-unit id="44f7acf29bd5c28fb7d8d6e6f897b376b75ea2f3" translate="yes" xml:space="preserve">
          <source>Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2625d939200fe0f3767b996a1eaa8c5f1f235d" translate="yes" xml:space="preserve">
          <source>Use the following factory methods to declare elements of the &lt;code&gt;binaries&lt;/code&gt; collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca17390ef51588303bcc0395c954faa0b511dcd" translate="yes" xml:space="preserve">
          <source>Use the intention from the IDE to include the missing import line:</source>
          <target state="translated">Используйте намерение из IDE,чтобы включить недостающую строку импорта:</target>
        </trans-unit>
        <trans-unit id="c9fe0e8ecff640eabedf59913fdfab4613b76bf4" translate="yes" xml:space="preserve">
          <source>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of &lt;code&gt;Boolean&lt;/code&gt; type, unless the meaning of all parameters is absolutely clear from context.</source>
          <target state="translated">Используйте синтаксис именованных аргументов, когда метод принимает несколько параметров одного и того же примитивного типа, или для параметров &lt;code&gt;Boolean&lt;/code&gt; типа, если значение всех параметров не является абсолютно ясным из контекста.</target>
        </trans-unit>
        <trans-unit id="09617aa736694d6bc881574c01e808ebeb4fb7c7" translate="yes" xml:space="preserve">
          <source>Use the path to the Java runtime version 1.8 or 11 for the &lt;em&gt;Gradle JVM&lt;/em&gt; field. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">Используйте путь к среде выполнения Java версии 1.8 или 11 для поля &lt;em&gt;Gradle JVM&lt;/em&gt; . Посетите &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; или &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/,&lt;/a&gt; чтобы узнать о лучшем распространении JRE, OpenJDK или JDK.</target>
        </trans-unit>
        <trans-unit id="b686514332051bdffa546563fa862bdb9f30b3de" translate="yes" xml:space="preserve">
          <source>Use the scope function &lt;a href=&quot;../../reference/scope-functions#let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; to run the function within the object context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe23756e108375f4f234fa62c62b1a3192f2334" translate="yes" xml:space="preserve">
          <source>Use the shared Kotlin library &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;from iOS app&lt;/a&gt;</source>
          <target state="translated">Используйте общую библиотеку Kotlin &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;из приложения iOS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdbe6eb3123e18a3df48280aadc1acf4ad69906d" translate="yes" xml:space="preserve">
          <source>Use the specified paths as base directories. Base directories are used for calculating relative paths in the source map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e87c063aea31b41f461fabf9570d133ee5c90c0" translate="yes" xml:space="preserve">
          <source>Use the standard library function &lt;code&gt;reversed()&lt;/code&gt; to reverse your name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9852a84398c6954bfc8ee0f3c95a700b78ffafb" translate="yes" xml:space="preserve">
          <source>Use the types &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; and &lt;code&gt;KotlinCompileCommon&lt;/code&gt; for the JS and Common targets, accordingly.</source>
          <target state="translated">Используйте типы &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; и &lt;code&gt;KotlinCompileCommon&lt;/code&gt; для целей JS и Common соответственно.</target>
        </trans-unit>
        <trans-unit id="ba751862add42b30b98929193759e854e81a1255" translate="yes" xml:space="preserve">
          <source>Use this function for projects that contain both Java and Kotlin source files. Note that the default source directories for Java sources don't follow the Java plugin's defaults. Instead, they are derived from the Kotlin source sets. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are &lt;code&gt;src/jvmMain/java&lt;/code&gt; (for production Java sources) and &lt;code&gt;src/jvmTest/java&lt;/code&gt; for test Java sources. Learn how to &lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;include Java sources in JVM compilations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e03be997274e2b63af86d76fc7bf98a2088dbc4" translate="yes" xml:space="preserve">
          <source>Use ts2kt to interact with libraries</source>
          <target state="translated">Использовать ts2kt для взаимодействия с библиотеками</target>
        </trans-unit>
        <trans-unit id="106c8f3de5148d18865fbc697fa5d5cdeecc28c4" translate="yes" xml:space="preserve">
          <source>Use-site variance: Type projections</source>
          <target state="translated">Разница в использовании сайта:Типовые проекции</target>
        </trans-unit>
        <trans-unit id="e2476b5675d923b0014d65b682cc8d7c7848dd3a" translate="yes" xml:space="preserve">
          <source>UseExperimental</source>
          <target state="translated">UseExperimental</target>
        </trans-unit>
        <trans-unit id="5948d8b97ec29bff3672a84e9d432b919624dc55" translate="yes" xml:space="preserve">
          <source>Used both during compilation and at runtime and is exported to library consumers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac3c810c772a41c5e178656755fecd6523a14fa" translate="yes" xml:space="preserve">
          <source>Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73310b7839f171659371cc3680a3ce118bf8dc6d" translate="yes" xml:space="preserve">
          <source>Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c609f5a60b09cc00048be8eb23732ff873a513" translate="yes" xml:space="preserve">
          <source>Used only with &lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27716b3301b8979f846685e09578fc4d968ef31" translate="yes" xml:space="preserve">
          <source>User-defined contracts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2546ff21c7035e67f381dd0185abecc195a459e2" translate="yes" xml:space="preserve">
          <source>Users of Kotlin on the Server Side</source>
          <target state="translated">Пользователи Kotlin на стороне сервера.</target>
        </trans-unit>
        <trans-unit id="47181373df2bd78be6294c0add1dbe6339b4681b" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Использует предоставленный &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;формат&lt;/a&gt; как строку формата и возвращает строку, полученную путем подстановки указанных аргументов с использованием указанного языкового стандарта.</target>
        </trans-unit>
        <trans-unit id="3391e8d9489d92fff425335dfe200993b486d0ea" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Использует предоставленный &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;формат&lt;/a&gt; как строку формата и возвращает строку, полученную путем подстановки указанных аргументов с использованием языкового стандарта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="704ebbde6e2b32eeb1c2f67d4e693a35f67af0fd" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac052dc5a6c0e7fbd28f5bc3a043e4ecb32e5f5" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd3b1deb8f1d7bfb8c12c5a14f2ab32a21d65af" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a75a8ac839c741b8d08dc9c1deee0d88e4f979c" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Использует предоставленный &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;формат&lt;/a&gt; как строку формата и возвращает строку, полученную путем подстановки указанных аргументов с использованием указанного языкового стандарта.</target>
        </trans-unit>
        <trans-unit id="9d3ac3ea11a7f22b1d758a682e71f98cc029fa36" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Использует предоставленный &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;формат&lt;/a&gt; как строку формата и возвращает строку, полученную путем подстановки указанных аргументов с использованием языкового стандарта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="10dc34a2059cb8159f0a883b5dd86e0bc6137e07" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82d324c322c9f91adb6f0983572279a3329ac89" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bfa57761f82862cfd81ebd5b8013f5e01aaad7" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fcdb82df9fab88befa785457e65d1af96aa239" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Использует эту строку в качестве строки форматирования и возвращает строку,полученную путем подстановки указанных аргументов,используя локаль по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3f6866db3da817af6ed67e3dae70c3ec02de81e2" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Использует эту строку в качестве строки форматирования и возвращает строку,полученную путем подстановки указанных аргументов,используя указанную локаль.</target>
        </trans-unit>
        <trans-unit id="6484cdf608c52e6f223f86ea931137798547136f" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a6e896b98588b46d5642885789c195ba9adc2a" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e62e86755452347944ce24bc99c8763bab8c2b5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt; suspending function we can receive &lt;em&gt;either&lt;/em&gt; from one channel or the other. But &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; expression allows us to receive from &lt;em&gt;both&lt;/em&gt; simultaneously using its &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clauses:</source>
          <target state="translated">Используя функцию приостановки &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;приема,&lt;/a&gt; мы можем получать &lt;em&gt;как&lt;/em&gt; с одного канала, так и с другого. Но выражение &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; позволяет нам получать от &lt;em&gt;обоих&lt;/em&gt; одновременно, используя его предложения &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="08f3f41e2b1efe6c5dce0e5fec64099ed03bdf2b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;lambdas&quot;&gt;higher-order functions&lt;/a&gt; imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</source>
          <target state="translated">Использование &lt;a href=&quot;lambdas&quot;&gt;функций высшего порядка&lt;/a&gt; налагает определенные штрафы во время выполнения: каждая функция является объектом, и она фиксирует замыкание, то есть те переменные, к которым осуществляется доступ в теле функции. Выделение памяти (как для функциональных объектов, так и для классов) и виртуальные вызовы приводят к накладным расходам времени выполнения.</target>
        </trans-unit>
        <trans-unit id="491e6c994c3baf4cc8af39219068162e74e38931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;::Foo&lt;/code&gt;, the zero-argument constructor of the class Foo, we can simply call it like this:</source>
          <target state="translated">Используя &lt;code&gt;::Foo&lt;/code&gt; , конструктор без аргументов класса Foo, мы можем просто назвать его следующим образом:</target>
        </trans-unit>
        <trans-unit id="df28902f080c8e95c2e047504754d8fc98471dfb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1288042cdb0bedb4cedef04fffbbc6421151560c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;when&lt;/code&gt; expression</source>
          <target state="translated">Использование выражения &lt;code&gt;when&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4d45feb4cce668fd7098830e83bf2557a415c16" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;if&lt;/em&gt; as an expression:</source>
          <target state="translated">Использование &lt;em&gt;if&lt;/em&gt; в качестве выражения:</target>
        </trans-unit>
        <trans-unit id="7956ce97b97e87d0f55a6ea0cc6e4e05373fcf15" translate="yes" xml:space="preserve">
          <source>Using AMD</source>
          <target state="translated">Использование AMD</target>
        </trans-unit>
        <trans-unit id="aae897c446cafc25370dcce91792d5e6dfa9a087" translate="yes" xml:space="preserve">
          <source>Using Ant</source>
          <target state="translated">Использование муравья</target>
        </trans-unit>
        <trans-unit id="44ab2ab05f55d2266ffc569dcf7fc124a65679b4" translate="yes" xml:space="preserve">
          <source>Using C Interop and libcurl for an App</source>
          <target state="translated">Использование C-интерропа и libcurl для приложения</target>
        </trans-unit>
        <trans-unit id="a59cc5aadf82954e8f0283bd3dfcaae639efbadd" translate="yes" xml:space="preserve">
          <source>Using C library from Kotlin/Native</source>
          <target state="translated">Использование библиотеки на С из Котлина/Натив</target>
        </trans-unit>
        <trans-unit id="d678710e9135632a43d33f3d5da6bf72dddacbe5" translate="yes" xml:space="preserve">
          <source>Using CommonJS</source>
          <target state="translated">Использование CommonJS</target>
        </trans-unit>
        <trans-unit id="e42f7c8cd0e8730768cbb184338fabc772fadfd5" translate="yes" xml:space="preserve">
          <source>Using Dynamic</source>
          <target state="translated">Используя Dynamic</target>
        </trans-unit>
        <trans-unit id="cbe69bb9e7692bc07945db15e10c51c3ee312db2" translate="yes" xml:space="preserve">
          <source>Using Generated Headers from C</source>
          <target state="translated">Использование сгенерированных заголовков из C</target>
        </trans-unit>
        <trans-unit id="27c679a18ee1d9ed93d7a66b728665e446e0b013" translate="yes" xml:space="preserve">
          <source>Using Gradle</source>
          <target state="translated">Использование колыбели</target>
        </trans-unit>
        <trans-unit id="17fbd0b7659b724c4b82377e5e5b6176a4a4d7c0" translate="yes" xml:space="preserve">
          <source>Using Gradle Kotlin DSL</source>
          <target state="translated">Использование Gradle Kotlin DSL</target>
        </trans-unit>
        <trans-unit id="71d5b086b763a415271837d49bf05b383ed34176" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA Build System</source>
          <target state="translated">Использование системы IntelliJ IDEA Build System</target>
        </trans-unit>
        <trans-unit id="be4003165448a14831defb73021c979f0b4b46d4" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cb9f3916c8314e916dfe4f86e42b9f41066648" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA we can easily run and debug the application in any of the possible application servers defined such as Tomcat, Glassfish or WildFly. In this case we're going to use Tomcat which has previously &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;been defined as an application server in IntelliJ IDEA&lt;/a&gt;. Note that application server support is only available in IntelliJ IDEA Ultimate.</source>
          <target state="translated">Используя IntelliJ IDEA, мы можем легко запускать и отлаживать приложение на любом из возможных серверов приложений, таких как Tomcat, Glassfish или WildFly. В этом случае мы собираемся использовать Tomcat, который ранее &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;был определен как сервер приложений в IntelliJ IDEA&lt;/a&gt; . Обратите внимание, что поддержка сервера приложений доступна только в IntelliJ IDEA Ultimate.</target>
        </trans-unit>
        <trans-unit id="4709ae28ff320dfabd65f0869103704aedfcf674" translate="yes" xml:space="preserve">
          <source>Using JNI with Kotlin</source>
          <target state="translated">Использование JNI с Котлином</target>
        </trans-unit>
        <trans-unit id="2bbc39d0664d569562a91137d4d90178cf23c617" translate="yes" xml:space="preserve">
          <source>Using Kotlin Android Extensions</source>
          <target state="translated">Использование Kotlin Android расширений</target>
        </trans-unit>
        <trans-unit id="b022874247f51c944909afa759f623b6478ca32e" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android Development</source>
          <target state="translated">Использование Kotlin для разработки Android</target>
        </trans-unit>
        <trans-unit id="60a1392d0c8d40966f3ba2738ae5f701e549f245" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android development, you can benefit from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf246aafd7124667a554d398075e5452aa83ed4" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Server-side Development</source>
          <target state="translated">Использование Kotlin для разработки серверов</target>
        </trans-unit>
        <trans-unit id="2b0fb5591f02bcbebcc2bd375ac8a71d601338b0" translate="yes" xml:space="preserve">
          <source>Using Kotlin/Native Targets</source>
          <target state="translated">Использование Котлина/Отрицательных целей</target>
        </trans-unit>
        <trans-unit id="936b968752b32f197dc84832341b3f607b83a027" translate="yes" xml:space="preserve">
          <source>Using Maven</source>
          <target state="translated">Использование Maven</target>
        </trans-unit>
        <trans-unit id="ef7af2346af2c37f7e6ee428aab1c98075a789a9" translate="yes" xml:space="preserve">
          <source>Using SharedCode from Android</source>
          <target state="translated">Использование общего кода от Android</target>
        </trans-unit>
        <trans-unit id="603ab8042b5d1c17d5b50d529fa9db7d658d860a" translate="yes" xml:space="preserve">
          <source>Using Struct and Union Types from Kotlin</source>
          <target state="translated">Используя структурные и соединительные типы от Kotlin</target>
        </trans-unit>
        <trans-unit id="6e4c13998b5f91e0846d37840959ab407900c453" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">Использование цикла &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe7e2f58454fbb71457b9ce1e7ce104ef338243" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">Используя &lt;code&gt;while&lt;/code&gt; цикл</target>
        </trans-unit>
        <trans-unit id="29dae43467cc406389583f725ed8cb7bcc1c247d" translate="yes" xml:space="preserve">
          <source>Using a Kotlin/JavaScript library.</source>
          <target state="translated">Использование библиотеки Kotlin/JavaScript.</target>
        </trans-unit>
        <trans-unit id="d3383ee07c516c1fa1802c63fcedaaefadd8e48c" translate="yes" xml:space="preserve">
          <source>Using a callable reference to an existing declaration:</source>
          <target state="translated">Использование вызываемой ссылки на существующую декларацию:</target>
        </trans-unit>
        <trans-unit id="197fb49229d662d3379f8cffecb5a8e470235340" translate="yes" xml:space="preserve">
          <source>Using a code block within a function literal, in one of the forms:</source>
          <target state="translated">Использование блока кода внутри буквальной функции,в одной из форм:</target>
        </trans-unit>
        <trans-unit id="a7c34a78b0f5530284b929714a111e0120a19cb8" translate="yes" xml:space="preserve">
          <source>Using a standard build tool</source>
          <target state="translated">Использование стандартного инструмента сборки</target>
        </trans-unit>
        <trans-unit id="6825ce8ddbdb846319b075044bc1aefd9c058144" translate="yes" xml:space="preserve">
          <source>Using artifacts built with Kotlin 1.4.x in a Kotlin 1.3.x project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3edbb4ebc2b355b2a8f195be33f5a03ead3d30" translate="yes" xml:space="preserve">
          <source>Using bindings</source>
          <target state="translated">Использование креплений</target>
        </trans-unit>
        <trans-unit id="92c77c8ea60a2ffe09d3b8484f979577fe3fe402" translate="yes" xml:space="preserve">
          <source>Using cinterop</source>
          <target state="translated">Использование цинтеропа</target>
        </trans-unit>
        <trans-unit id="6f335b7fd336f32636cf82fea33e6e5a118b4de7" translate="yes" xml:space="preserve">
          <source>Using collections</source>
          <target state="translated">Использование коллекций</target>
        </trans-unit>
        <trans-unit id="ce4da38f792e511ab4d77c2e6a228d9a0f717f17" translate="yes" xml:space="preserve">
          <source>Using conditional expressions</source>
          <target state="translated">Использование условных выражений</target>
        </trans-unit>
        <trans-unit id="918641690842037efdc3f921e9d2a03a1b94d884" translate="yes" xml:space="preserve">
          <source>Using conditional statements</source>
          <target state="translated">Использование условных операторов</target>
        </trans-unit>
        <trans-unit id="3fc2b300fe4dab146a33f883986c605263212bcf" translate="yes" xml:space="preserve">
          <source>Using experimental APIs</source>
          <target state="translated">Использование экспериментальных API</target>
        </trans-unit>
        <trans-unit id="ebd9b5845829e10c5bf4bfdb285f0143f1b0cc17" translate="yes" xml:space="preserve">
          <source>Using extension functions</source>
          <target state="translated">Использование функций расширения</target>
        </trans-unit>
        <trans-unit id="b252910d4e8badbe4bca9df0c30fd5478c5c630b" translate="yes" xml:space="preserve">
          <source>Using in CLI</source>
          <target state="translated">Использование в CLI</target>
        </trans-unit>
        <trans-unit id="30f417bc0504e6fe1552d975f144e48529a622bd" translate="yes" xml:space="preserve">
          <source>Using in Gradle</source>
          <target state="translated">Использование в колыбели</target>
        </trans-unit>
        <trans-unit id="987fbf118a45b1d5fc70735f1b4a9cb07d729a9e" translate="yes" xml:space="preserve">
          <source>Using in Maven</source>
          <target state="translated">Используется в Мавене</target>
        </trans-unit>
        <trans-unit id="b58b6328c1df079d0d8cccee5234ec40deb70287" translate="yes" xml:space="preserve">
          <source>Using infix functions</source>
          <target state="translated">Использование функций инфиксов</target>
        </trans-unit>
        <trans-unit id="a915c033f5e92eb86f6eb764c7d3fbfec97399c7" translate="yes" xml:space="preserve">
          <source>Using instances of a custom class that implements a function type as an interface:</source>
          <target state="translated">Использование экземпляров пользовательского класса,реализующих тип функции в качестве интерфейса:</target>
        </trans-unit>
        <trans-unit id="b7d1f08b0755e4efecc6155b06410d6d8f47dd0c" translate="yes" xml:space="preserve">
          <source>Using kotlinx.html</source>
          <target state="translated">Используя kotlinx.html</target>
        </trans-unit>
        <trans-unit id="e33a647f9d820f02525a9e589cf38c7cb15aa9e1" translate="yes" xml:space="preserve">
          <source>Using lambda expressions to filter and map collections:</source>
          <target state="translated">Использование лямбда-выражений для фильтрации и создания коллекций карт:</target>
        </trans-unit>
        <trans-unit id="85b9a9b134d068b76d1d9da5eba9082360a75376" translate="yes" xml:space="preserve">
          <source>Using loops</source>
          <target state="translated">Использование петель</target>
        </trans-unit>
        <trans-unit id="e702f70d153e5bb48504257ee3c4806c305f3fd0" translate="yes" xml:space="preserve">
          <source>Using modules</source>
          <target state="translated">Использование модулей</target>
        </trans-unit>
        <trans-unit id="9af9fabd79c052500b25a5c07039f994d4da9bd7" translate="yes" xml:space="preserve">
          <source>Using nullable &lt;code&gt;Boolean&lt;/code&gt; values in conditions</source>
          <target state="translated">Использование в условиях &lt;code&gt;Boolean&lt;/code&gt; значений, допускающих значение NULL</target>
        </trans-unit>
        <trans-unit id="d6a1a404256e60f476abcfdb633a3c534e236959" translate="yes" xml:space="preserve">
          <source>Using nullable values and checking for &lt;em&gt;null&lt;/em&gt;</source>
          <target state="translated">Использование значений, допускающих значение NULL, и проверка на &lt;em&gt;нуль&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="872ffc0740cd8cd114c0bd134533ae0bef8b975c" translate="yes" xml:space="preserve">
          <source>Using our favorite editor, we create a new file called &lt;em&gt;library.kt&lt;/em&gt;:</source>
          <target state="translated">Используя наш любимый редактор, мы создаем новый файл с именем &lt;em&gt;library.kt&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="4b0f18fbc913dc4d928de83407023cd4eadce18c" translate="yes" xml:space="preserve">
          <source>Using packages from npm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550a8f8d20b2e8584106d065339f4d4da1689dfc" translate="yes" xml:space="preserve">
          <source>Using ranges</source>
          <target state="translated">Диапазон использования</target>
        </trans-unit>
        <trans-unit id="51f179a48f07181aae2f460999afe3b38f8238e7" translate="yes" xml:space="preserve">
          <source>Using scope functions apply/with/run/also/let</source>
          <target state="translated">Использование функций диапазона применения/с/выполнение/подключение/включение</target>
        </trans-unit>
        <trans-unit id="3ec4dda09fda63d9abb963027b78f1d3b6ffe21e" translate="yes" xml:space="preserve">
          <source>Using string templates</source>
          <target state="translated">Использование строковых шаблонов</target>
        </trans-unit>
        <trans-unit id="4e76a46a35a0080ea05cb7befbedfc77e476e034" translate="yes" xml:space="preserve">
          <source>Using strings</source>
          <target state="translated">Использование строк</target>
        </trans-unit>
        <trans-unit id="e23bbbb1e9be4eb1c796c8553364504fb8af04eb" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt;&lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/a&gt; type just like we would use the &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; type for synchronously computed values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18148327a2ccfbb8e71316dac9304b16aaccd2b3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin for building &lt;a href=&quot;multiplatform&quot;&gt;multiplatform projects&lt;/a&gt; is described in &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Building Multiplatform Projects with Gradle&lt;/a&gt;.</source>
          <target state="translated">Использование &lt;code&gt;kotlin-multiplatform&lt;/code&gt; для создания &lt;a href=&quot;multiplatform&quot;&gt;многоплатформенных проектов&lt;/a&gt; описано в разделе Создание многоплатформенных &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;проектов с помощью Gradle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="662526f9ec265672a8f5eadc1e458fce90d93089" translate="yes" xml:space="preserve">
          <source>Using the C Function Pointer from Kotlin</source>
          <target state="translated">Использование функционального указателя C из Котлина</target>
        </trans-unit>
        <trans-unit id="3b3c88f2622b6c11af48eeafb534d5bf373c1268" translate="yes" xml:space="preserve">
          <source>Using the Code from Objective-C</source>
          <target state="translated">Используя код из Цели-С</target>
        </trans-unit>
        <trans-unit id="2751cf504326591f0615360e90b35bf6098ad931" translate="yes" xml:space="preserve">
          <source>Using the Code from Swift</source>
          <target state="translated">Использование кода от Swift</target>
        </trans-unit>
        <trans-unit id="d94748ae1985e15517523c51bbe68be1dc451c79" translate="yes" xml:space="preserve">
          <source>Using the Kotlin/JS IR compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e131a08f907def09c45df11a971dfb390d42ac" translate="yes" xml:space="preserve">
          <source>Using the command line to run scripts</source>
          <target state="translated">Использование командной строки для выполнения скриптов</target>
        </trans-unit>
        <trans-unit id="0dde1829bc0d42dfa9d3d99dc69c6583462ddf28" translate="yes" xml:space="preserve">
          <source>Using the tool &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin) we can convert any &lt;code&gt;d.ts&lt;/code&gt; files to Kotlin. To install the tool we can use &lt;code&gt;npm&lt;/code&gt;</source>
          <target state="translated">Используя инструмент &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin), мы можем преобразовать любые файлы &lt;code&gt;d.ts&lt;/code&gt; в Kotlin. Для установки инструмента мы можем использовать &lt;code&gt;npm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89a0f28e4e5bf44543e1c9581c55c0e6aecc40d" translate="yes" xml:space="preserve">
          <source>Using trailing commas has several benefits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebccac5de220cac33103fa30ac3780779ac2fcd" translate="yes" xml:space="preserve">
          <source>Using ts2kt to generate header files for Kotlin</source>
          <target state="translated">Использование ts2kt для генерации заголовочных файлов для Kotlin</target>
        </trans-unit>
        <trans-unit id="e0fbba9738442b4c0647e5831e5969871c4f6a2a" translate="yes" xml:space="preserve">
          <source>Using type checks and automatic casts</source>
          <target state="translated">Использование типовых проверок и автоматических отливок</target>
        </trans-unit>
        <trans-unit id="d8d81e999a726d52e9414f74a35f368a368d19de" translate="yes" xml:space="preserve">
          <source>Usually these fields are private but they can be exposed in one of the following ways:</source>
          <target state="translated">Обычно эти поля являются приватными,но они могут быть открыты одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="c1278d398657af96687576590c71d68b9a3f58aa" translate="yes" xml:space="preserve">
          <source>Usually, a native binary can be compiled as &lt;em&gt;debug&lt;/em&gt; with more debug information and fewer optimizations, and &lt;em&gt;release&lt;/em&gt; where optimizations are enabled and there is no (or at least less) debug information available.</source>
          <target state="translated">Обычно собственный двоичный файл может быть скомпилирован как &lt;em&gt;отладочный&lt;/em&gt; с большим количеством отладочной информации и меньшим количеством оптимизаций, а также &lt;em&gt;выпуск, в&lt;/em&gt; котором оптимизации включены и нет (или, по крайней мере, меньше) доступной отладочной информации.</target>
        </trans-unit>
        <trans-unit id="12caefb8a5010ce40aa23c1ea29352f8837f75ed" translate="yes" xml:space="preserve">
          <source>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it &lt;em&gt;unsafe&lt;/em&gt;. The unsafe cast in Kotlin is done by the infix operator &lt;em&gt;as&lt;/em&gt; (see &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;operator precedence&lt;/a&gt;):</source>
          <target state="translated">Обычно оператор приведения выдает исключение, если приведение невозможно. Таким образом, мы называем это &lt;em&gt;небезопасным&lt;/em&gt; . Небезопасное приведение в Kotlin выполняется инфиксным оператором &lt;em&gt;как&lt;/em&gt; (см. &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;Приоритет операторов&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="078efedb0f7a9297e4a66c7bf48c73578606e64d" translate="yes" xml:space="preserve">
          <source>Utility functions for concurrent programming.</source>
          <target state="translated">Функции утилиты для параллельного программирования.</target>
        </trans-unit>
        <trans-unit id="54a27f71a3926c933fffb4cc8fcd736d36aae00b" translate="yes" xml:space="preserve">
          <source>Utility functions for working with Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams&lt;/a&gt;.</source>
          <target state="translated">Служебные функции для работы с &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;потоками&lt;/a&gt; Java 8 .</target>
        </trans-unit>
        <trans-unit id="70a0023fe530c9e1dc6b5efd1156df2342cee154" translate="yes" xml:space="preserve">
          <source>Utility functions for working with the browser DOM.</source>
          <target state="translated">Функции утилиты для работы с браузером DOM.</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="b48498a5cff3c4e7ce37b18fdd81413319dd4656" translate="yes" xml:space="preserve">
          <source>VALUE_PARAMETER</source>
          <target state="translated">VALUE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="242cc9162b91c0b54499ac05fdd663dcea97e3ff" translate="yes" xml:space="preserve">
          <source>ValidityState</source>
          <target state="translated">ValidityState</target>
        </trans-unit>
        <trans-unit id="4ca51107e6a14998cd7631ba2234ead0b2f51037" translate="yes" xml:space="preserve">
          <source>Value arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc813f9a338f88bada03e57203025b97e72de98e" translate="yes" xml:space="preserve">
          <source>Value parameter of a function or a constructor</source>
          <target state="translated">Значение параметра функции или конструктора</target>
        </trans-unit>
        <trans-unit id="ae0d9f73010cf89531cbcdadc5148c931b0aba52" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;collected&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b78efaf35ec9ac8ccb78b50e8f937f6c083fa" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;emitted&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;emit&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7d4e58b65d5a70d4dfae24ee97f38d7c1a9ff0" translate="yes" xml:space="preserve">
          <source>Values can be updated. In turn, keys never change: once you add an entry, its key is constant.</source>
          <target state="translated">Значения могут быть обновлены.В свою очередь,клавиши никогда не меняются:как только вы добавляете запись,ее ключ остается постоянным.</target>
        </trans-unit>
        <trans-unit id="83ce8efcd219286f9e80c1c630307f7c0a05ac1f" translate="yes" xml:space="preserve">
          <source>Values of an annotation instance are exposed as properties to Kotlin code:</source>
          <target state="translated">Значения экземпляра аннотации выставляются в качестве свойств кода Kotlin:</target>
        </trans-unit>
        <trans-unit id="e2e1116424b8a24a96cede1b506dcc3d11485f0b" translate="yes" xml:space="preserve">
          <source>VarType</source>
          <target state="translated">VarType</target>
        </trans-unit>
        <trans-unit id="42ec9490f36e6cae9913c4374b09e32237c707ad" translate="yes" xml:space="preserve">
          <source>Varargs and optional/named parameters</source>
          <target state="translated">Препятствия и опциональные/именованные параметры</target>
        </trans-unit>
        <trans-unit id="10eea16b487acafb1da690a6fa932f924aadcf7a" translate="yes" xml:space="preserve">
          <source>Variable inspection</source>
          <target state="translated">переменная проверка</target>
        </trans-unit>
        <trans-unit id="342ee951b83918c9c708f1243be034edc6ba7220" translate="yes" xml:space="preserve">
          <source>Variable inspections for var variables works out of the box for primitive types. For non-primitive types there are custom pretty printers for lldb in &lt;code&gt;konan_lldb.py&lt;/code&gt;:</source>
          <target state="translated">Проверка переменных для переменных var работает из коробки для примитивных типов. Для непримитивных типов в &lt;code&gt;konan_lldb.py&lt;/code&gt; есть собственные симпатичные принтеры для lldb :</target>
        </trans-unit>
        <trans-unit id="a018b33a39aac69fe200a8b99412d4c30ecc8054" translate="yes" xml:space="preserve">
          <source>Variable names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">Имена переменных должны использовать &lt;code&gt;lowerCamelCase&lt;/code&gt; вместо &lt;code&gt;snake_case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43edb35cae8befc5879d0b7aa2cd22c92255e5d7" translate="yes" xml:space="preserve">
          <source>Variable number of arguments (Varargs)</source>
          <target state="translated">Переменное число аргументов (Varargs)</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="eaac90ed072370b9f57426b726154a33050c4fed" translate="yes" xml:space="preserve">
          <source>Variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; get the values returned by &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; called on elements of the collection.</source>
          <target state="translated">Переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; получают значения, возвращаемые &lt;code&gt;component1()&lt;/code&gt; и &lt;code&gt;component2()&lt;/code&gt; вызванными элементами коллекции.</target>
        </trans-unit>
        <trans-unit id="808412b58bbf8525d5dac7961edbdfc05c3db76a" translate="yes" xml:space="preserve">
          <source>Variables that can be reassigned use the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">Переменные, которые можно переназначить, используют ключевое слово &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="1a91ea423a97d4a87943d588b081e7e38282531c" translate="yes" xml:space="preserve">
          <source>Variance directions</source>
          <target state="translated">Варианты направлений</target>
        </trans-unit>
        <trans-unit id="5c16bf6df0ccb8c8f8d9897278f38f99a8d180ae" translate="yes" xml:space="preserve">
          <source>Variant generics</source>
          <target state="translated">Вариантные дженерики</target>
        </trans-unit>
        <trans-unit id="48aeb525f24a17a17a2746ff3465033889ff970a" translate="yes" xml:space="preserve">
          <source>Various collections and sequences can be converted to flows using &lt;code&gt;.asFlow()&lt;/code&gt; extension functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed714f305f37a57ecb8473b7415dfab9db01f6a" translate="yes" xml:space="preserve">
          <source>Various utilities for working with strings and char sequences.</source>
          <target state="translated">Различные утилиты для работы со строками и последовательностями символов.</target>
        </trans-unit>
        <trans-unit id="280853b24c26b2f29a476f73ab7f87fbd08c6186" translate="yes" xml:space="preserve">
          <source>Vector128</source>
          <target state="translated">Vector128</target>
        </trans-unit>
        <trans-unit id="6c08e229ae1df722641eb28302211d6c86591e45" translate="yes" xml:space="preserve">
          <source>Vector128Var</source>
          <target state="translated">Vector128Var</target>
        </trans-unit>
        <trans-unit id="9ffb8650f3fdd46d87c18838f3017eda5ad872f4" translate="yes" xml:space="preserve">
          <source>Vector128VarOf</source>
          <target state="translated">Vector128VarOf</target>
        </trans-unit>
        <trans-unit id="288ce52d20fd503b110a72d86e9675e1c95e19eb" translate="yes" xml:space="preserve">
          <source>Verify the emulator configuration and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">Проверьте конфигурацию эмулятора и нажмите &lt;strong&gt;Готово&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de621f8c2654b2397c981cb428da06adf04bb6fe" translate="yes" xml:space="preserve">
          <source>Versioned separately from the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bee7b1488f1e88fea6081e11b80da21edf9ec4" translate="yes" xml:space="preserve">
          <source>VideoFacingModeEnum</source>
          <target state="translated">VideoFacingModeEnum</target>
        </trans-unit>
        <trans-unit id="fa871b63d316a5ccaf06d516a54da0961996827d" translate="yes" xml:space="preserve">
          <source>VideoResizeModeEnum</source>
          <target state="translated">VideoResizeModeEnum</target>
        </trans-unit>
        <trans-unit id="64fea40a0473c85795b9336e14b2b716b018b418" translate="yes" xml:space="preserve">
          <source>VideoTrack</source>
          <target state="translated">VideoTrack</target>
        </trans-unit>
        <trans-unit id="c02eab00438fffc417a6ac0aa9bb22fc06605beb" translate="yes" xml:space="preserve">
          <source>View binding</source>
          <target state="translated">Смотровая привязка</target>
        </trans-unit>
        <trans-unit id="db9fea7c8a56a15e997acc428b673797be1af865" translate="yes" xml:space="preserve">
          <source>View caching</source>
          <target state="translated">Видовое кэширование</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="0d73e14a3fcddf8956a7da60bbcb1e077c95f7a0" translate="yes" xml:space="preserve">
          <source>Visibility Modifiers</source>
          <target state="translated">Модификаторы видимости</target>
        </trans-unit>
        <trans-unit id="28ffb1b2d0c701707ce3c73f2c7cf4a513706777" translate="yes" xml:space="preserve">
          <source>Visibility is an aspect of a Kotlin declaration regulating where that declaration is accessible in the source code. Visibility can be changed with one of the following modifiers: &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">Видимость - это аспект декларации Kotlin, регулирующий доступ к этой декларации в исходном коде. Видимость можно изменить с помощью одного из следующих модификаторов: &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="849b37d75d9e78cb34f760a7b86638406d0e4272" translate="yes" xml:space="preserve">
          <source>Visibility modifiers</source>
          <target state="translated">Модификаторы видимости</target>
        </trans-unit>
        <trans-unit id="572b59949083550c2f89c909f2a69634e1647c72" translate="yes" xml:space="preserve">
          <source>Visibility modifiers are required for declarations if the default visibility exposes them to the public API. This helps ensure that no declarations are exposed to the public API unintentionally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccb166e167967c0af7bc8270ccff3bc3f332444" translate="yes" xml:space="preserve">
          <source>Visibility modifiers can't be placed on local variables, since their visibility is always limited to the containing block.</source>
          <target state="translated">Модификаторы видимости не могут быть размещены на локальных переменных,так как их видимость всегда ограничена содержащим блоком.</target>
        </trans-unit>
        <trans-unit id="6cd8f7e2419769693129b0c2082de4e40a0da3a3" translate="yes" xml:space="preserve">
          <source>Visibility of Top-level Declarations</source>
          <target state="translated">Видимость деклараций высшего уровня</target>
        </trans-unit>
        <trans-unit id="b794e604145c856d9c96b2bfb79a673421c9cf64" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;internal&lt;/code&gt; modifier.</source>
          <target state="translated">Видимость деклараций, отмеченных модификатором &lt;code&gt;internal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63bf3a48e0f5fd4c5b7c9576056b33b03784b05d" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">Видимость объявлений, отмеченных модификатором &lt;code&gt;private&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d02ce232d311d05d3099c6a996cbef8c4dd286f9" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">Видимость объявлений, отмеченных модификатором &lt;code&gt;protected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd1c739248ca96578cca7f9bfb547899b54a876f" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;public&lt;/code&gt; modifier, or with no modifier at all.</source>
          <target state="translated">Видимость объявлений, помеченных модификатором &lt;code&gt;public&lt;/code&gt; или вообще без модификатора.</target>
        </trans-unit>
        <trans-unit id="de706486df3bb39a3413cb5cbbb1d996126bda21" translate="yes" xml:space="preserve">
          <source>Visibility of this callable, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">Видимость этого вызываемого объекта или значение &lt;code&gt;null&lt;/code&gt; , если его видимость не может быть представлена ​​в Kotlin.</target>
        </trans-unit>
        <trans-unit id="dac6119f07007062b4875b1638bac8a721585f4a" translate="yes" xml:space="preserve">
          <source>Visibility of this class, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">Видимость этого класса или значение &lt;code&gt;null&lt;/code&gt; , если его видимость не может быть представлена ​​в Kotlin.</target>
        </trans-unit>
        <trans-unit id="aabca03bdef260f1cffd784ffe10c2b762503211" translate="yes" xml:space="preserve">
          <source>Visibility rules regarding complex class hierarchies with companion objects</source>
          <target state="translated">Правила видимости относительно сложных классовых иерархий со смежными объектами</target>
        </trans-unit>
        <trans-unit id="ac3022e113442db8619d262ae03fa9c0097a6e0d" translate="yes" xml:space="preserve">
          <source>Volatile</source>
          <target state="translated">Volatile</target>
        </trans-unit>
        <trans-unit id="74365b04f91d0aa9f5cfe78a2b9d8c743270db07" translate="yes" xml:space="preserve">
          <source>Volatiles are of no help</source>
          <target state="translated">Волатиль не поможет</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="4e946026a7ff331eb2b9dc124f891817863bd199" translate="yes" xml:space="preserve">
          <source>WASM</source>
          <target state="translated">WASM</target>
        </trans-unit>
        <trans-unit id="25ca2ee13f635d58b0c2cff69efbc6a4f1b88f58" translate="yes" xml:space="preserve">
          <source>WASM32</source>
          <target state="translated">WASM32</target>
        </trans-unit>
        <trans-unit id="406538ae6cd24bca924c59857d3c75a306aa56eb" translate="yes" xml:space="preserve">
          <source>WATCHOS</source>
          <target state="translated">WATCHOS</target>
        </trans-unit>
        <trans-unit id="b9fac4aec6291b1c5ab0f9569e59e39d2636356c" translate="yes" xml:space="preserve">
          <source>WCString</source>
          <target state="translated">WCString</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="2e31950e28a56c4fe6e7025b187b2fd4fefe4871" translate="yes" xml:space="preserve">
          <source>WINDOWS</source>
          <target state="translated">WINDOWS</target>
        </trans-unit>
        <trans-unit id="d9fff1c0dfb1298ad2bb377a3be85896a8fef6d6" translate="yes" xml:space="preserve">
          <source>Waiting for a job</source>
          <target state="translated">В ожидании работы</target>
        </trans-unit>
        <trans-unit id="43754c49f6c1a5cc1ea3d54dbf166c296a415ea2" translate="yes" xml:space="preserve">
          <source>Warning! Annotating your API with &lt;code&gt;@JvmDefault&lt;/code&gt; has serious implications on binary compatibility. Make sure to carefully read the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;reference page&lt;/a&gt; before using &lt;code&gt;@JvmDefault&lt;/code&gt; in production.</source>
          <target state="translated">Предупреждение! &lt;code&gt;@JvmDefault&lt;/code&gt; вашего API с помощью @JvmDefault имеет серьезные последствия для двоичной совместимости. Обязательно внимательно прочтите &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;справочную страницу&lt;/a&gt; перед использованием &lt;code&gt;@JvmDefault&lt;/code&gt; в рабочей среде .</target>
        </trans-unit>
        <trans-unit id="7d38e4cd7c43347e6b57a76218aeff28900c3be2" translate="yes" xml:space="preserve">
          <source>Warning: using reflection is usually the wrong way to solve problems in Kotlin! In particular, if you have several classes that all have some common properties/functions and you want to write a function that can take an instance of any of those classes and use those properties, the correct approach is to define an interface with the common properties/functions and make all the relevant classes implement it; the function can then take that interface as a parameter. If you don't control those classes, you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern&lt;/a&gt; and write wrapper classes that implement the interface - this is very easy thanks to Kotlin's &lt;a href=&quot;inheritance#delegation&quot;&gt;delegation feature&lt;/a&gt;. You can also get a lot of leverage out of using generics in clever ways.</source>
          <target state="translated">Предупреждение: использование отражения обычно является неправильным способом решения проблем в Kotlin! В частности, если у вас есть несколько классов, каждый из которых имеет некоторые общие свойства / функции, и вы хотите написать функцию, которая может принимать экземпляр любого из этих классов и использовать эти свойства, правильным подходом будет определение интерфейса с общими свойствами. / functions и заставить все соответствующие классы реализовать его; затем функция может принять этот интерфейс в качестве параметра. Если вы не контролируете эти классы, вы можете использовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;шаблон адаптера&lt;/a&gt; и написать классы-оболочки, реализующие интерфейс - это очень просто благодаря &lt;a href=&quot;inheritance#delegation&quot;&gt;функции делегирования&lt;/a&gt; Kotlin . Вы также можете получить большую выгоду от разумного использования дженериков.</target>
        </trans-unit>
        <trans-unit id="5869fc3835710be9dffa94b09164944fe6c00863" translate="yes" xml:space="preserve">
          <source>Warnings as errors</source>
          <target state="translated">Предупреждения как ошибки</target>
        </trans-unit>
        <trans-unit id="7d7a6c37ae0a89dc47c6393b7b23a560c9ff63a7" translate="yes" xml:space="preserve">
          <source>Watch for deprecation warnings in advance for the best update experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621508220c73315e0bfc68d68f589c562907f45d" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;SharedCode&lt;/code&gt; framework to the Xcode project. For that let's click on the root node of the &lt;em&gt;project navigator&lt;/em&gt; and select the &lt;em&gt;target&lt;/em&gt; settings. Next, we click on the &lt;code&gt;+&lt;/code&gt; in the &lt;em&gt;Embedded Binaries&lt;/em&gt; section, click &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; button in the dialog to choose the framework from the disk. We can point to the following folder:</source>
          <target state="translated">Мы добавляем фреймворк &lt;code&gt;SharedCode&lt;/code&gt; в проект Xcode. Для этого щелкните корневой узел &lt;em&gt;навигатора проекта&lt;/em&gt; и выберите &lt;em&gt;целевые&lt;/em&gt; параметры. Затем мы нажимаем &lt;code&gt;+&lt;/code&gt; в разделе &lt;em&gt;Embedded Binaries&lt;/em&gt; , нажимаем кнопку &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; в диалоговом окне, чтобы выбрать фреймворк с диска. Мы можем указать на следующую папку:</target>
        </trans-unit>
        <trans-unit id="6a9f25c8723418966c0e0b17f9549ea1ce5a5f99" translate="yes" xml:space="preserve">
          <source>We also need to use the &lt;em&gt;war&lt;/em&gt; plugin that helps us generate the corresponding WAR artifacts for running/deploying</source>
          <target state="translated">Нам также необходимо использовать плагин &lt;em&gt;war,&lt;/em&gt; который помогает нам генерировать соответствующие артефакты WAR для запуска / развертывания.</target>
        </trans-unit>
        <trans-unit id="8f769d9a3ee354265c33ea15ceda2db82197765c" translate="yes" xml:space="preserve">
          <source>We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f808d588d4d3fcebee5f5b3ff2c14b3f46e0e3a6" translate="yes" xml:space="preserve">
          <source>We are now migrating Kotlin/JVM and Kotlin/JS to the same IR. As a result, all three backends share a lot of logic and have a unified pipeline. This allows us to implement most features, optimizations, and bug fixes only once for all platforms. Both new IR-based back-ends are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a06031f1e06a7952c57e44121ca5e185850421" translate="yes" xml:space="preserve">
          <source>We are now ready to start coding the iOS application and to use the Kotlin code from it</source>
          <target state="translated">Теперь мы готовы приступить к кодированию iOS-приложения и использовать код Kotlin из него.</target>
        </trans-unit>
        <trans-unit id="cff8cb63586d851860fe613c1e521ee0461e4b2e" translate="yes" xml:space="preserve">
          <source>We are ready to use the &lt;code&gt;SharedCode&lt;/code&gt; library from our Android and iOS applications.</source>
          <target state="translated">Мы готовы использовать библиотеку &lt;code&gt;SharedCode&lt;/code&gt; из наших приложений для Android и iOS.</target>
        </trans-unit>
        <trans-unit id="14edea8060ff3b0350a868b06c73ba61ae235890" translate="yes" xml:space="preserve">
          <source>We are starting with an implementation for the JVM. Let's create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; folder and provide a simple implementation, which delegates to &lt;code&gt;java.util.Base64&lt;/code&gt;:</source>
          <target state="translated">Мы начинаем с реализации JVM. Давайте создадим файл &lt;code&gt;Base64.kt&lt;/code&gt; в &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; и предоставим простую реализацию, которая делегирует &lt;code&gt;java.util.Base64&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b38f2316b8757428d73f475d7c1fadf769b873b4" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; for this tutorial. Both the &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;free and open source&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt; and IntelliJ IDEA Ultimate Edition work for this tutorial. We can download and install both of them from &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; if necessary. The Kotlin plugin is included with IntelliJ IDEA by default, but still, we need to make sure the Kotlin plugin version is 1.3.41 (or newer) in the &lt;em&gt;Settings&lt;/em&gt; or &lt;em&gt;Preferences&lt;/em&gt; dialog, under the Language &amp;amp; Frameworks | Kotlin section.</source>
          <target state="translated">Для этого урока мы используем &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; . Для этого руководства подходят как &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;бесплатная &lt;/a&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;версия&lt;/a&gt; IntelliJ IDEA Community Edition с открытым исходным кодом, так и IntelliJ IDEA Ultimate Edition. При необходимости мы можем загрузить и установить оба из них с &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; . Плагин Kotlin включен в IntelliJ IDEA по умолчанию, но тем не менее, нам нужно убедиться, что версия плагина Kotlin 1.3.41 (или новее) в диалоговом окне &amp;laquo; &lt;em&gt;Настройки&amp;raquo;&lt;/em&gt; или &amp;laquo; &lt;em&gt;Настройки&lt;/em&gt; &amp;raquo; в разделе &amp;laquo;Язык и рамки | Котлин раздел.</target>
        </trans-unit>
        <trans-unit id="55cc632a1ea27e5e64ad2495a5384f62f48dbc86" translate="yes" xml:space="preserve">
          <source>We are using the &lt;code&gt;delay()&lt;/code&gt; function that's like &lt;code&gt;Thread.sleep()&lt;/code&gt;, but better: it &lt;em&gt;doesn't block a thread&lt;/em&gt;, but only suspends the coroutine itself. The thread is returned to the pool while the coroutine is waiting, and when the waiting is done, the coroutine resumes on a free thread in the pool.</source>
          <target state="translated">Мы используем функцию &lt;code&gt;delay()&lt;/code&gt; , похожую на &lt;code&gt;Thread.sleep()&lt;/code&gt; , но лучше: она &lt;em&gt;не блокирует поток&lt;/em&gt; , а только приостанавливает саму сопрограмму. Поток возвращается в пул, пока сопрограмма ожидает, и когда ожидание завершено, сопрограмма возобновляет работу на свободном потоке в пуле.</target>
        </trans-unit>
        <trans-unit id="da1efc61212d59164e482ecaadd2d5e755cb8ec9" translate="yes" xml:space="preserve">
          <source>We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces &lt;em&gt;progressive&lt;/em&gt; compiler mode, which can be enabled by passing the argument &lt;code&gt;-progressive&lt;/code&gt; to the compiler.</source>
          <target state="translated">Мы считаем, что многие пользователи могут использовать гораздо более быстрый цикл, когда критические исправления ошибок компилятора поступают немедленно, что делает код более безопасным и правильным. Итак, Kotlin 1.3 вводит &lt;em&gt;прогрессивный&lt;/em&gt; режим компилятора, который можно включить, передав компилятору аргумент &lt;code&gt;-progressive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e996e5615a264af995c203eaebe6185c018bf0a" translate="yes" xml:space="preserve">
          <source>We believe that the words &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</source>
          <target state="translated">Мы считаем, что слова &lt;strong&gt;in&lt;/strong&gt; и &lt;strong&gt;out&lt;/strong&gt; объясняют сами себя (поскольку они уже довольно давно успешно используются в C #), поэтому упомянутая выше мнемоника на самом деле не нужна, и ее можно перефразировать для более высокой цели:</target>
        </trans-unit>
        <trans-unit id="a4b5a076e237cd86b9569bc0bd72070895b09bdf" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;lib.exe&lt;/code&gt; from the toolchain to generate the static library wrapper &lt;code&gt;libnative.lib&lt;/code&gt; that automates the DLL usage from the code:</source>
          <target state="translated">Мы вызываем &lt;code&gt;lib.exe&lt;/code&gt; из инструментальной цепочки, чтобы сгенерировать статическую библиотеку &lt;code&gt;libnative.lib&lt;/code&gt; , которая автоматизирует использование DLL из кода:</target>
        </trans-unit>
        <trans-unit id="b380a7bf1b634600b0c261666fb452d97fe21714" translate="yes" xml:space="preserve">
          <source>We call Kotlin classes directly from Objective-C code. A Kotlin &lt;code&gt;object&lt;/code&gt; has the class method function &lt;code&gt;object&lt;/code&gt;, which allows us to get the only instance of the object and to call &lt;code&gt;Object&lt;/code&gt; methods on it. The widespread pattern is used to create an instance of the &lt;code&gt;Clazz&lt;/code&gt; class. We call the &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; on Objective-C. We may also use &lt;code&gt;[DemoClazz new]&lt;/code&gt; for constructors without parameters. Global declarations from the Kotlin sources are scoped under the &lt;code&gt;DemoLibKt&lt;/code&gt; class in Objective-C. All methods are turned into class methods of that class. The &lt;code&gt;strings&lt;/code&gt; function is turned into &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; function in Objective-C, we can pass &lt;code&gt;NSString&lt;/code&gt; directly to it. The return is visible as &lt;code&gt;NSString&lt;/code&gt; too.</source>
          <target state="translated">Мы вызываем классы Kotlin прямо из кода Objective-C. Котлин &lt;code&gt;object&lt;/code&gt; имеет метод класса функции &lt;code&gt;object&lt;/code&gt; , что позволяет получить только экземпляр объекта и вызвать &lt;code&gt;Object&lt;/code&gt; методы на него. Распространенный шаблон используется для создания экземпляра класса &lt;code&gt;Clazz&lt;/code&gt; . Мы вызываем &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; на Objective-C. Мы также можем использовать &lt;code&gt;[DemoClazz new]&lt;/code&gt; для конструкторов без параметров. Глобальные объявления из исходных &lt;code&gt;DemoLibKt&lt;/code&gt; классом DemoLibKt в Objective-C. Все методы превращаются в методы класса этого класса. Функция &lt;code&gt;strings&lt;/code&gt; превращена в &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; в Objective-C, мы можем передать &lt;code&gt;NSString&lt;/code&gt; напрямую ей. Возврат также отображается как &lt;code&gt;NSString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6efbfc50d097338c67f6c25e5a2530e00802bbf1" translate="yes" xml:space="preserve">
          <source>We can also check a value for being &lt;em&gt;in&lt;/em&gt; or &lt;em&gt;!in&lt;/em&gt; a &lt;a href=&quot;ranges&quot;&gt;range&lt;/a&gt; or a collection:</source>
          <target state="translated">Мы также можем проверить значение быть &lt;em&gt;в&lt;/em&gt; или &lt;em&gt;в!&lt;/em&gt; В &lt;a href=&quot;ranges&quot;&gt;диапазоне&lt;/a&gt; или коллекции:</target>
        </trans-unit>
        <trans-unit id="6d48b261007df82564fff9e248b32f0b0877a7db" translate="yes" xml:space="preserve">
          <source>We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be71c4616ae57b989081464748078b992e6a499b" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; option.</source>
          <target state="translated">Мы также можем увидеть, как мы можем определить, хотим ли мы, чтобы компилятор генерировал для нас исходные карты, указав это с помощью опции &lt;code&gt;sourceMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db36be1716cde1f09b5bb491a1d29f546a1af582" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; parameter.</source>
          <target state="translated">Мы также можем увидеть, как мы можем определить, хотим ли мы, чтобы компилятор генерировал для нас исходные карты, указав это через параметр &lt;code&gt;sourceMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5bd60fd46fe6ea1c5b448761b2e310af9a2b34e" translate="yes" xml:space="preserve">
          <source>We can check whether an object conforms to a given type at runtime by using the &lt;code&gt;is&lt;/code&gt; operator or its negated form &lt;code&gt;!is&lt;/code&gt;:</source>
          <target state="translated">Мы можем проверить, соответствует ли объект заданному типу во время выполнения, используя оператор &lt;code&gt;is&lt;/code&gt; или его отрицательную форму &lt;code&gt;!is&lt;/code&gt; Is :</target>
        </trans-unit>
        <trans-unit id="80fca726c567776685be62a6f296ba802e4a0c48" translate="yes" xml:space="preserve">
          <source>We can choose to let &lt;code&gt;MotorVehicle&lt;/code&gt; implement that interface, since it's got the required members - but now we need to mark those members with &lt;code&gt;override&lt;/code&gt;, and we can remove &lt;code&gt;open&lt;/code&gt; since an overridden function is implicitly open:</source>
          <target state="translated">Мы можем позволить &lt;code&gt;MotorVehicle&lt;/code&gt; реализовать этот интерфейс, поскольку у него есть необходимые члены, но теперь нам нужно пометить эти члены &lt;code&gt;override&lt;/code&gt; , и мы можем удалить &lt;code&gt;open&lt;/code&gt; , поскольку переопределенная функция неявно открыта:</target>
        </trans-unit>
        <trans-unit id="b29aa01092a4a2f64bc0e5bf97de56d6e4257337" translate="yes" xml:space="preserve">
          <source>We can click the file reference on the right to navigate directly to the corresponding statement. Alternatively, we can manually switch to the &lt;em&gt;Sources&lt;/em&gt; tab, and find the correct file in the file tree. Navigating to the Kotlin file actually shows us regular Kotlin code (as opposed to minified JavaScript):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df63e38e36909132576c3c502bfc7296d767131" translate="yes" xml:space="preserve">
          <source>We can combine the declarative nature of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;catch&lt;/a&gt; operator with a desire to handle all the exceptions, by moving the body of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; operator into &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; and putting it before the &lt;code&gt;catch&lt;/code&gt; operator. Collection of this flow must be triggered by a call to &lt;code&gt;collect()&lt;/code&gt; without parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab28e12a4329ff5188bb6bb1c34f1f3bf4ce258" translate="yes" xml:space="preserve">
          <source>We can configure the Kotlin compiler option to use any of these. The last option (UMD) will generate UMD and fallback to the other options if one is not available. Currently Kotlin compiler options are per IntelliJ IDEA project as opposed to a Kotlin module.</source>
          <target state="translated">Мы можем настроить компилятор Kotlin на использование любого из них.Последняя опция (UMD)сгенерирует UMD и вернется к другим опциям,если одна из них недоступна.В настоящее время опции компилятора Kotlin для проекта IntelliJ IDEA в отличие от модуля Kotlin.</target>
        </trans-unit>
        <trans-unit id="5b4c1b5549ed7b71f56b6d1ba48bd66bf46537dc" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with &quot;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">Мы можем определять функции асинхронного стиля, которые вызывают &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; и &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; &lt;em&gt;асинхронно,&lt;/em&gt; используя построитель &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;асинхронных&lt;/a&gt; сопрограмм с явной ссылкой на &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; . Мы называем такие функции суффиксом &amp;laquo;Async&amp;raquo;, чтобы подчеркнуть тот факт, что они запускают только асинхронные вычисления, и для получения результата необходимо использовать полученное отложенное значение.</target>
        </trans-unit>
        <trans-unit id="452dc3c84f7cabd350d9558a57e866a1cf25ff79" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecb356b303055242a64963a7b2a1f314c6be1d3" translate="yes" xml:space="preserve">
          <source>We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:</source>
          <target state="translated">Мы можем определить пользовательские аксессуары для объекта недвижимости.Если мы определим пользовательский аксессуар,он будет вызываться каждый раз,когда мы получаем доступ к свойству (это позволяет нам реализовать вычисленное свойство).Вот пример пользовательского геттера:</target>
        </trans-unit>
        <trans-unit id="b31aa9761950ea554c775fecf5e0c018baf882fd" translate="yes" xml:space="preserve">
          <source>We can easily call it directly (&lt;code&gt;isOdd(5)&lt;/code&gt;), but we can also use it as a function type value, e.g. pass it to another function. To do this, we use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">Мы можем легко вызвать его напрямую ( &lt;code&gt;isOdd(5)&lt;/code&gt; ), но мы также можем использовать его как значение типа функции, например, передать его другой функции. Для этого мы используем &lt;code&gt;::&lt;/code&gt; оператор:</target>
        </trans-unit>
        <trans-unit id="ae17c1ca56657ad30866237b96021ef47b3cda29" translate="yes" xml:space="preserve">
          <source>We can explicitly convert a character to an &lt;code&gt;Int&lt;/code&gt; number:</source>
          <target state="translated">Мы можем явно преобразовать символ в число &lt;code&gt;Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d31ec9f07f4bc208cadad8ae2ec0b5f65d7cdf75" translate="yes" xml:space="preserve">
          <source>We can explicitly return a value from the lambda using the &lt;a href=&quot;returns#return-at-labels&quot;&gt;qualified return&lt;/a&gt; syntax. Otherwise, the value of the last expression is implicitly returned.</source>
          <target state="translated">Мы можем явно вернуть значение из лямбды, используя &lt;a href=&quot;returns#return-at-labels&quot;&gt;квалифицированный&lt;/a&gt; синтаксис возврата . В противном случае неявно возвращается значение последнего выражения.</target>
        </trans-unit>
        <trans-unit id="5af6b3dce006afd131588be4e84caa508a65cc20" translate="yes" xml:space="preserve">
          <source>We can import either a single name, e.g.</source>
          <target state="translated">Мы можем импортировать либо одно имя,например.</target>
        </trans-unit>
        <trans-unit id="8a9f3b72eb46629a298e0a057eccfdabab01c204" translate="yes" xml:space="preserve">
          <source>We can install &lt;code&gt;kotlinizer&lt;/code&gt; to the default repository:</source>
          <target state="translated">Мы можем установить &lt;code&gt;kotlinizer&lt;/code&gt; в репозиторий по умолчанию:</target>
        </trans-unit>
        <trans-unit id="6d3bad56e3c4235f442b8c993bfc65c9b26cdc43" translate="yes" xml:space="preserve">
          <source>We can now add our first Kotlin source code file and IntelliJ IDEA will prompt us to configure the project for Kotlin. On doing so, we should select as target JavaScript</source>
          <target state="translated">Теперь мы можем добавить наш первый файл исходного кода Kotlin,и IntelliJ IDEA попросит нас настроить проект для Kotlin.При этом мы должны выбрать в качестве целевого JavaScript.</target>
        </trans-unit>
        <trans-unit id="dc96081c653c84bb3dd3b5b83bfc524f3cd03b65" translate="yes" xml:space="preserve">
          <source>We can now do this (but it's still possible to call the function the normal way):</source>
          <target state="translated">Теперь мы можем это сделать (но все равно можно вызвать функцию обычным способом):</target>
        </trans-unit>
        <trans-unit id="2028680260413907a6ff455452315ba4c9be7fe7" translate="yes" xml:space="preserve">
          <source>We can now start debugging our program. For example, we can set a breakpoint by clicking on one of the line numbers. The developer tools even support setting breakpoints within a statement. As with regular JavaScript code, any set breakpoints will persist across page reloads. This also makes it possible to debug Kotlin's main method which is executed when the script is first loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb97bda68a25be3b25091829fa426075294c2d71" translate="yes" xml:space="preserve">
          <source>We can now use any of the standard Gradle tasks for Spring Boot to run the application. As such, running</source>
          <target state="translated">Теперь мы можем использовать любую из стандартных задач Gradle для Spring Boot для запуска приложения.Таким образом,запуск</target>
        </trans-unit>
        <trans-unit id="c6898463443208b858c46602bd14f4fe18a2e216" translate="yes" xml:space="preserve">
          <source>We can override a non-abstract open member with an abstract one</source>
          <target state="translated">Мы можем переопределить неабстрактного открытого участника абстрактным членом.</target>
        </trans-unit>
        <trans-unit id="443dbeb7b5959da838f042d1c795f241e1156ec7" translate="yes" xml:space="preserve">
          <source>We can replace &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; with &lt;code&gt;Thread.sleep&lt;/code&gt; in the body of &lt;code&gt;simple&lt;/code&gt;'s &lt;code&gt;flow { ... }&lt;/code&gt; and see that the main thread is blocked in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8ade084fb51f7b34b89fae3c572fe0de063884" translate="yes" xml:space="preserve">
          <source>We can run the compiler without parameters to have an interactive shell. We can type any valid Kotlin code and see the results.</source>
          <target state="translated">Мы можем запустить компилятор без параметров,чтобы иметь интерактивную оболочку.Мы можем набрать любой корректный код Kotlin и посмотреть результаты.</target>
        </trans-unit>
        <trans-unit id="f29622b395465874ab1409644634bdf5bd547c3e" translate="yes" xml:space="preserve">
          <source>We can see how the API is created. To start with, we need to initialize the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure. Let's take a look at the latest part of the &lt;code&gt;libnative_api.h&lt;/code&gt; for this:</source>
          <target state="translated">Мы видим, как создается API. Для начала нам нужно инициализировать структуру &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; . Давайте посмотрим на последнюю часть &lt;code&gt;libnative_api.h&lt;/code&gt; для этого:</target>
        </trans-unit>
        <trans-unit id="3d6f52d4243822ccee088838c7cbe381743f9a4c" translate="yes" xml:space="preserve">
          <source>We can see the completion cause is not null, because the flow was aborted due to downstream exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27d56a268fbe45c1d0688c4606abf60011997ba" translate="yes" xml:space="preserve">
          <source>We can simply refer to any class or member function inside our node.js code by simply importing the module using &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">Мы можем просто сослаться на любой класс или функцию-член внутри нашего кода node.js, просто импортировав модуль с помощью &lt;code&gt;require&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="831ccd2e7105b549d27fa757caf8f798b465ce95" translate="yes" xml:space="preserve">
          <source>We can simulate custom infix operations by using &lt;a href=&quot;functions#infix-notation&quot;&gt;infix function calls&lt;/a&gt;.</source>
          <target state="translated">Мы можем моделировать пользовательские инфиксные операции, используя &lt;a href=&quot;functions#infix-notation&quot;&gt;вызовы инфиксных функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="509f912bd5b5b6af65e5240f9ef362cc1a5f0b3f" translate="yes" xml:space="preserve">
          <source>We can start by creating a library file in Kotlin and save it as &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">Мы можем начать с создания файла библиотеки в Kotlin и сохранить его как &lt;code&gt;hello.kt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89f8fe8ceb180f0a0bdf079538aa483abb6121b4" translate="yes" xml:space="preserve">
          <source>We can then do this:</source>
          <target state="translated">Тогда мы сможем это сделать:</target>
        </trans-unit>
        <trans-unit id="ce9fbf3c0deb149f881d772488fa422e85d659ce" translate="yes" xml:space="preserve">
          <source>We can tune how tests are executed in Kotlin/JS by adjusting the settings available in the &lt;code&gt;testTask&lt;/code&gt; block in our &lt;code&gt;build.gradle.kts&lt;/code&gt;. For example, using the Karma test runner together with a headless instance of Chrome and an instance of Firefox looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16a2933e2edce96547337fb1fedcb97e299ea34" translate="yes" xml:space="preserve">
          <source>We can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;buffer&lt;/a&gt; operator on a flow to run emitting code of the &lt;code&gt;simple&lt;/code&gt; flow concurrently with collecting code, as opposed to running them sequentially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a4cc600951e3a005f1c78d3f5d6ddad7aa6cbe" translate="yes" xml:space="preserve">
          <source>We can use arbitrary expressions (not only constants) as branch conditions</source>
          <target state="translated">В качестве условий ветви можно использовать произвольные выражения (а не только константы)</target>
        </trans-unit>
        <trans-unit id="1d0515ada05fe82e395d7a6707b6351170a6e35a" translate="yes" xml:space="preserve">
          <source>We can use classes or functions from a Kotlin project, in our scratches and worksheets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b191724788dd23ede6b8c2149628b7a54092d58" translate="yes" xml:space="preserve">
          <source>We can use explicit conversions to widen numbers</source>
          <target state="translated">Мы можем использовать явные преобразования для расширения чисел</target>
        </trans-unit>
        <trans-unit id="dfb0038c9e10b5e80574a36666be3c3e86aa4353" translate="yes" xml:space="preserve">
          <source>We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca14a2211b4e71b478b08b4747bfb20c5dc2a24" translate="yes" xml:space="preserve">
          <source>We continue to explore more C language types and their representation in Kotlin/Native in our other tutorials:</source>
          <target state="translated">Мы продолжаем изучать больше типов языка C и их представление в Kotlin/Native в наших других учебниках:</target>
        </trans-unit>
        <trans-unit id="51b6f004886664d749f4d2984398143458f52375" translate="yes" xml:space="preserve">
          <source>We could call this using default arguments:</source>
          <target state="translated">Можно назвать это использованием аргументов по умолчанию:</target>
        </trans-unit>
        <trans-unit id="8ae10259ccef551da0909b6299a0fa1b0a4f1215" translate="yes" xml:space="preserve">
          <source>We could do a similar thing with contravariant projection by using &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">Мы могли бы сделать то же самое с контравариантной проекцией, используя &lt;code&gt;in&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39a9864b239884664ddf63f83dbaeb179ea24a10" translate="yes" xml:space="preserve">
          <source>We could use the same means of synchronization that are applicable to threads (a &lt;code&gt;CountDownLatch&lt;/code&gt; is what crosses my mind in this case), but let's take a safer and cleaner path.</source>
          <target state="translated">Мы могли бы использовать те же средства синхронизации, которые применимы к потокам ( в данном случае &lt;code&gt;CountDownLatch&lt;/code&gt; приходит в голову CountDownLatch ), но давайте выберем более безопасный и чистый путь.</target>
        </trans-unit>
        <trans-unit id="d12b57fa3f5ee09d20d2af80c6064fa21722785e" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">Мы рассмотрели основы настройки проекта, совместимого с IDE, с помощью Gradle в учебнике &lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin / Native Application&lt;/a&gt; . Пожалуйста, проверьте его, если вы ищете подробные первые шаги и инструкции о том, как запустить новый проект Kotlin / Native и открыть его в IntelliJ IDEA. В этом руководстве мы рассмотрим расширенные возможности взаимодействия с C для Kotlin / Native и &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;многоплатформенных&lt;/a&gt; сборок с Gradle.</target>
        </trans-unit>
        <trans-unit id="34c7674c59bff58842f8120c227b39dfc459b5e2" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1e2f897849388e9b5afd5f5e40ff3ed5d9341c" translate="yes" xml:space="preserve">
          <source>We create &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">Создаем &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; файл сборки Gradle со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="d792e0e9b2d61d7c507d6ac3c55fb78219ae3d1b" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;lib.h&lt;/code&gt; file to see how C functions are mapped into Kotlin:</source>
          <target state="translated">Мы создаем файл &lt;code&gt;lib.h&lt;/code&gt; , чтобы увидеть, как функции C отображаются в Kotlin:</target>
        </trans-unit>
        <trans-unit id="b48d0f7550a4bac04ad5285d58e805e5af18955b" translate="yes" xml:space="preserve">
          <source>We create a similar implementation file (and missing directories) for the iOS target in the &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">Мы создаем аналогичный файл реализации (и отсутствующие каталоги) для цели iOS в &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="785942d151a588aee24ed9a38ee1d8176b8dc181" translate="yes" xml:space="preserve">
          <source>We create the &lt;code&gt;hello.kt&lt;/code&gt; file with the library contents:</source>
          <target state="translated">Мы создаем &lt;code&gt;hello.kt&lt;/code&gt; файл библиотеки содержимым:</target>
        </trans-unit>
        <trans-unit id="fcb050d7cd97c1f800f9df98029b55284f1e77b7" translate="yes" xml:space="preserve">
          <source>We decided to productize this idea, but it hasn't reached the final shape yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed76b8d0d9018634906744837677e15921589b" translate="yes" xml:space="preserve">
          <source>We declare the generic type parameter before the function name for it to be available in the receiver type expression. See &lt;a href=&quot;generics&quot;&gt;Generic functions&lt;/a&gt;.</source>
          <target state="translated">Мы объявляем параметр универсального типа перед именем функции, чтобы он был доступен в выражении типа получателя. См. &lt;a href=&quot;generics&quot;&gt;Общие функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="908a5325e4c7755c51db166d96c5a188313020b0" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t currently support sharing a source set for these combinations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e038eb8a21b3199cc32241632b06a3909918bfe9" translate="yes" xml:space="preserve">
          <source>We don't have to annotate the &lt;code&gt;HTML&lt;/code&gt; or &lt;code&gt;Head&lt;/code&gt; classes with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; because their superclass is already annotated:</source>
          <target state="translated">Нам не нужно аннотировать классы &lt;code&gt;HTML&lt;/code&gt; или &lt;code&gt;Head&lt;/code&gt; с помощью &lt;code&gt;@HtmlTagMarker&lt;/code&gt; , потому что их суперкласс уже аннотирован:</target>
        </trans-unit>
        <trans-unit id="0d7e408c93316e02af7f4048c236f0b36f5b8539" translate="yes" xml:space="preserve">
          <source>We encourage you to try out the new Kotlin/JVM backend, which is currently in Alpha, and to file any issues and feature requests to our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;. This will help us to unify the compiler pipelines and bring compiler extensions like Jetpack Compose to the Kotlin community more quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd6ede6c8f3bf00110a9f180aa0db3e0e10e52" translate="yes" xml:space="preserve">
          <source>We encourage you to use our new &lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt; and &lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt; backends, which are currently in Alpha, and share your feedback with us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3df53e494bf93b03698e74de62415d2b98fbd8" translate="yes" xml:space="preserve">
          <source>We evolve the Kotlin Standard Library (kotlin-stdlib) for stable platforms according to the principles stated above. Changes to the contracts for its API undergo the same procedures as changes in the language itself.</source>
          <target state="translated">Мы разрабатываем Стандартную библиотеку Котлина (kotlin-stdlib)для стабильных платформ в соответствии с вышеизложенными принципами.Изменения в контрактах на ее API проходят те же процедуры,что и изменения в самом языке.</target>
        </trans-unit>
        <trans-unit id="a2535fe7404df5a6eb12c3a3917ab80b4135dbff" translate="yes" xml:space="preserve">
          <source>We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a &lt;em&gt;data class&lt;/em&gt; and is marked as &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">Мы часто создаем классы, основная цель которых - хранить данные. В таком классе некоторые стандартные функциональные возможности и служебные функции часто можно получить механически из данных. В Kotlin это называется &lt;em&gt;классом данных&lt;/em&gt; и помечается как &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a30f61b55b7b7e943a650a6aabc19b05c3bdf8d" translate="yes" xml:space="preserve">
          <source>We get only numbers up to 3 and a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; after trying to emit number 4:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aab8ad063fec7c5b2558d6a061d3a136f3a35e" translate="yes" xml:space="preserve">
          <source>We get quite a different output, where a line is printed at each emission from either &lt;code&gt;nums&lt;/code&gt; or &lt;code&gt;strs&lt;/code&gt; flows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee091486d809b243b18a19355b403e23f19e065" translate="yes" xml:space="preserve">
          <source>We have significantly reworked the API for JSON serialization to make it more consistent and easier to use. From now on, we'll continue developing the JSON serialization API in a backward-compatible manner. However, if you have used previous versions of it, you'll need to rewrite some of your code when migrating to 1.0.0-RC. To help you with this, we also offer the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin Serialization Guide&lt;/a&gt; &amp;ndash; the complete set of documentation for &lt;code&gt;kotlinx.serialization&lt;/code&gt;. It will guide you through the process of using the most important features and it can help you address any issues that you might face.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1094efa9f8fd00ffe04a3c7c86c1ceab68f5986d" translate="yes" xml:space="preserve">
          <source>We make sure to document precisely which subcomponents are not stable. We also do our best to warn users where possible and ask to opt in explicitly to avoid accidental usages of features that have not been released as stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a128ace07ce2a614969d8901fa6d436be396c723" translate="yes" xml:space="preserve">
          <source>We manage a lifecycle of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that is tied to the lifecycle of our activity. &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as default dispatcher:</source>
          <target state="translated">Мы управляем жизненным циклом наших сопрограмм, создавая экземпляр &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope,&lt;/a&gt; который привязан к жизненному циклу нашей деятельности. &lt;code&gt;CoroutineScope&lt;/code&gt; экземпляр может быть создан &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope ()&lt;/a&gt; или &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope ()&lt;/a&gt; фабричных функций. Первый создает область общего назначения, а второй создает область для приложений пользовательского интерфейса и использует &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main в&lt;/a&gt; качестве диспетчера по умолчанию:</target>
        </trans-unit>
        <trans-unit id="ccd2d1dce53a36cd421422934713d352fc3aea2f" translate="yes" xml:space="preserve">
          <source>We manage the lifecycles of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; tied to the lifecycle of our activity. A &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as the default dispatcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f8eb551efabdb4e2888f30edf606cbdfff7bc8" translate="yes" xml:space="preserve">
          <source>We may find the whole sources from that tutorial on &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">Мы можем найти полные исходники из этого руководства на &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="990e3fee35a9a6ae47d7273521920489a64503a8" translate="yes" xml:space="preserve">
          <source>We may include all declarations directly into the &lt;code&gt;.def&lt;/code&gt; file after a &lt;code&gt;---&lt;/code&gt; separator. It can be helpful to include macros or other C defines into the code generated by the &lt;code&gt;cinterop&lt;/code&gt; tool. Method bodies are compiled and fully included into the binary too. Let's use that feature to have a runnable example without a need for a C compiler. To implement that, we need to add implementations to the C functions from the &lt;code&gt;lib.h&lt;/code&gt; file, and place these functions into a &lt;code&gt;.def&lt;/code&gt; file. We will have the following &lt;code&gt;interop.def&lt;/code&gt; result:</source>
          <target state="translated">Мы можем включать все объявления прямо в файл &lt;code&gt;.def&lt;/code&gt; после разделителя &lt;code&gt;---&lt;/code&gt; . Может быть полезно включить макросы или другие определения языка C в код, созданный инструментом &lt;code&gt;cinterop&lt;/code&gt; . Тела методов также скомпилированы и полностью включены в двоичный файл. Давайте воспользуемся этой возможностью, чтобы получить работоспособный пример без компилятора C. Чтобы реализовать это, нам нужно добавить реализации для функций C из файла &lt;code&gt;lib.h&lt;/code&gt; и поместить эти функции в файл &lt;code&gt;.def&lt;/code&gt; . У нас будет следующий результат &lt;code&gt;interop.def&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb703fd0c61569a76d50c3b521794196aa1b8db0" translate="yes" xml:space="preserve">
          <source>We need to assign the &lt;code&gt;id&lt;/code&gt; to the &lt;code&gt;TextView&lt;/code&gt; control of our activity to access it from the code. Let's patch the &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; file (the name may be different if we changed it in the new project wizard) and add several more attributes to the &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Нам необходимо присвоить &lt;code&gt;id&lt;/code&gt; для &lt;code&gt;TextView&lt;/code&gt; контроля нашей деятельности для доступа к нему из кода. Давайте исправим файл &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; (имя может быть другим, если мы изменили его в мастере нового проекта) и добавим еще несколько атрибутов в элемент &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6b59ffea87e48a8dddabef126cfdaa1e77887d03" translate="yes" xml:space="preserve">
          <source>We need to configure an Xcode project to use our framework. The configuration depends on the target platform.</source>
          <target state="translated">Нам нужно настроить проект Xcode для использования нашего фреймворка.Конфигурация зависит от целевой платформы.</target>
        </trans-unit>
        <trans-unit id="8c3349f607cc5a810a187a7d773102a89d925fbd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial contains more explanations for that step. Let's assume, we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">Нам нужен компилятор Kotlin на наших машинах. &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;Базовый Котлин Применение&lt;/a&gt; учебник содержит больше объяснений этого шага. Предположим, у нас есть консоль, где &lt;code&gt;kotlinc-native&lt;/code&gt; команды kotlinc-native , &lt;code&gt;cinterop&lt;/code&gt; и &lt;code&gt;klib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="027177ad8c50f7e3918b01a86e99731d536a90cd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial covers that step in details. Let's assume that we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">Нам нужен компилятор Kotlin на наших машинах. В руководстве по &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;базовому приложению Kotlin&lt;/a&gt; этот шаг подробно рассматривается. Предположим, что у нас есть консоль, где &lt;code&gt;kotlinc-native&lt;/code&gt; команды kotlinc-native , &lt;code&gt;cinterop&lt;/code&gt; и &lt;code&gt;klib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c043e1a723b8be73d20799e39d49b6268885069" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial explains the steps in detail. Let's assume we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">Нам нужен компилятор Kotlin на наших машинах. В руководстве по &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;базовому приложению Kotlin&lt;/a&gt; подробно описаны шаги. Предположим, у нас есть консоль, на которой &lt;code&gt;kotlinc-native&lt;/code&gt; команды kotlinc-native , &lt;code&gt;cinterop&lt;/code&gt; и &lt;code&gt;klib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab5784dabb9482fdb660b478b956f2503674f995" translate="yes" xml:space="preserve">
          <source>We need to refresh the Gradle Project settings to apply these changes. Click on the &lt;code&gt;Sync Now&lt;/code&gt; link or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the refresh action from the context menu on the root Gradle project.</source>
          <target state="translated">Нам нужно обновить настройки Gradle Project, чтобы применить эти изменения. Щелкните ссылку &amp;laquo; &lt;code&gt;Sync Now&lt;/code&gt; или используйте окно инструмента &lt;em&gt;Gradle&lt;/em&gt; и щелкните действие обновления из контекстного меню корневого проекта Gradle.</target>
        </trans-unit>
        <trans-unit id="e0a25a2206a6fb40af56c49d12ab94e8fd653881" translate="yes" xml:space="preserve">
          <source>We need to supply the right Framework out of those four depending on the selected target in the Xcode project. It depends on the target configuration selected in Xcode. Also, we'd like to make Xcode compile the Framework for us before the build. We need to include the additional task to the end of the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle file:</source>
          <target state="translated">Нам нужно предоставить правильный Framework из этих четырех в зависимости от выбранной цели в проекте Xcode. Это зависит от целевой конфигурации, выбранной в Xcode. Кроме того, мы хотели бы, чтобы Xcode скомпилировал для нас Framework перед сборкой. Нам нужно включить дополнительную задачу в конец файла Gradle &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27d58e7d45f1a7f3fbb5989a56fe0b4132ca9bca" translate="yes" xml:space="preserve">
          <source>We now define the &lt;em&gt;GreetingController&lt;/em&gt; which serves requests of the form &lt;em&gt;/greeting?name={value}&lt;/em&gt; and returns a JSON object representing an instance of &lt;em&gt;Greeting&lt;/em&gt;</source>
          <target state="translated">Теперь мы определяем &lt;em&gt;GreetingController,&lt;/em&gt; который обслуживает запросы формы &lt;em&gt;/ приветствия? Name = {value}&lt;/em&gt; и возвращает объект JSON, представляющий экземпляр &lt;em&gt;Greeting&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5172c1ac8d2fad040b4dc376d3d08d8d24a279b3" translate="yes" xml:space="preserve">
          <source>We now have a local variable &lt;code&gt;number&lt;/code&gt; whose value is 42 and whose type is &lt;code&gt;Int&lt;/code&gt; (because that's the type of the literal &lt;code&gt;42&lt;/code&gt;), and another local variable &lt;code&gt;message&lt;/code&gt; whose value is &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; and whose type is &lt;code&gt;String&lt;/code&gt;. Subsequent usages of the variable must use only the name, not &lt;code&gt;var&lt;/code&gt;:</source>
          <target state="translated">Теперь у нас есть локальное переменное &lt;code&gt;number&lt;/code&gt; , значение которого 42 и чей тип &lt;code&gt;Int&lt;/code&gt; (потому что это тип буквальных &lt;code&gt;42&lt;/code&gt; ), а другое локальное переменное &lt;code&gt;message&lt;/code&gt; , значение которого &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; и тип которого является &lt;code&gt;String&lt;/code&gt; . При последующем использовании переменной должно использоваться только имя, а не &lt;code&gt;var&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dfb0f090289673dd1e3bce3bdb08b454f3c07da9" translate="yes" xml:space="preserve">
          <source>We now need an HTML page to load the code, so we'll create a file called &lt;code&gt;index.html&lt;/code&gt;. If you want more information on how Kotlin compiles to JavaScript and the output generated, check out the &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; tutorial.</source>
          <target state="translated">Теперь нам нужна HTML-страница для загрузки кода, поэтому мы создадим файл с именем &lt;code&gt;index.html&lt;/code&gt; . Если вам нужна дополнительная информация о том, как Kotlin компилируется в JavaScript и сгенерированы выходные данные, ознакомьтесь с учебником &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae2c927826795d420c34c1b15ddab31d41644c0" translate="yes" xml:space="preserve">
          <source>We observed that annotating your code almost hasn't changed when you switched to Kotlin. Now let's see what changes should be made to the build script.</source>
          <target state="translated">Мы заметили,что аннотация вашего кода почти не изменилась,когда вы переключились на Котлин.Теперь посмотрим,какие изменения следует внести в скрипт сборки.</target>
        </trans-unit>
        <trans-unit id="8ffa6d76c8e1bf7a1c5dd4d42cd1a6d0515ef81b" translate="yes" xml:space="preserve">
          <source>We open Xcode and select &lt;em&gt;Create a new Xcode project&lt;/em&gt; option. In the dialog, we choose the iOS target and select the &lt;em&gt;Single View App&lt;/em&gt;. Fill the next page with defaults, and use the &lt;code&gt;KotlinIOS&lt;/code&gt; (or something else) as the &lt;em&gt;Product Name&lt;/em&gt;. Let's select Swift as the language (it is possible to use Objective-C too). We should instruct Xcode to place the project into the &lt;code&gt;native&lt;/code&gt; folder under our project, later we will use relative paths in the configuration files.</source>
          <target state="translated">Мы открываем Xcode и выбираем опцию &lt;em&gt;Create a new Xcode project&lt;/em&gt; . В диалоговом окне мы выбираем цель iOS и выбираем приложение для &lt;em&gt;единого просмотра&lt;/em&gt; . Заполните следующую страницу значениями по умолчанию и используйте &lt;code&gt;KotlinIOS&lt;/code&gt; (или что-то еще) в качестве &lt;em&gt;названия продукта&lt;/em&gt; . Выберем Swift в качестве языка (можно использовать Objective-C). Мы должны указать Xcode поместить проект в &lt;code&gt;native&lt;/code&gt; папку в нашем проекте, позже мы будем использовать относительные пути в файлах конфигурации.</target>
        </trans-unit>
        <trans-unit id="a2530cc820c7c771c8fc29995c153d4bf24643ea" translate="yes" xml:space="preserve">
          <source>We provide &lt;em&gt;all-open&lt;/em&gt; plugin support both for Gradle and Maven with the complete IDE integration.</source>
          <target state="translated">Мы обеспечиваем &lt;em&gt;полностью открытую&lt;/em&gt; поддержку плагинов как для Gradle, так и для Maven с полной интеграцией IDE.</target>
        </trans-unit>
        <trans-unit id="8737e3b3a5c293a6cb9372838dbc9870d668570a" translate="yes" xml:space="preserve">
          <source>We provide the -language-version and -api-version flags that make a new version emulate the behaviour of an old one, for compatibility purposes. Normally, at least one previous version is supported. This effectively leaves a time span of two full feature release cycles for migration (which usually amounts to about two years). Using an older kotlin-stdlib or kotlin-reflect with a newer compiler without specifying compatibility flags is not recommended, and the compiler will report a &lt;a href=&quot;compatibility-modes&quot;&gt;warning&lt;/a&gt; when this happens.</source>
          <target state="translated">Мы предоставляем флаги -language-version и -api-version, которые заставляют новую версию имитировать поведение старой в целях совместимости. Обычно поддерживается как минимум одна предыдущая версия. Это фактически оставляет для миграции промежуток времени в два полноценных цикла выпуска функций (который обычно составляет около двух лет). Использование более старого kotlin-stdlib или kotlin-reflection с новым компилятором без указания флагов совместимости не рекомендуется, и компилятор сообщит &lt;a href=&quot;compatibility-modes&quot;&gt;предупреждение,&lt;/a&gt; когда это произойдет.</target>
        </trans-unit>
        <trans-unit id="e91c098e8aab839aef30caa8d584e2cae0663d0e" translate="yes" xml:space="preserve">
          <source>We qualified the type parameter with the &lt;code&gt;reified&lt;/code&gt; modifier, now it&amp;rsquo;s accessible inside the function, almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like &lt;code&gt;!is&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; are working now. Also, we can call it as mentioned above: &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">Мы уточнили параметр типа с помощью модификатора &lt;code&gt;reified&lt;/code&gt; , теперь он доступен внутри функции, как если бы это был обычный класс. Поскольку функция встроена, отражение не требуется, теперь работают обычные операторы, такие как &lt;code&gt;!is&lt;/code&gt; Is и &lt;code&gt;as&lt;/code&gt; . Кроме того, мы можем назвать его, как указано выше: &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7840bc09de48b5cc97bf23a9db5d15e17420d9fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;code&gt;with&lt;/code&gt; for calling functions on the context object without providing the lambda result. In the code, &lt;code&gt;with&lt;/code&gt; can be read as &amp;ldquo;&lt;em&gt;with this object, do the following.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">Мы рекомендуем &lt;code&gt;with&lt;/code&gt; для вызова функций объекта контекста без предоставления лямбда-результата. В коде &lt;code&gt;with&lt;/code&gt; можно читать как &amp;laquo; &lt;em&gt;с этим объектом выполните следующие действия. &lt;/em&gt;&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="ee965fb5c972bf1b84c2210f41280ef6b6a7b02d" translate="yes" xml:space="preserve">
          <source>We recommend that you use expected and actual declarations only for Kotlin declarations that have platform-specific dependencies. It is better to implement as much functionality as possible in the shared module even if doing so takes more time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55acd20cd8a96e52ff245292bd60de85bd57b76c" translate="yes" xml:space="preserve">
          <source>We see from these definitions that the Kotlin object &lt;code&gt;Object&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Object&lt;/code&gt;, and &lt;code&gt;Clazz&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt;. Both structs contain nothing but the &lt;code&gt;pinned&lt;/code&gt; field with a pointer, the field type &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is defined as &lt;code&gt;void*&lt;/code&gt; above.</source>
          <target state="translated">Из этих определений следует, что объект Котлин &lt;code&gt;Object&lt;/code&gt; переходит в &lt;code&gt;libnative_kref_example_Object&lt;/code&gt; и &lt;code&gt;Clazz&lt;/code&gt; переходит в &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt; . Обе структуры не содержат ничего, кроме &lt;code&gt;pinned&lt;/code&gt; поля с указателем, тип поля &lt;code&gt;libnative_KNativePtr&lt;/code&gt; определен как &lt;code&gt;void*&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="e6899aab23e93f36bbb67e40e2a50b9ebcd2d51b" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;cinterop&lt;/code&gt; generated wrapper types for our &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types. For &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; type declarations in C, we have the Kotlin classes &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; generated respectively. The wrappers inherit from the &lt;code&gt;CStructVar&lt;/code&gt; base class and declare all fields as Kotlin properties. It uses &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; to represent a by-value structure parameter and &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; to represent passing a pointer to a structure or a union.</source>
          <target state="translated">Мы видим, что &lt;code&gt;cinterop&lt;/code&gt; сгенерировал типы-оболочки для наших типов &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;union&lt;/code&gt; . Для &lt;code&gt;MyStruct&lt;/code&gt; типов MyStruct и &lt;code&gt;MyUnion&lt;/code&gt; в C у нас есть классы Kotlin &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; , созданные соответственно. &lt;code&gt;CStructVar&lt;/code&gt; наследуются от базового класса CStructVar и объявляют все поля как свойства Kotlin. Он использует &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; для представления параметра структуры по значению и &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; для представления передачи указателя на структуру или объединение.</target>
        </trans-unit>
        <trans-unit id="f057034bf9d5d678ae656c6371649fbb0395e9c1" translate="yes" xml:space="preserve">
          <source>We see that Kotlin &lt;code&gt;String&lt;/code&gt; and Objective-C &lt;code&gt;NSString*&lt;/code&gt; are mapped transparently. Similarly, &lt;code&gt;Unit&lt;/code&gt; type from Kotlin is mapped to &lt;code&gt;void&lt;/code&gt;. We see primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped into &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; types, as shown in the table &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;above&lt;/a&gt;. Both higher order functions &lt;code&gt;acceptFunF&lt;/code&gt; and &lt;code&gt;supplyFun&lt;/code&gt; are included, and accept Objective-C blocks.</source>
          <target state="translated">Мы видим, что Kotlin &lt;code&gt;String&lt;/code&gt; и Objective-C &lt;code&gt;NSString*&lt;/code&gt; отображаются прозрачно. Точно так же тип &lt;code&gt;Unit&lt;/code&gt; из Kotlin отображается на &lt;code&gt;void&lt;/code&gt; . Мы видим, что примитивные типы отображаются напрямую. Примитивные типы, не допускающие значения NULL, отображаются прозрачно. Примитивные типы, допускающие значение NULL, отображаются в типы &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; , как показано в таблице &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;выше&lt;/a&gt; . Обе функции более высокого порядка &lt;code&gt;acceptFunF&lt;/code&gt; и &lt;code&gt;supplyFun&lt;/code&gt; включены и принимают блоки Objective-C.</target>
        </trans-unit>
        <trans-unit id="35a16af72746a4a3a02afc71cbee1736ad51d23a" translate="yes" xml:space="preserve">
          <source>We see that our function typedef from C has been turned into Kotlin &lt;code&gt;typealias&lt;/code&gt;. It uses &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; type to represent the pointer parameters, and &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; to represent the function signature. There is an &lt;code&gt;invoke&lt;/code&gt; operator extension function available for all &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; types, so that it is possible to call it as we would call any other function in Kotlin.</source>
          <target state="translated">Мы видим, что наша функция typedef из C была преобразована в &lt;code&gt;typealias&lt;/code&gt; Kotlin . Он использует &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; для представления параметров указателя и &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; для представления сигнатуры функции. Существует функция расширения оператора &lt;code&gt;invoke&lt;/code&gt; доступная для всех &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; , поэтому ее можно вызывать так же, как и любую другую функцию в Kotlin.</target>
        </trans-unit>
        <trans-unit id="28a890b04741a752c8a070159a08ecb4fb5a731d" translate="yes" xml:space="preserve">
          <source>We see that while the first number was still being processed the second, and third were already produced, so the second one was &lt;em&gt;conflated&lt;/em&gt; and only the most recent (the third one) was delivered to the collector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2878a9c7f0b432f6ca797d421e5946bffba2e7e" translate="yes" xml:space="preserve">
          <source>We should drag the created build phase to the top of the list</source>
          <target state="translated">Нам нужно перетащить созданную фазу сборки наверх списка.</target>
        </trans-unit>
        <trans-unit id="96dd80304356c421140b6cec43e73736a5d2cf73" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumBy()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">Мы просто берем каждую сопрограмму и ждем ее результата здесь, затем все результаты складываются вместе стандартной библиотечной функцией &lt;code&gt;sumBy()&lt;/code&gt; . Но компилятор справедливо жалуется:</target>
        </trans-unit>
        <trans-unit id="256672724470d83204a91011d31c7585e8e896c2" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumOf()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4baf88fc00c2c6a8043a4496a26dfca6b633d7" translate="yes" xml:space="preserve">
          <source>We start with a very simple action that increments a shared mutable variable using multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;.</source>
          <target state="translated">Мы начнем с очень простого действия, которое увеличивает общую изменяемую переменную с помощью многопоточных &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6e2ee50e438c21fd164031d81fcec588a999b4f" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations as evident from the output of the above main function:</source>
          <target state="translated">Как видно из вывода вышеприведенной основной функции,мы все еще имеем параллельное выполнение обеих операций:</target>
        </trans-unit>
        <trans-unit id="d309cfebc83a39f58f865d0bd1891f05f3570150" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations, as evident from the output of the above &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c80eca3836dfb2ec346ec74a1498c04b650629" translate="yes" xml:space="preserve">
          <source>We suggest you try the method &lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt; instead which closes the stream when the processing is complete.</source>
          <target state="translated">Мы предлагаем вам попробовать вместо этого метод &lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines,&lt;/a&gt; который закрывает поток по завершении обработки.</target>
        </trans-unit>
        <trans-unit id="1f5ae8ba8a817df47cdd30f0d60e67f7842b5f3f" translate="yes" xml:space="preserve">
          <source>We use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00e20f64ce7aa51453973eb86f6197d3fb8aac0" translate="yes" xml:space="preserve">
          <source>We use a normal sequential invocation, because the code in the coroutine, just like in the regular code, is &lt;em&gt;sequential&lt;/em&gt; by default. The following example demonstrates it by measuring the total time it takes to execute both suspending functions:</source>
          <target state="translated">Мы используем обычный последовательный вызов, потому что код в сопрограмме, как и в обычном коде, по умолчанию является &lt;em&gt;последовательным&lt;/em&gt; . В следующем примере это демонстрируется путем измерения общего времени, необходимого для выполнения обеих функций приостановки:</target>
        </trans-unit>
        <trans-unit id="aadde77016fbc4d33f0abaca395b0e32828abddd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;import SharedCode&lt;/code&gt; to import our Framework, which we compiled with Kotlin/Native from Kotlin code. Next, we call the Kotlin function from it as &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt;. Follow the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial for more details on the Kotlin/Native to Swift (or Objective-C) interop.</source>
          <target state="translated">Мы используем &lt;code&gt;import SharedCode&lt;/code&gt; для импорта нашего фреймворка, который мы скомпилировали с помощью Kotlin / Native из кода Kotlin. Затем мы вызываем из него функцию Kotlin как &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt; . Следуйте руководству &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; для получения дополнительных сведений о взаимодействии Kotlin / Native с Swift (или Objective-C).</target>
        </trans-unit>
        <trans-unit id="085b9979a689e14ecd3808ec279a6c3ad33ba2ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;staticCFunction{..}&lt;/code&gt; helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. We may only use globally visible declarations. Throwing exceptions from a &lt;code&gt;staticCFunction{..}&lt;/code&gt; will end up in non-deterministic side-effects. It is vital to make sure that we are not throwing any sudden exceptions from it.</source>
          <target state="translated">Мы используем вспомогательную функцию &lt;code&gt;staticCFunction{..}&lt;/code&gt; из Kotlin / Native, чтобы обернуть лямбда-функцию Kotlin в указатель на функцию C. Он позволяет иметь только несвязанные и не захватывающие лямбда-функции. Например, он не может использовать локальную переменную из функции. Мы можем использовать только глобально видимые объявления. &lt;code&gt;staticCFunction{..}&lt;/code&gt; исключений из staticCFunction {..} приведет к недетерминированным побочным эффектам. Очень важно убедиться, что мы не выбрасываем из него никаких внезапных исключений.</target>
        </trans-unit>
        <trans-unit id="6d750a9144d219b73169d8ec8ee3282a5ce16530" translate="yes" xml:space="preserve">
          <source>We use the condition in the Gradle script to select the target platform for the framework. It is either &lt;code&gt;iOS arm64&lt;/code&gt; or &lt;code&gt;iOS x86_64&lt;/code&gt; depending on environment variables.</source>
          <target state="translated">Мы используем условие в скрипте Gradle для выбора целевой платформы для фреймворка. Это либо &lt;code&gt;iOS arm64&lt;/code&gt; , либо &lt;code&gt;iOS x86_64&lt;/code&gt; в зависимости от переменных среды.</target>
        </trans-unit>
        <trans-unit id="87ead7e377be828bc8f924111dcab22679cf1455" translate="yes" xml:space="preserve">
          <source>We use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers. Those pointers are only valid inside the &lt;code&gt;memScoped&lt;/code&gt; block.</source>
          <target state="translated">Мы используем свойство расширения &lt;code&gt;ptr&lt;/code&gt; , которое происходит от &lt;code&gt;memScoped&lt;/code&gt; лямбда-приемника &lt;code&gt;MyStruct&lt;/code&gt; чтобы превратить экземпляры MyStruct и &lt;code&gt;MyUnion&lt;/code&gt; в собственные указатели. Эти указатели действительны только внутри блока &lt;code&gt;memScoped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d19fb9c3674e9e7d03350ce663d175de7004c2d" translate="yes" xml:space="preserve">
          <source>We will be using &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; for the Android part of the tutorial. It is also possible to use &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community or Ultimate edition.</source>
          <target state="translated">Мы будем использовать &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; для части руководства, посвященной Android. Также можно использовать &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community или Ultimate edition.</target>
        </trans-unit>
        <trans-unit id="495de00f60f65274c47ffb67586fe526a49cb4f3" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for the example. You need to make sure you have the latest version of the Kotlin plugin installed, 1.3.x or newer. We select &lt;em&gt;File | New | Project&lt;/em&gt;, select &lt;em&gt;Kotlin | Kotlin (Multiplatform Library)&lt;/em&gt; and configure the project in the way we want.</source>
          <target state="translated">В качестве примера мы будем использовать IntelliJ IDEA Community Edition. Вам необходимо убедиться, что у вас установлена ​​последняя версия плагина Kotlin 1.3.x или новее. Выбираем &lt;em&gt;File | Новый | Project&lt;/em&gt; , выберите &lt;em&gt;Kotlin | Kotlin (многоплатформенная библиотека)&lt;/em&gt; и настраиваем проект так, как мы хотим.</target>
        </trans-unit>
        <trans-unit id="9c7906ddfb7d83aa5b930b2241b862ba86c46dd5" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240e26cd69c673ca5063d1fec6c288458947715f" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well. The Kotlin plugin 1.3.x or higher should be installed in the IDE. This can be verified via the &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE. Native part of this project is written using Mac OS X, but don't worry if you are using another platform, the platform affects only directory names in this particular tutorial.</source>
          <target state="translated">В этом руководстве мы будем использовать IntelliJ IDEA Community Edition, хотя также возможно использование Ultimate Edition. Плагин Kotlin 1.3.x или выше должен быть установлен в среде IDE. Это можно проверить с помощью &lt;em&gt;Language &amp;amp; Frameworks | &lt;/em&gt;Раздел &quot; &lt;em&gt;Обновления Kotlin&quot;&lt;/em&gt; в &lt;em&gt;настройках&lt;/em&gt; (или &lt;em&gt;предпочтениях&lt;/em&gt; ) среды IDE. Собственная часть этого проекта написана с использованием Mac OS X, но не беспокойтесь, если вы используете другую платформу, платформа влияет только на имена каталогов в этом конкретном руководстве.</target>
        </trans-unit>
        <trans-unit id="a5df86530b0f4b4eea42ee317054bed9ca2a9e03" translate="yes" xml:space="preserve">
          <source>We will be using the &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; console. We'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</source>
          <target state="translated">Мы будем использовать консоль &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; . Мы увидим ярлык для открытия консоли в меню &amp;laquo;Пуск&amp;raquo;. Он поставляется с пакетом Microsoft Visual Studio.</target>
        </trans-unit>
        <trans-unit id="356ae5746574838fa3924ac6e010e44bd7dc600e" translate="yes" xml:space="preserve">
          <source>We will continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</source>
          <target state="translated">Мы продолжим изучать больше типов языка C и их представление в Kotlin/Native в следующих учебниках:</target>
        </trans-unit>
        <trans-unit id="d5797487ddb0eb41e5d2e9c68ced4d766fd86f98" translate="yes" xml:space="preserve">
          <source>We will continue to explore more complicated C language types and their representation in Kotlin/Native in the next tutorials:</source>
          <target state="translated">Мы продолжим изучение более сложных типов языка C и их представление в Котлине/Натив в следующих учебниках:</target>
        </trans-unit>
        <trans-unit id="6cf9027aa102f6f0a5c64a43d077861c549d000f" translate="yes" xml:space="preserve">
          <source>We will cover this functionality with common tests and then publish the final library to Maven.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c2f2e6b1a14ab9c7e2d8312c7379c2ecdd3c02" translate="yes" xml:space="preserve">
          <source>We will create a simple Kotlin/JavaScript library.</source>
          <target state="translated">Мы создадим простую библиотеку Kotlin/JavaScript.</target>
        </trans-unit>
        <trans-unit id="194f5ab4f85b03618fc04358b4a842a9d1306f59" translate="yes" xml:space="preserve">
          <source>We will then see something similar to this:</source>
          <target state="translated">Тогда мы увидим нечто подобное:</target>
        </trans-unit>
        <trans-unit id="3a29960a39a18059d04b2735de83331640c538de" translate="yes" xml:space="preserve">
          <source>We would like to emphasize that extension functions are dispatched &lt;strong&gt;statically&lt;/strong&gt;, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime. For example:</source>
          <target state="translated">Мы хотели бы подчеркнуть, что функции расширения отправляются &lt;strong&gt;статически&lt;/strong&gt; , то есть они не являются виртуальными по типу получателя. Это означает, что вызываемая функция расширения определяется типом выражения, для которого функция вызывается, а не типом результата вычисления этого выражения во время выполнения. Например:</target>
        </trans-unit>
        <trans-unit id="b83946b87080a81db62683de18b3b00c28f7ba2c" translate="yes" xml:space="preserve">
          <source>We wouldn't know if this function would be invoked on only activities from our sources or on plain Java activities also. Because of this, we don&amp;rsquo;t use caching there, even if &lt;code&gt;MyActivity&lt;/code&gt; instance from the previous example is passed as a receiver.</source>
          <target state="translated">Мы не знали бы, будет ли эта функция вызываться только для действий из наших источников или также для простых действий Java. Из-за этого мы не используем там кеширование, даже если экземпляр &lt;code&gt;MyActivity&lt;/code&gt; из предыдущего примера передается как получатель.</target>
        </trans-unit>
        <trans-unit id="64fbc9430739427e8ecff708c04a32c1ecf8e64f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new API to &lt;code&gt;kotlin-reflect&lt;/code&gt; that can be used to enumerate all the direct subtypes of a &lt;code&gt;sealed&lt;/code&gt; class, namely &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt;.</source>
          <target state="translated">Мы добавили новый API в &lt;code&gt;kotlin-reflect&lt;/code&gt; ion, который можно использовать для перечисления всех прямых подтипов &lt;code&gt;sealed&lt;/code&gt; класса, а именно &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8104ed41ba0ad6b8cb42477062cc9a8702abbeec" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added one more action in IntelliJ IDEA 2020.1 with Gradle 6.0 and above &amp;ndash; &lt;strong&gt;Load Script Configurations&lt;/strong&gt;, which loads changes to the script configurations without updating the whole project. This takes much less time than reimporting the whole project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40438146e777422ec29b09a135f9a4faaaaf0ee2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve reworked how C interop libraries are built. With the new tooling, Kotlin/Native produces interop libraries up to 4 times as fast as before, and artifacts are 25% to 30% the size they used to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280290f99293d030e512b76f98e946df19f3aa24" translate="yes" xml:space="preserve">
          <source>We'd start solving it by creating a Kotlin source file with an arbitrary name. &lt;code&gt;A.kt&lt;/code&gt; will do well. First, we need to implement a function specified in the problem statement as:</source>
          <target state="translated">Мы начали бы ее решать с создания исходного файла Kotlin с произвольным именем. &lt;code&gt;A.kt&lt;/code&gt; подойдет. Во-первых, нам нужно реализовать функцию, указанную в формулировке задачи как:</target>
        </trans-unit>
        <trans-unit id="48dd517a499e14c158e9fa4782184f8188502e0f" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;getting-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">Мы будем использовать IntelliJ IDEA (Ultimate или Community edition). Чтобы узнать, как начать новый проект Kotlin в IntelliJ IDEA, см. &lt;a href=&quot;getting-started&quot;&gt;Учебное&lt;/a&gt; пособие по началу работы с IntellJ IDEA . Если вы используете инструменты сборки, см. Соответствующую запись в разделе &lt;a href=&quot;build-tools&quot;&gt;Инструменты сборки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13befb7a01cdbb85144f68b9efce98f561e6a626" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;jvm-get-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7aa73d697a63f1be8df9974161860c77d7f65f" translate="yes" xml:space="preserve">
          <source>We'll create a new Android project via &lt;em&gt;Start New Android Project&lt;/em&gt; item. If using IntelliJ IDEA, we need to select &lt;em&gt;Android&lt;/em&gt; in the left panel of the &lt;em&gt;New Project&lt;/em&gt; wizard.</source>
          <target state="translated">Мы создадим новый Android-проект через пункт &lt;em&gt;Start New Android Project&lt;/em&gt; . При использовании IntelliJ IDEA нам нужно выбрать &lt;em&gt;Android&lt;/em&gt; на левой панели мастера создания &lt;em&gt;проекта&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="adbf109def75db2c462938914849c5eb6eed73eb" translate="yes" xml:space="preserve">
          <source>We'll learn how to:</source>
          <target state="translated">Мы научимся:</target>
        </trans-unit>
        <trans-unit id="65dfa3289b9a70c638718585acaabd5931d1b082" translate="yes" xml:space="preserve">
          <source>We'll look at &lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;, &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;, &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; and &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (other frameworks can be set up similarly). All these frameworks work through annotation processing: you annotate the code to have the boiler-plate code generated for you. Annotations allow to hide all the verbosity and keep your code simple, and if you need to understand what actually happens at runtime, you can look at the generated code. Note that all these frameworks generate source code in Java, not Kotlin.</source>
          <target state="translated">Мы рассмотрим &lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt; , &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt; , &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; и &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (другие фреймворки можно настроить аналогичным образом). Все эти фреймворки работают через обработку аннотаций: вы аннотируете код, чтобы для вас был сгенерирован шаблонный код. Аннотации позволяют скрыть всю многословность и сделать ваш код простым, и если вам нужно понять, что на самом деле происходит во время выполнения, вы можете посмотреть сгенерированный код. Обратите внимание, что все эти фреймворки генерируют исходный код на Java, а не на Kotlin.</target>
        </trans-unit>
        <trans-unit id="c7ac9f8cb4bffee3deae462c300ad8acc7b22566" translate="yes" xml:space="preserve">
          <source>We'll use the following &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">Мы будем использовать следующий &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; build.gradle build.gradle.kts Gradle со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="35e9daf2777de53728fdd63d8121926825802dd9" translate="yes" xml:space="preserve">
          <source>We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;boast()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;MotorVehicle&lt;/code&gt;. We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;ride()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; implements &lt;code&gt;Driveable&lt;/code&gt; (thanks to being a subclass &lt;code&gt;MotorVehicle&lt;/code&gt;). Inside &lt;code&gt;boast()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;MotorVehicle&lt;/code&gt;, even if we're in a situation where we know that it's really a &lt;code&gt;Car&lt;/code&gt; (because there could be other callers that pass a non-&lt;code&gt;Car&lt;/code&gt;). Inside &lt;code&gt;ride()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;Driveable&lt;/code&gt;. This ensures that every member lookup is safe - the compiler only allows you to pass objects that are guaranteed to have the necessary members. The downside is that you will sometimes be forced to declare &quot;unnecessary&quot; interfaces or wrapper classes in order to make a function accept instances of different classes.</source>
          <target state="translated">Нам разрешено передать &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;boast()&lt;/code&gt; потому что &lt;code&gt;Car&lt;/code&gt; является подклассом &lt;code&gt;MotorVehicle&lt;/code&gt; . Нам разрешено передать &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;ride()&lt;/code&gt; потому что &lt;code&gt;Car&lt;/code&gt; реализует &lt;code&gt;Driveable&lt;/code&gt; (благодаря тому, что он является подклассом &lt;code&gt;MotorVehicle&lt;/code&gt; ). Внутри &lt;code&gt;boast()&lt;/code&gt; нам разрешен доступ только к членам объявленного типа параметра &lt;code&gt;MotorVehicle&lt;/code&gt; , даже если мы находимся в ситуации, когда мы знаем, что это действительно &lt;code&gt;Car&lt;/code&gt; (потому что могут быть другие вызывающие объекты, которые передают не- &lt;code&gt;Car&lt;/code&gt; ). Внутри &lt;code&gt;ride()&lt;/code&gt; , нам разрешен доступ только к членам объявленного типа параметра &lt;code&gt;Driveable&lt;/code&gt; . Это гарантирует, что поиск каждого члена безопасен - компилятор позволяет передавать только те объекты, которые гарантированно содержат необходимые члены. Обратной стороной является то, что вам иногда придется объявлять &amp;laquo;ненужные&amp;raquo; интерфейсы или классы-оболочки, чтобы функция могла принимать экземпляры разных классов.</target>
        </trans-unit>
        <trans-unit id="a12f1bb4ce7d202790746259d8059bc20b4c1c93" translate="yes" xml:space="preserve">
          <source>We're going to see how to set up TeamCity to build our Kotlin project. For more information and basics of TeamCity please check the &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;Documentation page&lt;/a&gt; which contains information about installation, basic configuration, etc.</source>
          <target state="translated">Мы собираемся посмотреть, как настроить TeamCity для сборки нашего проекта Kotlin. Для получения дополнительной информации и основ TeamCity посетите &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;страницу документации,&lt;/a&gt; которая содержит информацию об установке, базовой конфигурации и т. Д.</target>
        </trans-unit>
        <trans-unit id="dfe8cb673d9e8e417b1ac641d5d52b9b44cf3e8b" translate="yes" xml:space="preserve">
          <source>We're not going to cover the &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; in depth here since it doesn't have a close equivalent in Python, but check it out - it's pretty nifty, as it lets you compare one expression against many kinds of expressions in a very compact way (but it's not a full functional-programming-style pattern matcher). For example:</source>
          <target state="translated">Мы не собираемся здесь подробно рассматривать &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt;выражение &lt;/a&gt; &lt;code&gt;when&lt;/code&gt; , поскольку оно не имеет близкого эквивалента в Python, но проверьте его - оно довольно изящно, поскольку позволяет сравнивать одно выражение со многими видами выражений в очень компактном формате. способ (но это не полный сопоставитель шаблонов в стиле функционального программирования). Например:</target>
        </trans-unit>
        <trans-unit id="859b2e88a4b107551034ec5b70f0408cd92fac5e" translate="yes" xml:space="preserve">
          <source>We've also added the &lt;code&gt;ArrayDeque&lt;/code&gt; class &amp;ndash; an implementation of a double-ended queue. Double-ended queue lets you can add or remove elements both at the beginning and the end of the queue in an amortized constant time. You can use a double-ended queue by default when you need a queue or a stack in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6d4821c53a1c0b88e02c8ce15a60335e60fc0a" translate="yes" xml:space="preserve">
          <source>We've converted the ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;sample&lt;/a&gt; to Kotlin. The resulting code can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Мы преобразовали &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;образец&lt;/a&gt; ButterKnife в Kotlin. Полученный код можно найти &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30d2a23216aee2ca42dc00c09139bd8bf210d9fc" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;, and &lt;code&gt;lastIndexOf()&lt;/code&gt; extension functions of &lt;code&gt;FloatArray&lt;/code&gt; and &lt;code&gt;DoubleArray&lt;/code&gt; because they use the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; standard equality, which contradicts the total order equality in some corner cases. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9565458367bc75e7700ec47534de831e4a66b878" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;max()&lt;/code&gt; collection functions in favor of &lt;code&gt;minOrNull()&lt;/code&gt; and &lt;code&gt;maxOrNull()&lt;/code&gt;, which more properly reflect their behavior &amp;ndash; returning &lt;code&gt;null&lt;/code&gt; on empty collections. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215b5a7efdc1c89ee7092df264b96d7d1f704519" translate="yes" xml:space="preserve">
          <source>We've deprecated the functions &lt;code&gt;toShort()&lt;/code&gt; and &lt;code&gt;toByte()&lt;/code&gt; on &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; because they could lead to unexpected results because of the narrow value range and smaller variable size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c686dd7fee7d596ed3150966a1df858b5684ea" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">Теперь мы просмотрели все определения, и пора исправить код. Давайте &lt;code&gt;runDebugExecutableNative&lt;/code&gt; задачу runDebugExecutableNative Gradle &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в среде IDE&lt;/a&gt; или воспользуемся следующей командой для запуска кода:</target>
        </trans-unit>
        <trans-unit id="7303eeb28a81c2ad71ddaf7a7ef26c96a5d46db5" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8159d531b6661d9ca1d3ee3cd78cdb26173e7e20" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">Мы видели все определения, и пора исправить код. Давайте &lt;code&gt;runDebugExecutableNative&lt;/code&gt; задачу runDebugExecutableNative Gradle &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в IDE&lt;/a&gt; или воспользуемся следующей командой для запуска кода:</target>
        </trans-unit>
        <trans-unit id="5060dcbe8547bb3d7e1fb6bf0d1175fce384646a" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d875c328d56b6ba3de658fff30f901e7a7dadd62" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">Мы видели все определения, и пора исправить и запустить код. Давайте &lt;code&gt;runDebugExecutableNative&lt;/code&gt; задачу runDebugExecutableNative Gradle &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в среде IDE&lt;/a&gt; или воспользуемся следующей командой для запуска кода:</target>
        </trans-unit>
        <trans-unit id="6a79043503070152826fab6d2dc8528967704ffa" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a792d756a38347597c27360412bb8f8fa517b753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;AN&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный символ типа &quot;AN&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="24dbecca4697c39dcb12d83d3e21e053a4fbf4ac" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;BN&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный тип символов &quot;BN&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="b592dbfa74287749b5b330052c7e3f462ec0a974" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;CS&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный тип символов &quot;CS&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="d484194528c4965d5cfe46ac4072c437b4f7364f" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;EN&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный тип символов &quot;EN&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="73f96fcc50384aeb2e177d07991c8003c66a6753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ES&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный символьный тип &quot;ES&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="818ef5444e8d72a94e14f04b5d6b122d1830655b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ET&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный тип символов &quot;ET&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="34c6763955af9013896491090181dbcd5a8dd74c" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный символьный тип &quot;NSM&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="956c2a4c465d4b08d54fa1ddb34419c1810351ef" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.</source>
          <target state="translated">Слабый двунаправленный символьный тип &quot;PDF&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="10cf3089a5d1b6f0fd308ab8ea55feb903fcea98" translate="yes" xml:space="preserve">
          <source>WebAssembly (wasm32)</source>
          <target state="translated">WebAssembly (wasm32)</target>
        </trans-unit>
        <trans-unit id="54a290ccb466e5479f81f8b2a84a8c409c89300b" translate="yes" xml:space="preserve">
          <source>WebGLActiveInfo</source>
          <target state="translated">WebGLActiveInfo</target>
        </trans-unit>
        <trans-unit id="e6b73caf842064140299b1ca0b4460e6e2d7b8db" translate="yes" xml:space="preserve">
          <source>WebGLContextAttributes</source>
          <target state="translated">WebGLContextAttributes</target>
        </trans-unit>
        <trans-unit id="4270da2ffdc4cd7b0f031d7be5d3da6756d9f418" translate="yes" xml:space="preserve">
          <source>WebGLContextEventInit</source>
          <target state="translated">WebGLContextEventInit</target>
        </trans-unit>
        <trans-unit id="40e776dc5c04c24ed694e56559baff72c6650985" translate="yes" xml:space="preserve">
          <source>WebGLObject</source>
          <target state="translated">WebGLObject</target>
        </trans-unit>
        <trans-unit id="21ae6cd2acfef9ca69acf1201e1d6a74d9cbc06a" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContext</source>
          <target state="translated">WebGLRenderingContext</target>
        </trans-unit>
        <trans-unit id="4801b56eb1b5d686e9a1febe6821b4d7326421a2" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContextBase</source>
          <target state="translated">WebGLRenderingContextBase</target>
        </trans-unit>
        <trans-unit id="5484abb27b9c8304c0334e77ca1817b8faf244f4" translate="yes" xml:space="preserve">
          <source>WebGLShaderPrecisionFormat</source>
          <target state="translated">WebGLShaderPrecisionFormat</target>
        </trans-unit>
        <trans-unit id="598b5bbd37e1ce6914df736dcaf0620916e3e37e" translate="yes" xml:space="preserve">
          <source>WebGLUniformLocation</source>
          <target state="translated">WebGLUniformLocation</target>
        </trans-unit>
        <trans-unit id="3a3301048780c886766fd5f9fc46f7ed9edce741" translate="yes" xml:space="preserve">
          <source>Webpack provides two different &quot;flavors&quot; of CommonJS, &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, which affect the way your declarations are made available. While in most cases, you probably want &lt;code&gt;commonjs2&lt;/code&gt;, which adds the &lt;code&gt;module.exports&lt;/code&gt; syntax to the generated library, you can also opt for the &quot;pure&quot; &lt;code&gt;commonjs&lt;/code&gt; option, which implements the CommonJS specification exactly. To learn more about the difference between &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, check &lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee12f5d174e362fdee2c3d0937fed7a0a0418b29" translate="yes" xml:space="preserve">
          <source>What IDEs support Kotlin?</source>
          <target state="translated">Какие IDE поддерживают Котлина?</target>
        </trans-unit>
        <trans-unit id="f19e03186b38de86427a604326b5e20ce36b16e0" translate="yes" xml:space="preserve">
          <source>What Java has that Kotlin does not</source>
          <target state="translated">То,что есть на Яве,а не на Котлине...</target>
        </trans-unit>
        <trans-unit id="7c25e3810f499ecbecfd573d100c2992ec85dfee" translate="yes" xml:space="preserve">
          <source>What Kotlin has that Java does not</source>
          <target state="translated">То,что есть у Котлина,а не у Явы...</target>
        </trans-unit>
        <trans-unit id="a0618cd665f03aa3f49f142cd97a9d8c33d6f6d0" translate="yes" xml:space="preserve">
          <source>What advantages does Kotlin give me over the Java programming language?</source>
          <target state="translated">Какие преимущества дает мне Котлин по сравнению с языком программирования Java?</target>
        </trans-unit>
        <trans-unit id="2ec574e0a3bc1f92310ec6597730108793dbab22" translate="yes" xml:space="preserve">
          <source>What are we building?</source>
          <target state="translated">Что мы строим?</target>
        </trans-unit>
        <trans-unit id="54d0e194d6d22dc2c5cc598434a07c74290a1df0" translate="yes" xml:space="preserve">
          <source>What build tools support Kotlin?</source>
          <target state="translated">Какие строительные инструменты поддерживают Kotlin?</target>
        </trans-unit>
        <trans-unit id="b663cb1b85b44f2ed22f76f75c249fd71cd30ee5" translate="yes" xml:space="preserve">
          <source>What can I use Kotlin for?</source>
          <target state="translated">Для чего мне использовать Котлин?</target>
        </trans-unit>
        <trans-unit id="1c253aa8f7093e6c010267944ec10ed903d9b3d6" translate="yes" xml:space="preserve">
          <source>What companies are using Kotlin?</source>
          <target state="translated">Какие компании используют Котлин?</target>
        </trans-unit>
        <trans-unit id="05e8ab4ca375bf042d9384276202b934420c2059" translate="yes" xml:space="preserve">
          <source>What do we do if need to invoke them &lt;em&gt;sequentially&lt;/em&gt; &amp;ndash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and compute the sum of their results? In practice we do this if we use the results of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">Что нам делать, если нужно вызывать их &lt;em&gt;последовательно&lt;/em&gt; - сначала &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; ,&lt;em&gt;а затем &lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; и вычислить сумму их результатов? На практике мы делаем это, если используем результаты первой функции, чтобы принять решение о том, нужно ли нам вызывать вторую или решить, как ее вызывать.</target>
        </trans-unit>
        <trans-unit id="ec5e65d31d420634cb6bd22727661d2a91c1e71b" translate="yes" xml:space="preserve">
          <source>What do we do if we need them to be invoked &lt;em&gt;sequentially&lt;/em&gt; &amp;mdash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;, and compute the sum of their results? In practice we do this if we use the result of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75dc4fbbde8bc3398e1fc23b66dca3f704f50fe" translate="yes" xml:space="preserve">
          <source>What does Kotlin compile down to?</source>
          <target state="translated">К чему компилирует Котлин?</target>
        </trans-unit>
        <trans-unit id="cbc1b72459c6cd091c4b5fc250725f50ac98c379" translate="yes" xml:space="preserve">
          <source>What does it print at the end? It is highly unlikely to ever print &quot;Counter = 100000&quot;, because a hundred coroutines increment the &lt;code&gt;counter&lt;/code&gt; concurrently from multiple threads without any synchronization.</source>
          <target state="translated">Что печатается в конце? Маловероятно, что когда-либо выйдет &amp;laquo;Counter = 100000&amp;raquo;, потому что сотни сопрограмм увеличивают &lt;code&gt;counter&lt;/code&gt; одновременно из нескольких потоков без какой-либо синхронизации.</target>
        </trans-unit>
        <trans-unit id="18807a12b7e25a451e442847837857201bfc7505" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results in this kind of code all over the place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f65d1bc84288a4305aabbbfaad8cd7fe25a6b3d" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results into this kind of code all over the place:</source>
          <target state="translated">Что говорит эта подпись? Он говорит, что каждый раз, когда я к чему-то добавляю строку ( &lt;code&gt;StringBuilder&lt;/code&gt; , какой-то журнал, консоль и т. Д.), Я должен перехватывать эти &lt;code&gt;IOExceptions&lt;/code&gt; . Зачем? Потому что он может выполнять ввод-вывод ( &lt;code&gt;Writer&lt;/code&gt; также реализует &lt;code&gt;Appendable&lt;/code&gt; )&amp;hellip; Таким образом, он приводит к повсюду такого рода код:</target>
        </trans-unit>
        <trans-unit id="683b8d36e158b49d7282ac38785e02d0ec00e146" translate="yes" xml:space="preserve">
          <source>What happens if multiple children of a coroutine throw an exception? The general rule is &quot;the first exception wins&quot;, so the first thrown exception is exposed to the handler. But that may cause lost exceptions, for example if coroutine throws an exception in its &lt;code&gt;finally&lt;/code&gt; block. So, additional exceptions are suppressed.</source>
          <target state="translated">Что произойдет, если несколько дочерних элементов сопрограммы вызовут исключение? Общее правило - &amp;laquo;побеждает первое исключение&amp;raquo;, поэтому обработчику предоставляется первое созданное исключение. Но это может привести к потере исключений, например, если сопрограмма выдает исключение в своем блоке &lt;code&gt;finally&lt;/code&gt; . Таким образом, дополнительные исключения подавляются.</target>
        </trans-unit>
        <trans-unit id="365b6a79e0879610a6d21849bc8cc5cf6d51d197" translate="yes" xml:space="preserve">
          <source>What has happened here is called &lt;strong&gt;type projection&lt;/strong&gt;: we said that &lt;code&gt;from&lt;/code&gt; is not simply an array, but a restricted (&lt;strong&gt;projected&lt;/strong&gt;) one: we can only call those methods that return the type parameter &lt;code&gt;T&lt;/code&gt;, in this case it means that we can only call &lt;code&gt;get()&lt;/code&gt;. This is our approach to &lt;strong&gt;use-site variance&lt;/strong&gt;, and corresponds to Java's &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, but in a slightly simpler way.</source>
          <target state="translated">То, что здесь произошло, называется &lt;strong&gt;проекцией типа&lt;/strong&gt; : мы сказали, что &lt;code&gt;from&lt;/code&gt; - это не просто массив, а ограниченный ( &lt;strong&gt;спроецированный&lt;/strong&gt; ): мы можем вызывать только те методы, которые возвращают параметр типа &lt;code&gt;T&lt;/code&gt; , в этом случае это означает, что мы можем только вызывать &lt;code&gt;get()&lt;/code&gt; . Это наш подход к &lt;strong&gt;дисперсии использования сайта&lt;/strong&gt; и соответствует Java &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt; , но немного проще.</target>
        </trans-unit>
        <trans-unit id="77aa02de8be96f4d1a2d486916d80f88707bf2e0" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocation of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">Что делать, если между &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; и &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; нет зависимостей, и мы хотим получить ответ быстрее, выполняя и то, и другое &lt;em&gt;одновременно&lt;/em&gt; ? Здесь на помощь приходит &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;асинхронный режим&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9d26c1d8e7803f441abc75ddaa9a3cb6ee5810" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocations of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c61df73a1cd1792c66d92381a767d6d084db44" translate="yes" xml:space="preserve">
          <source>What is Kotlin?</source>
          <target state="translated">Что такое Котлин?</target>
        </trans-unit>
        <trans-unit id="9c97b9a8111f68ce8c52dfe8c2a3959e4d0cfd92" translate="yes" xml:space="preserve">
          <source>What is the current version of Kotlin?</source>
          <target state="translated">Какова текущая версия Котлина?</target>
        </trans-unit>
        <trans-unit id="72b9dc537736b5c80161df96b96d566c2340d8ed" translate="yes" xml:space="preserve">
          <source>What types do we have in the C language? Let's first list all of them. I have used the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C data types&lt;/a&gt; article from Wikipedia as a basis. There are following types in the C programming language:</source>
          <target state="translated">Какие типы у нас есть в языке C? Давайте сначала перечислим их все. Я взял за основу статью о &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;типах данных C&lt;/a&gt; из Википедии. В языке программирования C есть следующие типы:</target>
        </trans-unit>
        <trans-unit id="b3a3d061e51769639781e9a3b9954e0ba115ec4b" translate="yes" xml:space="preserve">
          <source>What we actually want is simply pass a type to this function, i.e. call it like this:</source>
          <target state="translated">На самом деле мы хотим просто передать тип этой функции,т.е.назвать ее так:</target>
        </trans-unit>
        <trans-unit id="a50c7ef1f0fafc2256df6585bc99119f3c512a67" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.1</source>
          <target state="translated">Что нового в Kotlin 1.1</target>
        </trans-unit>
        <trans-unit id="9a4d9d06c26d113727033d8ae4c1b63e386642d5" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.2</source>
          <target state="translated">Что нового в Kotlin 1.2</target>
        </trans-unit>
        <trans-unit id="293419c5954282d33701ae5e04016a88fddb332a" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.3</source>
          <target state="translated">Что нового в Kotlin 1.3</target>
        </trans-unit>
        <trans-unit id="9389cd373bffcc015f87751d1dc27567fa32b8ba" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.1</source>
          <target state="translated">Что нового в Котлине 1.1?</target>
        </trans-unit>
        <trans-unit id="39982142e8f2af3375fc2ff57e8c12a82c314d40" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.2</source>
          <target state="translated">Что нового в Котлине 1.2?</target>
        </trans-unit>
        <trans-unit id="215e0c6f310ade62568bdc051de3a2c9b6801880" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.3</source>
          <target state="translated">Что нового в Котлине 1.3?</target>
        </trans-unit>
        <trans-unit id="5d9f851e585b75f9f88496923e3d47ca44295647" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.4.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4b36bc57457b9920995102b0eb6da42363fb68" translate="yes" xml:space="preserve">
          <source>What's next?</source>
          <target state="translated">Что дальше?</target>
        </trans-unit>
        <trans-unit id="18389155bba5ed3245c0f065f5a1c5b22a9f917a" translate="yes" xml:space="preserve">
          <source>Whatever way you choose to solve koans, you can see the solution for each task: in the online version click on &quot;Show answer&quot;, inside EduTools plugin choose &quot;Peek solution&quot;. We recommend checking the solution after you implement the task to compare your solution with the proposed one. Make sure you don't cheat!</source>
          <target state="translated">Какой бы способ решения коансов вы ни выбрали,вы можете увидеть решение для каждой задачи:в онлайн-версии нажмите кнопку &quot;Показать ответ&quot;,внутри плагина EduTools выберите &quot;Заглянуть в решение&quot;.Мы рекомендуем проверить решение после выполнения задачи,чтобы сравнить ваше решение с предложенным.Убедитесь,что вы не обманываете!</target>
        </trans-unit>
        <trans-unit id="00a0667e561fb370ec041d741f3ea97adc25dc28" translate="yes" xml:space="preserve">
          <source>WheelEventInit</source>
          <target state="translated">WheelEventInit</target>
        </trans-unit>
        <trans-unit id="e3117f509259d5d29ab1ad441436b902cca8f031" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">Когда &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;перезапись&lt;/a&gt; это &lt;code&gt;true&lt;/code&gt; и &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;цель&lt;/a&gt; является каталогом, то он заменяется только если он пуст.</target>
        </trans-unit>
        <trans-unit id="f0d8a684192ba53b6aed7c801b9b7ef648714954" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d29ca92f5092a739732a54c47f3da4e556b36a7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;mpp-create-lib&quot;&gt;creating a project with the Project Wizard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f50fe0838c0d3908e85b9819f34dd2e3eeee8c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dcaec5d16f5bf398df957b0d47d8f09a80f320" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">Когда &lt;code&gt;launch { ... }&lt;/code&gt; используется без параметров, он наследует контекст (и, следовательно, диспетчер) от &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; , из которого он запускается. В этом случае он наследует контекст основной сопрограммы &lt;code&gt;runBlocking&lt;/code&gt; , которая выполняется в &lt;code&gt;main&lt;/code&gt; потоке.</target>
        </trans-unit>
        <trans-unit id="a67ed24b676d6021025f2b0f67bd9c35fd94aa47" translate="yes" xml:space="preserve">
          <source>When Expression</source>
          <target state="translated">Когда выражение</target>
        </trans-unit>
        <trans-unit id="e8a56a195bc479e7e07a6420a30ef594182bfdc7" translate="yes" xml:space="preserve">
          <source>When Java types are imported into Kotlin, all the references of the type &lt;code&gt;java.lang.Object&lt;/code&gt; are turned into &lt;code&gt;Any&lt;/code&gt;. Since &lt;code&gt;Any&lt;/code&gt; is not platform-specific, it only declares &lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; as its members, so to make other members of &lt;code&gt;java.lang.Object&lt;/code&gt; available, Kotlin uses &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;.</source>
          <target state="translated">Когда типы Java импортируются в Kotlin, все ссылки типа &lt;code&gt;java.lang.Object&lt;/code&gt; превращаются в &lt;code&gt;Any&lt;/code&gt; . Поскольку &lt;code&gt;Any&lt;/code&gt; не зависит от платформы, он объявляет только &lt;code&gt;toString()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; и &lt;code&gt;equals()&lt;/code&gt; качестве своих членов, поэтому для того, чтобы сделать другие члены &lt;code&gt;java.lang.Object&lt;/code&gt; доступными, Kotlin использует &lt;a href=&quot;extensions&quot;&gt;функции расширения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de657bff6abe90a927125239467dfc7f66aa4d06" translate="yes" xml:space="preserve">
          <source>When Kotlin classes make use of &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;declaration-site variance&lt;/a&gt;, there are two options of how their usages are seen from the Java code. Let's say we have the following class and two functions that use it:</source>
          <target state="translated">Когда классы Kotlin используют &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;вариативность объявления-сайта&lt;/a&gt; , есть два варианта того, как их использование видно из кода Java. Допустим, у нас есть следующий класс и две функции, которые его используют:</target>
        </trans-unit>
        <trans-unit id="752a77d62b6432105ad9d079610666a77a3a539f" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt; or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df342c27a1154aea786d8fd951c9e3bea894932" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;code&gt;@Throws&lt;/code&gt;-specified classes or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32316c9a35a40c6afef037fd3a597555044f54d5" translate="yes" xml:space="preserve">
          <source>When a C function takes or returns a struct / union &lt;code&gt;T&lt;/code&gt; by value, the corresponding argument type or return type is represented as &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Когда функция C принимает или возвращает структуру / объединение &lt;code&gt;T&lt;/code&gt; по значению, соответствующий тип аргумента или возвращаемый тип представляется как &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdcfd2e9efefb419f2bd9e89cb02a695c22cf07" translate="yes" xml:space="preserve">
          <source>When a big team is migrating onto a new version, it may appear in a &quot;inconsistent state&quot; at some point, when some developers have already updated, and others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide the following command line switches (also available in the IDE and &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt;/&lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt;):</source>
          <target state="translated">Когда большая команда переходит на новую версию, она может в какой-то момент оказаться в &amp;laquo;несогласованном состоянии&amp;raquo;, когда одни разработчики уже обновили, а другие нет. Чтобы первый не мог писать и фиксировать код, который другие не смогут скомпилировать, мы предоставляем следующие параметры командной строки (также доступны в IDE и &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt; / &lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="18b8e63399abd55d3bbbdde25d3e2fcb80bd3160" translate="yes" xml:space="preserve">
          <source>When a coroutine is launched in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; of another coroutine, it inherits its context via &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; and the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the new coroutine becomes a &lt;em&gt;child&lt;/em&gt; of the parent coroutine's job. When the parent coroutine is cancelled, all its children are recursively cancelled, too.</source>
          <target state="translated">Когда сопрограммный запущен в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; другой сопрограммы, она наследует контекст через &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;работа&lt;/a&gt; нового сопрограммы становится &lt;em&gt;ребенком&lt;/em&gt; на работе родительских сопрограммной в. Когда родительская сопрограмма отменяется, все ее дочерние элементы также рекурсивно отменяются.</target>
        </trans-unit>
        <trans-unit id="8b40f9ca947a81bd12ef472c030664610317efac" translate="yes" xml:space="preserve">
          <source>When a data class derived from a type that already had the &lt;code&gt;copy&lt;/code&gt; function with the same signature, the &lt;code&gt;copy&lt;/code&gt; implementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior, or failed at runtime if there were no default parameters in the supertype.</source>
          <target state="translated">Когда класс данных, производный от типа, который уже имел функцию &lt;code&gt;copy&lt;/code&gt; с той же подписью, реализация &lt;code&gt;copy&lt;/code&gt; созданная для класса данных, использовала значения по умолчанию из супертипа, что приводило к противоречивому поведению, или сбой во время выполнения, если не было значения по умолчанию параметры в супертипе.</target>
        </trans-unit>
        <trans-unit id="e1f3667f48b1b3a74567f895c3f805750be29c9e" translate="yes" xml:space="preserve">
          <source>When a declaration has &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to project's static resources and include via &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element. To tell Kotlin that it's ok to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from non-module environment, you should put &lt;code&gt;@JsNonModule&lt;/code&gt; declaration. For example, given JavaScript code:</source>
          <target state="translated">Когда в объявлении есть &lt;code&gt;@JsModule&lt;/code&gt; , вы не можете использовать его из кода Kotlin, если не скомпилируете его в модуль JavaScript. Обычно разработчики распространяют свои библиотеки как в виде модулей JavaScript, так и в виде загружаемых файлов &lt;code&gt;.js&lt;/code&gt; , которые вы можете скопировать в статические ресурсы проекта и включить через элемент &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . Чтобы сообщить Kotlin, что можно использовать объявление &lt;code&gt;@JsModule&lt;/code&gt; из немодульной среды, вы должны поместить объявление &lt;code&gt;@JsNonModule&lt;/code&gt; . Например, с учетом кода JavaScript:</target>
        </trans-unit>
        <trans-unit id="cdc056f54b314225b42eb84b111e0f374e0f43fb" translate="yes" xml:space="preserve">
          <source>When a declaration is marked as &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to your project's static resources and include via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. To tell Kotlin that it's okay to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from a non-module environment, add the &lt;code&gt;@JsNonModule&lt;/code&gt; annotation. For example, consider the following JavaScript code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2a92ee663b6eefd13c4799f36aa168f8eb6c67" translate="yes" xml:space="preserve">
          <source>When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt; operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06eb4fdaeb1116ee0773fa0c7742573f91abd273" translate="yes" xml:space="preserve">
          <source>When a function is called with both positional and named arguments, all the positional arguments should be placed before the first named one. For example, the call &lt;code&gt;f(1, y = 2)&lt;/code&gt; is allowed, but &lt;code&gt;f(x = 1, 2)&lt;/code&gt; is not.</source>
          <target state="translated">Когда функция вызывается как с позиционными, так и с именованными аргументами, все позиционные аргументы должны быть помещены перед первым именованным аргументом. Например, вызов &lt;code&gt;f(1, y = 2)&lt;/code&gt; разрешен, а &lt;code&gt;f(x = 1, 2)&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="c39ba3c630d6c34d1a8dfc3a61b0e9ace62da655" translate="yes" xml:space="preserve">
          <source>When a function of an external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0551e05b4cdcabc413ed022b08af90ba98955ec" translate="yes" xml:space="preserve">
          <source>When a function of external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">Когда функция внешнего базового класса перегружена сигнатурой,ее нельзя переопределить в производном классе.</target>
        </trans-unit>
        <trans-unit id="1cc5a0d8a7f78114a2ac1e09f9cb178d1a485871" translate="yes" xml:space="preserve">
          <source>When a function returns a single expression, the curly braces can be omitted and the body is specified after a &lt;strong&gt;=&lt;/strong&gt; symbol:</source>
          <target state="translated">Когда функция возвращает одно выражение, фигурные скобки можно опустить, а тело будет указано после символа &lt;strong&gt;=&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4d60c7b0c4e08585362731f2e3c9cea8a0422110" translate="yes" xml:space="preserve">
          <source>When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to the safe call receiver as well:</source>
          <target state="translated">Когда переменная присваивается из выражения безопасного вызова и проверяется на ноль,смарт-кастинг теперь применяется и к приемнику безопасного вызова:</target>
        </trans-unit>
        <trans-unit id="75ac04198276b2032c15af24079f880bbc7d4548" translate="yes" xml:space="preserve">
          <source>When an abstract class implements one or more interfaces, it is not required to provide definitions of the members of its interfaces (but it can if it wants to). It must still &lt;em&gt;declare&lt;/em&gt; such members, using &lt;code&gt;abstract override&lt;/code&gt; and not providing any body for the function or property:</source>
          <target state="translated">Когда абстрактный класс реализует один или несколько интерфейсов, не требуется предоставлять определения членов его интерфейсов (но может, если захочет). Он по-прежнему должен &lt;em&gt;объявлять&lt;/em&gt; такие члены, используя &lt;code&gt;abstract override&lt;/code&gt; и не предоставляя никакого тела для функции или свойства:</target>
        </trans-unit>
        <trans-unit id="78ca79aa88621d9e1ad1b6380be2be6eed3fd311" translate="yes" xml:space="preserve">
          <source>When an equality check operands are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; (nullable or not), the check follows the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">Когда проверка равенства операнды статически известны, &lt;code&gt;Float&lt;/code&gt; или &lt;code&gt;Double&lt;/code&gt; (обнуляемый или нет), то проверка следует IEEE 754 Стандарта для арифметики с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="a72bfaeeae8d98102d2bd16c961c912a01957df4" translate="yes" xml:space="preserve">
          <source>When an inline function is &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; and is not a part of a &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;internal&lt;/code&gt; declaration, it is considered a &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;module&lt;/a&gt;'s public API. It can be called in other modules and is inlined at such call sites as well.</source>
          <target state="translated">Когда встроенная функция является &lt;code&gt;public&lt;/code&gt; или &lt;code&gt;protected&lt;/code&gt; и не является частью &lt;code&gt;private&lt;/code&gt; или &lt;code&gt;internal&lt;/code&gt; объявления, она считается общедоступным API &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;модуля&lt;/a&gt; . Его можно вызывать в других модулях, а также он встроен в такие сайты вызовов.</target>
        </trans-unit>
        <trans-unit id="a8b8b82c3468010f3b6d8941f07253746e1af976" translate="yes" xml:space="preserve">
          <source>When an instance of a subclass is constructed, the superclass &quot;part&quot; is constructed first (via the superclass constructor). This means that during execution of the constructor of an open class, it could be that the object being constructed is an instance of a subclass, in which case the subclass-specific properties have not been initialized yet. For that reason, calling an open function from a constructor is risky: it might be overridden in the subclass, and if it is accessing subclass-specific properties, those won't be initialized yet.</source>
          <target state="translated">При построении экземпляра подкласса сначала (через конструктор суперкласса)строится &quot;часть&quot; суперкласса.Это означает,что во время выполнения конструктора открытого класса может оказаться,что строящийся объект является экземпляром подкласса,в этом случае специфические свойства подкласса еще не инициализированы.По этой причине вызов открытой функции из конструктора рискованно:она может быть переопределена в подклассе,а если она обращается к свойствам,специфичным для подкласса,то они еще не инициализированы.</target>
        </trans-unit>
        <trans-unit id="5b0f246d38c7c57581718b09879ae1a9f3dd0cfb" translate="yes" xml:space="preserve">
          <source>When applied to a class or a member with internal visibility allows to use it from public inline functions and makes it effectively public.</source>
          <target state="translated">При применении к классу или члену с внутренней видимостью позволяет использовать его из публичных встроенных функций и делает его эффективно публичным.</target>
        </trans-unit>
        <trans-unit id="b2719f8cfa129fbdd0adc701d2dba400cfb7a4df" translate="yes" xml:space="preserve">
          <source>When applied to annotation class X specifies that X defines a DSL language</source>
          <target state="translated">При применении к классу аннотации X указывает,что X определяет язык DSL</target>
        </trans-unit>
        <trans-unit id="4383cdeb336d893261a8fd71ba6fa7f60d10ca1e" translate="yes" xml:space="preserve">
          <source>When applied, the CocoaPods plugin does the following:</source>
          <target state="translated">При применении плагин CocoaPods делает следующее:</target>
        </trans-unit>
        <trans-unit id="d3cb13a5dd74d5989c8544a9bd856469cfe20ca8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;excludeDependentModules&lt;/code&gt; and &lt;code&gt;headerFilter&lt;/code&gt; are used, they are applied as an intersection.</source>
          <target state="translated">Когда используются и &lt;code&gt;excludeDependentModules&lt;/code&gt; , и &lt;code&gt;headerFilter&lt;/code&gt; , они применяются как пересечение.</target>
        </trans-unit>
        <trans-unit id="5bd916e17d31ae892ecde1eb2457f0a21c18c0ca" translate="yes" xml:space="preserve">
          <source>When building a Kotlin/JS project using Kotlin 1.3.xx, you may encounter a Gradle error if one of your dependencies (or any transitive dependency) was built using Kotlin 1.4 or higher: &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt;. This is a known problem, a workaround is provided &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f14a9a00a723afb155894bffae89af46e21d16f" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the &lt;code&gt;export&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05de934df0888bf3a4ea0106e90f35a575c92fc" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework, it is often necessary to pack not just the classes of the current project, but also the classes of some of its dependencies. The Binaries DSL allows one to specify which dependencies will be exported in the framework using the &lt;code&gt;export&lt;/code&gt; method. Note that only API dependencies of a corresponding source set can be exported.</source>
          <target state="translated">При создании платформы Objective-C часто бывает необходимо упаковать не только классы текущего проекта, но и классы некоторых его зависимостей. Binaries DSL позволяет указать, какие зависимости будут экспортированы во фреймворк, используя метод &lt;code&gt;export&lt;/code&gt; . Обратите внимание, что можно экспортировать только зависимости API соответствующего исходного набора.</target>
        </trans-unit>
        <trans-unit id="6c939554f4725c1c653be2725d54eb9e654761fc" translate="yes" xml:space="preserve">
          <source>When building from Xcode, you can use CocoaPods libraries without writing .def files manually and setting cinterop tool parameters. In this case, all required parameters can be obtained from the Xcode project configured by CocoaPods.</source>
          <target state="translated">При сборке из Xcode можно использовать библиотеки CocoaPods,не записывая .def файлы вручную и не настраивая параметры инструмента cinterop.В этом случае все необходимые параметры могут быть получены из проекта Xcode,сконфигурированного CocoaPods.</target>
        </trans-unit>
        <trans-unit id="c700148c224a841d5e4fb27c316b7b0f072a2aee" translate="yes" xml:space="preserve">
          <source>When called on an object with a predicate provided, &lt;code&gt;takeIf&lt;/code&gt; returns this object if it matches the predicate. Otherwise, it returns &lt;code&gt;null&lt;/code&gt;. So, &lt;code&gt;takeIf&lt;/code&gt; is a filtering function for a single object. In turn, &lt;code&gt;takeUnless&lt;/code&gt; returns the object if it doesn't match the predicate and &lt;code&gt;null&lt;/code&gt; if it does. The object is available as a lambda argument (&lt;code&gt;it&lt;/code&gt;).</source>
          <target state="translated">При вызове объекта с предоставленным предикатом &lt;code&gt;takeIf&lt;/code&gt; возвращает этот объект, если он соответствует предикату. В противном случае возвращается &lt;code&gt;null&lt;/code&gt; . Итак, &lt;code&gt;takeIf&lt;/code&gt; - это функция фильтрации для одного объекта. В свою очередь &lt;code&gt;takeUnless&lt;/code&gt; возвращает объект, если он не соответствует предикату, и &lt;code&gt;null&lt;/code&gt; , если он соответствует. Объект доступен как лямбда-аргумент ( &lt;code&gt;it&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="70ae5c844919498cf5a44f8ce155a9c7029cae97" translate="yes" xml:space="preserve">
          <source>When called on lists, &lt;code&gt;addAll()&lt;/code&gt; adds new elements in the same order as they go in the argument. You can also call &lt;code&gt;addAll()&lt;/code&gt; specifying an element position as the first argument. The first element of the argument collection will be inserted at this position. Other elements of the argument collection will follow it, shifting the receiver elements to the end.</source>
          <target state="translated">При вызове списков &lt;code&gt;addAll()&lt;/code&gt; добавляет новые элементы в том же порядке, в котором они идут в аргументе. Вы также можете вызвать &lt;code&gt;addAll()&lt;/code&gt; указав позицию элемента в качестве первого аргумента. В эту позицию будет вставлен первый элемент коллекции аргументов. За ней последуют другие элементы коллекции аргументов, сдвигая элементы-получатели в конец.</target>
        </trans-unit>
        <trans-unit id="4503c0345f7f96c5163267795a01f8ff6d6296b7" translate="yes" xml:space="preserve">
          <source>When called with the default arguments, the functions return the result similar to calling &lt;code&gt;toString()&lt;/code&gt; on the collection: a &lt;code&gt;String&lt;/code&gt; of elements' string representations separated by commas with spaces.</source>
          <target state="translated">При вызове с аргументами по умолчанию, функции возвращают результат , похожий на вызов &lt;code&gt;toString()&lt;/code&gt; на коллекции: а &lt;code&gt;String&lt;/code&gt; строковых представлений элементов , разделенные запятыми с пробелами.</target>
        </trans-unit>
        <trans-unit id="4f800ac9ce646dbfd1c595ccbbdab36f597cb7a9" translate="yes" xml:space="preserve">
          <source>When called with the key present in the map, operators overwrite the values of the corresponding entries.</source>
          <target state="translated">При вызове с помощью клавиши,присутствующей на карте,операторы перезаписывают значения соответствующих записей.</target>
        </trans-unit>
        <trans-unit id="0e3f5ee2c33fac5afe961b2bc4ee6475eb75da8a" translate="yes" xml:space="preserve">
          <source>When calling Kotlin functions from Java, nobody prevents us from passing &lt;em&gt;null&lt;/em&gt; as a non-null parameter. That's why Kotlin generates runtime checks for all public functions that expect non-nulls. This way we get a &lt;code&gt;NullPointerException&lt;/code&gt; in the Java code immediately.</source>
          <target state="translated">При вызове функций Kotlin из Java никто не мешает нам передать &lt;em&gt;null&lt;/em&gt; как ненулевой параметр. Вот почему Kotlin генерирует проверки времени выполнения для всех общедоступных функций, которые ожидают ненулевых значений. Таким образом, мы сразу получаем &lt;code&gt;NullPointerException&lt;/code&gt; в коде Java.</target>
        </trans-unit>
        <trans-unit id="5bf4931382d70d2a150fc1284b61bdc2c9c96f9a" translate="yes" xml:space="preserve">
          <source>When calling a function, you can name one or more of its arguments. This may be helpful when a function has a large number of arguments, and it's difficult to associate a value with an argument, especially if it's a boolean or &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afccfc52da19240ad334120985339616ba8ee626" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; or the &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport annotation&lt;/a&gt; to assign well-defined names to the functions that you want to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66c232a7677f7941a6400aa2f6dc79238791bec" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; to assign well-defined names to the functions that you need to call.</source>
          <target state="translated">При вызове функций, написанных на Kotlin для значений &lt;code&gt;dynamic&lt;/code&gt; типа, имейте в виду, что преобразование имен выполняется компилятором Kotlin в JavaScript. Возможно, вам потребуется использовать &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;аннотацию @JsName&lt;/a&gt; для присвоения четко определенных имен функциям, которые вам нужно вызвать.</target>
        </trans-unit>
        <trans-unit id="f401901149779f5935d80aef38d169d9b80565b3" translate="yes" xml:space="preserve">
          <source>When calling this function, you don&amp;rsquo;t have to name all its arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a144ef75b391ae884d7e13a94311bf67580a2244" translate="yes" xml:space="preserve">
          <source>When chaining other functions after &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;, don't forget to perform the null check or the safe call (&lt;code&gt;?.&lt;/code&gt;) because their return value is nullable.</source>
          <target state="translated">При связывании других функций после &lt;code&gt;takeIf&lt;/code&gt; и &lt;code&gt;takeUnless&lt;/code&gt; не забудьте выполнить нулевую проверку или безопасный вызов ( &lt;code&gt;?.&lt;/code&gt; ), Потому что их возвращаемое значение может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="c0a48c6031f8ea84f7db041425c7fe40478df5e8" translate="yes" xml:space="preserve">
          <source>When compiling (we'll use this term interchangeably with &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;) to JavaScript, Kotlin outputs two main files:</source>
          <target state="translated">При компиляции (мы будем использовать этот термин взаимозаменяемо с &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;транспилированием&lt;/a&gt; ) в JavaScript, Kotlin выводит два основных файла:</target>
        </trans-unit>
        <trans-unit id="9a71722d03195d233742cd235099b2a024ee3092" translate="yes" xml:space="preserve">
          <source>When compiling Kotlin code to targets JVM 1.8 and above, you could compile non-abstract methods of Kotlin interfaces into Java's &lt;code&gt;default&lt;/code&gt; methods. For this purpose, there was a mechanism that includes the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation for marking such methods and the &lt;code&gt;-Xjvm-default&lt;/code&gt; compiler option that enables processing of this annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c097f144946019495809506583d55bf5b42ced5" translate="yes" xml:space="preserve">
          <source>When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:</source>
          <target state="translated">При компиляции с байтовыми кодами JVM компилятор оптимизирует доступ к массивам так,чтобы не возникало накладных расходов:</target>
        </trans-unit>
        <trans-unit id="d5652ef4fdb2127a183b6f70658b4242e9138b50" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, methods having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. When such a method called through framework API throws an exception, it is either propagated as &lt;code&gt;NSError&lt;/code&gt; or considered unhandled (if exception &lt;code&gt;is&lt;/code&gt;&lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; or &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt;). In any case exception is not checked to be instance of one of the &lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;.</source>
          <target state="translated">При составлении в рамках Objective-C / Swift, методы , имеющие или наследующие эту аннотацию представлены как &lt;code&gt;NSError*&lt;/code&gt; -продуцирующих методы в Objective-C и , как &lt;code&gt;throws&lt;/code&gt; методы в Swift. Когда такой метод, вызываемый через API инфраструктуры, выдает исключение, оно либо распространяется как &lt;code&gt;NSError&lt;/code&gt; , либо считается необработанным (если исключение &lt;code&gt;is&lt;/code&gt; &lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; или &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt; ). В любом случае исключение не проверяется как экземпляр одного из &lt;a href=&quot;exception-classes&quot;&gt;классов exceptionClasses&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6587d9ea4d853cd6df9a3004ea764022f98d9281" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488e4ca566eb9082ca3b6286ce0e3243bb17b8f2" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9ee7ef1045f5338ee8701cbc0ba2b21b7f1d68" translate="yes" xml:space="preserve">
          <source>When compiling to Swift or the Objective-C framework, functions that have or are inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96c28145bcb8f6ff8815136a3e9f396b218615b" translate="yes" xml:space="preserve">
          <source>When compiling, the compiler always outputs the kotlin.js file. The easiest way to reference this without having to refer to paths, is to set the output library folder for the compiler options to &lt;code&gt;node_modules&lt;/code&gt;. This way, Node will automatically pick it up as it does an exhaustive search for files under these folders</source>
          <target state="translated">При компиляции компилятор всегда выводит файл kotlin.js. Самый простой способ сослаться на это, не &lt;code&gt;node_modules&lt;/code&gt; к путям, - это установить для папки выходной библиотеки для параметров компилятора значение node_modules . Таким образом, Node автоматически подберет его, поскольку выполняет исчерпывающий поиск файлов в этих папках.</target>
        </trans-unit>
        <trans-unit id="5b6df5ad94ece159e4d2e7854f633a08ec2ced8b" translate="yes" xml:space="preserve">
          <source>When creating a new application or module that targets JavaScript, we need to select &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; as the target</source>
          <target state="translated">При создании нового приложения или модуля, ориентированного на JavaScript, нам нужно выбрать &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; в качестве цели.</target>
        </trans-unit>
        <trans-unit id="40c235de508210259df882cfb516e8a1d647fb3f" translate="yes" xml:space="preserve">
          <source>When declaring dependencies on npm packages, you are now required to explicitly specify a version or version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm&amp;rsquo;s semver syntax&lt;/a&gt;. Specifying multiple version ranges is also supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03565eec78cb8bfb0c999a9b15ff0e6c755df92b" translate="yes" xml:space="preserve">
          <source>When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</source>
          <target state="translated">При объявлении имен параметров в многострочной лямбде,поставьте имена на первую строку,затем стрелку и новую строку:</target>
        </trans-unit>
        <trans-unit id="3ef5c76bfa4e43b35f38295e1d456c70ff2408cf" translate="yes" xml:space="preserve">
          <source>When executing this run configuration, we can note that the Gradle process continues watching for changes to the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dc660c0cd261412da813263e6942fbca96f489" translate="yes" xml:space="preserve">
          <source>When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210a72ecd64e91bda5f9f64c7a09dfe81ca0e12e" translate="yes" xml:space="preserve">
          <source>When flow represents the most recent value of a variable or operation (see also the related section on &lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt;), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;combine&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ca0ed2cf53ba99dfc24939c39b34cc8182bea3" translate="yes" xml:space="preserve">
          <source>When given a &lt;code&gt;-library foo&lt;/code&gt; flag, the compiler searches the &lt;code&gt;foo&lt;/code&gt; library in the following order:</source>
          <target state="translated">Когда &lt;code&gt;-library foo&lt;/code&gt; флаг -library foo , компилятор ищет библиотеку &lt;code&gt;foo&lt;/code&gt; в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="dd5a17a3b22c6470172a587dc5be67c1d1df4d62" translate="yes" xml:space="preserve">
          <source>When given the above snippet the &lt;code&gt;cinterop&lt;/code&gt; tool will search &lt;code&gt;libfoo.a&lt;/code&gt; in &lt;code&gt;/opt/local/lib&lt;/code&gt; and &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt;, and if it is found include the library binary into &lt;code&gt;klib&lt;/code&gt;.</source>
          <target state="translated">При &lt;code&gt;cinterop&lt;/code&gt; приведенного выше фрагмента инструмент cinterop будет искать &lt;code&gt;libfoo.a&lt;/code&gt; в &lt;code&gt;/opt/local/lib&lt;/code&gt; и &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt; , и, если он будет найден, включит двоичный файл библиотеки в &lt;code&gt;klib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010f9a9f094ca37e15156897e51ac67f748d0305" translate="yes" xml:space="preserve">
          <source>When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation)</source>
          <target state="translated">При реализации интерфейса держите выполняющие члены в том же порядке,что и члены интерфейса (если необходимо,перемежайте с дополнительными закрытыми методами,используемыми для реализации)</target>
        </trans-unit>
        <trans-unit id="27dfae03dd6477eb5611a6a8eca02c237e81ed5f" translate="yes" xml:space="preserve">
          <source>When in &lt;code&gt;both&lt;/code&gt; mode, the IR compiler backend and default compiler backend are both used when building a library from your sources (hence the name). This means that both &lt;code&gt;klib&lt;/code&gt; files with Kotlin IR as well as &lt;code&gt;jar&lt;/code&gt; files for the default compiler will be generated. When published under the same Maven coordinate, Gradle will automatically choose the right artifact depending on the use case &amp;ndash; &lt;code&gt;js&lt;/code&gt; for the old compiler, &lt;code&gt;klib&lt;/code&gt; for the new one. This enables you to compile and publish your library for projects that are using either of the two compiler backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8190bf6bb340fcc1bfe9465dd44a27ec0f22ba" translate="yes" xml:space="preserve">
          <source>When installed for the first time, EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Educator&lt;/strong&gt; to enable course creation functionality:</source>
          <target state="translated">При установке в первый раз плагин EduTools спрашивает, учащийся вы или преподаватель. Выберите &amp;laquo; &lt;strong&gt;Педагог&amp;raquo;,&lt;/strong&gt; чтобы включить функцию создания курса:</target>
        </trans-unit>
        <trans-unit id="8932a8146c0a90dc2dd58707de728ef7a12acaa8" translate="yes" xml:space="preserve">
          <source>When installed for the first time, the EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Learner&lt;/strong&gt;:</source>
          <target state="translated">При первой установке плагин EduTools спрашивает, учащийся вы или преподаватель. Пожалуйста, выберите &lt;strong&gt;Ученик&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="10a5b3cb7bba7c274d069162e0ee74e696f381e7" translate="yes" xml:space="preserve">
          <source>When library headers are imported to a C program with the &lt;code&gt;#include&lt;/code&gt; directive, all of the headers included by these headers are also included in the program. So all header dependencies are included in generated stubs as well.</source>
          <target state="translated">Когда заголовки библиотеки импортируются в программу на C с помощью директивы &lt;code&gt;#include&lt;/code&gt; , все заголовки, включенные в эти заголовки, также включаются в программу. Таким образом, все зависимости заголовков также включаются в сгенерированные заглушки.</target>
        </trans-unit>
        <trans-unit id="3922383306a8a09a6b0e8b2eb8f9a1db1f1ab0db" translate="yes" xml:space="preserve">
          <source>When list elements aren't &lt;code&gt;Comparable&lt;/code&gt;, you should provide a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; to use in the binary search. The list must be sorted in ascending order according to this &lt;code&gt;Comparator&lt;/code&gt;. Let's have a look at an example:</source>
          <target state="translated">Когда элементы списка &lt;code&gt;Comparable&lt;/code&gt; , вы должны предоставить &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; для использования в двоичном поиске. Список должен быть отсортирован в порядке возрастания в соответствии с этим &lt;code&gt;Comparator&lt;/code&gt; . Давайте посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="eb20fed2a040f5bec7d775d79d512be41c67a260" translate="yes" xml:space="preserve">
          <source>When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</source>
          <target state="translated">При выборе между сложным выражением,использующим несколько функций более высокого порядка,и циклом,следует понимать стоимость выполняемых операций в каждом конкретном случае и учитывать соображения производительности.</target>
        </trans-unit>
        <trans-unit id="34a85c247b6ac08983d01a72671ac866f48daed6" translate="yes" xml:space="preserve">
          <source>When multiple children of a coroutine fail with an exception, the general rule is &quot;the first exception wins&quot;, so the first exception gets handled. All additional exceptions that happen after the first one are attached to the first exception as suppressed ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2970ac1e3a2dbc090d5bfcbffc924f278b84baec" translate="yes" xml:space="preserve">
          <source>When returning a value, the parser gives preference to the qualified return, i.e.</source>
          <target state="translated">При возврате значения парсер отдает предпочтение квалифицированному возврату,т.е.</target>
        </trans-unit>
        <trans-unit id="91e0d5690967c5e3915ccf3388a11d3d82da8814" translate="yes" xml:space="preserve">
          <source>When running this example in the browser, the DOM will be assembled in a straightforward way. This is easily confirmed by checking the Elements of the website using the developer tools of our browser:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b57a6650ec36adfcbda42de47e0a60e863df953" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the experimental API used in its body.</source>
          <target state="translated">Когда кто-то вызывает функцию &lt;code&gt;getDate()&lt;/code&gt; , он не будет проинформирован об экспериментальном API, используемом в ее теле.</target>
        </trans-unit>
        <trans-unit id="bfa8681d13a7c615930222f478ec4f7aeac79c5a" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the opt-in requirements for APIs used in its body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6f8bdf23dc342f6366d0ca972d7d991572a9e7" translate="yes" xml:space="preserve">
          <source>When supported by the platform adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">При поддержке платформы добавляет указанное исключение в список исключений,которые были подавлены,чтобы доставить это исключение.</target>
        </trans-unit>
        <trans-unit id="6393b31c82857a557e8af4f2a0be0aaf5d58b5c5" translate="yes" xml:space="preserve">
          <source>When supported by the platform, adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c40217c2fbf96f7f32af012e76efee928b75c4a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, a different plugin should be applied:</source>
          <target state="translated">При нацеливании на JavaScript должен применяться другой плагин:</target>
        </trans-unit>
        <trans-unit id="6febffb6e2904e4bbf90391b0727f1dbf05ee0c1" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlin2Js&lt;/code&gt; and &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; for custom source sets.</source>
          <target state="translated">При нацеливании на JavaScript задачи называются &lt;code&gt;compileKotlin2Js&lt;/code&gt; и &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; соответственно и &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; для пользовательских исходных наборов.</target>
        </trans-unit>
        <trans-unit id="fb89dbb9f04dc9361c7746b53e92457b21476e1a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlinJs&lt;/code&gt; and &lt;code&gt;compileTestKotlinJs&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; for custom source sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68caa257adc3424d8615357e16a81ae92f1364f3" translate="yes" xml:space="preserve">
          <source>When targeting Node.js with Kotlin/JS, we can simply execute the &lt;code&gt;run&lt;/code&gt; Gradle task. This can be done for example via the command line, using the Gradle wrapper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8307ea9f68fd265bde506b102ae1144dc569ce2b" translate="yes" xml:space="preserve">
          <source>When targeting only JavaScript, use the &lt;code&gt;kotlin-js&lt;/code&gt; plugin. &lt;a href=&quot;js-project-setup&quot;&gt;Learn more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3700a9140aca950bb22b2b6e73a90e60e275240a" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, Kotlin produces Java compatible bytecode. When targeting JavaScript, Kotlin transpiles to ES5.1 and generates code which is compatible with module systems including AMD and CommonJS. When targeting native, Kotlin will produce platform-specific code (via LLVM).</source>
          <target state="translated">При нацеливании на JVM,Котлин производит Java совместимый байткод.При таргетировании JavaScript,Kotlin переносит на ES5.1 и генерирует код,совместимый с модульными системами,включая AMD и CommonJS.При таргетинге &quot;нативного&quot; кода,Котлин производит код,специфичный для конкретной платформы (через LLVM).</target>
        </trans-unit>
        <trans-unit id="2fd9751d3f79fd88ae2a197e9ec6c24a47840b01" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, the tasks are called &lt;code&gt;compileKotlin&lt;/code&gt; for production code and &lt;code&gt;compileTestKotlin&lt;/code&gt; for test code. The tasks for custom source sets are called accordingly to the &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; pattern.</source>
          <target state="translated">При нацеливании на JVM задачи называются &lt;code&gt;compileKotlin&lt;/code&gt; для производственного кода и &lt;code&gt;compileTestKotlin&lt;/code&gt; для тестового кода. Задачи для настраиваемых исходных наборов вызываются в соответствии с шаблоном &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb9436a471e8dbc8503c3b6e6a7c9d3c34f6ebb0" translate="yes" xml:space="preserve">
          <source>When targeting the browser, our project is required to have an HTML page. This page will be served by the development server while we are working on our application, and should embed our compiled Kotlin/JS file. Create and fill an HTML file &lt;code&gt;/src/main/resources/index.html&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18755d5fafc0688db03f9113e5e8aba876e9f17" translate="yes" xml:space="preserve">
          <source>When the argument type is final, there's usually no point in generating the wildcard, so &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; is always &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt;, no matter what position it takes.</source>
          <target state="translated">Когда тип аргумента является окончательным, обычно нет смысла создавать подстановочный знак, поэтому &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; всегда является &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; , независимо от того, какую позицию он занимает.</target>
        </trans-unit>
        <trans-unit id="4260e7c630e27226c5f3f5f47519e7ba6fce2dbf" translate="yes" xml:space="preserve">
          <source>When the operands &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; or their nullable counterparts (the type is declared or inferred or is a result of a &lt;a href=&quot;typecasts#smart-casts&quot;&gt;smart cast&lt;/a&gt;), the operations on the numbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">Когда операнды &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; статически известны как &lt;code&gt;Float&lt;/code&gt; или &lt;code&gt;Double&lt;/code&gt; или их аналоги, допускающие значение NULL (тип объявлен или выведен или является результатом &lt;a href=&quot;typecasts#smart-casts&quot;&gt;умного приведения&lt;/a&gt; ), операции над числами и диапазоном, которые они формируют, соответствуют IEEE 754 Стандарт для арифметики с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="50fe39e80afdb0bafe5609ac0ee60d49bbca274d" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">Когда исходное &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;продолжение&lt;/a&gt; завершается, инфраструктура сопрограмм вызывает &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; с результирующим продолжением, если оно было перехвачено, то есть если &lt;code&gt;interceptContinuation&lt;/code&gt; ранее возвращал другой экземпляр продолжения.</target>
        </trans-unit>
        <trans-unit id="41195e5948b5d9d14accce4fb777d5a5399f88d7" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee129400c7cdc16a95ec0912c8a4fd0a5a9f195" translate="yes" xml:space="preserve">
          <source>When the processing of an &lt;code&gt;Iterable&lt;/code&gt; includes multiple steps, they are executed eagerly: each processing step completes and returns its result &amp;ndash; an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.</source>
          <target state="translated">Когда обработка &lt;code&gt;Iterable&lt;/code&gt; включает в себя несколько шагов, они выполняются с нетерпением: каждый шаг обработки завершается и возвращает свой результат - промежуточную коллекцию. Следующий шаг выполняется для этой коллекции. В свою очередь, многоступенчатая обработка последовательностей по возможности выполняется лениво: фактические вычисления происходят только тогда, когда запрашивается результат всей цепочки обработки.</target>
        </trans-unit>
        <trans-unit id="45bf077d097fcdb663238684f69205850ecd18da" translate="yes" xml:space="preserve">
          <source>When the project consists of exclusively Kotlin source code, the easiest way to compile the project is to use the &lt;em&gt;kotlinc&lt;/em&gt; task:</source>
          <target state="translated">Когда проект состоит исключительно из исходного кода Kotlin, самый простой способ скомпилировать проект - использовать задачу &lt;em&gt;kotlinc&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="de3a7fefd9c0e4fdceeb9aa1f2016defc2704512" translate="yes" xml:space="preserve">
          <source>When this annotation is placed on a generic function parameter of a function, it enables to infer the type arguments of that generic function from the lambda body passed to that parameter.</source>
          <target state="translated">Когда эта аннотация размещена на общем параметре функции,она позволяет сделать вывод об аргументах типа этой общей функции из лямбда-тела,переданного этому параметру.</target>
        </trans-unit>
        <trans-unit id="4048f5f513aab453351704d3921c71dee68c7768" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается и заканчивается заданным &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделителем&lt;/a&gt; , возвращает новую последовательность символов, в которой этот &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделитель&lt;/a&gt; удален как из начала, так и из конца. В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="71738510e58b58513693f2e894d632554b8f850d" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662d6d4b8c6d089b2ede0be25f7514459a1a7dc8" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается и заканчивается заданным &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделителем&lt;/a&gt; , возвращает новую последовательность символов, в которой этот &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделитель&lt;/a&gt; удален как из начала, так и из конца. В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="7019a5ff21fc052821e44fe7b2517fb2a7e50ce1" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3cdbdc4358626eb141b88edd210afb71fcf1c" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается и заканчивается заданным &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделителем&lt;/a&gt; , возвращает новую последовательность символов, в которой этот &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;разделитель&lt;/a&gt; удален как из начала, так и из конца. В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="1343302e14e8f4c4b12b4a77e8795e48eee2bf82" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451a99a6d4be3b4584fd97e74744059ae797634b" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается с заданного &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикса&lt;/a&gt; и заканчивается заданным &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффиксом&lt;/a&gt; , возвращает новую последовательность символов, в которой удалены и данный &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикс,&lt;/a&gt; и &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффикс&lt;/a&gt; . В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="21ec09c18e0e164102ac5fa7a001d480731fe38a" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474027059649f995528fdc9848631cfc13badca6" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается с заданного &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикса&lt;/a&gt; и заканчивается заданным &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффиксом&lt;/a&gt; , возвращает новую последовательность символов, в которой удалены и данный &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикс,&lt;/a&gt; и &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффикс&lt;/a&gt; . В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="e1059589b0f168a1d76360357b34244200d2d5f4" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f20b674cd62de8c48c773a81ba6fdddb62b434" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">Когда эта последовательность символов начинается с заданного &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикса&lt;/a&gt; и заканчивается заданным &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффиксом&lt;/a&gt; , возвращает новую последовательность символов, в которой удалены и данный &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;префикс,&lt;/a&gt; и &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;суффикс&lt;/a&gt; . В противном случае возвращает новую последовательность символов с теми же символами.</target>
        </trans-unit>
        <trans-unit id="cdb86094485044abedbde00e051a13f9d6e30f2e" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b6ffb12763bc2138c97cf448035b6d9b90a8a2" translate="yes" xml:space="preserve">
          <source>When this map already has an implicit default value provided with a former call to &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, it is being replaced by this call.</source>
          <target state="translated">Когда эта карта уже имеет неявное значение по умолчанию, предоставленное при предыдущем вызове &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt; , оно заменяется этим вызовом.</target>
        </trans-unit>
        <trans-unit id="4cb6af1ae576c542ddecdff3ea4125d59a9ee8e7" translate="yes" xml:space="preserve">
          <source>When to use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17ab536e904cdcbae105ffd675f6f9b2f2e25d6" translate="yes" xml:space="preserve">
          <source>When transforming maps, you have two options: transform keys leaving values unchanged and vice versa. To apply a given transformation to keys, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt;&lt;code&gt;mapKeys()&lt;/code&gt;&lt;/a&gt;; in turn, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt;&lt;code&gt;mapValues()&lt;/code&gt;&lt;/a&gt; transforms values. Both functions use the transformations that take a map entry as an argument, so you can operate both its key and value.</source>
          <target state="translated">При преобразовании карт у вас есть два варианта: преобразовать ключи, оставив значения неизменными, и наоборот. Чтобы применить данное преобразование к ключам, используйте &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt; &lt;code&gt;mapKeys()&lt;/code&gt; &lt;/a&gt; ; в свою очередь, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt; &lt;code&gt;mapValues()&lt;/code&gt; &lt;/a&gt; преобразует значения. Обе функции используют преобразования, которые принимают запись карты в качестве аргумента, поэтому вы можете работать как с ее ключом, так и со значением.</target>
        </trans-unit>
        <trans-unit id="8770eb3127ee3d553d5540c7c283a25cbf45081e" translate="yes" xml:space="preserve">
          <source>When two or more function overloads have otherwise the same parameter lists that differ only in the return type of a functional parameter, this annotation enables overload selection by the type of the value returned from the lambda function passed to this functional parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c33f3916421868809be7997c01c86f79f8dba67" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;, apply the Kotlin plugins using the &lt;code&gt;plugins { ... }&lt;/code&gt; block. If you apply them with &lt;code&gt;apply { plugin(...) }&lt;/code&gt; instead, you may encounter unresolved references to the extensions generated by Gradle Kotlin DSL. To resolve that, you can comment out the erroneous usages, run the Gradle task &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt;, then uncomment the usages back and rerun the build or reimport the project into the IDE.</source>
          <target state="translated">При использовании &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt; примените плагины Kotlin с помощью блока &lt;code&gt;plugins { ... }&lt;/code&gt; . Если вместо этого вы примените их с помощью &lt;code&gt;apply { plugin(...) }&lt;/code&gt; , вы можете встретить неразрешенные ссылки на расширения, созданные Gradle Kotlin DSL. Чтобы решить эту проблему, вы можете закомментировать ошибочные использования, запустить задачу Gradle &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt; , затем раскомментировать использования и повторно запустить сборку или повторно импортировать проект в IDE.</target>
        </trans-unit>
        <trans-unit id="969e0f1eba169f04310601e387fff4607230faf4" translate="yes" xml:space="preserve">
          <source>When using AMD, we set the compiler option to use AMD. Once we do that, we can then reference any modules that we've defined as if they were regular AMD ones.</source>
          <target state="translated">При использовании AMD мы устанавливаем опцию компилятора для использования AMD.После этого мы можем ссылаться на любые модули,которые мы определили как обычные AMD.</target>
        </trans-unit>
        <trans-unit id="53fe6e4bace8d3f91a163b97ab403728f060528c" translate="yes" xml:space="preserve">
          <source>When using DSLs, one might have come across the problem that too many functions can be called in the context. We can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag &lt;code&gt;head&lt;/code&gt; inside another &lt;code&gt;head&lt;/code&gt;:</source>
          <target state="translated">При использовании DSL можно было столкнуться с проблемой, что в контексте может быть вызвано слишком много функций. Мы можем назвать методы любым доступного неявного приемника внутри лямбды и , следовательно , получить противоречивый результат, как бирки &lt;code&gt;head&lt;/code&gt; внутри другую &lt;code&gt;head&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fac3c8199ff8ff114bd0a9de76148fcb9a8c3dbd" translate="yes" xml:space="preserve">
          <source>When using UMD or CommonJS, for example, your callsite could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c361123f4c7cb5fe21faa0f281e0ce914b368c3" translate="yes" xml:space="preserve">
          <source>When using a generic type where you have star-projected one or more of its type parameters, you can:</source>
          <target state="translated">При использовании общего типа,когда у вас есть звездообразный проектируемый один или несколько его типовых параметров,вы можете:</target>
        </trans-unit>
        <trans-unit id="7db42a19309e043040b1f118ec7a9ccf3b7c095b" translate="yes" xml:space="preserve">
          <source>When using an acronym as part of a declaration name, capitalize it if it consists of two letters (&lt;code&gt;IOStream&lt;/code&gt;); capitalize only the first letter if it is longer (&lt;code&gt;XmlFormatter&lt;/code&gt;, &lt;code&gt;HttpInputStream&lt;/code&gt;).</source>
          <target state="translated">При использовании аббревиатуры как части имени объявления используйте &lt;code&gt;IOStream&lt;/code&gt; если она состоит из двух букв ( IOStream ); используйте только первую букву, если она длиннее ( &lt;code&gt;XmlFormatter&lt;/code&gt; , &lt;code&gt;HttpInputStream&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3685d4fda3e975e4ad59872db610504afb8dcbd" translate="yes" xml:space="preserve">
          <source>When using if/else as an expression, the &lt;code&gt;else&lt;/code&gt; part is mandatory (but there can also be &lt;code&gt;else if&lt;/code&gt; parts). If the body that ends up being evaluated contains more than one line, it's the result of the last line that becomes the result of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">При использовании if / else в качестве выражения часть &lt;code&gt;else&lt;/code&gt; является обязательной (но также могут быть части &lt;code&gt;else if&lt;/code&gt; ). Если тело, которое в конечном итоге оценивается, содержит более одной строки, это результат последней строки, которая становится результатом &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c13d37c9e596a2177cf34971de8b2f9ef301b366" translate="yes" xml:space="preserve">
          <source>When using such &lt;code&gt;klib&lt;/code&gt; in your program, the library is linked automatically.</source>
          <target state="translated">При использовании такого &lt;code&gt;klib&lt;/code&gt; в вашей программе библиотека подключается автоматически.</target>
        </trans-unit>
        <trans-unit id="de988175b9de40e29ae018fb8ec5826b1dac85a5" translate="yes" xml:space="preserve">
          <source>When using the IR compiler, the &lt;code&gt;binaries.executable()&lt;/code&gt; instruction must be present in the &lt;code&gt;js&lt;/code&gt; target configuration block of your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;. If this option is omitted, only Kotlin-internal library files are generated. These files can be used from other projects, but not run on their own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb8f752ff8f2ca50e7eef437c4f1437c5c24a5d" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, add the compiler option &lt;code&gt;-Xuse-ir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb1fb1d8c12c86796891c59eb085c47d128eb5" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, switch to explicit API mode by adding the &lt;code&gt;-Xexplicit-api&lt;/code&gt; compiler option with the value &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acd4ad721ee61253910c4ba13a8be0c94889bbe" translate="yes" xml:space="preserve">
          <source>When we call a &lt;code&gt;vararg&lt;/code&gt;-function, we can pass arguments one-by-one, e.g. &lt;code&gt;asList(1, 2, 3)&lt;/code&gt;, or, if we already have an array and want to pass its contents to the function, we use the &lt;strong&gt;spread&lt;/strong&gt; operator (prefix the array with &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;vararg&lt;/code&gt; -функцию , мы можем передавать аргументы один за другим, например &lt;code&gt;asList(1, 2, 3)&lt;/code&gt; , или, если у нас уже есть массив и мы хотим передать его содержимое функции, мы используем &lt;strong&gt;распространение&lt;/strong&gt; оператор (префикс массива с &lt;code&gt;*&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="79dc6e08abcd7d48d398a4ca21168dbf49b9bdf0" translate="yes" xml:space="preserve">
          <source>When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</source>
          <target state="translated">Когда мы вызываем методы на переменных типа платформы,Kotlin не выдает ошибок обнуления во время компиляции,но вызов может не сработать во время выполнения из-за исключения нулевого указателя или утверждения,которое Kotlin генерирует,чтобы предотвратить распространение нулей:</target>
        </trans-unit>
        <trans-unit id="ad1fe34b679899f7dee6782797e3bf361c2fe90a" translate="yes" xml:space="preserve">
          <source>When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example</source>
          <target state="translated">Когда мы объявляем много типов в нашем списке супертипов,может показаться,что мы наследуем более одной реализации одного и того же метода.Например</target>
        </trans-unit>
        <trans-unit id="08c1783813dd9fc626a089b7cae223c9d065db16" translate="yes" xml:space="preserve">
          <source>When we have a named function declared like this:</source>
          <target state="translated">Когда у нас объявлена такая именованная функция:</target>
        </trans-unit>
        <trans-unit id="61f9a57deb03c55b45ac7741559138e62485b782" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;b&lt;/code&gt;, we can say &quot;if &lt;code&gt;b&lt;/code&gt; is not null, use it, otherwise use some non-null value&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc0820779d8db91f205b3ecbf7db0ccf41073a0" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;r&lt;/code&gt;, we can say &quot;if &lt;code&gt;r&lt;/code&gt; is not null, use it, otherwise use some non-null value &lt;code&gt;x&lt;/code&gt;&quot;:</source>
          <target state="translated">Когда у нас есть ссылка &lt;code&gt;r&lt;/code&gt; , допускающая значение NULL , мы можем сказать: &amp;laquo;Если &lt;code&gt;r&lt;/code&gt; не равно NULL, используйте его, в противном случае используйте некоторое ненулевое значение &lt;code&gt;x&lt;/code&gt; &amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="5732d17582b0ef91e5bb01d205646ae68f3db2fc" translate="yes" xml:space="preserve">
          <source>When we pass a lambda to a dynamic call, all of its parameters by default have the type &lt;code&gt;dynamic&lt;/code&gt;:</source>
          <target state="translated">Когда мы передаем лямбду динамическому вызову, все его параметры по умолчанию имеют тип &lt;code&gt;dynamic&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0be162a260a9be965f47e4e14ba8852bd8d1fa24" translate="yes" xml:space="preserve">
          <source>When we read from &lt;code&gt;p&lt;/code&gt; that delegates to an instance of &lt;code&gt;Delegate&lt;/code&gt;, the &lt;code&gt;getValue()&lt;/code&gt; function from &lt;code&gt;Delegate&lt;/code&gt; is called, so that its first parameter is the object we read &lt;code&gt;p&lt;/code&gt; from and the second parameter holds a description of &lt;code&gt;p&lt;/code&gt; itself (e.g. you can take its name). For example:</source>
          <target state="translated">Когда мы читаем из &lt;code&gt;p&lt;/code&gt; , который делегирует экземпляр &lt;code&gt;Delegate&lt;/code&gt; , &lt;code&gt;getValue()&lt;/code&gt; функция getValue () из &lt;code&gt;Delegate&lt;/code&gt; , так что ее первым параметром является объект, из которого мы читаем &lt;code&gt;p&lt;/code&gt; , а второй параметр содержит описание самого &lt;code&gt;p&lt;/code&gt; (например, вы можете взять его имя). Например:</target>
        </trans-unit>
        <trans-unit id="111d8dd13a5f3aef5861ae64c3f6c02ff4cb90bb" translate="yes" xml:space="preserve">
          <source>When working from IntelliJ IDEA, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6c6017c96852fa45cd533d083255cb214a9f4c" translate="yes" xml:space="preserve">
          <source>When wrapping chained calls, put the &lt;code&gt;.&lt;/code&gt; character or the &lt;code&gt;?.&lt;/code&gt; operator on the next line, with a single indent:</source>
          <target state="translated">При переносе цепочечных вызовов поместите расширение &lt;code&gt;.&lt;/code&gt; символ или &lt;code&gt;?.&lt;/code&gt; оператор в следующей строке с одним отступом:</target>
        </trans-unit>
        <trans-unit id="9f05d7113cc0860bca9dd1b2c8b1f2efc8346629" translate="yes" xml:space="preserve">
          <source>When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case a plain old Kotlin cast can be used, e.g.</source>
          <target state="translated">При написании кода Котлина может потребоваться преобразование объекта из типа Котлина в эквивалентный тип Swift/Objective-C (или наоборот).В этом случае может быть использовано обычное старое приведение Котлина,например.</target>
        </trans-unit>
        <trans-unit id="9cafd8bf742afb2fbc35d3c6537af8b35836e156" translate="yes" xml:space="preserve">
          <source>When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</source>
          <target state="translated">При написании библиотек рекомендуется следовать дополнительному набору правил для обеспечения стабильности API:</target>
        </trans-unit>
        <trans-unit id="d741918b948509f4aba6408fd1ef9e8a1136bd6e" translate="yes" xml:space="preserve">
          <source>When writing native applications, oftentimes we need to access certain functionality that is not included in the Kotlin standard library, such as making HTTP requests, reading and writing from disk, etc.</source>
          <target state="translated">При написании нативных приложений часто возникает необходимость доступа к определенному функционалу,не входящему в стандартную библиотеку Kotlin,например,выполнение HTTP-запросов,чтение и запись с диска и т.д.</target>
        </trans-unit>
        <trans-unit id="463d09586d01fae3ba7cf55cbbc35d4b7f20011b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;mpp-create-lib&quot;&gt;create a multiplatform project&lt;/a&gt;, the Project Wizard automatically applies the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradle plugin in the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3156a4be9cfb99131296400d8e473f56e52183c" translate="yes" xml:space="preserve">
          <source>When you are ready, verify the task with the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If you passed, there will be the &lt;strong&gt;Congratulations!&lt;/strong&gt; message:</source>
          <target state="translated">Когда вы будете готовы, подтвердите задачу с помощью значка &amp;laquo; &lt;strong&gt;Проверить&amp;raquo;&lt;/strong&gt; в верхней части панели &amp;laquo; &lt;strong&gt;Описание задачи&amp;raquo;&lt;/strong&gt; . Если вы прошли, будут &lt;strong&gt;поздравления! &lt;/strong&gt;сообщение:</target>
        </trans-unit>
        <trans-unit id="598dab40b3272c1fb9a453390cd6e6de1808ea5d" translate="yes" xml:space="preserve">
          <source>When you call a member function on &lt;code&gt;this&lt;/code&gt;, you can skip the &lt;code&gt;this.&lt;/code&gt; part. If you have a non-member function with the same name, use this with caution, because in some cases it can be called instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4f91db759426c5c027f930c965bc523e90edeb" translate="yes" xml:space="preserve">
          <source>When you call this function, the compiler will know that the execution doesn't continue beyond the call:</source>
          <target state="translated">При вызове этой функции компилятор будет знать,что выполнение не продолжается после вызова:</target>
        </trans-unit>
        <trans-unit id="ebc718bb513c3e899345e0a1f6bade26496caf51" translate="yes" xml:space="preserve">
          <source>When you choose the JavaScript target, any Kotlin code that is part of the project as well as the standard library that ships with Kotlin is transpiled to JavaScript. However, this excludes the JDK and any JVM or Java framework or library used. Any file that is not Kotlin will be ignored during compilation.</source>
          <target state="translated">При выборе JavaScript-мишени любой код Kotlin,который является частью проекта,а также стандартная библиотека,которая поставляется с Kotlin,переносится на JavaScript.Однако,это исключает JDK и любую используемую JVM или Java-фреймворк или библиотеку.Любой файл,не являющийся Kotlin,будет проигнорирован во время компиляции.</target>
        </trans-unit>
        <trans-unit id="61cb3b5bb55f1ec33f90df7914d7d8c5178a623a" translate="yes" xml:space="preserve">
          <source>When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated.</source>
          <target state="translated">При компиляции многоплатформенного проекта для определенной платформы генерируется код как для общих,так и для специфических для платформы частей.</target>
        </trans-unit>
        <trans-unit id="a4955e4afeb340ef9f82c25ba0af627acbecccfb" translate="yes" xml:space="preserve">
          <source>When you create a multiplatform project, targets are added to the &lt;code&gt;kotlin&lt;/code&gt; block in the file &lt;code&gt;build.gradle&lt;/code&gt; (&lt;code&gt;build.gradle.kts&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487f53e65f3e40a392960d7ffe8fb70d789db81a" translate="yes" xml:space="preserve">
          <source>When you create a progression implicitly by iterating a range, this progression's &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; elements are the range's endpoints, and the &lt;code&gt;step&lt;/code&gt; is 1.</source>
          <target state="translated">Когда вы создаете прогрессию неявно путем итерации диапазона, &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;last&lt;/code&gt; элементы этой прогрессии являются конечными точками диапазона, а &lt;code&gt;step&lt;/code&gt; равен 1.</target>
        </trans-unit>
        <trans-unit id="51bafee0f48839d4b74895eeb5d22b3bc95f6844" translate="yes" xml:space="preserve">
          <source>When you create own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">Когда вы создаете собственные реализации интерфейсов коллекций, вы должны реализовать их функции-члены. Чтобы упростить создание новых реализаций, используйте скелетные реализации интерфейсов коллекций из стандартной библиотеки: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt; и их изменяемые аналоги.</target>
        </trans-unit>
        <trans-unit id="de5ca0060f568734c25c44dc064e42505647a415" translate="yes" xml:space="preserve">
          <source>When you create your own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3c8353ca1e574cdd5fef24454fb4fda2fc3277" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt;s, you can do the reverse transformation &amp;ndash; &lt;em&gt;unzipping&lt;/em&gt; &amp;ndash; that builds two lists from these pairs:</source>
          <target state="translated">Когда у вас есть &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt; s, вы можете выполнить обратное преобразование - &lt;em&gt;разархивировать&lt;/em&gt; - которое строит два списка из этих пар:</target>
        </trans-unit>
        <trans-unit id="5c27d02fe0802eb2c5dc736c355913900c0370a9" translate="yes" xml:space="preserve">
          <source>When you have a variable or parameter of function type (sometimes called a &lt;em&gt;function reference&lt;/em&gt;), you can call it as if it were an ordinary function, and that will cause the referenced function to be called:</source>
          <target state="translated">Когда у вас есть переменная или параметр типа функции (иногда называемый &lt;em&gt;ссылкой&lt;/em&gt; на &lt;em&gt;функцию&lt;/em&gt; ), вы можете вызвать ее, как если бы это была обычная функция, и это приведет к вызову функции, на которую указывает ссылка:</target>
        </trans-unit>
        <trans-unit id="e1aaa92f5ddb308d5297a444696d8b7457b69a72" translate="yes" xml:space="preserve">
          <source>When you have finished creating your course, it's a good idea to view your course from a learner's perspective and test it. Right-click on the course view and go to &lt;strong&gt;Course Creator -&amp;gt; Create Course Preview&lt;/strong&gt; to open your course in learner mode:</source>
          <target state="translated">Когда вы закончите создание своего курса, рекомендуется просмотреть его с точки зрения учащегося и протестировать его. Щелкните правой кнопкой мыши представление курса и выберите &amp;laquo; &lt;strong&gt;Создатель курса&amp;raquo; -&amp;gt; &amp;laquo;Создать предварительный просмотр курса&amp;raquo;,&lt;/strong&gt; чтобы открыть курс в режиме учащегося:</target>
        </trans-unit>
        <trans-unit id="a3250cc79c522d1ac623227bb111869e351b8f95" translate="yes" xml:space="preserve">
          <source>When you run this code, you'll see that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are executed in the same order as they appear in the code. First, you see &lt;code&gt;filter:&lt;/code&gt; for all elements, then &lt;code&gt;length:&lt;/code&gt; for the elements left after filtering, and then the output of the two last lines. This is how the list processing goes:</source>
          <target state="translated">Когда вы запустите этот код, вы увидите, что функции &lt;code&gt;filter()&lt;/code&gt; и &lt;code&gt;map()&lt;/code&gt; выполняются в том же порядке, в каком они появляются в коде. Сначала вы видите &lt;code&gt;filter:&lt;/code&gt; для всех элементов, затем &lt;code&gt;length:&lt;/code&gt; для элементов, оставшихся после фильтрации, а затем вывод двух последних строк. Вот как происходит обработка списка:</target>
        </trans-unit>
        <trans-unit id="05ad4ed8cb6fd5863366c2a4f1abcdd6e5010b48" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following with the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6928284bef91c96791612dd21e00cae5d64a5053" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">Когда вы &lt;code&gt;also&lt;/code&gt; видите в коде, вы можете прочитать это как &amp;laquo; &lt;em&gt;а также сделать следующее&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8d24e43a2e1296ae8492ad2425aad4e306037e84" translate="yes" xml:space="preserve">
          <source>When you switch to Kotlin, your xml layout files don't change at all. For instance, you use &lt;code&gt;variable&lt;/code&gt; within &lt;code&gt;data&lt;/code&gt; to describe a variable that may be used within the layout. You can declare a variable of a Kotlin type:</source>
          <target state="translated">Когда вы переключаетесь на Kotlin, ваши файлы макета xml вообще не меняются. Например, вы используете &lt;code&gt;variable&lt;/code&gt; в &lt;code&gt;data&lt;/code&gt; для описания переменной, которая может использоваться в макете. Вы можете объявить переменную типа Kotlin:</target>
        </trans-unit>
        <trans-unit id="1239262e94d3c7df345c600c729ad2ad431b78a5" translate="yes" xml:space="preserve">
          <source>When you take an interface or an open class as a parameter, you generally don't know the real type of the parameter at runtime, since it could be an instance of a subclass or of any class that implements the interface. It is possible to check what the exact type is, but like in Python, you should generally avoid it and instead design your class hierarchy such that you can do what you need by proper overriding of functions or properties.</source>
          <target state="translated">Когда вы берете в качестве параметра интерфейс или открытый класс,вы обычно не знаете реального типа параметра во время выполнения,так как это может быть экземпляр подкласса или любого класса,реализующего интерфейс.Можно проверить,что именно является типом,но,как и на Python,вы обычно должны избегать этого и вместо этого построить иерархию классов таким образом,чтобы вы могли делать то,что вам нужно,должным образом переопределяя функции или свойства.</target>
        </trans-unit>
        <trans-unit id="08daa6c22199d25d4c67e8e2145164a79b9c18ed" translate="yes" xml:space="preserve">
          <source>When you use an API in the code intended for third-party use (a library), you can propagate its opt-in requirement to your API as well. To do this, annotate your declaration with the &lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;opt-in requirement annotation&lt;/em&gt;&lt;/a&gt; of the API used in its body. This enables you to use the API elements marked with this annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7fe00cf3644a358da554d74666746417284178" translate="yes" xml:space="preserve">
          <source>When you use an arithmetic operator on two integers of different types, the result is &quot;upgraded&quot; to the widest type. Note that the result might still overflow.</source>
          <target state="translated">При использовании арифметического оператора на двух целых числах разных типов результат &quot;обновляется&quot; до самого широкого типа.Обратите внимание,что результат все равно может переполниться.</target>
        </trans-unit>
        <trans-unit id="3c62a163cbef716d256d43a2d19d876bb12a78c5" translate="yes" xml:space="preserve">
          <source>When you use an experimental API in the code intended for third-party use (a library), you can mark your API as experimental as well. To do this, annotate your declaration with the &lt;em&gt;experimental marker annotation&lt;/em&gt; of the API used in its body. This enables you to use the API elements annotated with this marker.</source>
          <target state="translated">Если вы используете экспериментальный API в коде, предназначенном для стороннего использования (библиотека), вы также можете пометить свой API как экспериментальный. Для этого аннотируйте свое объявление &lt;em&gt;экспериментальной аннотацией маркера&lt;/em&gt; API, используемого в его теле. Это позволяет использовать элементы API, помеченные этим маркером.</target>
        </trans-unit>
        <trans-unit id="06b65a21854b89868579d67b03180df54f3544a9" translate="yes" xml:space="preserve">
          <source>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values you can just leave them out altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d4e3a5ba4e31277cb9f0e61d2e54f709bf8961" translate="yes" xml:space="preserve">
          <source>When you're annotating a property or a primary constructor parameter, there are multiple Java elements which are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:</source>
          <target state="translated">При аннотации свойства или параметра первичного конструктора,существует несколько Java-элементов,которые генерируются из соответствующего элемента Котлин,и,следовательно,несколько возможных мест для аннотации в генерируемом Java-байткоде.Чтобы указать,как именно должна быть сгенерирована аннотация,используйте следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="b61884cef7d3f26b08581a78b91851698ab0fd2b" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;jvmMain&lt;/code&gt; is compiled for a certain target, &lt;code&gt;commonMain&lt;/code&gt; takes part in that compilation as well and is also compiled into the same target binary form, such as JVM class files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ad1e4f32412313aa6f0bd650dfc39dcb173e7f" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified.</source>
          <target state="translated">Каждый раз, когда он вызывается для одного и того же объекта более одного раза, метод &lt;code&gt;hashCode&lt;/code&gt; должен последовательно возвращать одно и то же целое число, при условии, что никакая информация, используемая в &lt;code&gt;equals&lt;/code&gt; сравнениях для объекта, не изменяется.</target>
        </trans-unit>
        <trans-unit id="55d78075233bceac802e1984993c3d3b3088601f" translate="yes" xml:space="preserve">
          <source>Whenever you create an instance of this class, you must specify an actual type in place of &lt;code&gt;T&lt;/code&gt;, unless the compiler can infer it from the constructor parameters: &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; or &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt;. Every use of this instance will act as if it were an instance of a class that looks like this:</source>
          <target state="translated">Каждый раз, когда вы создаете экземпляр этого класса, вы должны указывать фактический тип вместо &lt;code&gt;T&lt;/code&gt; , если компилятор не может вывести его из параметров конструктора: &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; или &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt; . Каждое использование этого экземпляра будет действовать так, как если бы это был экземпляр класса, который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="8ca39f6f0f111844ff04d02c9f4bf0efee656845" translate="yes" xml:space="preserve">
          <source>Whenever you use an arithmetic operator on two integers of the same type (or when you use a unary operator like negation), &lt;em&gt;there is no automatic &quot;upgrading&quot; if the result doesn't fit in the type of the operands!&lt;/em&gt; Try this:</source>
          <target state="translated">Когда вы используете арифметический оператор над двумя целыми числами одного типа (или когда вы используете унарный оператор, например отрицание), &lt;em&gt;не происходит автоматического &amp;laquo;обновления&amp;raquo;, если результат не соответствует типу операндов! &lt;/em&gt;Попробуй это:</target>
        </trans-unit>
        <trans-unit id="b65896c2c2c1091be4cf3076a04d4d7b1bc8f223" translate="yes" xml:space="preserve">
          <source>Whenever you want a variable that can only take on a limited number of values where the only feature of each value is that it's distinct from all the other values, you can create an &lt;em&gt;enum class&lt;/em&gt;:</source>
          <target state="translated">Если вам нужна переменная, которая может принимать только ограниченное количество значений, где единственной особенностью каждого значения является то, что оно отличается от всех других значений, вы можете создать &lt;em&gt;класс перечисления&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b72a1d211e3475b177a16c0ad833aad00f45de47" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;__TYPE__&lt;/code&gt; is one of the simple type names and &lt;code&gt;__CTYPE__&lt;/code&gt; is the related Objective-C type, e.g. &lt;code&gt;initWithChar(char)&lt;/code&gt;.</source>
          <target state="translated">Где &lt;code&gt;__TYPE__&lt;/code&gt; - одно из имен простых типов, а &lt;code&gt;__CTYPE__&lt;/code&gt; - связанный тип Objective-C, например &lt;code&gt;initWithChar(char)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279ee64e67a8a3e973e45233e8ce0a407cbaf608" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;declarationToKeep&lt;/code&gt; has the following syntax:</source>
          <target state="translated">Где &lt;code&gt;declarationToKeep&lt;/code&gt; имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="eb06827a60ce404697c981082d7a9ff58779079e" translate="yes" xml:space="preserve">
          <source>Where can I get an HD Kotlin logo?</source>
          <target state="translated">Где я могу получить логотип HD Kotlin?</target>
        </trans-unit>
        <trans-unit id="00d532d7604042ff0388fc0d8b327eb21555113f" translate="yes" xml:space="preserve">
          <source>Where can I learn more about Kotlin?</source>
          <target state="translated">Где я могу узнать больше о Котлине?</target>
        </trans-unit>
        <trans-unit id="60dc3003b0157a1bb3a0084a1e562958004b1c24" translate="yes" xml:space="preserve">
          <source>Whether a main function should be called</source>
          <target state="translated">Должна ли вызываться основная функция</target>
        </trans-unit>
        <trans-unit id="350fceb3b43601161521c9570f080755bec5203a" translate="yes" xml:space="preserve">
          <source>Whether metadata file with binary descriptors should be generated</source>
          <target state="translated">Должен ли файл метаданных с бинарными дескрипторами быть сгенерирован</target>
        </trans-unit>
        <trans-unit id="b1689158ae06f88b863b7fd9b887d675c25f4bd4" translate="yes" xml:space="preserve">
          <source>Whether sourcemap file should be generated</source>
          <target state="translated">Должен ли быть сгенерирован файл исходного кода</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c668af734b8bab593fb373580041499369e8214b" translate="yes" xml:space="preserve">
          <source>Which versions of JVM does Kotlin target?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02402c88e9d606c5d9042e0b0c12d1739344aeb9" translate="yes" xml:space="preserve">
          <source>While Kotlin annotations look like Python decorators, they are far less flexible: they can generally only be used for metadata. They are pure data-containing classes, and do not contain any executable code. Some built-in annotations have an effect on the compilation process (such as &lt;code&gt;@JvmStatic&lt;/code&gt;), but custom annotations are only useful for providing metadata that can be inspected at runtime by the reflection system. We won't delve deeply into annotations here, but here is an example. The annotations on the annotation declaration itself specify what constructs the annotation may be applied to and whether it is available for runtime inspection.</source>
          <target state="translated">Хотя аннотации Kotlin выглядят как декораторы Python, они гораздо менее гибкие: обычно их можно использовать только для метаданных. Это чистые классы, содержащие данные, и они не содержат исполняемого кода. Некоторые встроенные аннотации влияют на процесс компиляции (например, &lt;code&gt;@JvmStatic&lt;/code&gt; ), но пользовательские аннотации полезны только для предоставления метаданных, которые могут быть проверены во время выполнения системой отражения. Мы не будем здесь углубляться в аннотации, но вот пример. Аннотации в самом объявлении аннотации указывают, к каким конструкциям аннотация может применяться и доступна ли она для проверки во время выполнения.</target>
        </trans-unit>
        <trans-unit id="a68a67a970d91d390715c4a5723442211582200e" translate="yes" xml:space="preserve">
          <source>While Loops</source>
          <target state="translated">Пока петли</target>
        </trans-unit>
        <trans-unit id="c1b7c19248a78707f3905a80fc2242e3ecc22b20" translate="yes" xml:space="preserve">
          <source>While being different, conceptually, Flow &lt;em&gt;is&lt;/em&gt; a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by &lt;code&gt;kotlinx.coroutines&lt;/code&gt; out-of-the-box and can be found in corresponding reactive modules (&lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; for Reactive Streams, &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; for Project Reactor and &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt;/&lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; for RxJava2/RxJava3). Integration modules include conversions from and to &lt;code&gt;Flow&lt;/code&gt;, integration with Reactor's &lt;code&gt;Context&lt;/code&gt; and suspension-friendly ways to work with various reactive entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178ea4ef9776a99f280cbce3c37b6808c99bffb3" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, it does not scale well for larger projects with hundreds of files and libraries. For real-world projects it is recommended to use a &lt;a href=&quot;using-gradle&quot;&gt;build system&lt;/a&gt; and &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405a10cf31f596bca1e965bfbd41f2ec04a34af9" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, we should notice, that it does not scale well for bigger projects with hundreds of files and libraries. In addition to this, the command line approach does not explain to an IDE how to open such a project, where the sources are located, what dependencies are used, or how the dependencies are downloaded and so on.</source>
          <target state="translated">Хотя компиляция из консоли кажется простой и понятной,следует заметить,что она не очень хорошо масштабируется для больших проектов с сотнями файлов и библиотек.Кроме того,подход с использованием командной строки не объясняет IDE,как открыть такой проект,где находятся исходники,какие используются зависимости,как загружаются зависимости и так далее.</target>
        </trans-unit>
        <trans-unit id="1e744f3d4d9082a8982116fd4e4676866618d662" translate="yes" xml:space="preserve">
          <source>While cross-platform compilation is possible, which means using one platform to compile for a different one, in this case we'll be targeting the same platform we're compiling on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce105800554de67a92cb5eed4d6aabf562edfb9" translate="yes" xml:space="preserve">
          <source>While doing so was not useful in this particular example, one could get interesting effects by adding an unprojected parameter type &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt;, in which case the generic type parameter of &lt;code&gt;via&lt;/code&gt; would be forced to be &quot;in-between&quot; those of &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">Хотя в данном конкретном примере это было бесполезно, можно было бы получить интересные эффекты, добавив непроектируемый тип параметра &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt; , и в этом случае параметр универсального типа для &lt;code&gt;via&lt;/code&gt; будет вынужден быть &amp;laquo;промежуточным&amp;raquo; параметрами для &lt;code&gt;from&lt;/code&gt; и &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74f25352205ca76e991ebde88bff4a464449ff37" translate="yes" xml:space="preserve">
          <source>While it is possible in Kotlin to dynamically create new classes at runtime or to add members to a class, it's tricky and slow, and generally discouraged. However, it is easy to dynamically inspect an object to see e.g. what properties and functions it contains and which annotations exist on them. This is called &lt;em&gt;reflection&lt;/em&gt;, and it's not very performant, so avoid it unless you really need it.</source>
          <target state="translated">Хотя в Kotlin можно динамически создавать новые классы во время выполнения или добавлять члены в класс, это сложно, медленно и обычно не рекомендуется. Однако легко динамически проверять объект, чтобы увидеть, например, какие свойства и функции он содержит и какие аннотации существуют для них. Это называется &lt;em&gt;отражением&lt;/em&gt; , и оно не очень производительно, поэтому избегайте его, если оно вам действительно не нужно.</target>
        </trans-unit>
        <trans-unit id="00ebcc3032e38c0f9dbd212c37ea7b7605032b6f" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">Хотя можно использовать командную строку либо напрямую, либо путем объединения ее с файлом сценария (например, файлом sh или bat), мы должны заметить, что она плохо масштабируется для больших проектов с сотнями файлов и библиотек. Тогда лучше использовать компилятор Kotlin / Native с системой сборки, поскольку он помогает загружать и кэшировать двоичные файлы и библиотеки компилятора Kotlin / Native с транзитивными зависимостями, а также запускать компилятор и тесты. Kotlin / Native может использовать систему сборки &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; через плагин &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccb7cdd4315f54dc22cc954a705304d8025d4496" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4688c1c9cfee712dab9268862c4aa04c7274850f" translate="yes" xml:space="preserve">
          <source>While it was already possible to extract this variable just before &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;when&lt;/code&gt; has its scope properly restricted to the body of &lt;code&gt;when&lt;/code&gt;, and so preventing namespace pollution. See the full documentation on &lt;code&gt;when&lt;/code&gt;&lt;a href=&quot;control-flow#when-expression&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Хотя уже было возможно извлечь эту переменную непосредственно перед &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;when&lt;/code&gt; имеет свою область действия, правильно ограниченную телом &lt;code&gt;when&lt;/code&gt; , что предотвращает загрязнение пространства имен. См. Полную документацию о &lt;code&gt;when&lt;/code&gt; &lt;a href=&quot;control-flow#when-expression&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18fc211f02fff65fa62198ec0d6b2196f5fda852" translate="yes" xml:space="preserve">
          <source>While most IDE's including &lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; can generate the corresponding Gradle file, we're going to take a look at how to create this manually, to have a better understanding of how things work under the covers. If you'd like to use the IDE, check out &lt;a href=&quot;using-intellij-idea&quot;&gt;Using IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf1dfe40b0f0a7f06896b58374c31b6b8d9a056" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.2 to Kotlin 1.3</source>
          <target state="translated">Хотя большинство изменений языка уже было объявлено по другим каналам,таким как обновление журналов изменений или предупреждения компилятора,в этом документе все они обобщены,давая полную ссылку на миграцию с Kotlin 1.2 на Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="b3798978e8389c22f139d4b97896bde1b7b9685d" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.3 to Kotlin 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399ba37d2ce977b9a644dbef3594c75ca535f65a" translate="yes" xml:space="preserve">
          <source>While the above solution works well for situations in which we have a corresponding header file (be this something we've defined ourselves or converted from a TypeScript header), often times we need to work with some library that does not have a header. For instance, let's say we want to use a jQuery plugin, that allows us to convert an HTML table to a nice looking navigable grid.</source>
          <target state="translated">Хотя вышеприведенное решение хорошо работает в ситуациях,когда у нас есть соответствующий заголовочный файл (будь то определенный нами самими или преобразованный из заголовка TypeScript),часто нам приходится работать с какой-то библиотекой,не имеющей заголовка.Например,скажем,мы хотим использовать плагин jQuery,который позволяет нам конвертировать таблицу HTML в красивую навигационную сетку.</target>
        </trans-unit>
        <trans-unit id="7193542d5cd6b24f8c9a4e41a255c37b1a878838" translate="yes" xml:space="preserve">
          <source>While the converter is not fool-proof, it does a pretty decent job of converting most boilerplate code from Java to Kotlin. Some manual tweaking however is sometimes required.</source>
          <target state="translated">Несмотря на то,что конвертер не защищен от дураков,он делает довольно приличную работу по преобразованию большинства кодов boilerplate из Java в Kotlin.Однако иногда требуется ручная настройка.</target>
        </trans-unit>
        <trans-unit id="d3c9392710d351a08ea5a20fd29014ffdd0dc8f8" translate="yes" xml:space="preserve">
          <source>While the dots suggest that packages are nested inside each other, that's not actually the case from a language standpoint. While it's a good idea to organize your code such that the &quot;subpackages&quot; of &lt;code&gt;content&lt;/code&gt;, such as &lt;code&gt;content.exercises&lt;/code&gt; and &lt;code&gt;content.articles&lt;/code&gt;, both contain content-related code, these three packages are unrelated from a language standpoint. However, if you use &lt;em&gt;modules&lt;/em&gt; (as defined by your build system), it is typically the case that all &quot;subpackages&quot; go in the same module, in which case symbols with &lt;a href=&quot;visibility-modifiers&quot;&gt;&lt;code&gt;internal&lt;/code&gt; visibility&lt;/a&gt; are visible throughout the subpackages.</source>
          <target state="translated">Хотя точки предполагают, что пакеты вложены друг в друга, на самом деле это не так с точки зрения языка. Хотя неплохо организовать свой код таким образом, чтобы &amp;laquo;подпакеты&amp;raquo; &lt;code&gt;content&lt;/code&gt; , такие как &lt;code&gt;content.exercises&lt;/code&gt; и &lt;code&gt;content.articles&lt;/code&gt; , содержали связанный с контентом код, эти три пакета не связаны с языковой точки зрения. Однако, если вы используете &lt;em&gt;модули&lt;/em&gt; (как определено вашей системой сборки), обычно все &amp;laquo;подпакеты&amp;raquo; помещаются в один и тот же модуль, и в этом случае символы с &lt;a href=&quot;visibility-modifiers&quot;&gt; &lt;code&gt;internal&lt;/code&gt; видимостью&lt;/a&gt; видны во всех подпакетах.</target>
        </trans-unit>
        <trans-unit id="6f4289b089753c293140e137503818ca7bef2f53" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself and the Gradle build system require a Java 1.8 or 11 runtime. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or another resource for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">Хотя выходные данные компилятора не имеют никаких зависимостей или требований к виртуальной машине, для самого компилятора и системы сборки Gradle требуется среда выполнения Java 1.8 или 11. Посетите &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; или другой ресурс, чтобы узнать о лучшем распространении JRE, OpenJDK или JDK.</target>
        </trans-unit>
        <trans-unit id="10c2d0246f094d4009ab7bad0367365f4bcc7c84" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself requires &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8 or higher runtime&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d621226a511f26c66770b36d29a5c867fde780" translate="yes" xml:space="preserve">
          <source>While this example happened to use the same expression, that is not necessary - overloaded functions can do completely different things if need be (although your code can get confusing if you make functions that have very different behavior be overloads of each other).</source>
          <target state="translated">Хотя в этом примере случайно использовалось одно и то же выражение,в этом нет необходимости-перегруженные функции при необходимости могут делать совершенно разные вещи (хотя ваш код может запутаться,если вы сделаете функции,которые имеют очень разное поведение,перегрузками друг друга).</target>
        </trans-unit>
        <trans-unit id="68ab041f58d77da2145ef925bbf99b70a47a9c63" translate="yes" xml:space="preserve">
          <source>While uploading your library to Bintray, you will see multiple versions for each artifact (such as &lt;code&gt;my-library-jvm&lt;/code&gt;, &lt;code&gt;my-library-metadata&lt;/code&gt;, etc.). To fix this, add &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt;. See &lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;this issue&lt;/a&gt; for details. This is a common Gradle 6.0 issue that is neither MPP nor Kotlin specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d4507848ac2db4dd040b8f1b98e137154ce676" translate="yes" xml:space="preserve">
          <source>While we don&amp;rsquo;t recommend it, you can use a wildcard &lt;code&gt;*&lt;/code&gt; in place of a version number if you do not want to specify a version or version range explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79482c24120b8d210f4051a8c238d3feb29fa237" translate="yes" xml:space="preserve">
          <source>Who develops Kotlin?</source>
          <target state="translated">Кто разрабатывает Котлин?</target>
        </trans-unit>
        <trans-unit id="6b8ca7e4bd278a327d17a1ff62cc87137c652d74" translate="yes" xml:space="preserve">
          <source>Why Kotlin/Native?</source>
          <target state="translated">Почему Котлин/Натив?</target>
        </trans-unit>
        <trans-unit id="5327cb3e3f7820311f240e8254b2120a882043dc" translate="yes" xml:space="preserve">
          <source>Why not just add required manifest options to all Kotlin libraries</source>
          <target state="translated">Почему бы просто не добавить необходимые опции манифеста во все библиотеки Kotlin.</target>
        </trans-unit>
        <trans-unit id="dc289721e21b7419371258307342fbd161fffe25" translate="yes" xml:space="preserve">
          <source>Wildcard-types</source>
          <target state="translated">Wildcard-types</target>
        </trans-unit>
        <trans-unit id="1a6e732a37845c36fcda3afa6f1ba0d920b0ebca" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers</source>
          <target state="translated">WindowEventHandlers</target>
        </trans-unit>
        <trans-unit id="0be6c8c411ba30d8cffb7e90ca7acef58e77aa71" translate="yes" xml:space="preserve">
          <source>WindowLocalStorage</source>
          <target state="translated">WindowLocalStorage</target>
        </trans-unit>
        <trans-unit id="4695cae95157eec4a2f36b8710914191b7160a60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope</source>
          <target state="translated">WindowOrWorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="837e70bad69f4bf6bd4622325d1fb73918d9e99b" translate="yes" xml:space="preserve">
          <source>WindowSessionStorage</source>
          <target state="translated">WindowSessionStorage</target>
        </trans-unit>
        <trans-unit id="7d22ecce0385c959845f551d5a3b5ab183398dfa" translate="yes" xml:space="preserve">
          <source>Windowed</source>
          <target state="translated">Windowed</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="628596087f96fc1704310fa20e91f817ad0907ae" translate="yes" xml:space="preserve">
          <source>Windows (mingw x86_64, x86)</source>
          <target state="translated">Windows (mingw x86_64,x86)</target>
        </trans-unit>
        <trans-unit id="3501a24aebe2c74160390742479cffed6294f769" translate="yes" xml:space="preserve">
          <source>Windows targets require a Windows host;</source>
          <target state="translated">Для достижения целей Windows необходим хост Windows;</target>
        </trans-unit>
        <trans-unit id="ce9d44e441b23e1629b147f917e9518ae0913959" translate="yes" xml:space="preserve">
          <source>Windows: &lt;code&gt;libnative_api.h&lt;/code&gt;, &lt;code&gt;libnative_symbols.def&lt;/code&gt; and &lt;code&gt;libnative.dll&lt;/code&gt;</source>
          <target state="translated">Windows: &lt;code&gt;libnative_api.h&lt;/code&gt; , &lt;code&gt;libnative_symbols.def&lt;/code&gt; и &lt;code&gt;libnative.dll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a374d672ab75b4235e338c90ddfcf6afbecca5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes course creation for an educator. If you want to use EduTools plugin for learning, read &lt;a href=&quot;edu-tools-learner&quot;&gt;&quot;Learning Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">С &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;помощью&lt;/a&gt; плагина EduTools вы можете изучать и обучать Kotlin с помощью задач по отработке кода. Он доступен как в &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio, так&lt;/a&gt; и в &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; . В этом руководстве описывается создание курса для преподавателя. Если вы хотите использовать плагин EduTools для обучения, прочтите &lt;a href=&quot;edu-tools-learner&quot;&gt;&amp;laquo;Изучение Kotlin с помощью плагина EduTools&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e4afdf3ca90295d086cf8bfcf9a9049903e7a2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes the interactive learning. If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;&quot;Teaching Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">С &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;помощью&lt;/a&gt; плагина EduTools вы можете изучать и обучать Kotlin с помощью задач по отработке кода. Он доступен как в &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio, так&lt;/a&gt; и в &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; . В этом руководстве описывается интерактивное обучение. Если вы хотите использовать плагин EduTools для обучения, прочтите &lt;a href=&quot;edu-tools-educator&quot;&gt;&amp;laquo;Обучение Kotlin с помощью плагина EduTools&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddbee1008f9f20e446d88d4f79956907a6b4c399" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;the new hierarchical project structure support&lt;/a&gt;, you can share code among several targets in a multiplatform project. You can use platform-dependent libraries, such as &lt;code&gt;Foundation&lt;/code&gt;, &lt;code&gt;UIKit&lt;/code&gt;, and &lt;code&gt;posix&lt;/code&gt; in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c32707acceb3a92d660aaa2664e3b3b359ee59" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;let&lt;/code&gt;, you can rewrite it:</source>
          <target state="translated">С &lt;code&gt;let&lt;/code&gt; вы можете его переписать:</target>
        </trans-unit>
        <trans-unit id="af688b954f4540e476c35b0f74f11c5204100c85" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lisa&lt;/code&gt; and &lt;code&gt;anne&lt;/code&gt; from the infix example, you can now do:</source>
          <target state="translated">С &lt;code&gt;lisa&lt;/code&gt; и &lt;code&gt;anne&lt;/code&gt; из примера инфикса теперь вы можете:</target>
        </trans-unit>
        <trans-unit id="32acfa5cff03b7f1ee491ea16213412942069586" translate="yes" xml:space="preserve">
          <source>With Gradle 6.0 and above, you are now able to load all scripts at once as opposed to the previous implementation where they were loaded individually. Since each request requires the Gradle configuration phase to be executed, this could be resource-intensive for large Gradle projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2bc622686f7933d6457fe256aa33e7162dce61a" translate="yes" xml:space="preserve">
          <source>With Gradle Kotlin DSL, configure source sets with &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; instead.</source>
          <target state="translated">С Gradle Kotlin DSL настройте исходные наборы с помощью &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="bf21fbd8ac94a33fdcdb64a0972b9b5c1c2c5132" translate="yes" xml:space="preserve">
          <source>With Gradle metadata enabled, an additional 'root' publication named &lt;code&gt;kotlinMultiplatform&lt;/code&gt; is added to the project's publications. The default artifact ID of this publication matches the project name without any additional suffix. To configure this publication, access it via the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL of the &lt;code&gt;maven-publish&lt;/code&gt; plugin:</source>
          <target state="translated">При включенных метаданных Gradle к публикациям &lt;code&gt;kotlinMultiplatform&lt;/code&gt; добавляется дополнительная &amp;laquo;корневая&amp;raquo; публикация с именем kotlinMultiplatform . Идентификатор артефакта по умолчанию этой публикации соответствует имени проекта без дополнительного суффикса. Чтобы настроить эту публикацию, войдите в нее через DSL &lt;code&gt;publishing { ... }&lt;/code&gt; плагина &lt;code&gt;maven-publish&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cfc45b937026fd4fbaf26509635a71da2f380172" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.3, it is possible to mark members of a &lt;code&gt;companion&lt;/code&gt; object of interfaces with annotations &lt;code&gt;@JvmStatic&lt;/code&gt; and &lt;code&gt;@JvmField&lt;/code&gt;. In the classfile, such members will be lifted to the corresponding interface and marked as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">В Kotlin 1.3 можно пометить элементы &lt;code&gt;companion&lt;/code&gt; объекта интерфейсов аннотациями &lt;code&gt;@JvmStatic&lt;/code&gt; и &lt;code&gt;@JvmField&lt;/code&gt; . В файле класса такие члены будут перенесены в соответствующий интерфейс и помечены как &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b65590d91561b1b8e789678b4dd06427d7909a3" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4 you can now add a trailing comma in enumerations such as argument and parameter lists, &lt;code&gt;when&lt;/code&gt; entries, and components of destructuring declarations. With a trailing comma, you can add new items and change their order without adding or removing commas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492f25a9a5171ae34e810e40b21b2cb1efcdaaeb" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4, you can use the new tools in IntelliJ IDEA to simplify Kotlin development:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed9b754f624185d343cb02b0b8d34dd9ae4ed13" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4.0, we are shipping the first stable version of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt; - 1.0.0-RC. Now we are pleased to declare the JSON serialization API in &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; (previously known as &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt;) stable. Libraries for other serialization formats remain experimental, along with some advanced parts of the core library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6d7af5fe3aafc8094b8a2cfd86e6ef8192a99f" translate="yes" xml:space="preserve">
          <source>With Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;multiplatform&lt;/a&gt; projects, it is possible to share the same Kotlin code between all the supported platforms. Check out the tutorial on &lt;a href=&quot;mpp-ios-android&quot;&gt;sharing Kotlin code between iOS and Android&lt;/a&gt; or have a look at how to build your own &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;../../reference/multiplatform&quot;&gt;мультиплатформенных&lt;/a&gt; проектах Kotlin можно использовать один и тот же код Kotlin для всех поддерживаемых платформ. Ознакомьтесь с руководством по &lt;a href=&quot;mpp-ios-android&quot;&gt;обмену кодом Kotlin между iOS и Android&lt;/a&gt; или узнайте, как создать свою собственную &lt;a href=&quot;../multiplatform-library&quot;&gt;многоплатформенную библиотеку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63565c10375a2623a1558273ad959c355a70e5ce" translate="yes" xml:space="preserve">
          <source>With Kotlin Gradle DSL, the sections of predefined source sets should be marked &lt;code&gt;by getting&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7fe3c48a3cadc6919466836bffd195ba2a63be" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform libraries, you can reuse the multiplatform logic in common and platform-specific code. Common code can rely on a set of libraries that cover everyday tasks such as &lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;serialization&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;managing coroutines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3221afc2f20039e82884001a629bfe8610d1ab" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, share the code using the mechanisms Kotlin provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbab2d42979bafe508a0df0d9f59300200f67c7" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, spend less time on writing and maintaining the same code for &lt;a href=&quot;mpp-supported-platforms&quot;&gt;different platforms&lt;/a&gt; &amp;ndash; just share it using the mechanisms Kotlin provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e972123cd69ffcab96ad056c6c91d5aacf5be07" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, you can share the code using the mechanisms Kotlin provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3962fde44c4aec537b82dcd2abfc22db4cc626fa" translate="yes" xml:space="preserve">
          <source>With a value of 1, walker visits only the origin directory and all its immediate children, with a value of 2 also grandchildren, etc.</source>
          <target state="translated">При значении 1 ходячий посещает только каталог происхождения и всех его ближайших детей,при значении 2 также внуков и т.д.</target>
        </trans-unit>
        <trans-unit id="ef51393788d21d74c116e9c29eea336ed0a6d471" translate="yes" xml:space="preserve">
          <source>With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.</source>
          <target state="translated">При обратных вызовах,идея заключается в передаче одной функции в качестве параметра другой функции,и вызов этой функции после завершения процесса.</target>
        </trans-unit>
        <trans-unit id="016040b5eae4bf27f5a939a1b5c8156662185437" translate="yes" xml:space="preserve">
          <source>With collections and functions, polymorphism becomes more complicated - see the section on &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">С коллекциями и функциями полиморфизм усложняется - см. Раздел о &lt;a href=&quot;generics&quot;&gt;дженериках&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1dcb9e12e7f211f30c8a5176d8ae68de49c58b9" translate="yes" xml:space="preserve">
          <source>With either version of the import, you can now simply do:</source>
          <target state="translated">С любой из версий импорта теперь можно просто сделать:</target>
        </trans-unit>
        <trans-unit id="fe95a6fd3800d1f0d89afcda519d105e6e6110b2" translate="yes" xml:space="preserve">
          <source>With function literals, local functions and object expression, functions can be nested in Kotlin. Qualified &lt;em&gt;return&lt;/em&gt;s allow us to return from an outer function. The most important use case is returning from a lambda expression. Recall that when we write this:</source>
          <target state="translated">С помощью функциональных литералов, локальных функций и объектных выражений функции могут быть вложены в Kotlin. Квалифицированные &lt;em&gt;return&lt;/em&gt; позволяют нам вернуться из внешней функции. Самый важный вариант использования - возврат из лямбда-выражения. Напомним, когда мы пишем это:</target>
        </trans-unit>
        <trans-unit id="eb6ed75ff29820dbdcda23941139d4c1d4ba7dd2" translate="yes" xml:space="preserve">
          <source>With named arguments we can make the code much more readable:</source>
          <target state="translated">С помощью именованных аргументов мы можем сделать код намного более читабельным:</target>
        </trans-unit>
        <trans-unit id="3450c7c71d6bf1ddf49a4323aca70311d456d430" translate="yes" xml:space="preserve">
          <source>With that, our project should now build and produce the corresponding artifacts.</source>
          <target state="translated">При этом наш проект должен теперь строить и производить соответствующие артефакты.</target>
        </trans-unit>
        <trans-unit id="355ad4d87e7870b0c272b188aa3ef65d4dc920f9" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can learn Kotlin through code practicing tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b14af153f14d3f9734df37394a46678fa4ba5c" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can teach Kotlin through code practicing tasks. Take a look at the &lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;Educator Start Guide&lt;/a&gt; to learn how to create a simple Kotlin course that includes a set of programming tasks and integrated tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5382fb55641e05a034b3ea5d0c0d4be768aee31" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; interface from the standard library, you can create delegate providers without creating new classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dadda346a2629bde84d619a153f6df49f573d66b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;cancellable&lt;/code&gt; operator only the numbers from 1 to 3 are collected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f45b301e2a74f1dd5893d4a531ceba47efa69ee" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin &lt;strong&gt;source&lt;/strong&gt;&lt;strong&gt;sets&lt;/strong&gt; are also used to group sources but source files for different platforms are located in different source sets. For each declared target two source sets are created: &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; and &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; containing product and test sources for this platform. Common for all platforms sources are located in &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; source sets created by default. More information about source sets can be found &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">С &lt;code&gt;kotlin-multiplatform&lt;/code&gt; &lt;strong&gt;наборы &lt;/strong&gt;&lt;strong&gt;исходных &lt;/strong&gt;текстов плагинов также используются для группировки источников, но исходные файлы для разных платформ расположены в разных исходных наборах. Для каждой объявленной цели создаются два исходных набора: &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; и &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; , содержащие продукты и тестовые источники для этой платформы. Общие для всех платформ исходные &lt;code&gt;commonMain&lt;/code&gt; расположены в &lt;code&gt;commonTest&lt;/code&gt; источников commonMain и commonTest, созданных по умолчанию. Более подробную информацию об исходных наборах можно найти &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;здесь&lt;/a&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5d94234e74f15ed4145669bdb5e37f9dfb14ae3" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin a compilation always produces a &lt;code&gt;*.klib&lt;/code&gt; file. A separate &lt;code&gt;binaries&lt;/code&gt; block is used to configure what final native binaries should be produced by each target. Each binary can be configured independently including linker options, executable entry point etc.</source>
          <target state="translated">С &lt;code&gt;kotlin-multiplatform&lt;/code&gt; при компиляции всегда &lt;code&gt;*.klib&lt;/code&gt; файл * .klib . Отдельный блок &lt;code&gt;binaries&lt;/code&gt; используется для настройки того, какие окончательные собственные двоичные файлы должны создаваться каждой целью. Каждый двоичный файл можно настроить независимо, включая параметры компоновщика, точку входа исполняемого файла и т. Д.</target>
        </trans-unit>
        <trans-unit id="c6cb3a91147cfe093062a0839b721e658dabc4bd" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin interops are configured as a part of a compilation (see details &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;here&lt;/a&gt;). The rest of an interop configuration is the same as for the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin.</source>
          <target state="translated">С помощью &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin взаимодействия настраиваются как часть компиляции (подробности см. &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;Здесь&lt;/a&gt; ). Остальная часть конфигурации взаимодействия такая же, как и для &lt;code&gt;kotlin-platform-native&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1706d3b6b7ce15bdbf71dc7c9e04a857f530061f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin target platforms can be added into a project using special methods available in the &lt;code&gt;kotlin&lt;/code&gt; extension. Each method adds into a project one &lt;strong&gt;target&lt;/strong&gt; which can be accessed using the &lt;code&gt;targets&lt;/code&gt; property. Each target can be configured independently including output kinds, additional compiler options etc. See details about targets at the &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;corresponding page&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;kotlin-multiplatform&lt;/code&gt; целевые платформы могут быть добавлены в проект с помощью специальных методов, доступных в расширении &lt;code&gt;kotlin&lt;/code&gt; . Каждый метод добавляет в проекте одной &lt;strong&gt;цели&lt;/strong&gt; , которые могут быть доступны с помощью &lt;code&gt;targets&lt;/code&gt; свойства. Каждую цель можно настроить независимо, включая типы вывода, дополнительные параметры компилятора и т. Д. Подробную информацию о целях см. На &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;соответствующей странице&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71022b4d02eeeda0e92ce39399dff9342c3334b7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin a set of target platforms is specified as a list in properties of the main component:</source>
          <target state="translated">В &lt;code&gt;kotlin-platform-native&lt;/code&gt; набор целевых платформ указывается в виде списка в свойствах основного компонента:</target>
        </trans-unit>
        <trans-unit id="6a03f6034b00496a7bad530da3196155a72cc860" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin dependencies are configured in a traditional for Gradle way by grouping them into configurations using the project &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">С помощью &lt;code&gt;kotlin-platform-native&lt;/code&gt; зависимости настраиваются традиционным для Gradle способом, группируя их в конфигурации с помощью блока &lt;code&gt;dependencies&lt;/code&gt; проекта :</target>
        </trans-unit>
        <trans-unit id="e33e92feed8df1d895d9a97b45aacf36671d526c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin interop with a native library can be declared in component dependencies:</source>
          <target state="translated">С помощью &lt;code&gt;kotlin-platform-native&lt;/code&gt; взаимодействие с собственной библиотекой может быть объявлено в зависимостях компонентов:</target>
        </trans-unit>
        <trans-unit id="a97bf25e776050662c47b29cee8cd98d22ea2c1d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin output kinds are specified as a list in properties of a component:</source>
          <target state="translated">В &lt;code&gt;kotlin-platform-native&lt;/code&gt; типы вывода указываются в виде списка в свойствах компонента:</target>
        </trans-unit>
        <trans-unit id="32e186967f7559f8d4cf421fcfd2faf96d838898" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin source sets are used to separate test and product sources. Also you can specify different sources for different platforms in the same source set:</source>
          <target state="translated">С &lt;code&gt;kotlin-platform-native&lt;/code&gt; наборы исходных плагиных используются для разделения тестовых и производственных источников. Также вы можете указать разные источники для разных платформ в одном наборе источников:</target>
        </trans-unit>
        <trans-unit id="7fa674450fbd80d59d43844df0d5a16d3f6b263d" translate="yes" xml:space="preserve">
          <source>With the coroutine debugger, you can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b0fbf80a9fbc5a69ad66b25c87ece38e49f33b" translate="yes" xml:space="preserve">
          <source>With the flexible new Kotlin Project Wizard, you have a place to easily create and configure different types of Kotlin projects, including multiplatform projects, which can be difficult to configure without a UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c6c878f4a74b6cd56b16a6f707da3f34b03dce" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following declarations for our C functions:</source>
          <target state="translated">С помощью объявления &lt;em&gt;Goto&lt;/em&gt; или ошибок компилятора IntelliJ IDEA мы видим следующие объявления для наших функций C:</target>
        </trans-unit>
        <trans-unit id="cf252d7abb4fe418f54b8621d262b977ba904b60" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions, &lt;code&gt;struct&lt;/code&gt;, and &lt;code&gt;union&lt;/code&gt;:</source>
          <target state="translated">С помощью &lt;em&gt;декларации Goto&lt;/em&gt; или ошибок компилятора IntelliJ IDEA мы видим следующий сгенерированный API для наших функций, &lt;code&gt;struct&lt;/code&gt; и &lt;code&gt;union&lt;/code&gt; C :</target>
        </trans-unit>
        <trans-unit id="874119f71c620e91c1bb9c2e75fd174caab63b63" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions:</source>
          <target state="translated">С помощью &lt;em&gt;декларации Goto&lt;/em&gt; или ошибок компилятора IntelliJ IDEA мы видим следующий сгенерированный API для наших функций C:</target>
        </trans-unit>
        <trans-unit id="566c1425784d4c2e6ede1f7dfe672ee70373f129" translate="yes" xml:space="preserve">
          <source>With the new &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;&lt;code&gt;@JsExport&lt;/code&gt;&lt;/a&gt; annotation and the ability to &lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;generate TypeScript definitions&lt;/a&gt; from Kotlin code&lt;/strong&gt;, the Kotlin/JS IR compiler backend improves JavaScript &amp;amp; TypeScript interoperability. This also makes it easier to integrate Kotlin/JS code with existing tooling, to create &lt;strong&gt;hybrid applications&lt;/strong&gt; and leverage code-sharing functionality in multiplatform projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc753b11e4bb4891a70a654bb57daca9017fc7f" translate="yes" xml:space="preserve">
          <source>With the new hierarchical project structure support, you can share code among &lt;a href=&quot;mpp-supported-platforms&quot;&gt;several platforms&lt;/a&gt; in a &lt;a href=&quot;mpp-discover-project&quot;&gt;multiplatform project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574c1c740a16fa65a0f397005ee3b1c60f44325d" translate="yes" xml:space="preserve">
          <source>With these features, you can make your Gradle build file much more concise and easy to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c0b9fe68cd1e4b20ebebcee0ed1689356c0a07" translate="yes" xml:space="preserve">
          <source>With these helpers, the part of code for reading input becomes simpler, closely following the input specification in the problem statement line by line:</source>
          <target state="translated">С помощью этих помощников часть кода для чтения входа становится проще,внимательно следя за входной спецификацией в постановке задачи построчно:</target>
        </trans-unit>
        <trans-unit id="a228c17a745863a462bf780050c335cd1bf004e4" translate="yes" xml:space="preserve">
          <source>With these two interfaces, we can make a more versatile fruit bowl. The bowl itself needs to both produce and consume its generic type, so it can neither be covariant nor contravariant, but it can implement our covariant and contravariant interfaces:</source>
          <target state="translated">С помощью этих двух интерфейсов мы можем сделать более универсальную чашу для фруктов.Сама по себе чаша должна как производить,так и потреблять фрукты своего генерического типа,поэтому она не может быть ни ковариантной,ни противопоказательной,но может реализовать наши ковариантные и противопоказательные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="4a7d204c839bbeda2e10e199023fa5b9c64dcb76" translate="yes" xml:space="preserve">
          <source>With this external declaration, you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments, where the default values are calculated by the JavaScript implementation of &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d67501a892da363116927ae13a84e4aecbce70" translate="yes" xml:space="preserve">
          <source>With this mechanism, a common source set defines an &lt;em&gt;expected declaration&lt;/em&gt;, and platform source sets must provide the &lt;em&gt;actual declaration&lt;/em&gt; that corresponds to the expected declaration. This works for most Kotlin declarations, such as functions, classes, interfaces, enumerations, properties, and annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717e11f293d4b13a9a59d035d72d380a87efce32" translate="yes" xml:space="preserve">
          <source>With this setup, we can access elements of our DOM. To access the properties of the &lt;code&gt;input&lt;/code&gt; field, we invoke &lt;code&gt;getElementById&lt;/code&gt; and cast it to &lt;code&gt;HTMLInputElement&lt;/code&gt;. We can then safely access its properties, such as &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b77f41d3f8979c93fc79a64e556733e4160ef4" translate="yes" xml:space="preserve">
          <source>With this setup, we can recompile our project after each code change to see our changes. Kotlin/JS also supports a more convenient way of automatically rebuilding our application while we are developing it. To find out how to set up this &lt;em&gt;continuous mode&lt;/em&gt;, check out the &lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;corresponding tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9928576b159a395a58ce4f2d7b6c66f40874468" translate="yes" xml:space="preserve">
          <source>With this, we can then access any of the functionality defined inside &lt;code&gt;customerBL&lt;/code&gt;.</source>
          <target state="translated">После этого мы можем получить доступ к любой из функций, определенных внутри &lt;code&gt;customerBL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dacc9ec11c6c308f4e37da6d574002e02a0ff3a" translate="yes" xml:space="preserve">
          <source>Without the curly braces, only the first line is a part of the body. Indentation in Kotlin matters only for human readers, so the second print is outside the if and will always be executed.</source>
          <target state="translated">Без фигурных скобок только первая линия является частью тела.Отпечаток в Котлине имеет значение только для читателей,поэтому второй отпечаток находится вне &quot;если&quot; и всегда будет выполнен.</target>
        </trans-unit>
        <trans-unit id="d2ecf10500acdd56e5aa15cdc3d632f4d1b83484" translate="yes" xml:space="preserve">
          <source>Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:</source>
          <target state="translated">Без этой возможности перехватить привязку между свойством и его делегатом,для достижения той же самой функциональности вам пришлось бы явно передавать имя свойства,что не очень удобно:</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="b539d8a8b3ce433f937b71658160ff7e5f64cd4c" translate="yes" xml:space="preserve">
          <source>Worker that &lt;a href=&quot;value&quot;&gt;value&lt;/a&gt; is bound to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a502b8bb9786901c6dc61e82d98c92b4b73ae927" translate="yes" xml:space="preserve">
          <source>WorkerBoundReference</source>
          <target state="translated">WorkerBoundReference</target>
        </trans-unit>
        <trans-unit id="74a0d635bad8cb921832f022e80f37a47e5b135d" translate="yes" xml:space="preserve">
          <source>WorkerLocation</source>
          <target state="translated">WorkerLocation</target>
        </trans-unit>
        <trans-unit id="315e6d0000af41369aa07e54a100988d3fd17dee" translate="yes" xml:space="preserve">
          <source>WorkerNavigator</source>
          <target state="translated">WorkerNavigator</target>
        </trans-unit>
        <trans-unit id="2c80abf6e395bd6f326cb30a261f19ee445cba02" translate="yes" xml:space="preserve">
          <source>WorkerOptions</source>
          <target state="translated">WorkerOptions</target>
        </trans-unit>
        <trans-unit id="87bb291b389446f9344ad088d8d62a7a62a19eca" translate="yes" xml:space="preserve">
          <source>WorkerType</source>
          <target state="translated">WorkerType</target>
        </trans-unit>
        <trans-unit id="b6ef3acd0f91c0c6e2a6bad2692c8aa84dfc4c73" translate="yes" xml:space="preserve">
          <source>Workers</source>
          <target state="translated">Workers</target>
        </trans-unit>
        <trans-unit id="4854bbfffb40975ef729e9def93b58f75765479a" translate="yes" xml:space="preserve">
          <source>Workers with message passing</source>
          <target state="translated">Работники с передачей сообщений</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="7323cd213254c74db3a887f36bfadb481e7d4c0e" translate="yes" xml:space="preserve">
          <source>Working on all platforms is an explicit goal for Kotlin, but we see it as a premise to a much more important goal: sharing code between platforms. With support for JVM, Android, JavaScript, iOS, Linux, Windows, Mac and even embedded systems like STM32, Kotlin can handle any and all components of a modern application. And this brings the invaluable benefit of reuse for code and expertise, saving the effort for tasks more challenging than implementing everything twice or multiple times.</source>
          <target state="translated">Работа на всех платформах-это явная цель для Kotlin,но мы рассматриваем ее как предпосылку для гораздо более важной цели:обмена кодом между платформами.С поддержкой JVM,Android,JavaScript,iOS,Linux,Windows,Mac и даже встроенных систем,таких как STM32,Kotlin может справиться с любыми и всеми компонентами современного приложения.И это приносит неоценимую пользу повторного использования кода и опыта,экономя усилия на задачах,более сложных,чем реализация всего вдвое или в несколько раз.</target>
        </trans-unit>
        <trans-unit id="f538870f3ed8ccb71b1f28d4023b06274de86076" translate="yes" xml:space="preserve">
          <source>Working with Build Tools</source>
          <target state="translated">Работа со строительными инструментами</target>
        </trans-unit>
        <trans-unit id="4c5d22ef62b4e454bd0bf1e1374aa13390ad7ed1" translate="yes" xml:space="preserve">
          <source>Working with C strings</source>
          <target state="translated">Работа с C-струнами</target>
        </trans-unit>
        <trans-unit id="9ac89fee8e06569c4ebc756f83cddf2bbd9a8ca8" translate="yes" xml:space="preserve">
          <source>Working with Enum Constants</source>
          <target state="translated">Работа с Enum Constants</target>
        </trans-unit>
        <trans-unit id="1f8482b2bf142fad82a2f635e71a135183f56a5d" translate="yes" xml:space="preserve">
          <source>Working with JavaScript</source>
          <target state="translated">Работа с JavaScript</target>
        </trans-unit>
        <trans-unit id="8fc3285c1f9933f649e39499a1f3946c5619cf72" translate="yes" xml:space="preserve">
          <source>Working with Kotlin and JavaScript Modules</source>
          <target state="translated">Работа с Kotlin и JavaScript модулями</target>
        </trans-unit>
        <trans-unit id="9a49aac8293420ff01c5e9c031ff773d05799074" translate="yes" xml:space="preserve">
          <source>Working with nulls</source>
          <target state="translated">Работа с нулями</target>
        </trans-unit>
        <trans-unit id="e5c0c5bddfae833279acedcc9a537af19daf0f06" translate="yes" xml:space="preserve">
          <source>Working with tasks</source>
          <target state="translated">Работа с задачами</target>
        </trans-unit>
        <trans-unit id="7d46e00971b365b4ef3386294882d7496a7f75ed" translate="yes" xml:space="preserve">
          <source>Working with the Command Line Compiler</source>
          <target state="translated">Работа с компилятором командной строки</target>
        </trans-unit>
        <trans-unit id="f2a7db7b02d37c7f54b499213bb3a991f17a1744" translate="yes" xml:space="preserve">
          <source>Working with the strings</source>
          <target state="translated">Работа со струнами</target>
        </trans-unit>
        <trans-unit id="075cb3c4378fe512dd51ed618315bfebed19ab49" translate="yes" xml:space="preserve">
          <source>Worksheets automatically get access to classes and functions from the module where they reside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298b3785e2ae406d29010843be91172dd4b7a909" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="translated">Оборачивает указанное &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;действие&lt;/a&gt; в &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc7e6a2c63b3a339c10a75fe3c57e0e79aab2702" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask(kotlin.Function1((java.util.TimerTask,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2525837a1ad8d7e8a649a7a5e6c45999c5553523" translate="yes" xml:space="preserve">
          <source>Write &lt;strong&gt;full, type-safe React applications with Kotlin/JS&lt;/strong&gt; using the &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;&lt;code&gt;kotlin-wrappers&lt;/code&gt;&lt;/a&gt; provided by JetBrains, which provide convenient abstractions and deep integrations for one of the most popular JavaScript frameworks. &lt;code&gt;kotlin-wrappers&lt;/code&gt; also provides support for a select number of adjacent technologies like &lt;code&gt;react-redux&lt;/code&gt;, &lt;code&gt;react-router&lt;/code&gt;, or &lt;code&gt;styled-components&lt;/code&gt;. Interoperability with the JavaScript ecosystem also means that you can also use third-party React components and component libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7df02929ed6ce55a8f16204596caaf82c53075" translate="yes" xml:space="preserve">
          <source>Write operations</source>
          <target state="translated">Операции записи</target>
        </trans-unit>
        <trans-unit id="16f06037425e5570c7fb6c4cb0b8e9b025bb037c" translate="yes" xml:space="preserve">
          <source>Write the application</source>
          <target state="translated">Написать заявление</target>
        </trans-unit>
        <trans-unit id="5c829704c2a3eee8b986648971ed06cb5f976567" translate="yes" xml:space="preserve">
          <source>Write your code in the scratch and click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear opposite the lines of your code.</source>
          <target state="translated">Напишите свой код на пустом месте и нажмите &amp;laquo; &lt;strong&gt;Выполнить&amp;raquo;&lt;/strong&gt; . Результаты выполнения появятся напротив строк вашего кода.</target>
        </trans-unit>
        <trans-unit id="d5a79e41535865d72222565d75328e9ec50eab15" translate="yes" xml:space="preserve">
          <source>Writeable Objective-C properties overriding read-only properties of the superclass are represented as &lt;code&gt;setFoo()&lt;/code&gt; method for the property &lt;code&gt;foo&lt;/code&gt;. Same goes for a protocol's read-only properties that are implemented as mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96451968bc66bdb3ac0027e8c45718ed0567089" translate="yes" xml:space="preserve">
          <source>Writing output in Kotlin is usually straightforward with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;println(&amp;hellip;)&lt;/a&gt; calls and using Kotlin's &lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;string templates&lt;/a&gt;. However, care must be taken when output contains on order of 10&lt;sup&gt;5&lt;/sup&gt; lines or more. Issuing so many &lt;code&gt;println&lt;/code&gt; calls is too slow, since the output in Kotlin is automatically flushed after each line. A faster way to write many lines from an array or a list is using &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;joinToString()&lt;/a&gt; function with &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the separator, like this:</source>
          <target state="translated">Написание вывода в Kotlin обычно не вызывает &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;затруднений&lt;/a&gt; с вызовами println (&amp;hellip;) и использованием &lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;строковых шаблонов&lt;/a&gt; Kotlin . Однако следует проявлять осторожность, если вывод содержит порядка 10 &lt;sup&gt;5&lt;/sup&gt; строк или более. Выдача такого количества вызовов &lt;code&gt;println&lt;/code&gt; происходит слишком медленно, поскольку вывод в Kotlin автоматически сбрасывается после каждой строки. Более быстрый способ записать много строк из массива или списка - использовать &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;функцию joinToString ()&lt;/a&gt; с &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в качестве разделителя, например:</target>
        </trans-unit>
        <trans-unit id="ab2816d4bb9622be7220e5163963f6a9c487ee4d" translate="yes" xml:space="preserve">
          <source>Writing tests</source>
          <target state="translated">Тесты на написание</target>
        </trans-unit>
        <trans-unit id="9ef22deec2645bc05aadf8f135a7bff939813776" translate="yes" xml:space="preserve">
          <source>Written common tests which are executed on every platform.</source>
          <target state="translated">Написаны общие тесты,которые выполняются на каждой платформе.</target>
        </trans-unit>
        <trans-unit id="fd2be2d7287c5cdb16fe41c84b1e6ca191ff755e" translate="yes" xml:space="preserve">
          <source>Wrong common supertype between raw and integer literal type leads to unsound code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854c8fc48ee154c6555f79a9bf3716b40f710db3" translate="yes" xml:space="preserve">
          <source>Wrong emission withContext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541421193abf48f2287369752c7bf0243245c291" translate="yes" xml:space="preserve">
          <source>Wrong overload resolution for contravariant types with nullable type arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f216eec525b148735e7bf76a9146b212361d45a9" translate="yes" xml:space="preserve">
          <source>Wrote common tests which are executed on every platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc69ef99140607442e7db36f023118fd57bd0f0" translate="yes" xml:space="preserve">
          <source>X64</source>
          <target state="translated">X64</target>
        </trans-unit>
        <trans-unit id="c5b176396b5ad771a343d5324e35e073e54c2249" translate="yes" xml:space="preserve">
          <source>X86</source>
          <target state="translated">X86</target>
        </trans-unit>
        <trans-unit id="5fff9cda50156cd056976ef35552984685930eca" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestResponseType</source>
          <target state="translated">XMLHttpRequestResponseType</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
