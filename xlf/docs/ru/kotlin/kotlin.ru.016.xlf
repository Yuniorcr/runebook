<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / собственные &lt;a href=&quot;native/platform_libs&quot;&gt;библиотеки&lt;/a&gt; помогают делиться кодом Kotlin между проектами. POSIX, gzip, OpenGL, Metal, Foundation и многие другие популярные библиотеки и фреймворки Apple предварительно импортированы и включены как библиотеки Kotlin / Native в пакет компилятора.</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Плагин Котлин/Отрицательная Колыбель</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">Котлин/Отрицательные прогонные декларации</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native также тесно интегрирован с технологиями Apple. &lt;a href=&quot;apple-framework&quot;&gt;Котлин / Native как компания Apple Framework&lt;/a&gt; учебник объясняет , как компилировать код Котлин в качестве основы для Swift и Objective-C.</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native также тесно интегрирован с Objective-C и Swift. Он описан в учебнике &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">Котлин/Отрицательное как динамическая библиотека</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">Котлин/Отрицательное в качестве основы Apple.</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native можно использовать для многих &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;целей&lt;/a&gt; и приложений, включая, помимо прочего, macOS, Windows, Linux и &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; , инструмент генерирует привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробная информация обсуждается в учебнике &amp;laquo; &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Взаимодействие с библиотеками C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; ; инструмент создает привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробно об этом можно &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;прочитать в&lt;/a&gt; учебнике &amp;laquo; Взаимодействие с библиотеками C.</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native поставляется с инструментом &lt;code&gt;cinterop&lt;/code&gt; ; инструмент создает привязки между языком C и Kotlin. Он использует файл &lt;code&gt;.def&lt;/code&gt; , чтобы указать библиотеку C для импорта. Более подробно об этом можно &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;прочитать в&lt;/a&gt; учебнике &amp;laquo; Взаимодействие с библиотеками C. Самый быстрый способ опробовать сопоставление C API - иметь все объявления C в файле &lt;code&gt;interop.def&lt;/code&gt; , вообще не создавая никаких файлов &lt;code&gt;.h&lt;/code&gt; или &lt;code&gt;.c&lt;/code&gt; . Затем поместите объявления C в файл &lt;code&gt;interop.def&lt;/code&gt; после специальной строки разделителя &lt;code&gt;---&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Компилятор Kotlin / Native может создавать динамическую библиотеку из имеющегося у нас кода Kotlin. Динамическая библиотека часто поставляется с файлом заголовка, файлом &lt;code&gt;.h&lt;/code&gt; , который мы будем использовать для вызова скомпилированного кода из C.</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Компилятор Kotlin/Native может создать фреймворк для макросов и iOS из кода Kotlin.Созданный фреймворк содержит все объявления и двоичные файлы,необходимые для использования его с Objective-C и Swift.Лучший способ понять эти приемы-попробовать их самим.Сначала создадим крошечную библиотеку Kotlin и будем использовать ее из программы Objective-C.</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">Котлин/Национальный для коренных жителей</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native поддерживает двунаправленное взаимодействие с языками Objective-C и Swift. Объекты Kotlin интегрируются с подсчетом ссылок Objective-C / Swift. Неиспользуемые объекты Kotlin автоматически удаляются. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; статья содержит больше информации о деталях реализации Interop. Конечно, можно импортировать существующий фреймворк и использовать его из Kotlin. Kotlin / Native поставляется с хорошим набором предварительно импортированных системных фреймворков.</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">В Kotlin / Native есть сборка мусора, но она не помогает нам справляться с объектами Kotlin из языка C. Kotlin / Native взаимодействует с Objective-C и Swift и интегрируется с их счетчиками ссылок. В статье документации &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; содержится более подробная информация об этом. Также есть учебник &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native реализует строгие проверки изменчивости, обеспечивая важный инвариант, что объект либо неизменяем, либо доступен из одного потока в данный момент времени ( &lt;code&gt;mutable XOR global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Взаимодействие Kotlin / Native со Swift и Objective-C описано в статье &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;документации&lt;/a&gt; . Кроме того, эта же тема рассматривается в учебнике &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native как Apple Framework&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">Котлин/Отрицательная совместимость</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Котлин/Отрицательная совместимость со Swift/Объект-C</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native - это технология компиляции кода Kotlin в собственные двоичные файлы, которые могут работать без виртуальной машины. Это &lt;a href=&quot;https://llvm.org/&quot;&gt;серверная часть на&lt;/a&gt; основе LLVM для компилятора Kotlin и собственная реализация стандартной библиотеки Kotlin.</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native в настоящее время находится &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;в разработке&lt;/a&gt; . Он компилирует Kotlin в собственный код, который может работать без виртуальной машины. Выпущена предварительная версия Technology Preview, но она еще не готова к производству и еще не нацелена на все платформы, которые мы планируем поддерживать в версии 1.0. Для получения дополнительной информации ознакомьтесь с &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;сообщением&lt;/a&gt; в блоге, в котором анонсируется Kotlin / Native .</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native в первую очередь предназначен для компиляции для платформ, на которых &lt;em&gt;виртуальные машины&lt;/em&gt; нежелательны или невозможны, например для встроенных устройств или iOS. Он решает ситуации, когда разработчику необходимо создать автономную программу, не требующую дополнительной среды выполнения или виртуальной машины.</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">Котлин/Национальные библиотеки</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin/Native библиотеки-это zip-файлы,содержащие предопределенную структуру каталогов,со следующей раскладкой:</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Для плагина Kotlin / Native требуется более новая версия Gradle, давайте &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; и используем следующий &lt;code&gt;distrubutionUrl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native обеспечивает двунаправленную совместимость с Objective-C / Swift. В коде Kotlin можно использовать фреймворки и библиотеки Objective-C. Модули Kotlin также можно использовать в коде Swift / Objective-C. Кроме того, в Kotlin / Native есть &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt; . Существует также руководство по &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native как динамической библиотеке&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native обеспечивает двустороннюю совместимость с Objective-C. Фреймворки и библиотеки Objective-C можно использовать в коде Kotlin, если они правильно импортированы в сборку (системные фреймворки импортируются по умолчанию). См., Например, &amp;laquo;Использование cinterop&amp;raquo; в &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;документации плагина Gradle&lt;/a&gt; . Библиотеку Swift можно использовать в коде Kotlin, если ее API экспортируется в Objective-C с помощью &lt;code&gt;@objc&lt;/code&gt; . Модули Pure Swift пока не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native предоставляет нам возможность использовать стандартные библиотеки C, открывая целую экосистему функциональности, которая существует практически для всего, что нам может понадобиться. Фактически, Kotlin / Native уже поставляется с набором предварительно созданных &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;библиотек платформы,&lt;/a&gt; которые предоставляют некоторые дополнительные общие функции по сравнению со стандартной библиотекой.</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin/Native не поощряет классическую потоково-ориентированную параллельную модель с взаимоисключающими блоками кода и условными переменными,так как эта модель,как известно,подвержена ошибкам и ненадежна.Вместо этого мы предлагаем набор альтернативных подходов,позволяющих использовать аппаратное совпадение и реализовывать блокировку ввода-вывода.Эти подходы являются следующими и будут рассмотрены в последующих разделах:</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">Котлин/Отрицательные источники и примеры</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Котлин/Отрицательные источники и примеры (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Котлин/Отрицательные источники и примеры (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native также поддерживает взаимодействие C. Ознакомьтесь с руководством по &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native как динамической библиотеке&lt;/a&gt; для этого или посмотрите статью документации &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin/Native поддерживает следующие платформы:</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin/Native поддерживает двустороннее взаимодействие с родным миром.С одной стороны,компилятор создает:</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">Пресеты Kotlin / Native target (см. &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;Примечания&lt;/a&gt; ниже):</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Цели Kotlin / Native не требуют дополнительных тестовых зависимостей, а &lt;code&gt;kotlin.test&lt;/code&gt; API kotlin.test являются встроенными.</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native использует систему сборки &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; через плагин &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; . Ниже мы рассмотрим, как настроить сборку Gradle. В некоторых случаях компилятор Kotlin / Native все еще можно получить вручную (не рекомендуется) со &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;страницы выпусков Kotlin на GitHub&lt;/a&gt; . В этом руководстве мы сосредоточены на использовании сборок Gradle.</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">Приложение KotlinConf Spinner</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">приложение KotlinConf</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">Выражения лямбды и анонимные функции</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">синтаксис выражения лямбда</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Выражения Лямбда и анонимные функции являются &quot;функциональными литералами&quot;,т.е.функциями,которые не объявляются,а передаются немедленно в качестве выражения.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Лямбда-выражения и анонимные функции вместе называются &lt;em&gt;функциональными литералами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">Лямбда-выражения могут использоваться как функциональные литералы с приемником, когда тип приемника может быть выведен из контекста. Один из наиболее важных примеров их использования - &lt;a href=&quot;type-safe-builders&quot;&gt;типобезопасные компоновщики&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">лямбда-форматирование</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">параметры лямбды</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">результат лямбда</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">Языковые настройки</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">Языковые настройки исходного набора влияют на то,как источники анализируются в IDE.В связи с существующими ограничениями,в сборке Gradle используются только языковые настройки исходного набора компиляции по умолчанию,которые применяются ко всем источникам,участвующим в компиляции.</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">Свойства и переменные с задержкой инициализированные</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Латеинитные свойства верхнего уровня и локальные переменные</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">Лениво начал асинхронизировать</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">ленивое имущество</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">Бассейн знаний</target>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">Учебный Котлин</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">Учебный Котлин с плагином EduTools</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">Оставьте для остальных параметров значения по умолчанию и нажмите &lt;strong&gt;Готово&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">У нас будет два производителя струн: &lt;code&gt;fizz&lt;/code&gt; и &lt;code&gt;buzz&lt;/code&gt; . &lt;code&gt;fizz&lt;/code&gt; производит строку &amp;laquo;Fizz&amp;raquo; каждые 300 мс:</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">Давайте тысячу раз запустим сотню корутингов,делающих одно и то же действие.Мы также измерим время их завершения для дальнейших сравнений:</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">Давайте объединим наши знания о контекстах, детях и работе. Предположим, что у нашего приложения есть объект с жизненным циклом, но этот объект не является сопрограммой. Например, мы пишем приложение для Android и запускаем различные сопрограммы в контексте активности Android для выполнения асинхронных операций по выборке и обновлению данных, анимации и т. Д. Все эти сопрограммы должны быть отменены при уничтожении активности, чтобы избежать утечки памяти. , Мы, конечно, можем манипулировать контекстами и заданиями вручную, чтобы связать жизненные &lt;code&gt;kotlinx.coroutines&lt;/code&gt; действий и сопрограмм, но kotlinx.coroutines предоставляет абстракцию, которая инкапсулирует это: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . Вы должны быть уже знакомы с областью видимости сопрограмм, поскольку все построители сопрограмм объявлены на ней как расширения.</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">Давайте прогоним все семь раз:</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">Давайте начнем с дюжины из них со случайной задержкой.</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">Давайте возьмем &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent на примере async&lt;/a&gt; и &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; функцию, которая одновременно выполняет doSomethingUsefulOne и &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; и возвращает сумму их результатов. Поскольку построитель &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;асинхронных&lt;/a&gt; сопрограмм определен как расширение на &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope,&lt;/a&gt; нам нужно, чтобы он был в области видимости, и это то, что обеспечивает функция &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">Давайте напишем функцию производителя канала, которая использует канал отложенных строковых значений, ожидает каждого полученного отложенного значения, но только до тех пор, пока не появится следующее отложенное значение или пока канал не закроется. В этом примере предложения &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait объединяются&lt;/a&gt; в один и тот же &lt;code&gt;select&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">Давайте напишем пример производителя целых чисел, который отправляет свои значения в &lt;code&gt;side&lt;/code&gt; канал, когда потребители на его основном канале не могут за ним угнаться:</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">Давайте также убедимся, что наши сопрограммы действительно работают параллельно. Если мы добавим 1- секундную &lt;code&gt;delay()&lt;/code&gt; к каждому из &lt;code&gt;async&lt;/code&gt; вызовов, полученная программа не будет работать в течение 1 000 000 секунд (более 11,5 дней):</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">Предположим в приведенном выше коде, что &lt;code&gt;preparePost&lt;/code&gt; - это длительный процесс и, следовательно, блокирует пользовательский интерфейс. Что мы можем сделать, так это запустить его в отдельном потоке. Это позволит нам избежать блокировки пользовательского интерфейса. Это очень распространенный метод, но он имеет ряд недостатков:</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Назовем фреймворк из Objective-C. Для этого мы создаем файл &lt;code&gt;main.m&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Давайте проверим C API нашей библиотеки Kotlin.``</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">Давайте нажмем на конфигурацию запуска &lt;code&gt;App&lt;/code&gt; чтобы запустить наш проект на реальном устройстве Android или в эмуляторе.</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Давайте нажмем кнопку &amp;laquo; &lt;em&gt;Выполнить&amp;raquo;&lt;/em&gt; в Xcode, и мы увидим, что наше приложение работает.</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">Давайте создадим файл-заглушку &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; со следующим содержимым, чтобы увидеть, как объявления примитивных типов C видны из Kotlin:</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">Давайте создадим файл-заглушку &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; со следующим содержимым, чтобы увидеть, как наши объявления C видны из Kotlin:</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">Давайте снова создадим миллион сопрограмм, сохранив их &lt;code&gt;Deferred&lt;/code&gt; объекты. Теперь нет необходимости в атомарном счетчике, поскольку мы можем просто вернуть числа, которые нужно добавить, из наших сопрограмм:</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">Создадим класс &lt;code&gt;Base64Test&lt;/code&gt; в &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; и напишем базовые тесты для Base64.</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">Обозначим функцию f(x)таким образом:добавляем к x 1,затем,пока в результирующем числе есть хотя бы один трейлинговый ноль,удаляем этот ноль.</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">Давайте немного углубимся в то, что это значит. Самым большим достоинством сопрограмм является то, что они могут &lt;em&gt;приостанавливаться,&lt;/em&gt; не блокируя поток. Чтобы сделать это возможным, компилятор должен выдать специальный код, поэтому мы должны отметить в коде функции, которые &lt;em&gt;могут приостанавливаться&lt;/em&gt; . Мы используем для этого модификатор &lt;code&gt;suspend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">Выделим блок кода внутри &lt;code&gt;launch { ... }&lt;/code&gt; в отдельную функцию. Когда вы выполняете рефакторинг &amp;laquo;Извлечь функцию&amp;raquo; в этом коде, вы получаете новую функцию с модификатором &lt;code&gt;suspend&lt;/code&gt; . Это ваша первая &lt;em&gt;функция приостановки&lt;/em&gt; . Функции приостановки могут использоваться внутри сопрограмм так же, как обычные функции, но их дополнительная особенность заключается в том, что они, в свою очередь, могут использовать другие функции приостановки, такие как &lt;code&gt;delay&lt;/code&gt; в этом примере, для &lt;em&gt;приостановки&lt;/em&gt; выполнения сопрограммы.</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">Сначала создадим папку проекта.Все пути в данном руководстве будут относительны к этой папке.Иногда перед добавлением новых файлов необходимо создать недостающие каталоги.</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">Давайте сразу &lt;code&gt;.kt&lt;/code&gt; - введите это в файл с расширением .kt :</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">Давайте включим зависимость от проекта &lt;code&gt;SharedCode&lt;/code&gt; к проекту Android. Нам нужно &lt;code&gt;app/build.gradle&lt;/code&gt; файл app / build.gradle и включить следующую строку в блок &lt;code&gt;dependencies { .. }&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">Давайте посмотрим на &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , который реализован во внешней библиотеке &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">Давайте посмотрим на полную программу, в которой используется &lt;code&gt;launch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">Давайте посмотрим,что изменилось.В Java вы аннотировали поле,привязав его к соответствующему виду:</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">Убедимся,что сможем запустить приложение на эмуляторе или устройстве iPhone.</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">Переместим &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; папку src / nativeMain / kotlin в проекте. Это путь по умолчанию, по которому расположены исходные файлы, когда &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;используется&lt;/a&gt; плагин kotlin-multiplatform . Мы используем следующий блок, чтобы настроить проект для создания динамической или общей библиотеки для нас:</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">Переместим &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; папку src / nativeMain / kotlin в проекте. Это путь по умолчанию для расположения источников при использовании &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;плагина kotlin-multiplatform&lt;/a&gt; . Мы используем следующий блок, чтобы проинструктировать и настроить проект для создания для нас динамической или общей библиотеки:</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">Заменим &lt;code&gt;testSolution()&lt;/code&gt; функции testSolution () следующим:</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">Давайте запустим много из них</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">Давайте &lt;code&gt;linkNative&lt;/code&gt; задачу linkNative Gradle для сборки библиотеки &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в среде IDE&lt;/a&gt; или вызовем следующую консольную команду:</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">Допустим, вы пишете простую ORM. Ваша библиотека базы данных представляет строку как экземпляры класса &lt;code&gt;Entity&lt;/code&gt; с такими функциями, как &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; и &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; для получения типизированных значений из заданных столбцов. Мы могли бы создать типизированный класс-оболочку следующим образом:</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">Допустим, нам нужно вернуть две вещи из функции. Например, объект результата и какой-то статус. Компактный способ сделать это в Kotlin - объявить &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;класс данных&lt;/em&gt;&lt;/a&gt; и вернуть его экземпляр:</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">Давайте посмотрим, как &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;object&lt;/code&gt; отображаются на Objective-C и Swift. Сформированный &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; файл содержит точные определения для &lt;code&gt;Class&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; и &lt;code&gt;Object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">Давайте посмотрим, что &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; сначала превращается в указатель:</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">Давайте подведем итог тому,что у нас есть в таблице:</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Переключатель назад Давайте в Android Studio и выполнить &lt;code&gt;build&lt;/code&gt; Цель &lt;code&gt;SharedCode&lt;/code&gt; проекта из &lt;em&gt;Gradle&lt;/em&gt; окна инструмента. Задача ищет переменные среды, заданные сборкой Xcode, и копирует правильный вариант платформы в &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; . Затем мы включаем фреймворк из этой папки в сборку.</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">Давайте сначала посмотрим на декларации по времени выполнения Котлина:</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">Давайте рассмотрим конкретный пример.</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">Давайте посмотрим на поле &lt;code&gt;kotlin.root.example&lt;/code&gt; , оно имитирует структуру пакета нашего кода Kotlin с &lt;code&gt;kotlin.root.&lt;/code&gt; префикс.</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">Давайте посмотрим на разницу между &lt;code&gt;Iterable&lt;/code&gt; и &lt;code&gt;Sequence&lt;/code&gt; на примере.</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">Давайте посмотрим на сгенерированные функции, которые принимают наши &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; в качестве параметров. Мы видим, что параметры по значению представлены как &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; . А для параметров типизированного указателя мы видим &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; . Kotlin предоставляет нам API, чтобы легко работать с обоими типами, давайте попробуем и посмотрим.</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">Давайте возьмем трубопроводы в крайнем случае с примером,который генерирует простые числа с помощью трубопровода из корусинок.Начнем с бесконечной последовательности чисел.</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">Давайте попробуем то же самое с корутинами:</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">Попробуем использовать API от Kotlin. &lt;code&gt;pass_string&lt;/code&gt; вызовем pass_string :</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">Давайте обновим скрипты Gradle,чтобы реализовать это и настроить нашу IDE.</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">Давайте использовать его с каналом &lt;code&gt;a&lt;/code&gt; , который четыре раза генерирует строку &amp;laquo;Hello&amp;raquo;, и каналом &lt;code&gt;b&lt;/code&gt; , который генерирует строку &amp;laquo;World&amp;raquo; четыре раза:</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">Давайте пройдемся по интерфейсам и их реализациям.</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Давайте рассмотрим механизмы реализации типобезопасных построителей в Котлине. Прежде всего, нам нужно определить модель, которую мы хотим построить, в этом случае нам нужно смоделировать HTML-теги. Это легко сделать с помощью группы классов. Например, &lt;code&gt;HTML&lt;/code&gt; - это класс, описывающий &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; , т.е. он определяет дочерние элементы, такие как &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; . (См. Его заявление &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;ниже&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">Авторы библиотек могут использовать @Deprecated и @Experimental annotations для контроля эволюции своей поверхности API.Обратите внимание,что @Deprecated(level=HIDDEN)может использоваться для сохранения бинарной совместимости даже для объявлений,удаленных из API.</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">Библиотечный код всегда должен явно указывать возвращаемые типы публичных/защищенных функций и свойств,тем самым никогда не полагаясь на вывод типа для публичного API.Небольшое изменение типового вывода может привести к непреднамеренному изменению типов возвращаемых данных,что приведет к проблемам совместимости двоичных систем.</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">Последовательность поиска в библиотеке</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Библиотечное обслуживание аннотаций в Котлине.</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Лицензия Apache,версия 2.0.</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Как и Java, обобщенные типы Kotlin не сохраняются во время выполнения, т.е. объекты не несут информацию о фактических аргументах типа, переданных их конструкторам, т.е. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; неотличим от &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; . Это делает невозможным выполнение &lt;em&gt;is-&lt;/em&gt; проверок, учитывающих обобщенные типы. Kotlin разрешает &lt;em&gt;is-&lt;/em&gt; проверки только для общих типов с проекцией звезд:</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Как и в Python, функции в Kotlin являются первоклассными значениями - их можно назначать переменным и передавать как параметры. Тип функции - это &lt;em&gt;тип функции&lt;/em&gt; , который обозначается списком типов параметров в скобках и стрелкой к типу возвращаемого значения. Рассмотрим эту функцию:</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">Как и в Python, операторы могут заканчиваться точкой с запятой, но это не рекомендуется. Нет символа продолжения строки; вместо этого строка автоматически соединяется с одной или несколькими последующими строками, если это единственный способ правильно проанализировать код. На практике это означает, что оператор продолжается на следующей строке, если мы внутри открытой круглой скобки (как в Python), или если строка заканчивается &amp;laquo;висящим оператором&amp;raquo; (в отличие от Python) или если следующая строка не синтаксический анализ, если он не присоединен к предыдущему (также в отличие от Python). Обратите внимание, что это в значительной степени &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;противоположность JavaScript&lt;/a&gt; , который обычно будет соединять строки, пока полученный код все еще анализирует. Таким образом, следующие два выражения в Kotlin и в Python (потому что &lt;code&gt;+&lt;/code&gt; может быть унарным, поэтому вторая строка анализируется сама по себе), но одна в JavaScript:</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">Как и в Python, вы можете писать &lt;em&gt;лямбда-выражения&lt;/em&gt; : объявления безымянных функций с очень компактным синтаксисом, которые оценивают вызываемые объекты функций. В Kotlin лямбды могут содержать несколько операторов, что делает их полезными для &lt;a href=&quot;functional-programming#receivers&quot;&gt;более сложных задач,&lt;/a&gt; чем лямбды с одним выражением в Python. Последний оператор должен быть выражением, результат которого станет возвращаемым значением лямбда (если &lt;code&gt;Unit&lt;/code&gt; не является типом возвращаемого значения переменной / параметра, которому присвоено лямбда-выражение, и в этом случае лямбда не имеет возвращаемого значения). Лямбда-выражение заключено в фигурные скобки и начинается с перечисления имен его параметров и, возможно, их типов (если типы не могут быть выведены из контекста):</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">Как и цифры,символы помечены квадратиками,когда нужна нулевая ссылка.Идентичность не сохраняется при боксировании.</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">Точно так же, если многоплатформенная библиотека опубликована в экспериментальном &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;режиме публикации метаданных Gradle&lt;/a&gt; и проект настроен на использование метаданных, тогда достаточно указать зависимость только один раз для общего набора источников. В противном случае каждый исходный набор для конкретной платформы должен быть снабжен соответствующим платформенным модулем библиотеки в дополнение к общему модулю, как показано выше.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">Линейный поиск</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">Связать библиотеку с приложением</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">Связь с элементами</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64,arm32,MIPS,MIPS little endian,Raspberry Pi)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Для целей Linux MIPS ( &lt;code&gt;linuxMips32&lt;/code&gt; и &lt;code&gt;linuxMipsel32&lt;/code&gt; ) требуется хост Linux. Другие цели Linux могут быть созданы на любом поддерживаемом хосте;</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; и &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">Перечень конкретных операций</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">Элементы списка (включая нули) могут дублироваться: список может содержать любое количество одинаковых объектов или вхождений одного объекта. Два списка считаются равными, если они имеют одинаковые размеры и &lt;a href=&quot;equality#structural-equality&quot;&gt;структурно одинаковые&lt;/a&gt; элементы в одинаковых позициях.</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">Перечислить итераторы</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">Операции записи списка</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">Списки также предлагают функцию для замены элемента в заданной позиции - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; и его оператор form &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;set()&lt;/code&gt; не изменяет индексы других элементов.</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">Списки и наборы также предоставляют операции по обновлению элементов. Они описаны в &lt;a href=&quot;list-operations&quot;&gt;разделах &amp;laquo;Список конкретных операций&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;map-operations&quot;&gt;Операции для конкретных карт&amp;raquo;&lt;/a&gt; . Для наборов обновление не имеет смысла, поскольку оно фактически удаляет элемент и добавляет другой.</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">Списки поддерживают все стандартные операции для поиска элементов: &lt;code&gt;elementAt()&lt;/code&gt; , &lt;code&gt;first()&lt;/code&gt; , &lt;code&gt;last()&lt;/code&gt; и другие, перечисленные в &lt;a href=&quot;collection-elements&quot;&gt;разделе &amp;laquo;Получение отдельных элементов&amp;raquo;&lt;/a&gt; . Что характерно для списков, так это доступ к элементам по индексу, поэтому самый простой способ прочитать элемент - получить его по индексу. Это делается с помощью функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; с индексом, переданным в аргументе, или сокращенным синтаксисом &lt;code&gt;[index]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">Буквальные константы</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">Локальные удаленные свойства (начиная с 1.1)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">Местные функции</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">Классы местных аннотаций</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">Местные декларации</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">Местная делегированная собственность</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">Локальная функция может обращаться к локальным переменным внешних функций (то есть к закрытию), поэтому в приведенном выше случае &lt;em&gt;посещаемая&lt;/em&gt; может быть локальной переменной:</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">Локальная переменная</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">Локальные переменные обычно объявляются и инициализируются одновременно, и в этом случае &lt;em&gt;предполагается&lt;/em&gt; , что тип переменной является типом выражения, которым вы ее инициализируете:</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">Локальные переменные,функции и классы не могут иметь модификаторов видимости.</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">Блокировки используются, чтобы гарантировать, что только один поток может инициализировать экземпляр &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">Логарифмы: &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;ln&lt;/code&gt; , &lt;code&gt;ln1p&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">Логотипы можно скачать &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;здесь&lt;/a&gt; . При использовании логотипов соблюдайте простые правила, содержащиеся в &lt;code&gt;guidelines.pdf&lt;/code&gt; внутри архива, и &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;правила использования бренда Kotlin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">Ломбок ( &lt;code&gt;lombok.NonNull&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Длинные позиции помечены заглавной &lt;code&gt;L&lt;/code&gt; : &lt;code&gt;123L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">Ищете другие API? Создать &lt;a href=&quot;../multiplatform-library&quot;&gt;мультиплатформенную библиотеку&lt;/a&gt; и поделиться ею - легко !</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">Ищет функцию &lt;code&gt;inc()&lt;/code&gt; с модификатором &lt;code&gt;operator&lt;/code&gt; и без параметров, применимую к получателю типа &lt;code&gt;T&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">&lt;code&gt;unaryPlus()&lt;/code&gt; функцию unaryPlus () с модификатором &lt;code&gt;operator&lt;/code&gt; и без параметров для получателя &lt;code&gt;T&lt;/code&gt; , т. Е. Функцию- член или функцию расширения;</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">Петли на диапазонах</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">Низкоуровневые строительные блоки для библиотек,предоставляющих коррутинные API.</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">К счастью, в Kotlin есть &lt;em&gt;параметры овеществленного типа&lt;/em&gt; , которые устраняют некоторые из этих проблем. Написав &lt;code&gt;reified&lt;/code&gt; перед параметром универсального типа, он становится доступным во время выполнения, и вы можете написать &lt;code&gt;T::class&lt;/code&gt; для получения &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;метаданных класса&lt;/a&gt; . Вы можете сделать это только в встроенных функциях (так как встроенная функция будет скомпилирована в его callsite, если информация о типе &lt;em&gt;является&lt;/em&gt; доступна во время выполнения), но он все еще проходит долгий путь. Например, вы можете сделать встроенную функцию-оболочку для большой функции, которая имеет менее элегантную подпись.</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">MacOS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">Убедитесь, что его тип возвращаемого значения - &lt;code&gt;Unit&lt;/code&gt; , в противном случае сообщите об ошибке,</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">Убедитесь , что вы CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;установлены&lt;/a&gt; . Мы рекомендуем использовать CocoaPods 1.6.1 или новее.</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">Убедитесь, что вы &lt;code&gt;kotlin.js&lt;/code&gt; среду выполнения kotlin.js , а затем свое приложение.</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">Сделайте обновление до новых версий удобным для пользователей.</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Делает метод Котлина в классе Objective-C доступным через диспетчерскую Objective-C для использования в качестве действия,посланного управлением в UIKit или AppKit.</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Делает свойство Котлин в классе Объект-С устанавливаемым через диспетчерскую Объект-С для использования в качестве выхода IB.</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Делает подкласс Kotlin класса Objective-C видимым для поиска во время выполнения после вызова &lt;code&gt;main&lt;/code&gt; функции Kotlin .</target>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">Делает функцию верхнего уровня доступной из Си/Си++кода с заданным именем.</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">Сделать код вычислений отменяемым</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">Частое проведение нулевых проверок раздражает,поэтому,если вам приходится допускать возможность нулей,в Котлине есть несколько очень полезных операторов,которые облегчают работу со значениями,которые могут быть нулевыми,как описано ниже.</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">Неправильные последовательности байтов заменяются заменой char &lt;code&gt;\uFFFD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">Управление зависимостями</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">Управляющие источники</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">Управляющие цели</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">Ручная настройка</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">Ручная установка</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">Многие современные IDE поддерживают Kotlin и помогают в написании идиоматического кода Kotlin:</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">Многие из опций также могут быть настроены через свойства:</target>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">Карта конкретных операций</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">Отображать нулевое значение,если не нулевое</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">Операции записи на карту</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap()и Map.toMutableMap().</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">Картированные типы</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">Картирование типов функциональных указателей с C</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">Картографические функциональные указатели из C</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">Картирование примитивных типов данных из C</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">Строки отображения из C</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">Картографическая структура и соединительные типы C</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">Картографическая структура и соединительные типы от C</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">Интерфейс маркера, указывающий, что реализация &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; поддерживает быстрый индексированный доступ.</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">Интерфейс маркера, указывающий, что реализация &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; поддерживает быстрый индексированный доступ.</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">Элементы API маркировки</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">Маркировка экспериментального API</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">Правила маркировки:неявный получатель считается помеченным @Ann,если</target>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">Пометка переменной верхнего уровня с полем подложки или объектом как неизменяемой.Можно разделить такой объект на несколько потоков,но он становится глубоко замороженным,поэтому ни в его состояние,ни в состояние объектов,на которые он ссылается,не могут быть внесены никакие изменения.</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">Помечает переменную верхнего уровня полем поддержки или объектом как нитевую локальную.Объект остается мутируемым,и можно изменить его состояние,но каждая нить будет иметь отдельную копию этого объекта,поэтому изменения в одной нити не отражаются на другой.</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">Обозначает ожидаемый класс аннотаций,что не обязательно иметь реальных аналогов на всех платформах.</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">Отмечает элемент контекста сопрограммы, который перехватывает продолжения сопрограммы. Инфраструктура сопрограмм использует &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; для получения перехватчика и перехватывает все продолжения сопрограмм с вызовами &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">Обозначает API,который зависит от экспериментальных беззнаковых типов,включая сами эти типы.</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">Помечает поле поддержки JVM аннотированного свойства как &lt;code&gt;transient&lt;/code&gt; , что означает, что оно не является частью сериализованной формы объекта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">Помечает поле поддержки JVM аннотированного свойства как &lt;code&gt;volatile&lt;/code&gt; , что означает, что записи в это поле немедленно становятся видимыми для других потоков.</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">Отмечает JVM-метод, созданный из аннотированной функции, как &lt;code&gt;strictfp&lt;/code&gt; , что означает, что точность операций с плавающей запятой, выполняемых внутри метода, должна быть ограничена для достижения лучшей переносимости.</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">Отмечает JVM-метод, сгенерированный аннотированной функцией, как &lt;code&gt;synchronized&lt;/code&gt; , что означает, что метод будет защищен от одновременного выполнения несколькими потоками монитором экземпляра (или, для статических методов, класса), на котором определен метод.</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">Пометит аннотированную декларацию как устаревшую.</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">Математические операции в Котлин-Стдлиб</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">Математические функции и константы.</target>
        </trans-unit>
        <trans-unit id="6af37177e65c1a71744a7cb984d51ba2f07f5140" translate="yes" xml:space="preserve">
          <source>Maven</source>
          <target state="translated">Maven</target>
        </trans-unit>
        <trans-unit id="b522db69b358e8fce0593518fbe3b0d7db36d2d4" translate="yes" xml:space="preserve">
          <source>Maven configuration</source>
          <target state="translated">дискретная конфигурация</target>
        </trans-unit>
        <trans-unit id="71edee9db1ff5b8ff75c1bfdc3477115c9cadb2f" translate="yes" xml:space="preserve">
          <source>Max value</source>
          <target state="translated">Максимальное значение</target>
        </trans-unit>
        <trans-unit id="6f26174801b4fb329b7b4754a956851117212509" translate="yes" xml:space="preserve">
          <source>Maximum value a version component can have, a constant value 255.</source>
          <target state="translated">Максимальное значение,которое может иметь компонент версии,постоянное значение 255.</target>
        </trans-unit>
        <trans-unit id="258389887a049fd789e8d5c0611eb448fb932cc4" translate="yes" xml:space="preserve">
          <source>MediaDeviceInfo</source>
          <target state="translated">MediaDeviceInfo</target>
        </trans-unit>
        <trans-unit id="6134c6977e97c143c3e4282792a6fe2d4e4a8d3d" translate="yes" xml:space="preserve">
          <source>MediaDeviceKind</source>
          <target state="translated">MediaDeviceKind</target>
        </trans-unit>
        <trans-unit id="42773779c7725a712497e1de443b3526292ee7c5" translate="yes" xml:space="preserve">
          <source>MediaEncryptedEventInit</source>
          <target state="translated">MediaEncryptedEventInit</target>
        </trans-unit>
        <trans-unit id="5e9d9c4423f0ac299fce82e9517c3425a061ddb4" translate="yes" xml:space="preserve">
          <source>MediaError</source>
          <target state="translated">MediaError</target>
        </trans-unit>
        <trans-unit id="edc3252539f2977307059639af16d93b62f83e89" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageEventInit</source>
          <target state="translated">MediaKeyMessageEventInit</target>
        </trans-unit>
        <trans-unit id="0f9940df0a60e74d9f81259c874d8fc5cf90b250" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageType</source>
          <target state="translated">MediaKeyMessageType</target>
        </trans-unit>
        <trans-unit id="f6d29b82c487515b0ed4941f8440be7338b9cdd9" translate="yes" xml:space="preserve">
          <source>MediaKeySessionType</source>
          <target state="translated">MediaKeySessionType</target>
        </trans-unit>
        <trans-unit id="6a72b850014dcb01724de3815824e738f2a289e8" translate="yes" xml:space="preserve">
          <source>MediaKeyStatus</source>
          <target state="translated">MediaKeyStatus</target>
        </trans-unit>
        <trans-unit id="06b28afbee38c4e57833221839b448745bf0272f" translate="yes" xml:space="preserve">
          <source>MediaKeyStatusMap</source>
          <target state="translated">MediaKeyStatusMap</target>
        </trans-unit>
        <trans-unit id="334845d31e06fd797025ffec6b0e947ced1eee27" translate="yes" xml:space="preserve">
          <source>MediaKeySystemAccess</source>
          <target state="translated">MediaKeySystemAccess</target>
        </trans-unit>
        <trans-unit id="13b324678ad4a42d1cf13183ec5703ba89067f0a" translate="yes" xml:space="preserve">
          <source>MediaKeySystemConfiguration</source>
          <target state="translated">MediaKeySystemConfiguration</target>
        </trans-unit>
        <trans-unit id="261d7bee8c2a3f2851483973000c454b56a6d2f7" translate="yes" xml:space="preserve">
          <source>MediaKeySystemMediaCapability</source>
          <target state="translated">MediaKeySystemMediaCapability</target>
        </trans-unit>
        <trans-unit id="04bf6109f69f0241e714dae0a1bff955d8bb5503" translate="yes" xml:space="preserve">
          <source>MediaKeys</source>
          <target state="translated">MediaKeys</target>
        </trans-unit>
        <trans-unit id="0204337f58a70624acab6d8767bba63e305a6319" translate="yes" xml:space="preserve">
          <source>MediaKeysRequirement</source>
          <target state="translated">MediaKeysRequirement</target>
        </trans-unit>
        <trans-unit id="f30d349fe509ab2452d9ff5db776c749eb21115d" translate="yes" xml:space="preserve">
          <source>MediaList</source>
          <target state="translated">MediaList</target>
        </trans-unit>
        <trans-unit id="fb2396dadb0919fa005cf6b516e3b748e938e528" translate="yes" xml:space="preserve">
          <source>MediaProvider</source>
          <target state="translated">MediaProvider</target>
        </trans-unit>
        <trans-unit id="5264b922a464ea5a9f88144f8b72f9626c1db269" translate="yes" xml:space="preserve">
          <source>MediaQueryListEventInit</source>
          <target state="translated">MediaQueryListEventInit</target>
        </trans-unit>
        <trans-unit id="70dcd56d399d2e12aa2533dd163497d5ff6362fd" translate="yes" xml:space="preserve">
          <source>MediaStreamConstraints</source>
          <target state="translated">MediaStreamConstraints</target>
        </trans-unit>
        <trans-unit id="c74168a0d6b99bbcdaff6005366c94dc042ddd9e" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackEventInit</source>
          <target state="translated">MediaStreamTrackEventInit</target>
        </trans-unit>
        <trans-unit id="f6268479064052c02a6fe8b1b48bf8011df3d770" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackState</source>
          <target state="translated">MediaStreamTrackState</target>
        </trans-unit>
        <trans-unit id="10f95ad72ba533133d954c473a07f3f67fdac829" translate="yes" xml:space="preserve">
          <source>MediaTrackCapabilities</source>
          <target state="translated">MediaTrackCapabilities</target>
        </trans-unit>
        <trans-unit id="bb47b7b2d8ef429be15b6e0dad452a4f8b48f974" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraintSet</source>
          <target state="translated">MediaTrackConstraintSet</target>
        </trans-unit>
        <trans-unit id="8054e6c6485f93790f303ed390e1cba5c2743911" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraints</source>
          <target state="translated">MediaTrackConstraints</target>
        </trans-unit>
        <trans-unit id="43ae2bb87ab91212c29f9b3badd22fa54472dcc6" translate="yes" xml:space="preserve">
          <source>MediaTrackSettings</source>
          <target state="translated">MediaTrackSettings</target>
        </trans-unit>
        <trans-unit id="7e941f3e34c1287f6e0e3fa6973fe4daf92e6bf1" translate="yes" xml:space="preserve">
          <source>MediaTrackSupportedConstraints</source>
          <target state="translated">MediaTrackSupportedConstraints</target>
        </trans-unit>
        <trans-unit id="0821090b6a2b08e3c2088bad74f0cd7597a2e61c" translate="yes" xml:space="preserve">
          <source>MemScope</source>
          <target state="translated">MemScope</target>
        </trans-unit>
        <trans-unit id="13754495aca84346deb594b0d23bc4d086989ee4" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
          <target state="translated">Функции членов</target>
        </trans-unit>
        <trans-unit id="2675e87b859fb2d5772f0ea8bf6c203afefdde62" translate="yes" xml:space="preserve">
          <source>Member function names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">Имена функций-членов должны использовать &lt;code&gt;lowerCamelCase&lt;/code&gt; вместо &lt;code&gt;snake_case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">Функции членов</target>
        </trans-unit>
        <trans-unit id="d58072c4501a38b0ae1c8099bd6324750503224c" translate="yes" xml:space="preserve">
          <source>Member functions are called with dot notation:</source>
          <target state="translated">Функции членов вызываются с точечной нотацией:</target>
        </trans-unit>
        <trans-unit id="90302bd1ef8edadba09a04d671c6ada71d5d8a46" translate="yes" xml:space="preserve">
          <source>Member functions define operations that are essential for a collection type. For example, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; contains the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt;&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/a&gt; for checking its emptiness; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; contains &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; for index access to elements, and so on.</source>
          <target state="translated">Функции-члены определяют операции, которые необходимы для типа коллекции. Например, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; содержит функцию &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt; &lt;code&gt;isEmpty()&lt;/code&gt; &lt;/a&gt; для проверки ее пустоты; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; содержит &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; для индексного доступа к элементам и так далее.</target>
        </trans-unit>
        <trans-unit id="a569ddca50a19b2205ceb3e1f59db2a7ba968aef" translate="yes" xml:space="preserve">
          <source>Member properties and member functions inside a generic class may for the most part use the class' generic type parameters as if they were ordinary types, without having to redeclare them. It is also possible to make functions that take more generic parameters than the class does, and to make generic functions inside nongeneric classes, and to make generic top-level functions (which is what we'll do in the next example). Note the different placement of the generic type parameter in generic function declarations:</source>
          <target state="translated">Свойства членов и функции-члены внутри общего класса могут в большинстве случаев использовать параметры общего типа класса,как если бы они были обычными типами,без необходимости их передекларирования.Также возможно сделать функции,которые принимают более общие параметры,чем класс,и сделать общие функции внутри неэнергетических классов,и сделать общие функции верхнего уровня (что мы и сделаем в следующем примере).Обратите внимание на различное размещение общего параметра типа в объявлениях общих функций:</target>
        </trans-unit>
        <trans-unit id="74971806b05c2768bdffa67bcc7b89b958d7edea" translate="yes" xml:space="preserve">
          <source>Member references and reflection</source>
          <target state="translated">Рекомендации и размышления членов</target>
        </trans-unit>
        <trans-unit id="10aac04b8647c134bc4873cf9a0d33a0bd4048e1" translate="yes" xml:space="preserve">
          <source>MemberAt</source>
          <target state="translated">MemberAt</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="2fd5b3fb4a679664c9a47a448257d9fa802a22f3" translate="yes" xml:space="preserve">
          <source>Members of Objective-C categories and Swift extensions are imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin. And the extension initializers aren't available as Kotlin constructors.</source>
          <target state="translated">Участники категорий Objective-C и Swift расширений импортируются в Kotlin в качестве расширений.Вот почему эти декларации не могут быть переопределены в Котлине.А инициализаторы расширений не доступны в качестве конструкторов Котлина.</target>
        </trans-unit>
        <trans-unit id="c590aa47cb148126a7aed2e0252e6e56de2e1fb5" translate="yes" xml:space="preserve">
          <source>Members of the companion object can be called by using simply the class name as the qualifier:</source>
          <target state="translated">Члены объекта-сопутника могут быть вызваны с помощью простого имени класса в качестве классификатора:</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">Распределение памяти</target>
        </trans-unit>
        <trans-unit id="0c2ee25c3007f8df17e0050402341b2f4ae697bc" translate="yes" xml:space="preserve">
          <source>Memory model binary was compiled with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73a4635af37ee3ef43681ca08ff16f60452ecfe" translate="yes" xml:space="preserve">
          <source>Memory model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69164a09919e64cc770d2e92a315c7be5fe9ce87" translate="yes" xml:space="preserve">
          <source>MemoryModel</source>
          <target state="translated">MemoryModel</target>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="ccca7aad0aa3bbb87c9ea30bfca4cd685ee282a6" translate="yes" xml:space="preserve">
          <source>MessageEventInit</source>
          <target state="translated">MessageEventInit</target>
        </trans-unit>
        <trans-unit id="da50feb28afa8ee6b84decde6712247ff2db1356" translate="yes" xml:space="preserve">
          <source>Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">Метасимволы или экранирующие последовательности во входной последовательности не будут иметь особого значения.</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="00c97618202a4d85cdcf254062dd76c688bb9937" translate="yes" xml:space="preserve">
          <source>Metadata in a custom format. The format may be different (or even absent) for different kinds.</source>
          <target state="translated">Метаданные в пользовательском формате.Формат может быть разным (или даже отсутствовать)для разных видов.</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="6ef376dbda2a9dfd9fe8fb9172d6ea36380a325e" translate="yes" xml:space="preserve">
          <source>Method call formatting</source>
          <target state="translated">Форматирование вызова метода</target>
        </trans-unit>
        <trans-unit id="3643c572e5a5065b656aa6b5fce445bafca060de" translate="yes" xml:space="preserve">
          <source>Method declarations</source>
          <target state="translated">Объявления о методе</target>
        </trans-unit>
        <trans-unit id="6c23f25a80838dd8e19f20f6fec8854933be69db" translate="yes" xml:space="preserve">
          <source>Method names translation</source>
          <target state="translated">Перевод названий методов</target>
        </trans-unit>
        <trans-unit id="88533fb91c329fcc07daac7abd293e3d2ef386bf" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; are not available on references of type &lt;code&gt;Any&lt;/code&gt;. Their usage is generally discouraged in favor of &lt;code&gt;java.util.concurrent&lt;/code&gt;. If you really need to call these methods, you can cast to &lt;code&gt;java.lang.Object&lt;/code&gt;:</source>
          <target state="translated">Методы &lt;code&gt;wait()&lt;/code&gt; и &lt;code&gt;notify()&lt;/code&gt; недоступны для ссылок типа &lt;code&gt;Any&lt;/code&gt; . Их использование обычно не рекомендуется в пользу &lt;code&gt;java.util.concurrent&lt;/code&gt; . Если вам действительно нужно вызвать эти методы, вы можете преобразовать его в &lt;code&gt;java.lang.Object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="04764bae2f3b42e32503d658246fd786e62d1716" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as platform, i.e. it's possible to perform unsafe operation in Kotlin:</source>
          <target state="translated">Методы, определенные в &lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; используют &lt;code&gt;T&lt;/code&gt; в качестве платформы, т.е. в Kotlin можно выполнять небезопасные операции:</target>
        </trans-unit>
        <trans-unit id="2362d4b5d61680189ee786359c95c772832ea599" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; overriding methods in &lt;code&gt;MutableList&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as non-platform types:</source>
          <target state="translated">Методы, определенные в &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; методы переопределения в &lt;code&gt;MutableList&lt;/code&gt; , используют &lt;code&gt;T&lt;/code&gt; как неплатформенные типы:</target>
        </trans-unit>
        <trans-unit id="1643049f5673b4e1c5eb74d112c9611cf055d3c5" translate="yes" xml:space="preserve">
          <source>Methods returning void</source>
          <target state="translated">Способы возврата пустоты</target>
        </trans-unit>
        <trans-unit id="a8027f1188b3014c0f8995cd7120023b72397d3d" translate="yes" xml:space="preserve">
          <source>Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with &lt;code&gt;get&lt;/code&gt; and single-argument methods with names starting with &lt;code&gt;set&lt;/code&gt;) are represented as properties in Kotlin. &lt;code&gt;Boolean&lt;/code&gt; accessor methods (where the name of the getter starts with &lt;code&gt;is&lt;/code&gt; and the name of the setter starts with &lt;code&gt;set&lt;/code&gt;) are represented as properties which have the same name as the getter method.</source>
          <target state="translated">Методы, которые следуют соглашениям Java для геттеров и сеттеров (методы без аргументов с именами, начинающимися с &lt;code&gt;get&lt;/code&gt; , и методы с одним аргументом с именами, начинающимися с &lt;code&gt;set&lt;/code&gt; ), представлены как свойства в Kotlin. &lt;code&gt;Boolean&lt;/code&gt; методы доступа (где имя получателя начинается с &lt;code&gt;is&lt;/code&gt; , а имя установщика начинается с &lt;code&gt;set&lt;/code&gt; ) представлены как свойства, которые имеют то же имя, что и метод получения.</target>
        </trans-unit>
        <trans-unit id="a23dee2288fafb96e4e3f4b56c185b2062a8905b" translate="yes" xml:space="preserve">
          <source>Micronaut also has a lot of well-detailed &lt;a href=&quot;https://guides.micronaut.io/tags/kotlin.html&quot;&gt;guides&lt;/a&gt;, showing how you can build microservices in Kotlin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2474109210e0ea672543f6c977728ae54b8f124d" translate="yes" xml:space="preserve">
          <source>Migrate the code with the help of the tooling</source>
          <target state="translated">Миграция кода с помощью инструментов</target>
        </trans-unit>
        <trans-unit id="708b9cf32b4bb9e8e85c01bf95c0ef78c92becb6" translate="yes" xml:space="preserve">
          <source>Migrating from Java</source>
          <target state="translated">Мигрирующий с Явы</target>
        </trans-unit>
        <trans-unit id="b9d3a9e9670f7240a77d83260fefdcb2501bc774" translate="yes" xml:space="preserve">
          <source>Migrating to Kotlin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44d82dafb548c8ad9d6490ef0e69cd3d1ba217d" translate="yes" xml:space="preserve">
          <source>Migration to a new code style</source>
          <target state="translated">Переход на новый стиль кода</target>
        </trans-unit>
        <trans-unit id="d0a1c8e409ae53cb281e66770ad717b9178d43ce" translate="yes" xml:space="preserve">
          <source>Migration to a new code style discussion</source>
          <target state="translated">Переход к обсуждению нового стиля кода</target>
        </trans-unit>
        <trans-unit id="1bd7ccbde8d3077fec1f549017e747393223a900" translate="yes" xml:space="preserve">
          <source>MimeType</source>
          <target state="translated">MimeType</target>
        </trans-unit>
        <trans-unit id="ed52d3a5f9993b67e83d292332a8f9a1d86ebf44" translate="yes" xml:space="preserve">
          <source>MimeTypeArray</source>
          <target state="translated">MimeTypeArray</target>
        </trans-unit>
        <trans-unit id="98f205e04abca4bbe7595051d07e6eb3a4abe953" translate="yes" xml:space="preserve">
          <source>Min value</source>
          <target state="translated">Минимальное значение</target>
        </trans-unit>
        <trans-unit id="222d1f694d764125a7a7a5786d11a04234b0be8d" translate="yes" xml:space="preserve">
          <source>Missing errors in class constructor&amp;rsquo;s &lt;code&gt;@get:&lt;/code&gt; annotations</source>
          <target state="translated">Отсутствуют ошибки в аннотациях &lt;code&gt;@get:&lt;/code&gt; конструктора класса</target>
        </trans-unit>
        <trans-unit id="47e4750870ece5e5c348eda89bdc8e3fbb4c6cff" translate="yes" xml:space="preserve">
          <source>Missing getter-targeted annotations on annotation constructor parameters</source>
          <target state="translated">Пропущенные геттер-таргетированные аннотации по параметрам аннотационного конструктора</target>
        </trans-unit>
        <trans-unit id="52b91c038ffc21a08d48959a44ba1c6fddb114f2" translate="yes" xml:space="preserve">
          <source>Mixed Java and Kotlin</source>
          <target state="translated">Смешанная Ява и Котлин</target>
        </trans-unit>
        <trans-unit id="86c40367cc1e1c53a8c10c73ada1f29fd66c1405" translate="yes" xml:space="preserve">
          <source>Mixing Java and Kotlin in one project</source>
          <target state="translated">Смешивание Java и Kotlin в одном проекте</target>
        </trans-unit>
        <trans-unit id="404ab93e44ed76b5232ab6931dd26299f542e43d" translate="yes" xml:space="preserve">
          <source>Modern debuggers provide several ways to set a breakpoint, see below for a tool-by-tool breakdown:</source>
          <target state="translated">Современные отладчики предоставляют несколько способов установки точки останова,см.ниже разбивку по инструментам:</target>
        </trans-unit>
        <trans-unit id="5ba6ee64964304bc6c3c5424baba2b34cd73ea5d" translate="yes" xml:space="preserve">
          <source>Modifier Keywords</source>
          <target state="translated">Модификатор Ключевые слова</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="42cd86d0e702bd27bcb835a0b162fb95197132a2" translate="yes" xml:space="preserve">
          <source>Modifies the value of the property.</source>
          <target state="translated">Изменяет значение свойства.</target>
        </trans-unit>
        <trans-unit id="723a9a05eb17a0ec38db3b56d4b0ea18be0358a6" translate="yes" xml:space="preserve">
          <source>Module and Package Documentation</source>
          <target state="translated">Модульная и пакетная документация</target>
        </trans-unit>
        <trans-unit id="ed8def074470e81fe96b7cdd8aac08ec3fff3bc6" translate="yes" xml:space="preserve">
          <source>Module system used by the Kotlin Standard Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec446b6ebb15f053c4868dce62c242283cf04673" translate="yes" xml:space="preserve">
          <source>Module-wide markers</source>
          <target state="translated">Маркеры для всего модуля</target>
        </trans-unit>
        <trans-unit id="738fa33a16ad3f30c737fafc42459e4a03f30470" translate="yes" xml:space="preserve">
          <source>Module-wide use</source>
          <target state="translated">Использование модуля в целом</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d62ac0bf808c354dcb97b6778e8aaae4635a7c9f" translate="yes" xml:space="preserve">
          <source>More details and advanced use-cases are presented in the</source>
          <target state="translated">Более подробная информация и расширенные примеры использования представлены в разделе</target>
        </trans-unit>
        <trans-unit id="91aa2ec21d9f2bac781876761e04b45d52ef74fe" translate="yes" xml:space="preserve">
          <source>More documentation on the types mapping can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; article.</source>
          <target state="translated">Дополнительную документацию по сопоставлению типов можно найти в статье &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5c09addc98121bf0f9aad66c228b38f1430aecf" translate="yes" xml:space="preserve">
          <source>More information about all other types mapping details can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Более подробную информацию обо всех других деталях сопоставления типов можно найти в статье документации &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b061f32f9ec8d43b64e344ed5485c4d9f7caf378" translate="yes" xml:space="preserve">
          <source>More tips and tricks</source>
          <target state="translated">Больше советов и хитростей</target>
        </trans-unit>
        <trans-unit id="e9792383929cbb7b1909aa88012c0f218c0c51f8" translate="yes" xml:space="preserve">
          <source>Most built-in types are comparable:</source>
          <target state="translated">Большинство встроенных типов сопоставимы:</target>
        </trans-unit>
        <trans-unit id="f9f0f6eb5ddb49db8f8ae5d8eb9cab0176d9ace5" translate="yes" xml:space="preserve">
          <source>Most of the functionality of signed types are supported for unsigned counterparts too:</source>
          <target state="translated">Большинство функциональных возможностей подписанных типов поддерживается и для неподписанных аналогов:</target>
        </trans-unit>
        <trans-unit id="cb91c080f7b68ae6a8bbb2b702b1059a13b12c96" translate="yes" xml:space="preserve">
          <source>Most of the operators that are recognized by Kotlin's syntax have predefined textual names and are available for implementation in your classes, just like you can do with Python's double-underscore operator names. For example, the binary &lt;code&gt;+&lt;/code&gt; operator is called &lt;code&gt;plus&lt;/code&gt;. Similarly to the infix example, if you do this inside a &lt;code&gt;Person&lt;/code&gt; class that has got a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Большинство операторов, которые распознаются синтаксисом Kotlin, имеют предопределенные текстовые имена и доступны для реализации в ваших классах, точно так же, как вы можете сделать с именами операторов Python с двойным подчеркиванием. Например, бинарный оператор &lt;code&gt;+&lt;/code&gt; называется &lt;code&gt;plus&lt;/code&gt; . Как и в примере с инфиксом, если вы сделаете это внутри класса &lt;code&gt;Person&lt;/code&gt; , у которого есть свойство &lt;code&gt;name&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef0792097f4b2ac5841fae23eda77fe48d6f36a5" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level - directly under packages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edbae2a158aaf025c7463b2890fdba1f30e0552" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level, i.e. directly under packages:</source>
          <target state="translated">Большую часть времени мы определяем расширения на верхнем уровне,т.е.непосредственно под пакетами:</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="e5f579f208747beb161cf00d47a3a0c086f81dbe" translate="yes" xml:space="preserve">
          <source>MouseEventInit</source>
          <target state="translated">MouseEventInit</target>
        </trans-unit>
        <trans-unit id="19754c53e87ae21affdf187e21540a29ec7c1fa2" translate="yes" xml:space="preserve">
          <source>Much like we reference an input element, we can access other elements on the page, casting them to the appropriate types.</source>
          <target state="translated">Подобно тому,как мы ссылаемся на входной элемент,мы можем получить доступ к другим элементам на странице,приведя их к соответствующим типам.</target>
        </trans-unit>
        <trans-unit id="85e61eaa48d6be8dae51bf80212b85c25bd2b301" translate="yes" xml:space="preserve">
          <source>Much the same way as regular properties, the properties declared in the primary constructor can be mutable (&lt;em&gt;var&lt;/em&gt;) or read-only (&lt;em&gt;val&lt;/em&gt;).</source>
          <target state="translated">Во многом так же, как и обычные свойства, свойства, объявленные в основном конструкторе, могут быть изменяемыми ( &lt;em&gt;var&lt;/em&gt; ) или доступными только для чтения ( &lt;em&gt;val&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf10a69dc3111e2f0b70a7a3b5fcde0eb5de58f0" translate="yes" xml:space="preserve">
          <source>Multiplatform &lt;code&gt;Random&lt;/code&gt;</source>
          <target state="translated">Мультиплатформенный &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d27d69385dad1ecc38485d70b593ff3be6501e1" translate="yes" xml:space="preserve">
          <source>Multiplatform Gradle Project</source>
          <target state="translated">Многоплатформенный проект &quot;Колыбель</target>
        </trans-unit>
        <trans-unit id="b476304566bdb2c8284f4c5fabc7060e30563d1f" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin Library</source>
          <target state="translated">Мультиплатформенная библиотека Котлин</target>
        </trans-unit>
        <trans-unit id="594342484b7fa8723561cd74a56adf5ed5eecd56" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin library</source>
          <target state="translated">Мультиплатформенная библиотека Котлин</target>
        </trans-unit>
        <trans-unit id="abdd2b4ca66085ea36500996c307f3c54d5bee0a" translate="yes" xml:space="preserve">
          <source>Multiplatform Libraries</source>
          <target state="translated">Мультиплатформенные библиотеки</target>
        </trans-unit>
        <trans-unit id="49bdb75dde412727c37ad9cfdc25f84b9800e1ee" translate="yes" xml:space="preserve">
          <source>Multiplatform Programming</source>
          <target state="translated">Мультиплатформенное программирование</target>
        </trans-unit>
        <trans-unit id="8831ff8afbd886576a6d26e7a38c2a2945370e5f" translate="yes" xml:space="preserve">
          <source>Multiplatform Project: iOS and Android</source>
          <target state="translated">Мультиплатформенный проект:iOS и Android</target>
        </trans-unit>
        <trans-unit id="5cff52171a748c24fbdfa2675a9193d1e17c8b90" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects</source>
          <target state="translated">Многоплатформенные проекты</target>
        </trans-unit>
        <trans-unit id="30ece0cd52430a4d7a64233600e1721dbcbbe2bf" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects (experimental)</source>
          <target state="translated">Многоплатформенные проекты (экспериментальные)</target>
        </trans-unit>
        <trans-unit id="0198731e127deda4e2a86e65a7c2c819b3c35ae8" translate="yes" xml:space="preserve">
          <source>Multiplatform documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f424e82581dd0443f6b1cfe8761404b9445347c" translate="yes" xml:space="preserve">
          <source>Multiplatform programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce33eff96bb2026a847a2a553a328f131ebdfe5" translate="yes" xml:space="preserve">
          <source>Multiplatform projects</source>
          <target state="translated">Мультиплатформенные проекты</target>
        </trans-unit>
        <trans-unit id="48104e942ea0eb10a48e224f17bd6af63a0f01ad" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are a new &lt;strong&gt;experimental&lt;/strong&gt; feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin &amp;ndash; JVM, JavaScript and (in the future) Native. In a multiplatform project, you have three kinds of modules:</source>
          <target state="translated">Мультиплатформенные проекты - это новая &lt;strong&gt;экспериментальная&lt;/strong&gt; функция в Kotlin 1.2, позволяющая повторно использовать код между целевыми платформами, поддерживаемыми Kotlin - JVM, JavaScript и (в будущем) Native. В мультиплатформенном проекте у вас есть три типа модулей:</target>
        </trans-unit>
        <trans-unit id="56c55ee3ca3b8c8dc0a5fe577d6b3cbe7b6bf668" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language and tooling features described in this document are subject to change in future Kotlin versions.</source>
          <target state="translated">Мультиплатформенные проекты являются экспериментальной функцией в Kotlin 1.2 и 1.3.Все языковые и инструментальные возможности,описанные в этом документе,могут быть изменены в будущих версиях Kotlin.</target>
        </trans-unit>
        <trans-unit id="7e1b4e8641ccf9f8084108431aa99a93d1fa43a8" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. Language features and tooling may change in future Kotlin versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47f8ee1f56229364d475a5b4995314b84d9fc4e" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may receive from the same channel, distributing work between themselves. Let us start with a producer coroutine that is periodically producing integers (ten numbers per second):</source>
          <target state="translated">Из одного и того же канала могут получать несколько коруселей,распределяя работу между собой.Начнем с корутины-производителя,которая периодически производит целые числа (десять чисел в секунду):</target>
        </trans-unit>
        <trans-unit id="264744e655406950142eec2a53dc539eed8a5fd7" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may send to the same channel. For example, let us have a channel of strings, and a suspending function that repeatedly sends a specified string to this channel with a specified delay:</source>
          <target state="translated">На один и тот же канал могут посылать несколько коруселей.Например,давайте иметь канал строк и функцию приостановки,которая многократно посылает в этот канал указанную строку с указанной задержкой:</target>
        </trans-unit>
        <trans-unit id="9d79d3118202ae1d668fb56014f9cb20b36159e5" translate="yes" xml:space="preserve">
          <source>Multiplies this value by the other value.</source>
          <target state="translated">Умножает это значение на другое.</target>
        </trans-unit>
        <trans-unit id="f342e79f479c63b3a6f1a4035901daea4fbf30b9" translate="yes" xml:space="preserve">
          <source>MustBeDocumented</source>
          <target state="translated">MustBeDocumented</target>
        </trans-unit>
        <trans-unit id="07b00606431523d4ebea7077981984b607d973e8" translate="yes" xml:space="preserve">
          <source>Mutable closure variables</source>
          <target state="translated">Мутируемые переменные закрытия</target>
        </trans-unit>
        <trans-unit id="e427611262df2a9a50ee135e0fceaecfa0c80c7f" translate="yes" xml:space="preserve">
          <source>Mutable concurrently accessible data buffer. Could be accessed from several workers simulteniously.</source>
          <target state="translated">Мутируемый одновременно буфер данных.Может быть доступен одновременно нескольким работникам.</target>
        </trans-unit>
        <trans-unit id="46fb0a3dd2497d28351f3b643be68bf38c4dcf04" translate="yes" xml:space="preserve">
          <source>Mutable iterators</source>
          <target state="translated">Мутируемые итераторы</target>
        </trans-unit>
        <trans-unit id="9b7b2307fe92cd7c012fa39281f7b175b249dd6e" translate="yes" xml:space="preserve">
          <source>MutableCollection</source>
          <target state="translated">MutableCollection</target>
        </trans-unit>
        <trans-unit id="42724994b4f6f408170a142d4bb3a6bfa7198849" translate="yes" xml:space="preserve">
          <source>MutableCollection.iterator</source>
          <target state="translated">MutableCollection.iterator</target>
        </trans-unit>
        <trans-unit id="1a5033d42eefb58adbea823fa5255b0aed1d662e" translate="yes" xml:space="preserve">
          <source>MutableData</source>
          <target state="translated">MutableData</target>
        </trans-unit>
        <trans-unit id="5e9e097c14385f745d368faabbd3854a67b05b46" translate="yes" xml:space="preserve">
          <source>MutableEntry</source>
          <target state="translated">MutableEntry</target>
        </trans-unit>
        <trans-unit id="8a4f4102af09300cf876f9a6460618caaa96575a" translate="yes" xml:space="preserve">
          <source>MutableIterable</source>
          <target state="translated">MutableIterable</target>
        </trans-unit>
        <trans-unit id="a652e5941b9ff793ccc9e659b88bf1a8f5227c3a" translate="yes" xml:space="preserve">
          <source>MutableIterator</source>
          <target state="translated">MutableIterator</target>
        </trans-unit>
        <trans-unit id="49e02d16b11d601b6e4902190c5bca350a9202fc" translate="yes" xml:space="preserve">
          <source>MutableList</source>
          <target state="translated">MutableList</target>
        </trans-unit>
        <trans-unit id="4c650d57f6075cf5940d694638ac9e4ec8e77bc6" translate="yes" xml:space="preserve">
          <source>MutableListIterator</source>
          <target state="translated">MutableListIterator</target>
        </trans-unit>
        <trans-unit id="f20ff48f1ceb7119a78b4b13a251cf2c7628b7ac" translate="yes" xml:space="preserve">
          <source>MutableMap</source>
          <target state="translated">MutableMap</target>
        </trans-unit>
        <trans-unit id="c0a289c1f11c0248072d86bca1271c7246850c9c" translate="yes" xml:space="preserve">
          <source>MutableSet</source>
          <target state="translated">MutableSet</target>
        </trans-unit>
        <trans-unit id="0b5d551add97f7ca81d05d95c5a9f114421d02ad" translate="yes" xml:space="preserve">
          <source>Mutating the backing field of a read-only property by assigning &lt;code&gt;field = ...&lt;/code&gt; in the custom getter has been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">Изменение поля поддержки свойства, доступного только для чтения, путем присвоения &lt;code&gt;field = ...&lt;/code&gt; в настраиваемом геттере устарело, с предупреждением в Kotlin 1.2 и ошибкой в ​​Kotlin 1.3.</target>
        </trans-unit>
        <trans-unit id="d9e09542ba7562ba06b3618d585343bb16717cc0" translate="yes" xml:space="preserve">
          <source>MutationObserver</source>
          <target state="translated">MutationObserver</target>
        </trans-unit>
        <trans-unit id="bf760ce86085d0556b58a1fb2886ad6300cf25c9" translate="yes" xml:space="preserve">
          <source>MutationObserverInit</source>
          <target state="translated">MutationObserverInit</target>
        </trans-unit>
        <trans-unit id="902e161ec72b34937173fb6ae6f1167c6c4b933a" translate="yes" xml:space="preserve">
          <source>MutationRecord</source>
          <target state="translated">MutationRecord</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">Взаимное исключение</target>
        </trans-unit>
        <trans-unit id="f2a0cc7430b6ab201c123d93595f5409656e44aa" translate="yes" xml:space="preserve">
          <source>Mutual exclusion solution to the problem is to protect all modifications of the shared state with a &lt;em&gt;critical section&lt;/em&gt; that is never executed concurrently. In a blocking world you'd typically use &lt;code&gt;synchronized&lt;/code&gt; or &lt;code&gt;ReentrantLock&lt;/code&gt; for that. Coroutine's alternative is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt;. It has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;lock&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;unlock&lt;/a&gt; functions to delimit a critical section. The key difference is that &lt;code&gt;Mutex.lock()&lt;/code&gt; is a suspending function. It does not block a thread.</source>
          <target state="translated">Решением проблемы взаимного исключения является защита всех модификаций общего состояния с помощью &lt;em&gt;критического раздела,&lt;/em&gt; который никогда не выполняется одновременно. В мире блокировки вы обычно используете для этого &lt;code&gt;synchronized&lt;/code&gt; или &lt;code&gt;ReentrantLock&lt;/code&gt; . Альтернатива &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Coroutine&lt;/a&gt; называется Mutex . Он имеет функции &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;блокировки&lt;/a&gt; и &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;разблокировки,&lt;/a&gt; чтобы ограничить критический раздел. Ключевое отличие состоит в том, что &lt;code&gt;Mutex.lock()&lt;/code&gt; - это функция приостановки. Он не блокирует поток.</target>
        </trans-unit>
        <trans-unit id="e6a87480ef216b736cda78776d20937ae965a5a1" translate="yes" xml:space="preserve">
          <source>My first coroutine</source>
          <target state="translated">Мой первый корутин</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="ac5af3d78fb9a248a0c8878049fa45cb722c5609" translate="yes" xml:space="preserve">
          <source>NEGATIVE_INFINITY</source>
          <target state="translated">NEGATIVE_INFINITY</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="19b5db1284eda5fe55423cf6ff666bbd91d48790" translate="yes" xml:space="preserve">
          <source>NONSPACING_MARK</source>
          <target state="translated">NONSPACING_MARK</target>
        </trans-unit>
        <trans-unit id="a711913b07f219db3720165b1cc42ba33ab84d07" translate="yes" xml:space="preserve">
          <source>NON_SPACING_MARK</source>
          <target state="translated">NON_SPACING_MARK</target>
        </trans-unit>
        <trans-unit id="b12d9f3adce16f3c42e185c9323b0f2c05d0d02a" translate="yes" xml:space="preserve">
          <source>NOTE: Octal literals are not supported.</source>
          <target state="translated">ПРИМЕЧАНИЕ:Октальные буквы не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="c820cc676951d2a6935d55d3c748ef2d4229e0ef" translate="yes" xml:space="preserve">
          <source>NSArray</source>
          <target state="translated">NSArray</target>
        </trans-unit>
        <trans-unit id="850a25e67ede967c8226916d9435ee3fa9fe30c0" translate="yes" xml:space="preserve">
          <source>NSDictionary</source>
          <target state="translated">NSDictionary</target>
        </trans-unit>
        <trans-unit id="88142d93bc155af7430eda23b521adf5177befb3" translate="yes" xml:space="preserve">
          <source>NSMutableArray</source>
          <target state="translated">NSMutableArray</target>
        </trans-unit>
        <trans-unit id="093cc39541f1d88e9c8d7815809e04abdc468222" translate="yes" xml:space="preserve">
          <source>NSMutableDictionary</source>
          <target state="translated">NSMutableDictionary</target>
        </trans-unit>
        <trans-unit id="6f353d0803276b29f669e8e00d5912e0735d118f" translate="yes" xml:space="preserve">
          <source>NSMutableString</source>
          <target state="translated">NSMutableString</target>
        </trans-unit>
        <trans-unit id="21b6f3d1ecc982003af64b405b1aec1eeffcbd63" translate="yes" xml:space="preserve">
          <source>NSNumber</source>
          <target state="translated">NSNumber</target>
        </trans-unit>
        <trans-unit id="6049050154f9c68876906ec983b62a8beb7bfd87" translate="yes" xml:space="preserve">
          <source>NSSet</source>
          <target state="translated">NSSet</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed2a70884b6ea61a0ea998c7fe86ebc6c43c39e1" translate="yes" xml:space="preserve">
          <source>Name of the module being compiled</source>
          <target state="translated">Название компилируемого модуля</target>
        </trans-unit>
        <trans-unit id="bd9b36517a10ed825bfe97b96fd841ffbfd62dda" translate="yes" xml:space="preserve">
          <source>Name of the worker, as specified in &lt;a href=&quot;start&quot;&gt;Worker.start&lt;/a&gt; or &quot;worker $id&quot; by default,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4efab9c724a7839dff5f1e0118b1a9b242fe8997" translate="yes" xml:space="preserve">
          <source>Name of this parameter as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the parameter has no name or its name is not available at runtime. Examples of nameless parameters include &lt;code&gt;this&lt;/code&gt; instance for member functions, extension receiver for extension functions or properties, parameters of Java methods compiled without the debug information, and others.</source>
          <target state="translated">Имя этого параметра, как оно было объявлено в исходном коде, или значение &lt;code&gt;null&lt;/code&gt; , если параметр не имеет имени или его имя недоступно во время выполнения. Примеры безымянных параметров включают &lt;code&gt;this&lt;/code&gt; экземпляр для функций-членов, приемник расширения для функций или свойств расширения, параметры методов Java, скомпилированных без отладочной информации, и другие.</target>
        </trans-unit>
        <trans-unit id="9e0268761f1a46defda13527e24a738481491b83" translate="yes" xml:space="preserve">
          <source>Name translation</source>
          <target state="translated">Перевод названия</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="translated">Именные аргументы</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">Названные аргументы</target>
        </trans-unit>
        <trans-unit id="7eee412e511b81f184e8fdcdd0d16df4490ee091" translate="yes" xml:space="preserve">
          <source>NamedNodeMap</source>
          <target state="translated">NamedNodeMap</target>
        </trans-unit>
        <trans-unit id="89ed0927522265d199caf008b2d935b4dc13e4ec" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Grouping&lt;/code&gt; supports the following operations:</source>
          <target state="translated">А именно, &lt;code&gt;Grouping&lt;/code&gt; поддерживает следующие операции:</target>
        </trans-unit>
        <trans-unit id="ce7873d11ca1350ea35c4e7edcc86d0f3faedfbb" translate="yes" xml:space="preserve">
          <source>Names for backing properties</source>
          <target state="translated">Наименования для свойств подложки</target>
        </trans-unit>
        <trans-unit id="d5e90b6eaa5ac7d68bfe0de19720901740a9662f" translate="yes" xml:space="preserve">
          <source>Names for test methods</source>
          <target state="translated">Наименования для методов испытаний</target>
        </trans-unit>
        <trans-unit id="1bbe1b5bbc9b48ae056a0ba828b7773769b4e6a7" translate="yes" xml:space="preserve">
          <source>Names in links are resolved using the same rules as if the name was used inside the element being documented. In particular, this means that if you have imported a name into the current file, you don't need to fully qualify it when you use it in a KDoc comment.</source>
          <target state="translated">Имена в ссылках разрешаются по тем же правилам,как если бы имя использовалось внутри документируемого элемента.В частности,это означает,что если вы импортировали имя в текущий файл,вам не нужно полностью его квалифицировать,когда вы используете его в комментарии KDoc.</target>
        </trans-unit>
        <trans-unit id="c5380f68245bbc672ad92afb09b8fb6715ad3ca6" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use camel humps:</source>
          <target state="translated">Названия классов и объектов начинаются с заглавной буквы и используют верблюжьи горбы:</target>
        </trans-unit>
        <trans-unit id="3b4a6dab1202620b73c1005110fe77d753a54e9f" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use the camel case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc15464a07c43531a73eacebb7c301c643be9755" translate="yes" xml:space="preserve">
          <source>Names of constants (properties marked with &lt;code&gt;const&lt;/code&gt;, or top-level or object &lt;code&gt;val&lt;/code&gt; properties with no custom &lt;code&gt;get&lt;/code&gt; function that hold deeply immutable data) should use uppercase underscore-separated names:</source>
          <target state="translated">Имена констант (свойства, помеченные как &lt;code&gt;const&lt;/code&gt; , свойства верхнего уровня или объекта &lt;code&gt;val&lt;/code&gt; без специальной функции &lt;code&gt;get&lt;/code&gt; , которые содержат глубоко неизменяемые данные) должны использовать имена, разделенные нижним подчеркиванием в верхнем регистре:</target>
        </trans-unit>
        <trans-unit id="ed152e23d368497078b7ae5dc12a67a09aef9537" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use camel humps and no underscores:</source>
          <target state="translated">Имена функций,свойств и локальных переменных начинаются с строчной буквы и используют верблюжьи горбы и без знаков подчеркивания:</target>
        </trans-unit>
        <trans-unit id="1e715a573269457e03280d22e2a0d8e880e4fdae" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use the camel case and no underscores:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe2ff19a7f565c3d30edceae570abf2351b799b" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.myproject&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use camel humps (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">Имена пакетов всегда &lt;code&gt;org.example.myproject&lt;/code&gt; нижнем регистре и не используют подчеркивания ( org.example.myproject ). Использование многословных имен обычно не рекомендуется, но если вам действительно нужно использовать несколько слов, вы можете просто объединить их вместе или использовать верблюжьи горбы ( &lt;code&gt;org.example.myProject&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d506a4b97208834d8b60a4f447f3486fac1cf5be" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.project&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use the camel case (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7adf5dd484e8eda6819e4b4ab1a277a17337ee" translate="yes" xml:space="preserve">
          <source>Names of properties holding references to singleton objects can use the same naming style as &lt;code&gt;object&lt;/code&gt; declarations:</source>
          <target state="translated">Имена свойств, содержащих ссылки на одноэлементные объекты, могут использовать тот же стиль именования, что и объявления &lt;code&gt;object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ae79cc54e87e697302be7b45dcff0dc1ad4a5a71" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use camel-case names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd1c430f56a1096d7535c6bff1f0b002bb217ee" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use regular camel-hump names:</source>
          <target state="translated">Имена свойств объектов верхнего уровня или объектов,в которых хранятся объекты с поведенческими или мутирующими данными,должны использовать обычные имена верблюжьих горбов:</target>
        </trans-unit>
        <trans-unit id="a821637ed465037f50fb45146c7157533ce303ab" translate="yes" xml:space="preserve">
          <source>Naming coroutines for debugging</source>
          <target state="translated">Название корутинов для отладки</target>
        </trans-unit>
        <trans-unit id="b8f89bc873847bc6acb441471008e2ef77f271a2" translate="yes" xml:space="preserve">
          <source>Naming rules</source>
          <target state="translated">Правила наименования</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="712b0ca62af66efef9be01024a01163935118cd1" translate="yes" xml:space="preserve">
          <source>NativeFreeablePlacement</source>
          <target state="translated">NativeFreeablePlacement</target>
        </trans-unit>
        <trans-unit id="8c2ed68939229f0bed6cd8b6f2cb9306658a5c17" translate="yes" xml:space="preserve">
          <source>NativePlacement</source>
          <target state="translated">NativePlacement</target>
        </trans-unit>
        <trans-unit id="f6500269f9c3fb94b4438bc913d694314febde22" translate="yes" xml:space="preserve">
          <source>NativePointed</source>
          <target state="translated">NativePointed</target>
        </trans-unit>
        <trans-unit id="82e059ceb59aa7b7713c457045493d8d28dcc3f4" translate="yes" xml:space="preserve">
          <source>NativePtr</source>
          <target state="translated">NativePtr</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">естественный порядок</target>
        </trans-unit>
        <trans-unit id="c8e6f949b8ada118fdafbdc6ee8783d697f007cb" translate="yes" xml:space="preserve">
          <source>Navigator</source>
          <target state="translated">Navigator</target>
        </trans-unit>
        <trans-unit id="e7b5edc7e8cb311a0b039335c594c9a957eb3175" translate="yes" xml:space="preserve">
          <source>NavigatorConcurrentHardware</source>
          <target state="translated">NavigatorConcurrentHardware</target>
        </trans-unit>
        <trans-unit id="c539be135337dd03c6301959fad0ce1bee475889" translate="yes" xml:space="preserve">
          <source>NavigatorContentUtils</source>
          <target state="translated">NavigatorContentUtils</target>
        </trans-unit>
        <trans-unit id="00b43738cf147df0c752dcea119b953d47ded336" translate="yes" xml:space="preserve">
          <source>NavigatorCookies</source>
          <target state="translated">NavigatorCookies</target>
        </trans-unit>
        <trans-unit id="ca09397d83fa076ca8fa71c95007223165d66fb5" translate="yes" xml:space="preserve">
          <source>NavigatorID</source>
          <target state="translated">NavigatorID</target>
        </trans-unit>
        <trans-unit id="1c556456dba6623478e38282faadace5b5f02feb" translate="yes" xml:space="preserve">
          <source>NavigatorLanguage</source>
          <target state="translated">NavigatorLanguage</target>
        </trans-unit>
        <trans-unit id="b3ab2a10f83370ceafad9f996d8048d28d1a1363" translate="yes" xml:space="preserve">
          <source>NavigatorOnLine</source>
          <target state="translated">NavigatorOnLine</target>
        </trans-unit>
        <trans-unit id="e94d6507f620430ae9754053564c70782f33c7c9" translate="yes" xml:space="preserve">
          <source>NavigatorPlugins</source>
          <target state="translated">NavigatorPlugins</target>
        </trans-unit>
        <trans-unit id="e7f4b2c609e0e06e378710e78e2e3f9dbec6df11" translate="yes" xml:space="preserve">
          <source>Negative values show that it's less than the argument.</source>
          <target state="translated">Отрицательные значения показывают,что это меньше,чем аргумент.</target>
        </trans-unit>
        <trans-unit id="789280e01339d5a915f0345cf138b9b4fb941c8e" translate="yes" xml:space="preserve">
          <source>Nested and Inner Classes</source>
          <target state="translated">Вложенный и внутренний классы</target>
        </trans-unit>
        <trans-unit id="ee69ace2d0864bd815e214e20536f1f61364fc0f" translate="yes" xml:space="preserve">
          <source>Nested classifiers in enum entries</source>
          <target state="translated">Вложенные классификаторы в перечислениях</target>
        </trans-unit>
        <trans-unit id="40c58381d790a3e7eec655ca2a16667d8a074dd3" translate="yes" xml:space="preserve">
          <source>Nested declarations in annotation classes</source>
          <target state="translated">Вложенные заявления в классах аннотаций</target>
        </trans-unit>
        <trans-unit id="d053911ed6d5cc20ee675fd6a4520e78c20b1efb" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;B&quot; in the Unicode specification.</source>
          <target state="translated">Нейтральный двунаправленный символ типа &quot;В&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="8fd58ea9d9361ae87799e3e0adb497216a8850cd" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;ON&quot; in the Unicode specification.</source>
          <target state="translated">Нейтральный двунаправленный символ типа &quot;ON&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="cc8492cfce3dced2f8758c8c41b89e84144de788" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;S&quot; in the Unicode specification.</source>
          <target state="translated">Нейтральный двунаправленный символ типа &quot;S&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="61ee633fcd6ff884b460c34fd4f698e42b8d1f57" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;WS&quot; in the Unicode specification.</source>
          <target state="translated">Нейтральный двунаправленный символьный тип &quot;WS&quot; в спецификации Юникода.</target>
        </trans-unit>
        <trans-unit id="9ac5f98640f23386ec33233fa4af214ae29bb68c" translate="yes" xml:space="preserve">
          <source>Never equal to null: for any non-null value &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(null)&lt;/code&gt; should return false.</source>
          <target state="translated">Никогда не равен нулю: для любого ненулевого значения &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.equals(null)&lt;/code&gt; должен возвращать ложь.</target>
        </trans-unit>
        <trans-unit id="c8ca579cfa2a0bc063bd07e3a4d9c7f65e8e3087" translate="yes" xml:space="preserve">
          <source>Never put a space after &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, or before &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">Никогда не ставьте пробел после &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; или перед &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9294e60ab9df0dbecb3a72a47335eee294748f65" translate="yes" xml:space="preserve">
          <source>Never put a space around &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;?.&lt;/code&gt;: &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt;, &lt;code&gt;foo?.bar()&lt;/code&gt;</source>
          <target state="translated">Никогда не оставляйте пространство вокруг &lt;code&gt;.&lt;/code&gt; или &lt;code&gt;?.&lt;/code&gt; : &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt; , &lt;code&gt;foo?.bar()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="989c5da0440d6ef3c75ca61d82d832246ce632de" translate="yes" xml:space="preserve">
          <source>New Kotlin/JS IR compiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845d99d67846936e2a2ecffc0c1f73a93b077848" translate="yes" xml:space="preserve">
          <source>New extensions for &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;CharSequence&lt;/code&gt; cover such use cases as buffering or batch processing (&lt;code&gt;chunked&lt;/code&gt;), sliding window and computing sliding average (&lt;code&gt;windowed&lt;/code&gt;) , and processing pairs of subsequent items (&lt;code&gt;zipWithNext&lt;/code&gt;):</source>
          <target state="translated">Новые расширения для &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;CharSequence&lt;/code&gt; охватывают такие варианты использования, как буферизация или пакетная обработка ( &lt;code&gt;chunked&lt;/code&gt; ), скользящее окно и вычисление скользящего среднего ( &lt;code&gt;windowed&lt;/code&gt; ) и обработка пар последующих элементов ( &lt;code&gt;zipWithNext&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e22e233ab95d5952f18b874d9870e1b80280d15d" translate="yes" xml:space="preserve">
          <source>New functions were added for converting &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; to and from their bit representations:</source>
          <target state="translated">Были добавлены новые функции для преобразования &lt;code&gt;Double&lt;/code&gt; и &lt;code&gt;Float&lt;/code&gt; в их битовые представления и обратно:</target>
        </trans-unit>
        <trans-unit id="1c41e8d2c414e76e3966946fcc4d1e55e43e96ed" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dcc6d65c266a50c3f667c9e5ea8aa135aa58a6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;basic-syntax&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">Впервые на Котлине? Взгляните на страницу &amp;laquo; &lt;a href=&quot;basic-syntax&quot;&gt;Начало работы&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9559254cbe41a97686cb7a5c40de455ecdf8ee6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Visit &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting started with Kotlin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">Следующие шаги</target>
        </trans-unit>
        <trans-unit id="5079a9846101e11db84a1abb592a9473e268055f" translate="yes" xml:space="preserve">
          <source>Next open a new terminal and install Kotlin with:</source>
          <target state="translated">Далее откройте новый терминал и установите Kotlin с:</target>
        </trans-unit>
        <trans-unit id="2f460c75911314c0c9543c3367959a31445cb463" translate="yes" xml:space="preserve">
          <source>Next, let's include the following line of code into the &lt;code&gt;MainActivity&lt;/code&gt; class from the &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; file, to the end of the &lt;code&gt;onCreate&lt;/code&gt; method:</source>
          <target state="translated">Затем давайте включим следующую строку кода в класс &lt;code&gt;MainActivity&lt;/code&gt; из файла &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; в конец метода &lt;code&gt;onCreate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61e1f7fc790c5246a6e519f4f67f422c4a517358" translate="yes" xml:space="preserve">
          <source>Next, we need to create the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file with the following content:</source>
          <target state="translated">Затем нам нужно создать файл &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="fba44f74cfbe24d927a6f2e32c74f105a6d9ca00" translate="yes" xml:space="preserve">
          <source>Next: Annotations &amp;rarr;</source>
          <target state="translated">Далее: Аннотации &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="00ef744e43f0f9ea134186c2ef008876b94cfb5d" translate="yes" xml:space="preserve">
          <source>Next: Classes &amp;rarr;</source>
          <target state="translated">Далее: Классы &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="c8735b85302131b9db681cecd1fb40aa277a0558" translate="yes" xml:space="preserve">
          <source>Next: Collections &amp;rarr;</source>
          <target state="translated">Далее: Коллекции &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="07999039cc4614cf9d9c83d8a64e7926f8829364" translate="yes" xml:space="preserve">
          <source>Next: Compiling and running &amp;rarr;</source>
          <target state="translated">Далее: Компиляция и запуск &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="f20d28acc929c74946791930cf9c56d2978b64a8" translate="yes" xml:space="preserve">
          <source>Next: Conditionals &amp;rarr;</source>
          <target state="translated">Далее: Условные выражения &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="840074b0ba8fd90b4e90aa33d45718551b373169" translate="yes" xml:space="preserve">
          <source>Next: Declaring variables &amp;rarr;</source>
          <target state="translated">Далее: Объявление переменных &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="cce5126b0175141ca7a8267a7936ebe65fe68d5f" translate="yes" xml:space="preserve">
          <source>Next: Documentation &amp;rarr;</source>
          <target state="translated">Далее: Документация &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="fa55701df6604b3cecc0d604af09a04554d557b6" translate="yes" xml:space="preserve">
          <source>Next: Exceptions &amp;rarr;</source>
          <target state="translated">Далее: Исключения &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6b6aa34eef4e603a14fc427c78ce11728dd25836" translate="yes" xml:space="preserve">
          <source>Next: Extension functions/properties &amp;rarr;</source>
          <target state="translated">Далее: Функции / свойства расширения &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="085547cea36d9036af28992fd35c78130fafdd20" translate="yes" xml:space="preserve">
          <source>Next: File I/O &amp;rarr;</source>
          <target state="translated">Далее: Файловый ввод-вывод &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1ad7d1fc04a3f8f5bb3171b2738d368b2e7962ea" translate="yes" xml:space="preserve">
          <source>Next: Functional programming &amp;rarr;</source>
          <target state="translated">Далее: Функциональное программирование &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="4ca230bdec76005c5c8ecf036e517045996d632a" translate="yes" xml:space="preserve">
          <source>Next: Functions &amp;rarr;</source>
          <target state="translated">Далее: Функции &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="ee174e846c5088dfbb38266ba627304b28a4e778" translate="yes" xml:space="preserve">
          <source>Next: Generics &amp;rarr;</source>
          <target state="translated">Далее: Дженерики &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1fc3a42a52feb37755a354083cafdc34a3336119" translate="yes" xml:space="preserve">
          <source>Next: Hello World &amp;rarr;</source>
          <target state="translated">Далее: Hello World &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="3e18f658842ac7800584f5830d0086c6615ba81e" translate="yes" xml:space="preserve">
          <source>Next: Inheritance &amp;rarr;</source>
          <target state="translated">Далее: Наследование &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="e300f7cf6a03c09bab1b47c326855a60fe6e07fb" translate="yes" xml:space="preserve">
          <source>Next: Loops &amp;rarr;</source>
          <target state="translated">Далее: Петли &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="42aae1e29d68a1d88913d08cee33e89180a579d7" translate="yes" xml:space="preserve">
          <source>Next: Member references and reflection &amp;rarr;</source>
          <target state="translated">Далее: Ссылки на элементы и отражение &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="47130dd2717d7971c3c94623669be8f3f6e6f3ff" translate="yes" xml:space="preserve">
          <source>Next: Null safety &amp;rarr;</source>
          <target state="translated">Далее: Нулевая безопасность &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="86e91a1d2169b2b6d5f0e4158807082816cf024d" translate="yes" xml:space="preserve">
          <source>Next: Objects and companion objects &amp;rarr;</source>
          <target state="translated">Далее: Объекты и сопутствующие объекты &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6bfa5e253a9933523c52548db5718fffcec08ff4" translate="yes" xml:space="preserve">
          <source>Next: Packages and imports &amp;rarr;</source>
          <target state="translated">Далее: Пакеты и импорт &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="61b315e1a975491d53d3e93505ae2e73a35eccf9" translate="yes" xml:space="preserve">
          <source>Next: Primitive data types and their limitations &amp;rarr;</source>
          <target state="translated">Далее: Примитивные типы данных и их ограничения &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="a8e3f58e4df0923f458764df8d805bc1daaebc52" translate="yes" xml:space="preserve">
          <source>Next: Scoped resource usage &amp;rarr;</source>
          <target state="translated">Далее: Использование ограниченного ресурса &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="d22ef24051b74c0f8f3a98dbd34b162df22e8d8a" translate="yes" xml:space="preserve">
          <source>Next: Strings &amp;rarr;</source>
          <target state="translated">Далее: Струны &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="df94caa7ffe6e8dba6f94ac077da12da6df4dd88" translate="yes" xml:space="preserve">
          <source>Next: Visibility modifiers &amp;rarr;</source>
          <target state="translated">Далее: Модификаторы видимости &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="dd6dd817ee9557c6ebd9ce223abe7e65e35724c3" translate="yes" xml:space="preserve">
          <source>Nice utility functions</source>
          <target state="translated">Хорошие функции утилиты</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="fc6d6d07a9da4b1cf8d3f863c9932b05d0b9d378" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;EXPRESSION&lt;/code&gt; and &lt;code&gt;FILE&lt;/code&gt; among &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;targets&lt;/a&gt;</source>
          <target state="translated">Нет &lt;code&gt;EXPRESSION&lt;/code&gt; и &lt;code&gt;FILE&lt;/code&gt; среди &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;целей&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d50a5c00dba30dbb17216b740546f411fd49910a" translate="yes" xml:space="preserve">
          <source>No custom getter</source>
          <target state="translated">Нет пользовательского getter</target>
        </trans-unit>
        <trans-unit id="c2792086f80dff691fc70c60e9944bd70ee578bb" translate="yes" xml:space="preserve">
          <source>No locks are used to synchronize an access to the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value; if the instance is accessed from multiple threads, its behavior is undefined.</source>
          <target state="translated">Никакие блокировки не используются для синхронизации доступа к значению экземпляра &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; ; если к экземпляру обращаются из нескольких потоков, его поведение не определено.</target>
        </trans-unit>
        <trans-unit id="1576fb8454236b0d4fa99182ffbcc64b6805f9d7" translate="yes" xml:space="preserve">
          <source>No need to mark the Application class as &lt;em&gt;open&lt;/em&gt; since we are using the &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle plugin which does that automatically.</source>
          <target state="translated">Нет необходимости отмечать класс Application как &lt;em&gt;открытый,&lt;/em&gt; поскольку мы используем плагин Gradle &lt;em&gt;kotlin-spring,&lt;/em&gt; который делает это автоматически.</target>
        </trans-unit>
        <trans-unit id="1ea178000db803133ca4ed5bf0f26cf40a2ac141" translate="yes" xml:space="preserve">
          <source>No parameters.</source>
          <target state="translated">Параметров нет.</target>
        </trans-unit>
        <trans-unit id="a39dbb3db1c73d98fb6e9bf0a6cc7fe2780640aa" translate="yes" xml:space="preserve">
          <source>No raw types</source>
          <target state="translated">Нет типов сырья</target>
        </trans-unit>
        <trans-unit id="4512f94421443be3bb6fe68bb037823683ccfd0a" translate="yes" xml:space="preserve">
          <source>No-arg compiler plugin</source>
          <target state="translated">плагин компилятора No-arg</target>
        </trans-unit>
        <trans-unit id="ec11a5bdeaa38cafa1809cd0b1418fa7f8f3cfef" translate="yes" xml:space="preserve">
          <source>No. Kotlin lets you choose between generating Java 6 and Java 8 compatible bytecode. More optimal byte code may be generated for higher versions of the platform.</source>
          <target state="translated">Нет.Kotlin позволяет выбирать между генерацией Java 6 и Java 8 совместимых байткодов.Более оптимальный байтовый код может быть сгенерирован для более высоких версий платформы.</target>
        </trans-unit>
        <trans-unit id="ce3234172e6888dbe6cf68e5d69aca93bdbdb6aa" translate="yes" xml:space="preserve">
          <source>No: called without the context object</source>
          <target state="translated">Нет:вызывается без объекта контекста</target>
        </trans-unit>
        <trans-unit id="44924246111ca028f4b377861fa8b1a56b2f8f3f" translate="yes" xml:space="preserve">
          <source>No: takes the context object as an argument.</source>
          <target state="translated">Нет:принимает в качестве аргумента объект контекста.</target>
        </trans-unit>
        <trans-unit id="23a71e363ee25bc12526201fd5e1559555edeab5" translate="yes" xml:space="preserve">
          <source>NoSuchElementException</source>
          <target state="translated">NoSuchElementException</target>
        </trans-unit>
        <trans-unit id="9a296716d89fec45e837ec162f0a3cdfae0666f6" translate="yes" xml:space="preserve">
          <source>NoSuchFileException</source>
          <target state="translated">NoSuchFileException</target>
        </trans-unit>
        <trans-unit id="8e965431f22047ddfc939473709e81428fafe4f0" translate="yes" xml:space="preserve">
          <source>NoSuchPropertyException</source>
          <target state="translated">NoSuchPropertyException</target>
        </trans-unit>
        <trans-unit id="dd82911bf9c2f7cf6fe3c3a3a0486e6fd4980949" translate="yes" xml:space="preserve">
          <source>NoWhenBranchMatchedException</source>
          <target state="translated">NoWhenBranchMatchedException</target>
        </trans-unit>
        <trans-unit id="6d1452836a5e358d27de613d82985d8f206e4345" translate="yes" xml:space="preserve">
          <source>NodeFilter</source>
          <target state="translated">NodeFilter</target>
        </trans-unit>
        <trans-unit id="749f705e68c34826a7cc3dffa5cbbe3e73f820de" translate="yes" xml:space="preserve">
          <source>NodeIterator</source>
          <target state="translated">NodeIterator</target>
        </trans-unit>
        <trans-unit id="05a2a8746fe10231011b4d6850be527a41c1c732" translate="yes" xml:space="preserve">
          <source>NodeList</source>
          <target state="translated">NodeList</target>
        </trans-unit>
        <trans-unit id="683af661ab161f85e9822c648db026a9cf30dda6" translate="yes" xml:space="preserve">
          <source>Non-constant vararg annotation parameters</source>
          <target state="translated">Непостоянные параметры аннотации варангов</target>
        </trans-unit>
        <trans-unit id="dc9767217a1c7b0bf421fbdc439c549407505217" translate="yes" xml:space="preserve">
          <source>Non-existent type correction</source>
          <target state="translated">Коррекция несуществующего типа</target>
        </trans-unit>
        <trans-unit id="fe155a80a88ca53a5855fdd7ccb55154dece22f7" translate="yes" xml:space="preserve">
          <source>Non-external classes can't be extended by external classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faaccd91d30b37f731dad2f02cd8a91e9099b87" translate="yes" xml:space="preserve">
          <source>Non-local returns</source>
          <target state="translated">Нелокальная доходность</target>
        </trans-unit>
        <trans-unit id="92dc2c3bbe1e4d97caf60f89e03fd837acb72669" translate="yes" xml:space="preserve">
          <source>Non-private fields</source>
          <target state="translated">Нечастные поля</target>
        </trans-unit>
        <trans-unit id="f8f526d37ae54edc0292fa3b9fb52e0ef28cf4f3" translate="yes" xml:space="preserve">
          <source>Non-propagating use</source>
          <target state="translated">Неразмножающееся использование</target>
        </trans-unit>
        <trans-unit id="806c74a6dd444e7b581fe8d0651c3b583f7e4a35" translate="yes" xml:space="preserve">
          <source>NonDocumentTypeChildNode</source>
          <target state="translated">NonDocumentTypeChildNode</target>
        </trans-unit>
        <trans-unit id="928c9a9956e3637b60b5e9617db297b95e7290fd" translate="yes" xml:space="preserve">
          <source>NonElementParentNode</source>
          <target state="translated">NonElementParentNode</target>
        </trans-unit>
        <trans-unit id="d75dfc52cb45227dc75a26a76fe24ef6aeb82f70" translate="yes" xml:space="preserve">
          <source>Normal functions (not marked as inline) cannot have reified parameters. A type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like &lt;code&gt;Nothing&lt;/code&gt;) cannot be used as an argument for a reified type parameter.</source>
          <target state="translated">Нормальные функции (не помеченные как встроенные) не могут иметь уточненных параметров. Тип, не имеющий представления времени выполнения (например, параметр нереалифицированного типа или фиктивный тип, такой как &lt;code&gt;Nothing&lt;/code&gt; ), не может использоваться в качестве аргумента для параметра реифицируемого типа.</target>
        </trans-unit>
        <trans-unit id="49a45a50e6244c47619f28727155a0cbe41bd131" translate="yes" xml:space="preserve">
          <source>Normal methods can be overridden using the &lt;code&gt;override&lt;/code&gt; Kotlin keyword. In this case the overriding method must have the same parameter names as the overridden one.</source>
          <target state="translated">Обычные методы можно переопределить с помощью ключевого слова &lt;code&gt;override&lt;/code&gt; Kotlin. В этом случае замещающий метод должен иметь те же имена параметров, что и замещаемый.</target>
        </trans-unit>
        <trans-unit id="a916e7bdcd294dc74af71b748cdce7d82df98e31" translate="yes" xml:space="preserve">
          <source>Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full signature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt;&lt;code&gt;@JvmOverloads&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">Обычно, если вы пишете функцию Kotlin со значениями параметров по умолчанию, она будет видна в Java только как полная подпись со всеми присутствующими параметрами. Если вы хотите предоставить вызывающим Java- &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt; &lt;code&gt;@JvmOverloads&lt;/code&gt; &lt;/a&gt; несколько перегрузок, вы можете использовать аннотацию @JvmOverloads .</target>
        </trans-unit>
        <trans-unit id="6a89db40e0b8cfbd047b44012190c470a3ee8af7" translate="yes" xml:space="preserve">
          <source>Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.</source>
          <target state="translated">Обычно,свойства,объявленные как имеющие ненулевой тип,должны быть инициализированы в конструкторе.Однако,довольно часто это не удобно.Например,свойства могут быть инициализированы с помощью инжекции зависимостей или в методе настройки модульного теста.В этом случае в конструкторе нельзя задать ненулевой инициализатор,но все же хочется избежать нулевой проверки при обращении к свойству внутри тела класса.</target>
        </trans-unit>
        <trans-unit id="a967d31a488ea79d5210d74fd176b0b854f6d231" translate="yes" xml:space="preserve">
          <source>Not only classes can have type parameters. Functions can, too. Type parameters are placed &lt;strong&gt;before&lt;/strong&gt; the name of the function:</source>
          <target state="translated">Не только классы могут иметь параметры типа. Функции тоже могут. Параметры типа помещаются &lt;strong&gt;перед&lt;/strong&gt; именем функции:</target>
        </trans-unit>
        <trans-unit id="2efce3f5aa2c271d194d1082031602e01c017249" translate="yes" xml:space="preserve">
          <source>Not use any members that take a star-projected type as a parameter</source>
          <target state="translated">Не использовать члены,которые принимают звездообразный тип в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="68b62df2b207d9543eb97cef507795cf7a5eb731" translate="yes" xml:space="preserve">
          <source>Not-null assertion operator</source>
          <target state="translated">Оператор не нулевого утверждения</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="0525b1fa9e28d14aa40cc8644228138fdab333ad" translate="yes" xml:space="preserve">
          <source>Notation for Platform Types</source>
          <target state="translated">Нотация для типов платформ</target>
        </trans-unit>
        <trans-unit id="346c210a245c6f4ac5e207e281e87f32eaf27522" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;the lateinit modifier&lt;/a&gt; allows to declare a non-null type initialized after the object is created (after the constructor call). Without &lt;code&gt;lateinit&lt;/code&gt; you'd have to declare a &lt;a href=&quot;../reference/null-safety&quot;&gt;nullable type&lt;/a&gt; and add additional nullability checks.</source>
          <target state="translated">Обратите внимание, как &lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;модификатор lateinit&lt;/a&gt; позволяет объявить ненулевой тип, инициализированный после создания объекта (после вызова конструктора). Без &lt;code&gt;lateinit&lt;/code&gt; вам пришлось бы объявить &lt;a href=&quot;../reference/null-safety&quot;&gt;тип, допускающий значение NULL,&lt;/a&gt; и добавить дополнительные проверки допустимости NULL.</target>
        </trans-unit>
        <trans-unit id="8d92da0b04ba642342db49ac8931c42f19e47f68" translate="yes" xml:space="preserve">
          <source>Note how both the first &lt;code&gt;async&lt;/code&gt; and the awaiting parent are cancelled on failure of one of the children (namely, &lt;code&gt;two&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece9aff9cfec4f422a4dd193e67bb220717aeb47" translate="yes" xml:space="preserve">
          <source>Note how easily one may forget the corresponding context element and then still safely access thread local. To avoid such situations, it is recommended to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">Обратите внимание, как легко можно забыть соответствующий элемент контекста и при этом безопасно получить доступ к локальному потоку. Чтобы избежать таких ситуаций, рекомендуется использовать метод &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;surePresent&lt;/a&gt; и выполнять отказоустойчивость при неправильном использовании.</target>
        </trans-unit>
        <trans-unit id="27e144234fbe29431367eab42a112f44ba9e6e90" translate="yes" xml:space="preserve">
          <source>Note on visibility</source>
          <target state="translated">Примечание по видимости</target>
        </trans-unit>
        <trans-unit id="f7e11b4556b13f0f82fdc5bafcd108c64e182fe4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin (automatically bundled into the Kotlin plugin in Android Studio) solves the same issue: replacing &lt;code&gt;findViewById&lt;/code&gt; with a concise and straightforward code. Consider using it unless you're already using ButterKnife and don't want to migrate.</source>
          <target state="translated">Обратите внимание, что плагин &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; (автоматически включаемый в плагин Kotlin в Android Studio) решает ту же проблему: заменяя &lt;code&gt;findViewById&lt;/code&gt; кратким и простым кодом. Рассмотрите возможность его использования, если вы уже не используете ButterKnife и не хотите мигрировать.</target>
        </trans-unit>
        <trans-unit id="b10bef8aca468769cab7ca0f31c1ca35bfeef062" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; is an extension function defined only for channels with non-nullable elements so that there is no accidental confusion between a closed channel and a null value.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; - это функция расширения, определенная только для каналов с элементами, не допускающими значения NULL, так что не возникает случайной путаницы между закрытым каналом и нулевым значением.</target>
        </trans-unit>
        <trans-unit id="23cd4a64981ce83f9769929d7af16453dd2385a0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt; is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a fixed rate of produced elements.</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;тикер&lt;/a&gt; знает о возможных паузах потребителя и, по умолчанию, регулирует задержку следующего создаваемого элемента, если возникает пауза, пытаясь поддерживать фиксированную частоту создаваемых элементов.</target>
        </trans-unit>
        <trans-unit id="e4f574aa6b81a2a53d14300616da27a08406bc5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;isActive&lt;/a&gt; in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is just a convenient shortcut for &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;IsActive&lt;/a&gt; в &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; это просто удобный ярлык для &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643f0957c5be70b41f4b5877b3662ee68c79f859" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-&lt;/code&gt; is an &lt;em&gt;invalid&lt;/em&gt; symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;-&lt;/code&gt; это &lt;em&gt;недопустимый&lt;/em&gt; символ в Java, а это означает , что невозможно назвать функции , которые принимают встроенные классы из Java.</target>
        </trans-unit>
        <trans-unit id="326418c4e5742c7d5633cf6eb21a36a9bd5007fa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;associate()&lt;/code&gt; produces short-living &lt;code&gt;Pair&lt;/code&gt; objects which may affect the performance. Thus, &lt;code&gt;associate()&lt;/code&gt; should be used when the performance isn't critical or it's more preferable than other options.</source>
          <target state="translated">Обратите внимание, что метод &lt;code&gt;associate()&lt;/code&gt; создает недолговечные объекты &lt;code&gt;Pair&lt;/code&gt; , которые могут повлиять на производительность. Таким образом, &lt;code&gt;associate()&lt;/code&gt; следует использовать, когда производительность не критична или предпочтительнее других вариантов.</target>
        </trans-unit>
        <trans-unit id="4712744d1c59fe11b666d701399f2acdde076310" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations, i.e. in &lt;code&gt;Node&lt;/code&gt; class we do not put &lt;code&gt;external&lt;/code&gt; before member functions and properties.</source>
          <target state="translated">Обратите внимание, что модификатор &lt;code&gt;external&lt;/code&gt; наследуется вложенными объявлениями, т.е. в классе &lt;code&gt;Node&lt;/code&gt; мы не помещаем &lt;code&gt;external&lt;/code&gt; перед функциями и свойствами-членами.</target>
        </trans-unit>
        <trans-unit id="7c2abf53e89201db42a6d7da34bd24e5d79ffb90" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;jQuery&lt;/code&gt; needs to be included in the corresponding HTML:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;jQuery&lt;/code&gt; необходимо включить в соответствующий HTML:</target>
        </trans-unit>
        <trans-unit id="a130b307700ca7edccdf73fda8c49be967259f51" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:</source>
          <target state="translated">Обратите внимание, что &lt;em&gt;null&lt;/em&gt; нельзя преобразовать в &lt;code&gt;String&lt;/code&gt; , поскольку этот тип не &lt;a href=&quot;null-safety&quot;&gt;допускает значения NULL&lt;/a&gt; , т.е. если &lt;code&gt;y&lt;/code&gt; имеет значение NULL, приведенный выше код вызывает исключение. Чтобы соответствовать семантике приведения Java, мы должны иметь тип, допускающий значение NULL, в правой части приведения, например:</target>
        </trans-unit>
        <trans-unit id="50af001ffdcccd71b90632cabd329ef39ee390e5" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. To make such code correct for null values, use the nullable type on the right hand side of the cast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b25bca041a3db971a025c2e5df5df075febfd74" translate="yes" xml:space="preserve">
          <source>Note that KDoc does not have any syntax for resolving overloaded members in links. Since the Kotlin documentation generation tool puts the documentation for all overloads of a function on the same page, identifying a specific overloaded function is not required for the link to work.</source>
          <target state="translated">Обратите внимание,что KDoc не имеет никакого синтаксиса для разрешения перегруженных членов в ссылках.Так как инструмент генерации документации Kotlin помещает документацию по всем перегрузкам функции на одной и той же странице,идентификация конкретной перегруженной функции не требуется для работы ссылки.</target>
        </trans-unit>
        <trans-unit id="378fb47127c89ebfae61cf028d6a1d9ec0aaa851" translate="yes" xml:space="preserve">
          <source>Note that Kapt does not support multiple rounds for the generated Kotlin files.</source>
          <target state="translated">Обратите внимание,что Kapt не поддерживает несколько раундов для сгенерированных файлов Kotlin.</target>
        </trans-unit>
        <trans-unit id="f3383898decca7a9f7b6deb5d495a2e5e68df372" translate="yes" xml:space="preserve">
          <source>Note that Kotlin compiler does not apply such mangling to &lt;code&gt;external&lt;/code&gt; declarations, so you don't have to use &lt;code&gt;@JsName&lt;/code&gt; on them. Another case worth noticing is inheriting non-external classes from external classes. In this case any overridden functions won't be mangled as well.</source>
          <target state="translated">Обратите внимание, что компилятор Kotlin не применяет такое искажение к &lt;code&gt;external&lt;/code&gt; объявлениям, поэтому вам не нужно использовать &lt;code&gt;@JsName&lt;/code&gt; них @JsName . Еще один заслуживающий внимания случай - наследование невнешних классов от внешних классов. В этом случае любые переопределенные функции также не будут искажены.</target>
        </trans-unit>
        <trans-unit id="123a11d8fa5ed53f8ac07b91892dff993cf556e9" translate="yes" xml:space="preserve">
          <source>Note that Kotlin does not have a &lt;em&gt;new&lt;/em&gt; keyword.</source>
          <target state="translated">Обратите внимание, что в Kotlin нет &lt;em&gt;нового&lt;/em&gt; ключевого слова.</target>
        </trans-unit>
        <trans-unit id="24cefba751ca3442834b1d28297766c4dedb14f5" translate="yes" xml:space="preserve">
          <source>Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</source>
          <target state="translated">Обратите внимание,что SAM-преобразования работают только для интерфейсов,а не для абстрактных классов,даже если они также имеют только один абстрактный метод.</target>
        </trans-unit>
        <trans-unit id="50497e29cee31d617bb240dff5362b9731a558da" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop always implicitly declares a new read-only variable (in this example, &lt;code&gt;name&lt;/code&gt;) - if the outer scope already contains a variable with the same name, it will be shadowed by the unrelated loop variable. For the same reason, the final value of the loop variable is not accessible after the loop.</source>
          <target state="translated">Обратите внимание, что цикл &lt;code&gt;for&lt;/code&gt; всегда неявно объявляет новую переменную только для чтения (в этом примере &lt;code&gt;name&lt;/code&gt; ) - если внешняя область уже содержит переменную с тем же именем, она будет затенена несвязанной переменной цикла. По той же причине окончательное значение переменной цикла недоступно после цикла.</target>
        </trans-unit>
        <trans-unit id="f345c0305c039a5c5d92b2679df3ab69307a3616" translate="yes" xml:space="preserve">
          <source>Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the &lt;code&gt;.java&lt;/code&gt; property on a &lt;code&gt;KClass&lt;/code&gt; instance.</source>
          <target state="translated">Обратите внимание, что ссылка на класс Kotlin - это не то же самое, что ссылка на класс Java. Чтобы получить ссылку на класс Java, используйте свойство &lt;code&gt;.java&lt;/code&gt; в экземпляре &lt;code&gt;KClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0206a8d998dc749c92f53c56e6d927b2e3bb8c96" translate="yes" xml:space="preserve">
          <source>Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; becomes a &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; in Kotlin.</source>
          <target state="translated">Обратите внимание, что упакованный примитивный тип, используемый в качестве параметра типа, сопоставляется с типом платформы: например, &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; становится &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; В Kotlin.</target>
        </trans-unit>
        <trans-unit id="cda0f8a2d7cf131c070c968ead3e02616cc75710" translate="yes" xml:space="preserve">
          <source>Note that a file marked with the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation can't contain non-&lt;code&gt;external&lt;/code&gt; declarations.</source>
          <target state="translated">Обратите внимание, что файл, помеченный аннотацией &lt;code&gt;@JsQualifier(...)&lt;/code&gt; не может содержать не &lt;code&gt;external&lt;/code&gt; объявлений.</target>
        </trans-unit>
        <trans-unit id="406525d21e4a3c81c722c7741ff866f95a0130cf" translate="yes" xml:space="preserve">
          <source>Note that a function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly.</source>
          <target state="translated">Обратите внимание,что тип функции без приемника выводится по умолчанию,даже если переменная инициализируется со ссылкой на функцию расширения.Чтобы изменить это,явно укажите тип переменной.</target>
        </trans-unit>
        <trans-unit id="b53df8b9afb9e806e949a0d6af036fa85a8a9db9" translate="yes" xml:space="preserve">
          <source>Note that a module referenced by a dependency declared for &lt;code&gt;commonMain&lt;/code&gt; or &lt;code&gt;commonTest&lt;/code&gt; source set must be published using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. If you want to use libraries published by the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin, you need to declare a separate source set for common native sources.</source>
          <target state="translated">Обратите внимание, что модуль, на который ссылается зависимость, объявленная для исходного набора &lt;code&gt;commonMain&lt;/code&gt; или &lt;code&gt;commonTest&lt;/code&gt; , должен быть опубликован с использованием &lt;code&gt;kotlin-multiplatform&lt;/code&gt; . Если вы хотите использовать библиотеки, опубликованные &lt;code&gt;kotlin-platform-native&lt;/code&gt; , вам необходимо объявить отдельный исходный набор для общих исходных кодов.</target>
        </trans-unit>
        <trans-unit id="07dbd163eca990505b14bc6390f514e8f9d894c6" translate="yes" xml:space="preserve">
          <source>Note that a read-only variable is not a constant per se: it can be initialized with the value of a variable (so its value doesn't need to be known at compile-time), and if it is declared inside a construct that is repeatedly invoked (such as a function or a loop), it can take on a different value on each invocation. Also, while the read-only variable may not be reassigned while it is in scope, it can still refer to an object which is in itself mutable (such as a list).</source>
          <target state="translated">Обратите внимание,что переменная,доступная только для чтения,не является константой как таковой:она может быть инициализирована значением переменной (поэтому ее значение не обязательно знать во время компиляции),и если она объявлена внутри многократно вызываемой конструкции (например,в функции или цикле),то при каждом вызове она может принимать разное значение.Кроме того,хотя переменная,доступная только для чтения,не может быть переназначена во время ее нахождения в диапазоне видимости,она все равно может ссылаться на объект,который сам по себе является мутируемым (например,список).</target>
        </trans-unit>
        <trans-unit id="89edad7d707ce970adc3246bd03659328accf5e4" translate="yes" xml:space="preserve">
          <source>Note that all classes in this tutorial are in the &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; package.</source>
          <target state="translated">Обратите внимание, что все классы в этом руководстве находятся в пакете &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e339722ad427ded0a06508490a0f24fc47b54f2b" translate="yes" xml:space="preserve">
          <source>Note that altering a mutable collection doesn't require it to be a &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;: write operations modify the same mutable collection object, so the reference doesn't change. Although, if you try to reassign a &lt;code&gt;val&lt;/code&gt; collection, you'll get a compilation error.</source>
          <target state="translated">Обратите внимание, что для изменения изменяемой коллекции не требуется, чтобы она была &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; : операции записи изменяют один и тот же изменяемый объект коллекции, поэтому ссылка не изменяется. Хотя, если вы попытаетесь переназначить коллекцию &lt;code&gt;val&lt;/code&gt; , вы получите ошибку компиляции.</target>
        </trans-unit>
        <trans-unit id="402c9cc77c78831d6ef7a6f5b12edeefd76b9797" translate="yes" xml:space="preserve">
          <source>Note that an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder is a dual of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; coroutine builder. An actor is associated with the channel that it receives messages from, while a producer is associated with the channel that it sends elements to.</source>
          <target state="translated">Обратите внимание , что &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;актер&lt;/a&gt; сопрограммной строитель является двойственной &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;продукцией&lt;/a&gt; сопрограммного строителя. Актер связан с каналом, из которого он получает сообщения, а производитель связан с каналом, на который он отправляет элементы.</target>
        </trans-unit>
        <trans-unit id="3f7eda5be515629fb292c86295db20e329d1452f" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">Обратите внимание, что эта оболочка меняет порядок &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;компаратора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d17efed58ea9f37046b141c69cdea45b1227096" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending(kotlin.Comparator((kotlin.comparisons.compareByDescending.K)),%20kotlin.Function1((kotlin.comparisons.compareByDescending.T,%20kotlin.comparisons.compareByDescending.K)))/comparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cfcc2bcacb2464eb49e0f0ddd2d5c9c0f5de73" translate="yes" xml:space="preserve">
          <source>Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.</source>
          <target state="translated">Обратите внимание,что параметры анонимных функций всегда передаются внутри скобок.Синтаксис,позволяющий оставить функцию вне скобок,работает только для лямбда-выражений.</target>
        </trans-unit>
        <trans-unit id="9217d029286f8cd07e91756805e90b92b90c8d04" translate="yes" xml:space="preserve">
          <source>Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a return type of a public function or the type of a public property, the actual type of that function or property will be the declared supertype of the anonymous object, or &lt;code&gt;Any&lt;/code&gt; if you didn't declare any supertype. Members added in the anonymous object will not be accessible.</source>
          <target state="translated">Обратите внимание, что анонимные объекты могут использоваться как типы только в локальных и частных объявлениях. Если вы используете анонимный объект в качестве возвращаемого типа публичной функции или типа публичного свойства, фактическим типом этой функции или свойства будет объявленный супертип анонимного объекта или &lt;code&gt;Any&lt;/code&gt; если вы не объявили какой-либо супертип. , Члены, добавленные в анонимный объект, будут недоступны.</target>
        </trans-unit>
        <trans-unit id="58e17f85bfcb71bf347b7f266c8bad279b3e8c99" translate="yes" xml:space="preserve">
          <source>Note that another regular expression constructed from the same pattern string may have different &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;options&lt;/a&gt; and may match strings differently.</source>
          <target state="translated">Обратите внимание, что другое регулярное выражение, построенное на основе той же строки шаблона, может иметь другие &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;параметры&lt;/a&gt; и может по-разному соответствовать строкам.</target>
        </trans-unit>
        <trans-unit id="0e1195c36b54acff13f3bf0d0c44bfdb9ba62965" translate="yes" xml:space="preserve">
          <source>Note that blank lines do not affect the detected indent level.</source>
          <target state="translated">Обратите внимание,что пустые строки не влияют на уровень обнаруженных отступов.</target>
        </trans-unit>
        <trans-unit id="901eb90b706fa87b74726ae4ca585fc8ee1df3bd" translate="yes" xml:space="preserve">
          <source>Note that both the target platform and the name matter: if a target was created as &lt;code&gt;jvm('jvm6')&lt;/code&gt;, using &lt;code&gt;jvm()&lt;/code&gt; will create a separate target (with the default name &lt;code&gt;jvm&lt;/code&gt;). If the preset function used to create the target under that name was different, an error is reported.</source>
          <target state="translated">Обратите внимание, что и целевая платформа, и имя имеют значение: если цель была создана как &lt;code&gt;jvm('jvm6')&lt;/code&gt; , использование &lt;code&gt;jvm()&lt;/code&gt; создаст отдельную цель (с именем по умолчанию &lt;code&gt;jvm&lt;/code&gt; ). Если предустановленная функция, использованная для создания цели под этим именем, была другой, выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="20a8a158a1c056ad5cea3eaeda038189df025fb8" translate="yes" xml:space="preserve">
          <source>Note that boxing of numbers does not necessarily preserve identity:</source>
          <target state="translated">Обратите внимание,что бокс с номерами не обязательно сохраняет идентичность:</target>
        </trans-unit>
        <trans-unit id="18f0c3bd108e4fca3d9b4ad0c92853cb37af67e8" translate="yes" xml:space="preserve">
          <source>Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration over the channel that processor coroutines are doing.</source>
          <target state="translated">Обратите внимание,что отмена корутины производителя закрывает ее канал,тем самым,в конечном счете,прекращая итерацию по каналу,которую делают корутины процессора.</target>
        </trans-unit>
        <trans-unit id="a4257481b27fd911ec2dc62a1694406a02635294" translate="yes" xml:space="preserve">
          <source>Note that changing type from unsigned type to signed counterpart (and vice versa) is a &lt;em&gt;binary incompatible&lt;/em&gt; change</source>
          <target state="translated">Обратите внимание, что изменение типа с беззнакового типа на подписанный аналог (и наоборот) является &lt;em&gt;двоичным несовместимым&lt;/em&gt; изменением.</target>
        </trans-unit>
        <trans-unit id="fb531691886575d5d0b4f4f27624c19223bae127" translate="yes" xml:space="preserve">
          <source>Note that characters are not numbers in Kotlin.</source>
          <target state="translated">Обратите внимание,что в Котлине символы не являются цифрами.</target>
        </trans-unit>
        <trans-unit id="224781b538ad44d496b4eb9848adbb611bc7607f" translate="yes" xml:space="preserve">
          <source>Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in the same file.</source>
          <target state="translated">Обратите внимание,что классы,расширяющие подклассы герметичного класса (непрямые наследники),могут быть размещены где угодно,не обязательно в одном и том же файле.</target>
        </trans-unit>
        <trans-unit id="4b347074d3d760a0df60b87ff4401c3b2a375933" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01c476864e020a6b3bdf6a577c404757a04f763" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">Обратите внимание,что код в блоках инициализатора фактически становится частью первичного конструктора.Делегирование первичному конструктору происходит как первое утверждение вторичного конструктора,поэтому код во всех блоках инициализатора выполняется перед телом вторичного конструктора.Даже если класс не имеет первичного конструктора,делегирование все равно происходит неявно,а блоки инициализатора все равно выполняются:</target>
        </trans-unit>
        <trans-unit id="40662d03b687698fb7e2efe397dfb49179bd8a28" translate="yes" xml:space="preserve">
          <source>Note that coroutines are currently considered an &lt;strong&gt;experimental feature&lt;/strong&gt;, meaning that the Kotlin team is not committing to supporting the backwards compatibility of this feature after the final 1.1 release.</source>
          <target state="translated">Обратите внимание, что сопрограммы в настоящее время считаются &lt;strong&gt;экспериментальной функцией&lt;/strong&gt; , а это означает, что команда Kotlin не обязуется поддерживать обратную совместимость этой функции после окончательной версии 1.1.</target>
        </trans-unit>
        <trans-unit id="abdd0e9fc4f6072582fff7f11143b17405eee64f" translate="yes" xml:space="preserve">
          <source>Note that despite the fact that the right-hand side of &lt;em&gt;as?&lt;/em&gt; is a non-null type &lt;code&gt;String&lt;/code&gt; the result of the cast is nullable.</source>
          <target state="translated">Обратите внимание, что несмотря на то, что правая часть &lt;em&gt;as? &lt;/em&gt;является ненулевым типом &lt;code&gt;String&lt;/code&gt; , результат приведения допускает значение NULL.</target>
        </trans-unit>
        <trans-unit id="d2338fe045f1f2d5efa433b2cf56bf15940234fd" translate="yes" xml:space="preserve">
          <source>Note that division between integers always returns an integer. Any fractional part is discarded. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984acf59abb99e6edf5501246d83e1bc7951b21e" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; is false, values of the type can still be &lt;code&gt;null&lt;/code&gt;. This may happen if it is a type of the type parameter with a nullable upper bound:</source>
          <target state="translated">Обратите внимание, что даже если &lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; имеет значение false, значения типа все равно могут быть &lt;code&gt;null&lt;/code&gt; . Это может произойти, если это тип параметра типа с верхней границей, допускающей значение NULL:</target>
        </trans-unit>
        <trans-unit id="f9717ca7605239239d9b446b8d8baf568533a62a" translate="yes" xml:space="preserve">
          <source>Note that even if you initialize a variable with a reference to an extension function, the inferred function type will have no receiver (it will have an additional parameter accepting a receiver object). To have a function type with receiver instead, specify the type explicitly:</source>
          <target state="translated">Обратите внимание,что даже если вы инициализируете переменную со ссылкой на функцию расширения,выведенный тип функции не будет иметь приемника (у нее будет дополнительный параметр,принимающий объект-приемник).Чтобы иметь тип функции со ссылкой на приемник,укажите этот тип явно:</target>
        </trans-unit>
        <trans-unit id="e1859932d9a0b691a9fc9411f62e5506be7f8a66" translate="yes" xml:space="preserve">
          <source>Note that even though this is a read-only property due to declaring it with &lt;code&gt;val&lt;/code&gt; (in which case you may not provide a setter), its value can still change since it reads from a mutable property - you just can't assign to the property. Also, note that the property type is inferred from the return value of the getter.</source>
          <target state="translated">Обратите внимание: несмотря на то, что это свойство доступно только для чтения из-за объявления его с помощью &lt;code&gt;val&lt;/code&gt; (в этом случае вы не можете предоставить сеттер), его значение все равно может измениться, поскольку оно считывается из изменяемого свойства - вы просто не можете назначить его свойство. Также обратите внимание, что тип свойства выводится из возвращаемого значения получателя.</target>
        </trans-unit>
        <trans-unit id="fd6bde9af50a41c1d5f97ea7b48311cc0527806c" translate="yes" xml:space="preserve">
          <source>Note that exceptions are somewhat discouraged in Kotlin except when interacting with Java code. Instead of throwing exceptions in your own code, consider using special return types like &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; or &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; from the &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow library&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что исключения в Kotlin несколько не приветствуются, кроме случаев взаимодействия с кодом Java. Вместо того, чтобы создавать исключения в собственном коде, рассмотрите возможность использования специальных возвращаемых типов, таких как &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; или &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either,&lt;/a&gt; из &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;библиотеки Arrow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33e073ab069310793fb905b91ca3476dc4caf23c" translate="yes" xml:space="preserve">
          <source>Note that expected declarations are not restricted to interfaces and interface members. In this example, the expected class has a constructor and can be created directly from common code. You can apply the &lt;code&gt;expect&lt;/code&gt; modifier to other declarations as well, including top-level declarations and annotations:</source>
          <target state="translated">Обратите внимание, что ожидаемые объявления не ограничиваются интерфейсами и членами интерфейса. В этом примере ожидаемый класс имеет конструктор и может быть создан непосредственно из общего кода. Вы также можете применить модификатор &lt;code&gt;expect&lt;/code&gt; к другим объявлениям, включая объявления и аннотации верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="45215a2c612cfc18ca0212e4816f62d8f14fe5b3" translate="yes" xml:space="preserve">
          <source>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even if its value is null, and can check for &lt;code&gt;this == null&lt;/code&gt; inside the body. This is what allows you to call toString() in Kotlin without checking for null: the check happens inside the extension function.</source>
          <target state="translated">Обратите внимание, что расширения могут быть определены с типом приемника, допускающим значение NULL. Такие расширения могут быть вызваны для объектной переменной, даже если ее значение равно null, и могут проверять &lt;code&gt;this == null&lt;/code&gt; внутри тела. Это то, что позволяет вам вызывать toString () в Kotlin без проверки на null: проверка происходит внутри функции расширения.</target>
        </trans-unit>
        <trans-unit id="519b88833afa591c638bec3f6bbeb8adf1aa4ab7" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание , что для верхнего уровня &lt;strong&gt;расширения&lt;/strong&gt; собственности, делегат является одинаковым для всех приемников расширения, поэтому фактический &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;получатель&lt;/a&gt; экземпляр передается в не собирается делать какие - либо различия, оно должно быть только значение &lt;a href=&quot;index#T&quot;&gt;Т&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2defd349af6dc7f8207169257d4b38f3d3fe54d" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate(kotlin.reflect.KProperty1.T)/receiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ed19157d69e7092350d01754dff2c913099ef4" translate="yes" xml:space="preserve">
          <source>Note that for the IDE to correctly analyze the dependencies of the common sources, the common source sets need to have corresponding dependencies on the Kotlin metadata packages in addition to the platform-specific artifact dependencies of the platform-specific source sets. Usually, an artifact with a suffix &lt;code&gt;-common&lt;/code&gt; (as in &lt;code&gt;kotlin-stdlib-common&lt;/code&gt;) or &lt;code&gt;-metadata&lt;/code&gt; is required when using a published library (unless it is published with Gradle metadata, as described below).</source>
          <target state="translated">Обратите внимание, что для того, чтобы среда IDE могла правильно анализировать зависимости общих источников, общие наборы источников должны иметь соответствующие зависимости от пакетов метаданных Kotlin в дополнение к зависимостям артефактов, зависящих от платформы, для исходных наборов, зависящих от платформы. Обычно при использовании опубликованной библиотеки требуется артефакт с суффиксом &lt;code&gt;-common&lt;/code&gt; (как в &lt;code&gt;kotlin-stdlib-common&lt;/code&gt; ) или &lt;code&gt;-metadata&lt;/code&gt; (если только он не опубликован с метаданными Gradle, как описано ниже).</target>
        </trans-unit>
        <trans-unit id="ef903749bbe41c983b27f632974567077577929e" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of this tutorial, we've done a line by line literal translation. Obviously we could write this in a more Kotlin idiomatic way.</source>
          <target state="translated">Обратите внимание,что для целей данного учебника мы выполнили линейно-литературный перевод.Очевидно,что мы могли бы написать это более идиоматическим способом Котлина.</target>
        </trans-unit>
        <trans-unit id="2712e3816fc9fe0e5aede4e3fca67cc623f69a68" translate="yes" xml:space="preserve">
          <source>Note that if a class has got a primary constructor, it is no longer possible to create an instance of it without supplying any parameters (unless one of the secondary constructors is parameterless).</source>
          <target state="translated">Обратите внимание,что если класс имеет первичный конструктор,то больше невозможно создать экземпляр без поставки каких-либо параметров (если только один из вторичных конструкторов не является безпараметрическим).</target>
        </trans-unit>
        <trans-unit id="3b1296c9d04a31b1fde17dffa086ef1b8acdb6c3" translate="yes" xml:space="preserve">
          <source>Note that if a library consumer defines variants that are missing in the library, they need to provide &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;matching fallbacks&lt;/a&gt;. For example, if a library does not have or does not publish a &lt;code&gt;staging&lt;/code&gt; build type, it will be necessary to provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">Обратите внимание: если потребитель библиотеки определяет варианты, которые отсутствуют в библиотеке, ему необходимо предоставить &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;соответствующие резервные&lt;/a&gt; варианты . Например, если библиотека не имеет или не публикует &lt;code&gt;staging&lt;/code&gt; тип сборки, необходимо будет предоставить запасной вариант для потребителей, у которых есть такой тип сборки, указав хотя бы один из типов сборки, публикуемых библиотекой:</target>
        </trans-unit>
        <trans-unit id="6c82c92fd55806c5e9d8d4f7e9db855fd43d5a7a" translate="yes" xml:space="preserve">
          <source>Note that if an inline function has no inlinable function parameters and no &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt;, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что если встроенная функция не имеет параметров встроенной функции и параметров повторного &lt;a href=&quot;#reified-type-parameters&quot;&gt;типа&lt;/a&gt; , компилятор выдаст предупреждение, так как встраивание таких функций вряд ли будет полезным (вы можете подавить предупреждение, если уверены, что встраивание необходимо, используя аннотация &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac1401dfe931b50e5500ce4b2ebac5d2aaf6e00c" translate="yes" xml:space="preserve">
          <source>Note that if an interface with &lt;code&gt;@JvmDefault&lt;/code&gt; methods is used as a &lt;a href=&quot;delegation&quot;&gt;delegate&lt;/a&gt;, the default method implementations are called even if the actual delegate type provides its own implementations.</source>
          <target state="translated">Обратите внимание, что если интерфейс с методами &lt;code&gt;@JvmDefault&lt;/code&gt; используется в качестве &lt;a href=&quot;delegation&quot;&gt;делегата&lt;/a&gt; , вызываются реализации метода по умолчанию, даже если фактический тип делегата предоставляет свои собственные реализации.</target>
        </trans-unit>
        <trans-unit id="5c363669dd6ed31274f54972ddb75e1fa04284aa" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;comparator&lt;/code&gt; considers any two keys of this map equal, only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;comparator&lt;/code&gt; считает любые два ключа этой карты равными, только значение, связанное с последним из них, попадает в результирующую карту.</target>
        </trans-unit>
        <trans-unit id="169507f367051a5b585a09223134ff4c0faab6be" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">Обратите внимание , что если естественный порядок сортировки ключей рассматривает любые две клавиш этой карты равной (это может произойти , если равенство ключей в соответствии с &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; несовместимо с равенством по &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt; ), только значение , связанное с последним из них попадает в получившуюся карту.</target>
        </trans-unit>
        <trans-unit id="e0314127afde0714d8e6361a9b85bacb2fcd7ce9" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo(kotlin.Comparable.T)&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdeead972a4f0dc85a954b4ef35d091c4109a874" translate="yes" xml:space="preserve">
          <source>Note that if the type of the result is known from the context, the type argument can be omitted as usual due to the type inference.</source>
          <target state="translated">Обратите внимание,что если тип результата известен из контекста,то аргумент типа может быть опущен,как обычно,из-за вывода типа.</target>
        </trans-unit>
        <trans-unit id="3df7a58b11ae9c7f677f019b7e29ec36da986c3e" translate="yes" xml:space="preserve">
          <source>Note that if this function fails, then partial copying may have taken place.</source>
          <target state="translated">Обратите внимание,что в случае сбоя этой функции,возможно,имело место частичное копирование.</target>
        </trans-unit>
        <trans-unit id="e537ff121d99004384d6b13ae0784e74c296eabf" translate="yes" xml:space="preserve">
          <source>Note that if we have called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; and omitted &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, then we would have got the sequential behaviour as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for the execution to finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">Обратите внимание, что если бы мы вызвали &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; в &lt;code&gt;println&lt;/code&gt; и пропустили &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; для отдельных сопрограмм, тогда мы получили бы последовательное поведение, поскольку &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; запускает выполнение сопрограммы и ожидает завершения выполнения, что не является предполагаемым вариантом использования для лени. Вариант использования &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; является заменой стандартной &lt;code&gt;lazy&lt;/code&gt; функции в случаях, когда вычисление значения включает приостановку функций.</target>
        </trans-unit>
        <trans-unit id="ca8da6b3b0810e7069d1865b81c075dccb66b2c6" translate="yes" xml:space="preserve">
          <source>Note that if we just call &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; without first calling &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, this will lead to sequential behavior, since &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for its finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e82a73f61c52b17d7e3c65e8e99e11241b677f8" translate="yes" xml:space="preserve">
          <source>Note that if you are using multi-project build, you should apply plugin to the main project that is an entry point to your application.</source>
          <target state="translated">Обратите внимание,что если вы используете многопроектную сборку,то вы должны применить плагин к основному проекту,который является точкой входа в вашу заявку.</target>
        </trans-unit>
        <trans-unit id="e39d91f028c6c4bc3b768c071107ff617a7a7685" translate="yes" xml:space="preserve">
          <source>Note that if you use the project template generated by the &lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; service, the &lt;code&gt;kotlin-spring&lt;/code&gt; plugin will be enabled by default.</source>
          <target state="translated">Обратите внимание, что если вы используете шаблон проекта, созданный службой &lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; , плагин &lt;code&gt;kotlin-spring&lt;/code&gt; будет включен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="261071b80b92f5599125de0c5212f010938aeec4" translate="yes" xml:space="preserve">
          <source>Note that if your function has parameters, its name will be mangled, so the mangled name should be used in the keep directive.</source>
          <target state="translated">Обратите внимание,что если у вашей функции есть параметры,то ее имя будет искажено,поэтому искаженное имя должно быть использовано в директиве keep.</target>
        </trans-unit>
        <trans-unit id="6917f47d5bafd263295f3acf8a1ef7ab9d827116" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin, outer class does not see private members of its inner classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659e4fb54490f44ab2332ce79f12e2c6749032d5" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS &lt;a href=&quot;../set#kotlin.text%24set(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.Char)&quot;&gt;set&lt;/a&gt; operator function has non-constant execution time complexity. Therefore, increasing length of this string builder and then updating each character by index may slow down your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c99e0a3c39d8997895800da0e15222c8aa2ad3b" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS Float range is wider than &quot;single format&quot; bit layout can represent, so some Float values may overflow, underflow or loose their accuracy after conversion to bits and back.</source>
          <target state="translated">Обратите внимание,что в Kotlin/JS Float диапазон шире,чем может представлять &quot;одноформатная&quot; битовая компоновка,поэтому некоторые значения Float могут переполняться,переполняться или терять свою точность после преобразования в битах и обратно.</target>
        </trans-unit>
        <trans-unit id="88d47ad6334c013775aba391a38df6074a6dc3f4" translate="yes" xml:space="preserve">
          <source>Note that in competitive programming it is customary to give variables shorter names than it is typical in industrial programming practice, since the code is to be written just once and not supported thereafter. However, these names are usually still mnemonic &amp;mdash; &lt;code&gt;a&lt;/code&gt; for arrays, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, etc for indices, &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; for row and column numbers in tables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for coordinates, etc. It is easier to keep the same names for input data as it is given in the problem statement. However, more complex problems require more code which leads to using longer self-explanatory variable and function names.</source>
          <target state="translated">Обратите внимание, что в соревновательном программировании принято давать переменным более короткие имена, чем это принято в практике промышленного программирования, так как код должен быть написан только один раз и после этого не поддерживается. Однако эти имена обычно по-прежнему мнемонические - &lt;code&gt;a&lt;/code&gt; для массивов, &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; и т. Д. Для индексов, &lt;code&gt;r&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; для номеров строк и столбцов в таблицах, &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; для координат и т. Д. входные данные так, как они указаны в постановке задачи. Однако более сложные проблемы требуют большего количества кода, что приводит к использованию более длинных, не требующих пояснений имен переменных и функций.</target>
        </trans-unit>
        <trans-unit id="24fc67264648157b787a9e1d8a1aee247379a870" translate="yes" xml:space="preserve">
          <source>Note that in many cases there's no need to use custom interoperability library creation mechanisms described below, as for APIs available on the platform standardized bindings called &lt;a href=&quot;platform_libs&quot;&gt;platform libraries&lt;/a&gt; could be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks on macOS/iOS are available this way.</source>
          <target state="translated">Обратите внимание, что во многих случаях нет необходимости использовать механизмы создания настраиваемых библиотек взаимодействия, описанные ниже, поскольку для API-интерфейсов, доступных на платформе, могут использоваться стандартизованные привязки, называемые &lt;a href=&quot;platform_libs&quot;&gt;библиотеками платформы&lt;/a&gt; . Например, POSIX на платформах Linux / macOS, Win32 на платформе Windows или фреймворки Apple на macOS / iOS доступны таким образом.</target>
        </trans-unit>
        <trans-unit id="4c3031faf8b33ed043c9d69fe73ae60488938a50" translate="yes" xml:space="preserve">
          <source>Note that in most cases using &lt;a href=&quot;#string-templates&quot;&gt;string templates&lt;/a&gt; or raw strings is preferable to string concatenation.</source>
          <target state="translated">Обратите внимание, что в большинстве случаев использование &lt;a href=&quot;#string-templates&quot;&gt;строковых шаблонов&lt;/a&gt; или необработанных строк предпочтительнее конкатенации строк.</target>
        </trans-unit>
        <trans-unit id="8d1e2fa9797125ae266c1521c6c52af5e4d67c8b" translate="yes" xml:space="preserve">
          <source>Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6addd273834de7f83ab126536995cca9dd6643b2" translate="yes" xml:space="preserve">
          <source>Note that incremental annotation processing requires &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;incremental compilation&lt;/a&gt; to be enabled as well.</source>
          <target state="translated">Обратите внимание, что для инкрементальной обработки аннотаций также необходимо включить &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;инкрементную компиляцию&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7588c134bcd5e8f4a5da82d120b4047c151b76" translate="yes" xml:space="preserve">
          <source>Note that infix functions always require both the receiver and the parameter to be specified. When you're calling a method on the current receiver using the infix notation, you need to use &lt;code&gt;this&lt;/code&gt; explicitly; unlike regular method calls, it cannot be omitted. This is required to ensure unambiguous parsing.</source>
          <target state="translated">Обратите внимание, что инфиксные функции всегда требуют указания и получателя, и параметра. Когда вы вызываете метод текущего получателя, используя инфиксную нотацию, вам нужно использовать &lt;code&gt;this&lt;/code&gt; явно; в отличие от обычных вызовов методов, его нельзя пропустить. Это требуется для обеспечения однозначного анализа.</target>
        </trans-unit>
        <trans-unit id="ad1d05af6c1aa655f7d3f68b893652c8d8011b1f" translate="yes" xml:space="preserve">
          <source>Note that instead of declaring lambdas in xml like in the following example, you can can bind actions directly in the code:</source>
          <target state="translated">Обратите внимание,что вместо того,чтобы объявлять lambdas в xml,как в следующем примере,вы можете связывать действия непосредственно в коде:</target>
        </trans-unit>
        <trans-unit id="5d76391f0c3ceb2cfa6bd1897bb1920148848dd2" translate="yes" xml:space="preserve">
          <source>Note that invoking &lt;code&gt;js()&lt;/code&gt; returns a result of type &lt;a href=&quot;dynamic-type&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/a&gt;, which provides no type safety at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de64757cb014df0ce60c045d22eb608329bdbb9" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">Обратите внимание, что не рекомендуется вызывать функции &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; или &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; синхронно в том же стеке, где выполняется функция приостановки. Используйте &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; как более безопасный способ получить текущий экземпляр продолжения.</target>
        </trans-unit>
        <trans-unit id="9d6ffb0207257e6147b3a7dc3f05f4b2eb90ba26" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">Обратите внимание, что не рекомендуется вызывать функции &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; или &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; синхронно в том же стеке, где выполняется функция приостановки. Используйте &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; как более безопасный способ получить текущий экземпляр продолжения.</target>
        </trans-unit>
        <trans-unit id="ef6ff08c8afdc4c88bfce216a4201b44bef8d337" translate="yes" xml:space="preserve">
          <source>Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:</source>
          <target state="translated">Обратите внимание,что еще можно вызывать членов внешнего приемника,но для этого необходимо явно указать этот приемник:</target>
        </trans-unit>
        <trans-unit id="1a8a5665bc44d5cdbf2531c3d2423dcbe7d87681" translate="yes" xml:space="preserve">
          <source>Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:</source>
          <target state="translated">Обратите внимание,что параметры первичного конструктора могут быть использованы в блоках инициализатора.Они также могут быть использованы в инициализаторах свойств,объявленных в теле класса:</target>
        </trans-unit>
        <trans-unit id="88ac6b28b3a3b8435f7eba9f01321df2f731f34d" translate="yes" xml:space="preserve">
          <source>Note that right after the &quot;Task from coroutine scope&quot; message (while waiting for nested launch) &quot;Task from runBlocking&quot; is executed and printed &amp;mdash; even though the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is not completed yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c4053dbcf27c46808a2ab0e8b3303b9f7cbf9a" translate="yes" xml:space="preserve">
          <source>Note that set operations are supported by &lt;code&gt;List&lt;/code&gt; as well. However, the result of set operations on lists is still a &lt;code&gt;Set&lt;/code&gt;, so all the duplicate elements are removed.</source>
          <target state="translated">Обратите внимание, что операции с наборами также поддерживаются &lt;code&gt;List&lt;/code&gt; . Однако результатом операций над наборами списков по-прежнему остается &lt;code&gt;Set&lt;/code&gt; , поэтому все повторяющиеся элементы удаляются.</target>
        </trans-unit>
        <trans-unit id="205ca8f88f3bcbd4d7774a26be00ee48e66a2ebf" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties&quot;&gt;an example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecba1bd96686456eab8e7e25340f9f56c1cd293b" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;the example&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что, начиная с Kotlin 1.1, вы можете объявить делегированное свойство внутри функции или блока кода, оно не обязательно должно быть членом класса. Ниже вы можете найти &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;пример&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f27fe847dccbaf44c3e83c0485bdf6be308f0d6" translate="yes" xml:space="preserve">
          <source>Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:</source>
          <target state="translated">Обратите внимание,что смарт-касты не работают,когда компилятор не может гарантировать,что переменная не может измениться между проверкой и использованием.Точнее,смарт-касты применимы по следующим правилам:</target>
        </trans-unit>
        <trans-unit id="8d16f91fe350efdfdab6da644c90340156b7ba22" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c295c01c9e6a32796148120ae2cf2ae77c47235" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">Обратите внимание, что некоторые видимости Java, такие как package-private и protected (что также дает доступ к элементам из того же пакета), не могут быть представлены в Kotlin, поэтому им не &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;соответствует&lt;/a&gt; значение KVisibility .</target>
        </trans-unit>
        <trans-unit id="a13526efa441f113eff7267561f09b5212747a9d" translate="yes" xml:space="preserve">
          <source>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the &lt;code&gt;crossinline&lt;/code&gt; modifier:</source>
          <target state="translated">Обратите внимание, что некоторые встроенные функции могут вызывать лямбды, переданные им в качестве параметров не непосредственно из тела функции, а из другого контекста выполнения, такого как локальный объект или вложенная функция. В таких случаях нелокальный поток управления также не допускается в лямбдах. Чтобы указать это, параметр лямбда должен быть помечен модификатором &lt;code&gt;crossinline&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7e376b19704536e280b87471b9d2f1935ff22e7" translate="yes" xml:space="preserve">
          <source>Note that some of the Kotlin/Native targets require an &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;appropriate host machine&lt;/a&gt; to build on.</source>
          <target state="translated">Обратите внимание, что для некоторых целей Kotlin / Native требуется &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;соответствующий хост-компьютер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36013172d7bed76a773c2a3e7f523422dd3a224f" translate="yes" xml:space="preserve">
          <source>Note that sometimes channels may produce executions that look unfair due to the nature of the executor that is being used. See &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание, что иногда каналы могут производить казни, которые выглядят нечестными из-за характера используемого исполнителя. Подробнее см. В &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;этом выпуске&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c3b5c2f9f97ede3b692c00928df156ad477b585" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Обратите внимание, что реализация этого интерфейса &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; в Kotlin / JS имеет неопределенное поведение, если &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;индекс&lt;/a&gt; находится за его пределами.</target>
        </trans-unit>
        <trans-unit id="459ff0aa9d321691761e4a91e298d7fd73dfd1d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656f0ee95d7b273c3b267aed0322b60e181f19cb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Обратите внимание, что реализация этого интерфейса &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; в Kotlin / JS имеет неопределенное поведение, если &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;индекс&lt;/a&gt; находится за его пределами.</target>
        </trans-unit>
        <trans-unit id="86d97d17b217564ee55541f4e63de5ad16ee2c54" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;@DslMarker&lt;/code&gt; annotation is available only since Kotlin 1.1.</source>
          <target state="translated">Обратите внимание, что аннотация &lt;code&gt;@DslMarker&lt;/code&gt; доступна только с Kotlin 1.1.</target>
        </trans-unit>
        <trans-unit id="e7b3f809dbbb0b87e0e79d9712336f436e1ff493" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;componentN()&lt;/code&gt; functions need to be marked with the &lt;code&gt;operator&lt;/code&gt; keyword to allow using them in a destructuring declaration.</source>
          <target state="translated">Обратите внимание, что функции &lt;code&gt;componentN()&lt;/code&gt; должны быть помечены ключевым словом &lt;code&gt;operator&lt;/code&gt; , чтобы их можно было использовать в объявлении деструктуризации.</target>
        </trans-unit>
        <trans-unit id="4929a13b1b30f84a327018335edc5ac7a8c0ec7a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations. This is why in the example &lt;code&gt;Node&lt;/code&gt; class, we do not need to add the &lt;code&gt;external&lt;/code&gt; modifier before member functions and properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942ddfab9f982a7bff6988ad53e1b8f734657f3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;kotlin-multiplaform&lt;/code&gt; plugin doesn't create any production binaries by default. The only binary available by default is a debug executable allowing one to run tests from the &lt;code&gt;test&lt;/code&gt; compilation.</source>
          <target state="translated">Обратите внимание, что плагин &lt;code&gt;kotlin-multiplaform&lt;/code&gt; по умолчанию не создает никаких производственных двоичных файлов. Единственный доступный по умолчанию двоичный файл - это исполняемый файл отладки, позволяющий запускать тесты из &lt;code&gt;test&lt;/code&gt; компиляции.</target>
        </trans-unit>
        <trans-unit id="c656240136213ce9805ea2877dde6b34a8442c1b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;provideDelegate&lt;/code&gt; method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter.</source>
          <target state="translated">Обратите внимание, что метод &lt;code&gt;provideDelegate&lt;/code&gt; влияет только на создание вспомогательного свойства и не влияет на код, созданный для получателя или установщика.</target>
        </trans-unit>
        <trans-unit id="eaabc3c1b973d9e58d5da5690136b6ca64e5f983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;rem&lt;/code&gt; operator is supported since Kotlin 1.1. Kotlin 1.0 uses the &lt;code&gt;mod&lt;/code&gt; operator, which is deprecated in Kotlin 1.1.</source>
          <target state="translated">Обратите внимание, что оператор &lt;code&gt;rem&lt;/code&gt; поддерживается начиная с Kotlin 1.1. Kotlin 1.0 использует оператор &lt;code&gt;mod&lt;/code&gt; , который устарел в Kotlin 1.1.</target>
        </trans-unit>
        <trans-unit id="72e01dcbd71cc06e15070eae50092b4b7e9eed02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;to&lt;/code&gt; notation creates a short-living &lt;code&gt;Pair&lt;/code&gt; object, so it's recommended that you use it only if performance isn't critical. To avoid excessive memory usage, use alternative ways. For example, you can create a mutable map and populate it using the write operations. The &lt;a href=&quot;scope-functions#apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function can help to keep the initialization fluent here.</source>
          <target state="translated">Обратите внимание, что нотация &lt;code&gt;to&lt;/code&gt; создает недолговечный объект &lt;code&gt;Pair&lt;/code&gt; , поэтому рекомендуется использовать его только в том случае, если производительность не критична. Чтобы избежать чрезмерного использования памяти, используйте альтернативные способы. Например, вы можете создать изменяемую карту и заполнить ее с помощью операций записи. Функция &lt;a href=&quot;scope-functions#apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; может помочь сохранить плавную инициализацию здесь.</target>
        </trans-unit>
        <trans-unit id="14f09727b2d752324269a0d82ae94535e1c1e4e5" translate="yes" xml:space="preserve">
          <source>Note that the String implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0cdfd1c642695da1e12ec7f632f89942b6add0" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что последовательность символов, переданная в функцию &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечна и действительна только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Последняя последовательность символов может содержать меньше символов, чем заданный &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd01abddf25872ce916797664b86dae36d2cc1ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691b0c57806763a4b2bdecce9c41e605803c5ebe" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что последовательность символов, переданная в функцию &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечна и действительна только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Последняя последовательность символов может содержать меньше символов, чем заданный &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66c2ad296d8e177430bc0fa68ba7b9eb97117778" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1754418c79853b8c6ec574fcc023dbf40a7d737e" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что последовательность символов, переданная в функцию &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечна и действительна только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Несколько последних последовательностей символов могут содержать меньше символов, чем заданный &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3008d758022d0b209de4899387968b8ac78ed4" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266d21f640d721c4dd41a4ded8abb4f2b56ec11c" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что последовательность символов, переданная в функцию &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечна и действительна только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Несколько последних последовательностей символов могут содержать меньше символов, чем заданный &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e51326b0cfaf636fb6a7d19970d3f5dc2bf4c4ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeca19ffbd81bf7218d5ce25611e87d001f58db2" translate="yes" xml:space="preserve">
          <source>Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:</source>
          <target state="translated">Обратите внимание,что компилятор использует для автоматически генерируемых функций только свойства,определенные внутри первичного конструктора.Чтобы исключить свойство из генерируемых реализаций,объявите его внутри тела класса:</target>
        </trans-unit>
        <trans-unit id="29a5989520a2bf8fd601f2d782fa7b5f4d18221d" translate="yes" xml:space="preserve">
          <source>Note that the content of &lt;code&gt;platform.posix&lt;/code&gt; is NOT identical on different platforms, in the same way as different &lt;code&gt;POSIX&lt;/code&gt; implementations are a little different.</source>
          <target state="translated">Обратите внимание, что содержимое &lt;code&gt;platform.posix&lt;/code&gt; НЕ идентично на разных платформах, точно так же, как разные реализации &lt;code&gt;POSIX&lt;/code&gt; немного отличаются.</target>
        </trans-unit>
        <trans-unit id="6e0ba2d2cb4d8f4a9dbc1b85a017969941095acd" translate="yes" xml:space="preserve">
          <source>Note that the databinding expression language uses the same syntax for referring to properties as Kotlin: &lt;code&gt;data.imageUrl&lt;/code&gt;. In Kotlin you can write &lt;code&gt;v.prop&lt;/code&gt; instead of &lt;code&gt;v.getProp()&lt;/code&gt; even if &lt;code&gt;getProp()&lt;/code&gt; is a Java method. Similarly, instead of calling a setter directly, you may use an assignment:</source>
          <target state="translated">Обратите внимание, что язык выражений привязки данных использует тот же синтаксис для ссылки на свойства, что и Kotlin: &lt;code&gt;data.imageUrl&lt;/code&gt; . В Kotlin вы можете написать &lt;code&gt;v.prop&lt;/code&gt; вместо &lt;code&gt;v.getProp()&lt;/code&gt; даже если &lt;code&gt;getProp()&lt;/code&gt; является методом Java. Точно так же вместо прямого вызова сеттера вы можете использовать присваивание:</target>
        </trans-unit>
        <trans-unit id="e38cb3723f44256fc4af27d394f0da73badd7310" translate="yes" xml:space="preserve">
          <source>Note that the first build isn't incremental in any case.</source>
          <target state="translated">Обратите внимание,что первая сборка в любом случае не инкрементальна.</target>
        </trans-unit>
        <trans-unit id="3539b1a59eaf5408904eb51b677999543b8a5f8e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что список, переданный функции &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечен и действителен только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. В последнем списке может быть меньше элементов, чем заданный &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36bd5508df864c7458e1fccd9c81158cc477d507" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6ec3f60ea3d3f0e1450f4fd127d92b3dabc464" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что список, переданный функции &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечен и действителен только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. В последнем списке может быть меньше элементов, чем заданный &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4dd0c4a7944c546ed18e9237812f399b9a75bb2" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c9e1743347f1aa8d11316573c39fab1f4d2b86" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что список, переданный функции &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечен и действителен только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Несколько последних списков могут содержать меньше элементов, чем заданный &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fccc14666a62fb388999ea11066179edff1c4d5e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a01e230c14a996ac73932af98798f763d520bb" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что список, переданный функции &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; недолговечен и действителен только внутри этой функции. Вы не должны хранить его или позволять ему каким-либо образом ускользать, если вы не сделали его снимок. Несколько последних списков могут содержать меньше элементов, чем заданный &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;размер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01be197fd2cc3bdf986de65122c65771b937478d" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6259e89a9a4c0b547dbd66ff1bea24b671ef991" translate="yes" xml:space="preserve">
          <source>Note that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older than 5.3.</source>
          <target state="translated">Обратите внимание,что метаданные модуля,опубликованные в Gradle 5.3 и выше,не могут быть прочитаны версиями Gradle старше 5.3.</target>
        </trans-unit>
        <trans-unit id="289248f23bcb06f8e447242c0fc575e0c1a20430" translate="yes" xml:space="preserve">
          <source>Note that the named argument syntax cannot be used when calling Java functions, because Java bytecode does not always preserve names of function parameters.</source>
          <target state="translated">Обратите внимание,что синтаксис именованных аргументов не может быть использован при вызове Java-функций,так как Java-байткод не всегда сохраняет имена параметров функции.</target>
        </trans-unit>
        <trans-unit id="7b39b5b0c66187e76139e4031731bcf6a323f589" translate="yes" xml:space="preserve">
          <source>Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.</source>
          <target state="translated">Обратите внимание,что операция не гарантированно будет атомарной,если карта изменяется одновременно.</target>
        </trans-unit>
        <trans-unit id="f1adf6c7e534562475c3f5e5643436265ce9a453" translate="yes" xml:space="preserve">
          <source>Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</source>
          <target state="translated">Обратите внимание,что обратный обратный перевод еще не реализован:Методы перебрасывания ошибок Swift/Objective-C не импортируются в Kotlin как метод перебрасывания исключений.</target>
        </trans-unit>
        <trans-unit id="13e4f5805154eec53798d94ef883500f35ad56a4" translate="yes" xml:space="preserve">
          <source>Note that the other uses of curly braces in Kotlin, such as in function and class definitions and after &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; statements, are not lambda expressions (so it is &lt;em&gt;not&lt;/em&gt; the case that &lt;code&gt;if&lt;/code&gt; is a function that conditionally executes a lambda function).</source>
          <target state="translated">Обратите внимание, что другие варианты использования фигурных скобок в Kotlin, например, в определениях функций и классов и после операторов &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; , не являются лямбда-выражениями (так что это &lt;em&gt;не&lt;/em&gt; тот случай, &lt;code&gt;if&lt;/code&gt; - это функция, которая условно выполняет лямбда-выражение. функция).</target>
        </trans-unit>
        <trans-unit id="29cdb0fff079bd2313b913b84a243b2ced642967" translate="yes" xml:space="preserve">
          <source>Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">Обратите внимание,что возвращаемый экземпляр использует себя для синхронизации.Не синхронизируйтесь с внешним кодом на возвращаемом экземпляре,так как это может привести к случайному блокировке.Также такое поведение может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="ab68d93b5c9158ca99b7d3217cfebeb0bc1dbe0f" translate="yes" xml:space="preserve">
          <source>Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing &lt;code&gt;&quot;\uDC00\uD800&quot;&lt;/code&gt; produces &lt;code&gt;&quot;\uD800\uDC00&quot;&lt;/code&gt; which is a valid surrogate pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bb4d1e09ed7e1f3f7c48bd69bd7281f7032077" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и добавляемый массив повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="4bc2850950af5238d132e57cd0616b073acff952" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и вычитаемый массив повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="8cd8b63a074395eb7bac096117fd2d1a65ca128f" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и добавляемая коллекция повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="230e838a21a0d86d33ae636264aea12d232d60bc" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и вычитаемая коллекция повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="1d7a2c8875e7a4328f4bc1cb1a337451636c5765" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и добавляемая последовательность повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="9b6c8e7b439f69f32239265aaaa738e3fcea0362" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">Обратите внимание, что исходная последовательность и вычитаемая последовательность повторяются только тогда, когда &lt;code&gt;iterator&lt;/code&gt; запрашивается из результирующей последовательности. Изменение любого из них между последовательными вызовами &lt;code&gt;iterator&lt;/code&gt; может повлиять на результат.</target>
        </trans-unit>
        <trans-unit id="0f3815a86501d3751673db13b1bc40b17a55063d" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly has only been available since Kotlin 1.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4783ce40fed5c138c67544445542f050cb0f80" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly is available only since Kotlin 1.1.</source>
          <target state="translated">Обратите внимание, что синтаксис &lt;code&gt;this::prop&lt;/code&gt; для прямой ссылки на &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;связанную вызываемую ссылку&lt;/a&gt; в коде доступен только начиная с Kotlin 1.1.</target>
        </trans-unit>
        <trans-unit id="2949a431bbdf8be1e322b0911e16815ddc68d4b3" translate="yes" xml:space="preserve">
          <source>Note that the terms &quot;subclass&quot; and &quot;superclass&quot; can span multiple levels of inheritance - &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;Any&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt; is the superclass of everything. If we want to restrict ourselves to one level of inheritance, we will say &quot;direct subclass&quot; or &quot;direct superclass&quot;.</source>
          <target state="translated">Обратите внимание, что термины &amp;laquo;подкласс&amp;raquo; и &amp;laquo;суперкласс&amp;raquo; могут охватывать несколько уровней наследования: &lt;code&gt;Car&lt;/code&gt; является подклассом &lt;code&gt;Any&lt;/code&gt; , а &lt;code&gt;Any&lt;/code&gt; - суперклассом всего. Если мы хотим ограничиться одним уровнем наследования, мы скажем &amp;laquo;прямой подкласс&amp;raquo; или &amp;laquo;прямой суперкласс&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6f04df739b130f057070e51840257477306e9abb" translate="yes" xml:space="preserve">
          <source>Note that the trailing newline of each line is stripped. You can also call &lt;code&gt;readLines()&lt;/code&gt; on a file object to get a list of all the lines, or &lt;code&gt;useLines()&lt;/code&gt; to supply a function that will be called on every line. If you simply want the entire file contents as one string or byte array, call &lt;code&gt;readText()&lt;/code&gt; or &lt;code&gt;readBytes()&lt;/code&gt;, respectively.</source>
          <target state="translated">Обратите внимание, что завершающая новая строка каждой строки удаляется. Вы также можете вызвать &lt;code&gt;readLines()&lt;/code&gt; для файлового объекта, чтобы получить список всех строк, или &lt;code&gt;useLines()&lt;/code&gt; чтобы предоставить функцию, которая будет вызываться для каждой строки. Если вы просто хотите, чтобы все содержимое файла представляло собой одну строку или массив байтов, вызовите &lt;code&gt;readText()&lt;/code&gt; или &lt;code&gt;readBytes()&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="3233b123410bb0637d15ef36074b9c50ad6be8ca" translate="yes" xml:space="preserve">
          <source>Note that the type of a property must be explicitly specified. As opposed to Python, declaring a property directly inside the class does not create a class-level property, but an instance-level one: every instance of &lt;code&gt;Person&lt;/code&gt; will have &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;. Their values will start out in every instance as &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;, respectively, but the value in each instance can be modified independently of the others:</source>
          <target state="translated">Обратите внимание, что тип свойства должен быть указан явно. В отличие от Python, объявление свойства непосредственно внутри класса создает не свойство уровня класса, а свойство уровня экземпляра: каждый экземпляр &lt;code&gt;Person&lt;/code&gt; будет иметь &lt;em&gt;собственное &lt;/em&gt; &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;age&lt;/code&gt; . Их значения будут начинаться в каждом экземпляре как &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; и &lt;code&gt;32&lt;/code&gt; соответственно, но значение в каждом экземпляре может быть изменено независимо от других:</target>
        </trans-unit>
        <trans-unit id="f7f16b8fd146ff06d4c86373cb61d32bd374065c" translate="yes" xml:space="preserve">
          <source>Note that the type systems of TypeScript and Kotlin do not match exactly, so you may need to edit the generated headers in case you encounter difficulties with using the APIs from Kotlin.</source>
          <target state="translated">Обратите внимание,что системы типов TypeScript и Kotlin не совсем совпадают,поэтому вам может понадобиться отредактировать сгенерированные заголовки в случае,если вы столкнетесь с трудностями при использовании API от Kotlin.</target>
        </trans-unit>
        <trans-unit id="b0f31d7eb5e41ba2d64378a5f837d7e8fe985ed7" translate="yes" xml:space="preserve">
          <source>Note that the use of local returns in previous three examples is similar to the use of &lt;em&gt;continue&lt;/em&gt; in regular loops. There is no direct equivalent for &lt;em&gt;break&lt;/em&gt;, but it can be simulated by adding another nesting lambda and non-locally returning from it:</source>
          <target state="translated">Обратите внимание, что использование локальных возвратов в предыдущих трех примерах аналогично использованию &lt;em&gt;continue&lt;/em&gt; в обычных циклах. Прямого эквивалента для &lt;em&gt;break нет&lt;/em&gt; , но его можно смоделировать, добавив еще одну вложенную лямбду и не локально возвращаясь из нее:</target>
        </trans-unit>
        <trans-unit id="3f8c27f5e2c38c0c780333a188295d27c17547ca" translate="yes" xml:space="preserve">
          <source>Note that there are some cases in which the Kotlin compiler does not apply mangling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4baab91a6183da58c03d16fdff1a5962cf6d45a" translate="yes" xml:space="preserve">
          <source>Note that there must be no space between &lt;code&gt;continue&lt;/code&gt;/&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что между &lt;code&gt;continue&lt;/code&gt; / &lt;code&gt;break&lt;/code&gt; и &lt;code&gt;@&lt;/code&gt; не должно быть пробелов .</target>
        </trans-unit>
        <trans-unit id="9d4ed672615deb4b3ea8e8cf90856dae61208644" translate="yes" xml:space="preserve">
          <source>Note that there's no point in optimizing your code when comparing to &lt;code&gt;null&lt;/code&gt; explicitly: &lt;code&gt;a == null&lt;/code&gt; will be automatically translated to &lt;code&gt;a === null&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что нет смысла оптимизировать ваш код при явном сравнении с &lt;code&gt;null&lt;/code&gt; : &lt;code&gt;a == null&lt;/code&gt; будет автоматически преобразовано в &lt;code&gt;a === null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29bbb70efdb2913fbd8c12ace3a60040ce02ee39" translate="yes" xml:space="preserve">
          <source>Note that these &lt;code&gt;xxxAsync&lt;/code&gt; functions are &lt;strong&gt;not&lt;/strong&gt;&lt;em&gt;suspending&lt;/em&gt; functions. They can be used from anywhere. However, their use always implies asynchronous (here meaning &lt;em&gt;concurrent&lt;/em&gt;) execution of their action with the invoking code.</source>
          <target state="translated">Обратите внимание, что эти функции &lt;code&gt;xxxAsync&lt;/code&gt; &lt;strong&gt;не &lt;/strong&gt;&lt;em&gt;приостанавливают&lt;/em&gt; функции. Их можно использовать откуда угодно. Однако их использование всегда подразумевает асинхронное (здесь имеется в виду &lt;em&gt;одновременное&lt;/em&gt; ) выполнение их действия с вызывающим кодом.</target>
        </trans-unit>
        <trans-unit id="d091dbc112d0275a030bcbf9509f2a82ef36aedb" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does not take locale into account, and will result in an unsatisfactory ordering for certain locales.</source>
          <target state="translated">Обратите внимание,что этот Сравнитель не учитывает местность и приведет к неудовлетворительному заказу для определенных местностей.</target>
        </trans-unit>
        <trans-unit id="bf9957e9675cc2706846aa1653497d6600b98d94" translate="yes" xml:space="preserve">
          <source>Note that this example also uses &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads that are created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">Обратите внимание, что в этом примере также используется функция &lt;code&gt;use&lt;/code&gt; из стандартной библиотеки Kotlin для освобождения потоков, созданных с помощью &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext,&lt;/a&gt; когда они больше не нужны.</target>
        </trans-unit>
        <trans-unit id="75aded832e4b3dd5a16b56a1e23cf328870005d2" translate="yes" xml:space="preserve">
          <source>Note that this example also uses the &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec685b693941d4e96b2af1eef69e4363925a8b20" translate="yes" xml:space="preserve">
          <source>Note that this mechanism currently only works on Java version 1.7+. The JS and Native restrictions are temporary and will be lifted in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cc5e3b07875e2d5bb6712ec59bb2224c29a52e" translate="yes" xml:space="preserve">
          <source>Note that this only works where &lt;code&gt;b&lt;/code&gt; is immutable (i.e. a local variable which is not modified between the check and the usage or a member &lt;em&gt;val&lt;/em&gt; which has a backing field and is not overridable), because otherwise it might happen that &lt;code&gt;b&lt;/code&gt; changes to &lt;em&gt;null&lt;/em&gt; after the check.</source>
          <target state="translated">Обратите внимание, что это работает только там, где &lt;code&gt;b&lt;/code&gt; является неизменным (то есть локальная переменная, которая не изменяется между проверкой и использованием, или член &lt;em&gt;val,&lt;/em&gt; который имеет резервное поле и не может быть переопределен), потому что в противном случае может случиться, что &lt;code&gt;b&lt;/code&gt; изменится на &lt;em&gt;null&lt;/em&gt; после чек.</target>
        </trans-unit>
        <trans-unit id="02cb3aecbee6ce81505199ced32233815d499b61" translate="yes" xml:space="preserve">
          <source>Note that this part of the &lt;code&gt;.def&lt;/code&gt; file is treated as part of the header file, so functions with the body should be declared as &lt;code&gt;static&lt;/code&gt;. The declarations are parsed after including the files from the &lt;code&gt;headers&lt;/code&gt; list.</source>
          <target state="translated">Обратите внимание, что эта часть файла &lt;code&gt;.def&lt;/code&gt; обрабатывается как часть файла заголовка, поэтому функции с телом должны быть объявлены как &lt;code&gt;static&lt;/code&gt; . Объявления анализируются после включения файлов из списка &lt;code&gt;headers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="632fe2c8e3130a19688049106ee9e7cf2e3fa004" translate="yes" xml:space="preserve">
          <source>Note that this way of applying the Kotlin/JS plugin requires adding the following code to Gradle settings file (&lt;code&gt;settings.gradle&lt;/code&gt;):</source>
          <target state="translated">Обратите внимание, что этот способ применения плагина Kotlin / JS требует добавления следующего кода в файл &lt;code&gt;settings.gradle&lt;/code&gt; Gradle ( settings.gradle ):</target>
        </trans-unit>
        <trans-unit id="3e08e867fd041797206da0cee5969714ae5576c9" translate="yes" xml:space="preserve">
          <source>Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a &lt;code&gt;Double&lt;/code&gt; parameter can be called only on &lt;code&gt;Double&lt;/code&gt; values, but not &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, or other numeric values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d89b0ac97e4e72ec3a56a39219f1c2ad6cf8c5b" translate="yes" xml:space="preserve">
          <source>Note that we do not use &lt;code&gt;val&lt;/code&gt; in front of &lt;code&gt;maxSpeed&lt;/code&gt; in &lt;code&gt;Car&lt;/code&gt; - doing so would have introduced a distinct property in &lt;code&gt;Car&lt;/code&gt; that would have &lt;em&gt;shadowed&lt;/em&gt; the one inherited from &lt;code&gt;MotorVehicle&lt;/code&gt;. As written, it's just a constructor parameter that we pass on to the superconstructor.</source>
          <target state="translated">Обратите внимание , что мы не используем &lt;code&gt;val&lt;/code&gt; перед &lt;code&gt;maxSpeed&lt;/code&gt; в &lt;code&gt;Car&lt;/code&gt; - делать так бы ввел отдельную собственность в &lt;code&gt;Car&lt;/code&gt; , который бы &lt;em&gt;затененное&lt;/em&gt; один унаследованный от &lt;code&gt;MotorVehicle&lt;/code&gt; . Как написано, это просто параметр конструктора, который мы передаем суперконструктору.</target>
        </trans-unit>
        <trans-unit id="32efdf9e14f64cdc5ac4ce116b4cf7f1f66b160c" translate="yes" xml:space="preserve">
          <source>Note that when the LazyThreadSafetyMode.SYNCHRONIZED mode is specified the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">Обратите внимание,что при указании режима LazyThreadSafetyMode.SYNCHRONIZED возвращаемый экземпляр использует себя для синхронизации.Не синхронизируйтесь с внешним кодом на возвращаемом экземпляре,так как это может привести к случайному блокировке.Также такое поведение может быть изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="d89d8b71e027e7e428c09aada677d55add6a81f5" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;File()&lt;/code&gt; does create a &quot;file object&quot;, it doesn't actually open the file - the file object is just a reference to the file path; opening the file is a separate action. The preceding functions open and close the file automatically, whereas other functions separately open and close the file. For example, if you're parsing binary data and you don't want to read the entire file at once, you must create an &lt;em&gt;input stream&lt;/em&gt; (for binary data) or an &lt;em&gt;input stream reader&lt;/em&gt; (for strings) - the example below will read 16 bytes:</source>
          <target state="translated">Обратите внимание, что хотя &lt;code&gt;File()&lt;/code&gt; действительно создает &amp;laquo;файловый объект&amp;raquo;, он на самом деле не открывает файл - файловый объект является просто ссылкой на путь к файлу; открытие файла - отдельное действие. Предыдущие функции открывают и закрывают файл автоматически, тогда как другие функции открывают и закрывают файл отдельно. Например, если вы анализируете двоичные данные и не хотите читать весь файл сразу, вы должны создать &lt;em&gt;входной поток&lt;/em&gt; (для двоичных данных) или &lt;em&gt;считыватель входного потока&lt;/em&gt; (для строк) - пример ниже будет читать 16 байт:</target>
        </trans-unit>
        <trans-unit id="14f5320c56ff81654d679ede920646b9dc75066a" translate="yes" xml:space="preserve">
          <source>Note that with Gradle Kotlin DSL, you should get the task from the project's &lt;code&gt;tasks&lt;/code&gt; first.</source>
          <target state="translated">Обратите внимание, что с Gradle Kotlin DSL вы должны сначала получить задачу из &lt;code&gt;tasks&lt;/code&gt; проекта .</target>
        </trans-unit>
        <trans-unit id="c40d9fcf3b6b2afa85b538678b5ccf141165484f" translate="yes" xml:space="preserve">
          <source>Note that you can build the same pipeline using &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; coroutine builder from the standard library. Replace &lt;code&gt;produce&lt;/code&gt; with &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; with &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;ReceiveChannel&lt;/code&gt; with &lt;code&gt;Iterator&lt;/code&gt;, and get rid of the coroutine scope. You will not need &lt;code&gt;runBlocking&lt;/code&gt; either. However, the benefit of a pipeline that uses channels as shown above is that it can actually use multiple CPU cores if you run it in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context.</source>
          <target state="translated">Обратите внимание, что вы можете построить тот же конвейер, используя построитель сопрограмм &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt; из стандартной библиотеки. Замените &lt;code&gt;produce&lt;/code&gt; на &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; с &lt;code&gt;yield&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; с помощью &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;ReceiveChannel&lt;/code&gt; с помощью &lt;code&gt;Iterator&lt;/code&gt; и избавьтесь от области сопрограммы. Вам также не понадобится &lt;code&gt;runBlocking&lt;/code&gt; . Однако преимущество конвейера, использующего каналы, как показано выше, заключается в том, что он может фактически использовать несколько ядер ЦП, если вы запускаете его в контексте &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb9e894663a37dff3bfdff25d326ba2089261968" translate="yes" xml:space="preserve">
          <source>Note that you can open folders in the Source tab and see sources of libraries you are using in your project, including Kotlin standard library (&lt;code&gt;kotlin.js&lt;/code&gt;). This, however, requires that libraries are compiled with source maps enabled, as well as sources embedded into source maps. So the good practice is: if you share a library for Kotlin/JS, please, include source map into distribution.</source>
          <target state="translated">Обратите внимание, что вы можете открывать папки на вкладке &amp;laquo;Источник&amp;raquo; и просматривать источники библиотек, которые вы используете в своем проекте, включая стандартную библиотеку Kotlin ( &lt;code&gt;kotlin.js&lt;/code&gt; ). Однако для этого необходимо, чтобы библиотеки были скомпилированы с включенными исходными картами, а также с источниками, встроенными в исходные карты. Итак, хорошая практика: если вы разделяете библиотеку для Kotlin / JS, пожалуйста, включите исходную карту в дистрибутив.</target>
        </trans-unit>
        <trans-unit id="f3d310ef82c3c4cf7ec6ba7c31c24dfd55f8f136" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;em&gt;override&lt;/em&gt; keyword as part of the property declaration in a primary constructor.</source>
          <target state="translated">Обратите внимание, что вы можете использовать ключевое слово &lt;em&gt;override&lt;/em&gt; как часть объявления свойства в основном конструкторе.</target>
        </trans-unit>
        <trans-unit id="49136291f4ccdd63f93ac650ad3552f2ac330a1e" translate="yes" xml:space="preserve">
          <source>Note that you can't extend a non-external class by external classes.</source>
          <target state="translated">Обратите внимание,что вы не можете расширить не-внешний класс за счет внешних классов.</target>
        </trans-unit>
        <trans-unit id="3e28231afdd7ac958845e417ade6744d2f5c90c1" translate="yes" xml:space="preserve">
          <source>Note that you need to turn on the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental flag&lt;/a&gt; to use &lt;code&gt;LayoutContainer&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что для использования &lt;code&gt;LayoutContainer&lt;/code&gt; необходимо включить &lt;a href=&quot;#enabling-experimental-features&quot;&gt;экспериментальный флаг&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7606870a12c3125873b69f0dbf82ae21f8b6f6b5" translate="yes" xml:space="preserve">
          <source>Note that, as described in &lt;a href=&quot;classes#secondary-constructors&quot;&gt;Secondary Constructors&lt;/a&gt;, if a class has default values for all constructor parameters, a public no-argument constructor will be generated for it. This works even if the &lt;code&gt;@JvmOverloads&lt;/code&gt; annotation is not specified.</source>
          <target state="translated">Обратите внимание, что, как описано в &lt;a href=&quot;classes#secondary-constructors&quot;&gt;разделе &amp;laquo;Вторичные конструкторы&amp;raquo;&lt;/a&gt; , если класс имеет значения по умолчанию для всех параметров конструктора, для него будет сгенерирован общедоступный конструктор без аргументов. Это работает, даже если аннотация &lt;code&gt;@JvmOverloads&lt;/code&gt; не указана.</target>
        </trans-unit>
        <trans-unit id="bcfd3d4bc13c4d196d89ced424f8f78ed6df819a" translate="yes" xml:space="preserve">
          <source>Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces:</source>
          <target state="translated">Обратите внимание,что даже если члены объектов-компаньонов выглядят как статические члены на других языках,во время исполнения они все равно являются экземплярами членов реальных объектов,и могут,например,реализовывать интерфейсы:</target>
        </trans-unit>
        <trans-unit id="63673aeff981591d75550c2f1b2c84d22a058b57" translate="yes" xml:space="preserve">
          <source>Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time.</source>
          <target state="translated">Обратите внимание,что если у класса Java есть только сеттер,то он не будет виден как свойство в Котлине,так как Котлин в данный момент не поддерживает только сеттерские свойства.</target>
        </trans-unit>
        <trans-unit id="4ff451e50da6bbf10519c4f38e0ec36c818d0c89" translate="yes" xml:space="preserve">
          <source>Note that, since &lt;em&gt;throw&lt;/em&gt; and &lt;em&gt;return&lt;/em&gt; are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:</source>
          <target state="translated">Обратите внимание: поскольку &lt;em&gt;throw&lt;/em&gt; и &lt;em&gt;return&lt;/em&gt; являются выражениями в Kotlin, их также можно использовать в правой части оператора elvis. Это может быть очень удобно, например, для проверки аргументов функции:</target>
        </trans-unit>
        <trans-unit id="ff2652dcfc51e4dc3d549eb0a81df9a68d2667cc" translate="yes" xml:space="preserve">
          <source>Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a &lt;a href=&quot;properties#backing-fields&quot;&gt;backing field&lt;/a&gt;. This is why &lt;strong&gt;initializers are not allowed for extension properties&lt;/strong&gt;. Their behavior can only be defined by explicitly providing getters/setters.</source>
          <target state="translated">Обратите внимание: поскольку расширения фактически не вставляют члены в классы, не существует эффективного способа для свойства расширения иметь &lt;a href=&quot;properties#backing-fields&quot;&gt;поле поддержки&lt;/a&gt; . Вот почему &lt;strong&gt;инициализаторы не разрешены для свойств расширения&lt;/strong&gt; . Их поведение можно определить только путем явного предоставления геттеров / сеттеров.</target>
        </trans-unit>
        <trans-unit id="410e3cbb9102efe17f7c84d061da15f92debf764" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;@NotNull&lt;/code&gt; annotations on &lt;code&gt;String&lt;/code&gt; type arguments. Without them, we get platform types in the type arguments:</source>
          <target state="translated">Обратите внимание на аннотации &lt;code&gt;@NotNull&lt;/code&gt; для аргументов типа &lt;code&gt;String&lt;/code&gt; . Без них мы получаем типы платформ в аргументах типа:</target>
        </trans-unit>
        <trans-unit id="c5849a883ad401340758801d94c3c8fe5489e593" translate="yes" xml:space="preserve">
          <source>Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:</source>
          <target state="translated">Обратите внимание на разницу между декларированием двух параметров и декларированием пары деструкции вместо параметра:</target>
        </trans-unit>
        <trans-unit id="fe84360ef08152f70a600e469dd1daf46f251b07" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;visibility modifier&lt;/a&gt; here. While the concept of visibility modifier is not relevant for competitive programming at all, it allows you to place multiple solution files based on the same template without getting an error for conflicting public declarations in the same package.</source>
          <target state="translated">Обратите внимание на использование здесь &lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;модификатора &lt;/a&gt; &lt;code&gt;private&lt;/code&gt; видимости . Хотя концепция модификатора видимости вообще не актуальна для конкурентного программирования, она позволяет размещать несколько файлов решений на основе одного и того же шаблона без получения ошибки из-за конфликтующих общедоступных объявлений в одном пакете.</target>
        </trans-unit>
        <trans-unit id="32363778a2d483af8b5e294fa0d257703c3636de" translate="yes" xml:space="preserve">
          <source>Note the use of Kotlin's &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;null-assertion operator&lt;/a&gt;&lt;code&gt;!!&lt;/code&gt; after the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine()&lt;/a&gt; function call. Kotlin's &lt;code&gt;readLine()&lt;/code&gt; function is defined to return a &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable type&lt;/a&gt;&lt;code&gt;String?&lt;/code&gt; and returns &lt;code&gt;null&lt;/code&gt; on the end of the input, which explicitly forces the developer to handle the case of missing input.</source>
          <target state="translated">Обратите внимание на использование Kotlin &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;оператора нулевого утверждения &lt;/a&gt; &lt;code&gt;!!&lt;/code&gt; после вызова функции &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine ()&lt;/a&gt; . Функция Kotlin &lt;code&gt;readLine()&lt;/code&gt; определена для возврата &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;обнуляемого типа &lt;/a&gt; &lt;code&gt;String?&lt;/code&gt; и возвращает &lt;code&gt;null&lt;/code&gt; в конце ввода, что явно заставляет разработчика обрабатывать случай отсутствия ввода.</target>
        </trans-unit>
        <trans-unit id="ac2f2aad869d626d4d52fe790ab55573fcf5e8e3" translate="yes" xml:space="preserve">
          <source>Note, Kotlin/Native object references do not support multi-threaded access. Hosting the returned &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; pointer per thread might be necessary.</source>
          <target state="translated">Обратите внимание: ссылки на объекты Kotlin / Native не поддерживают многопоточный доступ. &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; возвращаемого указателя libnative_ExportedSymbols * для каждого потока.</target>
        </trans-unit>
        <trans-unit id="2b78a1550dcdacf66568124ca1b7e49361c24581" translate="yes" xml:space="preserve">
          <source>Note, here we use the &lt;code&gt;$SRCROOT/../..&lt;/code&gt; as the path to the root of our Gradle project. It can depend on the way the Xcode project was created. Also, we use the generated &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; script, the &lt;code&gt;packForXCode&lt;/code&gt; task generates it. We assumed that the Gradle build is executed at least once, before opening the Xcode project on a fresh machine</source>
          <target state="translated">Обратите внимание, здесь мы используем &lt;code&gt;$SRCROOT/../..&lt;/code&gt; как путь к корню нашего проекта Gradle. Это может зависеть от того, как был создан проект Xcode. Также мы используем сгенерированный &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; , его &lt;code&gt;packForXCode&lt;/code&gt; задача packForXCode . Мы предполагали, что сборка Gradle выполняется хотя бы один раз, прежде чем открыть проект Xcode на новой машине.</target>
        </trans-unit>
        <trans-unit id="e681d434ce2d0ba5fe65e1c3eb9e64a72c2114ad" translate="yes" xml:space="preserve">
          <source>Note, how both first &lt;code&gt;async&lt;/code&gt; and awaiting parent are cancelled on the one child failure:</source>
          <target state="translated">Обратите внимание, как первый &lt;code&gt;async&lt;/code&gt; и ожидающий родитель отменяются при сбое одного дочернего элемента:</target>
        </trans-unit>
        <trans-unit id="fa14e718dbed55afbde738f5e7d1fbd2fe0275f6" translate="yes" xml:space="preserve">
          <source>Note, however, that members overridden in this way do not get called from the members of the delegate object, which can only access its own implementations of the interface members:</source>
          <target state="translated">Обратите внимание,однако,что члены,переопределенные таким образом,не получают вызовов от членов объекта делегата,который может получить доступ только к своим собственным реализациям членов интерфейса:</target>
        </trans-unit>
        <trans-unit id="63c0fd4e85cb25d5c9ec03f575f81a0e9dd952a9" translate="yes" xml:space="preserve">
          <source>Note, that Android has first-party support for coroutine scope in all entities with the lifecycle. See &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope&quot;&gt;the corresponding documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9016aa7ea4f2b1fc5592a3d2b46f69f0ff3c825e" translate="yes" xml:space="preserve">
          <source>Note, that an exception thrown by &lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is rethrown by this function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">Обратите внимание, что исключение, созданное функцией &lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;преобразования,&lt;/a&gt; повторно генерируется этой функцией. См. &lt;a href=&quot;recover-catching&quot;&gt;RecoveryCatching&lt;/a&gt; для альтернативы, которая инкапсулирует исключения.</target>
        </trans-unit>
        <trans-unit id="ab4261a565eea01ddcb4378ad59c0c58898851cf" translate="yes" xml:space="preserve">
          <source>Note, that for some cases cycle collection need to be done to ensure that dead cycles do not affect reachability of passed object graph.</source>
          <target state="translated">Обратите внимание,что в некоторых случаях необходимо собирать циклы,чтобы убедиться,что мертвые циклы не влияют на достижимость передаваемого объектного графа.</target>
        </trans-unit>
        <trans-unit id="cb746582c1d18af800034f12e0c2fb36cf93a443" translate="yes" xml:space="preserve">
          <source>Note, that incrementing and decrementing &lt;code&gt;acquired&lt;/code&gt; counter here from 100K coroutines is completely safe, since it always happens from the same main thread. More on that will be explained in the next chapter on coroutine context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6259b2eebc86f15dafec32912cdde080c4e1580" translate="yes" xml:space="preserve">
          <source>Note, that the generated bindings are generally platform-specific, so if you are developing for multiple targets, the bindings need to be regenerated.</source>
          <target state="translated">Обратите внимание,что сгенерированные крепления,как правило,зависят от платформы,поэтому,если вы разрабатываете крепления для нескольких целей,они должны быть регенерированы.</target>
        </trans-unit>
        <trans-unit id="7b7682c3f874c25b43973c6dea774be8a4df50c1" translate="yes" xml:space="preserve">
          <source>Note, that this function rethrows any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover#kotlin%24recover(kotlin.Result((kotlin.recover.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recover.R)))/transform&quot;&gt;transform&lt;/a&gt; function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe80340489c5eb8bbb1e5235c463cea51b0d96bc" translate="yes" xml:space="preserve">
          <source>Note, the task may not work &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;correctly&lt;/a&gt; if you use Gradle older than 4.10. In this tutorial we have already &lt;a href=&quot;#gradle-upgrade&quot;&gt;upgraded it to 4.7&lt;/a&gt;.</source>
          <target state="translated">Учтите, что задача может работать &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;некорректно,&lt;/a&gt; если вы используете Gradle старше 4.10. В этом руководстве мы уже &lt;a href=&quot;#gradle-upgrade&quot;&gt;обновили его до версии 4.7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdfb7f6c960fbbb54ec2a22474d762eebb5eb578" translate="yes" xml:space="preserve">
          <source>Note, the way Kotlin/Native exports symbols is subject to change without notice.</source>
          <target state="translated">Обратите внимание,что способ экспорта символов Kotlin/Native может быть изменен без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="a421385920384e5f4a176ab3c70967301467e475" translate="yes" xml:space="preserve">
          <source>Note, this mechanism currently works only on Java version 1.7+. Limitation on JS and Native is temporary and will be fixed in the future.</source>
          <target state="translated">Обратите внимание,что в настоящее время этот механизм работает только на Java версии 1.7+.Ограничение на JS и Native является временным и будет исправлено в будущем.</target>
        </trans-unit>
        <trans-unit id="12618a61ea26af57372d00837c08269ccff8b13d" translate="yes" xml:space="preserve">
          <source>Note, we use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from a &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type, to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers.</source>
          <target state="translated">Обратите внимание, что мы используем свойство расширения &lt;code&gt;ptr&lt;/code&gt; , которое происходит от &lt;code&gt;memScoped&lt;/code&gt; лямбда-приемника memScoped , чтобы превратить &lt;code&gt;MyStruct&lt;/code&gt; и &lt;code&gt;MyUnion&lt;/code&gt; в собственные указатели.</target>
        </trans-unit>
        <trans-unit id="928235a3ea58117b013d6814e6ae398b8d106eb5" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">Примечание: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; может принимать только подмножество логических выражений, где параметр функции или получатель ( &lt;code&gt;this&lt;/code&gt; ) подвергается</target>
        </trans-unit>
        <trans-unit id="154a86bc22d004fb84d8a8a0b6c888692235178f" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies(kotlin.Boolean)/booleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6981f24296bbc00cf0e0f8db9ec6624b3daecbcc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Any&lt;/code&gt; is not &lt;code&gt;java.lang.Object&lt;/code&gt;; in particular, it does not have any members other than &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;toString()&lt;/code&gt;. Please consult the &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java interoperability&lt;/a&gt; section for more details.</source>
          <target state="translated">Примечание: &lt;code&gt;Any&lt;/code&gt; не является &lt;code&gt;java.lang.Object&lt;/code&gt; ; в частности, он не имеет других членов, кроме &lt;code&gt;equals()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; и &lt;code&gt;toString()&lt;/code&gt; . Пожалуйста, обратитесь к разделу &lt;a href=&quot;java-interop#object-methods&quot;&gt;совместимости Java&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="7cea38b31131e5f3bc473b1806a7dadc1df3f76c" translate="yes" xml:space="preserve">
          <source>Note: Before 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:</source>
          <target state="translated">Примечание:До версии 1.3.40 и тестовые,и продуктовые исполняемые файлы были представлены одним и тем же типом двоичных файлов.Таким образом,для доступа к создаваемому плагином тестовому двоичному файлу по умолчанию использовалась следующая строка:</target>
        </trans-unit>
        <trans-unit id="fb3a30630df8eec859177fc75c5dd700ee60baec" translate="yes" xml:space="preserve">
          <source>Note: For Spring you can use the &lt;code&gt;kotlin-spring&lt;/code&gt; compiler plugin (&lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">Примечание. Для Spring вы можете использовать плагин компилятора &lt;code&gt;kotlin-spring&lt;/code&gt; ( &lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;см. Ниже&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6a0dc39a4a138257b96c621b751cc052081b76a" translate="yes" xml:space="preserve">
          <source>Note: This above code will work properly only on JDK7+ that supports &lt;code&gt;suppressed&lt;/code&gt; exceptions</source>
          <target state="translated">Примечание: приведенный выше код будет правильно работать только на JDK7 +, который поддерживает &lt;code&gt;suppressed&lt;/code&gt; исключения.</target>
        </trans-unit>
        <trans-unit id="484cdded81040d7cac731a5df3e0b2162661d2db" translate="yes" xml:space="preserve">
          <source>Note: creating a source set does not link it to any target. Some source sets are &lt;a href=&quot;#default-project-layout&quot;&gt;predefined&lt;/a&gt; and thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. See: &lt;a href=&quot;#connecting-source-sets&quot;&gt;Connecting source sets&lt;/a&gt;.</source>
          <target state="translated">Примечание: создание исходного набора не связывает его ни с какой целью. Некоторые исходные наборы &lt;a href=&quot;#default-project-layout&quot;&gt;предопределены&lt;/a&gt; и поэтому компилируются по умолчанию. Однако настраиваемые исходные наборы всегда необходимо явно направлять на компиляции. См .: &lt;a href=&quot;#connecting-source-sets&quot;&gt;Подключение источников&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d3cb30c99fb08c5217d1cecd77b25e0a37cf168" translate="yes" xml:space="preserve">
          <source>Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.</source>
          <target state="translated">Замечание:в связи с текущими техническими ограничениями,IDE некорректно распознает эти аннотации по аргументам типов в скомпилированных библиотеках Java,которые используются в качестве зависимостей.</target>
        </trans-unit>
        <trans-unit id="43526e690a06b94dffa5d82ef9ea46b38220defe" translate="yes" xml:space="preserve">
          <source>Note: runtime lookup can be forced even when the class is referenced statically from Objective-C source code by adding &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; to its &lt;code&gt;@interface&lt;/code&gt;.</source>
          <target state="translated">Примечание: поиск во время выполнения может быть принудительным, даже если на класс статически ссылаются из исходного кода Objective-C, добавив &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; к его &lt;code&gt;@interface&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961c619d9fb3964975b4b9e69245c681552524a7" translate="yes" xml:space="preserve">
          <source>Note: static and shared libraries has suffixes &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; respectively, e.g. &lt;code&gt;fooDebugStatic&lt;/code&gt; or &lt;code&gt;barReleaseShared&lt;/code&gt;</source>
          <target state="translated">Примечание: статические и общие библиотеки имеют суффиксы &lt;code&gt;static&lt;/code&gt; и &lt;code&gt;shared&lt;/code&gt; соответственно, например &lt;code&gt;fooDebugStatic&lt;/code&gt; или &lt;code&gt;barReleaseShared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba0ca9c0ff727e2f159f9a318e2b4838c970baa" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;lib&lt;/code&gt; directory which contains &lt;code&gt;kotlin.js&lt;/code&gt; and other library files is only created in IntelliJ IDEA-based projects and is controlled by the &lt;em&gt;Copy library runtime files&lt;/em&gt; flag in the Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;facet settings&lt;/a&gt;. In a Maven or Gradle build (including multiplatform projects), no library files are copied by default to the compilation output directory. See the corresponding tutorials for the instructions on how to achieve the same with those build systems.</source>
          <target state="translated">Примечание: каталог &lt;code&gt;lib&lt;/code&gt; , содержащий &lt;code&gt;kotlin.js&lt;/code&gt; и другие файлы библиотеки, создается только в проектах на основе IntelliJ IDEA и управляется флагом &lt;em&gt;Копировать файлы среды выполнения библиотеки&lt;/em&gt; в &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;настройках фасета&lt;/a&gt; Kotlin . В сборке Maven или Gradle (включая многоплатформенные проекты) файлы библиотеки по умолчанию не копируются в выходной каталог компиляции. См. Соответствующие руководства для получения инструкций о том, как добиться того же с этими системами сборки.</target>
        </trans-unit>
        <trans-unit id="7a0e64e270b153ff90968e1ff6456ea22567f491" translate="yes" xml:space="preserve">
          <source>Note: the built-in JSR-305 annotations &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt;&lt;code&gt;@CheckForNull&lt;/code&gt;&lt;/a&gt; are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the &lt;code&gt;-Xjsr305&lt;/code&gt; flag.</source>
          <target state="translated">Примечание: встроенные аннотации JSR-305 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt; &lt;code&gt;@CheckForNull&lt;/code&gt; &lt;/a&gt; всегда включены и влияют на типы аннотированных объявлений в Kotlin, независимо от конфигурации компилятора с флагом &lt;code&gt;-Xjsr305&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70ea34d1da722222e140a53cf5465f6882b21617" translate="yes" xml:space="preserve">
          <source>Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</source>
          <target state="translated">Замечание:миграционный статус аннулируемой аннотации не наследуется никами классификаторов типов,а применяется к ее использованию в классификаторах типов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c0edc7da32b33f24605529da7af1e0f20a415a52" translate="yes" xml:space="preserve">
          <source>Note: the static members of these Java types are not directly accessible on the &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion objects&lt;/a&gt; of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt;.</source>
          <target state="translated">Примечание: статические члены этих типов Java не доступны напрямую для &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;сопутствующих объектов&lt;/a&gt; типов Kotlin. Для их вызова используйте полные квалифицированные имена типов Java, например &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d630dc0f3f2c164372b5befca4a458dbf430dc" translate="yes" xml:space="preserve">
          <source>Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt;&lt;code&gt;@UnderMigration&lt;/code&gt; annotation&lt;/a&gt; and &lt;a href=&quot;#compiler-configuration&quot;&gt;Compiler configuration&lt;/a&gt; sections.</source>
          <target state="translated">Примечание: типы в этом примере имеют место только при включенном строгом режиме, в противном случае типы платформ остаются. См. &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt; &lt;code&gt;@UnderMigration&lt;/code&gt; аннотации @UnderMigration&lt;/a&gt; и &lt;a href=&quot;#compiler-configuration&quot;&gt;конфигурации компилятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1897db2fc3536b91b9cf29ef737cb27b1a12735f" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">Примечание: эта аннотация является экспериментальной, см. &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; о том, как подписаться на нее.</target>
        </trans-unit>
        <trans-unit id="0b4255d1b07a5ecec5778c495ae7e465e074b5b4" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">Примечание: эта аннотация является экспериментальной, см. &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; о том, как подписаться на нее.</target>
        </trans-unit>
        <trans-unit id="357bf8828e4f466867f5aa8f9b5bb6f1a07b487b" translate="yes" xml:space="preserve">
          <source>Note: to use a visible top-level declaration from another package, you should still &lt;a href=&quot;packages#imports&quot;&gt;import&lt;/a&gt; it.</source>
          <target state="translated">Примечание: чтобы использовать видимое объявление верхнего уровня из другого пакета, вы все равно должны его &lt;a href=&quot;packages#imports&quot;&gt;импортировать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0d56c46129caef4c0e06f3c8334481a847bd34" translate="yes" xml:space="preserve">
          <source>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; to an &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt;, which prevents a possible runtime failure (but you can use &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt;, see &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt;).</source>
          <target state="translated">Примечание: в отличие от Java, массивы в Kotlin инвариантны. Это означает , что Котлин не позволяет присвоить &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; на &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt; , что предотвращает возможный отказ выполнения (но вы можете использовать &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt; см &lt;a href=&quot;generics#type-projections&quot;&gt;Тип проекциях&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="79090fccdb94d09e1c560c62dc8ff6d888bc7489" translate="yes" xml:space="preserve">
          <source>Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception).</source>
          <target state="translated">Ничего не бывает.Вы можете использовать Nothing для представления &quot;значения,которое никогда не существует&quot;:например,если функция имеет тип возврата Nothing,это означает,что она никогда не возвращается (всегда бросает исключение).</target>
        </trans-unit>
        <trans-unit id="a531e5857d96a6fe172e33a54636fa2c5e7837a4" translate="yes" xml:space="preserve">
          <source>Notice that the implementation on &lt;em&gt;every&lt;/em&gt; platform can encode byte arrays to a string. If we want we can provide a more efficient implementation for this method, for example, let's specialize it on the JVM:</source>
          <target state="translated">Обратите внимание, что реализация на &lt;em&gt;каждой&lt;/em&gt; платформе может кодировать байтовые массивы в строку. Если мы хотим, мы можем предоставить более эффективную реализацию этого метода, например, давайте специализируемся на JVM:</target>
        </trans-unit>
        <trans-unit id="ac46cd6bf2ec7e9d90f5e3709af6c843ffd8a6af" translate="yes" xml:space="preserve">
          <source>NotificationAction</source>
          <target state="translated">NotificationAction</target>
        </trans-unit>
        <trans-unit id="f541255e0e0d091ef01be7d639674756d30f41bc" translate="yes" xml:space="preserve">
          <source>NotificationDirection</source>
          <target state="translated">NotificationDirection</target>
        </trans-unit>
        <trans-unit id="596349e0f504aa4e6ec1f31115a62914042449e8" translate="yes" xml:space="preserve">
          <source>NotificationEventInit</source>
          <target state="translated">NotificationEventInit</target>
        </trans-unit>
        <trans-unit id="2a1a4c24d8e083b47b4ff678b4cd0997219c060e" translate="yes" xml:space="preserve">
          <source>NotificationOptions</source>
          <target state="translated">NotificationOptions</target>
        </trans-unit>
        <trans-unit id="93c639dc73db96edc66ede2299276f652971fac6" translate="yes" xml:space="preserve">
          <source>NotificationPermission</source>
          <target state="translated">NotificationPermission</target>
        </trans-unit>
        <trans-unit id="94e838061a82a5ce0b113db3557cf9f9730866ea" translate="yes" xml:space="preserve">
          <source>Now check it with the command &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; and you should see a successful build. That's it, our library is now successfully published and any Kotlin project can depend on it, whether it is another common library, JVM, JS, or Native application.</source>
          <target state="translated">Теперь проверьте это с помощью команды &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; , и вы должны увидеть успешную сборку. Вот и все, наша библиотека теперь успешно опубликована, и от нее может зависеть любой проект Kotlin, будь то другая общая библиотека, JVM, JS или собственное приложение.</target>
        </trans-unit>
        <trans-unit id="4c6fdd021c50c395969a31c37923d25d734b30ed" translate="yes" xml:space="preserve">
          <source>Now compile the program linking with the library we have just created:</source>
          <target state="translated">Теперь скомпилируйте программу,связывающую с только что созданной нами библиотекой:</target>
        </trans-unit>
        <trans-unit id="7fd938355a267ec17f411c8d98d04708e4180da6" translate="yes" xml:space="preserve">
          <source>Now it is time to provide an &lt;code&gt;actual&lt;/code&gt; implementation of &lt;code&gt;Base64Factory&lt;/code&gt; for every platform.</source>
          <target state="translated">&lt;code&gt;Base64Factory&lt;/code&gt; время предоставить &lt;code&gt;actual&lt;/code&gt; реализацию Base64Factory для каждой платформы.</target>
        </trans-unit>
        <trans-unit id="ef159996af2b9215562c38a942c2f8905195f55d" translate="yes" xml:space="preserve">
          <source>Now it is time to refresh the Gradle project again in Android Studio. Click &lt;em&gt;Sync Now&lt;/em&gt; on the yellow stripe or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the &lt;code&gt;Refresh&lt;/code&gt; action in the context menu on the root Gradle project. The &lt;code&gt;:SharedCode&lt;/code&gt; project should be recognized by the IDE now.</source>
          <target state="translated">Пришло время снова обновить проект Gradle в Android Studio. Нажмите &amp;laquo; &lt;em&gt;Синхронизировать сейчас&amp;raquo;&lt;/em&gt; на желтой полосе или используйте окно инструмента &lt;em&gt;Gradle&lt;/em&gt; и щелкните действие &amp;laquo; &lt;code&gt;Refresh&lt;/code&gt; в контекстном меню корневого проекта Gradle. Теперь &lt;code&gt;:SharedCode&lt;/code&gt; должна распознать проект : SharedCode .</target>
        </trans-unit>
        <trans-unit id="9eb8c10ce256de217fd7408c5d0fa2be1c81f16b" translate="yes" xml:space="preserve">
          <source>Now it is time to see how to use &lt;code&gt;cValue&lt;/code&gt; and pass by-value parameters:</source>
          <target state="translated">Теперь пора посмотреть, как использовать &lt;code&gt;cValue&lt;/code&gt; и передавать параметры по значению:</target>
        </trans-unit>
        <trans-unit id="f62049422e34abdef8fb40e736ddaa894413b1d4" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;1784293664&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">Теперь он выводит что-то осмысленное: &lt;code&gt;1784293664&lt;/code&gt; , потому что все сопрограммы завершены.</target>
        </trans-unit>
        <trans-unit id="144f2d2ebae18220179fd1c455d34a68896fdfc7" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;500000500000&lt;/code&gt;, because all coroutines complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3c5f110103dcae6c7a1c5048ae4801a489102c" translate="yes" xml:space="preserve">
          <source>Now it's time to add the task description. Click the &lt;strong&gt;Edit&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel to switch to the editing mode:</source>
          <target state="translated">Пришло время добавить описание задачи. Щелкните значок &lt;strong&gt;Изменить&lt;/strong&gt; в верхней части панели &lt;strong&gt;описания задачи,&lt;/strong&gt; чтобы переключиться в режим редактирования:</target>
        </trans-unit>
        <trans-unit id="f21a6f3ded0ce3ad0d37be7f610a6bcde3237278" translate="yes" xml:space="preserve">
          <source>Now let us launch five processors and let them work for almost a second. See what happens:</source>
          <target state="translated">Теперь давайте запустим пять процессоров и позволим им работать почти секунду.Посмотрим,что получится:</target>
        </trans-unit>
        <trans-unit id="3a85707fc6ed973d97aee272da025f72a2062245" translate="yes" xml:space="preserve">
          <source>Now let's check out the contents of the library:</source>
          <target state="translated">Теперь давайте проверим содержимое библиотеки:</target>
        </trans-unit>
        <trans-unit id="06f1756ff063bdd720deb57bebdc098cbb1f3682" translate="yes" xml:space="preserve">
          <source>Now let's open the project in IntelliJ IDEA. For that we click on the File | Open&amp;hellip; and select our &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; project file.</source>
          <target state="translated">Теперь откроем проект в IntelliJ IDEA. Для этого щелкаем на File | Откройте ... и выберите наш &lt;code&gt;build.gradle&lt;/code&gt; проекта &lt;code&gt;build.gradle.kts&lt;/code&gt; build.gradle .</target>
        </trans-unit>
        <trans-unit id="62863dbb3bcee301c0e208573e6e92993330cf1e" translate="yes" xml:space="preserve">
          <source>Now let's see how it works in practice:</source>
          <target state="translated">Теперь посмотрим,как это работает на практике:</target>
        </trans-unit>
        <trans-unit id="316006c9bf1b6b4efc24b9287e973de18a0cd5b2" translate="yes" xml:space="preserve">
          <source>Now let's write the same with sequences:</source>
          <target state="translated">Теперь давайте напишем то же самое с последовательностями:</target>
        </trans-unit>
        <trans-unit id="a94f1a0ca142aa8eb48c8af48afa3350f83b1400" translate="yes" xml:space="preserve">
          <source>Now need to create an empty &lt;code&gt;settings.gradle.kts&lt;/code&gt;&lt;code&gt;settings.gradle&lt;/code&gt; file in the project root directory.</source>
          <target state="translated">Теперь нужно создать пустой файл &lt;code&gt;settings.gradle.kts&lt;/code&gt; &lt;code&gt;settings.gradle&lt;/code&gt; в корневом каталоге проекта.</target>
        </trans-unit>
        <trans-unit id="6c9080cd76ec0143ae2c7fdafc332586543b3c8a" translate="yes" xml:space="preserve">
          <source>Now the application is ready to run. The easiest way is to click the green &lt;strong&gt;Run&lt;/strong&gt; icon in the gutter and select &lt;strong&gt;Run 'AppKt'&lt;/strong&gt;.</source>
          <target state="translated">Теперь приложение готово к запуску. Самый простой способ - щелкнуть зеленый значок &amp;laquo; &lt;strong&gt;Выполнить&amp;raquo;&lt;/strong&gt; в желобе и выбрать &amp;laquo; &lt;strong&gt;Запустить AppKt&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a4dea9f6780cb4b1fb116abe461c884b2fc3e6f5" translate="yes" xml:space="preserve">
          <source>Now the classic &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt; can be used. Don't forget to specify the group and version of your library along with the plugin in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">Теперь можно использовать классический &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;плагин&lt;/a&gt; Gradle для &lt;code&gt;maven-publish&lt;/code&gt; . Не забудьте указать группу и версию вашей библиотеки вместе с плагином в &lt;code&gt;build.gradle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c36da2f63965003675ecd4f90e9e76c88deea8db" translate="yes" xml:space="preserve">
          <source>Now the main function awaits for the first of them to complete and counts the number of deferred values that are still active. Note that we've used here the fact that &lt;code&gt;select&lt;/code&gt; expression is a Kotlin DSL, so we can provide clauses for it using an arbitrary code. In this case we iterate over a list of deferred values to provide &lt;code&gt;onAwait&lt;/code&gt; clause for each deferred value.</source>
          <target state="translated">Теперь функция main ожидает завершения первого из них и подсчитывает количество отложенных значений, которые все еще активны. Обратите внимание, что мы использовали здесь тот факт, что выражение &lt;code&gt;select&lt;/code&gt; является Kotlin DSL, поэтому мы можем предоставить для него предложения, используя произвольный код. В этом случае мы перебираем список отложенных значений, чтобы предоставить предложение &lt;code&gt;onAwait&lt;/code&gt; для каждого отложенного значения.</target>
        </trans-unit>
        <trans-unit id="fafa6b7e1e97bd8d0310f07c3ffc916e9bc52c4e" translate="yes" xml:space="preserve">
          <source>Now the result is still the same, but the code of the main coroutine is not tied to the duration of the background job in any way. Much better.</source>
          <target state="translated">Теперь результат остается прежним,но код основной корутины никак не привязан к длительности фонового задания.Намного лучше.</target>
        </trans-unit>
        <trans-unit id="68e76914b57b2c484d2fcdeac9dacb63ea15843e" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">Теперь мы готовы &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;открыть проект в IntelliJ IDEA&lt;/a&gt; и посмотреть, как исправить пример проекта. При этом мы рассмотрим, как функции C отображаются в объявлениях Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="0cc37329b152a7d48d832f02d3782a3273c9a922" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">Теперь мы готовы &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;открыть проект в IntelliJ IDEA&lt;/a&gt; и посмотреть, как исправить пример проекта. При этом мы рассмотрим, как примитивные типы C отображаются в Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="280651c06a20fde5cc37b475316ca2430a0a1d40" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">Теперь мы готовы &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;открыть проект в IntelliJ IDEA&lt;/a&gt; и посмотреть, как исправить пример проекта. При этом мы рассмотрим, как функции C отображаются в объявлениях Kotlin / Native.</target>
        </trans-unit>
        <trans-unit id="323fc12d5da11d2d2fc025d2cb42257bb510df5c" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20c24d185e4d030be0d0a6f1a94b265b8692d27" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c161d0d7217a9d942a7808aa2fde773f92818a9" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8514872c5f66d71d839c86ef7b8ede3a7f8b037f" translate="yes" xml:space="preserve">
          <source>Now we are ready to compile our &lt;code&gt;main.c&lt;/code&gt; into an executable. We include the generated &lt;code&gt;libnative.lib&lt;/code&gt; into the build command and start:</source>
          <target state="translated">Теперь мы готовы скомпилировать наш &lt;code&gt;main.c&lt;/code&gt; в исполняемый файл. &lt;code&gt;libnative.lib&lt;/code&gt; сгенерированный libnative.lib в команду сборки и запускаем:</target>
        </trans-unit>
        <trans-unit id="bd615a740472938a27e61f3e5ad1d8c088398a62" translate="yes" xml:space="preserve">
          <source>Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, and launching new pipeline stage for each prime number found:</source>
          <target state="translated">Теперь мы строим наш трубопровод,начиная поток номеров с 2,беря первичный номер с текущего канала,и запуская новый этап трубопровода для каждого найденного первичного номера:</target>
        </trans-unit>
        <trans-unit id="b09d5a8ac24e62ac515e5408d015b6449705f5ff" translate="yes" xml:space="preserve">
          <source>Now we have implementations on all the platforms and it is time to move to testing of our library.</source>
          <target state="translated">Теперь у нас есть реализации на всех платформах,и пора переходить к тестированию нашей библиотеки.</target>
        </trans-unit>
        <trans-unit id="6fc43d604b99f2dfefc014ae5ff71405690d454a" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">Теперь мы узнали, как использовать объявления C в нашем коде, мы готовы опробовать это на реальном примере. Давайте исправим наш код и посмотрим, как он работает, вызвав задачу &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;в среде IDE&lt;/a&gt; или используя следующую консольную команду:</target>
        </trans-unit>
        <trans-unit id="50d459965bcc6d81fd4d90553a544db8ca2bdb40" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdaca8bf7117a3b069ebd97d9d500bbee893084" translate="yes" xml:space="preserve">
          <source>Now we have our library and Kotlin stubs, we can consume them from our application. To keep things simple, in this tutorial we're going to convert one of the simplest &lt;code&gt;libcurl&lt;/code&gt; examples over to Kotlin.</source>
          <target state="translated">Теперь у нас есть библиотека и заглушки Kotlin, мы можем использовать их из нашего приложения. Для простоты в этом уроке мы собираемся преобразовать один из простейших примеров &lt;code&gt;libcurl&lt;/code&gt; в Kotlin.</target>
        </trans-unit>
        <trans-unit id="56a410308bdaa182b925a6dff7fc3ba66711f037" translate="yes" xml:space="preserve">
          <source>Now we have the &lt;code&gt;TextView&lt;/code&gt; that will show us the text created by the shared code function &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt;. It shows &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt;. Let's see how it works.</source>
          <target state="translated">Теперь у нас есть &lt;code&gt;TextView&lt;/code&gt; , который покажет нам текст, созданный функцией общего кода &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt; . Он показывает &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; . Посмотрим, как это работает.</target>
        </trans-unit>
        <trans-unit id="ff70a609caee6a29932d7e21240cf4b92c28370c" translate="yes" xml:space="preserve">
          <source>Now we need to define the classes and interfaces we want to implement. Create the file &lt;code&gt;Base64.kt&lt;/code&gt; in the &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; folder. Core primitive will be the &lt;code&gt;Base64Encoder&lt;/code&gt; interface which knows how to convert bytes to bytes in &lt;code&gt;Base64&lt;/code&gt; format:</source>
          <target state="translated">Теперь нам нужно определить классы и интерфейсы, которые мы хотим реализовать. Создайте файл &lt;code&gt;Base64.kt&lt;/code&gt; в &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; . &lt;code&gt;Base64Encoder&lt;/code&gt; примитивом будет интерфейс Base64Encoder, который знает, как конвертировать байты в байты в формате &lt;code&gt;Base64&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ca6511b451c4bb08b2161576b6d00b309bd636f" translate="yes" xml:space="preserve">
          <source>Now we need to explain to Xcode, where to look for frameworks. We need to add the &lt;em&gt;relative&lt;/em&gt; path &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; into the &lt;em&gt;Search Paths | Framework Search Paths&lt;/em&gt; section. Open the &lt;em&gt;Build Settings&lt;/em&gt; tab again, pick the &lt;em&gt;All&lt;/em&gt; sub-tab below, and type the &lt;em&gt;Framework Search Paths&lt;/em&gt; into the search field to easily find the option. Xcode will then show the substituted path in the UI for it.</source>
          <target state="translated">Теперь нам нужно объяснить Xcode, где искать фреймворки. Нам нужно добавить &lt;em&gt;относительный&lt;/em&gt; путь &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; в &lt;em&gt;Search Paths | &lt;/em&gt;Раздел &quot; &lt;em&gt;Пути поиска фреймворка&quot;&lt;/em&gt; . Откройте &lt;em&gt;Параметры построения&lt;/em&gt; вкладки еще раз, выберите &lt;em&gt;All&lt;/em&gt; подвкладку ниже и введите &lt;em&gt;Framework Путь поиска&lt;/em&gt; в поле поиска , чтобы легко найти вариант. Затем Xcode покажет для него замененный путь в пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="bbdba5d4735168e3785e68f7843040b781bf6309" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;workload()&lt;/code&gt; from a coroutine, the compiler knows that it may suspend and will prepare accordingly:</source>
          <target state="translated">Теперь, когда мы вызываем &lt;code&gt;workload()&lt;/code&gt; из сопрограммы, компилятор знает, что он может приостановиться, и подготовится соответствующим образом:</target>
        </trans-unit>
        <trans-unit id="1d24cd9e38cbefb079dd50a49d7d7f03311c7bf3" translate="yes" xml:space="preserve">
          <source>Now you are ready to create a new Kotlin project.</source>
          <target state="translated">Теперь вы готовы создать новый проект Kotlin.</target>
        </trans-unit>
        <trans-unit id="290dbe288d985515eeabffa880759f9b6702dbd0" translate="yes" xml:space="preserve">
          <source>Now you can declare a dependency on a Kotlin/Native library in the traditional &lt;code&gt;group:artifact:version&lt;/code&gt; notation:</source>
          <target state="translated">Теперь вы можете объявить зависимость от библиотеки Kotlin / Native в традиционной нотации &lt;code&gt;group:artifact:version&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21f7ffde9424834101062b3a3b4388e5becd0386" translate="yes" xml:space="preserve">
          <source>Now you can publish the artifacts with the standard Gradle &lt;code&gt;publish&lt;/code&gt; task:</source>
          <target state="translated">Теперь вы можете опубликовать артефакты с помощью стандартной задачи &lt;code&gt;publish&lt;/code&gt; Gradle :</target>
        </trans-unit>
        <trans-unit id="1f0e0a97af9c78bc7052cbc7558b0c5721564a3e" translate="yes" xml:space="preserve">
          <source>Now you can use this class from JavaScript in the following way:</source>
          <target state="translated">Теперь вы можете использовать этот класс из JavaScript следующим образом:</target>
        </trans-unit>
        <trans-unit id="d5043215278e17616ae1356fe9712ab2361ec4d2" translate="yes" xml:space="preserve">
          <source>Now you have the new project created with the following folder structure:</source>
          <target state="translated">Теперь новый проект создан со следующей структурой папок:</target>
        </trans-unit>
        <trans-unit id="3e24bac49840414b90995c5cbd33ee7b86539a1d" translate="yes" xml:space="preserve">
          <source>Now you're ready to start learning. Read the first task description and the exercise code. You will find a placeholder in the exercise code which you need to complete to solve the task:</source>
          <target state="translated">Теперь ты готов начать учиться.Прочитайте первое описание задания и код упражнения.В коде упражнения вы найдете место,которое необходимо заполнить для решения задания:</target>
        </trans-unit>
        <trans-unit id="5cb44051b734fae4af55ffe5224978dec7c87251" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;callStatic()&lt;/code&gt; is static in Java, while &lt;code&gt;callNonStatic()&lt;/code&gt; is not:</source>
          <target state="translated">Теперь &lt;code&gt;callStatic()&lt;/code&gt; статичен в Java, а &lt;code&gt;callNonStatic()&lt;/code&gt; нет:</target>
        </trans-unit>
        <trans-unit id="a13d0fb128d24db7d3bb5f2f36926ba1c128f4f2" translate="yes" xml:space="preserve">
          <source>Now, &lt;em&gt;this&lt;/em&gt; can be omitted, as usual, and we get something that looks very much like a builder already:</source>
          <target state="translated">Теперь, как обычно , &lt;em&gt;это&lt;/em&gt; можно опустить, и мы получим что-то, что уже очень похоже на конструктор:</target>
        </trans-unit>
        <trans-unit id="f0a82c0a40d22072db820930c190224b73ea978f" translate="yes" xml:space="preserve">
          <source>Now, all is left is to write the main function that reads the input and implements the rest of the algorithm that the problem statement asks for &amp;mdash; to compute the number of different integers that are produced while repeatedly applying function &lt;code&gt;f&lt;/code&gt; to the initial number &lt;code&gt;n&lt;/code&gt; that is given in the standard input.</source>
          <target state="translated">Теперь осталось написать основную функцию, которая считывает входные данные и реализует остальную часть алгоритма, о котором требует постановление задачи, - для вычисления количества различных целых чисел, которые производятся при многократном применении функции &lt;code&gt;f&lt;/code&gt; к начальному числу &lt;code&gt;n&lt;/code&gt; , которое дается в стандартном вводе.</target>
        </trans-unit>
        <trans-unit id="fb6047e18f4bc8d11bc30e4fd65fb8d503da1662" translate="yes" xml:space="preserve">
          <source>Now, if you call a method or access a property on &lt;code&gt;a&lt;/code&gt;, it's guaranteed not to cause an NPE, so you can safely say:</source>
          <target state="translated">Теперь, если вы вызываете метод или получаете доступ к свойству в &lt;code&gt;a&lt;/code&gt; , это гарантированно не вызовет NPE, поэтому вы можете смело сказать:</target>
        </trans-unit>
        <trans-unit id="20f3d5cd33eec60a8a8002b141a9b28a6b9b7682" translate="yes" xml:space="preserve">
          <source>Now, if you do:</source>
          <target state="translated">Теперь,если ты это сделаешь:</target>
        </trans-unit>
        <trans-unit id="f71ccd18f05da02b03c8a2c32b3e5cdf31e2366b" translate="yes" xml:space="preserve">
          <source>Now, if you open DevTools, you should see both JavaScript and Kotlin files in Sources tab, as shown in the picture below.</source>
          <target state="translated">Теперь,если вы откроете DevTools,вы должны увидеть и JavaScript и Kotlin файлы на вкладке Sources,как показано на рисунке ниже.</target>
        </trans-unit>
        <trans-unit id="a83d9e77f9456d18d8a05fd327f1e236de7060bd" translate="yes" xml:space="preserve">
          <source>Now, if you rebuild the project, you should see both &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.js.map&lt;/code&gt; files generated.</source>
          <target state="translated">Теперь, если вы перестроите проект, вы должны увидеть &lt;code&gt;.js.map&lt;/code&gt; файлы &lt;code&gt;.js&lt;/code&gt; и .js.map .</target>
        </trans-unit>
        <trans-unit id="76f6cc5aafdabd68e55d4250b74b32cd977c308a" translate="yes" xml:space="preserve">
          <source>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use implicit labels: such a label has the same name as the function to which the lambda is passed.</source>
          <target state="translated">Теперь он возвращается только с лямбда-выражения.Часто удобнее использовать неявные метки:такая метка имеет то же название,что и функция,которой передается лямбда.</target>
        </trans-unit>
        <trans-unit id="94f815aeffcc5ac17241b513b6e20a9f1cdaea31" translate="yes" xml:space="preserve">
          <source>Now, let us see what happens if we launch a couple of coroutines sending strings (in this example we launch them in the context of the main thread as main coroutine's children):</source>
          <target state="translated">Теперь посмотрим,что произойдет,если мы запустим пару корутингов,посылающих строки (в данном примере мы запустим их в контексте главного потока в качестве дочерних элементов главного корутина):</target>
        </trans-unit>
        <trans-unit id="71d025254fd20926043d356611276f9c88403338" translate="yes" xml:space="preserve">
          <source>Now, let's make sure that coroutines are really cheaper than threads. How about starting a million of them? Let's try starting a million threads first:</source>
          <target state="translated">Теперь давайте убедимся,что корудины действительно дешевле,чем нитки.Как насчет того,чтобы начать миллион из них? Давай сначала попробуем начать миллион нитей:</target>
        </trans-unit>
        <trans-unit id="16dd7a2ec4c182b0f69f31fe9543eb28189fc230" translate="yes" xml:space="preserve">
          <source>Now, let's recall why we can say something like this in the code:</source>
          <target state="translated">Теперь давайте вспомним,почему мы можем сказать что-то подобное в коде:</target>
        </trans-unit>
        <trans-unit id="544d487017d11ee4001cb80b112987fd1c122959" translate="yes" xml:space="preserve">
          <source>Now, let's say we want to extract our &lt;em&gt;workload&lt;/em&gt; (which is &quot;wait 1 second and return a number&quot;) into a separate function:</source>
          <target state="translated">Теперь предположим, что мы хотим извлечь нашу &lt;em&gt;рабочую нагрузку&lt;/em&gt; (то есть &amp;laquo;подождать 1 секунду и вернуть число&amp;raquo;) в отдельную функцию:</target>
        </trans-unit>
        <trans-unit id="c750281f584acadba2af58cffcc8c1305b106c0d" translate="yes" xml:space="preserve">
          <source>Now, the type parameter of &lt;code&gt;to&lt;/code&gt; must be a supertype of that of &lt;code&gt;from&lt;/code&gt;. This time, we're losing the ability to call &lt;code&gt;get()&lt;/code&gt; on &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">Теперь параметр типа &lt;code&gt;to&lt;/code&gt; должен быть супертипом &lt;code&gt;from&lt;/code&gt; . На этот раз, мы теряем возможность вызова &lt;code&gt;get()&lt;/code&gt; на &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66aa36fc01590becc140967b82e52fb54836cefb" translate="yes" xml:space="preserve">
          <source>Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43de32521253364ea5d09558750dd9502168f58f" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; using the defined &lt;code&gt;scope&lt;/code&gt;. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841ea7e84248eb13447bb49e5c5c6dbc24123f33" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; without having to explicitly specify their context. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">Теперь мы можем запускать сопрограммы в рамках этого &lt;code&gt;Activity&lt;/code&gt; без явного указания их контекста. Для демонстрации мы запускаем десять сопрограмм, которые задерживаются на разное время:</target>
        </trans-unit>
        <trans-unit id="b7b794f9844126d9635b31ec7a7259faff61ea34" translate="yes" xml:space="preserve">
          <source>Now, we can qualify a &lt;em&gt;break&lt;/em&gt; or a &lt;em&gt;continue&lt;/em&gt; with a label:</source>
          <target state="translated">Теперь мы можем квалифицировать &lt;em&gt;перерыв&lt;/em&gt; или &lt;em&gt;продолжение&lt;/em&gt; с помощью метки:</target>
        </trans-unit>
        <trans-unit id="4009ace22d0b31f5461708301ff321a7b41e34f1" translate="yes" xml:space="preserve">
          <source>Now, we need to create the implementation file (and missing directories) for Android in the &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">Теперь нам нужно создать файл реализации (и отсутствующие каталоги) для Android в &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc32792e1ffb6994d09d3ccc5850fcde297ab5b1" translate="yes" xml:space="preserve">
          <source>Now, whenever anyone reads &lt;code&gt;p.name&lt;/code&gt;, &lt;code&gt;getValue()&lt;/code&gt; will be invoked with &lt;code&gt;p&lt;/code&gt; as &lt;code&gt;thisRef&lt;/code&gt; and metadata about the &lt;code&gt;name&lt;/code&gt; property as &lt;code&gt;property&lt;/code&gt;. Since &lt;code&gt;thisRef&lt;/code&gt; is a &lt;code&gt;DbModel&lt;/code&gt;, this delegated property can only be used inside &lt;code&gt;DbModel&lt;/code&gt; and its subclasses.</source>
          <target state="translated">Теперь, когда кто-либо читает &lt;code&gt;p.name&lt;/code&gt; , &lt;code&gt;getValue()&lt;/code&gt; будет вызываться с &lt;code&gt;p&lt;/code&gt; в качестве &lt;code&gt;thisRef&lt;/code&gt; и метаданными о свойстве &lt;code&gt;name&lt;/code&gt; в качестве &lt;code&gt;property&lt;/code&gt; . Поскольку &lt;code&gt;thisRef&lt;/code&gt; является &lt;code&gt;DbModel&lt;/code&gt; , это делегированное свойство можно использовать только внутри &lt;code&gt;DbModel&lt;/code&gt; и его подклассов.</target>
        </trans-unit>
        <trans-unit id="1ddfae4b18596b2854071f83733087767ffb2d01" translate="yes" xml:space="preserve">
          <source>Now, you can do:</source>
          <target state="translated">Теперь ты можешь:</target>
        </trans-unit>
        <trans-unit id="c62d757ce7f75d3f121e4c4fec1867b7958bd009" translate="yes" xml:space="preserve">
          <source>Now, you can no longer say &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt;.</source>
          <target state="translated">Теперь вы больше не можете сказать &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c97d282b328adc12f3e5a556471451c0554c8b2" translate="yes" xml:space="preserve">
          <source>Now, you can say &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; to load an object from the &lt;code&gt;Exercise&lt;/code&gt; database table.</source>
          <target state="translated">Теперь вы можете сказать &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; чтобы загрузить объект из таблицы базы данных &lt;code&gt;Exercise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93baa80c955acf188a4912f62d9bfabe1e89cde4" translate="yes" xml:space="preserve">
          <source>Now, you can treat a bowl of &lt;code&gt;T&lt;/code&gt; as a producer of any superclass of &lt;code&gt;T&lt;/code&gt;, and as a consumer of any subclass of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Теперь вы можете рассматривать чашу &lt;code&gt;T&lt;/code&gt; как производителя любого суперкласса &lt;code&gt;T&lt;/code&gt; и как потребителя любого подкласса &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb06774e37de315de0f5603f0b4fd0176b0b42a0" translate="yes" xml:space="preserve">
          <source>Now, you may not create a &lt;code&gt;TreeNode&lt;/code&gt; of a type that is not a subclass/implementor of &lt;code&gt;Vehicle&lt;/code&gt;. Inside the class, whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;, you may access all the public members of &lt;code&gt;Vehicle&lt;/code&gt; on it.</source>
          <target state="translated">Теперь вы не можете создавать &lt;code&gt;TreeNode&lt;/code&gt; типа, который не является подклассом / разработчиком &lt;code&gt;Vehicle&lt;/code&gt; . Внутри класса, когда у вас есть значение типа &lt;code&gt;T&lt;/code&gt; , вы можете получить доступ ко всем открытым членам класса &lt;code&gt;Vehicle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e66b62de2c45ca7a1dafaa470efed27db40c8abf" translate="yes" xml:space="preserve">
          <source>Null Safety</source>
          <target state="translated">Безопасность корпуса</target>
        </trans-unit>
        <trans-unit id="961437d22902a2f7dfd53365cc313f4a8b919ec9" translate="yes" xml:space="preserve">
          <source>Null references are &lt;a href=&quot;null-safety&quot;&gt;controlled by the type system&lt;/a&gt;.</source>
          <target state="translated">Нулевые ссылки &lt;a href=&quot;null-safety&quot;&gt;контролируются системой типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b2542f64eaa222fbfda6a1a4f6d0850cf59a88" translate="yes" xml:space="preserve">
          <source>Null safety</source>
          <target state="translated">Безопасность корпуса</target>
        </trans-unit>
        <trans-unit id="39f94d225bc04bec959b32c61b7c0b099f1b3de4" translate="yes" xml:space="preserve">
          <source>Null safety is enforced as usual, so a variable of type &lt;code&gt;ContentKind&lt;/code&gt; can not be null, unlike in Java.</source>
          <target state="translated">Безопасность NULL обеспечивается как обычно, поэтому переменная типа &lt;code&gt;ContentKind&lt;/code&gt; не может иметь значение NULL, в отличие от Java.</target>
        </trans-unit>
        <trans-unit id="c768f27b8cd368aac53b3bf7b3466119f4aeaaad" translate="yes" xml:space="preserve">
          <source>Null-Safety and Platform Types</source>
          <target state="translated">Null-Safety и типы платформ</target>
        </trans-unit>
        <trans-unit id="7b2e605360643dd896eff359d1535b4e4db34c3d" translate="yes" xml:space="preserve">
          <source>Null-safety</source>
          <target state="translated">Null-safety</target>
        </trans-unit>
        <trans-unit id="e96a81e5fc6aa1615fc78a379fdad68b748bc26c" translate="yes" xml:space="preserve">
          <source>NullPointerException</source>
          <target state="translated">NullPointerException</target>
        </trans-unit>
        <trans-unit id="7cfd44db910fd8b20253bc74265b31aeaf45384c" translate="yes" xml:space="preserve">
          <source>Nullability</source>
          <target state="translated">Nullability</target>
        </trans-unit>
        <trans-unit id="13c99d5e49300b52aefe21f12764921df1d1f93f" translate="yes" xml:space="preserve">
          <source>Nullability annotations</source>
          <target state="translated">Аннотации по поводу непригодности к использованию</target>
        </trans-unit>
        <trans-unit id="e5e6784edcd14305d294e06ecb03d642a0a57873" translate="yes" xml:space="preserve">
          <source>Nullability assertions on access to Java types annotated with &lt;code&gt;@NotNull&lt;/code&gt;</source>
          <target state="translated">Утверждения об отсутствии значения при доступе к типам Java, аннотированным с помощью &lt;code&gt;@NotNull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e5389deab4b42bc503c62cbba549bbb26b00be1" translate="yes" xml:space="preserve">
          <source>Nullable Receiver</source>
          <target state="translated">Мощный приемник</target>
        </trans-unit>
        <trans-unit id="29ff5a1131fe0933e804809fec54eb9e91bf1512" translate="yes" xml:space="preserve">
          <source>Nullable receiver</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea692fde5fad8fec43d27ab3923928d9c3e4f762" translate="yes" xml:space="preserve">
          <source>Nullable types and Non-Null Types</source>
          <target state="translated">Обтекаемые типы и ненулевые типы</target>
        </trans-unit>
        <trans-unit id="eda4c49c3f8e3f49857bedaeb7bb3c5e705b11d9" translate="yes" xml:space="preserve">
          <source>Nullable values and &lt;em&gt;null&lt;/em&gt; checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="2e1ee95668fd5f69d1925d4acd4d52b859469b82" translate="yes" xml:space="preserve">
          <source>NumberFormatException</source>
          <target state="translated">NumberFormatException</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="b7b3deb2440db7b27508e61ad6b6526ba91d78a1" translate="yes" xml:space="preserve">
          <source>Numbers are compared with the ends of this range according to IEEE-754.</source>
          <target state="translated">Цифры сравниваются с концом этого диапазона в соответствии с IEEE-754.</target>
        </trans-unit>
        <trans-unit id="b1c2afbaeee52797fa3a437d9c480e4a05cf0193" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, an so on.</source>
          <target state="translated">Числовые типы используют традиционный числовой порядок: &lt;code&gt;1&lt;/code&gt; больше &lt;code&gt;0&lt;/code&gt; ; &lt;code&gt;-3.4f&lt;/code&gt; больше &lt;code&gt;-5f&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="aadf9b6283ac66e1e51fce7a8cfe42781b4ea431" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132a0e722f57154d901e124e4cb8e8bc570f7174" translate="yes" xml:space="preserve">
          <source>Numerous use cases are covered by just the default source sets and don't require custom source sets.</source>
          <target state="translated">Многочисленные случаи использования покрываются только исходными наборами по умолчанию и не требуют пользовательских исходных наборов.</target>
        </trans-unit>
        <trans-unit id="f5bd86a2929ff840c45d76159d984c1239906a9d" translate="yes" xml:space="preserve">
          <source>OSGi</source>
          <target state="translated">OSGi</target>
        </trans-unit>
        <trans-unit id="802bfbdcec1e0873ee0e4b3f43f68d3022244543" translate="yes" xml:space="preserve">
          <source>OTHER_LETTER</source>
          <target state="translated">OTHER_LETTER</target>
        </trans-unit>
        <trans-unit id="c526c1a55d3a7d1197fc54064f8aa775a085df54" translate="yes" xml:space="preserve">
          <source>OTHER_NEUTRALS</source>
          <target state="translated">OTHER_NEUTRALS</target>
        </trans-unit>
        <trans-unit id="0528be3a553ee55304545e3df532c16619f9a75f" translate="yes" xml:space="preserve">
          <source>OTHER_NUMBER</source>
          <target state="translated">OTHER_NUMBER</target>
        </trans-unit>
        <trans-unit id="a79f18b5ad7c3bc6ad0e1685c0b9f1d91e9ea75c" translate="yes" xml:space="preserve">
          <source>OTHER_PUNCTUATION</source>
          <target state="translated">OTHER_PUNCTUATION</target>
        </trans-unit>
        <trans-unit id="5dcd7535199ae15a813d866ef04e762cfaa07f6c" translate="yes" xml:space="preserve">
          <source>OTHER_SYMBOL</source>
          <target state="translated">OTHER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="5d84eb9e92dc661a577d3adfba33f1d74c56b13f" translate="yes" xml:space="preserve">
          <source>OUT</source>
          <target state="translated">OUT</target>
        </trans-unit>
        <trans-unit id="91920f1b8433472c27ea07aeaf636cc60ba181dc" translate="yes" xml:space="preserve">
          <source>ObjCAction</source>
          <target state="translated">ObjCAction</target>
        </trans-unit>
        <trans-unit id="e75d1b861d64404390b1044e805e449a8200ca83" translate="yes" xml:space="preserve">
          <source>ObjCBlockVar</source>
          <target state="translated">ObjCBlockVar</target>
        </trans-unit>
        <trans-unit id="e9af1c5fc6d5face32a12e24e19f7721bddde5b0" translate="yes" xml:space="preserve">
          <source>ObjCClass</source>
          <target state="translated">ObjCClass</target>
        </trans-unit>
        <trans-unit id="f25e8c7f51c9fbd76d5d3f0065c1777ea9957679" translate="yes" xml:space="preserve">
          <source>ObjCClassOf</source>
          <target state="translated">ObjCClassOf</target>
        </trans-unit>
        <trans-unit id="f6a51cb987439b8eee022689cce7766c56796d55" translate="yes" xml:space="preserve">
          <source>ObjCConstructor</source>
          <target state="translated">ObjCConstructor</target>
        </trans-unit>
        <trans-unit id="174b16a8130fefe11ed27381abeeb2de5f620114" translate="yes" xml:space="preserve">
          <source>ObjCFactory</source>
          <target state="translated">ObjCFactory</target>
        </trans-unit>
        <trans-unit id="b26295bcadcc4d23542076fe5cb26969093b0b48" translate="yes" xml:space="preserve">
          <source>ObjCMethod</source>
          <target state="translated">ObjCMethod</target>
        </trans-unit>
        <trans-unit id="07d9267ddaf9a5ade080cb2ba3e61a2c1db5834c" translate="yes" xml:space="preserve">
          <source>ObjCNotImplementedVar</source>
          <target state="translated">ObjCNotImplementedVar</target>
        </trans-unit>
        <trans-unit id="88fce822e198e83b3ad7f5c732a4ec9995f176b3" translate="yes" xml:space="preserve">
          <source>ObjCObject</source>
          <target state="translated">ObjCObject</target>
        </trans-unit>
        <trans-unit id="c3946e9e7a5b7a873393f4068d626ccc17017e1d" translate="yes" xml:space="preserve">
          <source>ObjCObjectBase</source>
          <target state="translated">ObjCObjectBase</target>
        </trans-unit>
        <trans-unit id="f2b935ffe4e074cda5d9854c568bff792bd27525" translate="yes" xml:space="preserve">
          <source>ObjCObjectBaseMeta</source>
          <target state="translated">ObjCObjectBaseMeta</target>
        </trans-unit>
        <trans-unit id="968b48c24c631a6e3656fa344166e2e696dac30a" translate="yes" xml:space="preserve">
          <source>ObjCObjectMeta</source>
          <target state="translated">ObjCObjectMeta</target>
        </trans-unit>
        <trans-unit id="877c2fba97f85ebcbe0815d3dd7f9aa9abf27eb2" translate="yes" xml:space="preserve">
          <source>ObjCObjectVar</source>
          <target state="translated">ObjCObjectVar</target>
        </trans-unit>
        <trans-unit id="380d9e7d32a5ea9a8f4a45d77367a2bd6224641f" translate="yes" xml:space="preserve">
          <source>ObjCOutlet</source>
          <target state="translated">ObjCOutlet</target>
        </trans-unit>
        <trans-unit id="6ad1a2f860c17b61aedf856b4ee3682acdaa8417" translate="yes" xml:space="preserve">
          <source>ObjCProtocol</source>
          <target state="translated">ObjCProtocol</target>
        </trans-unit>
        <trans-unit id="7ddeec08c37b0e1684597f07f64a856e9d5996d5" translate="yes" xml:space="preserve">
          <source>ObjCStringVarOf</source>
          <target state="translated">ObjCStringVarOf</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">Объектные декларации</target>
        </trans-unit>
        <trans-unit id="7c97f9bd791112ffa2e31c34e5efe261bd493bd5" translate="yes" xml:space="preserve">
          <source>Object Expressions and Declarations</source>
          <target state="translated">Выражения объектов и декларации</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">Методы объекта</target>
        </trans-unit>
        <trans-unit id="da5029a017fab6364fe3776821fcb6e385dc5dee" translate="yes" xml:space="preserve">
          <source>Object Transfer Basics.</source>
          <target state="translated">Основы переноса объектов.</target>
        </trans-unit>
        <trans-unit id="720b937cd9168a2afdad295cde0f6e29e57ba3f8" translate="yes" xml:space="preserve">
          <source>Object configuration and computing the result: &lt;code&gt;run&lt;/code&gt;</source>
          <target state="translated">Конфигурация объекта и вычисление результата: &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1602dbe04f927f110613a2ff025fac15d0ab85e1" translate="yes" xml:space="preserve">
          <source>Object configuration: &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">Конфигурация объекта: &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d1d8d22ba8224cd8039f6fb03638fcc7cc89d7" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe and done at first access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a447624065dc9ff0a50d2837d5bc597740342d7d" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe.</source>
          <target state="translated">Инициализация объявления объекта является потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="628c7c8804cdd6233ca4db93a682c55cf0920e38" translate="yes" xml:space="preserve">
          <source>Object declarations</source>
          <target state="translated">Заявления об объектах</target>
        </trans-unit>
        <trans-unit id="cae8f3bd29605b55880171db0511493e6eb7c132" translate="yes" xml:space="preserve">
          <source>Object describing the current platform program executes upon.</source>
          <target state="translated">Объект,описывающий выполнение текущей программы платформы.</target>
        </trans-unit>
        <trans-unit id="652916453e90e519555e6ab21189e4862e16ddc5" translate="yes" xml:space="preserve">
          <source>Object expressions</source>
          <target state="translated">Выражения объектов</target>
        </trans-unit>
        <trans-unit id="a5005a7247de5e6b7399fc2c0fe58f85332088cd" translate="yes" xml:space="preserve">
          <source>Object pinning</source>
          <target state="translated">Штифтовое соединение объектов</target>
        </trans-unit>
        <trans-unit id="bd34180a1517f8541977dbe1575129ec09ee4ed0" translate="yes" xml:space="preserve">
          <source>Object reference</source>
          <target state="translated">Ссылка на объект</target>
        </trans-unit>
        <trans-unit id="c74457d6502afea678cde0191acb0c28174b3019" translate="yes" xml:space="preserve">
          <source>Object subgraph detachment</source>
          <target state="translated">Отделение субграфа объекта</target>
        </trans-unit>
        <trans-unit id="9e612181ece96085e9c01a6c4c75420948e3db15" translate="yes" xml:space="preserve">
          <source>Object subgraph freezing</source>
          <target state="translated">Замораживание субграфа объекта</target>
        </trans-unit>
        <trans-unit id="f714255fe9b4b0abd289766d10b307beefd8bdca" translate="yes" xml:space="preserve">
          <source>Object subgraph ownership transfer</source>
          <target state="translated">Передача прав собственности на субграфы объектов</target>
        </trans-unit>
        <trans-unit id="f7e1ff28ab70fc23071798b8c0343f8a27fa8277" translate="yes" xml:space="preserve">
          <source>Object transfer and freezing</source>
          <target state="translated">Передача и замораживание объекта</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="f624b8a4ac060c545ced78fe5b569d299005d811" translate="yes" xml:space="preserve">
          <source>Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</source>
          <target state="translated">Задача-С позволяет объявить дженерики ковариантными или контрвариантными.Swift не поддерживает дисперсию.Генерические классы,получаемые из Объектива-С,могут быть принудительно литыми по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="c34ace6f5a2b6e2147c689be6867500eabe88ca9" translate="yes" xml:space="preserve">
          <source>Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too. Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting. We do not need to use anything special to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</source>
          <target state="translated">Объект-С и Свифт используют подсчет ссылок.У Kotlin/Native тоже есть свой собственный сбор мусора.Уборка мусора Kotlin/Native интегрирована с функцией подсчета ссылок Objective-C/Swift.Нам не нужно использовать ничего особенного для контроля срока службы экземпляров Kotlin/Native от Swift или Objective-C.</target>
        </trans-unit>
        <trans-unit id="81b529433016c0d2c2b79263ff487c0612e2136f" translate="yes" xml:space="preserve">
          <source>Objective-C classes and protocols</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d9bdb0193a26ed15d57450ee6f73bec2393ce7" translate="yes" xml:space="preserve">
          <source>Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with &lt;code&gt;Protocol&lt;/code&gt; name suffix, i.e. &lt;code&gt;@protocol Foo&lt;/code&gt; -&amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt;. These classes and interfaces are placed into a package &lt;a href=&quot;#usage&quot;&gt;specified in build configuration&lt;/a&gt; (&lt;code&gt;platform.*&lt;/code&gt; packages for preconfigured system frameworks).</source>
          <target state="translated">Классы Objective-C импортируются в Kotlin с их исходными именами. Протоколы импортируются как интерфейсы с суффиксом имени &lt;code&gt;Protocol&lt;/code&gt; , например &lt;code&gt;@protocol Foo&lt;/code&gt; -&amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt; . Эти классы и интерфейсы помещаются в пакет, &lt;a href=&quot;#usage&quot;&gt;указанный в конфигурации сборки&lt;/a&gt; ( пакеты &lt;code&gt;platform.*&lt;/code&gt; Для предварительно сконфигурированных системных фреймворков).</target>
        </trans-unit>
        <trans-unit id="e28ecca8c4c63098937f693b564f06106597a69f" translate="yes" xml:space="preserve">
          <source>Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</source>
          <target state="translated">Генерики Objective-C не поддерживают все возможности ни Kotlin,ни Swift,поэтому при переводе будет потеряна некоторая информация.</target>
        </trans-unit>
        <trans-unit id="edc50c4e6d2116d2eefbad12ba8e08e873a18c54" translate="yes" xml:space="preserve">
          <source>Objective-C supports &quot;lightweight generics&quot; defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</source>
          <target state="translated">Objective-C поддерживает &quot;легкие дженерики&quot;,определенные на классах,с относительно ограниченным набором функций.Swift может импортировать дженерики,определенные по классам,чтобы предоставить компилятору дополнительную информацию о типах.</target>
        </trans-unit>
        <trans-unit id="872324a80a8df1d396c94677f04ea994d1ae3329" translate="yes" xml:space="preserve">
          <source>Objects and companion objects</source>
          <target state="translated">Предметы и сопутствующие предметы</target>
        </trans-unit>
        <trans-unit id="baa64e9ea92fa8d9f0990d9b1a5bc22ee025b445" translate="yes" xml:space="preserve">
          <source>Objects can be passed between threads in one of two possible modes.</source>
          <target state="translated">Объекты могут передаваться между потоками в одном из двух возможных режимов.</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="53d6bf00994a7a961b92ecd0048f0ecd77a13ddf" translate="yes" xml:space="preserve">
          <source>ObservableProperty</source>
          <target state="translated">ObservableProperty</target>
        </trans-unit>
        <trans-unit id="1145800f1de30eba6d1df3a4fd2cc70c1f07f939" translate="yes" xml:space="preserve">
          <source>Obtain the Kotlin/Native compiler</source>
          <target state="translated">Получите компилятор Kotlin/Native.</target>
        </trans-unit>
        <trans-unit id="cdf71ecbbe212f441c04603a28909072a535e232" translate="yes" xml:space="preserve">
          <source>Obtaining member references from a class reference</source>
          <target state="translated">Получение ссылок на членов из ссылки на класс</target>
        </trans-unit>
        <trans-unit id="df8298dcee7334200280003820f9875dbf3c187b" translate="yes" xml:space="preserve">
          <source>Obtaining the Compiler</source>
          <target state="translated">Получение компилятора</target>
        </trans-unit>
        <trans-unit id="b10db2a36e46741d4da85b74ece4b6f72fb9bfd8" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;KClass&lt;/code&gt; instance for the given constructor reference.</source>
          <target state="translated">Получает экземпляр &lt;code&gt;KClass&lt;/code&gt; для данной ссылки конструктора.</target>
        </trans-unit>
        <trans-unit id="9910159f8fee624aa4548124f031d4745a86c889" translate="yes" xml:space="preserve">
          <source>Obtains a constructor reference for the given &lt;code&gt;KClass&lt;/code&gt;.</source>
          <target state="translated">Получает ссылку на конструктор для данного &lt;code&gt;KClass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0219b4a8ea1da937bc70be9c1ab95184f21fc8c4" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and either suspends currently running coroutine or returns result immediately without suspension.</source>
          <target state="translated">Получает текущий экземпляр продолжения внутри функций приостановки и либо приостанавливает текущую работу корутины,либо немедленно возвращает результат без приостановки.</target>
        </trans-unit>
        <trans-unit id="646fc575bcb6c35847d73d3b2dd2cc5db56f01df" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends currently running coroutine.</source>
          <target state="translated">Получает текущий экземпляр продолжения внутри функций приостановки и приостанавливает текущую работу корутины.</target>
        </trans-unit>
        <trans-unit id="dedd1425a40b177d169a6eb17080f5f8210d2fe7" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine.</source>
          <target state="translated">Получает текущий экземпляр продолжения внутри функций приостановки и приостанавливает текущую выполняющуюся коруэтину.</target>
        </trans-unit>
        <trans-unit id="0e481b647fccdeaa073311d1f3e53a76a5713079" translate="yes" xml:space="preserve">
          <source>Of course, there are use cases, where we need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A &lt;code&gt;NativePlacement&lt;/code&gt; will be needed here.</source>
          <target state="translated">Конечно, есть варианты использования, когда нам нужно передать структуру в качестве значения одному вызову, а затем передать ту же структуру в качестве ссылки на другой вызов. Это возможно и в Kotlin / Native. Здесь &lt;code&gt;NativePlacement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31883564163ba418ee2d22f8e75f951da14db61c" translate="yes" xml:space="preserve">
          <source>Of course, this function makes sense for any &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt;, and we can make it generic:</source>
          <target state="translated">Конечно, эта функция имеет смысл для любого &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt; , и мы можем сделать ее универсальной:</target>
        </trans-unit>
        <trans-unit id="a8b4afe53634485a00aaaa6addcb6e74df14c763" translate="yes" xml:space="preserve">
          <source>Of course, this is not a complete list of how you can use Kotlin/JS to your advantage, but merely a selection of cherry-picked cases. We invite you to experiment with combinations of these use cases, and find out what works best for your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fad7001a3bd3884c94e7702bc3df04daa71091" translate="yes" xml:space="preserve">
          <source>Of course, you can use both &lt;code&gt;kotlin-allopen&lt;/code&gt; and &lt;code&gt;kotlin-spring&lt;/code&gt; in the same project.</source>
          <target state="translated">Конечно, вы можете использовать и &lt;code&gt;kotlin-allopen&lt;/code&gt; , и &lt;code&gt;kotlin-spring&lt;/code&gt; в одном проекте.</target>
        </trans-unit>
        <trans-unit id="42c11258f0fc4616029dfe363fc90cedc10dac00" translate="yes" xml:space="preserve">
          <source>Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It is passed to some C function (or written to the struct) as e.g. &lt;code&gt;void*&lt;/code&gt;. However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with &lt;code&gt;StableRef&lt;/code&gt; class.</source>
          <target state="translated">Часто API-интерфейсы C позволяют передавать некоторые пользовательские данные в обратные вызовы. Такие данные обычно предоставляются пользователем при настройке обратного вызова. Он передается некоторой функции C (или записывается в структуру) как, например, &lt;code&gt;void*&lt;/code&gt; . Однако ссылки на объекты Kotlin не могут быть напрямую переданы в C. Поэтому они требуют обертывания перед настройкой обратного вызова, а затем развертывания в самом обратном вызове, чтобы безопасно плавать из Котлина в Котлин через мир C. Такая упаковка возможна с классом &lt;code&gt;StableRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="242f4c07d8050ddde5e50538c080e4ec4486413c" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a Kotlin/Native binary using an interop. It can be done using the &lt;code&gt;target&lt;/code&gt; script block:</source>
          <target state="translated">Часто необходимо указать параметры компоновщика для конкретной цели для двоичного файла Kotlin / Native с помощью взаимодействия. Это можно сделать с помощью &lt;code&gt;target&lt;/code&gt; блока скрипта:</target>
        </trans-unit>
        <trans-unit id="954df0a6263002ad270cb3cbc1c777c4a6fac8a1" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a binary which uses a native library. It can by done using the &lt;code&gt;linkerOpts&lt;/code&gt; property of the binary. See the &lt;a href=&quot;#configuring-binaries&quot;&gt;Configuring binaries&lt;/a&gt; section for details.</source>
          <target state="translated">Часто необходимо указать параметры компоновщика для конкретной цели для двоичного файла, который использует собственную библиотеку. Это можно сделать с &lt;code&gt;linkerOpts&lt;/code&gt; свойства linkerOpts двоичного файла . См. Подробности в разделе &amp;laquo; &lt;a href=&quot;#configuring-binaries&quot;&gt;Настройка двоичных файлов&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="17450dcb9110eb38f3fe2d512c09098b5921aef0" translate="yes" xml:space="preserve">
          <source>Older compilers reject binaries that rely on new features (e.g. a 1.0 compiler rejects binaries that use coroutines).</source>
          <target state="translated">Старые компиляторы отвергают двоичные файлы,которые полагаются на новые возможности (например,компилятор 1.0 отвергает двоичные файлы,использующие coroutines).</target>
        </trans-unit>
        <trans-unit id="622d524446394c09abc4f2559c91821dbd352982" translate="yes" xml:space="preserve">
          <source>Omit semicolons whenever possible.</source>
          <target state="translated">Опустите точку с запятой,когда это возможно.</target>
        </trans-unit>
        <trans-unit id="902eb259efe55ed5caa3e21ba3397c994cd51091" translate="yes" xml:space="preserve">
          <source>On Apple platforms &lt;code&gt;objc&lt;/code&gt; library is provided for interoperability with &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt;.</source>
          <target state="translated">На платформах Apple &lt;code&gt;objc&lt;/code&gt; библиотека objc для взаимодействия с &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a12a3cf1289b0209f29a4a3a5bf9dabfcdb8788" translate="yes" xml:space="preserve">
          <source>On GitHub</source>
          <target state="translated">На GitHub</target>
        </trans-unit>
        <trans-unit id="c0ab16d7d10cfcca8fa016bc8b366c04e76c5016" translate="yes" xml:space="preserve">
          <source>On JVM it is possible to redefine global exception handler for all coroutines by registering &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; via &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;. Global exception handler is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt; which is used when no more specific handlers are registered. On Android, &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; is installed as a global coroutine exception handler.</source>
          <target state="translated">В JVM можно переопределить глобальный обработчик исключений для всех сопрограмм, зарегистрировав &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; через &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; . Глобальный обработчик исключений похож на &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt; ,&lt;/a&gt; который используется, когда больше не зарегистрированы конкретные обработчики. В Android &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; установлен как глобальный обработчик исключений сопрограммы.</target>
        </trans-unit>
        <trans-unit id="52a2cc9b4e5cfa91fe617932ce29f7d004cf9460" translate="yes" xml:space="preserve">
          <source>On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634a94c081c286c31c7efa035cd25a12a05ea49" translate="yes" xml:space="preserve">
          <source>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</source>
          <target state="translated">В JVM этот генератор является потокобезопасным,его методы могут быть вызваны из нескольких потоков.</target>
        </trans-unit>
        <trans-unit id="82b7124cbe78a1bd0ee0229af53226a5b9d9303c" translate="yes" xml:space="preserve">
          <source>On Linux we call a similar command:</source>
          <target state="translated">В Linux мы вызываем аналогичную команду:</target>
        </trans-unit>
        <trans-unit id="debaeb12f7add41593464f7eef76b63e195de057" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32995a2978fac4fc27ca1ef6f69f7fd0261ff6b" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">В Windows динамические библиотеки включаются либо через сгенерированную оболочку статической библиотеки, либо с помощью ручного кода, который имеет дело с &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; или аналогичными функциями Win32API. Мы &lt;code&gt;libnative.dll&lt;/code&gt; первым вариантом и сгенерируем статическую библиотеку-оболочку для libnative.dll самостоятельно.</target>
        </trans-unit>
        <trans-unit id="215b62ee2a4bb5fa218d3c640f454cdd3fd9a459" translate="yes" xml:space="preserve">
          <source>On a &lt;code&gt;dynamic&lt;/code&gt; variable, you can call &lt;strong&gt;any&lt;/strong&gt; property or function, with any parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7653dc191105be976f3e4142a119bd4841c071b" translate="yes" xml:space="preserve">
          <source>On compiling, Gradle will produce the output of our application, which is by default placed under the &lt;code&gt;build/classes/main&lt;/code&gt; directory. This can be overridden using &lt;a href=&quot;#configuring-compiler-options&quot;&gt;the compiler options&lt;/a&gt;.</source>
          <target state="translated">При компиляции Gradle выдаст вывод нашего приложения, который по умолчанию находится в каталоге &lt;code&gt;build/classes/main&lt;/code&gt; . Это можно изменить с помощью &lt;a href=&quot;#configuring-compiler-options&quot;&gt;параметров компилятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c14acaa8726202e56fd6764b8d4c4f4bf976a344" translate="yes" xml:space="preserve">
          <source>On compiling, Maven will produce the following output</source>
          <target state="translated">При компиляции,Maven выдаст следующие результаты.</target>
        </trans-unit>
        <trans-unit id="605e2cebf9185d39a487f4db48ecd6fb230665c8" translate="yes" xml:space="preserve">
          <source>On empty collections, &lt;code&gt;random()&lt;/code&gt; throws an exception. To receive &lt;code&gt;null&lt;/code&gt; instead, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random-or-null&quot;&gt;&lt;code&gt;randomOrNull()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2882a4f2583407f0619da2020ec98bec3d44466d" translate="yes" xml:space="preserve">
          <source>On macOS 10.13 with Xcode, we compile the C code and link it with the dynamic library with the following command:</source>
          <target state="translated">На MacOS 10.13 с Xcode мы компилируем код на C и связываем его с динамической библиотекой следующей командой:</target>
        </trans-unit>
        <trans-unit id="29573262d66dff209bb25d8ca0d7651c0e4d12be" translate="yes" xml:space="preserve">
          <source>On the JVM platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99e2927eb300e8d0d8fcf2adae0bb05f7e1dd48" translate="yes" xml:space="preserve">
          <source>On the JVM platform, the runtime component required for using the reflection features is distributed as a separate artifact &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the Kotlin compiler distribution. This is done to reduce the required size of the runtime library for applications that do not use reflection features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4ddd201d36fd87940a13588d6e11985482252b" translate="yes" xml:space="preserve">
          <source>On the JVM side, the main build tools include &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt;, &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt;, and &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt&lt;/a&gt;. There are also some build tools available that target client-side JavaScript.</source>
          <target state="translated">Что касается JVM, к основным инструментам сборки относятся &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt; , &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt; , &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt; и &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt&lt;/a&gt; . Также доступны некоторые инструменты сборки, предназначенные для клиентского JavaScript.</target>
        </trans-unit>
        <trans-unit id="8a846654c5fb7b58771a6c8aa68e2bb8f0431b17" translate="yes" xml:space="preserve">
          <source>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see &lt;a href=&quot;classes#constructors&quot;&gt;Constructors&lt;/a&gt;).</source>
          <target state="translated">В JVM, если сгенерированный класс должен иметь конструктор без параметров, необходимо указать значения по умолчанию для всех свойств (см. &lt;a href=&quot;classes#constructors&quot;&gt;Конструкторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="22f3441381be355a57b0344800020b03a2e7fba9" translate="yes" xml:space="preserve">
          <source>On the JVM, non-nullable values of this type are represented as values of the primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">В JVM значения этого типа, не допускающие значения NULL, представлены как значения примитивного типа &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ad8bfe3e9b420b17609f7d80f8fe5d46e556b" translate="yes" xml:space="preserve">
          <source>On the JVM, one could provide an implementation that writes the log to the standard output:</source>
          <target state="translated">На JVM можно было бы обеспечить реализацию,которая записывает журнал в стандартный вывод:</target>
        </trans-unit>
        <trans-unit id="37c721a8e1ab899d231ec42baf253266e008d200" translate="yes" xml:space="preserve">
          <source>On the JVM, the &lt;a href=&quot;basic-types#arrays&quot;&gt;array types&lt;/a&gt; (&lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt;) retain the information about the erased type of their elements, and the type casts to an array type are partially checked: the nullability and actual type arguments of the elements type are still erased. For example, the cast &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; will succeed if &lt;code&gt;foo&lt;/code&gt; is an array holding any &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;, nullable or not.</source>
          <target state="translated">В JVM &lt;a href=&quot;basic-types#arrays&quot;&gt;типы массивов&lt;/a&gt; ( &lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt; ) сохраняют информацию об удаленном типе своих элементов, а приведение типов к типу массива частично проверяется: допустимость значения NULL и фактические аргументы типа для типа элементов по-прежнему стираются. Например, приведение &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; Будет успешным, если &lt;code&gt;foo&lt;/code&gt; является массивом, содержащим любой &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; , допускающий значение NULL или нет.</target>
        </trans-unit>
        <trans-unit id="5506431e2bb120557c874e7652f1a65950568290" translate="yes" xml:space="preserve">
          <source>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. &lt;code&gt;Int?&lt;/code&gt;) or generics are involved. In the latter cases numbers are boxed.</source>
          <target state="translated">На платформе Java числа физически хранятся как примитивные типы JVM, если нам не нужна ссылка на число, допускающее значение NULL (например, &lt;code&gt;Int?&lt;/code&gt; ), Или не используются универсальные типы . В последнем случае числа заключены в рамку.</target>
        </trans-unit>
        <trans-unit id="fc1cc156e617b185ed0f40e773e41bff1f85a104" translate="yes" xml:space="preserve">
          <source>On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">На платформе Java стандартная библиотека содержит расширения для классов отражения, которые обеспечивают отображение объектов отражения Java и обратно (см. Пакет &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; ). Например, чтобы найти вспомогательное поле или метод Java, который служит получателем для свойства Kotlin, вы можете сказать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="2a19f51c47052a4b52d4d3a45688012ff83885d4" translate="yes" xml:space="preserve">
          <source>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt;). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</source>
          <target state="translated">На платформе Java компонент среды выполнения, необходимый для использования функций отражения, распространяется в виде отдельного файла JAR ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ). Это сделано для уменьшения необходимого размера библиотеки времени выполнения для приложений, которые не используют функции отражения. Если вы действительно используете отражение, убедитесь, что файл .jar добавлен в путь к классам вашего проекта.</target>
        </trans-unit>
        <trans-unit id="5d535cc279349339edec2b28152e5485a7cce0a0" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform this code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">На платформе JavaScript этот код будет компилироваться &amp;laquo;как есть&amp;raquo;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; в Kotlin становится &lt;code&gt;dyn.whatever(1)&lt;/code&gt; в сгенерированном коде JavaScript.</target>
        </trans-unit>
        <trans-unit id="5b66a81be58a9639896f5746359a7ffeeb1b2933" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform, only class references are currently supported. &lt;a href=&quot;js-reflection&quot;&gt;Learn more about reflection in Kotlin/JS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7710454ff099464789e309cce04c505a88cd2a29" translate="yes" xml:space="preserve">
          <source>On the generic Native platform we don't have the luxury to use someone else's implementation, so we will have to write one ourselves. I won't explain the implementation details here, but it's pretty straightforward and follows Base64 format description without any optimizations:</source>
          <target state="translated">На универсальной платформе коренных народов у нас нет роскоши использовать чужую реализацию,так что нам придется написать ее самим.Здесь я не буду объяснять подробности реализации,но она довольно проста и следует описанию формата Base64 без всяких оптимизаций:</target>
        </trans-unit>
        <trans-unit id="dc341284a94c1ff306b2072d23ec90c8ced7deca" translate="yes" xml:space="preserve">
          <source>On the one hand, to achieve this, the compiler has to provide certain ABI stability guarantees under the constraints of separate compilation. This is why every change in the language is examined from the point of view of binary compatibility.</source>
          <target state="translated">С одной стороны,для этого компилятор должен предоставлять определенные гарантии стабильности ABI при ограничениях отдельной компиляции.Поэтому каждое изменение в языке рассматривается с точки зрения бинарной совместимости.</target>
        </trans-unit>
        <trans-unit id="000c75f582537e6c16176741f98b45d2d110bbb3" translate="yes" xml:space="preserve">
          <source>On the other hand, Kotlin/Native supports interoperability to use existing libraries directly from Kotlin/Native:</source>
          <target state="translated">С другой стороны,Kotlin/Native поддерживает интероперабельность для использования существующих библиотек непосредственно из Kotlin/Native:</target>
        </trans-unit>
        <trans-unit id="60f0f1b25c5dff1f04424f892492e20e71e1b66d" translate="yes" xml:space="preserve">
          <source>On the other hand, a lot depends on the library authors being careful about which changes are safe to make. Thus it's very important that library authors understand how source changes affect compatibility and follow certain best practices to keep both APIs and ABIs of their libraries stable. Here are some assumptions that we make when considering language changes from the library evolution standpoint:</source>
          <target state="translated">С другой стороны,многое зависит от того,насколько осторожно авторы библиотеки подойдут к вопросу о том,какие изменения безопасно внести.Поэтому очень важно,чтобы авторы библиотек понимали,как изменения в исходном тексте влияют на совместимость,и следовали определенным лучшим практикам для поддержания стабильности как API,так и ABI своих библиотек.Вот некоторые допущения,которые мы делаем при рассмотрении изменений языка с точки зрения эволюции библиотек:</target>
        </trans-unit>
        <trans-unit id="24a6b58cfe3e05a456f0e657a9154e03adab1e36" translate="yes" xml:space="preserve">
          <source>On the other hand, if we don't need wildcards where they are generated, we can use &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt;:</source>
          <target state="translated">С другой стороны, если нам не нужны подстановочные знаки там, где они генерируются, мы можем использовать &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9fe83b5bff0a5d4a34dc3a1fd60b88652cfd8998" translate="yes" xml:space="preserve">
          <source>On the other hand, infix function call's precedence is higher than that of the boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;- and &lt;code&gt;in&lt;/code&gt;-checks, and some other operators. These expressions are equivalent as well:</source>
          <target state="translated">С другой стороны, приоритет вызова инфиксной функции выше, чем приоритет логических операторов &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;is&lt;/code&gt; - and &lt;code&gt;in&lt;/code&gt; -checks и некоторые другие операторы. Эти выражения также эквивалентны:</target>
        </trans-unit>
        <trans-unit id="4b4a432df45f297429fbc3cee76b5f8d7f65a8e2" translate="yes" xml:space="preserve">
          <source>On the other hand, it preserves equality:</source>
          <target state="translated">С другой стороны,он сохраняет равенство:</target>
        </trans-unit>
        <trans-unit id="7e3c3918cd7bead7b21ab07c18b704638f85c9a4" translate="yes" xml:space="preserve">
          <source>On the other hand, the platform libs in the distribution are merely just wrappers and bindings to the native libraries. That means the native libraries themselves (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt; etc) should be installed on the machine.</source>
          <target state="translated">С другой стороны, библиотеки платформы в дистрибутиве - это просто оболочки и привязки к собственным библиотекам. Это означает , что нативные библиотеки сами ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.a&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; и т.д.) должны быть установлены на компьютере.</target>
        </trans-unit>
        <trans-unit id="a4bdeb370dbf1cefb8a423a42914a31fcb4ec6d9" translate="yes" xml:space="preserve">
          <source>On the other side, by default, a dispatcher for the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is inherited. The default dispatcher for &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with a predictable FIFO scheduling.</source>
          <target state="translated">С другой стороны, по умолчанию наследуется диспетчер внешнего &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . Диспетчер по умолчанию для сопрограммы &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; , в частности, ограничен потоком вызывающего, поэтому его наследование приводит к ограничению выполнения этим потоком с предсказуемым планированием FIFO.</target>
        </trans-unit>
        <trans-unit id="425d42a58936f61d420710d94f729d1304fe83b3" translate="yes" xml:space="preserve">
          <source>On the other side, the dispatcher is inherited from the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; by default. The default dispatcher for the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with predictable FIFO scheduling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40268462bf212f39b8385da7e84960f17dde7ce2" translate="yes" xml:space="preserve">
          <source>On this page, you'll learn how the modifiers apply to different types of declaring scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0097b825a22364e0ed5d52b543c2c2d7417ac42f" translate="yes" xml:space="preserve">
          <source>OnErrorAction</source>
          <target state="translated">OnErrorAction</target>
        </trans-unit>
        <trans-unit id="af3390fd9bdb1b1f1af829e06104c3364aeb4907" translate="yes" xml:space="preserve">
          <source>Once a worker is started with the &lt;code&gt;Worker.start&lt;/code&gt; function call, it can be addressed with its own unique integer worker id. Other workers, or non-worker concurrency primitives, such as OS threads, can send a message to the worker with the &lt;code&gt;execute&lt;/code&gt; call.</source>
          <target state="translated">Как только рабочий запускается с помощью &lt;code&gt;Worker.start&lt;/code&gt; функции Worker.start , к нему можно обращаться с его собственным уникальным целочисленным идентификатором рабочего процесса. Другие рабочие процессы или нерабочие примитивы параллелизма, такие как потоки ОС, могут отправить сообщение рабочему с помощью вызова &lt;code&gt;execute&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df99b41ffc8e8869530eb6fc788d462a8f350ad0" translate="yes" xml:space="preserve">
          <source>Once that's done, we simply right-click on our &lt;code&gt;index.html&lt;/code&gt; file and select the Debug option. This launches Chrome and then stops at the breakpoint defined in our code inside IntelliJ IDEA, from where we can evaluate expressions, step through code, etc.</source>
          <target state="translated">Как только это будет сделано, мы просто щелкаем правой кнопкой мыши наш файл &lt;code&gt;index.html&lt;/code&gt; и выбираем параметр &amp;laquo;Отладка&amp;raquo;. Это запускает Chrome, а затем останавливается в точке останова, определенной в нашем коде внутри IntelliJ IDEA, откуда мы можем оценивать выражения, выполнять пошаговый код и т. Д.</target>
        </trans-unit>
        <trans-unit id="3775c8ff21ba04eef02e13e8e82e7fea59a82c9d" translate="yes" xml:space="preserve">
          <source>Once the IDE has finished creating the new project, we should be left with the following layout</source>
          <target state="translated">После того,как IDE закончит создание нового проекта,нам нужно будет оставить следующий макет</target>
        </trans-unit>
        <trans-unit id="d9769c12f9ad9598db953dee152f3b5b5ad3daf0" translate="yes" xml:space="preserve">
          <source>Once the code is ready, select a fragment you want a learner to fill in, invoke &lt;strong&gt;Add Answer Placeholder&lt;/strong&gt; command from the right-click menu and add the placeholder text and some hints to help the learner find the right solution:</source>
          <target state="translated">Когда код будет готов, выберите фрагмент, который должен заполнить учащийся, вызовите команду &lt;strong&gt;Добавить&lt;/strong&gt; заполнитель &lt;strong&gt;ответа&lt;/strong&gt; из контекстного меню и добавьте текст заполнителя и некоторые подсказки, чтобы помочь учащемуся найти правильное решение:</target>
        </trans-unit>
        <trans-unit id="46c1b63ed4fbeaebfc1fd631405807b64e959941" translate="yes" xml:space="preserve">
          <source>Once the dependency is included, we can access the different interfaces provided to generate DOM. The code below will add a new &lt;code&gt;span&lt;/code&gt; tag with the text &lt;code&gt;Hello&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt; on the &lt;code&gt;window.load&lt;/code&gt; event.</source>
          <target state="translated">После включения зависимости мы можем получить доступ к различным интерфейсам, предоставленным для генерации DOM. Приведенный ниже код добавит новый тег &lt;code&gt;span&lt;/code&gt; с текстом &lt;code&gt;Hello&lt;/code&gt; внутри &lt;code&gt;div&lt;/code&gt; в событии &lt;code&gt;window.load&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f0142e56236eba7d0f9779ea0961db259aa8e0d" translate="yes" xml:space="preserve">
          <source>Once the file is created, add the &lt;code&gt;main&lt;/code&gt; function which is the entry point to a Kotlin application. IntelliJ IDEA offers a template to do this quickly. Just type &lt;em&gt;main&lt;/em&gt; and press tab.</source>
          <target state="translated">После создания файла добавьте &lt;code&gt;main&lt;/code&gt; функцию, которая является точкой входа в приложение Kotlin. IntelliJ IDEA предлагает шаблон, чтобы сделать это быстро. Просто введите &lt;em&gt;основной&lt;/em&gt; и нажмите вкладку.</target>
        </trans-unit>
        <trans-unit id="c73312381dcc07c6b7a625ba7ed9e57ac7440a0f" translate="yes" xml:space="preserve">
          <source>Once the plugin is installed and Eclipse is restarted, make sure the plugin is installed correctly: open the &lt;strong&gt;Kotlin perspective&lt;/strong&gt; in the menu &lt;strong&gt;Window | Open Perspective | Other&amp;hellip;&lt;/strong&gt;</source>
          <target state="translated">После установки плагина и перезапуска Eclipse убедитесь, что плагин установлен правильно: откройте &lt;strong&gt;перспективу Kotlin&lt;/strong&gt; в меню &lt;strong&gt;Window | Открытая перспектива | Другой&amp;hellip;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea14fe002f3a94c4720dab1f2d5b5523e7e10653" translate="yes" xml:space="preserve">
          <source>Once we do that, we can start the app by running the following command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0796366ca4be24e6c9cb8aea2efb2652251fe7de" translate="yes" xml:space="preserve">
          <source>Once we do that, we can then invoke the corresponding extensions, which are properties named after the views in the XML file. For example, for this view:</source>
          <target state="translated">После этого мы можем вызвать соответствующие расширения,которые являются свойствами,названными в честь представлений в XML-файле.Например,для этого вида:</target>
        </trans-unit>
        <trans-unit id="1c271397461aeb676abb2a2efff251e0af0e8c64" translate="yes" xml:space="preserve">
          <source>Once we have the build script defined with the correct dependencies, we can now create a controller</source>
          <target state="translated">После того,как мы определили сценарий сборки с правильными зависимостями,мы можем создать контроллер</target>
        </trans-unit>
        <trans-unit id="a08b600d20b04c79c7a79b722bf898a01cce7fce" translate="yes" xml:space="preserve">
          <source>Once we have the definition file ready, we can create project files and open the project in an IDE.</source>
          <target state="translated">После того,как файл определения готов,мы можем создать проектные файлы и открыть проект в IDE.</target>
        </trans-unit>
        <trans-unit id="d8045dca300b9f4677fd2c5dc7702ace1a03cfe2" translate="yes" xml:space="preserve">
          <source>Once we have the file generated, we can simply include it in our project and use it:</source>
          <target state="translated">После того,как мы сгенерировали файл,мы можем просто включить его в наш проект и использовать его:</target>
        </trans-unit>
        <trans-unit id="bd56b1bd7445724ec0021ec14943c2a384d08186" translate="yes" xml:space="preserve">
          <source>Once we run the application (using this previous run configuration), and on successful deployment, we should be able to navigate to the browser with the correct url and see the response:</source>
          <target state="translated">Как только мы запустим приложение (используя эту предыдущую запущенную конфигурацию),и при успешной установке мы сможем перейти в браузер с правильным url и увидеть ответ:</target>
        </trans-unit>
        <trans-unit id="1b6604db47f0dce985d7de59d4f23c0c4c5c9cca" translate="yes" xml:space="preserve">
          <source>Once you complete the steps, Android Studio creates a project. The project already contains all the code and resources for building an application that can run on your Android device or an emulator.</source>
          <target state="translated">После того,как вы выполнили все шаги,Android Studio создает проект.Проект уже содержит весь код и ресурсы для построения приложения,которое может быть запущено на вашем Android-устройстве или эмуляторе.</target>
        </trans-unit>
        <trans-unit id="07c62572d32f4ddef7a4fab02344f0c5993a4073" translate="yes" xml:space="preserve">
          <source>Once you have IntelliJ IDEA installed, it's time to create your first Kotlin application.</source>
          <target state="translated">После установки IntelliJ IDEA пришло время создать первое приложение Kotlin.</target>
        </trans-unit>
        <trans-unit id="57c7fbdcf305fcf640a6242dec4553b583c17b02" translate="yes" xml:space="preserve">
          <source>Once you have a source file, add the &lt;code&gt;main&lt;/code&gt; function - the entry point to a Kotlin application. You can simply type &lt;code&gt;main&lt;/code&gt; and invoke code completion by hitting &lt;code&gt;Ctrl + Space&lt;/code&gt;.</source>
          <target state="translated">Когда у вас есть исходный файл, добавьте &lt;code&gt;main&lt;/code&gt; функцию - точку входа в приложение Kotlin. Вы можете просто ввести &lt;code&gt;main&lt;/code&gt; и вызвать автозавершение кода, нажав &lt;code&gt;Ctrl + Space&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e85f75a1aece4509c955931a0b0a7c85d0dc463" translate="yes" xml:space="preserve">
          <source>Once you have finished writing your code in a scratch or a worksheet, click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear in the lines opposite your code.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
