<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="686299f7711a328af7f7ede481ecd878f135b9f6" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;code&gt;v-if&lt;/code&gt; has higher toggle costs while &lt;code&gt;v-show&lt;/code&gt; has higher initial render costs. So prefer &lt;code&gt;v-show&lt;/code&gt; if you need to toggle something very often, and prefer &lt;code&gt;v-if&lt;/code&gt; if the condition is unlikely to change at runtime.</source>
          <target state="translated">Вообще говоря, &lt;code&gt;v-if&lt;/code&gt; имеет более высокую стоимость переключения, в то время как &lt;code&gt;v-show&lt;/code&gt; имеет более высокую начальную стоимость рендеринга. Поэтому предпочитайте &lt;code&gt;v-show&lt;/code&gt; , если вам нужно что-то переключать очень часто, и &lt;code&gt;v-if&lt;/code&gt; , если условие вряд ли изменится во время выполнения.</target>
        </trans-unit>
        <trans-unit id="54c5f98c2534a5664e54bdf67174809b2a27c8a3" translate="yes" xml:space="preserve">
          <source>Get Support</source>
          <target state="translated">Получить поддержку</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="4687f4eea959b8d3a7678579930ba86b60298a4b" translate="yes" xml:space="preserve">
          <source>Global API</source>
          <target state="translated">Глобальный API</target>
        </trans-unit>
        <trans-unit id="d99de9060d9d291cf15a1d729547287918e216dc" translate="yes" xml:space="preserve">
          <source>Global Config</source>
          <target state="translated">Глобальная конфигурация</target>
        </trans-unit>
        <trans-unit id="a87e1f8386cdfab8951563f9287ce245995f5751" translate="yes" xml:space="preserve">
          <source>Global Mixin</source>
          <target state="translated">Global Mixin</target>
        </trans-unit>
        <trans-unit id="12acfdfcb7281091faacdbe76162537707d677a4" translate="yes" xml:space="preserve">
          <source>Global Registration</source>
          <target state="translated">Глобальная регистрация</target>
        </trans-unit>
        <trans-unit id="d23476cf27dc98d9e3173cbdb68ad4566d7bbe61" translate="yes" xml:space="preserve">
          <source>Global registration often isn&amp;rsquo;t ideal. For example, if you&amp;rsquo;re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">Глобальная регистрация часто не идеальна. Например, если вы используете систему сборки, такую ​​как Webpack, глобальная регистрация всех компонентов означает, что даже если вы прекратите использовать компонент, он все равно может быть включен в вашу окончательную сборку. Это излишне увеличивает количество JavaScript, которое должны загружать ваши пользователи.</target>
        </trans-unit>
        <trans-unit id="e2b51a4acf3ac2ad46709058f4a65e88a724bd55" translate="yes" xml:space="preserve">
          <source>Global state management</source>
          <target state="translated">Глобальный государственный менеджмент</target>
        </trans-unit>
        <trans-unit id="d2cdbb9287a2eee1e29278ad1a52afa18af50490" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created afterwards &amp;ndash; and even inside all subcomponents of that Vue instance&amp;rsquo;s component tree.</source>
          <target state="translated">Глобально зарегистрированные компоненты могут использоваться в шаблоне любого корневого экземпляра Vue ( &lt;code&gt;new Vue&lt;/code&gt; ), созданного впоследствии - и даже внутри всех подкомпонентов дерева компонентов этого экземпляра Vue.</target>
        </trans-unit>
        <trans-unit id="9d53a8dc9787d0f1938039b6b2df16c89e2967b1" translate="yes" xml:space="preserve">
          <source>Go ahead and enter &lt;code&gt;app3.seen = false&lt;/code&gt; in the console. You should see the message disappear.</source>
          <target state="translated">Идите вперед и введите в консоли &lt;code&gt;app3.seen = false&lt;/code&gt; . Вы должны увидеть, что сообщение исчезнет.</target>
        </trans-unit>
        <trans-unit id="61dedcf053ff33692baacbf7789c5d7195d9acbe" translate="yes" xml:space="preserve">
          <source>Good</source>
          <target state="translated">Good</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="613dffa8c694c4b79227626375484864e1cbb5bc" translate="yes" xml:space="preserve">
          <source>HTML &amp;amp; CSS</source>
          <target state="translated">HTML и CSS</target>
        </trans-unit>
        <trans-unit id="ecb5ae374f41987062d1edb5a439c141fbcfee47" translate="yes" xml:space="preserve">
          <source>HTML Interpolation &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">HTML-интерполяция &lt;sup&gt;удалена&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="61152bedc285b45e3443132c85b9e9eab87b1c71" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">Имена атрибутов HTML не чувствительны к регистру, поэтому браузеры будут интерпретировать любые символы верхнего регистра как строчные. Это означает, что, когда вы используете шаблоны в DOM, в именах опор с верблюжьим регистром должны использоваться их эквиваленты в кебабе (разделенные дефисом):</target>
        </trans-unit>
        <trans-unit id="206317f92c61c3721e7b0ef393e74b50f2adc608" translate="yes" xml:space="preserve">
          <source>HTML elements,</source>
          <target state="translated">HTML-элементы,</target>
        </trans-unit>
        <trans-unit id="b7d20a95e49462d14a4c08f7dda3686750b36c96" translate="yes" xml:space="preserve">
          <source>HTML interpolation has been &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;removed in favor of &lt;code&gt;v-html&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Интерполяция HTML была &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;удалена в пользу &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b1c56685d95ab775546bda4c6e1ef23eea39b81" translate="yes" xml:space="preserve">
          <source>HTML interpolations (&lt;code&gt;{{{ foo }}}&lt;/code&gt;) have been removed in favor of the &lt;a href=&quot;../api/index#v-html&quot;&gt;&lt;code&gt;v-html&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">HTML-интерполяции ( &lt;code&gt;{{{ foo }}}&lt;/code&gt; ) были удалены в пользу &lt;a href=&quot;../api/index#v-html&quot;&gt;директивы &lt;/a&gt; &lt;code&gt;v-html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5f7d68ba95b6c2f0128818861a5fb3a7ce41b3" translate="yes" xml:space="preserve">
          <source>HTML&amp;rsquo;s built-in input types won&amp;rsquo;t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">Встроенные типы ввода HTML не всегда соответствуют вашим потребностям. К счастью, компоненты Vue позволяют создавать многократно используемые входы с полностью настраиваемым поведением. Эти входы работают даже с &lt;code&gt;v-model&lt;/code&gt; ! Чтобы узнать больше, прочтите о &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;настраиваемых входах&lt;/a&gt; в руководстве по компонентам.</target>
        </trans-unit>
        <trans-unit id="69b83e92529f5151314d046d862c4a9c77d93516" translate="yes" xml:space="preserve">
          <source>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue&amp;rsquo;s reactivity features.</source>
          <target state="translated">Шаблоны на основе HTML значительно упрощают постепенную миграцию существующих приложений, чтобы воспользоваться функциями реактивности Vue.</target>
        </trans-unit>
        <trans-unit id="5e6fab8d8bdb45dbc0c724b264884e741a1423d5" translate="yes" xml:space="preserve">
          <source>Handling Edge Cases</source>
          <target state="translated">Обработка кромочных корпусов</target>
        </trans-unit>
        <trans-unit id="0c27db799f42037e36231e8871e3549a290cef26" translate="yes" xml:space="preserve">
          <source>Handling Loading State</source>
          <target state="translated">Состояние погрузки при обработке</target>
        </trans-unit>
        <trans-unit id="f70e7e4e8994ebaac734eaf505f7cb87f5015b0f" translate="yes" xml:space="preserve">
          <source>Handling User Input</source>
          <target state="translated">Обработка пользовательского ввода</target>
        </trans-unit>
        <trans-unit id="553c9fd444b729d939071ffd415fb951213f90a4" translate="yes" xml:space="preserve">
          <source>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</source>
          <target state="translated">Хэшбанги больше не нужны Google для сканирования URL,поэтому они больше не являются стандартными (или даже опциями)для хэш-стратегии.</target>
        </trans-unit>
        <trans-unit id="a8d68b23680238f325efc34072a89db096cd1404" translate="yes" xml:space="preserve">
          <source>Having this validator extracted out, we&amp;rsquo;ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it&amp;rsquo;s actually impossible for users to enter anything wrong, similar to what the browser&amp;rsquo;s native number input tries to do.</source>
          <target state="translated">После извлечения этого валидатора нам также было удобнее превратить его в более надежное решение. Причуды состояния были устранены, и пользователи фактически не могут ввести что-либо неправильно, подобно тому, что пытается сделать собственный ввод числа в браузере.</target>
        </trans-unit>
        <trans-unit id="5d3e638fd34dc7467faa0ba823b8497588b5815b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;attributeName&lt;/code&gt; будет динамически оцениваться как выражение JavaScript, и его оцененное значение будет использоваться как окончательное значение для аргумента. Например, если ваш экземпляр Vue имеет свойство данных &lt;code&gt;attributeName&lt;/code&gt; , значение которого равно &lt;code&gt;&quot;href&quot;&lt;/code&gt; , то эта привязка будет эквивалентна &lt;code&gt;v-bind:href&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a97b67c98ddcf2e842f6272379190e542a3a62" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;filterA&lt;/code&gt; is defined as a function taking three arguments. The value of &lt;code&gt;message&lt;/code&gt; will be passed into the first argument. The plain string &lt;code&gt;'arg1'&lt;/code&gt; will be passed into the &lt;code&gt;filterA&lt;/code&gt; as its second argument, and the value of expression &lt;code&gt;arg2&lt;/code&gt; will be evaluated and passed in as the third argument.</source>
          <target state="translated">Здесь &lt;code&gt;filterA&lt;/code&gt; определяется как функция, принимающая три аргумента. Значение &lt;code&gt;message&lt;/code&gt; будет передано в первый аргумент. &lt;code&gt;filterA&lt;/code&gt; строка &lt;code&gt;'arg1'&lt;/code&gt; будет передана в filterA в качестве второго аргумента, а значение выражения &lt;code&gt;arg2&lt;/code&gt; будет оценено и передано в качестве третьего аргумента.</target>
        </trans-unit>
        <trans-unit id="b533c1b3a997459bdeab6c6103d2b8341430c012" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;href&lt;/code&gt; - это аргумент, который указывает директиве &lt;code&gt;v-bind&lt;/code&gt; привязать атрибут &lt;code&gt;href&lt;/code&gt; элемента к значению выражения &lt;code&gt;url&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a2ad49522f0c5140bd579d6e3f6cc63de82a9e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; can be omitted as it is implied:</source>
          <target state="translated">Здесь &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; можно не указывать, поскольку это подразумевается:</target>
        </trans-unit>
        <trans-unit id="a5a992eb5c40fb541d26012305484c0906879154" translate="yes" xml:space="preserve">
          <source>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</source>
          <target state="translated">Здесь аргумент-название события,которое нужно прослушать.Мы также поговорим об обработке событий более подробно.</target>
        </trans-unit>
        <trans-unit id="f407b88178ffc4e03f9f78c8af7c050fb1a05bb8" translate="yes" xml:space="preserve">
          <source>Here we are encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you are seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &amp;ldquo;keep this element&amp;rsquo;s &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the Vue instance.&amp;rdquo;</source>
          <target state="translated">Здесь мы встречаемся с чем-то новым. &lt;code&gt;v-bind&lt;/code&gt; атрибут вы видите, называется &lt;strong&gt;директивой&lt;/strong&gt; . Директивы имеют префикс &lt;code&gt;v-&lt;/code&gt; , чтобы указать, что они являются специальными атрибутами, предоставляемыми Vue, и, как вы, возможно, догадались, они применяют особое реактивное поведение к визуализированной DOM. Здесь, по сути, говорится: &amp;laquo;Держите атрибут &lt;code&gt;title&lt;/code&gt; этого элемента в актуальном состоянии со свойством &lt;code&gt;message&lt;/code&gt; в экземпляре Vue&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="20439924cb310f6e6ebea9dce4e509745f1d1bb0" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;reversedMessage&lt;/code&gt;. The function we provided will be used as the getter function for the property &lt;code&gt;vm.reversedMessage&lt;/code&gt;:</source>
          <target state="translated">Здесь мы объявили вычисляемое свойство &lt;code&gt;reversedMessage&lt;/code&gt; . Предоставленная нами функция будет использоваться как функция получения для свойства &lt;code&gt;vm.reversedMessage&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41a58605aec4adfd7f18a1d980084fe022c01384" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete example of a simple todo list:</source>
          <target state="translated">Вот полный пример простого списка дел:</target>
        </trans-unit>
        <trans-unit id="e6deaab1ac1757bb576b7c7fb31ce01f23836233" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a &lt;code&gt;smart-list&lt;/code&gt; component that delegates to more specific components, depending on the props passed to it:</source>
          <target state="translated">Вот пример компонента &lt;code&gt;smart-list&lt;/code&gt; который делегирует полномочия более конкретным компонентам в зависимости от переданных ему реквизитов:</target>
        </trans-unit>
        <trans-unit id="8edc36b060f6cabd0970dde81f8964d59b6e1225" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a Vue component:</source>
          <target state="translated">Вот пример компонента Vue:</target>
        </trans-unit>
        <trans-unit id="b31be59658661ba4e66f41944f3554b7a0be5398" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a file we&amp;rsquo;ll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">Вот пример файла, который мы назовем &lt;code&gt;Hello.vue&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b33ffef562696923d8035d66d6b00e446f9c5cd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example using a template component:</source>
          <target state="translated">Вот пример использования компонента шаблона:</target>
        </trans-unit>
        <trans-unit id="99ff339aed17c551cb54d5842ca9646f53c8ed64" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with all of these modifiers used together:</source>
          <target state="translated">Вот пример, когда все эти модификаторы используются вместе:</target>
        </trans-unit>
        <trans-unit id="18a91a386128ffc554ca249fb0825499466cf9d3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">Вот пример без префиксов правил CSS для краткости:</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="f7ffc75a586e32509010b20213e0f4e623c0e848" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s that in action:</source>
          <target state="translated">Вот это в действии:</target>
        </trans-unit>
        <trans-unit id="9a829483e3b314613758a5a663c73e6905d5701b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;slot-scope&lt;/code&gt; declares the received props object as the &lt;code&gt;slotProps&lt;/code&gt; variable, and makes it available inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; scope. You can name &lt;code&gt;slotProps&lt;/code&gt; anything you like similar to naming function arguments in JavaScript.</source>
          <target state="translated">Здесь &lt;code&gt;slot-scope&lt;/code&gt; объявляет полученный объект &lt;code&gt;slotProps&lt;/code&gt; переменную slotProps и делает его доступным внутри области &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; . Вы можете называть &lt;code&gt;slotProps&lt;/code&gt; как угодно, подобно аргументам функции в JavaScript.</target>
        </trans-unit>
        <trans-unit id="f68e5bf516c14d7636dc7e787f07b009104eba6f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;v-if&lt;/code&gt; directive would remove/insert the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element based on the truthiness of the value of the expression &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">Здесь директива &lt;code&gt;v-if&lt;/code&gt; удаляет / вставляет элемент &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; на основе истинности значения &lt;code&gt;seen&lt;/code&gt; выражения .</target>
        </trans-unit>
        <trans-unit id="8e26e3e40dfd6774d32a14ec704c7c19bb0bf799" translate="yes" xml:space="preserve">
          <source>Hook Functions</source>
          <target state="translated">Функции крюка</target>
        </trans-unit>
        <trans-unit id="d2bdd950b4b524b4faf0540c42b846e440d3ebd2" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Одноименные функции-перехватчики объединяются в массив, поэтому все они будут вызваны. Перехватчики Mixin будут вызываться &lt;strong&gt;перед&lt;/strong&gt; собственными перехватчиками компонента.</target>
        </trans-unit>
        <trans-unit id="656dedbf5301c31ed9bdf32f2a451638643101f3" translate="yes" xml:space="preserve">
          <source>How Changes Are Tracked</source>
          <target state="translated">Как отслеживаются изменения</target>
        </trans-unit>
        <trans-unit id="a056aea1f6dc2d57c44eacd2de4c8078611a80e1" translate="yes" xml:space="preserve">
          <source>How long will it take to migrate a Vue 1.x app to 2.0?</source>
          <target state="translated">Сколько времени займет миграция приложения Vue 1.x на 2.0?</target>
        </trans-unit>
        <trans-unit id="a173386c8ab0ffd650a7e5d8b6fb73ce6260ce4e" translate="yes" xml:space="preserve">
          <source>How many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!</source>
          <target state="translated">Сколько раз ты отвлекаешься и начинаешь играть с классной новой функцией.😉 Не осуждая,это тоже случилось с нами во время сборки 2.0!</target>
        </trans-unit>
        <trans-unit id="5b51fcd95b1bb4c1d0a2feadea82b32351c13de4" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;inline-template&lt;/code&gt; makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the &lt;code&gt;template&lt;/code&gt; option or in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element in a &lt;code&gt;.vue&lt;/code&gt; file.</source>
          <target state="translated">Однако &lt;code&gt;inline-template&lt;/code&gt; усложняет понимание объема ваших шаблонов. &lt;code&gt;.vue&lt;/code&gt; определять шаблоны внутри компонента с помощью параметра &lt;code&gt;template&lt;/code&gt; или в элементе &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; в файле .vue .</target>
        </trans-unit>
        <trans-unit id="42d602a14282520e03f05621c18e657389b28401" translate="yes" xml:space="preserve">
          <source>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;, &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;, and &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;.</source>
          <target state="translated">Тем не менее, даже это едва ли не касается того, на что способны слоты с ограниченным объемом памяти. Для реальных ярких примеров использования слотов с ограниченным объемом мы рекомендуем просматривать библиотеки, такие как &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt; , &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt; и &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e377ccc91063a19e1128087c043b05ac14bc27fd" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;Vue.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">Однако для приложений, которые используют &lt;strong&gt;только&lt;/strong&gt; глобальные определения компонентов через &lt;code&gt;Vue.component&lt;/code&gt; , мы рекомендуем использовать kebab-case. Причины:</target>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">Однако, если вам требуется / импортировать компоненты с помощью &lt;strong&gt;модульной системы&lt;/strong&gt; , например, через Webpack или Browserify, вы получите сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Однако, если вы исключили вышеуказанное и оказались в чрезвычайно редкой ситуации, когда вам нужно вручную принудительно обновить обновление, вы можете сделать это с помощью &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">Однако в некоторых случаях вы можете захотеть использовать оба элемента в одном элементе, например, иметь анимацию CSS, запускаемую Vue, вместе с эффектом перехода CSS при наведении курсора. В этих случаях вам нужно будет явно объявить тип, о котором Vue будет заботиться, в атрибуте &lt;code&gt;type&lt;/code&gt; со значением &lt;code&gt;animation&lt;/code&gt; или &lt;code&gt;transition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">Однако,как и в случае с другими директивами,сокращение доступно только при наличии аргумента.Это означает,что следующий синтаксис недействителен:</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">Однако не все хотят использовать TypeScript. Во многих случаях использования меньшего масштаба внедрение системы типов может привести к большим накладным расходам, чем к увеличению производительности. В таких случаях лучше использовать Vue, поскольку использование Angular без TypeScript может оказаться сложной задачей.</target>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">Однако у внедрения зависимостей есть и обратные стороны. Он связывает компоненты вашего приложения с их текущей организацией, что затрудняет рефакторинг. Предоставленные свойства также не являются реактивными. Это сделано намеренно, потому что их использование для создания центрального хранилища данных масштабируется так же плохо, как и &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;использование &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt; для той же цели. Если свойства, которыми вы хотите поделиться, являются специфическими для вашего приложения, а не общими, или если вы когда-нибудь захотите обновить предоставленные данные внутри предков, то это хороший признак того, что вам, вероятно, понадобится реальное решение для управления состоянием, такое как &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">Однако это может быть немного многословным, если у вас несколько условных классов. Вот почему также можно использовать синтаксис объекта внутри синтаксиса массива:</target>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">Однако это не будет автоматически передавать какие-либо данные в компонент, поскольку компоненты имеют собственные изолированные области действия. Чтобы передать итерированные данные в компонент, мы также должны использовать props:</target>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">Однако при общении между далекими потомками / предками &lt;code&gt;$emit&lt;/code&gt; вам не поможет. Вместо этого простейшим возможным обновлением было бы использование централизованного концентратора событий. Это дает дополнительное преимущество, позволяя вам обмениваться данными между компонентами независимо от того, где они находятся в дереве компонентов - даже между братьями и сестрами! Поскольку экземпляры Vue реализуют интерфейс генератора событий, вы можете использовать для этой цели пустой экземпляр Vue.</target>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">Однако вы все равно можете обернуть содержимое слота по умолчанию в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; , если хотите быть явным:</target>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">Я надеюсь, что прямо сейчас вы читаете это предложение на предпочитаемом вами языке. Если нет, не могли бы вы помочь нам туда добраться?</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">Рад, что ты спросил! Ответ - нет. Около 90% API осталось прежним, а основные концепции не изменились. Это длинно, потому что мы предлагаем очень подробные объяснения и включать множество примеров. Будьте уверены, &lt;strong&gt;это не то, что вам нужно читать сверху вниз!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">Если шаблон &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; содержал элемента &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; , любое содержимое, предоставленное между его открывающим и закрывающим тегами, будет отброшено.</target>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">Если аргумент &lt;code&gt;elementOrSelector&lt;/code&gt; не указан , шаблон будет отображаться как элемент вне документа, и вам придется использовать собственный DOM API, чтобы вставить его в документ самостоятельно.</target>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Если &lt;code&gt;isButtonDisabled&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;disabled&lt;/code&gt; атрибут даже не будет включен в отображаемый элемент &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Если я обновлю Vue 2,нужно ли мне также обновить Vuex и Vue Router?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Если бы у Vue не было этого правила, нажатие одной кнопки повлияло бы на данные &lt;em&gt;всех других экземпляров&lt;/em&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Если экземпляр Vue не получил опцию &lt;code&gt;el&lt;/code&gt; при создании, он будет в &amp;laquo;размонтированном&amp;raquo; состоянии без связанного элемента DOM. &lt;code&gt;vm.$mount()&lt;/code&gt; можно использовать для ручного запуска монтирования отключенного экземпляра Vue.</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">Если компонент имеет смысл только в контексте одного родительского компонента,то эта связь должна быть очевидна в его названии.Поскольку редакторы обычно упорядочивают файлы в алфавитном порядке,это также позволяет хранить эти связанные файлы рядом друг с другом.</target>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">Если во время рендеринга компонента возникает ошибка времени выполнения, она будет передана в глобальную &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; конфигурации Vue.config.errorHandler, если она была установлена. Было бы неплохо использовать этот хук вместе с сервисом отслеживания ошибок, таким как &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt; , который обеспечивает &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;официальную интеграцию&lt;/a&gt; для Vue.</target>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">Если даны и событие,и обратный вызов,удалите слушателя только для этого конкретного вызова.</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">Если вместо этого вы намерены условно пропустить выполнение цикла, вы можете поместить &lt;code&gt;v-if&lt;/code&gt; в элемент оболочки (или &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">Если его нужно ввести из свойства с другим именем, используйте &lt;code&gt;from&lt;/code&gt; для обозначения исходного свойства:</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">Если в цепочке наследования или родительской цепочке компонента существует несколько хуков &lt;code&gt;errorCaptured&lt;/code&gt; , все они будут вызываться при одной и той же ошибке.</target>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">Если ни функция &lt;code&gt;render&lt;/code&gt; ни параметр &lt;code&gt;template&lt;/code&gt; не указаны, встроенный в DOM HTML-код монтируемого элемента DOM будет извлечен как шаблон. В этом случае следует использовать сборку Vue Runtime + Compiler.</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">Если переходы / анимация CSS не обнаружены и не предусмотрены перехватчики JavaScript, операции DOM для вставки и / или удаления будут выполняться немедленно в следующем кадре (Примечание: это кадр анимации браузера, отличный от концепции &lt;code&gt;nextTick&lt;/code&gt; во Vue ).</target>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">Если аргументов нет,удалите всех слушателей мероприятия;</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">Если предоставляется только данное мероприятие,удалите всех слушателей для данного мероприятия;</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Если функция render присутствует в опции Vue,то шаблон будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">При необходимости можно получить глубокий клон исходного объекта, передав &lt;code&gt;vm.$data&lt;/code&gt; через &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">Если это так, пожалуйста, создайте вилку репозитория для &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;этих документов&lt;/a&gt; или любой другой официально поддерживаемой документации, а затем приступайте к переводу. Как только вы добьетесь некоторого прогресса, откройте проблему или запрос на вытягивание в основном репозитории, и мы обратимся к другим участникам, которые помогут вам.</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;errorCaptured&lt;/code&gt; сам выдает ошибку, и эта ошибка, и исходная зафиксированная ошибка отправляются в глобальный &lt;code&gt;config.errorHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">Если компонент является функциональным, функция рендеринга также получает дополнительный аргумент &lt;code&gt;context&lt;/code&gt; , который обеспечивает доступ к контекстным данным, поскольку функциональные компоненты не имеют экземпляров.</target>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">Если начальное значение вашего выражения &lt;code&gt;v-model&lt;/code&gt; не соответствует ни одной из опций, элемент &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; будет отображаться в &amp;laquo;невыделенном&amp;raquo; состоянии. В iOS это приведет к тому, что пользователь не сможет выбрать первый элемент, потому что iOS в этом случае не запускает событие изменения. Поэтому рекомендуется указать отключенный параметр с пустым значением, как показано в примере выше.</target>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">Если строка начинается с символа &lt;code&gt;#&lt;/code&gt; , она будет использоваться как querySelector и использовать innerHTML выбранного элемента в качестве строки шаблона. Это позволяет использовать обычный трюк &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; для включения шаблонов.</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">Если компонент перехода предоставил &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;перехватчики JavaScript&lt;/a&gt; , эти перехватчики будут вызываться в соответствующее время.</target>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">Если вы предпочитаете использовать сторонний маршрутизатор, например &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; или &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt; , интеграция &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;также проста&lt;/a&gt; . Вот &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;полный пример&lt;/a&gt; использования Page.js.</target>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">Если эта опция доступна при создании экземпляра, экземпляр немедленно перейдет в режим компиляции; в противном случае пользователю придется явно вызвать &lt;code&gt;vm.$mount()&lt;/code&gt; чтобы вручную запустить компиляцию.</target>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">Если вы также хотите применить переход к начальному рендерингу узла, вы можете добавить атрибут &lt;code&gt;appear&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">Если вы поклонник CSS-in-JS, многие популярные библиотеки CSS-in-JS поддерживают Vue (например, &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; и &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-Emotion&lt;/a&gt; ). Основное различие между React и Vue заключается в том, что метод стилизации по умолчанию в Vue заключается в использовании более знакомых тегов &lt;code&gt;style&lt;/code&gt; в &lt;a href=&quot;single-file-components&quot;&gt;однофайловых компонентах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">Если вы опытный фронтенд-разработчик и хотите узнать, как Vue сравнивается с другими библиотеками / фреймворками, ознакомьтесь со &lt;a href=&quot;guide/comparison&quot;&gt;статьей Сравнение с другими фреймворками&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">Если вы разрабатываете большой проект,работаете с другими разработчиками или иногда включаете HTML/CSS сторонних разработчиков (например,из Auth0),последовательное определение границ проекта гарантирует,что ваши стили будут применяться только к тем компонентам,для которых они предназначены.</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">Если вы знакомы с концепциями Virtual DOM и предпочитаете грубую мощь JavaScript, вы также можете &lt;a href=&quot;render-function&quot;&gt;напрямую писать функции рендеринга&lt;/a&gt; вместо шаблонов с дополнительной поддержкой JSX.</target>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Если вы используете Webpack и предпочитаете разделять файлы JavaScript и шаблонов, вы можете использовать &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt; , который также преобразует файлы шаблонов в функции рендеринга JavaScript на этапе сборки.</target>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">Если вы используете родные Модули ES,существует также сборка,совместимая с Модулями ES:</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">Если вы используете функциональные компоненты на основе шаблонов, вам также придется вручную добавить атрибуты и слушатели. Поскольку у нас есть доступ к индивидуальному содержимому контекста, мы можем использовать &lt;code&gt;data.attrs&lt;/code&gt; для передачи любых HTML-атрибутов и &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;(псевдоним для &lt;code&gt;data.on&lt;/code&gt; )&lt;/em&gt; для передачи любых слушателей событий.</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">Если вы используете полную сборку, то есть напрямую включаете Vue через тег скрипта без инструмента сборки, убедитесь, что вы используете уменьшенную версию ( &lt;code&gt;vue.min.js&lt;/code&gt; ) для производства. Обе версии можно найти в &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Руководстве&lt;/a&gt; по установке .</target>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">Если вы &lt;strong&gt;не&lt;/strong&gt; хотите, чтобы корневой элемент компонента наследовал атрибуты, вы можете установить &lt;code&gt;inheritAttrs: false&lt;/code&gt; в параметрах компонента. Например:</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">Если вы не объявляете &lt;code&gt;message&lt;/code&gt; в параметре данных, Vue предупредит вас, что функция рендеринга пытается получить доступ к несуществующему свойству.</target>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">Если вы обнаружите, что выведение типа или завершение членов не работают, аннотирование определенных методов может помочь решить эти проблемы. Использование параметра &lt;code&gt;--noImplicitAny&lt;/code&gt; поможет найти многие из этих неаннотированных методов.</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Если вам нужно принудительно обновить Vue, в 99,99% случаев вы где-то ошиблись.</target>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">Если вы используете партиалы в важной для производительности части приложения, вам следует перейти на &lt;a href=&quot;render-function#Functional-Components&quot;&gt;функциональные компоненты&lt;/a&gt; . Они должны быть в простом файле JS / JSX (а не в файле &lt;code&gt;.vue&lt;/code&gt; ) и не иметь состояния и экземпляров, как частичные. Это делает рендеринг чрезвычайно быстрым.</target>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">Если у вас есть какие-либо вопросы о том, как вы можете более активно участвовать в жизни местного сообщества Vue, &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;обращайтесь&lt;/a&gt; на @Vuejs_Events !</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">Если у вас есть какие-либо тесты, запустите их и посмотрите, что по-прежнему не работает. Если у вас нет тестов, просто откройте приложение в браузере и следите за предупреждениями или ошибками во время навигации.</target>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">Если вам нужно несколько псевдонимов,вы также можете использовать синтаксис массива:</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">Если вам нужно добавить новые маршруты после создания экземпляра маршрутизатора, вы можете заменить сопоставитель маршрутизатора новым, который включает маршрут, который вы хотите добавить:</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">Если вам нужно скомпилировать шаблоны на клиенте (например, передать строку в параметр &lt;code&gt;template&lt;/code&gt; или подключиться к элементу, используя его HTML-код в DOM в качестве шаблона), вам понадобится компилятор и, следовательно, полная сборка:</target>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">Если вам необходимо программно генерировать маршруты при запуске приложения,вы можете сделать это,динамически проталкивая определения в массив маршрутов.Например:</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно сгруппировать переходы списка, вы можете контролировать время, установив и получив доступ к &lt;code&gt;data-index&lt;/code&gt; (или аналогичному атрибуту) для элемента. См. &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;Пример здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">Если вам нужна только очень простая маршрутизация и вы не хотите использовать полнофункциональную библиотеку маршрутизатора,вы можете сделать это,динамически отрисовав компонент уровня страниц,подобный этому:</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">Если вы снова &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; консоль JavaScript и введете app2.message = 'some new message' , вы снова увидите, что связанный HTML - в данном случае атрибут &lt;code&gt;title&lt;/code&gt; - был обновлен.</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">Если вы предпочитаете API на основе классов при объявлении компонентов, вы можете использовать официально поддерживаемый декоратор &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">Если вы предпочитаете что-то более интерактивное, вы также можете ознакомиться с &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;этой серией руководств по Scrimba&lt;/a&gt; , где вы найдете сочетание скринкастов и площадок для кода, которые вы можете приостановить и поиграть в любое время.</target>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">Если вам действительно нужно переопределить другой &lt;code&gt;!important&lt;/code&gt; , вы должны использовать строковый синтаксис:</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">Если вы действительно хотите многократно дублировать один и тот же элемент/компонент,вы можете сделать это с помощью заводской функции.Например,следующая функция рендеринга является отличным способом отрисовки 20 идентичных параграфов:</target>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">Если вы все еще хотите вызвать функцию разворота внутри обратного вызова,сначала проверьте ее доступность:</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">Однако, если вы попробуете это в своем шаблоне, Vue покажет ошибку, объясняя, что &lt;strong&gt;каждый компонент должен иметь единственный корневой элемент&lt;/strong&gt; . Вы можете исправить эту ошибку, заключив шаблон в родительский элемент, например:</target>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">Если Вы используете в своих шаблонах какие-либо пользовательские элементы,отличные от Vue,например,веб-компонент,то PascalCase гарантирует,что Ваши компоненты Vue останутся отчетливо видимыми.</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">Если вы хотите принудить реквизит,установите вместо него локальное вычисленное значение.Например,вместо:</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">Если вы хотите сразу погрузиться в работу и начать играть с однофайловыми компонентами, ознакомьтесь с &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;этим простым приложением-&lt;/a&gt; делом на CodeSandbox.</target>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">Если вы хотите передать все свойства объекта как свойства, вы можете использовать &lt;code&gt;v-bind&lt;/code&gt; без аргумента ( &lt;code&gt;v-bind&lt;/code&gt; вместо &lt;code&gt;v-bind:prop-name&lt;/code&gt; ). Например, для объекта &lt;code&gt;post&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">Если вместо этого вы хотите зарегистрировать директиву локально, компоненты также принимают параметр &lt;code&gt;directives&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">Если вы хотите, чтобы пользовательский ввод автоматически приводился к типу числа, вы можете добавить модификатор &lt;code&gt;number&lt;/code&gt; к управляемым входам &lt;code&gt;v-model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">Если вы хотите, чтобы пробелы из пользовательского ввода были обрезаны автоматически, вы можете добавить модификатор &lt;code&gt;trim&lt;/code&gt; к входам, управляемым &lt;code&gt;v-model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">Если вы ранее полагались на &lt;code&gt;vm.$watch&lt;/code&gt; чтобы что-то делать с DOM после обновления компонента, вы можете вместо этого сделать это в &lt;code&gt;updated&lt;/code&gt; хуке жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">Если вы хотите также условно переключить класс в списке,вы можете сделать это с помощью тернарного выражения:</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">Если вы хотите узнать больше о Vue перед тем, как погрузиться в него, мы создали видео, в котором рассматриваются основные принципы и пример проекта.</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">Если вы пользователь &lt;strong&gt;Browserify,&lt;/strong&gt; который хотел бы использовать асинхронные компоненты, его создатель, к сожалению, &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;ясно дал понять,&lt;/a&gt; что асинхронная загрузка &amp;laquo;это не то, что Browserify когда-либо будет поддерживать&amp;raquo;. По крайней мере, официально. Сообщество Browserify нашло &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;несколько обходных путей&lt;/a&gt; , которые могут быть полезны для существующих и сложных приложений. Для всех других сценариев мы рекомендуем использовать Webpack для встроенной первоклассной поддержки async.</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">Если вы работаете с React, вам может быть интересно, как vuex сравнивается с &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt; , самой популярной реализацией Flux в этой экосистеме. Redux фактически не зависит от уровня представления, поэтому его можно легко использовать с Vue с помощью &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;простых привязок&lt;/a&gt; . Vuex отличается тем, что &lt;em&gt;знает,&lt;/em&gt; что находится в приложении Vue. Это позволяет ему лучше интегрироваться с Vue, предлагая более интуитивно понятный API и улучшенный опыт разработки.</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">Если вы не будете осторожны, рекурсивные компоненты также могут привести к бесконечным циклам:</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">Если вы не используете модульную систему с &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; , вы, вероятно, можете пока пропустить этот раздел. Если да, у нас есть специальные инструкции и советы специально для вас.</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">Если вы еще не знакомы с компонентами Vue, вы можете пропустить это сейчас.</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">Если вы все еще здесь, то, вероятно, вы используете модульную систему, например, с Babel и Webpack. В этих случаях мы рекомендуем создать каталог &lt;code&gt;components&lt;/code&gt; , в котором каждый компонент находится в отдельном файле.</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">Если вы пишете много функций &lt;code&gt;render&lt;/code&gt; , вам может быть больно писать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">Если вашей директиве нужно несколько значений,то вы также можете передать их в литературе объекта JavaScript.Помните,что директивы могут принимать любые допустимые выражения JavaScript.</target>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">Представьте, что это шаблон для &lt;code&gt;bootstrap-date-input&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">Неявное общение между родителями и детьми</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">Неявное общение между родителями и детьми следует &lt;sup&gt;использовать с осторожностью&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">В 2.2.0+ и выше, &lt;code&gt;activated&lt;/code&gt; и &lt;code&gt;deactivated&lt;/code&gt; будут срабатывать для всех вложенных компонентов внутри дерева &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">В версии 2.2.0+ эта ловушка также фиксирует ошибки в хуках жизненного цикла компонентов. Кроме того, когда этот перехватчик не &lt;code&gt;undefined&lt;/code&gt; , захваченные ошибки будут регистрироваться с помощью &lt;code&gt;console.error&lt;/code&gt; вместо сбоя приложения.</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">В версии 2.2.0+ при использовании &lt;code&gt;v-for&lt;/code&gt; с компонентом теперь требуется &lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">В версии 2.4.0+этот крючок также перехватывает ошибки,брошенные внутри обработчиков событий Vue.</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">В 2.5.0+инъекции могут быть опциональными со значением по умолчанию:</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">В версии 2.5.0+, если вы используете однофайловые &lt;a href=&quot;single-file-components&quot;&gt;компоненты&lt;/a&gt; , функциональные компоненты на основе шаблонов могут быть объявлены с помощью:</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">В версии 2.6+ &lt;code&gt;v-for&lt;/code&gt; также может работать со значениями, реализующими &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt; , включая собственные &lt;code&gt;Map&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt; . Однако следует отметить, что Vue 2.x в настоящее время не поддерживает реактивность &lt;code&gt;Set&lt;/code&gt; значений &lt;code&gt;Map&lt;/code&gt; и Set , поэтому не может автоматически обнаруживать изменения.</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">В версии 2.6.0+ этот перехватчик также перехватывает ошибки, возникающие в слушателях &lt;code&gt;v-on&lt;/code&gt; DOM. Вдобавок, если какой-либо из охваченных хуков или обработчиков возвращает цепочку обещаний (например, асинхронные функции), ошибка из этой цепочки обещаний также будет обработана.</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">В версии 2.6.0 мы представили новый унифицированный синтаксис ( директива &lt;code&gt;v-slot&lt;/code&gt; ) для именованных и ограниченных слотов. Он заменяет атрибуты &lt;code&gt;slot&lt;/code&gt; и &lt;code&gt;slot-scope&lt;/code&gt; , которые теперь устарели, но &lt;em&gt;не&lt;/em&gt; были удалены и все еще задокументированы &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;здесь&lt;/a&gt; . Обоснование введения нового синтаксиса описано в этом &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">В &lt;a href=&quot;../guide/single-file-components&quot;&gt;компонентах одного файла&lt;/a&gt; , &lt;code&gt;scoped&lt;/code&gt; стили не будут применяться к содержимому внутри &lt;code&gt;v-html&lt;/code&gt; , потому что HTML не обрабатываются шаблон компилятором Vue в. Если вы хотите настроить таргетинг на &lt;code&gt;v-html&lt;/code&gt; - контент с помощью CSS с ограниченной областью видимости, вы можете вместо этого использовать &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модули CSS&lt;/a&gt; или дополнительный глобальный элемент &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; с ручной стратегией определения области, например БЭМ.</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">В JavaScript,PascalCase является соглашением для классов и конструкторов прототипов-по сути,все,что может иметь отдельные экземпляры.Компоненты Vue также имеют экземпляры,поэтому имеет смысл использовать PascalCase.Как дополнительное преимущество,использование PascalCase в JSX (и шаблонах)позволяет читателям кода легче различать компоненты и HTML-элементы.</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">В JavaScript разделение объектов с несколькими свойствами на несколько строк широко считается хорошим соглашением, потому что его гораздо легче читать. Наши шаблоны и &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; заслуживают того же внимания.</target>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">В компании Polymer команда также сделала свою систему привязки данных очень ограниченной для того,чтобы компенсировать производительность.Например,единственными выражениями,поддерживаемыми в шаблонах Polymer,являются булевое отрицание и вызовы одиночных методов.Его вычислительная реализация свойств также не очень гибкая.</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">В React,все компоненты выражают свой пользовательский интерфейс внутри рендер-функций,используя JSX,декларативный XML-подобный синтаксис,который работает внутри JavaScript.</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">На самом деле,все это просто JavaScript.Мало того,что HTML-структуры выражаются через JSX,последние тенденции также имеют тенденцию помещать CSS-управление внутри JavaScript.Такой подход имеет свои преимущества,но и поставляется с различными компромиссами,которые могут показаться не очень выгодными для каждого разработчика.</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">В React, когда состояние компонента изменяется, он запускает повторный рендеринг всего поддерева компонента, начиная с этого компонента как корневого. Чтобы избежать ненужного повторного рендеринга дочерних компонентов, вам нужно либо использовать &lt;code&gt;PureComponent&lt;/code&gt; , либо реализовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , когда это возможно. Вам также может потребоваться использовать неизменяемые структуры данных, чтобы сделать изменения вашего состояния более удобными для оптимизации. Однако в некоторых случаях вы не сможете полагаться на такую ​​оптимизацию, потому что &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; предполагает, что вывод рендеринга всего поддерева определяется свойствами текущего компонента. Если это не так, то такая оптимизация может привести к несогласованному состоянию DOM.</target>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">В Vue 2.x &lt;code&gt;Vue.observable&lt;/code&gt; напрямую изменяет переданный ему объект, чтобы он был эквивалентен возвращаемому объекту, как &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;показано здесь&lt;/a&gt; . В Vue 3.x вместо этого будет возвращен реактивный прокси, оставляя исходный объект не реактивным при непосредственном изменении. Поэтому для будущей совместимости мы рекомендуем всегда работать с объектом, возвращаемым &lt;code&gt;Vue.observable&lt;/code&gt; , а не с первоначально переданным ему объектом.</target>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">В Vue компонент,по сути,является экземпляром Vue с предустановленными опциями.Регистрация компонента в Vue проста:</target>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Во Vue зависимости компонента автоматически отслеживаются во время его рендеринга, поэтому система точно знает, какие компоненты действительно нужно повторно рендерить при изменении состояния. Можно считать, что каждый компонент должен автоматически реализовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , без оговорок о вложенных компонентах.</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Во Vue у нас также есть &lt;a href=&quot;render-function&quot;&gt;функции рендеринга&lt;/a&gt; и даже &lt;a href=&quot;render-function#JSX&quot;&gt;поддержка JSX&lt;/a&gt; , потому что иногда вам действительно нужна такая мощь. Однако по умолчанию мы предлагаем шаблоны как более простую альтернативу. Любой допустимый HTML-код также является допустимым шаблоном Vue, и это дает несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">В Webpack 4+ вы можете использовать опцию &lt;code&gt;mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">В большом приложении необходимо разделить все приложение на компоненты, чтобы сделать разработку управляемой. Мы еще поговорим о компонентах &lt;a href=&quot;guide/components&quot;&gt;позже в руководстве&lt;/a&gt; , но вот (воображаемый) пример того, как шаблон приложения может выглядеть с компонентами:</target>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">Однако в типичном приложении у вас, скорее всего, будет массив сообщений в &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">В дополнение к свойствам данных, экземпляры Vue предоставляют ряд полезных свойств и методов экземпляра. Они имеют префикс &lt;code&gt;$&lt;/code&gt; , чтобы отличать их от свойств, определяемых пользователем. Например:</target>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">В дополнение к текстовой интерполяции,мы также можем связать атрибуты элементов таким образом:</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">В дополнение к опции &lt;code&gt;watch&lt;/code&gt; вы также можете использовать императивный &lt;a href=&quot;../api/index#vm-watch&quot;&gt;API vm. $ Watch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">В дополнение к стандартному набору директив, поставляемых в ядре ( &lt;code&gt;v-model&lt;/code&gt; и &lt;code&gt;v-show&lt;/code&gt; ), Vue также позволяет вам регистрировать свои собственные пользовательские директивы. Обратите внимание, что в Vue 2.0 основной формой повторного использования и абстракции кода являются компоненты, однако могут быть случаи, когда вам понадобится некоторый низкоуровневый доступ к DOM для простых элементов, и именно здесь пользовательские директивы по-прежнему будут полезны. Примером может быть элемент ввода, например этот:</target>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">Кроме того, &lt;code&gt;type&lt;/code&gt; также может быть функцией настраиваемого конструктора, и утверждение будет выполняться с проверкой &lt;code&gt;instanceof&lt;/code&gt; . Например, если существует следующая функция-конструктор:</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">Кроме того,каждый экземпляр/компонент все еще может владеть и управлять своим собственным частным состоянием:</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">Кроме того, каждый раз, когда обновляется родительский компонент, все свойства дочернего компонента будут обновляться до последнего значения. Это означает, что вы &lt;strong&gt;не&lt;/strong&gt; должны пытаться &lt;strong&gt;изменить&lt;/strong&gt; опору внутри дочернего компонента. Если вы это сделаете, Vue предупредит вас в консоли.</target>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">Если вы еще не заметили, Vue выполняет обновления DOM &lt;strong&gt;асинхронно&lt;/strong&gt; . Всякий раз, когда наблюдается изменение данных, он открывает очередь и буферизует все изменения данных, которые происходят в том же цикле событий. Если один и тот же наблюдатель запускается несколько раз, он будет помещен в очередь только один раз. Эта буферизованная дедупликация важна для предотвращения ненужных вычислений и манипуляций с DOM. Затем в следующем цикле событий &amp;laquo;тик&amp;raquo; Vue очищает очередь и выполняет фактическую (уже удаленную) работу. Внутренне Vue пробует собственные &lt;code&gt;Promise.then&lt;/code&gt; , &lt;code&gt;MutationObserver&lt;/code&gt; и &lt;code&gt;setImmediate&lt;/code&gt; для асинхронной организации очереди и возвращается к &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">Если вы предпочитаете настраивать собственную сборку с нуля, вам нужно будет вручную настроить webpack с помощью &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt; . Чтобы узнать больше о самом webpack, ознакомьтесь с &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;их официальной документацией&lt;/a&gt; и &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">В случаях, подобных описанным выше, когда контент предоставляется &lt;em&gt;только&lt;/em&gt; для слота по умолчанию, теги компонента могут использоваться в качестве шаблона слота. Это позволяет нам использовать &lt;code&gt;v-slot&lt;/code&gt; непосредственно в компоненте:</target>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">В таких случаях мы можем пометить компоненты как &lt;code&gt;functional&lt;/code&gt; , что означает, что они не имеют состояния (без &lt;a href=&quot;../api/index#Options-Data&quot;&gt;реактивных данных&lt;/a&gt; ) и без экземпляров (без &lt;code&gt;this&lt;/code&gt; контекста). А &lt;strong&gt;функциональный компонент&lt;/strong&gt; выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">В коде фиксации определения опоры всегда должны быть как можно более подробными,с указанием,по крайней мере,типа(ов).</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">Для сравнения, &lt;code&gt;v-show&lt;/code&gt; намного проще - элемент всегда отображается независимо от начального состояния с переключением на основе CSS.</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">Для сравнения: вызов метода &lt;strong&gt;всегда&lt;/strong&gt; запускает функцию всякий раз, когда происходит повторный рендеринг.</target>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">В процессе разработки Vue предупредит вас,если компонент когда-нибудь будет предоставлен неверно отформатированный реквизит,что поможет вам поймать потенциальные источники ошибок.</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">В каждом подкомпоненте &lt;code&gt;new Vue&lt;/code&gt; экземпляра Vue к этому корневому экземпляру можно получить доступ с помощью свойства &lt;code&gt;$root&lt;/code&gt; . Например, в этом корневом экземпляре:</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">Фактически, вы можете думать о внедрении зависимостей как о своего рода &amp;laquo;дальнобойных опорах&amp;raquo;, за исключением:</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">В общем, всякий раз, когда что-то может быть достигнуто с помощью простого JavaScript, мы не хотим вводить специальный синтаксис, такой как фильтры, чтобы решить ту же проблему. Вот как вы можете заменить встроенные фильтры директив Vue:</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">В больших приложениях нам может потребоваться разделить приложение на более мелкие части и загружать компонент с сервера только тогда, когда это необходимо. Чтобы упростить это, Vue позволяет вам определить ваш компонент как фабричную функцию, которая асинхронно разрешает определение вашего компонента. Vue будет запускать фабричную функцию только тогда, когда компонент нужно отрендерить, и кэширует результат для будущих повторных отрисовок. Например:</target>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">Во многих проектах Vue глобальные компоненты будут определяться с помощью &lt;code&gt;Vue.component&lt;/code&gt; , за которым следует &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; для нацеливания на элемент контейнера в теле каждой страницы.</target>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">Однако во многих случаях вы все равно &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; странным поведением (например, 0,035.toFixed (2) округляет до &lt;code&gt;0.04&lt;/code&gt; , а &lt;code&gt;0.045&lt;/code&gt; округляется до &lt;code&gt;0.04&lt;/code&gt; ). Чтобы обойти эти проблемы, вы можете использовать &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt; библиотеку для более надежного форматирования валют.</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">Во многих случаях вам может потребоваться такое же поведение при &lt;code&gt;bind&lt;/code&gt; и &lt;code&gt;update&lt;/code&gt; , но не заботиться о других хуках. Например:</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">В большинстве случаев Vue может автоматически определить, когда переход завершен. По умолчанию Vue ожидает первого события &lt;code&gt;transitionend&lt;/code&gt; или &lt;code&gt;animationend&lt;/code&gt; в корневом элементе перехода. Однако это не всегда может быть желательным - например, у нас может быть хореографическая последовательность переходов, в которой некоторые вложенные внутренние элементы имеют отложенный переход или более длительную продолжительность перехода, чем корневой переходный элемент.</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">В большинстве случаев лучше избегать обращения к другим экземплярам компонентов или ручного манипулирования элементами DOM. Однако есть случаи, когда это может быть целесообразным.</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">В большинстве случаев,обращение к родителю затрудняет отладку и понимание вашего приложения,особенно если вы мутируете данные в родителе.При последующем рассмотрении этого компонента будет очень сложно понять,откуда взялась эта мутация.</target>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">В естественном английском языке прилагательные и другие дескрипторы обычно появляются перед существительными,в то время как исключения требуют соединительных слов.Например:</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">В обычных случаях вам не нужно вызывать этот метод самостоятельно. Предпочитайте управлять жизненным циклом дочерних компонентов на основе данных с помощью &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">В нашем случае, давайте укажем на компонент &lt;code&gt;tree-folder&lt;/code&gt; . Мы знаем, что дочерним элементом, который создает парадокс, является компонент &lt;code&gt;tree-folder-contents&lt;/code&gt; , поэтому мы подождем, пока &lt;code&gt;beforeCreate&lt;/code&gt; жизненного цикла beforeCreate не зарегистрирует его:</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">По нашему опыту, лучше &lt;em&gt;всегда&lt;/em&gt; добавлять уникальный ключ, чтобы вам и вашей команде просто не приходилось беспокоиться об этих крайних случаях. Затем в редких, критичных к производительности сценариях, когда постоянство объекта не требуется, вы можете сделать сознательное исключение.</target>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">В ситуациях, когда вычисленные свойства невозможны (например, внутри вложенных циклов &lt;code&gt;v-for&lt;/code&gt; ), вы можете использовать метод:</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">В некоторых случаях нам может потребоваться &amp;laquo;двусторонняя привязка&amp;raquo; для опоры. К сожалению, истинная двусторонняя привязка может создать проблемы с обслуживанием, поскольку дочерние компоненты могут изменять родительский элемент, при этом источник этой мутации не является очевидным как для родительского, так и для дочернего компонентов.</target>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">В таких случаях вы можете указать явную продолжительность перехода (в миллисекундах), используя свойство &lt;code&gt;duration&lt;/code&gt; в компоненте &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">В этом случае прослушиватель &lt;code&gt;.native&lt;/code&gt; в родительском элементе будет молча прерван . &lt;code&gt;onFocus&lt;/code&gt; не будет , но обработчик onFocus не будет вызван, когда мы этого ожидали.</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">В &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;каталоге &lt;/a&gt; &lt;code&gt;dist/&lt;/code&gt; пакета NPM вы найдете множество различных сборок Vue.js. Вот обзор разницы между ними:</target>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере обработчик будет вызываться только в том случае, если &lt;code&gt;$event.key&lt;/code&gt; равно &lt;code&gt;'PageDown'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">В случае булевых атрибутов, где их простое существование подразумевает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;v-bind&lt;/code&gt; работает немного иначе. В этом примере:</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">В консоли введите &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; . Вы должны увидеть новый элемент, добавленный к списку.</target>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;currentTabComponent&lt;/code&gt; может содержать:</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">В приведенном выше примере либо атрибут &amp;laquo; &lt;code&gt;appear&lt;/code&gt; , либо хук &lt;code&gt;v-on:appear&lt;/code&gt; вызовет переход &amp;laquo;появление&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">В будущем вы можете обратиться к &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;справочнику&lt;/a&gt; по API для получения полного списка свойств и методов экземпляра.</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">В родительском &lt;code&gt;postFontSize&lt;/code&gt; мы можем поддерживать эту функцию, добавив свойство данных postFontSize :</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">В двух приведенных выше примерах мы передаем строковые значения, но на самом деле в опору можно передать значение &lt;em&gt;любого&lt;/em&gt; типа.</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">В этих случаях вы также можете использовать &lt;code&gt;key&lt;/code&gt; атрибут для перехода между разными состояниями одного и того же элемента. Вместо использования &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-else&lt;/code&gt; приведенный выше пример можно переписать как:</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">В этих случаях вы можете определить ваши компоненты как простые JavaScript-объекты:</target>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">В этом случае &lt;code&gt;filterA&lt;/code&gt; , определенный с одним аргументом, получит значение &lt;code&gt;message&lt;/code&gt; , а затем будет &lt;code&gt;filterB&lt;/code&gt; функция filterB с результатом &lt;code&gt;filterA&lt;/code&gt; , переданным в единственный аргумент &lt;code&gt;filterB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">В этом случае для &lt;code&gt;class&lt;/code&gt; определены два разных значения :</target>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">В этом случае использование опции &lt;code&gt;watch&lt;/code&gt; позволяет нам выполнять асинхронную операцию (доступ к API), ограничивать частоту выполнения этой операции и устанавливать промежуточные состояния до тех пор, пока мы не получим окончательный ответ. Ничего из этого было бы невозможно с вычисляемым свойством.</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">В этом компоненте всем потомкам &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; нужен доступ к методу &lt;code&gt;getMap&lt;/code&gt; , чтобы знать, с какой картой взаимодействовать. К сожалению, использование свойства &lt;code&gt;$parent&lt;/code&gt; плохо масштабировалось для более глубоко вложенных компонентов. Вот где может быть полезно внедрение зависимостей с использованием двух новых параметров экземпляра: &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">В этом примере мы решили назвать объект, содержащий все наши реквизиты &lt;code&gt;slotProps&lt;/code&gt; , slotProps , но вы можете использовать любое имя, какое захотите.</target>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">В этом примере, когда значение &lt;code&gt;eventName&lt;/code&gt; равно &lt;code&gt;&quot;focus&quot;&lt;/code&gt; , &lt;code&gt;v-on:[eventName]&lt;/code&gt; будет эквивалентно &lt;code&gt;v-on:focus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">Выражения внутри шаблона очень удобны,но предназначены для простых операций.Слишком много логики в ваших шаблонах может сделать их раздутыми и сложными в обслуживании.Например:</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">Отдельные узлы</target>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">Информация для разработчиков реакторов</target>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">Интернет-шаблоны</target>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">Внутри блоков &lt;code&gt;v-for&lt;/code&gt; у нас есть полный доступ к свойствам родительской области. &lt;code&gt;v-for&lt;/code&gt; также поддерживает необязательный второй аргумент для индекса текущего элемента.</target>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Установите плагин Vue.js. Если плагин является объектом, он должен предоставлять метод &lt;code&gt;install&lt;/code&gt; . Если это сама функция, она будет рассматриваться как метод установки. Будет вызван метод установки с аргументом Vue.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">Экземпляр DOM-параметры</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">Крюки для жизненного цикла</target>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">Экземпляры Методы/Данные</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">Экстраординационные методы/события</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">Экстраординарные методы/Жизненный цикл</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">Свойства вещества</target>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">Вместо вычисляемого свойства мы можем определить ту же функцию как метод. Для конечного результата эти два подхода действительно абсолютно одинаковы. Однако разница в том, что &lt;strong&gt;вычисляемые свойства кэшируются на основе их реактивных зависимостей. &lt;/strong&gt;Вычисляемое свойство будет повторно оцениваться только после изменения некоторых его реактивных зависимостей. Это означает, что, пока &lt;code&gt;message&lt;/code&gt; не изменилось, множественный доступ к вычисляемому свойству &lt;code&gt;reversedMessage&lt;/code&gt; немедленно вернет ранее вычисленный результат без необходимости повторного запуска функции.</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">Вместо привязки непосредственно к названию метода,мы можем также использовать методы в встроенном операторе JavaScript:</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">Вместо того, чтобы жестко кодировать содержимое для каждой задачи, мы можем позволить родительскому компоненту взять на себя управление, сделав каждую задачу в слот, а затем &lt;code&gt;todo&lt;/code&gt; как свойство слота:</target>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">Вместо использования этого интерфейса для отслеживания событий, &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; самим хранилищем (например, store.on ('mutation', callback) ), вводится новый метод &lt;code&gt;store.subscribe&lt;/code&gt; . Типичное использование внутри плагина:</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">Вместо этого &lt;strong&gt;параметр &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;data&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; компонента должен быть функцией&lt;/strong&gt; , чтобы каждый экземпляр мог поддерживать независимую копию возвращаемого объекта данных:</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">Вместо этого,извлекайте реактивные данные напрямую.</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">Вместо этого мы рекомендуем объединить два префикса в &lt;code&gt;$_&lt;/code&gt; в качестве соглашения для определяемых пользователем частных свойств, которые гарантируют отсутствие конфликтов с Vue.</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">Вместо этого мы хотим,чтобы каждый экземпляр компонента управлял только своими данными.Для этого каждый экземпляр должен сгенерировать уникальный объект данных.В JavaScript это можно сделать,вернув объект в функцию:</target>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">Вместо этого,вы должны всегда указывать имя слота,если вы хотите использовать сокращение:</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">Вместо этого вы должны использовать массив &lt;strong&gt;объектов,&lt;/strong&gt; чтобы &lt;code&gt;v-model&lt;/code&gt; могла обновлять поле объекта. Например:</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">Интеграция сторонних маршрутизаторов</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">Интересно,что существует довольно много сходства в том,как Angular и Vue решают эти вопросы AngularJS.</target>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">Внутренне скопированные слоты работают,обертывая содержимое слота в функцию,передающую один единственный аргумент:</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">Интерполяция &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; полей ( &amp;lt;textarea&amp;gt; {{text}} &amp;lt;/textarea&amp;gt; ) не работает. Вместо этого используйте &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Интерполяция в атрибутах &lt;sup&gt;удалена.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">Интерполяция внутри атрибутов больше недействительна.Например:</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">Кроме того,это значительно облегчает дизайнерам и менее опытным разработчикам анализ и внесение вклада в разработку кодовой базы.</target>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">Его также можно использовать для принудительной замены элемента/компонента вместо повторного использования.Это может быть полезно,когда вы этого хотите:</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">Он не может создавать проекты из пользовательских &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;предустановок&lt;/a&gt; , что может быть особенно полезно для корпоративных сред с заранее установленными соглашениями.</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">Это зависит от нескольких факторов:</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Он не допускает никакой конфигурации во время генерации проекта, в то время как Vue CLI работает поверх обновляемой зависимости времени выполнения, которая может быть расширена с помощью &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;плагинов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">Обычно перемещение по вложенным подкаталогам занимает больше времени, чем прокрутка отдельного каталога &lt;code&gt;components&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">Очень часто необходимо вызывать &lt;code&gt;event.preventDefault()&lt;/code&gt; или &lt;code&gt;event.stopPropagation()&lt;/code&gt; внутри обработчиков событий. Хотя мы можем легко сделать это внутри методов, было бы лучше, если бы методы могли быть связаны исключительно с логикой данных, а не иметь дело с деталями событий DOM.</target>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">Также можно добавить &amp;laquo;блок else&amp;raquo; с помощью &lt;code&gt;v-else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">Больше не поддерживается использование &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; с тем же именем в одном шаблоне. Когда слот визуализируется, он &amp;laquo;израсходован&amp;raquo; и не может быть визуализирован где-либо еще в том же дереве визуализации. Если вам необходимо отобразить один и тот же контент в нескольких местах, передайте это содержимое как опору.</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">Теперь запрещено заменять root $ data экземпляра компонента. Это предотвращает некоторые крайние случаи в системе реактивности и делает состояние компонента более предсказуемым (особенно с системами проверки типов).</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">Часто бывает хорошей идеей связать с объектом стиля напрямую так,чтобы шаблон был чище:</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Часто упускается из виду, что источником истины в приложениях Vue является необработанный объект &lt;code&gt;data&lt;/code&gt; - экземпляр Vue только передает к нему доступ. Следовательно, если у вас есть часть состояния, которая должна совместно использоваться несколькими экземплярами, вы можете поделиться ею по идентификатору:</target>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">Рекомендуется по возможности предоставлять &lt;code&gt;key&lt;/code&gt; атрибут с &lt;code&gt;v-for&lt;/code&gt; , если только повторяющееся содержимое DOM не является простым или если вы намеренно не полагаетесь на поведение по умолчанию для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">В основном это работает хорошо, но отложенные обновления состояния могут вызвать странное поведение. Например, щелкните вкладку &amp;laquo; &lt;code&gt;Result&lt;/code&gt; &amp;raquo; и попробуйте ввести &lt;code&gt;9.999&lt;/code&gt; в один из этих входов. Когда вход теряет фокус, его значение обновляется до &lt;code&gt;$10.00&lt;/code&gt; . Однако, посмотрев на рассчитанную сумму, вы увидите, что &lt;code&gt;9.999&lt;/code&gt; - это то, что хранится в наших данных. Версия реальности, которую видит пользователь, не синхронизирована!</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">Он предлагает только один шаблон, который предполагает, что вы создаете одностраничное приложение, в то время как Vue предлагает широкий спектр параметров по умолчанию для различных целей и систем сборки.</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">Для этого требуется сохранить &lt;code&gt;picker&lt;/code&gt; в экземпляре компонента, если возможно, что доступ к нему потребуется только хукам жизненного цикла. Это не страшно, но это можно считать беспорядком.</target>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">Следует отметить, что &lt;strong&gt;это ограничение &lt;em&gt;не&lt;/em&gt; применяется, если вы используете строковые шаблоны из одного из следующих источников&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">Он сделает:</target>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">На самом деле можно переходить между любым количеством элементов, используя несколько &lt;code&gt;v-if&lt;/code&gt; или привязав один элемент к динамическому свойству. Например:</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">Также неплохо явно добавить &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; для переходов только для JavaScript, чтобы Vue мог пропустить обнаружение CSS. Это также предотвращает случайное вмешательство правил CSS в переход.</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">Обычно приложение организовано в виде дерева вложенных компонентов:</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">Проще найти реализации функций обработчика в коде JS, просмотрев HTML-шаблон.</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">Также легко переключить наличие элемента:</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">Важно отметить, что многие из этих ограничений являются намеренными дизайнерскими решениями, принимаемыми командой create-react-app, и у них есть свои преимущества. Например, если потребности вашего проекта очень просты и вам никогда не нужно &amp;laquo;извлекать&amp;raquo; для настройки процесса сборки, вы сможете обновить его как зависимость. Вы можете узнать больше о &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;различных философиях здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">Важно отметить, что вы никогда не должны заменять исходный объект состояния в своих действиях - компоненты и хранилище должны совместно использовать ссылку на один и тот же объект, чтобы можно было наблюдать мутации.</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">В JavaScript редко когда-либо упоминаются глобальные компоненты, поэтому соблюдение соглашения для JavaScript не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">Рекомендуется обернуть все содержимое в новый элемент, например:</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">Иногда бывает полезно передать определенное значение с событием. Например, мы можем захотеть, чтобы компонент &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; отвечал за то, на сколько увеличивать текст. В таких случаях мы можем использовать второй параметр &lt;code&gt;$emit&lt;/code&gt; для предоставления этого значения:</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX против Шаблонов</target>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScript Hooks</target>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">Собственный &lt;code&gt;.filter&lt;/code&gt; JavaScript также может управлять гораздо более сложными операциями фильтрации, поскольку у вас есть доступ ко всей мощи JavaScript в рамках вычисляемых свойств. Например, если вы хотите найти всех активных пользователей и сопоставить их имя и адрес электронной почты без учета регистра:</target>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Присоединяйтесь к сообществу Vue.js!</target>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">Как и в случае с элементами HTML, часто бывает полезно иметь возможность передавать контент в компонент, например:</target>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">Просто для поддержки относительно небольшой разметки в шаблоне:</target>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">Однако имейте в виду, что компоненты, построенные по этому шаблону, все еще хрупки по своей природе. Например, представьте, что мы добавляем новый компонент &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; , и когда в нем появляется &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; , он должен отображать только маркеры, попадающие в эту область:</target>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">Ключевые коды</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">Ключевые модификаторы</target>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Keyed &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;essential&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">Ключ v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">Knockout был пионером в области MVVM и отслеживания зависимостей, и его система реактивности очень похожа на Vue. Его &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;поддержка браузером&lt;/a&gt; также очень впечатляет, учитывая все, что он делает, с поддержкой IE6! Vue, с другой стороны, поддерживает только IE9 +.</target>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">Большие приложения часто могут усложняться из-за множества частей состояния, разбросанных по многим компонентам, и взаимодействия между ними. Чтобы решить эту проблему, Vue предлагает &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt; : нашу собственную библиотеку управления состоянием, вдохновленную Elm. Он даже интегрируется в &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; , обеспечивая нулевой доступ к настройке для &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;отладки&lt;/a&gt; во времени .</target>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Наконец, стили в однофайловых компонентах Vue очень гибкие. С помощью &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt; вы можете использовать любой препроцессор, постпроцессор и даже глубокую интеграцию с &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модулями CSS&lt;/a&gt; - все в элементе &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">Последняя стабильная версия:2.6.10</target>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о внедрении зависимостей см. В документации &lt;a href=&quot;../api/index#provide-inject&quot;&gt;по API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">Кривая обучения</target>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">Давайте погрузимся в простой пример, в котором функция &lt;code&gt;render&lt;/code&gt; будет практичной. Предположим, вы хотите создать привязанные заголовки:</target>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">Допустим, у вас есть список задач:</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">Допустим, вы хотите создать специальную директиву, которая позволяет закреплять элементы на странице с помощью фиксированного позиционирования. Мы могли бы создать специальную директиву, значение которой обновляет вертикальное позиционирование в пикселях, например:</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Допустим, вы строите дерево каталогов файлов, как в Finder или File Explorer. У вас может быть компонент &lt;code&gt;tree-folder&lt;/code&gt; с этим шаблоном:</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">Диаграмма жизненного цикла</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">События жизненного цикла (в порядке их наименования)</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">Крюки для жизненного цикла</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">Внесение в список/вынесение из него Переходы</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">Список Перемещение Переходы</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">Рендеринг списка</target>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">Список Переходов</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">Прослушивание настраиваемого события на текущей виртуальной машине. События могут запускаться с помощью &lt;code&gt;vm.$emit&lt;/code&gt; . Обратный вызов получит все дополнительные аргументы, переданные этим методам запуска событий.</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">Слушайте пользовательское мероприятие,но только один раз.Слушатель будет удален после первого срабатывания.</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">Слушайте событие только один раз с помощью &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">Прослушивание события с помощью &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Прослушивание собственных событий на компонентах с &lt;sup&gt;измененным &lt;/sup&gt; &lt;code&gt;v-on&lt;/code&gt; &lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">Прослушивание детских компонентов События</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">Прослушивание событий</target>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">Прослушивание пользовательских событий в дочернем компоненте (обработчик вызывается, когда дочерний компонент генерирует &amp;laquo;my-event&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">Прослушивание версии на базе кебабаба не даст никакого эффекта:</target>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">Локальная регистрация</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">Локальная регистрация в модульной системе</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">Логика теперь отделена от уровня представления,что значительно облегчает обслуживание (изменение/расширение логики).</target>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">Поддержание государства</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Заставьте Vue игнорировать пользовательские элементы, определенные вне Vue (например, с помощью API веб-компонентов). В противном случае будет выдано предупреждение о &lt;code&gt;Unknown custom element&lt;/code&gt; , если вы забыли зарегистрировать глобальный компонент или неправильно написали имя компонента.</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">Сделайте объект реактивным. Внутри Vue использует это для объекта, возвращаемого функцией &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">Убедитесь в том , чтобы прочитать о &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;различных сборках Vue&lt;/a&gt; и использовать &lt;strong&gt;производственную &lt;br/&gt;версию&lt;/strong&gt; в опубликованном сайте, заменив &lt;code&gt;vue.js&lt;/code&gt; с &lt;code&gt;vue.min.js&lt;/code&gt; . Это меньшая сборка, оптимизированная для скорости, а не для удобства разработки.</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">Управление множеством переходов между состояниями может быстро усложнить экземпляр или компонент Vue. К счастью, многие анимации можно выделить в специальные дочерние компоненты. Сделаем это с анимированным целым числом из нашего предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">Управление состоянием &lt;code&gt;this.$root&lt;/code&gt; и / или использование &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;глобальной шины событий&lt;/a&gt; может быть удобным для очень простых случаев, но не подходит для большинства приложений. Vuex предлагает не только центральное место для управления состоянием, но также инструменты для организации, отслеживания и отладки изменений состояния.</target>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">Манипулировать детьми,реквизитом или данными перед передачей их детскому компоненту.</target>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">Множество файлов со схожими именами,что затрудняет быстрое переключение файлов в редакторах кода.</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">Множество вложенных подкаталогов, что увеличивает время, необходимое для просмотра компонентов на боковой панели редактора.</target>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">Многие из ваших компонентов будут относительно общими, возможно, только для обертывания элемента, такого как ввод или кнопка. Мы иногда называем их &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;базовыми компонентами,&lt;/a&gt; и они, как правило, очень часто используются в ваших компонентах.</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">Отображение массива на элементы с помощью &lt;code&gt;v-for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">Мета-методы инстанций</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">Обработчики событий метода</target>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">Методы в онлайн обработчиках</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Методы, которые нужно добавить в экземпляр Vue. Вы можете получить доступ к этим методам непосредственно на экземпляре виртуальной машины или использовать их в выражениях директив. Контекст &lt;code&gt;this&lt;/code&gt; у всех методов будет автоматически привязан к экземпляру Vue.</target>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Промежуточное ПО &lt;sup&gt;заменено&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">Среднее оборудование заменяется плагинами.Плагин-это функция,которая принимает хранилище в качестве единственного аргумента и может прослушивать событие мутации на хранилище:</target>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Миграция с Vue 1.x</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Миграция с маршрутизатора Vue Router 0.7.x</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Миграция с Vuex 0.6.x на 1.0</target>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Перехватчики Mixin вызываются в том порядке, в котором они указаны, и вызываются перед собственными перехватчиками компонента.</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Миксины - это гибкий способ распространять повторно используемые функции для компонентов Vue. Объект миксина может содержать любые параметры компонента. Когда компонент использует миксин, все параметры миксина будут &amp;laquo;смешаны&amp;raquo; с собственными опциями компонента.</target>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX стал довольно популярным в сообществе React и фактически использует систему реактивности, почти идентичную Vue. В некоторой степени рабочий процесс React + MobX можно рассматривать как более подробный Vue, поэтому, если вы используете эту комбинацию и получаете от нее удовольствие, переход на Vue, вероятно, станет следующим логическим шагом.</target>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">Клавиши модификаторов:</target>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">Модификаторы - это специальные постфиксы, обозначаемые точкой, которые указывают, что директива должна быть связана каким-то особым образом. Например, модификатор &lt;code&gt;.prevent&lt;/code&gt; указывает директиве &lt;code&gt;v-on&lt;/code&gt; вызвать &lt;code&gt;event.preventDefault()&lt;/code&gt; для инициированного события:</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">Модульные системы</target>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">Более зрелая поддержка инструментов. Vue обеспечивает официальную поддержку &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; и &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt; , а Riot полагается на поддержку сообщества для интеграции системы сборки.</target>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">Большинство приведенных ниже советов включены по умолчанию, если вы используете &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt; . Этот раздел актуален только в том случае, если вы используете настраиваемую настройку сборки.</target>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">Большинство случаев использования мутирующего опоры могут быть заменены одним из этих вариантов:</target>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">Модификаторы кнопок мыши</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">Намного лучше, не правда ли?</target>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">Намного проще! Вроде, как бы, что-то вроде. Код короче, но также требует большего знакомства со свойствами экземпляра Vue. В этом случае вы должны знать, что когда вы передаете дочерние элементы без директивы &lt;code&gt;v-slot&lt;/code&gt; в компонент, например &lt;code&gt;Hello world!&lt;/code&gt; внутри &lt;code&gt;anchored-heading&lt;/code&gt; эти дочерние элементы хранятся в экземпляре компонента в &lt;code&gt;$slots.default&lt;/code&gt; . Если вы еще этого не сделали, &lt;strong&gt;рекомендуется прочитать &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API свойств экземпляра,&lt;/a&gt; прежде чем углубляться в функции рендеринга.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">Мульти-атрибутные элементы</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; элементы с несколькими атрибутами&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">Многословные имена компонентов</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Названия компонентов из нескольких слов &lt;sup&gt;необходимы&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">Многострочный текст</target>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">Многочисленные значения</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">Несколько флажков,привязанных к одному и тому же массиву:</target>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">Несколько узлов,в которых за один раз отображается только 1.</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">Множественный выбор (привязан к массиву):</target>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">Усы нельзя использовать внутри атрибутов HTML. Вместо этого используйте &lt;a href=&quot;../api/index#v-bind&quot;&gt;директиву v-bind&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">Локальное изменение свойства теперь считается анти-шаблоном, например, объявление &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; и последующая установка this.myProp = 'someOtherValue' в компоненте. Благодаря новому механизму рендеринга всякий раз, когда родительский компонент повторно рендерит, локальные изменения дочернего компонента будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">Мутационные методы</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">Методы мутации, как следует из названия, изменяют исходный массив, для которого они вызываются. Для сравнения, существуют также немутантные методы, например &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;concat()&lt;/code&gt; и &lt;code&gt;slice()&lt;/code&gt; , которые не изменяют исходный массив, но &lt;strong&gt;всегда возвращают новый массив&lt;/strong&gt; . При работе с немутантными методами старый массив можно заменить новым:</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">NPM - рекомендуемый метод установки при создании крупномасштабных приложений с помощью Vue. Он прекрасно сочетается с такими сборщиками модулей, как &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; или &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; . Vue также предоставляет сопутствующие инструменты для создания &lt;a href=&quot;single-file-components&quot;&gt;однофайловых компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">Имя Корпус</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">Конфликты имен (например, несколько компонентов &lt;code&gt;ButtonDelete.vue&lt;/code&gt; ) затрудняют быстрый переход к определенному компоненту в редакторе кода.</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">Именованные слоты</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">Слотс-блокнот</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">Именованные слоты с атрибутом &lt;code&gt;slot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">местное население</target>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">Новое в 2.1.0+</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">Новое в версии 2.1.0+: возвращает Promise, если обратный вызов не предоставлен и Promise поддерживается в среде выполнения. Обратите внимание, что Vue не поставляется с полифилом Promise, поэтому, если вы нацеливаетесь на браузеры, которые изначально не поддерживают Promises (глядя на вас, IE), вам придется предоставить полифил самостоятельно.</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">Новое в 2.1.4+</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">Новое в 2.2.0</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">Новое в 2.2.0+</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">Новое в 2.3.0+</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">Новое в 2.4.0+</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">Новое в 2.5.0+</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">Новое в 2.6.0+</target>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">В этом больше нет необходимости,так как теперь по умолчанию предупреждения поставляются со стековыми трассами.</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">Никакого реального использования. Если вы так или иначе полагаетесь на эту функцию и не знаете, как ее обойти, отправьте сообщение на &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;форум&lt;/a&gt; для получения идей.</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">Узлы,деревья и виртуальное хранилище.</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">Атрибуты,не относящиеся к урожаю</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">Внеплановое государственное управление</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;С осторожностью используйте&lt;/sup&gt; управление состоянием без потока&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">Обратите внимание, что каждый дочерний элемент в &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; должен иметь &lt;strong&gt;уникальный ключ,&lt;/strong&gt; чтобы анимация работала правильно.</target>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; требует, чтобы все переключаемые компоненты имели имена, либо с использованием параметра &lt;code&gt;name&lt;/code&gt; в компоненте, либо посредством локальной / глобальной регистрации.</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;inheritAttrs: false&lt;/code&gt; вариант не &lt;strong&gt;не&lt;/strong&gt; влияет на &lt;code&gt;style&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt; привязок.</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;mounted&lt;/code&gt; вовсе &lt;strong&gt;не&lt;/strong&gt; гарантирует , что все дочерние компоненты также были установлены. Если вы хотите подождать, пока все представление будет отрисовано, вы можете использовать &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ NextTick&lt;/a&gt; внутри &lt;code&gt;mounted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; не поддерживается в &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; , поэтому, если вам нужно открыть ссылку в новой вкладке, вы должны вместо этого использовать &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;updated&lt;/code&gt; вовсе &lt;strong&gt;не&lt;/strong&gt; гарантирует , что все дочерние компоненты также были повторно вынесено. Если вы хотите дождаться повторного рендеринга всего представления, вы можете использовать &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ NextTick&lt;/a&gt; внутри &lt;code&gt;updated&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;v-bind&lt;/code&gt; с модификатором &lt;code&gt;.sync&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; работает с выражениями (например, &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; Недействителен). Вместо этого вы должны указать только имя свойства, которое вы хотите привязать, аналогично &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;v-show&lt;/code&gt; не поддерживает элемент &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; и не работает с &lt;code&gt;v-else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; можно добавить только в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt; (за &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;одним исключением&lt;/a&gt; ), в отличие от устаревшего &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;атрибута &lt;/a&gt; &lt;code&gt;slot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">Обратите внимание , что &lt;strong&gt;локально зарегистрированные компоненты &lt;em&gt;не&lt;/em&gt; также доступны в подкомпонентов&lt;/strong&gt; . Например, если вы хотите, чтобы &lt;code&gt;ComponentA&lt;/code&gt; был доступен в &lt;code&gt;ComponentB&lt;/code&gt; , вам нужно было бы использовать:</target>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;вы не должны использовать стрелочную функцию для определения метода&lt;/strong&gt; (например, &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ). Причина в том, что стрелочные функции связывают родительский контекст, поэтому &lt;code&gt;this&lt;/code&gt; не будет экземпляр Vue, как вы ожидаете, а &lt;code&gt;this.a&lt;/code&gt; будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;вы не должны использовать функцию стрелки для определения наблюдателя&lt;/strong&gt; (например, &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ). Причина в том, что стрелочные функции связывают родительский контекст, поэтому &lt;code&gt;this&lt;/code&gt; не будет экземпляр Vue, как вы ожидаете, а &lt;code&gt;this.updateAutocomplete&lt;/code&gt; будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что система событий Vue отличается от &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt; браузера . Хотя они работают аналогично, &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; и &lt;code&gt;$off&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; являются псевдонимами для &lt;code&gt;dispatchEvent&lt;/code&gt; , &lt;code&gt;addEventListener&lt;/code&gt; и &lt;code&gt;removeEventListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">Обратите внимание, что для других директив (например, &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-show&lt;/code&gt; ) нормальная правдивость JavaScript все еще применяется.</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">Обратите внимание: если вы используете стрелочную функцию с вычисляемым свойством, &lt;code&gt;this&lt;/code&gt; не будет экземпляр компонента, но вы все равно можете получить доступ к экземпляру в качестве первого аргумента функции:</target>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">Обратите внимание, что если вы используете стрелочную функцию со свойством &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; не будет экземпляр компонента, но вы все равно можете получить доступ к экземпляру в качестве первого аргумента функции:</target>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">Обратите внимание, что в ES2015 + размещение имени переменной, например &lt;code&gt;ComponentA&lt;/code&gt; , внутри объекта является сокращением для &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; , что означает, что имя переменной одновременно:</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">Обратите внимание,что в этом методе мы обновляем состояние нашего приложения,не касаясь DOM-все манипуляции с DOM обрабатываются Vue,а написанный вами код сфокусирован на основной логике.</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;не&lt;/strong&gt; рекомендуется использовать &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; вместе. См. Подробности в &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;руководстве&lt;/a&gt; по стилю .</target>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что клавиши - модификаторы отличаются от обычных ключей и при использовании &lt;code&gt;keyup&lt;/code&gt; событий, они должны быть нажаты , когда событие генерируется. Другими словами, &lt;code&gt;keyup.ctrl&lt;/code&gt; сработает, только если вы отпустите клавишу, удерживая &lt;code&gt;ctrl&lt;/code&gt; . Он не сработает, если вы отпустите только клавишу &lt;code&gt;ctrl&lt;/code&gt; . Если вы хотите , такое поведение, используйте &lt;code&gt;keyCode&lt;/code&gt; для &lt;code&gt;ctrl&lt;/code&gt; вместо: &lt;code&gt;keyup.17&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">Обратите внимание , что объекты и массивы в JavaScript передаются по ссылке, так что, если опора представляет собой массив или объект, видоизменяется объект или сам массив внутри компонента ребенка &lt;strong&gt;будет&lt;/strong&gt; влиять на родительское состояние.</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">Обратите внимание, что свойства проверяются &lt;strong&gt;до&lt;/strong&gt; создания экземпляра компонента, поэтому свойства экземпляра (например, &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; и т. Д.) Не будут доступны внутри функций по &lt;code&gt;default&lt;/code&gt; или функций &lt;code&gt;validator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">Обратите внимание, что элементы &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; по-прежнему эффективно повторно используются, поскольку у них нет &lt;code&gt;key&lt;/code&gt; атрибутов.</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">Обратите внимание, что сокращенный синтаксис слота по умолчанию &lt;strong&gt;нельзя&lt;/strong&gt; смешивать с именованными слотами, так как это приведет к неоднозначности области видимости:</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что те же стратегии слияния используются в &lt;code&gt;Vue.extend()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">Обратите внимание, что с &lt;code&gt;immediate&lt;/code&gt; опцией вы не сможете отменить отслеживание данного свойства при первом вызове обратного вызова.</target>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Обратите внимание, что вы должны включить &lt;code&gt;strict: true&lt;/code&gt; (или, по крайней мере, &lt;code&gt;noImplicitThis: true&lt;/code&gt; который является частью &lt;code&gt;strict&lt;/code&gt; флага), чтобы использовать проверку типа &lt;code&gt;this&lt;/code&gt; в методах компонентов, иначе он всегда обрабатывается как &lt;code&gt;any&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">Обратите внимание, что вы должны использовать &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+, если хотите использовать приведенный выше синтаксис для компонентов маршрута.</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">Обратите внимание , что вы все еще должны объявить &lt;code&gt;checked&lt;/code&gt; опору в компоненте &lt;code&gt;props&lt;/code&gt; варианта.</target>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">Обратите внимание на атрибут &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; . Это необходимо в шаблонах DOM, потому что внутри &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; допустим только элемент &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; &amp;gt; . Он делает то же самое, что и &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; , но устраняет потенциальную ошибку синтаксического анализа браузера. Смотрите &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM разбор шаблон предостережения&lt;/a&gt; , чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; разработан для случая, когда у него есть один прямой дочерний компонент, который переключается. Это не работает, если внутри у вас есть &lt;code&gt;v-for&lt;/code&gt; . Когда есть несколько условных дочерних элементов, как указано выше, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; требует, чтобы одновременно отображался только один дочерний элемент.</target>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">Примечание. На клавиатурах Macintosh мета - это командная клавиша (⌘). На клавиатуре Windows мета - это клавиша Windows (⊞). На клавиатурах Sun Microsystems мета отмечена сплошным ромбиком (◆). На некоторых клавиатурах, особенно на клавиатурах MIT и Lisp, а также на их последователях, таких как клавиатура Knight, клавиатура Space-cadet, мета помечена как &amp;laquo;META&amp;raquo;. На клавиатурах Symbolics мета помечена как &amp;laquo;МЕТА&amp;raquo; или &amp;laquo;Мета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">Примечание: в версиях до 2.3.0 опция &lt;code&gt;props&lt;/code&gt; требуется, если вы хотите принимать реквизиты в функциональном компоненте. В 2.3.0+ можно опустить &lt;code&gt;props&lt;/code&gt; опцию и все атрибуты , найденные на компоненте узла будут неявно извлекаются в качестве реквизита.</target>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">Примечание: привязки &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; НЕ являются реактивными. Это сделано намеренно. Однако, если вы передаете наблюдаемый объект, свойства этого объекта остаются реактивными.</target>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">Примечание: этот параметр &lt;strong&gt;не&lt;/strong&gt; влияет на привязки &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;style&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">Примечание: при изменении (а не замене) объекта или массива старое значение будет таким же, как новое значение, потому что они ссылаются на один и тот же объект / массив. Vue не хранит копию значения перед изменением.</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">Обратите внимание, что все действия, изменяющие состояние хранилища, помещаются внутри самого хранилища. Такой тип централизованного управления состоянием упрощает понимание того, какие мутации могут произойти и как они запускаются. Теперь, когда что-то пойдет не так, у нас также будет журнал того, что привело к ошибке.</target>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">Обратите внимание, что при нажатии на кнопки для каждой из них ведется отдельный &lt;code&gt;count&lt;/code&gt; . Это потому, что каждый раз, когда вы используете компонент, создается его новый &lt;strong&gt;экземпляр&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">Теперь &lt;code&gt;v-model&lt;/code&gt; должен отлично работать с этим компонентом:</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">Теперь и &lt;code&gt;ComponentA&lt;/code&gt; , и &lt;code&gt;ComponentC&lt;/code&gt; можно использовать внутри шаблона &lt;code&gt;ComponentB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">Теперь все внутри элементов &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; будет передано в соответствующие слоты. Предполагается, что любой контент, не заключенный в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; с использованием &lt;code&gt;v-slot&lt;/code&gt; , предназначен для слота по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">Теперь в компоненте, в котором вы определили эту &lt;code&gt;ref&lt;/code&gt; , вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">Пришло время совершить глубокое погружение! Одна из самых отличительных особенностей Vue - ненавязчивая система реактивности. Модели - это просто объекты JavaScript. Когда вы их изменяете, вид обновляется. Это делает управление состоянием простым и интуитивно понятным, но также важно понимать, как оно работает, чтобы избежать некоторых распространенных ошибок. В этом разделе мы собираемся углубиться в некоторые низкоуровневые детали системы реактивности Vue.</target>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">Теперь давайте добавим кнопку для увеличения текста прямо перед содержанием каждого сообщения:</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">Теперь давайте рассмотрим пример перехода на вход и выход с использованием тех же классов CSS, которые мы использовали ранее:</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">Теперь давайте рассмотрим пример. Вот переход JavaScript с использованием Velocity.js:</target>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">Теперь давайте обновим переход для наших кнопок включения / выключения с помощью &lt;code&gt;out-in&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">Теперь компонент &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; является &lt;strong&gt;полностью прозрачной оболочкой&lt;/strong&gt; , что означает, что его можно использовать точно так же, как обычный элемент &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; : все те же атрибуты и слушатели будут работать без модификатора &lt;code&gt;.native&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">Теперь вкладка &amp;laquo; &lt;em&gt;Сообщения&lt;/em&gt; &amp;raquo; сохраняет свое состояние (выбранная запись), даже если она не отображается. См. &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;Этот скрипт&lt;/a&gt; для получения полного кода.</target>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">Теперь эти входы будут отображаться с нуля каждый раз,когда вы переключаете.Убедитесь сами:</target>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">Теперь мы можем передать задачу каждому повторяющемуся компоненту с помощью &lt;code&gt;v-bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">Теперь мы поняли:</target>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">Теперь мы ответим как на то, что сообщество может сделать для вас, так и на то, что вы можете сделать для него.</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">Теперь при использовании &lt;code&gt;v-model&lt;/code&gt; на этом компоненте:</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">Теперь, когда мы используем &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; в родительском компоненте, не предоставляя содержимого для слота:</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">Теперь, когда мы используем компонент &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; , мы можем дополнительно определить альтернативный &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; для элементов списка задач, но с доступом к данным от дочернего элемента:</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">Теперь, когда вы запускаете &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; , будет вызываться установщик, и &lt;code&gt;vm.firstName&lt;/code&gt; и &lt;code&gt;vm.lastName&lt;/code&gt; будут соответственно обновлены.</target>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">Теперь всякий раз, когда &lt;code&gt;sourceOfTruth&lt;/code&gt; изменяется , и &lt;code&gt;vmA&lt;/code&gt; , и &lt;code&gt;vmB&lt;/code&gt; будут обновлять свои представления автоматически. Подкомпоненты в каждом из этих экземпляров также будут иметь доступ через &lt;code&gt;this.$root.$data&lt;/code&gt; . Теперь у нас есть единый источник истины, но отладка будет кошмаром. Любая часть данных может быть изменена любой частью нашего приложения в любое время, не оставляя следов.</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">Теперь вы можете скомпоновать его в шаблоне другого компонента:</target>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь, когда новое свойство добавляется к объектам &lt;code&gt;post&lt;/code&gt; , оно автоматически становится доступным внутри &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">Обнаружение изменения объекта Пещеры</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">Буквы объекта</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">Синтаксис объекта</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">Официальная декларация в пакетах НПМ</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">Официальное внедрение Flux-Like</target>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">Официальный маршрутизатор</target>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">При &lt;code&gt;input&lt;/code&gt; генерировать собственное пользовательское событие &lt;code&gt;input&lt;/code&gt; с новым значением</target>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">На более высоком уровне можно разделить компоненты на две категории:презентационные и логические.Мы рекомендуем использовать шаблоны для презентационных компонентов и функцию рендеринга/JSX для логических компонентов.Процент этих компонентов зависит от типа создаваемого приложения,но в целом мы находим презентационные компоненты гораздо более распространенными.</target>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">В обычных компонентах атрибуты, не определенные как реквизиты, автоматически добавляются к корневому элементу компонента, заменяя или &lt;a href=&quot;class-and-style&quot;&gt;разумно объединяя&lt;/a&gt; любые существующие атрибуты с тем же именем.</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">Корневые Vue экземпляров (то есть экземпляры , созданные с &lt;code&gt;new Vue({ ... })&lt;/code&gt; ), вы должны использовать &lt;code&gt;propsData&lt;/code&gt; вместо &lt;code&gt;props&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">С другой стороны, &lt;code&gt;$refs&lt;/code&gt; предназначены в первую очередь для программного доступа в JavaScript - не рекомендуется полагаться на них в шаблонах, потому что это будет означать ссылку на состояние, которое не принадлежит самому экземпляру. Это нарушит модель представления Vue, управляемую данными.</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">С другой стороны, сборка только во время выполнения полностью совместима с CSP. При использовании сборки только во время выполнения с &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; или &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt; ваши шаблоны будут предварительно скомпилированы в функции &lt;code&gt;render&lt;/code&gt; которые отлично работают в средах CSP.</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">На этой странице мы рассмотрим только переходы входа, выхода и списка, но вы можете увидеть следующий раздел для &lt;a href=&quot;transitioning-state&quot;&gt;управления переходами состояний&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">Как только реквизит зарегистрирован,вы можете передать ему данные в качестве пользовательского атрибута,например,вот так:</target>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">Еще раз, постарайтесь не злоупотреблять этим шаблоном. Хотя это удобно в тех редких случаях, когда вам нужно отрендерить много статического контента, это просто необязательно, если вы действительно не заметите медленную визуализацию - плюс, это может вызвать много путаницы позже. Например, представьте другого разработчика, который не знаком с &lt;code&gt;v-once&lt;/code&gt; или просто пропустил его в шаблоне. Они могут часами пытаться понять, почему шаблон не обновляется правильно.</target>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">После наблюдения вы больше не можете добавлять реактивные свойства к объекту корневых данных.Поэтому рекомендуется объявить все реактивные свойства корневого объекта перед созданием экземпляра.</target>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">Как только вы почувствуете себя комфортно с только что усвоенными знаниями, мы рекомендуем вернуться, чтобы прочитать полное руководство по &lt;a href=&quot;components-dynamic-async&quot;&gt;динамическим и асинхронным компонентам&lt;/a&gt; , а также другие страницы в разделе &amp;laquo;Подробные сведения о компонентах&amp;raquo; на боковой панели.</target>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">Одно важное замечание: эти переходы FLIP не работают с элементами, установленными на &lt;code&gt;display: inline&lt;/code&gt; . В качестве альтернативы вы можете использовать &lt;code&gt;display: inline-block&lt;/code&gt; или размещать элементы в гибком контексте.</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">Следует отметить одну важную вещь: &lt;strong&gt;разделение проблем не равно разделению типов файлов. &lt;/strong&gt;В современной разработке пользовательского интерфейса мы обнаружили, что вместо разделения кодовой базы на три огромных слоя, которые переплетаются друг с другом, имеет смысл разделить их на слабо связанные компоненты и составить их. Внутри компонента его шаблон, логика и стили неразрывно связаны, и их совместное размещение фактически делает компонент более связным и удобным в обслуживании.</target>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">Один из наиболее распространенных типов переходов использует переходы CSS. Вот пример:</target>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">Одно из наиболее распространенных применений этих методов - связь между родителем и его прямыми потомками. В этих случаях вы действительно можете &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;прослушать &lt;code&gt;$emit&lt;/code&gt; от ребенка с помощью &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; . Это позволяет сохранить удобство событий с добавленной явностью.</target>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Один или несколько именованных параметров &lt;sup&gt;изменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">Одно замечание: подобно тому, как &lt;code&gt;v-bind:class&lt;/code&gt; и &lt;code&gt;v-bind:style&lt;/code&gt; имеют особую обработку в шаблонах, у них есть свои собственные поля верхнего уровня в объектах данных VNode. Этот объект также позволяет связывать обычные атрибуты HTML, а также свойства DOM, такие как &lt;code&gt;innerHTML&lt;/code&gt; (это заменит директиву &lt;code&gt;v-html&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">Одноразовые привязки ( &lt;code&gt;{{* foo }}&lt;/code&gt; ) были заменены новой &lt;a href=&quot;../api/index#v-once&quot;&gt;директивой &lt;/a&gt; &lt;code&gt;v-once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Одноразовые привязки &lt;sup&gt;заменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">Односторонний поток данных</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">С Bower доступны только сборки UMD.</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Только Vue Router 2 совместим с Vue 2, поэтому, если вы обновляете Vue, вам также придется обновить Vue Router. Вот почему мы включили подробную информацию о пути миграции сюда, в основные документы. Полное руководство по использованию нового Vue Router см. В &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;документации Vue Router&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Только Vue Router 2 совместим с Vue 2, так что да, вам также придется следовать &lt;a href=&quot;migration-vue-router&quot;&gt;путем миграции для Vue Router&lt;/a&gt; . К счастью, в большинстве приложений не так много кода маршрутизатора, поэтому это, скорее всего, не займет больше часа.</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">Только в версии 2.2.0+:Также работает с массивом+индексом.</target>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">Усилия по оптимизации</target>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">вариант объединения</target>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">Опции/Активы</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">Опции/Состав</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">Опции/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">Опции/Данные</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">Опции/Крюки жизненного цикла</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">Опции/Ошибки</target>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">Такие параметры, как &lt;code&gt;acceptStatement&lt;/code&gt; , &lt;code&gt;deep&lt;/code&gt; , &lt;code&gt;priority&lt;/code&gt; и т. Д. Были удалены. Чтобы заменить директивы &lt;code&gt;twoWay&lt;/code&gt; , см. &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;Этот пример&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">Параметры, которые ожидают значения объекта, например &lt;code&gt;methods&lt;/code&gt; , &lt;code&gt;components&lt;/code&gt; и &lt;code&gt;directives&lt;/code&gt; , будут объединены в один и тот же объект. Параметры компонента будут иметь приоритет, если в этих объектах есть конфликтующие ключи:</target>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">Или данные/считанные свойства:</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">Или функция рендеринга:</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">Или, в качестве альтернативы, вы можете использовать асинхронный &lt;code&gt;import&lt;/code&gt; Webpack при локальной регистрации компонента:</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">Или,что еще лучше,передайте методы удаления индексу:</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">Или даже другие компоненты:</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">Или, если &lt;code&gt;myElement&lt;/code&gt; является последним дочерним элементом :</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">Или, если вы используете модули ES2015, например, через Babel и Webpack, это может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">Или с функцией рендеринга:</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">Или с помощью компонентных методов:</target>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">Или,если обработчик событий-это метод:</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">Или, если вы используете сборку Vue только для времени выполнения:</target>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">Или атрибут &lt;code&gt;slot&lt;/code&gt; также можно использовать непосредственно в обычном элементе:</target>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">Или, используя &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; с Grunt и &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">Или, используя &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; с Gulp:</target>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">Порядок имеет значение при использовании модификаторов, потому что соответствующий код генерируется в том же порядке. Поэтому использование &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; предотвратит &lt;strong&gt;все щелчки,&lt;/strong&gt; а &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; предотвратит только щелчки по самому элементу.</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">Порядок слов в названиях компонентов</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется&lt;/sup&gt; порядок слов в названиях компонентов.&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">Организационные компоненты</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">Организация переходов на компоненты</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">Другие примеры</target>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">Наш &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Кодекс поведения&lt;/a&gt; - это руководство, которое упростит обогащение всех нас и технических сообществ, в которых мы участвуем.</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">Наша пользовательская директива теперь достаточно гибкая для поддержки нескольких различных случаев использования.</target>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">Наш установочный код хранится отдельно от кода очистки,что затрудняет программную очистку всего,что мы устанавливаем.</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">Однако со временем развитие Knockout замедлилось, и он начал немного показывать свой возраст. Например, в его компонентной системе отсутствует полный набор хуков жизненного цикла, и, хотя это очень распространенный вариант использования, интерфейс для передачи дочерних элементов компоненту кажется немного неуклюжим по сравнению с &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">В целом это устраняет необходимость в целом классе оптимизаций производительности с планшета разработчика и позволяет им больше сосредоточиться на создании самого приложения по мере его масштабирования.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">Частичные данные были удалены в пользу более явного потока данных между компонентами с использованием свойств. Если вы не используете партиал в области, критичной к производительности, рекомендуется использовать вместо него &lt;a href=&quot;components&quot;&gt;обычный компонент&lt;/a&gt; . Если вы динамически связывали &lt;code&gt;name&lt;/code&gt; партиала, вы можете использовать &lt;a href=&quot;components#Dynamic-Components&quot;&gt;динамический компонент&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">У PascalCase есть несколько преимуществ по сравнению с кебабом:</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase лучше всего работает с автозаполнением в редакторах кода, поскольку он соответствует тому, как мы ссылаемся на компоненты в JS (X) и шаблонах, где это возможно. Однако имена файлов со смешанным регистром иногда могут создавать проблемы в файловых системах без учета регистра, поэтому kebab-case также вполне приемлем.</target>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">Передайте реквизит экземпляру во время его создания.Это в первую очередь предназначено для облегчения юнит-тестирования.</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">Передача атрибутов и событий детским элементам/компонентам</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">Передача данных в детские компоненты с реквизитами</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">Проходящие статические или динамические реквизиты</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">Проходя мимо булева</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">Передача номера</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">Проходя через массив</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">Передача предмета</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">Передача &lt;code&gt;immediate: true&lt;/code&gt; в опции вызовет обратный вызов немедленно с текущим значением выражения:</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">Передача свойств объекта</target>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">С точки зрения производительности, Vue обгоняет Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;с перевесом справедливой&lt;/a&gt; , даже после последнего обновления Glimmer двигателя в Ember 3.x. Vue автоматически пакетирует обновления, а в Ember вам нужно вручную управлять циклами выполнения в критических для производительности ситуациях.</target>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;Объявление класса VNode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;Документацию по пакету vue-server-renderer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">Плагины могут добавлять к глобальным свойствам / экземплярам Vue и параметрам компонентов. В этих случаях объявления типов необходимы для компиляции подключаемых модулей в TypeScript. К счастью, есть функция TypeScript для расширения существующих типов, называемая &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;расширением модулей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">Плагины обычно добавляют в Vue функциональность глобального уровня.Для плагина нет строго определенной области применения-обычно существует несколько типов плагинов:</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer - еще один проект, спонсируемый Google, и на самом деле он также послужил источником вдохновения для Vue. Компоненты Vue можно легко сравнить с пользовательскими элементами Polymer, и оба обеспечивают очень похожий стиль разработки. Самая большая разница в том, что Polymer основан на последних функциях веб-компонентов и требует нетривиальных полифиллов для работы (с пониженной производительностью) в браузерах, которые изначально не поддерживают эти функции. Напротив, Vue работает без каких-либо зависимостей или полифиллов вплоть до IE9.</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">Предварительная компиляция шаблонов</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Библиотеки предсказаний и другие библиотеки реактивного типа</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">В стилях с &lt;code&gt;scoped&lt;/code&gt; селекторам классов, а не селекторам элементов , поскольку большое количество селекторов элементов выполняется медленно.</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">Довольно круто,да?</target>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">Раньше &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; в сочетании с &lt;code&gt;v-for&lt;/code&gt; создавал массив элементов / компонентов, потому что не было возможности дать каждому элементу уникальное имя. Вы по-прежнему можете добиться этого, задав каждому элементу одну и ту же &lt;code&gt;ref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">Раньше &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; имел &lt;code&gt;number&lt;/code&gt; начинающийся с 0 и заканчивающийся 9. Теперь он начинается с 1 и заканчивается на 10.</target>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">В основном используется для сохранения состояния компонентов или во избежание повторного использования.</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">Правила Приоритета А:Существенный (предотвращение ошибок)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">Приоритет А:Существенный</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">Правила приоритета В:Настоятельно рекомендуемые (улучшение читабельности)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">Приоритет В:настоятельно рекомендуется</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">Правила приоритета С:Рекомендуемые (Сведение к минимуму произвольного выбора и когнитивной надбавки)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">Приоритет С:Рекомендуется</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">Правила приоритета D:Использовать с осторожностью (потенциально опасные образцы).</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">Приоритет D:Использовать с осторожностью</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">Имена частных владений</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Названия частной собственности &lt;sup&gt;необходимы&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">Проблема решена!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">Развертывание производства</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">Слушатели программных мероприятий</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">Программная навигация</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">Программно выбрать один из нескольких других компонентов для делегирования на</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">Создание проекта</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">Корпус реквизита (кейс верблюда против кебабаба)</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">Prop Mutation &lt;sup&gt;устарел&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="23ca9a44a1ade4d87027ae10b8309bece2e74a54" translate="yes" xml:space="preserve">
          <source>Prop Types</source>
          <target state="translated">Типы реквизита</target>
        </trans-unit>
        <trans-unit id="0d718a828e84189a6c1ea77a0099a78e06d7d7c9" translate="yes" xml:space="preserve">
          <source>Prop Validation</source>
          <target state="translated">Проверка достоверности реквизитов</target>
        </trans-unit>
        <trans-unit id="3ad34219a208945c8ea06d8eb918df83f7e61456" translate="yes" xml:space="preserve">
          <source>Prop definitions</source>
          <target state="translated">Определения реквизитов</target>
        </trans-unit>
        <trans-unit id="e2f4b4fdf875186ea4cf16dbb812dbea30216d87" translate="yes" xml:space="preserve">
          <source>Prop definitions &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Основные&lt;/sup&gt; определения &lt;sup&gt;реквизита&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="895e352dc19c97709d5567c55fe72b1a6d482c35" translate="yes" xml:space="preserve">
          <source>Prop name casing</source>
          <target state="translated">Корпус реквизита</target>
        </trans-unit>
        <trans-unit id="b90f11ae0da8cbfe0b2f736a16886c055d6bffd1" translate="yes" xml:space="preserve">
          <source>Prop name casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется&lt;/sup&gt; корпус с названием пропуска&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="66e61e4c98d3b3a635091c842dada04fef1b9143" translate="yes" xml:space="preserve">
          <source>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt;. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.</source>
          <target state="translated">Правильная настройка всех обсуждаемых аспектов готового к работе серверного приложения может быть сложной задачей. К счастью, есть отличный общественный проект , который стремится сделать все это проще: &lt;a href=&quot;https://nuxtjs.org/&quot;&gt;Nuxt.js&lt;/a&gt; . Nuxt.js - это фреймворк более высокого уровня, построенный на основе экосистемы Vue, который обеспечивает чрезвычайно упрощенный опыт разработки для написания универсальных приложений Vue. А еще лучше, вы даже можете использовать его как генератор статических сайтов (со страницами, созданными как однофайловые компоненты Vue)! Мы настоятельно рекомендуем попробовать.</target>
        </trans-unit>
        <trans-unit id="fc7c765b5dbb95f7134159f12c7f78946b944760" translate="yes" xml:space="preserve">
          <source>Properly trigger lifecycle hooks of a component</source>
          <target state="translated">Правильно запускать крюки жизненного цикла компонента</target>
        </trans-unit>
        <trans-unit id="e9f3056a7ba256cf707e7dce02bf806a8e3e1baf" translate="yes" xml:space="preserve">
          <source>Properties that start with &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; be proxied on the Vue instance because they may conflict with Vue&amp;rsquo;s internal properties and API methods. You will have to access them as &lt;code&gt;vm.$data._property&lt;/code&gt;.</source>
          <target state="translated">Свойства, начинающиеся с &lt;code&gt;_&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; , &lt;strong&gt;не&lt;/strong&gt; будут проксироваться в экземпляре Vue, потому что они могут конфликтовать с внутренними свойствами и методами API Vue. Вам нужно будет получить к ним доступ как &lt;code&gt;vm.$data._property&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="824b655ece5f935a9f95c151296cb1d2ff2e73ec" translate="yes" xml:space="preserve">
          <source>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a &lt;code&gt;props&lt;/code&gt; option:</source>
          <target state="translated">Свойства - это настраиваемые атрибуты, которые можно зарегистрировать в компоненте. Когда значение передается в атрибут prop, оно становится свойством этого экземпляра компонента. Чтобы передать заголовок нашему компоненту сообщения в блоге, мы можем включить его в список свойств, которые принимает этот компонент, используя опцию &lt;code&gt;props&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02635ba77eef9661786c01a78d90b7501db1be4e" translate="yes" xml:space="preserve">
          <source>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</source>
          <target state="translated">Теперь реквизит всегда односторонний.Для создания побочных эффектов в родительской области видимости компонент должен явно излучать событие,а не полагаться на неявное связывание.Для получения дополнительной информации,смотрите:</target>
        </trans-unit>
        <trans-unit id="f6122d047108de3e0837cf3e23276a8775fc2406" translate="yes" xml:space="preserve">
          <source>Props on a Root Instance &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Реквизиты на корневом экземпляре &lt;sup&gt;заменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="877adb56a197e1259015de3210d87c2e790b7975" translate="yes" xml:space="preserve">
          <source>Provide an alternative render output when the default &lt;code&gt;render&lt;/code&gt; function encounters an error. The error will be passed to &lt;code&gt;renderError&lt;/code&gt; as the second argument. This is particularly useful when used together with hot-reload.</source>
          <target state="translated">Предоставьте альтернативный вывод рендеринга, когда функция &lt;code&gt;render&lt;/code&gt; по умолчанию обнаруживает ошибку. Ошибка будет передана в &lt;code&gt;renderError&lt;/code&gt; в качестве второго аргумента. Это особенно полезно при использовании вместе с горячей перезагрузкой.</target>
        </trans-unit>
        <trans-unit id="02efa133aeef7a133aefd2f252af936a5cccad26" translate="yes" xml:space="preserve">
          <source>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</source>
          <target state="translated">Предоставьте экземпляру Vue существующий элемент DOM для установки.Это может быть CSS-селекторная строка или реальный HTMLElement.</target>
        </trans-unit>
        <trans-unit id="dcf49ab626c30fff5ed5ee4dbe07721b4605c56b" translate="yes" xml:space="preserve">
          <source>Quasar Framework SSR + PWA</source>
          <target state="translated">Квазар Framework SSR+PWA</target>
        </trans-unit>
        <trans-unit id="282e30765bd347047d1a351ac3b6f1cf18becd81" translate="yes" xml:space="preserve">
          <source>Quoted attribute values</source>
          <target state="translated">Значения кавычек атрибутов</target>
        </trans-unit>
        <trans-unit id="683b9e103293a057ef4362aa5bc974a4f8bd8131" translate="yes" xml:space="preserve">
          <source>Quoted attribute values &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">Значения атрибутов в кавычках &lt;sup&gt;настоятельно рекомендуются&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ed1e44a4093ca562205b72061c34f1507e70c015" translate="yes" xml:space="preserve">
          <source>RFC-0001</source>
          <target state="translated">RFC-0001</target>
        </trans-unit>
        <trans-unit id="b11bf19e3f65b4a1ada383e41f26dab5c503940e" translate="yes" xml:space="preserve">
          <source>Radio</source>
          <target state="translated">Radio</target>
        </trans-unit>
        <trans-unit id="76550ff95e4521edf8dc9e8329b78993dc047414" translate="yes" xml:space="preserve">
          <source>Raw HTML</source>
          <target state="translated">HTML в исходном формате</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b183e9aafa930f129da2c452cc641903b8199bea" translate="yes" xml:space="preserve">
          <source>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt;, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!</source>
          <target state="translated">React Native позволяет писать приложения с рендерингом для iOS и Android, используя одну и ту же компонентную модель React. Это здорово, поскольку вы как разработчик можете применять свои знания о фреймворке на нескольких платформах. В этом отношении Vue официально сотрудничает с &lt;a href=&quot;https://weex.apache.org/&quot;&gt;Weex&lt;/a&gt; , кроссплатформенным фреймворком пользовательского интерфейса, созданным Alibaba Group и инкубируемым Apache Software Foundation (ASF). Weex позволяет использовать один и тот же синтаксис компонента Vue для создания компонентов, которые могут отображаться не только в браузере, но и изначально на iOS и Android!</target>
        </trans-unit>
        <trans-unit id="ee4366331847de86650378c9e4041dac06218df0" translate="yes" xml:space="preserve">
          <source>React and Vue share many similarities. They both:</source>
          <target state="translated">React и Vue имеют много общего.Они оба:</target>
        </trans-unit>
        <trans-unit id="bb65ef679dc307f628a20a0b729cd808d18c5ac0" translate="yes" xml:space="preserve">
          <source>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React&amp;rsquo;s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it&amp;rsquo;s absolutely not suitable for production.</source>
          <target state="translated">React известен своей крутой кривой обучения. Прежде чем вы действительно сможете начать, вам нужно узнать о JSX и, возможно, о ES2015 +, поскольку во многих примерах используется синтаксис класса React. Вы также должны узнать о системах сборки, потому что, хотя вы можете технически использовать Babel Standalone для живой компиляции вашего кода в браузере, он абсолютно не подходит для производства.</target>
        </trans-unit>
        <trans-unit id="bb1b40c27f9e4939cf3ff484fca2a9371f8d3b42" translate="yes" xml:space="preserve">
          <source>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.</source>
          <target state="translated">Реакционные библиотеки обычно стараются поделиться с React как можно большей частью своего API и экосистемы,насколько это возможно.По этой причине подавляющее большинство приведенных выше сравнений относится и к ним.Основным отличием,как правило,будет уменьшенная экосистема,часто значительно,по сравнению с React.Поскольку эти библиотеки не могут быть на 100% совместимы со всем,что находится в экосистеме React,некоторые инструментальные средства и библиотеки-компаньоны могут быть непригодны для использования.Или,даже если кажется,что они работают,они могут сломаться в любое время,если только ваша конкретная библиотека,подобная React-like,официально не поддерживается наравне с React.</target>
        </trans-unit>
        <trans-unit id="96578d9c2e6eaee240051ff91e83f741cc87e93b" translate="yes" xml:space="preserve">
          <source>Reactivity</source>
          <target state="translated">Reactivity</target>
        </trans-unit>
        <trans-unit id="38be1878e88addc141471e2ac5be059c49256537" translate="yes" xml:space="preserve">
          <source>Reactivity in Depth</source>
          <target state="translated">Реактивность в глубине</target>
        </trans-unit>
        <trans-unit id="446d7c237336d575135ddcd7063341761426b025" translate="yes" xml:space="preserve">
          <source>Ready for More?</source>
          <target state="translated">Готов к Большому?</target>
        </trans-unit>
        <trans-unit id="40fe62216df511ee5c87bc8e026789c819f7b21e" translate="yes" xml:space="preserve">
          <source>Really though, any transition attribute can be dynamically bound. And it&amp;rsquo;s not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.</source>
          <target state="translated">На самом деле, любой атрибут перехода можно привязать динамически. И это не только атрибуты. Поскольку перехватчики событий являются методами, они имеют доступ к любым данным в контексте. Это означает, что в зависимости от состояния вашего компонента переходы JavaScript могут вести себя по-разному.</target>
        </trans-unit>
        <trans-unit id="cdb5994a5662a9b7831e2e56b44ea27b6edb5bab" translate="yes" xml:space="preserve">
          <source>Recent versions of Angular, with &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;AOT compilation&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;tree-shaking&lt;/a&gt;, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by &lt;code&gt;angular-cli&lt;/code&gt; (~65KB gzipped).</source>
          <target state="translated">Последние версии Angular с &lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot;&gt;компиляцией AOT&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_shaking&quot;&gt;встряхиванием дерева&amp;raquo;&lt;/a&gt; смогли значительно уменьшить его размер. Однако полнофункциональный проект Vue 2 с включенным Vuex + Vue Router (~ 30 КБ в сжатом виде) по-прежнему значительно легче, чем готовое приложение, скомпилированное AOT, созданное с помощью &lt;code&gt;angular-cli&lt;/code&gt; (~ 65 КБ в сжатом виде).</target>
        </trans-unit>
        <trans-unit id="3f99a56b4630f2ac18091fad78531d1626d4dac4" translate="yes" xml:space="preserve">
          <source>Recommended Configuration</source>
          <target state="translated">Рекомендуемая конфигурация</target>
        </trans-unit>
        <trans-unit id="f9d18b779732cc0ea4b60f929feea8a7c40df5fc" translate="yes" xml:space="preserve">
          <source>Recreating dynamic components is normally useful behavior, but in this case, we&amp;rsquo;d really like those tab component instances to be cached once they&amp;rsquo;re created for the first time. To solve this problem, we can wrap our dynamic component with a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Воссоздание динамических компонентов обычно является полезным поведением, но в этом случае нам бы очень хотелось, чтобы эти экземпляры компонентов вкладки кэшировались после их создания в первый раз. Чтобы решить эту проблему, мы можем обернуть наш динамический компонент элементом &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25c0556aa6352203342eea1a65c58a623378dbcc" translate="yes" xml:space="preserve">
          <source>Recursive Components</source>
          <target state="translated">Рекурсивные компоненты</target>
        </trans-unit>
        <trans-unit id="46819d95829c2f8ee915e7d271f512463387fc11" translate="yes" xml:space="preserve">
          <source>Refactoring becomes more difficult, because find-and-replace often isn&amp;rsquo;t sufficient to update relative references to a moved component.</source>
          <target state="translated">Рефакторинг становится более трудным, потому что поиска и замены часто недостаточно для обновления относительных ссылок на перемещенный компонент.</target>
        </trans-unit>
        <trans-unit id="f4234eefb475a2340f218d9e7a7e6c874a82a6fa" translate="yes" xml:space="preserve">
          <source>Refer to the respective build tool documentations to see how it&amp;rsquo;s done:</source>
          <target state="translated">Обратитесь к соответствующей документации инструмента сборки, чтобы узнать, как это делается:</target>
        </trans-unit>
        <trans-unit id="8d8b1f50199fd6cb6ab6141f41a87fd8dae1f00d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global component. Registration also automatically sets the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; with the given &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">Зарегистрируйте или получите глобальный компонент. Регистрация также автоматически устанавливает компоненту &lt;code&gt;name&lt;/code&gt; с указанным &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0168019975e7b996b73bc3be3562ac476872545c" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global directive.</source>
          <target state="translated">Зарегистрируйте или получите глобальную директиву.</target>
        </trans-unit>
        <trans-unit id="13bd6c258247a18188a7e24270fbc9f007d7c82d" translate="yes" xml:space="preserve">
          <source>Register or retrieve a global filter.</source>
          <target state="translated">Зарегистрируйте или получите глобальный фильтр.</target>
        </trans-unit>
        <trans-unit id="76de89743a325c94ab024ae33f08812f80d685bb" translate="yes" xml:space="preserve">
          <source>Relation to Custom Elements</source>
          <target state="translated">Отношение к пользовательским элементам</target>
        </trans-unit>
        <trans-unit id="0ea4af908fe06688dd3fc02035189b08293c5074" translate="yes" xml:space="preserve">
          <source>Release Notes</source>
          <target state="translated">Информация о выпуске</target>
        </trans-unit>
        <trans-unit id="d92abdf653f23351eb7a0ab4d23290ee1313902d" translate="yes" xml:space="preserve">
          <source>Remember that &lt;strong&gt;global registration must take place before the root Vue instance is created (with &lt;code&gt;new Vue&lt;/code&gt;)&lt;/strong&gt;. &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;Here&amp;rsquo;s an example&lt;/a&gt; of this pattern in a real project context.</source>
          <target state="translated">Помните, что &lt;strong&gt;глобальная регистрация должна произойти до создания корневого экземпляра Vue (с &lt;code&gt;new Vue&lt;/code&gt; )&lt;/strong&gt; . &lt;a href=&quot;https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js&quot;&gt;Вот пример&lt;/a&gt; этого шаблона в контексте реального проекта.</target>
        </trans-unit>
        <trans-unit id="73942b04c7d6e9cc0cafd922223a9eab5438c235" translate="yes" xml:space="preserve">
          <source>Remove custom event listener(s).</source>
          <target state="translated">Удалить пользовательские слушатели событий.</target>
        </trans-unit>
        <trans-unit id="25c548f4a7b9b6ef1cfbffbca926739476b1c4e2" translate="yes" xml:space="preserve">
          <source>Removed due to hooks simplification. If you really must suppress transition errors, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt;&lt;code&gt;try&lt;/code&gt;&amp;hellip;&lt;code&gt;catch&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Убрано в связи с упрощением зацепов. Если вам действительно необходимо подавить ошибки перехода, вы можете вместо этого использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch&quot;&gt; &lt;code&gt;try&lt;/code&gt; &amp;hellip; &lt;code&gt;catch&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f3ed71f5d7421b91e0c25cc42984adb65b4fdd" translate="yes" xml:space="preserve">
          <source>Renamed to &lt;code&gt;base&lt;/code&gt; for consistency with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;the HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</source>
          <target state="translated">Переименовано в &lt;code&gt;base&lt;/code&gt; для согласованности с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;элементом &lt;/a&gt;HTML &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3aa893c2a6ebe75166762d5109366b728fa5dc54" translate="yes" xml:space="preserve">
          <source>Render Functions &amp;amp; JSX</source>
          <target state="translated">Функции рендеринга и JSX</target>
        </trans-unit>
        <trans-unit id="f54e5429aec68f05a2b3b43a85ee9662c29159d7" translate="yes" xml:space="preserve">
          <source>Render Functions - Slots</source>
          <target state="translated">Функции кредитора-Слоты</target>
        </trans-unit>
        <trans-unit id="aeac0239d7806a13c73e4eacbb8e89032112b08f" translate="yes" xml:space="preserve">
          <source>Render functions with JSX have a few advantages:</source>
          <target state="translated">Рендерные функции с JSX имеют несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="c0f479c7d13498bbd2aa42eae8f88242964120b5" translate="yes" xml:space="preserve">
          <source>Render the element and component &lt;strong&gt;once&lt;/strong&gt; only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</source>
          <target state="translated">Визуализируйте элемент и компонент только &lt;strong&gt;один раз&lt;/strong&gt; . При последующих повторных отрисовках элемент / компонент и все его дочерние элементы будут обрабатываться как статический контент и пропускаться. Это можно использовать для оптимизации производительности обновления.</target>
        </trans-unit>
        <trans-unit id="1c510f643528b3292df74bbcf70195487418102f" translate="yes" xml:space="preserve">
          <source>Render the element or template block multiple times based on the source data. The directive&amp;rsquo;s value must use the special syntax &lt;code&gt;alias in expression&lt;/code&gt; to provide an alias for the current element being iterated on:</source>
          <target state="translated">Выполните рендеринг элемента или блока шаблона несколько раз на основе исходных данных. Значение директивы должно использовать специальный &lt;code&gt;alias in expression&lt;/code&gt; синтаксиса в выражении, чтобы предоставить псевдоним для текущего элемента, по которому выполняется итерация:</target>
        </trans-unit>
        <trans-unit id="9647e21c53c63f65c167aa12298837e080c17cb0" translate="yes" xml:space="preserve">
          <source>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains &lt;strong&gt;a lot&lt;/strong&gt; of static content. In these cases, you can ensure that it&amp;rsquo;s only evaluated once and then cached by adding the &lt;code&gt;v-once&lt;/code&gt; directive to the root element, like this:</source>
          <target state="translated">Визуализация простых HTML-элементов во Vue выполняется очень быстро, но иногда у вас может быть компонент, содержащий &lt;strong&gt;много&lt;/strong&gt; статического содержимого. В этих случаях вы можете убедиться, что он оценивается только один раз, а затем кэшируется, добавив директиву &lt;code&gt;v-once&lt;/code&gt; к корневому элементу, например:</target>
        </trans-unit>
        <trans-unit id="9a09ee1cf84326d5d5b1fbbb8dcaca046fb652f2" translate="yes" xml:space="preserve">
          <source>Replacing &lt;code&gt;vm.$data&lt;/code&gt;&lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Замена &lt;code&gt;vm.$data&lt;/code&gt; &lt;sup&gt;удалена&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6336d2b4c545bfdb0a2c2e6130a2fe522bc117ed" translate="yes" xml:space="preserve">
          <source>Replacing Template Features with Plain JavaScript</source>
          <target state="translated">Замена функций шаблона на обычный JavaScript</target>
        </trans-unit>
        <trans-unit id="3694e119ff9868c46a5da68ac50107adb0cd0254" translate="yes" xml:space="preserve">
          <source>Replacing an Array</source>
          <target state="translated">Замена массива</target>
        </trans-unit>
        <trans-unit id="448ceec811e5cd1612b41b145f75a74425a6d60a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;capitalize&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра с &lt;code&gt;capitalize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ebc9242fd66a164fb0466c94c267b085022f523" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;currency&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;currency&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e8e54f171683ed43699d784bb3a20daa786f68a" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;debounce&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;debounce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc05ccbf460e1bee1b220a363cd9b366122fc62c" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;filterBy&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра По &lt;code&gt;filterBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aadbac5cc6d5572fbf9f02300727b922b52477f" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;json&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5af22200afbbae6350485e71f8a0930a62620a3b" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;limitBy&lt;/code&gt; Filter</source>
          <target state="translated">Замена &lt;code&gt;limitBy&lt;/code&gt; фильтра</target>
        </trans-unit>
        <trans-unit id="63239b2dfa73a07907b85e48d0e4e3d07aa51efd" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;lowercase&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;lowercase&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="307535ec9952915e10873762b9b0a59ea99d17d1" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;orderBy&lt;/code&gt; Filter</source>
          <target state="translated">Замена &lt;code&gt;orderBy&lt;/code&gt; фильтра</target>
        </trans-unit>
        <trans-unit id="5a0b57fe75978a4fde52508fa6b11e6a9fcbade8" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;pluralize&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;pluralize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895ba028c303252e37b6295f10778b7ca351267" translate="yes" xml:space="preserve">
          <source>Replacing the &lt;code&gt;uppercase&lt;/code&gt; Filter</source>
          <target state="translated">Замена фильтра &lt;code&gt;uppercase&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c183ebe6cda4d505c2e49d3160c8367d36be5b90" translate="yes" xml:space="preserve">
          <source>Replacing/Merging with Existing Attributes</source>
          <target state="translated">Замена/сопряжение с существующими атрибутами</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="1f5b54bbca313ab53947ed8a4f97b16e01f729d9" translate="yes" xml:space="preserve">
          <source>Reusable Transitions</source>
          <target state="translated">Многоразовые переходы</target>
        </trans-unit>
        <trans-unit id="a48bbafb258bfc790b66aec7d45e0a6a8fa1cd83" translate="yes" xml:space="preserve">
          <source>Reusing Components</source>
          <target state="translated">Повторное использование компонентов</target>
        </trans-unit>
        <trans-unit id="b836c4c63ed0b1bed339e82e9c78c2b817e6736c" translate="yes" xml:space="preserve">
          <source>Riot</source>
          <target state="translated">Riot</target>
        </trans-unit>
        <trans-unit id="6e85617241bed85b4dcd2ae064b3025078b134e9" translate="yes" xml:space="preserve">
          <source>Riot 3.0 provides a similar component-based development model (which is called a &amp;ldquo;tag&amp;rdquo; in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:</source>
          <target state="translated">Riot 3.0 предоставляет аналогичную модель разработки на основе компонентов (которая в Riot называется &amp;laquo;тегом&amp;raquo;) с минимальным и красиво оформленным API. У Riot и Vue, вероятно, много общего в философии дизайна. Однако, несмотря на то, что он немного тяжелее, чем Riot, Vue предлагает некоторые существенные преимущества:</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="8e4ecad6a05d926091d335638bbc9859c1de1f8b" translate="yes" xml:space="preserve">
          <source>Rollup + rollup-plugin-vue</source>
          <target state="translated">Рулон+рулон-плугин-вью</target>
        </trans-unit>
        <trans-unit id="42ec7ccbef29d0422b242b5178f06191bc8484d0" translate="yes" xml:space="preserve">
          <source>Route Definitions</source>
          <target state="translated">Определения маршрута</target>
        </trans-unit>
        <trans-unit id="6e3b967c60ba49b0f518c43998cb2dc91dd2134c" translate="yes" xml:space="preserve">
          <source>Route Hooks</source>
          <target state="translated">Крюки маршрута</target>
        </trans-unit>
        <trans-unit id="2b73a7098cbf7da1b1613b48acc5eb7c6f35331c" translate="yes" xml:space="preserve">
          <source>Route Matching</source>
          <target state="translated">Сопоставление маршрутов</target>
        </trans-unit>
        <trans-unit id="18febd25894978ca61139fd68c461cb521819d89" translate="yes" xml:space="preserve">
          <source>Route Options: Misc</source>
          <target state="translated">Опции маршрута:Ошибка</target>
        </trans-unit>
        <trans-unit id="f0865cca790a39153b3f106f9c19244b4f157bd4" translate="yes" xml:space="preserve">
          <source>Route matching now uses &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; under the hood, making it much more flexible than previously.</source>
          <target state="translated">Сопоставление маршрутов теперь использует под капотом &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;путь к регулярному выражению&lt;/a&gt; , что делает его гораздо более гибким, чем раньше.</target>
        </trans-unit>
        <trans-unit id="32027b0a6491682801317490f82d9b553e764f1b" translate="yes" xml:space="preserve">
          <source>Router Initialization</source>
          <target state="translated">Инициализация маршрутизатора</target>
        </trans-unit>
        <trans-unit id="1b4778ead27c045154fa8a8032dcbf9b6b10e64f" translate="yes" xml:space="preserve">
          <source>Router Options: Modes</source>
          <target state="translated">Опции маршрутизатора:Режимы</target>
        </trans-unit>
        <trans-unit id="9add2b84e8289fb0ea9dcb2637e5d5907ca4d748" translate="yes" xml:space="preserve">
          <source>Routes are now defined as an array on a &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt;&lt;code&gt;routes&lt;/code&gt; option&lt;/a&gt; at router instantiation. So these routes for example:</source>
          <target state="translated">Маршруты теперь определены как массив в &lt;a href=&quot;https://router.vuejs.org/en/essentials/getting-started.html#javascript&quot;&gt;опции &lt;/a&gt; &lt;code&gt;routes&lt;/code&gt; при создании экземпляра маршрутизатора. Вот эти маршруты, например:</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="d670f1115ef0c3c29b2d47e241e7dd62eafb1e11" translate="yes" xml:space="preserve">
          <source>Rule Categories</source>
          <target state="translated">Категории правил</target>
        </trans-unit>
        <trans-unit id="91ba54d8bd5025bb2cb3e7a4cd0c0785af90a756" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find &lt;code&gt;keep-alive&lt;/code&gt; attributes.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти атрибуты &lt;code&gt;keep-alive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2ac67778b450ed0b9659002961f8409d707930" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find CSS selectors targeting named slots (e.g. &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt;).</source>
          <target state="translated">Запуск &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощника миграции&lt;/a&gt; на вашем код , чтобы найти CSS селекторов таргетинга по имени слота (например , &lt;code&gt;[slot=&quot;my-slot-name&quot;]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb8ef12ba88bdd9ea8d64f474b58bd5f002af15c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find HTML interpolations.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти интерполяции HTML.</target>
        </trans-unit>
        <trans-unit id="e29967481758c6af408495a286989e2f4b3a4403" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find all examples of this hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти все примеры этой ловушки.</target>
        </trans-unit>
        <trans-unit id="131ad91eddecfe4bcd3aa1d2c3dae1e7c9a6d28b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;$dispatch&lt;/code&gt; и &lt;code&gt;$broadcast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5547bdef16b43ebf6aa5572275c3effebf29215" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$remove&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">Запуск &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощника миграции&lt;/a&gt; на ваш код , чтобы найти примеры &lt;code&gt;.$remove&lt;/code&gt; на массиве. Если вы что-то пропустите, вы должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; из-за отсутствующего метода.</target>
        </trans-unit>
        <trans-unit id="4d1a3ee9aa64afee960f48bf970646ff2ca1516a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;.$set&lt;/code&gt; on an array. If you miss any, you should see &lt;strong&gt;console errors&lt;/strong&gt; from the missing method.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;.$set&lt;/code&gt; в массиве. Если вы что-то пропустите, вы должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; из-за отсутствующего метода.</target>
        </trans-unit>
        <trans-unit id="f7cf2f519c21c26383d689b999383e7f48c8daeb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.async&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.config.async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adba4cc2d78c532c252af8489b44bb0c82a60071" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.debug&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.config.debug&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842114654af7636636f5d0ca2790f492b054f6ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.delimiters&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.config.delimiters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56d3c94b1fca7d1fecbd0be685fc6a65bfb4e3ff" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt;. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.config.unsafeDelimiters&lt;/code&gt; . После этого помощник также найдет экземпляры интерполяции HTML, чтобы вы могли заменить их на `v-html`.</target>
        </trans-unit>
        <trans-unit id="7abfe983d07d10f68fd1a923086c66cfb28e6a0a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.elementDirective&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.elementDirective&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbd833dba88270b867f404265f89cd61957dd9e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.partial&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.partial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be876bb1c3f71e3306a218289a786bebe66e6ac" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.set&lt;/code&gt; or &lt;code&gt;Vue.delete&lt;/code&gt; on a Vue instance. If you miss any, they'll trigger &lt;strong&gt;console warnings&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.set&lt;/code&gt; или &lt;code&gt;Vue.delete&lt;/code&gt; в экземпляре Vue. Если вы что-то пропустите, они вызовут &lt;strong&gt;предупреждения консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c98c79eef3d7a23f61df5ef62ac7e471ae74fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;Vue.transition&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;Vue.transition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd48bf0c847ee511a1c8d066fdfbdc6f4f6ffc4" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;replace: false&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;replace: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc77c164d9ea83ca27d60242ad248d1e7b987f0e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.alias&lt;/code&gt; being called.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;router.alias&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cf69302085bdd68f35cf86d99ec675583acea23" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.go&lt;/code&gt; being used where &lt;code&gt;router.push&lt;/code&gt; should be used instead.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры использования &lt;code&gt;router.go&lt;/code&gt; там , где &lt;code&gt;router.push&lt;/code&gt; следует использовать.</target>
        </trans-unit>
        <trans-unit id="e39b23f840933b639f0659fde34e12f635127e7f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.map&lt;/code&gt; being called.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;router.map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b828dfd9e2d7bcae2364000145b56e764e6ebe03" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.on&lt;/code&gt; being called.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;router.on&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9a6975194aa0ce1b5cad1c6626af7c35453fcd0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.redirect&lt;/code&gt; being called.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;router.redirect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc5f2a33706f0e2d3f4cdbd090a5e649c5b6ae0f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;router.start&lt;/code&gt; being called.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;router.start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f2fbe802e2c06eba8dee0a46275f8ee4460bc0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.on&lt;/code&gt;, &lt;code&gt;store.off&lt;/code&gt;, and &lt;code&gt;store.emit&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;store.on&lt;/code&gt; , &lt;code&gt;store.off&lt;/code&gt; и &lt;code&gt;store.emit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00ad6c9fe856a5b4567b7a4dab60a0fe45a37f40" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;store.watch&lt;/code&gt; with a string as the first argument.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;store.watch&lt;/code&gt; со строкой в ​​качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="4f47a47355d74434a753364a679e2f4c9a402ae5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;track-by&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;track-by&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da0f85cb5aa67bdac2ea466f36918db2fcd36b05" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;v-el&lt;/code&gt; and &lt;code&gt;v-ref&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;v-el&lt;/code&gt; и &lt;code&gt;v-ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aa5783c6df3a82bb69131d32c3850e7f84cfda7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$after&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$after&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="09e7d78d817c1fd2a45c3cf9b9c21a2069c4fd37" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$appendTo&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$appendTo&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d7350cc4e203e91682eee37d60894b3e1314af48" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$before&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры использования &lt;code&gt;vm.$before&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c4f878eaed231fe0dbb2225df03cd65dc84e13" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$eval&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$eval&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3f8e856f05355ed8982ce86f4336ff6eacabf3e2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$get&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$get&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0dd654ce3404b139a97c6070c1ea80255ce0fd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$interpolate&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$interpolate&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="81bbbda8f1ba1322792aa46e4294439738bc392f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$log&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$log&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="381f44de62059e317b1f31d7ce9b3541555d602b" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of &lt;code&gt;vm.$remove&lt;/code&gt;. If you miss any, you'll see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;vm.$remove&lt;/code&gt; . Если вы их пропустите, вы увидите &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b874a37ca4886af9d3b7780e6010cf89d9c7f988" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of arbitrary route properties not scoped under meta.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры произвольных свойств маршрута, не относящихся к мета.</target>
        </trans-unit>
        <trans-unit id="1fa158cea69bdd4c40bd2a48988a099538d4dc5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры определенных директив. Помощник отметит их все, так как в большинстве случаев вам может потребоваться выполнить рефакторинг компонента.</target>
        </trans-unit>
        <trans-unit id="979e6458f784d896c90752c57e560652f6c8525d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters being used inside directives. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры фильтров, используемых внутри директив. Если вы что-то пропустите, вы также должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="801a0e4488b5e174aaaa485bb9fbdd0fb7f5b389" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of filters used in directives like &lt;code&gt;v-model&lt;/code&gt;. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры фильтров, используемых в директивах, таких как &lt;code&gt;v-model&lt;/code&gt; . Если вы что-то пропустите, вы также должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83b833ef69efe1e17f7ef29c061f04dea5876bad" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of interpolation used within attributes.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры интерполяции, используемой в атрибутах.</target>
        </trans-unit>
        <trans-unit id="9bb76b174b8438ba3c0f4ba54b4026ce44dd98ca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of overwriting &lt;code&gt;vm.$data&lt;/code&gt;. If you miss any, &lt;strong&gt;console warnings&lt;/strong&gt; will be emitted.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры перезаписи &lt;code&gt;vm.$data&lt;/code&gt; . Если вы что-то пропустите, на &lt;strong&gt;консоли&lt;/strong&gt; появятся &lt;strong&gt;предупреждения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8dbff7c8c83dec265171807e5ec5ea40ea988ad1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of style bindings with &lt;code&gt;!important&lt;/code&gt; in objects.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры привязки стилей с &lt;code&gt;!important&lt;/code&gt; в объектах.</target>
        </trans-unit>
        <trans-unit id="93ebbb2019ca1300c683d3ae1afb72a96650f915" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;$loadingRouteData&lt;/code&gt; meta property.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;$loadingRouteData&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52407d926e2b5716bf90f4cb35758896e87892ed" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;.once&lt;/code&gt; and &lt;code&gt;.sync&lt;/code&gt; modifiers.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры модификаторов &lt;code&gt;.once&lt;/code&gt; и &lt;code&gt;.sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8ce2853d843c2c72201a428aaae4467ceec09d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;abstract: true&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры опции &lt;code&gt;abstract: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2258f58c39858d2874ac267df312bf5774d76c18" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;activate&lt;/code&gt; hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры ловушки &lt;code&gt;activate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d2dd196d33a6838401706a980c174ba91eb1c6e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;cache: false&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры параметра &lt;code&gt;cache: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="635b9a1176068b8a0020a01c4f47cb421d064226" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canActivate&lt;/code&gt; hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;canActivate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ef7f740384cd3cfdf159ef6085f2faaac1ec88f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canDeactivate&lt;/code&gt; hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;canDeactivate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="416c87ed212eefdaa2ddbf02f6a0ba2e74d86959" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;canReuse: false&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры параметра &lt;code&gt;canReuse: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce44d3b81054ffa59cb49fd62f006c1d791e2ab0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;coerce&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры опции &lt;code&gt;coerce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61fdd38d446cfe928998b1181aa744e45596c1c5" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;data&lt;/code&gt; hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры ловушки &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb9b18e06a447d16bfa196a854b2eb06f05360a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;deactivate&lt;/code&gt; hook.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры ловушки &lt;code&gt;deactivate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f483517518991a282467c00ae1cad300e136b269" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;debounce&lt;/code&gt; attribute.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры атрибута &lt;code&gt;debounce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b65067f3a77b357e086f22629678c364185b2ab2" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;hashbang: false&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры опции &lt;code&gt;hashbang: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2e5b8abfbc6295fa11dd1caccde1ae7c3d69af" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;history: true&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры опции &lt;code&gt;history: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452c89b5559555a477ca0eb92f956476ce00d5cd" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;middlewares&lt;/code&gt; option on a store.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;middlewares&lt;/code&gt; в магазине.</target>
        </trans-unit>
        <trans-unit id="6faa58ba44b5eb605740b8397f8693bbaaa6f840" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;root&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;root&lt;/code&gt; параметра.</target>
        </trans-unit>
        <trans-unit id="ab45ded99a30a006bddeceb3fd6aa38bb6c3d9c6" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;saveScrollPosition: true&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры параметра &lt;code&gt;saveScrollPosition: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec2df901f80374c6ff66f398825204e5f18d423" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;subRoutes&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры опции &lt;code&gt;subRoutes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7178b2cc5e9e2a36383d9e60b9eea90fb3bcb121" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;suppressTransitionError: true&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры параметра &lt;code&gt;suppressTransitionError: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e988285e061dd6f2c40c32cddfbc676c1aab12a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры атрибута &lt;code&gt;transition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5f2b82da8cac7dc4262de8c7c93d4a46587dbca" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transition&lt;/code&gt; attribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры атрибута &lt;code&gt;transition&lt;/code&gt; . Во время обновления вы также можете перейти (что очень важно) на новую потрясающую стратегию.</target>
        </trans-unit>
        <trans-unit id="34922f45eeac604f53b4193f84913c2beb89b350" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;transitionOnLoad: true&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры параметра &lt;code&gt;transitionOnLoad: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c97a1b14162dd07775888af56118c3a3370301" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;twoWay&lt;/code&gt; option.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры варианта &lt;code&gt;twoWay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3445799897bdc7ce3106b11c9b2c1f1d554568" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-else&lt;/code&gt; with &lt;code&gt;v-show&lt;/code&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры &lt;code&gt;v-else&lt;/code&gt; с &lt;code&gt;v-show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bccc02e6c6793423ef659db42169cb5afa5716d0" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link-active&lt;/code&gt; directive.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры директивы &lt;code&gt;v-link-active&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea921119a7e1635ac4e5a00b3d8a84491101f3fb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the &lt;code&gt;v-link&lt;/code&gt; directive.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры директивы &lt;code&gt;v-link&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a825bdc145076ec6a6e4b0c215f030aa3ba79b85" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the `.literal` modifier on a directive.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры модификатора `.literal` в директиве.</target>
        </trans-unit>
        <trans-unit id="733bb79e129d2dca49869269db0a3698c6f65fa8" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like &lt;code&gt;position&lt;/code&gt; or &lt;code&gt;num&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры устаревшего порядка аргументов. Обратите внимание: если вы назовете свои аргументы индекса чем-то необычным, например &lt;code&gt;position&lt;/code&gt; или &lt;code&gt;num&lt;/code&gt; , помощник не будет их отмечать.</target>
        </trans-unit>
        <trans-unit id="da725380e126a62727af458ad28bac7c6524d798" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;property&lt;/code&gt;, the helper will not flag them.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры устаревшего порядка аргументов. Обратите внимание, что если вы назовете свои ключевые аргументы чем-то вроде &lt;code&gt;name&lt;/code&gt; или &lt;code&gt;property&lt;/code&gt; , помощник не будет их отмечать.</target>
        </trans-unit>
        <trans-unit id="f1e1035d99ed76f7515df578e692ff719107895a" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete route syntax.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры устаревшего синтаксиса маршрута.</target>
        </trans-unit>
        <trans-unit id="142bb71333ac86e488c9aacc373010de66e961e1" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete text filters. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры устаревших текстовых фильтров. Если вы что-то пропустите, вы также должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="397d5ab0302428112127147010f4482ef9051b5e" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the obsolete usage.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры устаревшего использования.</target>
        </trans-unit>
        <trans-unit id="c1aa36c4bb555ce2607bb2d08c4631182d133d50" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the old filter syntax. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt;.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры старого синтаксиса фильтра. Если вы что-то пропустите, вы также должны увидеть &lt;strong&gt;ошибки консоли&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="20564b7f4450c4fa59c4a3ba6fa87121c27fe89f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the the old &lt;code&gt;keyCode&lt;/code&gt; configuration syntax.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры старого синтаксиса конфигурации &lt;code&gt;keyCode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc0976e79e68e3874825b8d9309f7bc3cf13503f" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of the these param attributes.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры этих атрибутов параметров.</target>
        </trans-unit>
        <trans-unit id="4a53e2c9b9e1ccea5753bf6c5b26aa93f8d31041" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find examples of these removed variables. If you miss any, you should also see &lt;strong&gt;console errors&lt;/strong&gt; such as: &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти примеры этих удаленных переменных. Если вы пропустите что-либо, вы также должны увидеть &lt;strong&gt;ошибки консоли,&lt;/strong&gt; такие как: &lt;code&gt;Uncaught ReferenceError: $index is not defined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0ae781de5086e5c0e4123dc4514d344522a5237" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on your codebase to find one-time bindings.</source>
          <target state="translated">Запустите &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощник&lt;/a&gt; по миграции в своей кодовой базе, чтобы найти одноразовые привязки.</target>
        </trans-unit>
        <trans-unit id="2c800955474c5ae66271d1f51e3a706afff6e929" translate="yes" xml:space="preserve">
          <source>Run your bundling command with the actual &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable set to &lt;code&gt;&quot;production&quot;&lt;/code&gt;. This tells &lt;code&gt;vueify&lt;/code&gt; to avoid including hot-reload and development related code.</source>
          <target state="translated">Запустите команду связывания с фактической переменной среды &lt;code&gt;NODE_ENV&lt;/code&gt; , установленной на &lt;code&gt;&quot;production&quot;&lt;/code&gt; . Это говорит &lt;code&gt;vueify&lt;/code&gt; избегать включения кода горячей перезагрузки и разработки.</target>
        </trans-unit>
        <trans-unit id="65124f23df07644ee66ed5e04606bd6c7b54318b" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about duplicate slots &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">Запустите комплексный тестовый набор или приложение после обновления и поищите &lt;strong&gt;предупреждения консоли&lt;/strong&gt; о повторяющихся слотах &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0276baa533bc89d334fafab4aee362813fb56fba" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about inline value attributes with &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">После обновления запустите комплексный тестовый набор или приложение и найдите &lt;strong&gt;предупреждения консоли&lt;/strong&gt; о встроенных атрибутах значений с &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9168febc3cd9fb510564d5d619d53cfceebc829" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about multiple root elements in a template.</source>
          <target state="translated">После обновления запустите комплексный тестовый пакет или приложение и найдите &lt;strong&gt;предупреждения консоли&lt;/strong&gt; о нескольких корневых элементах в шаблоне.</target>
        </trans-unit>
        <trans-unit id="6cd905d20455b18138224bc59c413711a6de22a2" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about prop mutations.</source>
          <target state="translated">Запустите комплексный тестовый пакет или приложение после обновления и поищите &lt;strong&gt;предупреждения консоли&lt;/strong&gt; о мутациях свойств.</target>
        </trans-unit>
        <trans-unit id="7da416f4436591687e3ea5cf9d579fb6711b7dbd" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite or app after upgrading and look for &lt;strong&gt;console warnings&lt;/strong&gt; about the &lt;code&gt;el&lt;/code&gt; option with &lt;code&gt;Vue.extend&lt;/code&gt;.</source>
          <target state="translated">После обновления запустите комплексный тестовый пакет или приложение и найдите &lt;strong&gt;предупреждения консоли&lt;/strong&gt; о параметре &lt;code&gt;el&lt;/code&gt; с помощью &lt;code&gt;Vue.extend&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de5aa3b1e8bcd9a2e9b6648cc6da29ebd7c682fa" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">Запустите комплекс сквозных тестов, если он у вас есть. В &lt;strong&gt;неудачных испытаниях&lt;/strong&gt; должны предупредить вас , чтобы любую часть вашего приложения , которые могут быть затронуты этим изменением.</target>
        </trans-unit>
        <trans-unit id="25b0475e8303e55dc27cdda9bbd8ef8c1c492011" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that a watcher was relying on the old behavior.</source>
          <target state="translated">Запустите комплекс сквозных тестов, если он у вас есть. В &lt;strong&gt;неудачных испытаниях&lt;/strong&gt; должны предупреждать вас о том , что наблюдатель был опирающимся на старом поведении.</target>
        </trans-unit>
        <trans-unit id="3925b4e9140324a46bda954fa3ba6a11551d44d8" translate="yes" xml:space="preserve">
          <source>Run your end-to-end test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to the fact that props passed to root instances are no longer working.</source>
          <target state="translated">Запустите комплекс сквозных тестов, если он у вас есть. В &lt;strong&gt;неудачных испытаниях&lt;/strong&gt; должны предупреждать вас о том , что реквизит , передаваемый корневые экземпляры, больше не работает.</target>
        </trans-unit>
        <trans-unit id="c7a107bdb49919e8c77ec76a87618731104be368" translate="yes" xml:space="preserve">
          <source>Run your test suite, if you have one. The &lt;strong&gt;failed tests&lt;/strong&gt; should alert to you to any parts of your app that may be affected by this change.</source>
          <target state="translated">Запустите свой набор тестов, если он у вас есть. В &lt;strong&gt;неудачных испытаниях&lt;/strong&gt; должны предупредить вас , чтобы любую часть вашего приложения , которые могут быть затронуты этим изменением.</target>
        </trans-unit>
        <trans-unit id="13285023695c206297d4666f3184c48b775d9ec3" translate="yes" xml:space="preserve">
          <source>Runtime + Compiler vs. Runtime-only</source>
          <target state="translated">Runtime+Compiler против Runtime-only</target>
        </trans-unit>
        <trans-unit id="ce3caf82d6dc4282305777c04d22cb7e32e8739f" translate="yes" xml:space="preserve">
          <source>Runtime Performance</source>
          <target state="translated">Производительность в режиме реального времени</target>
        </trans-unit>
        <trans-unit id="0ab3eee80056a96ec147159fe704ef0b8dcd1e74" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#slot-scope&quot;&gt;&lt;code&gt;slot-scope&lt;/code&gt;&lt;/a&gt; except that &lt;code&gt;scope&lt;/code&gt; can only be used on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">То же, что и &lt;a href=&quot;#slot-scope&quot;&gt; &lt;code&gt;slot-scope&lt;/code&gt; ,&lt;/a&gt; за исключением того, что &lt;code&gt;scope&lt;/code&gt; может использоваться только для элементов &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c41f297530a1a4027d4fe5146dc89421c3603b93" translate="yes" xml:space="preserve">
          <source>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:</source>
          <target state="translated">Сара Драснер демонстрирует это в демонстрационном примере ниже,используя комбинацию изменения состояния,обусловленного временем и интерактивностью:</target>
        </trans-unit>
        <trans-unit id="a29f0256272e79ca91a1c4e608f09a6264397d12" translate="yes" xml:space="preserve">
          <source>Scale</source>
          <target state="translated">Scale</target>
        </trans-unit>
        <trans-unit id="88011a37856972ada6fede54fa2220927bfb5ac0" translate="yes" xml:space="preserve">
          <source>Scaling Down</source>
          <target state="translated">Масштабирование вниз</target>
        </trans-unit>
        <trans-unit id="2d20a53538fb773c0616dc1ef8c4f21c2ceb637d" translate="yes" xml:space="preserve">
          <source>Scaling Up</source>
          <target state="translated">Увеличение масштаба</target>
        </trans-unit>
        <trans-unit id="bf1e630e7268556a0635e37341aa31c69f284094" translate="yes" xml:space="preserve">
          <source>Scoped Slots</source>
          <target state="translated">Скопированные слоты</target>
        </trans-unit>
        <trans-unit id="c891d436871bb971da8c2ff8081958bff3ddb19a" translate="yes" xml:space="preserve">
          <source>Scoped Slots with the &lt;code&gt;slot-scope&lt;/code&gt; Attribute</source>
          <target state="translated">Слоты с заданной &lt;code&gt;slot-scope&lt;/code&gt; атрибутом слот-области</target>
        </trans-unit>
        <trans-unit id="6aa971b69d2fe9a8fec7d58fa039f9aafe0f8da1" translate="yes" xml:space="preserve">
          <source>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Функции слотов с заданной областью теперь гарантированно возвращают массив VNodes, если возвращаемое значение не является недопустимым, и в этом случае функция вернет &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa277d957af13fbcf610edac48d6ff9d1d53991" translate="yes" xml:space="preserve">
          <source>Search your codebase for the regex &lt;code&gt;/\w+ in \d+/&lt;/code&gt;. Wherever it appears in a &lt;code&gt;v-for&lt;/code&gt;, check to see if you may be affected.</source>
          <target state="translated">Найдите в своей кодовой базе регулярное выражение &lt;code&gt;/\w+ in \d+/&lt;/code&gt; . Где бы он ни появлялся в &lt;code&gt;v-for&lt;/code&gt; , проверьте, может ли это повлиять на вас.</target>
        </trans-unit>
        <trans-unit id="0d4f1b3e1926d0de28455af2f7b050061aa08a61" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;this fiddle&lt;/a&gt; for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we&amp;rsquo;d recommend creating a reusable &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">См. &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/1Leb7up8/&quot;&gt;Этот скрипт&lt;/a&gt; для получения полного кода. Однако обратите внимание, что если вам приходится выполнять большую настройку и очистку в пределах одного компонента, лучшим решением обычно будет создание большего количества модульных компонентов. В этом случае мы рекомендуем создать повторно используемый компонент &lt;code&gt;&amp;lt;input-datepicker&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04b10db48b879dd4894715118934c8f16e790244" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;this fiddle&lt;/a&gt; for the complete code behind the above demo.</source>
          <target state="translated">См. &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/65gLu2b6/&quot;&gt;Этот скрипт&lt;/a&gt; для получения полного кода приведенной выше демонстрации.</target>
        </trans-unit>
        <trans-unit id="030b52b1aecbbfd160c5986ee59275d22c9f7672" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;this fiddle&lt;/a&gt; to experiment with the full code, or &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;this version&lt;/a&gt; for an example binding to a component&amp;rsquo;s options object, instead of its registered name.</source>
          <target state="translated">См. &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/o3nycadu/&quot;&gt;Эту скрипту,&lt;/a&gt; чтобы поэкспериментировать с полным кодом, или &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/b2qj69o1/&quot;&gt;эту версию,&lt;/a&gt; чтобы увидеть пример привязки к объекту параметров компонента, а не к его зарегистрированному имени.</target>
        </trans-unit>
        <trans-unit id="bc6fd808ffb90ac93f1cb9d312e01c08b9a59bf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;TypeScript compiler options docs&lt;/a&gt; for more details.</source>
          <target state="translated">Дополнительные сведения см. В &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/compiler-options.html&quot;&gt;документации&lt;/a&gt; по параметрам компилятора TypeScript .</target>
        </trans-unit>
        <trans-unit id="8f4b188488a5cff189e4cfc9d54ff0931435281a" translate="yes" xml:space="preserve">
          <source>See example &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;the plugins docs&lt;/a&gt; for more info.</source>
          <target state="translated">См. Пример &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;документации плагинов&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b7cdc723bd45704f63d3132765b8411da257e1bf" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Vue-controlled Wall-E&lt;/a&gt; by Sarah Drasner (&lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://codepen.io/sdras/pen/YZBGNp/&quot;&gt;Управляемую&lt;/a&gt; Pen Vue Wall-E от Сары Драснер ( &lt;a href=&quot;https://codepen.io/sdras&quot;&gt;@sdras&lt;/a&gt; ) на &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8598222918d3c6e513d63060cf55e2971ded729a" translate="yes" xml:space="preserve">
          <source>Select</source>
          <target state="translated">Select</target>
        </trans-unit>
        <trans-unit id="d84be9de2f9e35e379e0e4f6e0bb2340cf1b2d0b" translate="yes" xml:space="preserve">
          <source>Select Options</source>
          <target state="translated">Выберите Опции</target>
        </trans-unit>
        <trans-unit id="33e3b8ff7914aff97145e0add0103e5154bdde21" translate="yes" xml:space="preserve">
          <source>Self-closing components</source>
          <target state="translated">Самозакрывающиеся компоненты</target>
        </trans-unit>
        <trans-unit id="8aa1710830cfa45dfe404022342d5aade64a9767" translate="yes" xml:space="preserve">
          <source>Self-closing components &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется&lt;/sup&gt; самозакрывающиеся компоненты&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="01fe9a20a8fdeb0f312fdcea1363c6a939cf772b" translate="yes" xml:space="preserve">
          <source>Server-Side Rendering</source>
          <target state="translated">Рендеринг на стороне сервера</target>
        </trans-unit>
        <trans-unit id="d986e7075907e08286bd92c14ff694e5215b1ede" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;false&lt;/code&gt; to prevent the production tip on Vue startup.</source>
          <target state="translated">Установите значение &lt;code&gt;false&lt;/code&gt; , чтобы предотвратить появление подсказки при запуске Vue.</target>
        </trans-unit>
        <trans-unit id="0322b76a288cd27bf5d650f3c073fe32426bc786" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; API.</source>
          <target state="translated">Установите для этого параметра значение &lt;code&gt;true&lt;/code&gt; , чтобы включить отслеживание производительности инициализации, компиляции, рендеринга и исправления компонентов на панели производительности / шкалы времени инструмента разработчика браузера. Работает только в режиме разработки и в браузерах, поддерживающих API &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark&quot;&gt;performance.mark&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97f2f59947f62c014c5d7c2a4de9191db27303ae" translate="yes" xml:space="preserve">
          <source>Share (and Build) Your Experience</source>
          <target state="translated">Поделитесь (и создайте)своим опытом</target>
        </trans-unit>
        <trans-unit id="89dd25c3e7bb9f776951ef9ad74e60a7d6dd05bb" translate="yes" xml:space="preserve">
          <source>Shorthands</source>
          <target state="translated">Shorthands</target>
        </trans-unit>
        <trans-unit id="1ae7276e79db945fd551dc9db134399c32bb6984" translate="yes" xml:space="preserve">
          <source>Should either be updated to use an inline expression:</source>
          <target state="translated">Должны быть либо обновлены,чтобы использовать выражение в строке:</target>
        </trans-unit>
        <trans-unit id="b0a3536bb7788ee14bd41892adba577744a1012d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;$root&lt;/code&gt;, the &lt;code&gt;$parent&lt;/code&gt; property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</source>
          <target state="translated">Подобно &lt;code&gt;$root&lt;/code&gt; , свойство &lt;code&gt;$parent&lt;/code&gt; можно использовать для доступа к родительскому экземпляру из дочернего элемента. Это может быть соблазнительно использовать как ленивую альтернативу передаче данных с помощью опоры.</target>
        </trans-unit>
        <trans-unit id="dadac4906f4bc6e4a81d9058bdcbf1bbcb397f71" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-else&lt;/code&gt;, a &lt;code&gt;v-else-if&lt;/code&gt; element must immediately follow a &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-else-if&lt;/code&gt; element.</source>
          <target state="translated">Подобно &lt;code&gt;v-else&lt;/code&gt; , элемент &lt;code&gt;v-else-if&lt;/code&gt; должен сразу следовать за элементом &lt;code&gt;v-if&lt;/code&gt; или &lt;code&gt;v-else-if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af9b7b6d2657eb7de92b424e723e1ce34e27dd45" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;v-on&lt;/code&gt; and &lt;code&gt;v-bind&lt;/code&gt;, &lt;code&gt;v-slot&lt;/code&gt; also has a shorthand, replacing everything before the argument (&lt;code&gt;v-slot:&lt;/code&gt;) with the special symbol &lt;code&gt;#&lt;/code&gt;. For example, &lt;code&gt;v-slot:header&lt;/code&gt; can be rewritten as &lt;code&gt;#header&lt;/code&gt;:</source>
          <target state="translated">Подобно &lt;code&gt;v-on&lt;/code&gt; и &lt;code&gt;v-bind&lt;/code&gt; , &lt;code&gt;v-slot&lt;/code&gt; также имеет сокращение, заменяющее все перед аргументом ( &lt;code&gt;v-slot:&lt;/code&gt; ) специальным символом &lt;code&gt;#&lt;/code&gt; . Например, &lt;code&gt;v-slot:header&lt;/code&gt; можно переписать как &lt;code&gt;#header&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="110921f9f16f79ec9020d42a774f85de76c9358e" translate="yes" xml:space="preserve">
          <source>Similar to prop defaults, you need to use a factory function for non primitive values:</source>
          <target state="translated">Как и в случае со значениями по умолчанию prop,для не примитивных значений необходимо использовать заводскую функцию:</target>
        </trans-unit>
        <trans-unit id="3115d0b13d887f54dba012634384e7c25cfdf659" translate="yes" xml:space="preserve">
          <source>Similar to template &lt;code&gt;v-if&lt;/code&gt;, you can also use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag with &lt;code&gt;v-for&lt;/code&gt; to render a block of multiple elements. For example:</source>
          <target state="translated">Подобно шаблону &lt;code&gt;v-if&lt;/code&gt; , вы также можете использовать &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; с &lt;code&gt;v-for&lt;/code&gt; для визуализации блока из нескольких элементов. Например:</target>
        </trans-unit>
        <trans-unit id="9032b6dd131e5bdf77e7f1e8c9ad6ef9e98b4db4" translate="yes" xml:space="preserve">
          <source>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</source>
          <target state="translated">Аналогичным образом,вы можете использовать динамические аргументы для привязки обработчика к имени динамического события:</target>
        </trans-unit>
        <trans-unit id="e756f11c70f78a0ba1866d4795579c59fa6d1833" translate="yes" xml:space="preserve">
          <source>Simple Assertions</source>
          <target state="translated">Простые утверждения</target>
        </trans-unit>
        <trans-unit id="bbba1d068bf49ca0e64f1e344f51043367c2266d" translate="yes" xml:space="preserve">
          <source>Simple Routing From Scratch</source>
          <target state="translated">Простая маршрутизация от царапин</target>
        </trans-unit>
        <trans-unit id="4e794aae53f27e868a697d7573dd5ec04e937e2a" translate="yes" xml:space="preserve">
          <source>Simple State Management from Scratch</source>
          <target state="translated">Простое управление состоянием от Scratch</target>
        </trans-unit>
        <trans-unit id="7a423acd4331de7d207764fc94ba09543c17ef88" translate="yes" xml:space="preserve">
          <source>Simple computed properties</source>
          <target state="translated">Простые вычисления свойств</target>
        </trans-unit>
        <trans-unit id="28fbbfbd1e3c5e7641094f470de044776bb5ad02" translate="yes" xml:space="preserve">
          <source>Simple computed properties &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; простые вычисляемые свойства&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="37761f78a8d655b3953b071e198e22dcd5a02587" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates</source>
          <target state="translated">Простые выражения в шаблонах</target>
        </trans-unit>
        <trans-unit id="fcf7b67ac329ddfb22fdf3fbec785727bf9bf466" translate="yes" xml:space="preserve">
          <source>Simple expressions in templates &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; простые выражения в шаблонах&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="211d49f995dbe282f57faa15874e031ac53eeff7" translate="yes" xml:space="preserve">
          <source>Simpler, well-named computed properties are:</source>
          <target state="translated">Более простые,хорошо названные вычислительные свойства:</target>
        </trans-unit>
        <trans-unit id="63a2bccabf19824dace120aef2460e5986003d8a" translate="yes" xml:space="preserve">
          <source>Simplifying computed properties forces you to give each value a descriptive name, even if it&amp;rsquo;s not reused. This makes it much easier for other developers (and future you) to focus in on the code they care about and figure out what&amp;rsquo;s going on.</source>
          <target state="translated">Упрощение вычисляемых свойств заставляет вас давать каждому значению описательное имя, даже если оно не используется повторно. Это позволяет другим разработчикам (и вам в будущем) сосредоточиться на коде, который им небезразличен, и понять, что происходит.</target>
        </trans-unit>
        <trans-unit id="5fd1e98b263d4df6091312537a5b1fb83da16e24" translate="yes" xml:space="preserve">
          <source>Simply download and include with a script tag. &lt;code&gt;Vue&lt;/code&gt; will be registered as a global variable.</source>
          <target state="translated">Просто скачайте и включите с тегом сценария. &lt;code&gt;Vue&lt;/code&gt; будет зарегистрирован как глобальная переменная.</target>
        </trans-unit>
        <trans-unit id="d5938f34f8624b63802c3118f180d5e293766247" translate="yes" xml:space="preserve">
          <source>Simultaneous entering and leaving transitions aren&amp;rsquo;t always desirable though, so Vue offers some alternative &lt;strong&gt;transition modes&lt;/strong&gt;:</source>
          <target state="translated">Однако одновременный вход и выход из переходов не всегда желателен, поэтому Vue предлагает несколько альтернативных &lt;strong&gt;режимов перехода&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="6a69d78f54bcf8ac6e1f4a3963e04cee33a026d0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;$nextTick()&lt;/code&gt; returns a promise, you can achieve the same as the above using the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;ES2016 async/await&lt;/a&gt; syntax:</source>
          <target state="translated">Поскольку &lt;code&gt;$nextTick()&lt;/code&gt; возвращает обещание, вы можете добиться того же, что и выше, используя новый &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;синтаксис ES2016 async / await&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="10a777de149e5a77b75501c009eb466a9bc93514" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;v-ref&lt;/code&gt; is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with &lt;code&gt;v-for&lt;/code&gt;. For example:</source>
          <target state="translated">Поскольку &lt;code&gt;v-ref&lt;/code&gt; больше не директива, а специальный атрибут, его также можно определять динамически. Это особенно полезно в сочетании с &lt;code&gt;v-for&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="9de3c1e0a71e1edcdc7ffbc2b45060ebfe43b095" translate="yes" xml:space="preserve">
          <source>Since Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;performs DOM updates asynchronously&lt;/a&gt;, assertions on DOM updates resulting from state change will have to be made in a &lt;code&gt;Vue.nextTick&lt;/code&gt; callback:</source>
          <target state="translated">Поскольку Vue &lt;a href=&quot;reactivity#Async-Update-Queue&quot;&gt;выполняет обновления DOM асинхронно&lt;/a&gt; , утверждения об обновлениях DOM в результате изменения состояния должны быть сделаны в &lt;code&gt;Vue.nextTick&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6f5eaf2601394efec9f1b3f5eff696573b84807" translate="yes" xml:space="preserve">
          <source>Since Vue doesn&amp;rsquo;t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</source>
          <target state="translated">Поскольку Vue не позволяет динамически добавлять реактивные свойства корневого уровня, вы должны инициализировать экземпляры Vue, заранее объявив все реактивные свойства данных корневого уровня, даже с пустым значением:</target>
        </trans-unit>
        <trans-unit id="17a485dec90726f134aafab30671454807556666" translate="yes" xml:space="preserve">
          <source>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. &lt;code&gt;MyButton&lt;/code&gt;, &lt;code&gt;VueButton&lt;/code&gt;).</source>
          <target state="translated">Поскольку имена компонентов всегда должны состоять из нескольких слов, это соглашение избавляет вас от необходимости выбирать произвольный префикс для простых оболочек компонентов (например, &lt;code&gt;MyButton&lt;/code&gt; , &lt;code&gt;VueButton&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba2168060abb1674449c97121137c7602377ef42" translate="yes" xml:space="preserve">
          <source>Since components are reusable Vue instances, they accept the same options as &lt;code&gt;new Vue&lt;/code&gt;, such as &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, and lifecycle hooks. The only exceptions are a few root-specific options like &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">Поскольку компоненты являются многократно используемыми экземплярами Vue, они принимают те же параметры, что и &lt;code&gt;new Vue&lt;/code&gt; , такие как &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; , &lt;code&gt;watch&lt;/code&gt; , &lt;code&gt;methods&lt;/code&gt; и перехватчики жизненного цикла. Единственное исключение - несколько параметров, зависящих от root, например &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b68173db2c99b86c3a75462f226a7b75ff0f1d5" translate="yes" xml:space="preserve">
          <source>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</source>
          <target state="translated">Поскольку редакторы обычно организуют файлы в алфавитном порядке,все важные взаимосвязи между компонентами теперь очевидны с первого взгляда.</target>
        </trans-unit>
        <trans-unit id="ef79f75d79e817472bd0ed5aad52845e59dbf2e4" translate="yes" xml:space="preserve">
          <source>Since functional components are just functions, they&amp;rsquo;re much cheaper to render.</source>
          <target state="translated">Поскольку функциональные компоненты - это просто функции, их визуализация намного дешевле.</target>
        </trans-unit>
        <trans-unit id="5ca066badcd55a6324af0033eddd42706cb8d9c3" translate="yes" xml:space="preserve">
          <source>Since it&amp;rsquo;s a generic mechanism for Vue to identify nodes, the &lt;code&gt;key&lt;/code&gt; also has other uses that are not specifically tied to &lt;code&gt;v-for&lt;/code&gt;, as we will see later in the guide.</source>
          <target state="translated">Поскольку это общий механизм для Vue для идентификации узлов, &lt;code&gt;key&lt;/code&gt; также может использоваться и в других целях, которые специально не привязаны к &lt;code&gt;v-for&lt;/code&gt; , как мы увидим позже в руководстве.</target>
        </trans-unit>
        <trans-unit id="c460325ca52e3630249720f5552ae7b020e4765a" translate="yes" xml:space="preserve">
          <source>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</source>
          <target state="translated">Так как сборки только для исполнения примерно на 30% легче,чем их полносборные аналоги,Вы должны использовать их везде,где это возможно.Если Вы всё ещё хотите использовать полную сборку вместо неё,Вам необходимо настроить псевдоним в своём пакете:</target>
        </trans-unit>
        <trans-unit id="e62e1d6e39e14f551529b609a48c6fb619bb1df6" translate="yes" xml:space="preserve">
          <source>Since these are &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;published on NPM&lt;/a&gt;, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don&amp;rsquo;t need any additional tooling to use TypeScript with Vue.</source>
          <target state="translated">Поскольку они &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/types/&quot;&gt;публикуются в NPM&lt;/a&gt; , а последняя версия TypeScript знает, как разрешать объявления типов в пакетах NPM, это означает, что при установке через NPM вам не нужны дополнительные инструменты для использования TypeScript с Vue.</target>
        </trans-unit>
        <trans-unit id="4ea3d2ff946bc5b79835d964012d367a993b9ca6" translate="yes" xml:space="preserve">
          <source>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</source>
          <target state="translated">Поскольку эти компоненты так часто используются,вы можете просто сделать их глобальными,вместо того,чтобы импортировать их повсюду.Префикс делает это возможным при использовании Webpack:</target>
        </trans-unit>
        <trans-unit id="796906cd98540356e295c43d625d24ed68862aac" translate="yes" xml:space="preserve">
          <source>Since we&amp;rsquo;re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</source>
          <target state="translated">Поскольку мы больше не используем параметры фильтра, требующие возврата значения, наша работа с валютой фактически может выполняться асинхронно. Это означает, что если бы у нас было много приложений, которые должны работать с валютами, мы могли бы легко реорганизовать эту логику в общий микросервис.</target>
        </trans-unit>
        <trans-unit id="a31aa77b805847e93b5d67d3ae054b43de8ddfb3" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</source>
          <target state="translated">Поскольку вам не нужно вручную прикреплять прослушиватели событий в JS, ваш код ViewModel может быть чистой логикой и без DOM. Это упрощает тестирование.</target>
        </trans-unit>
        <trans-unit id="59debd2931aa770a2b0975329d41213dcd9c5d88" translate="yes" xml:space="preserve">
          <source>Since you don&amp;rsquo;t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; to learn enough to build non-trivial applications.</source>
          <target state="translated">Поскольку вам не нужно знать о JSX, ES2015 или системах сборки, чтобы начать работу с Vue, разработчикам обычно требуется меньше дня, чтобы прочитать &lt;a href=&quot;../index&quot;&gt;руководство,&lt;/a&gt; чтобы узнать достаточно, чтобы создавать нетривиальные приложения.</target>
        </trans-unit>
        <trans-unit id="4a6e205b866dd29d282ce270191d3645216b482d" translate="yes" xml:space="preserve">
          <source>Single File Components</source>
          <target state="translated">Компоненты из одного файла</target>
        </trans-unit>
        <trans-unit id="5e7f1d7d63552994a465b38c32202f3620abe335" translate="yes" xml:space="preserve">
          <source>Single checkbox, boolean value:</source>
          <target state="translated">Одинарный флажок,булевое значение:</target>
        </trans-unit>
        <trans-unit id="040f06c8b02b9ecd8ce3bcc463d52f44ab71de30" translate="yes" xml:space="preserve">
          <source>Single select:</source>
          <target state="translated">Одиночный выбор:</target>
        </trans-unit>
        <trans-unit id="95ef58f9b3d77202b180ce829f19b7953db91e4d" translate="yes" xml:space="preserve">
          <source>Single-file (&lt;code&gt;.vue&lt;/code&gt;) components</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; ( .vue ) компоненты</target>
        </trans-unit>
        <trans-unit id="a0fcc7019dc5bbeb59c13b0247440b91dff10e8e" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing</source>
          <target state="translated">Однофайловый корпус с именем компонента</target>
        </trans-unit>
        <trans-unit id="093c716d53dd968ee64e9ba688e8285861d21500" translate="yes" xml:space="preserve">
          <source>Single-file component filename casing &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; регистр имени файла однофайлового компонента&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="aad2c1946beed7073bd3f80b10b836af1bd801c0" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order</source>
          <target state="translated">Заказ однофайловых элементов верхнего уровня</target>
        </trans-unit>
        <trans-unit id="369e619c0ac6b0e41c0c5e5672725a1dad22811c" translate="yes" xml:space="preserve">
          <source>Single-file component top-level element order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Рекомендуется&lt;/sup&gt; порядок элементов верхнего уровня однофайлового компонента&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e5ab16f7ba44150cac61508afe92cbd1d1dd294b" translate="yes" xml:space="preserve">
          <source>Single-instance component names</source>
          <target state="translated">Названия отдельных компонентов</target>
        </trans-unit>
        <trans-unit id="801a9b431b0affdfa69d3dd93084d1b29dae9cb0" translate="yes" xml:space="preserve">
          <source>Single-instance component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; одноразовые имена компонентов.&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="896ccfe8515d070b5a15610d907daecc5196a888" translate="yes" xml:space="preserve">
          <source>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</source>
          <target state="translated">Пропустите компиляцию для этого элемента и всех его детей.Вы можете использовать это для отображения необработанных тегов усов.Пропуск большого количества узлов без директив на них также может ускорить компиляцию.</target>
        </trans-unit>
        <trans-unit id="083d20797ac518ecfd2d5802f11e56f053d9b2a3" translate="yes" xml:space="preserve">
          <source>Slot Content</source>
          <target state="translated">Содержание слота</target>
        </trans-unit>
        <trans-unit id="0c1a16e17517d5db584e59f03e5701a1df0aec29" translate="yes" xml:space="preserve">
          <source>Slots</source>
          <target state="translated">Slots</target>
        </trans-unit>
        <trans-unit id="0c05d5215c9958f423cfa89492ade3561c496be1" translate="yes" xml:space="preserve">
          <source>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</source>
          <target state="translated">Небольшие,сфокусированные вычислительные свойства делают меньше предположений о том,как будет использоваться информация,поэтому требуют меньшего рефакторинга по мере изменения требований.</target>
        </trans-unit>
        <trans-unit id="270782c16d7dfcd9bacc30c93f3205da13a192a6" translate="yes" xml:space="preserve">
          <source>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</source>
          <target state="translated">Поэтому,даже если мы отображаем элементы только для небольшой части пользователей,нам приходится каждый раз при повторном отрисовывании повторять итерацию по всему списку,независимо от того,изменился ли набор активных пользователей или нет.</target>
        </trans-unit>
        <trans-unit id="9efa5f0263f4584699ee25a6ef7cd96b38af2cbd" translate="yes" xml:space="preserve">
          <source>So far we&amp;rsquo;ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</source>
          <target state="translated">Пока мы привязывались только к простым ключам свойств в наших шаблонах. Но Vue.js на самом деле поддерживает всю мощь выражений JavaScript внутри всех привязок данных:</target>
        </trans-unit>
        <trans-unit id="fc43cc8fe805d607917adfb57b267a4c1e366e21" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve managed transitions for:</source>
          <target state="translated">На данный момент мы осуществили переходы для:</target>
        </trans-unit>
        <trans-unit id="9990ce27d68bc258ecfe618b1e117aba2e010d2d" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only created components using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">Пока что мы создали только компоненты с использованием &lt;code&gt;Vue.component&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="67796fb098e807812b451996ffa7c37901a92525" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve only seen props listed as an array of strings:</source>
          <target state="translated">До сих пор мы видели только реквизиты, перечисленные в виде массива строк:</target>
        </trans-unit>
        <trans-unit id="bcb7e6dc22797e50c31c81c6ca57f0d64cd4b40a" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen props passed a static value, like in:</source>
          <target state="translated">До сих пор вы видели, что реквизитам передается статическое значение, например:</target>
        </trans-unit>
        <trans-unit id="bf5ea7f867584dc6f766ba242591c6f576f49d80" translate="yes" xml:space="preserve">
          <source>So far, you&amp;rsquo;ve seen uses of &lt;code&gt;$emit&lt;/code&gt;, listened to with &lt;code&gt;v-on&lt;/code&gt;, but Vue instances also offer other methods in its events interface. We can:</source>
          <target state="translated">До сих пор вы видели использование &lt;code&gt;$emit&lt;/code&gt; , прослушиваемое с помощью &lt;code&gt;v-on&lt;/code&gt; , но экземпляры Vue также предлагают другие методы в своем интерфейсе событий. Мы можем:</target>
        </trans-unit>
        <trans-unit id="8d84a44b86d81a516326f9813e2b3977e997a457" translate="yes" xml:space="preserve">
          <source>So this might be a good time to refactor the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to accept a single &lt;code&gt;post&lt;/code&gt; prop instead:</source>
          <target state="translated">Так что сейчас самое время реорганизовать компонент &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; , чтобы вместо этого принять одну опору &lt;code&gt;post&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6aa2762b60d0919d3cc5d125c99532a28d73b78" translate="yes" xml:space="preserve">
          <source>So what about for when we have a whole list of items we want to render simultaneously, for example with &lt;code&gt;v-for&lt;/code&gt;? In this case, we&amp;rsquo;ll use the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component. Before we dive into an example though, there are a few things that are important to know about this component:</source>
          <target state="translated">Так что насчет того, когда у нас есть целый список элементов, которые мы хотим отображать одновременно, например, с помощью &lt;code&gt;v-for&lt;/code&gt; ? В этом случае мы будем использовать компонент &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; . Однако, прежде чем мы погрузимся в пример, важно знать несколько вещей об этом компоненте:</target>
        </trans-unit>
        <trans-unit id="147f6354f521a67959c12f2f8261d77ce2bb9c39" translate="yes" xml:space="preserve">
          <source>Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="translated">Некоторые элементы HTML, такие как &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , имеют ограничения на то, какие элементы могут появляться внутри них, а некоторые элементы, такие как &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; , могут только появляются внутри некоторых других элементов.</target>
        </trans-unit>
        <trans-unit id="9c0790e8dcd7f3a0c69aa32f511de55c1f1ea0e6" translate="yes" xml:space="preserve">
          <source>Some advantages of this convention:</source>
          <target state="translated">Некоторые преимущества этой конвенции:</target>
        </trans-unit>
        <trans-unit id="2108424fbba417074fadf0d75a3e1edc693ebce6" translate="yes" xml:space="preserve">
          <source>Some argue that you&amp;rsquo;d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn&amp;rsquo;t mean the user doesn&amp;rsquo;t need to learn anything - it&amp;rsquo;s additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it&amp;rsquo;s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. &lt;code&gt;v-on&lt;/code&gt; modifiers). The same task can involve a lot more code when using plain JSX or render functions.</source>
          <target state="translated">Некоторые утверждают, что вам нужно изучить дополнительный DSL (предметно-ориентированный язык), чтобы иметь возможность писать шаблоны - мы считаем, что это различие в лучшем случае является поверхностным. Во-первых, JSX не означает, что пользователю не нужно ничего изучать - это дополнительный синтаксис поверх простого JavaScript, поэтому его может легко изучить кто-то, знакомый с JavaScript, но утверждение, что он по сути бесплатный, вводит в заблуждение. Точно так же шаблон - это просто дополнительный синтаксис поверх обычного HTML и, следовательно, имеет очень низкую стоимость обучения для тех, кто уже знаком с HTML. С помощью DSL мы также можем помочь пользователю сделать больше с меньшим количеством кода (например, модификаторы &lt;code&gt;v-on&lt;/code&gt; ). Та же задача может включать намного больше кода при использовании простого JSX или функций рендеринга.</target>
        </trans-unit>
        <trans-unit id="a9ef7770ac385e4eae53d066a2f3c10a8b6c4ab6" translate="yes" xml:space="preserve">
          <source>Some directives can take an &amp;ldquo;argument&amp;rdquo;, denoted by a colon after the directive name. For example, the &lt;code&gt;v-bind&lt;/code&gt; directive is used to reactively update an HTML attribute:</source>
          <target state="translated">Некоторые директивы могут принимать &amp;laquo;аргумент&amp;raquo;, обозначаемый двоеточием после имени директивы. Например, директива &lt;code&gt;v-bind&lt;/code&gt; используется для реактивного обновления атрибута HTML:</target>
        </trans-unit>
        <trans-unit id="09428a807ec781f76bc254d725a9a4e0a2df7f8b" translate="yes" xml:space="preserve">
          <source>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of &lt;code&gt;new Function()&lt;/code&gt; for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</source>
          <target state="translated">В некоторых средах, таких как Google Chrome Apps, применяется политика безопасности контента (CSP), запрещающая использование &lt;code&gt;new Function()&lt;/code&gt; для оценки выражений. Полная сборка зависит от этой функции для компиляции шаблонов, поэтому ее нельзя использовать в этих средах.</target>
        </trans-unit>
        <trans-unit id="5a2e23d7e711dac515b3913d004594ddb71e0888" translate="yes" xml:space="preserve">
          <source>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</source>
          <target state="translated">Некоторые функции Vue существуют для того,чтобы приспособиться к редким крайним случаям или более плавным миграциям из унаследованной кодовой базы.Однако при чрезмерном использовании они могут усложнить сопровождение вашего кода или даже стать источником ошибок.Эти правила проливают свет на потенциально опасные возможности,описывая,когда и почему их следует избегать.</target>
        </trans-unit>
        <trans-unit id="d10fd1239637017ec222f508352aa84bee00680a" translate="yes" xml:space="preserve">
          <source>Some of Vue&amp;rsquo;s syntax will look very similar to AngularJS (e.g. &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt;). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.</source>
          <target state="translated">Некоторый синтаксис Vue будет очень похож на AngularJS (например, &lt;code&gt;v-if&lt;/code&gt; vs &lt;code&gt;ng-if&lt;/code&gt; ). Это потому, что в AngularJS было много правильных вещей, и они послужили источником вдохновения для Vue в самом начале его разработки. Однако есть много проблем, связанных с AngularJS, где Vue попытался предложить значительные улучшения.</target>
        </trans-unit>
        <trans-unit id="ba632b521cfadde631ed92ffd03194fe0b0a9806" translate="yes" xml:space="preserve">
          <source>Some of the current hooks have different behavior and there are also a couple new hooks.</source>
          <target state="translated">Некоторые из нынешних крючков имеют различное поведение,а также есть пара новых крючков.</target>
        </trans-unit>
        <trans-unit id="823d42c9ef6472009b44bd254d2588f2ed0ae4c8" translate="yes" xml:space="preserve">
          <source>Some of the most notable differences include:</source>
          <target state="translated">Некоторые из наиболее заметных отличий включают в себя:</target>
        </trans-unit>
        <trans-unit id="85976567c84aab5c4b5906f9117b4275cd11d741" translate="yes" xml:space="preserve">
          <source>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.</source>
          <target state="translated">Некоторые из разделов ниже также могут быть слегка устаревшими в связи с недавними обновлениями в React 16+,и мы планируем работать с сообществом React,чтобы обновить этот раздел в ближайшем будущем.</target>
        </trans-unit>
        <trans-unit id="e66b9d4602dcda92a8811e8379102ad854fa4037" translate="yes" xml:space="preserve">
          <source>Some plugins provided by Vue.js official plugins such as &lt;code&gt;vue-router&lt;/code&gt; automatically calls &lt;code&gt;Vue.use()&lt;/code&gt; if &lt;code&gt;Vue&lt;/code&gt; is available as a global variable. However in a module environment such as CommonJS, you always need to call &lt;code&gt;Vue.use()&lt;/code&gt; explicitly:</source>
          <target state="translated">Некоторые плагины, предоставляемые официальными плагинами Vue.js, такие как &lt;code&gt;vue-router&lt;/code&gt; , автоматически вызывают &lt;code&gt;Vue.use()&lt;/code&gt; если &lt;code&gt;Vue&lt;/code&gt; доступен как глобальная переменная. Однако в модульной среде, такой как CommonJS, вам всегда нужно явно вызывать &lt;code&gt;Vue.use()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9fe62eac7aa92f9e248fd4f6cf8a8c9817319b5d" translate="yes" xml:space="preserve">
          <source>Some users have enjoyed using two-way filters with &lt;code&gt;v-model&lt;/code&gt; to create interesting inputs with very little code. While &lt;em&gt;seemingly&lt;/em&gt; simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</source>
          <target state="translated">Некоторым пользователям нравилось использовать двусторонние фильтры с &lt;code&gt;v-model&lt;/code&gt; для создания интересных входных данных с очень небольшим количеством кода. Несмотря на &lt;em&gt;кажущуюся&lt;/em&gt; простоту, двусторонние фильтры также могут скрывать большую сложность и даже способствовать плохому UX, задерживая обновления состояния. Вместо этого рекомендуется использовать компоненты, обертывающие входные данные, как более явный и многофункциональный способ создания пользовательских входных данных.</target>
        </trans-unit>
        <trans-unit id="a20659b05e332a0ae32621debfebacc5d1ababa5" translate="yes" xml:space="preserve">
          <source>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</source>
          <target state="translated">Иногда это работает отлично,как,например,когда переходные элементы абсолютно расположены друг над другом:</target>
        </trans-unit>
        <trans-unit id="f26fd8bf6b50010b5da928fa27ec1a70c263cd9c" translate="yes" xml:space="preserve">
          <source>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special &lt;code&gt;$event&lt;/code&gt; variable:</source>
          <target state="translated">Иногда нам также необходимо получить доступ к исходному событию DOM во встроенном обработчике операторов. Вы можете передать его в метод с помощью специальной переменной &lt;code&gt;$event&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a58007ff3d542a5e64e8ab0473747490736edba5" translate="yes" xml:space="preserve">
          <source>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</source>
          <target state="translated">Иногда мы хотим отобразить отфильтрованную или отсортированную версию массива без фактического мутирования или сброса исходных данных.В этом случае можно создать вычисленное свойство,возвращающее отфильтрованный или отсортированный массив.</target>
        </trans-unit>
        <trans-unit id="bb4776e0f84b8cab0978edcc2a16ccf37eb32d43" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of new properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. In such cases, you should create a fresh object with properties from both objects. So instead of:</source>
          <target state="translated">Иногда вам может потребоваться присвоить несколько новых свойств существующему объекту, например, используя &lt;code&gt;Object.assign()&lt;/code&gt; или &lt;code&gt;_.extend()&lt;/code&gt; . В таких случаях вам следует создать новый объект со свойствами обоих объектов. Так что вместо:</target>
        </trans-unit>
        <trans-unit id="4216179a7f142347ead5e8b4c8a44ddd1938267a" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to assign a number of properties to an existing object, for example using &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</source>
          <target state="translated">Иногда вам может потребоваться присвоить несколько свойств существующему объекту, например, используя &lt;code&gt;Object.assign()&lt;/code&gt; или &lt;code&gt;_.extend()&lt;/code&gt; . Однако новые свойства, добавленные к объекту, не вызывают изменений. В таких случаях создайте новый объект со свойствами как исходного объекта, так и объекта примеси:</target>
        </trans-unit>
        <trans-unit id="4a3e5c479936fa0c0c3ae63c92af5bdeccbe0976" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful for slot content to have access to data only available in the child component. For example, imagine a &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">Иногда для содержимого слота полезно иметь доступ к данным, доступным только в дочернем компоненте. Например, представьте компонент &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; со следующим шаблоном:</target>
        </trans-unit>
        <trans-unit id="d2dd5e9a7fd5d98bf25e0a4d4fb18f9f4c3db2f1" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to dynamically switch between components, like in a tabbed interface:</source>
          <target state="translated">Иногда полезно динамически переключаться между компонентами, например, в интерфейсе с вкладками:</target>
        </trans-unit>
        <trans-unit id="878866be830f3d4c0492c7b15ce7d3313f921fc8" translate="yes" xml:space="preserve">
          <source>Soup &lt;em&gt;of the&lt;/em&gt; day</source>
          <target state="translated">Суп &lt;em&gt;из&lt;/em&gt; дня</target>
        </trans-unit>
        <trans-unit id="9898b37c34a88e00f23e82b5e3dc9a1701903a0c" translate="yes" xml:space="preserve">
          <source>Special Attributes</source>
          <target state="translated">Специальные атрибуты</target>
        </trans-unit>
        <trans-unit id="c1844df643c3c6b29d9ebd395e5456144c913b68" translate="yes" xml:space="preserve">
          <source>Special Attributes - ref</source>
          <target state="translated">Специальные атрибуты-ссылка</target>
        </trans-unit>
        <trans-unit id="7f375124a7e84608fdea56b183bf085ef84dd0dd" translate="yes" xml:space="preserve">
          <source>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</source>
          <target state="translated">Указывает значение по умолчанию для реквизита.Если реквизит не передан,вместо него будет использоваться это значение.Значения по умолчанию объекта или массива должны быть возвращены из заводской функции.</target>
        </trans-unit>
        <trans-unit id="3d419b352796d39146919ef5966306201da0baac" translate="yes" xml:space="preserve">
          <source>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as &lt;code&gt;this.$parent&lt;/code&gt; for the child, and the child will be pushed into the parent&amp;rsquo;s &lt;code&gt;$children&lt;/code&gt; array.</source>
          <target state="translated">Укажите родительский экземпляр для создаваемого экземпляра. Устанавливает между ними родительско-дочерние отношения. Родитель будет доступен как &lt;code&gt;this.$parent&lt;/code&gt; для дочернего элемента, а дочерний элемент будет помещен в родительский массив &lt;code&gt;$children&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4de7be6dcaca74a1df3b6f74eed72c7caf49130" translate="yes" xml:space="preserve">
          <source>Staggering List Transitions</source>
          <target state="translated">Ошеломляющий список переходов</target>
        </trans-unit>
        <trans-unit id="5ba91e4b27bd154b6feecd545db4023c8e7c12d0" translate="yes" xml:space="preserve">
          <source>Start by running the &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;migration helper&lt;/a&gt; on a current project. We&amp;rsquo;ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they&amp;rsquo;ll let you know, offer suggestions, and provide links to more info.</source>
          <target state="translated">Начните с запуска &lt;a href=&quot;https://github.com/vuejs/vue-migration-helper&quot;&gt;помощника&lt;/a&gt; по миграции в текущем проекте. Мы тщательно уменьшили и сжали старшего разработчика Vue в простой интерфейс командной строки. Когда они обнаруживают устаревшую функцию, они сообщают вам об этом, предлагают предложения и ссылки на дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="5fcf8af955dfbcfec984375c6e8f6a528e65233d" translate="yes" xml:space="preserve">
          <source>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="translated">Начиная с версии 2.3.0+вы можете предоставить массив из нескольких (префиксных)значений,например,в свойство стиля:</target>
        </trans-unit>
        <trans-unit id="9ba53e05f135de31a97be4f79621e7c2bfae116b" translate="yes" xml:space="preserve">
          <source>Starting in 2.4.0+, &lt;code&gt;v-on&lt;/code&gt; also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</source>
          <target state="translated">Начиная с версии 2.4.0+, &lt;code&gt;v-on&lt;/code&gt; также поддерживает привязку к объекту пар событие / прослушиватель без аргументов. Обратите внимание, что при использовании синтаксиса объекта он не поддерживает никаких модификаторов.</target>
        </trans-unit>
        <trans-unit id="9b9230ebf8a27183774b5eb88b79650092ee23d2" translate="yes" xml:space="preserve">
          <source>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="translated">Начиная с версии 2.6.0,можно также использовать выражение JavaScript в аргументе директивы,обернув его квадратными скобками:</target>
        </trans-unit>
        <trans-unit id="bfa146787ba4b5ec0af7e28c9b9db98dcdf2cd1c" translate="yes" xml:space="preserve">
          <source>State Management</source>
          <target state="translated">Государственное управление</target>
        </trans-unit>
        <trans-unit id="d5d64221ddf91f88df67cce91813f4262eb7edaf" translate="yes" xml:space="preserve">
          <source>State Transitions</source>
          <target state="translated">Государственные преобразования</target>
        </trans-unit>
        <trans-unit id="a872ca8fe22c7e62b5337472cd220dc9385362c8" translate="yes" xml:space="preserve">
          <source>Stop listening for an event with &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">Прекратить прослушивание события с помощью &lt;code&gt;$off(eventName, eventHandler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59e5fba28ea5c4503821b338479233b19afe716" translate="yes" xml:space="preserve">
          <source>Store&amp;rsquo;s Event Emitter &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Излучатель событий магазина &lt;sup&gt;удален.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="91315c1968e95b4caef2bb0299209f84b45e1fa3" translate="yes" xml:space="preserve">
          <source>String templates (e.g. &lt;code&gt;template: '...'&lt;/code&gt;)</source>
          <target state="translated">Шаблоны строк (например, &lt;code&gt;template: '...'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="74b4f2ed89813f9a73f7270d61c097ff9c059dd6" translate="yes" xml:space="preserve">
          <source>Style Guide</source>
          <target state="translated">Руководство по стилю</target>
        </trans-unit>
        <trans-unit id="93b9066aa73ddae63c26874719afa6da8fe21b7f" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority A: Essential</source>
          <target state="translated">Руководство по стилю:Приоритет А:Существенный</target>
        </trans-unit>
        <trans-unit id="43212530e7b38b61ce475ee08dd6944866d5239c" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority B: Strongly Recommended</source>
          <target state="translated">Руководство по стилю:Приоритет В:настоятельно рекомендуется</target>
        </trans-unit>
        <trans-unit id="dc97fc3044903277305bdcda1967fb4d1dab822e" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority C: Recommended</source>
          <target state="translated">Руководство по стилю:Приоритет С:Рекомендуется</target>
        </trans-unit>
        <trans-unit id="b9a479a71d55ce0478bf03634c2c6dce93bce7d7" translate="yes" xml:space="preserve">
          <source>Style Guide: Priority D: Use with Caution</source>
          <target state="translated">Руководство по стилю:Приоритет D:Использовать с осторожностью</target>
        </trans-unit>
        <trans-unit id="d999535d9e96f490d6db66310b5ab700b8118ee7" translate="yes" xml:space="preserve">
          <source>Style Guide: Rule Categories</source>
          <target state="translated">Руководство по стилю:Категории правил</target>
        </trans-unit>
        <trans-unit id="fbbf610d0cedad761fd69b3fc9625e259e3102c5" translate="yes" xml:space="preserve">
          <source>Suppress all Vue logs and warnings.</source>
          <target state="translated">Подавить все журналы Vue и предупреждения.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="ed4b8354b13fc6485ba3014a73af2e474df2ab5c" translate="yes" xml:space="preserve">
          <source>System Modifier Keys</source>
          <target state="translated">Клавиши системных модификаторов</target>
        </trans-unit>
        <trans-unit id="d3c9825399d84e5c262586eb382db07595391d25" translate="yes" xml:space="preserve">
          <source>Template Compilation</source>
          <target state="translated">Составление шаблона</target>
        </trans-unit>
        <trans-unit id="efb3147068725b40c3436e7283942bba6c112bbf" translate="yes" xml:space="preserve">
          <source>Template Syntax</source>
          <target state="translated">Синтаксис шаблона</target>
        </trans-unit>
        <trans-unit id="a60e21f3a907038b2e4d24850447a7990f71ed0d" translate="yes" xml:space="preserve">
          <source>Template expressions are sandboxed and only have access to a &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;whitelist of globals&lt;/a&gt; such as &lt;code&gt;Math&lt;/code&gt; and &lt;code&gt;Date&lt;/code&gt;. You should not attempt to access user defined globals in template expressions.</source>
          <target state="translated">Выражения шаблонов изолированы и имеют доступ только к &lt;a href=&quot;https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9&quot;&gt;белому списку глобальных переменных,&lt;/a&gt; таких как &lt;code&gt;Math&lt;/code&gt; и &lt;code&gt;Date&lt;/code&gt; . Вы не должны пытаться получить доступ к определяемым пользователем глобальным объектам в выражениях шаблона.</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="03aaa3887a5a2deee792941da96ae7dda7d74089" translate="yes" xml:space="preserve">
          <source>Thanks to Vue&amp;rsquo;s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</source>
          <target state="translated">Благодаря системе Vue Reactivity, он всегда знает, когда обновлять (если вы правильно ее используете). Однако есть крайние случаи, когда вам может потребоваться принудительное обновление, несмотря на то, что никакие реактивные данные не изменились. Есть и другие случаи, когда вы можете предотвратить ненужные обновления.</target>
        </trans-unit>
        <trans-unit id="b5627556ef42d923efe566603e16cd6d339c54b6" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; listener, the parent will receive the event and update &lt;code&gt;postFontSize&lt;/code&gt; value.</source>
          <target state="translated">Благодаря прослушивателю &lt;code&gt;v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&lt;/code&gt; родительский &lt;code&gt;postFontSize&lt;/code&gt; получит событие и обновит значение postFontSize .</target>
        </trans-unit>
        <trans-unit id="36e5dbb5155a7f2f18ff2f7f92eeacd1bc83b650" translate="yes" xml:space="preserve">
          <source>That means the value of &lt;code&gt;v-slot&lt;/code&gt; can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;), you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; to pull out specific slot props, like so:</source>
          <target state="translated">Это означает, что значение &lt;code&gt;v-slot&lt;/code&gt; может фактически принимать любое допустимое выражение JavaScript, которое может появиться в позиции аргумента определения функции. Таким образом, в поддерживаемых средах ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;однофайловые &lt;/a&gt;&lt;a href=&quot;single-file-components&quot;&gt;компоненты&lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;современные браузеры&lt;/a&gt; ) вы также можете использовать деструктуризацию ES2015 для извлечения определенных реквизитов слота, например:</target>
        </trans-unit>
        <trans-unit id="bcb7688f15ef595e1970dc731883ce107eed33d5" translate="yes" xml:space="preserve">
          <source>That means this element:</source>
          <target state="translated">Это означает этот элемент:</target>
        </trans-unit>
        <trans-unit id="e26ac9d99d2de3a31a44d33d135f52e40dec965b" translate="yes" xml:space="preserve">
          <source>That said, it would probably make a better comparison between Vue core and Ember&amp;rsquo;s &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;templating&lt;/a&gt; and &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;object model&lt;/a&gt; layers:</source>
          <target state="translated">Тем не менее, это, вероятно, поможет лучше сравнить между ядром Vue и уровнями &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/&quot;&gt;шаблонов&lt;/a&gt; и &lt;a href=&quot;https://guides.emberjs.com/v2.10.0/object-model/&quot;&gt;объектной модели&lt;/a&gt; Ember :</target>
        </trans-unit>
        <trans-unit id="fd91ee6e59ac928406a857815fec4a8fd6adac41" translate="yes" xml:space="preserve">
          <source>That slot has access to the same instance properties (i.e. the same &amp;ldquo;scope&amp;rdquo;) as the rest of the template. The slot does &lt;strong&gt;not&lt;/strong&gt; have access to &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s scope. For example, trying to access &lt;code&gt;url&lt;/code&gt; would not work:</source>
          <target state="translated">Этот слот имеет доступ к тем же свойствам экземпляра (т. Е. К той же &amp;laquo;области&amp;raquo;), что и остальная часть шаблона. Слот &lt;strong&gt;не&lt;/strong&gt; имеет доступа к области действия &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; . Например, попытка доступа к &lt;code&gt;url&lt;/code&gt; не сработает:</target>
        </trans-unit>
        <trans-unit id="459dd83f2362d8a07c853704c9fdaa721e9d7d51" translate="yes" xml:space="preserve">
          <source>That template doesn&amp;rsquo;t feel great. It&amp;rsquo;s not only verbose, but we&amp;rsquo;re duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level and will have to do the same when we add the anchor element.</source>
          <target state="translated">Этот шаблон не очень хорош. Это не только многословно, но и мы дублируем &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; для каждого уровня заголовка, и нам придется делать то же самое при добавлении элемента привязки.</target>
        </trans-unit>
        <trans-unit id="f0e76918c986bcb84adf08fee89b468d3a1fda00" translate="yes" xml:space="preserve">
          <source>That won&amp;rsquo;t work, however, because only the &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; component has access to the &lt;code&gt;user&lt;/code&gt; and the content we&amp;rsquo;re providing is rendered in the parent.</source>
          <target state="translated">Однако это не сработает, потому что только компонент &lt;code&gt;&amp;lt;current-user&amp;gt;&lt;/code&gt; имеет доступ к &lt;code&gt;user&lt;/code&gt; а предоставляемый нами контент отображается в родительском элементе.</target>
        </trans-unit>
        <trans-unit id="f7e6eaf815a0b389b506fd9203ee98688ac385cc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about DOM template parsing caveats for now &amp;ndash; and actually, the end of Vue&amp;rsquo;s &lt;em&gt;Essentials&lt;/em&gt;. Congratulations! There&amp;rsquo;s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</source>
          <target state="translated">Это все, что вам нужно знать о предостережениях при анализе DOM-шаблонов на данный момент - и на самом деле, о конце Vue &lt;em&gt;Essentials&lt;/em&gt; . Поздравляю! Еще есть чему поучиться, но сначала мы рекомендуем сделать перерыв, чтобы поиграть с Vue самостоятельно и создать что-нибудь интересное.</target>
        </trans-unit>
        <trans-unit id="e65f913a2b8930db25e11b615901938e35677612" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about custom component events for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-custom-events&quot;&gt;Custom Events&lt;/a&gt;.</source>
          <target state="translated">Это все, что вам нужно знать о событиях пользовательских компонентов на данный момент, но как только вы закончите читать эту страницу и почувствуете себя комфортно с ее содержанием, мы рекомендуем вернуться позже, чтобы прочитать полное руководство по &lt;a href=&quot;components-custom-events&quot;&gt;пользовательским событиям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="814dc84544fcf8f9ba3af47bc369c70717b8fdfa" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about dynamic components for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;.</source>
          <target state="translated">Это все, что вам нужно знать о динамических компонентах на данный момент, но как только вы закончите читать эту страницу и почувствуете себя комфортно с ее содержанием, мы рекомендуем вернуться позже, чтобы прочитать полное руководство по &lt;a href=&quot;components-dynamic-async&quot;&gt;динамическим и асинхронным компонентам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1370785d9557daacd2793450c22d6061fa0adbc6" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about props for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-props&quot;&gt;Props&lt;/a&gt;.</source>
          <target state="translated">Это все, что вам нужно знать о реквизите на данный момент, но как только вы закончите читать эту страницу и почувствуете себя комфортно с ее содержанием, мы рекомендуем вернуться позже, чтобы прочитать полное руководство по &lt;a href=&quot;components-props&quot;&gt;Props&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e701db7e6d05f9288626f8d97a85fc554f9593e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about registration for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-registration&quot;&gt;Component Registration&lt;/a&gt;.</source>
          <target state="translated">Это все, что вам нужно знать о регистрации на данный момент, но как только вы закончите читать эту страницу и почувствуете себя комфортно с ее содержанием, мы рекомендуем вернуться позже, чтобы прочитать полное руководство по &lt;a href=&quot;components-registration&quot;&gt;регистрации компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7ac0de9bc7b2393fad83ed8e57aa35094e7cc2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know about slots for now, but once you&amp;rsquo;ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on &lt;a href=&quot;components-slots&quot;&gt;Slots&lt;/a&gt;.</source>
          <target state="translated">Это все, что вам нужно знать о слотах на данный момент, но как только вы закончите читать эту страницу и почувствуете себя комфортно с ее содержанием, мы рекомендуем вернуться позже, чтобы прочитать полное руководство по &lt;a href=&quot;components-slots&quot;&gt;слотам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f39b1bdd26be7312e776a774c103e8b83e7cb1a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why for any complex logic, you should use a &lt;strong&gt;computed property&lt;/strong&gt;.</source>
          <target state="translated">Вот почему для любой сложной логики следует использовать &lt;strong&gt;вычисляемое свойство&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b16487797e90834fa5c92964e14dabbe10606c8" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why instead, we recommend emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, in a hypothetical component with a &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="translated">Вот почему вместо этого мы рекомендуем генерировать события в шаблоне &lt;code&gt;update:myPropName&lt;/code&gt; . Например, в гипотетическом компоненте с опорой &lt;code&gt;title&lt;/code&gt; мы могли бы сообщить о намерении присвоить новое значение с помощью:</target>
        </trans-unit>
        <trans-unit id="996c0c7a918cb9833eb237973fce54baee6b3199" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why there&amp;rsquo;s a &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;Babel plugin&lt;/a&gt; to use JSX with Vue, getting us back to a syntax that&amp;rsquo;s closer to templates:</source>
          <target state="translated">Вот почему есть &lt;a href=&quot;https://github.com/vuejs/jsx&quot;&gt;плагин Babel&lt;/a&gt; для использования JSX с Vue, возвращающий нас к синтаксису, который ближе к шаблонам:</target>
        </trans-unit>
        <trans-unit id="ad7c55b719b44c49b49edeaa4e2789ec22bd2ca2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why we offer a full system for rapid Vue.js development. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.</source>
          <target state="translated">Вот почему мы предлагаем полную систему для быстрой разработки на Vue.js. &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI&lt;/a&gt; стремится стать стандартным базовым набором инструментов для экосистемы Vue. Он обеспечивает бесперебойную работу различных инструментов сборки с разумными настройками по умолчанию, поэтому вы можете сосредоточиться на написании своего приложения, а не тратить часы на споры с конфигурациями. В то же время он по-прежнему предлагает гибкость для настройки конфигурации каждого инструмента в соответствии с конкретными потребностями.</target>
        </trans-unit>
        <trans-unit id="e8054cccceec827f8cba34b7a1b6bd02a65cd67d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;guide/installation&quot;&gt;Installation&lt;/a&gt; page provides more options of installing Vue. Note: We &lt;strong&gt;do not&lt;/strong&gt; recommend that beginners start with &lt;code&gt;vue-cli&lt;/code&gt;, especially if you are not yet familiar with Node.js-based build tools.</source>
          <target state="translated">На странице &amp;laquo; &lt;a href=&quot;guide/installation&quot;&gt;Установка&amp;raquo;&lt;/a&gt; представлены дополнительные варианты установки Vue. Примечание. Мы &lt;strong&gt;не&lt;/strong&gt; рекомендуем новичкам начинать с &lt;code&gt;vue-cli&lt;/code&gt; , особенно если вы еще не знакомы с инструментами сборки на основе Node.js.</target>
        </trans-unit>
        <trans-unit id="a5ab4cb7708169e37819b6bac8b1dd32c12097a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;pluralize&lt;/a&gt; package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like &lt;code&gt;0&lt;/code&gt;, then you can also easily define your own pluralize functions. For example:</source>
          <target state="translated">Пакет &lt;a href=&quot;https://www.npmjs.com/package/pluralize&quot;&gt;множественного числа&lt;/a&gt; в NPM прекрасно служит этой цели, но если вы хотите использовать только множественное число для определенного слова или хотите иметь специальный вывод для таких случаев, как &lt;code&gt;0&lt;/code&gt; , вы также можете легко определить свои собственные функции множественного числа. Например:</target>
        </trans-unit>
        <trans-unit id="05878157178d05a4e01a1c89173d306a9458b9ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$route&lt;/code&gt; property is now reactive, so you can use a watcher to react to route changes, like this:</source>
          <target state="translated">Свойство &lt;code&gt;$route&lt;/code&gt; теперь является реактивным, поэтому вы можете использовать наблюдателя, чтобы реагировать на изменения маршрута, например:</target>
        </trans-unit>
        <trans-unit id="26e5d2730ae73e0e0de2df953cf2ee3a5fad3d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; will be the actual link (and will get the correct href), but the active class will be applied to the outer &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; будет фактической ссылка (и получите правильный HREF), но активный класс будет применяться к наружному &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c768384d9ec752c708894881ada4881202a8fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; will not be visible until the compilation is done.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; не будет виден , пока компиляция не будет сделано.</target>
        </trans-unit>
        <trans-unit id="6726c886cd7d1313872ea34b72b56e9373d396cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; component might define a &lt;code&gt;map&lt;/code&gt; property that all subcomponents need access to. In this case &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; might want to access that map with something like &lt;code&gt;this.$parent.getMap&lt;/code&gt;, in order to add a set of markers to it. You can see this pattern &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;in action here&lt;/a&gt;.</source>
          <target state="translated">Компонент &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; может определять свойство &lt;code&gt;map&lt;/code&gt; которому требуется доступ для всех подкомпонентов. В этом случае &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; может захотеть получить доступ к этой карте с помощью чего-то вроде &lt;code&gt;this.$parent.getMap&lt;/code&gt; , чтобы добавить к ней набор маркеров. Здесь вы можете увидеть этот шаблон &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/ttzutdxh/&quot;&gt;в действии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="780604d1e5198fdcc94939f3a317c58b142346c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of &lt;strong&gt;the &lt;code&gt;v-move&lt;/code&gt; class&lt;/strong&gt;, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided &lt;code&gt;name&lt;/code&gt; attribute and you can also manually specify a class with the &lt;code&gt;move-class&lt;/code&gt; attribute.</source>
          <target state="translated">У компонента &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; есть еще одна хитрость в рукаве. Он может не только анимировать вход и выход, но и изменение положения. Единственная новая концепция вы должны знать , чтобы использовать эту функцию , является добавлением &lt;strong&gt;к &lt;code&gt;v-move&lt;/code&gt; класса&lt;/strong&gt; , который добавляется , когда элементы меняются позиция. Как и другие классы, его префикс будет соответствовать значению предоставленного атрибута &lt;code&gt;name&lt;/code&gt; , и вы также можете вручную указать класс с атрибутом &lt;code&gt;move-class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="606648505385790cf915adeb72e619634753fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.camel&lt;/code&gt; modifier allows camelizing a &lt;code&gt;v-bind&lt;/code&gt; attribute name when using in-DOM templates, e.g. the SVG &lt;code&gt;viewBox&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;.camel&lt;/code&gt; модификатор позволяет camelizing с &lt;code&gt;v-bind&lt;/code&gt; имени атрибута при использовании в DOM-шаблонов, например, SVG &lt;code&gt;viewBox&lt;/code&gt; атрибут:</target>
        </trans-unit>
        <trans-unit id="b9f947cb89a1b3d04c28ecc1fa1b5146bc308109" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.exact&lt;/code&gt; modifier allows control of the exact combination of system modifiers needed to trigger an event.</source>
          <target state="translated">&lt;code&gt;.exact&lt;/code&gt; модификатор позволяет контролировать точное сочетание системы модификаторов , необходимых , чтобы вызвать событие.</target>
        </trans-unit>
        <trans-unit id="71dc161e02d764cb61bccce7f7216e558eea41ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.literal&lt;/code&gt; modifier has been removed, as the same can be easily achieved by providing a string literal as the value.</source>
          <target state="translated">&lt;code&gt;.literal&lt;/code&gt; модификатор был удален, так как то же самое может быть легко достигнут путем предоставления строкового литерала в качестве значения.</target>
        </trans-unit>
        <trans-unit id="447f18c9c1ff6544a5bf8da7ab660de9c45d00c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.passive&lt;/code&gt; modifier is especially useful for improving performance on mobile devices.</source>
          <target state="translated">&lt;code&gt;.passive&lt;/code&gt; модификатор особенно полезен для повышения производительности на мобильных устройствах.</target>
        </trans-unit>
        <trans-unit id="21fd043aec56c5be7446f861bc772ebd8e753810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sync&lt;/code&gt; modifier can also be used with &lt;code&gt;v-bind&lt;/code&gt; when using an object to set multiple props at once:</source>
          <target state="translated">&lt;code&gt;.sync&lt;/code&gt; модификатор может быть также использован с &lt;code&gt;v-bind&lt;/code&gt; при использовании объекта , чтобы установить несколько реквизита сразу:</target>
        </trans-unit>
        <trans-unit id="c3321d11e9ef44eba8d358a3614e37323b934b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;events&lt;/code&gt; option has been removed. Event handlers should now be registered in the &lt;code&gt;created&lt;/code&gt; hook instead. Check out the &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt;&lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; migration guide&lt;/a&gt; for a detailed example.</source>
          <target state="translated">Опция &lt;code&gt;events&lt;/code&gt; была удалена. Обработчики событий теперь должны быть зарегистрированы в ловушке &lt;code&gt;created&lt;/code&gt; . См. Подробный пример в &lt;a href=&quot;#dispatch-and-broadcast-replaced&quot;&gt;руководстве&lt;/a&gt; по миграции &lt;code&gt;$dispatch&lt;/code&gt; и &lt;code&gt;$broadcast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7c4b5febaa054c2d70f2972911d81840dc234e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-out&lt;/code&gt; mode isn&amp;rsquo;t used as often, but can sometimes be useful for a slightly different transition effect. Let&amp;rsquo;s try combining it with the slide-fade transition we worked on earlier:</source>
          <target state="translated">Режим &lt;code&gt;in-out&lt;/code&gt; используется не так часто, но иногда может быть полезен для немного другого эффекта перехода. Давайте попробуем объединить его с переходом слайд-затухание, над которым мы работали ранее:</target>
        </trans-unit>
        <trans-unit id="7bb2562df8be00932287fedd76a233d44e708651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</source>
          <target state="translated">Свойства &lt;code&gt;include&lt;/code&gt; и &lt;code&gt;exclude&lt;/code&gt; позволяют условно кэшировать компоненты. Оба свойства могут быть строкой, разделенной запятыми, регулярным выражением или массивом:</target>
        </trans-unit>
        <trans-unit id="4cd088c8b9dd70d20f540d863e4827655ef4afc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; option should be either:</source>
          <target state="translated">Вариант &lt;code&gt;inject&lt;/code&gt; должен быть либо:</target>
        </trans-unit>
        <trans-unit id="582a8cbd2aa999f85f97f4835ddb07fec729cd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; special attribute is primarily used as a hint for Vue&amp;rsquo;s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; специальный атрибут в основном используются в качестве подсказки для алгоритма виртуального DOM Vue, чтобы определить VNodes когда сравнивает новый список узлов против старого списка. Без ключей Vue использует алгоритм, который минимизирует перемещение элементов и пытается исправлять / повторно использовать элементы одного и того же типа на месте, насколько это возможно. С ключами он будет переупорядочивать элементы в зависимости от изменения порядка ключей, а элементы с ключами, которых больше нет, всегда будут удалены / уничтожены.</target>
        </trans-unit>
        <trans-unit id="dc118214d9d96bdcdab86a3dcf6dbc36ea6680a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt; param attributes are now modifiers, to make it more clear what That means instead of:</source>
          <target state="translated">В &lt;code&gt;lazy&lt;/code&gt; и &lt;code&gt;number&lt;/code&gt; атрибутов Param являются теперь модификаторы, чтобы сделать его более ясным , что это значит вместо:</target>
        </trans-unit>
        <trans-unit id="cb26d534e1e0fd7dab034b343fe732f25ec4cdc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mixins&lt;/code&gt; option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in &lt;code&gt;Vue.extend()&lt;/code&gt;. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</source>
          <target state="translated">Опция &lt;code&gt;mixins&lt;/code&gt; принимает массив объектов mixin. Эти объекты примеси могут содержать параметры экземпляра, такие как обычные объекты экземпляра, и они будут объединены с возможными параметрами, используя ту же логику объединения параметров в &lt;code&gt;Vue.extend()&lt;/code&gt; . например, если ваш миксин содержит созданный хук и сам компонент также имеет его, будут вызваны обе функции.</target>
        </trans-unit>
        <trans-unit id="a26f8d5002e995f88abd483d65f2b8981c550aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Reflect.ownKeys&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;provide&lt;/code&gt; должен быть объектом или функцией, возвращающей объект. Этот объект содержит свойства, доступные для внедрения в его потомков. Вы можете использовать символы ES2015 в качестве ключей в этом объекте, но только в средах, которые изначально поддерживают &lt;code&gt;Symbol&lt;/code&gt; и &lt;code&gt;Reflect.ownKeys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1df98a28e225ea8d4b071027515cc8bf9c095a9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; options allows us to specify the data/methods we want to &lt;strong&gt;provide&lt;/strong&gt; to descendent components. In this case, that&amp;rsquo;s the &lt;code&gt;getMap&lt;/code&gt; method inside &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Параметры &lt;code&gt;provide&lt;/code&gt; позволяют нам указать данные / методы, которые мы хотим &lt;strong&gt;предоставить&lt;/strong&gt; дочерним компонентам. В данном случае это метод &lt;code&gt;getMap&lt;/code&gt; внутри &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e89e752e4e0ad59fc71d8c42dbb8b140ac0a0a39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; function has priority over the render function compiled from &lt;code&gt;template&lt;/code&gt; option or in-DOM HTML template of the mounting element which is specified by the &lt;code&gt;el&lt;/code&gt; option.</source>
          <target state="translated">Функция &lt;code&gt;render&lt;/code&gt; имеет приоритет над функцией рендеринга, скомпилированной из параметра &lt;code&gt;template&lt;/code&gt; или встроенного в DOM HTML-шаблона монтируемого элемента, указанного в параметре &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f312c98cab71695e7dd222c575b78b0d13a0c64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;slot-scope&lt;/code&gt; attribute can also be used directly on a non-&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element (including components):</source>
          <target state="translated">&lt;code&gt;slot-scope&lt;/code&gt; атрибута также может быть использован непосредственно на нерабочий &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; элемента (включая компоненты):</target>
        </trans-unit>
        <trans-unit id="955152ea21b24fdf404e6e6a60a1465f0de55be9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;true-value&lt;/code&gt; and &lt;code&gt;false-value&lt;/code&gt; attributes don&amp;rsquo;t affect the input&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; attribute, because browsers don&amp;rsquo;t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. &amp;ldquo;yes&amp;rdquo; or &amp;ldquo;no&amp;rdquo;), use radio inputs instead.</source>
          <target state="translated">Атрибуты &amp;laquo; &lt;code&gt;true-value&lt;/code&gt; и &amp;laquo; &lt;code&gt;false-value&lt;/code&gt; не влияют на входной атрибут &lt;code&gt;value&lt;/code&gt; , поскольку браузеры не включают в себя неотмеченные поля при отправке форм. Чтобы гарантировать, что одно из двух значений представлено в форме (например, &amp;laquo;да&amp;raquo; или &amp;laquo;нет&amp;raquo;), используйте вместо этого радио-входы.</target>
        </trans-unit>
        <trans-unit id="e182f837614c4a38080aad510dbbf2060bfc370d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; can be one of the following native constructors:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; может быть один из следующих нативных конструкторов:</target>
        </trans-unit>
        <trans-unit id="e190ce9f5befbb3426f06af3ed96f5a8aa0969e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-&lt;/code&gt; prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the &lt;code&gt;v-&lt;/code&gt; prefix becomes less important when you are building a &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt;, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, &lt;code&gt;v-bind&lt;/code&gt; and &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-&lt;/code&gt; Приставка служит визуальным сигналом для идентификации Вьет-специфические атрибуты в шаблонах. Это полезно, когда вы используете Vue.js для применения динамического поведения к существующей разметке, но может показаться многословным для некоторых часто используемых директив. В то же время необходимость в префиксе &lt;code&gt;v-&lt;/code&gt; становится менее важной, когда вы создаете &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-page_application&quot;&gt;SPA&lt;/a&gt; , где Vue управляет каждым шаблоном. Поэтому Vue предоставляет специальные сокращения для двух наиболее часто используемых директив, &lt;code&gt;v-bind&lt;/code&gt; и &lt;code&gt;v-on&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd8461a9f091788550d2bcfcb0e99f3643c233d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-else-if&lt;/code&gt;, as the name suggests, serves as an &amp;ldquo;else if block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;. It can also be chained multiple times:</source>
          <target state="translated">&lt;code&gt;v-else-if&lt;/code&gt; , как следует из названия, служит в качестве &amp;laquo;другого , если блок&amp;raquo; для &lt;code&gt;v-if&lt;/code&gt; . Его также можно связать несколько раз:</target>
        </trans-unit>
        <trans-unit id="0f6244029a3dc18b6cba09b3e6e0a940180e13b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link-active&lt;/code&gt; directive has also been replaced by the &lt;code&gt;tag&lt;/code&gt; attribute on &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;the &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;. So for example, you&amp;rsquo;ll update this:</source>
          <target state="translated">&lt;code&gt;v-link-active&lt;/code&gt; директива также была заменена &lt;code&gt;tag&lt;/code&gt; атрибутом &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;в &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; компоненте&lt;/a&gt; . Так, например, вы обновите это:</target>
        </trans-unit>
        <trans-unit id="83d24c44d5fff24f0114d4c306087248f718b001" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-link&lt;/code&gt; directive has been replaced with a new &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt;&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; component&lt;/a&gt;, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:</source>
          <target state="translated">&lt;code&gt;v-link&lt;/code&gt; Директива была заменена новым &lt;a href=&quot;https://router.vuejs.org/en/api/router-link.html&quot;&gt; &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; компонентом&lt;/a&gt; , так как этот вид работы в настоящее время несет ответственность только компоненты в Vue 2. Это означает , когда там , где у вас есть ссылка , как это:</target>
        </trans-unit>
        <trans-unit id="913c16238f6be321d10c7aa5ede9be4e8848de68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v-slot&lt;/code&gt; directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes. The full rationale for introducing &lt;code&gt;v-slot&lt;/code&gt; is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;. The &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</source>
          <target state="translated">&lt;code&gt;v-slot&lt;/code&gt; директива была введена в Vue 2.6.0, предлагая улучшенный, альтернативный API к еще поддерживаемых &lt;code&gt;slot&lt;/code&gt; и &lt;code&gt;slot-scope&lt;/code&gt; атрибутов. Полное обоснование введения &lt;code&gt;v-slot&lt;/code&gt; описано в этом &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt; . В &lt;code&gt;slot&lt;/code&gt; и &lt;code&gt;slot-scope&lt;/code&gt; атрибуты по- прежнему будет поддерживаться во всех последующих версиях 2.x, но официально осуждается и в конечном итоге будут удалены в Vue 3.</target>
        </trans-unit>
        <trans-unit id="f371f3394ccbbd9c9c7339bc5a079bc98cf103c4" translate="yes" xml:space="preserve">
          <source>The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt; without any build tools before using the CLI.</source>
          <target state="translated">Интерфейс командной строки предполагает предварительное знание Node.js и связанных с ним инструментов сборки. Если вы новичок в Vue или интерфейсных инструментах сборки, мы настоятельно рекомендуем просмотреть &lt;a href=&quot;../index&quot;&gt;руководство&lt;/a&gt; без каких-либо инструментов сборки перед использованием CLI.</target>
        </trans-unit>
        <trans-unit id="431e39681a2982cceb38425ec480f7e168f10ba0" translate="yes" xml:space="preserve">
          <source>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;config options&lt;/a&gt;.</source>
          <target state="translated">Интерфейс командной строки позаботится о большинстве конфигураций инструментов, но также позволяет выполнять тонкую настройку с помощью собственных &lt;a href=&quot;https://cli.vuejs.org/config/&quot;&gt;параметров конфигурации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37e9961ffd2140433ee6300b4c25596bb92249ae" translate="yes" xml:space="preserve">
          <source>The Complete SSR Guide</source>
          <target state="translated">Полное руководство по SSR</target>
        </trans-unit>
        <trans-unit id="eb35b5bf284498fbba8e557432a08e707e7edef3" translate="yes" xml:space="preserve">
          <source>The Data Object In-Depth</source>
          <target state="translated">Объект данных в глубину</target>
        </trans-unit>
        <trans-unit id="3c531607ce360cbb5aec13ac8c3438a41dc5f330" translate="yes" xml:space="preserve">
          <source>The Virtual DOM</source>
          <target state="translated">Виртуальный DOM</target>
        </trans-unit>
        <trans-unit id="babecbcffc795b2e20d9189e575e0bb731f8cd62" translate="yes" xml:space="preserve">
          <source>The Vue Instance</source>
          <target state="translated">Vue Instance</target>
        </trans-unit>
        <trans-unit id="be83ced5c720e31f43242c0f5e365ad3f2da0751" translate="yes" xml:space="preserve">
          <source>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don&amp;rsquo;t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</source>
          <target state="translated">Спецификация веб-компонентов была завершена, но не во всех браузерах изначально реализована. Safari 10.1+, Chrome 54+ и Firefox 63+ изначально поддерживают веб-компоненты. Для сравнения, компоненты Vue не требуют полифиллов и работают согласованно во всех поддерживаемых браузерах (IE9 и выше). При необходимости компоненты Vue также можно обернуть внутри собственного настраиваемого элемента.</target>
        </trans-unit>
        <trans-unit id="0a28d4802ae8f29af4f28a606d7b55fd498ccb1b" translate="yes" xml:space="preserve">
          <source>The above code is imperative and repetitive. Compare it with a computed property version:</source>
          <target state="translated">Вышеуказанный код является обязательным и повторяющимся.Сравните его с вычисленной версией свойства:</target>
        </trans-unit>
        <trans-unit id="bb879e483c23bffcd30b4eb818c6b264dd8b31d3" translate="yes" xml:space="preserve">
          <source>The above declarations allow the following code to be compiled:</source>
          <target state="translated">Приведенные выше декларации позволяют скомпилировать следующий код:</target>
        </trans-unit>
        <trans-unit id="f57aa3ad596a32aa0ee96ea34ada406c21b66366" translate="yes" xml:space="preserve">
          <source>The above example and some future ones use JavaScript&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template literal&lt;/a&gt; to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;newline escapes&lt;/a&gt; instead.</source>
          <target state="translated">В приведенном выше примере и в некоторых будущих используется &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;литерал шаблона&lt;/a&gt; JavaScript, чтобы сделать многострочные шаблоны более удобочитаемыми. Они не поддерживаются Internet Explorer (IE), поэтому, если вы должны поддерживать IE и не выполняете транспилирование (например, с помощью Babel или TypeScript), используйте вместо них escape-символы &lt;a href=&quot;https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/&quot;&gt;новой строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99a5b0f10fab94bdbe6947c371a61fc4c4300760" translate="yes" xml:space="preserve">
          <source>The above is made possible by Vue&amp;rsquo;s &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; element with the &lt;code&gt;is&lt;/code&gt; special attribute:</source>
          <target state="translated">Это стало возможным благодаря элементу Vue &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; со специальным атрибутом &lt;code&gt;is&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7374ad3f755708e5dc13a8b4b98839ff8d234e1" translate="yes" xml:space="preserve">
          <source>The above only renders the todos that are not complete.</source>
          <target state="translated">Вышеуказанное делает только те тодос,которые не являются полными.</target>
        </trans-unit>
        <trans-unit id="4af7e3e4b79fac718e6fd64e5702254c69dcf11f" translate="yes" xml:space="preserve">
          <source>The above syntax means the presence of the &lt;code&gt;active&lt;/code&gt; class will be determined by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthiness&lt;/a&gt; of the data property &lt;code&gt;isActive&lt;/code&gt;.</source>
          <target state="translated">Вышеупомянутый синтаксис означает, что наличие &lt;code&gt;active&lt;/code&gt; класса будет определяться &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;истинностью&lt;/a&gt; свойства данных &lt;code&gt;isActive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeec69d6935039bffd444e21fbd1ed7763a7edf9" translate="yes" xml:space="preserve">
          <source>The above will be equivalent to:</source>
          <target state="translated">Вышеупомянутое будет эквивалентно:</target>
        </trans-unit>
        <trans-unit id="bc22dad858f565e9beeefc992c5465134124606c" translate="yes" xml:space="preserve">
          <source>The anchored heading component we created earlier is relatively simple. It doesn&amp;rsquo;t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it&amp;rsquo;s only a function with some props.</source>
          <target state="translated">Компонент привязанного заголовка, который мы создали ранее, относительно прост. Он не управляет никаким состоянием, не следит за любым состоянием, переданным ему, и у него нет методов жизненного цикла. На самом деле, это всего лишь функция с некоторыми реквизитами.</target>
        </trans-unit>
        <trans-unit id="87b9709d9cefabc9cccc6ad0b23e243c50a3cb35" translate="yes" xml:space="preserve">
          <source>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.</source>
          <target state="translated">Синтаксис массива обеспечивает более предсказуемое соответствие маршрута,так как итерации по объекту не гарантируют использование одного и того же порядка свойств в браузерах.</target>
        </trans-unit>
        <trans-unit id="da3ddd2386065d734a4382298ee4c3e11da253a3" translate="yes" xml:space="preserve">
          <source>The array syntax for &lt;code&gt;v-bind:style&lt;/code&gt; allows you to apply multiple style objects to the same element:</source>
          <target state="translated">Синтаксис массива для &lt;code&gt;v-bind:style&lt;/code&gt; позволяет применять несколько объектов стиля к одному и тому же элементу:</target>
        </trans-unit>
        <trans-unit id="e823b9beb8c48498f2cf709b4d0756d4d1fc6465" translate="yes" xml:space="preserve">
          <source>The async component factory can also return an object of the following format:</source>
          <target state="translated">Завод асинхронных компонентов может также возвращать объект следующего формата:</target>
        </trans-unit>
        <trans-unit id="ba11fc067d05679fdd5921eda5ec20ebd31b1c5d" translate="yes" xml:space="preserve">
          <source>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</source>
          <target state="translated">Автозавершение в редакторах делает стоимость написания более длинных имен очень низкой,в то время как ясность,которую они обеспечивают,бесценна.Необычных сокращений,в частности,всегда следует избегать.</target>
        </trans-unit>
        <trans-unit id="8c22ef1ce4c22f9fdb3192ace8ea666bf31d6a91" translate="yes" xml:space="preserve">
          <source>The bound object doesn&amp;rsquo;t have to be inline:</source>
          <target state="translated">Связанный объект не обязательно должен быть встроенным:</target>
        </trans-unit>
        <trans-unit id="c473e09bb4188e420d79ebd60ee46d8c65246cf3" translate="yes" xml:space="preserve">
          <source>The component system is another important concept in Vue, because it&amp;rsquo;s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</source>
          <target state="translated">Система компонентов - еще одна важная концепция Vue, потому что это абстракция, которая позволяет нам создавать крупномасштабные приложения, состоящие из небольших, автономных и часто повторно используемых компонентов. Если задуматься, почти любой тип интерфейса приложения можно абстрагировать в дерево компонентов:</target>
        </trans-unit>
        <trans-unit id="e2a227479dfaa2ebe9e09278b1482fab712cafda" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it&amp;rsquo;s usually better to use a &lt;a href=&quot;#computed&quot;&gt;computed property&lt;/a&gt; or &lt;a href=&quot;#watch&quot;&gt;watcher&lt;/a&gt; instead.</source>
          <target state="translated">DOM компонента будет обновлена ​​при вызове этой ловушки, поэтому здесь вы можете выполнять операции, зависящие от DOM. Однако в большинстве случаев вам следует избегать изменения состояния внутри ловушки. Чтобы реагировать на изменения состояния, обычно лучше использовать &lt;a href=&quot;#computed&quot;&gt;вычисляемое свойство&lt;/a&gt; или &lt;a href=&quot;#watch&quot;&gt;наблюдателя&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33a9c37f2f9908b2ff6754fe4ced3a3b882e927a" translate="yes" xml:space="preserve">
          <source>The component&amp;rsquo;s name is the first argument of &lt;code&gt;Vue.component&lt;/code&gt;.</source>
          <target state="translated">Имя компонента - это первый аргумент &lt;code&gt;Vue.component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c50d6a412a378e537c001610ef774aa9ae31afc" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;code&gt;span&lt;/code&gt; will be replaced with the value of the &lt;code&gt;rawHtml&lt;/code&gt; property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use &lt;code&gt;v-html&lt;/code&gt; to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</source>
          <target state="translated">Содержимое &lt;code&gt;span&lt;/code&gt; будет заменено значением свойства &lt;code&gt;rawHtml&lt;/code&gt; , интерпретируемым как обычный HTML - привязки данных игнорируются. Обратите внимание, что вы не можете использовать &lt;code&gt;v-html&lt;/code&gt; для создания частей шаблона, потому что Vue не является механизмом создания шаблонов на основе строк. Вместо этого компоненты предпочтительнее в качестве основной единицы для повторного использования и композиции пользовательского интерфейса.</target>
        </trans-unit>
        <trans-unit id="0aabf5563ee74ceaaa562a702ba84f4906e6efaf" translate="yes" xml:space="preserve">
          <source>The custom component &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the &lt;code&gt;is&lt;/code&gt; special attribute offers a workaround:</source>
          <target state="translated">Пользовательский компонент &lt;code&gt;&amp;lt;blog-post-row&amp;gt;&lt;/code&gt; будет извлечен как недопустимое содержимое, что приведет к ошибкам в конечном отображаемом выводе. К счастью, специальный атрибут &lt;code&gt;is&lt;/code&gt; предлагает обходной путь:</target>
        </trans-unit>
        <trans-unit id="773dcdb0e4554ae71591d98763ca297e3e508d9e" translate="yes" xml:space="preserve">
          <source>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it &amp;ldquo;reactive&amp;rdquo;. &lt;strong&gt;The object must be plain&lt;/strong&gt;: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</source>
          <target state="translated">Объект данных для экземпляра Vue. Vue рекурсивно преобразует свои свойства в геттеры / сеттеры, чтобы сделать его &amp;laquo;реактивным&amp;raquo;. &lt;strong&gt;Объект должен быть простым&lt;/strong&gt; : собственные объекты, такие как объекты API браузера и свойства прототипа, игнорируются. Эмпирическое правило состоит в том, что данные должны быть просто данными - не рекомендуется наблюдать за объектами с их собственным поведением с отслеживанием состояния.</target>
        </trans-unit>
        <trans-unit id="f249c1e096e4760333b8a1a164e494b46a537f23" translate="yes" xml:space="preserve">
          <source>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</source>
          <target state="translated">Объект данных,который наблюдает экземпляр Vue.Экземпляр Vue проксирует доступ к свойствам своего объекта данных.</target>
        </trans-unit>
        <trans-unit id="536204b9289a091fc1bfb216ea4a0b6805215f8d" translate="yes" xml:space="preserve">
          <source>The default behavior of &lt;code&gt;v-for&lt;/code&gt; will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the &lt;code&gt;key&lt;/code&gt; special attribute:</source>
          <target state="translated">По умолчанию &lt;code&gt;v-for&lt;/code&gt; пытается исправить элементы на месте, не перемещая их. Чтобы заставить его переупорядочить элементы, вам необходимо предоставить подсказку для порядка с помощью специального атрибута &lt;code&gt;key&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d129c09e272230c72d4816c9cf37d602f78c6b98" translate="yes" xml:space="preserve">
          <source>The detailed usage for &lt;code&gt;v-for&lt;/code&gt; is explained in the guide section linked below.</source>
          <target state="translated">Подробное использование &lt;code&gt;v-for&lt;/code&gt; объясняется в разделе руководства по ссылке ниже.</target>
        </trans-unit>
        <trans-unit id="fcb2400b62e62455e5be23679bc16dcd684f0e97" translate="yes" xml:space="preserve">
          <source>The difference is that an element with &lt;code&gt;v-show&lt;/code&gt; will always be rendered and remain in the DOM; &lt;code&gt;v-show&lt;/code&gt; only toggles the &lt;code&gt;display&lt;/code&gt; CSS property of the element.</source>
          <target state="translated">Разница в том, что элемент с &lt;code&gt;v-show&lt;/code&gt; всегда будет отображаться и оставаться в DOM; &lt;code&gt;v-show&lt;/code&gt; только переключает свойство &lt;code&gt;display&lt;/code&gt; CSS элемента.</target>
        </trans-unit>
        <trans-unit id="9beac5c57d068b893c427afee540acec4a448457" translate="yes" xml:space="preserve">
          <source>The direct child components of the current instance. &lt;strong&gt;Note there&amp;rsquo;s no order guarantee for &lt;code&gt;$children&lt;/code&gt;, and it is not reactive.&lt;/strong&gt; If you find yourself trying to use &lt;code&gt;$children&lt;/code&gt; for data binding, consider using an Array and &lt;code&gt;v-for&lt;/code&gt; to generate child components, and use the Array as the source of truth.</source>
          <target state="translated">Прямые дочерние компоненты текущего экземпляра. &lt;strong&gt;Обратите внимание, что для &lt;code&gt;$children&lt;/code&gt; нет гарантии порядка , и он не является реактивным. &lt;/strong&gt;Если вы обнаружите, что пытаетесь использовать &lt;code&gt;$children&lt;/code&gt; для привязки данных, подумайте об использовании Array и &lt;code&gt;v-for&lt;/code&gt; для генерации дочерних компонентов и используйте Array как источник истины.</target>
        </trans-unit>
        <trans-unit id="8966ad2384af724eb5afaebd84955178e2bef331" translate="yes" xml:space="preserve">
          <source>The directive &lt;code&gt;v-if&lt;/code&gt; is used to conditionally render a block. The block will only be rendered if the directive&amp;rsquo;s expression returns a truthy value.</source>
          <target state="translated">Директива &lt;code&gt;v-if&lt;/code&gt; используется для условного рендеринга блока. Блок будет отображен только в том случае, если выражение директивы вернет истинное значение.</target>
        </trans-unit>
        <trans-unit id="a9e1b62f46f6347c3255105bf2f7f7bb4beb980e" translate="yes" xml:space="preserve">
          <source>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the &lt;code&gt;v-html&lt;/code&gt; directive:</source>
          <target state="translated">Двойные усы интерпретируют данные как обычный текст, а не как HTML. Чтобы вывести настоящий HTML, вам нужно будет использовать директиву &lt;code&gt;v-html&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cdf9489100840a3b7f6fc331943b5d3351ce62f0" translate="yes" xml:space="preserve">
          <source>The easiest way to pre-compile templates is using &lt;a href=&quot;single-file-components&quot;&gt;Single-File Components&lt;/a&gt; - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</source>
          <target state="translated">Самый простой способ предварительной компиляции шаблонов - использование &lt;a href=&quot;single-file-components&quot;&gt;однофайловых компонентов&lt;/a&gt; - связанные настройки сборки автоматически выполняют предварительную компиляцию за вас, поэтому встроенный код содержит уже скомпилированные функции рендеринга вместо необработанных строк шаблона.</target>
        </trans-unit>
        <trans-unit id="75f9865708d8a06fa846e682702658bdabd9c8e0" translate="yes" xml:space="preserve">
          <source>The easiest way to try out Vue.js is using the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;JSFiddle Hello World example&lt;/a&gt;. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;create an &lt;code&gt;index.html&lt;/code&gt; file&lt;/a&gt; and include Vue with:</source>
          <target state="translated">Самый простой способ попробовать Vue.js - использовать &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/50wL7mdz/&quot;&gt;пример JSFiddle Hello World&lt;/a&gt; . Не стесняйтесь открывать его в другой вкладке и следить, пока мы рассмотрим некоторые основные примеры. Или вы можете &lt;a href=&quot;https://gist.githubusercontent.com/chrisvfritz/7f8d7d63000b48493c336e48b3db3e52/raw/ed60c4e5d5c6fec48b0921edaed0cb60be30e87c/index.html&quot;&gt;создать файл &lt;code&gt;index.html&lt;/code&gt; &lt;/a&gt; и включить Vue с помощью:</target>
        </trans-unit>
        <trans-unit id="847757f66edc351ea14e3e7f70aa130ed1b67ad7" translate="yes" xml:space="preserve">
          <source>The el option can no longer be used in &lt;code&gt;Vue.extend&lt;/code&gt;. It&amp;rsquo;s only valid as an instance creation option.</source>
          <target state="translated">Параметр el больше нельзя использовать в &lt;code&gt;Vue.extend&lt;/code&gt; . Он действителен только как вариант создания экземпляра.</target>
        </trans-unit>
        <trans-unit id="14ff2ebab179926c1bba713b3418f8fa507384ca" translate="yes" xml:space="preserve">
          <source>The filter&amp;rsquo;s function always receives the expression&amp;rsquo;s value (the result of the former chain) as its first argument. In the above example, the &lt;code&gt;capitalize&lt;/code&gt; filter function will receive the value of &lt;code&gt;message&lt;/code&gt; as its argument.</source>
          <target state="translated">Функция фильтра всегда получает значение выражения (результат предыдущей цепочки) в качестве своего первого аргумента. В приведенном выше примере функция фильтра с &lt;code&gt;capitalize&lt;/code&gt; получит значение &lt;code&gt;message&lt;/code&gt; качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="25978631002a6e912099e352f219ba34c4dc10cb" translate="yes" xml:space="preserve">
          <source>The filtered list will &lt;em&gt;only&lt;/em&gt; be re-evaluated if there are relevant changes to the &lt;code&gt;users&lt;/code&gt; array, making filtering much more efficient.</source>
          <target state="translated">Отфильтрованный список будет &lt;em&gt;только&lt;/em&gt; переоцениваться , если есть соответствующие изменения в &lt;code&gt;users&lt;/code&gt; массив, что делает фильтрацию гораздо более эффективными.</target>
        </trans-unit>
        <trans-unit id="b5951356bec324133fa39def8def2ef7e47b05c1" translate="yes" xml:space="preserve">
          <source>The following template:</source>
          <target state="translated">Следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="6e4a514c82bb3b7baff7919684302ede3370a422" translate="yes" xml:space="preserve">
          <source>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; for a more inspection-friendly interface.</source>
          <target state="translated">Геттеры / сеттеры невидимы для пользователя, но внутри они позволяют Vue выполнять отслеживание зависимостей и уведомление об изменении при доступе к свойствам или их изменении. Одно предостережение заключается в том, что консоли браузера по-разному форматируют геттеры / сеттеры при регистрации преобразованных объектов данных, поэтому вы можете установить &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; для более удобного интерфейса.</target>
        </trans-unit>
        <trans-unit id="8cd9d811837e0eecf0a4df368877b6262fe04425" translate="yes" xml:space="preserve">
          <source>The implicitly assigned &lt;code&gt;$index&lt;/code&gt; and &lt;code&gt;$key&lt;/code&gt; variables have been removed in favor of explicitly defining them in &lt;code&gt;v-for&lt;/code&gt;. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.</source>
          <target state="translated">Неявно назначенные переменные &lt;code&gt;$index&lt;/code&gt; и &lt;code&gt;$key&lt;/code&gt; были удалены в пользу их явного определения в &lt;code&gt;v-for&lt;/code&gt; . Это упрощает чтение кода для разработчиков, менее опытных с Vue, а также приводит к более четкому поведению при работе с вложенными циклами.</target>
        </trans-unit>
        <trans-unit id="cd591127230d8deaf3a79ff7072473dcdfb326ef" translate="yes" xml:space="preserve">
          <source>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</source>
          <target state="translated">Опции инстанцирования,используемые для текущего экземпляра Vue.Это полезно,когда вы хотите включить пользовательские свойства в опции:</target>
        </trans-unit>
        <trans-unit id="6507e95ac3123f38dc39170ae522dfbce1786b53" translate="yes" xml:space="preserve">
          <source>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the &lt;code&gt;v-on&lt;/code&gt; attribute isn&amp;rsquo;t feasible. That&amp;rsquo;s why &lt;code&gt;v-on&lt;/code&gt; can also accept the name of a method you&amp;rsquo;d like to call.</source>
          <target state="translated">Однако логика для многих обработчиков событий будет более сложной, поэтому сохранение вашего JavaScript в значении атрибута &lt;code&gt;v-on&lt;/code&gt; невозможно. Вот почему &lt;code&gt;v-on&lt;/code&gt; также может принимать имя метода, который вы хотите вызвать.</target>
        </trans-unit>
        <trans-unit id="a7dfd0134284048bc632e36141f4ea3e7333c213" translate="yes" xml:space="preserve">
          <source>The match is first checked on the component&amp;rsquo;s own &lt;code&gt;name&lt;/code&gt; option, then its local registration name (the key in the parent&amp;rsquo;s &lt;code&gt;components&lt;/code&gt; option) if the &lt;code&gt;name&lt;/code&gt; option is not available. Anonymous components cannot be matched against.</source>
          <target state="translated">Соответствие сначала проверяется в параметре собственного &lt;code&gt;name&lt;/code&gt; компонента , затем его локальном регистрационном имени (ключ в параметре родительского &lt;code&gt;components&lt;/code&gt; ), если параметр &lt;code&gt;name&lt;/code&gt; недоступен. Анонимные компоненты не могут быть сопоставлены.</target>
        </trans-unit>
        <trans-unit id="a6157926048113f46fe23ee578e48fe424291d8e" translate="yes" xml:space="preserve">
          <source>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</source>
          <target state="translated">Максимальное количество экземпляров компонентов для кэширования.Как только это число будет достигнуто,кэшированный экземпляр компонента,который был доступен меньше всего недавно,будет уничтожен перед созданием нового экземпляра.</target>
        </trans-unit>
        <trans-unit id="8bf10a52fb597971ee2811a4b6daca68eb87e10e" translate="yes" xml:space="preserve">
          <source>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</source>
          <target state="translated">Стратегия слияния получает значение опции,определенной на родительском и дочернем экземплярах в качестве первого и второго аргументов соответственно.В качестве третьего аргумента передаётся контекстный экземпляр Vue.</target>
        </trans-unit>
        <trans-unit id="7f5a003cef802af9e91a6f9747fac2e515359d41" translate="yes" xml:space="preserve">
          <source>The method returns the instance itself so you can chain other instance methods after it.</source>
          <target state="translated">Метод возвращает сам экземпляр,так что вы можете связать другие методы экземпляра с ним.</target>
        </trans-unit>
        <trans-unit id="46eb4e33843509639b8c44662beadd21ed8310ed" translate="yes" xml:space="preserve">
          <source>The most basic form of data binding is text interpolation using the &amp;ldquo;Mustache&amp;rdquo; syntax (double curly braces):</source>
          <target state="translated">Самая простая форма привязки данных - это интерполяция текста с использованием синтаксиса &amp;laquo;Усы&amp;raquo; (двойные фигурные скобки):</target>
        </trans-unit>
        <trans-unit id="bd564c73b6d49eec1b2c8919fa49f3bc33098a11" translate="yes" xml:space="preserve">
          <source>The most common use case is combined with &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">Наиболее распространенный вариант использования совмещен с &lt;code&gt;v-for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c379b64d918d58c59f406c013a50f15fd94aaa4c" translate="yes" xml:space="preserve">
          <source>The mustache tag will be replaced with the value of the &lt;code&gt;msg&lt;/code&gt; property on the corresponding data object. It will also be updated whenever the data object&amp;rsquo;s &lt;code&gt;msg&lt;/code&gt; property changes.</source>
          <target state="translated">Тег усов будет заменен значением свойства &lt;code&gt;msg&lt;/code&gt; соответствующего объекта данных. Он также будет обновляться при изменении свойства &lt;code&gt;msg&lt;/code&gt; объекта данных.</target>
        </trans-unit>
        <trans-unit id="37afbe4bcd06f0f0be230e6d8e06d5f57d026a3e" translate="yes" xml:space="preserve">
          <source>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or &lt;a href=&quot;single-file-components&quot;&gt;single-file component&lt;/a&gt;), we strongly recommend following the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;W3C rules&lt;/a&gt; for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</source>
          <target state="translated">Имя, которое вы даете компоненту, может зависеть от того, где вы собираетесь его использовать. При использовании компонента непосредственно в DOM (в отличие от строкового шаблона или &lt;a href=&quot;single-file-components&quot;&gt;однофайлового компонента&lt;/a&gt; ) мы настоятельно рекомендуем следовать &lt;a href=&quot;https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name&quot;&gt;правилам W3C&lt;/a&gt; для имен настраиваемых тегов (все строчные буквы, должны содержать дефис). Это поможет вам избежать конфликтов с текущими и будущими элементами HTML.</target>
        </trans-unit>
        <trans-unit id="49544b57b4faf031cbd490df14c62342f8913c7c" translate="yes" xml:space="preserve">
          <source>The new, more concise way to configure &lt;code&gt;keyCodes&lt;/code&gt; is through &lt;code&gt;Vue.config.keyCodes&lt;/code&gt;. For example:</source>
          <target state="translated">Новый, более лаконичный способ настройки &lt;code&gt;keyCodes&lt;/code&gt; - через &lt;code&gt;Vue.config.keyCodes&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="1ba4a8191026a27a782703cf2cb8992c45a25eab" translate="yes" xml:space="preserve">
          <source>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the &lt;code&gt;props&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt; initialization.</source>
          <target state="translated">Следующие 2 примера работают с Vue 2.2.1+. Ниже этой версии введенные значения были разрешены после &lt;code&gt;props&lt;/code&gt; и инициализации &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e0ddfdd8217a03837dee9d518c520c1cff551b" translate="yes" xml:space="preserve">
          <source>The next thing you&amp;rsquo;ll have to become familiar with is how to use template features in the &lt;code&gt;createElement&lt;/code&gt; function. Here are the arguments that &lt;code&gt;createElement&lt;/code&gt; accepts:</source>
          <target state="translated">Следующее, с чем вам нужно будет ознакомиться, это как использовать возможности шаблона в функции &lt;code&gt;createElement&lt;/code&gt; . Вот аргументы, которые принимает &lt;code&gt;createElement&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a93809e131de1acb92c27480b98ade7c8b177368" translate="yes" xml:space="preserve">
          <source>The object syntax for &lt;code&gt;v-bind:style&lt;/code&gt; is pretty straightforward - it looks almost like CSS, except it&amp;rsquo;s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</source>
          <target state="translated">Синтаксис объекта для &lt;code&gt;v-bind:style&lt;/code&gt; довольно прост - он выглядит почти как CSS, за исключением того, что это объект JavaScript. Вы можете использовать camelCase или kebab-case (используйте кавычки с kebab-case) для имен свойств CSS:</target>
        </trans-unit>
        <trans-unit id="f804d7c199bb60087ee99a4d2ed2841ff111fad8" translate="yes" xml:space="preserve">
          <source>The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</source>
          <target state="translated">Официальное руководство предполагает знание HTML,CSS и JavaScript на среднем уровне.Если вы новичок во фронтенд-разработке,то,возможно,не лучшая идея прыгать прямо во фреймворк в качестве первого шага-ухватитесь за основы,а затем возвращайтесь! Предыдущий опыт работы с другими фреймворками помогает,но не требуется.</target>
        </trans-unit>
        <trans-unit id="cdcd3cc5d3cb2f01160d1290fc4a6159e0dddd79" translate="yes" xml:space="preserve">
          <source>The only exception to this being the use of &lt;code&gt;Object.freeze()&lt;/code&gt;, which prevents existing properties from being changed, which also means the reactivity system can&amp;rsquo;t &lt;em&gt;track&lt;/em&gt; changes.</source>
          <target state="translated">Единственным исключением из этого &lt;code&gt;Object.freeze()&lt;/code&gt; является использование Object.freeze () , который предотвращает изменение существующих свойств, что также означает, что система реактивности не может &lt;em&gt;отслеживать&lt;/em&gt; изменения.</target>
        </trans-unit>
        <trans-unit id="8eb7f5feed0a750d304ea8614d2edca774bd3f41" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;scoped&lt;/code&gt; attribute automatically scopes this CSS to your component by adding a unique attribute (such as &lt;code&gt;data-v-21e5b78&lt;/code&gt;) to elements and compiling &lt;code&gt;.list-container:hover&lt;/code&gt; to something like &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt;.</source>
          <target state="translated">Необязательный атрибут &lt;code&gt;scoped&lt;/code&gt; автоматически применяет этот CSS к вашему компоненту, добавляя уникальный атрибут (например, &lt;code&gt;data-v-21e5b78&lt;/code&gt; ) к элементам и компилируя &lt;code&gt;.list-container:hover&lt;/code&gt; к чему-то вроде &lt;code&gt;.list-container[data-v-21e5b78]:hover&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f86e91201591c3c1631acf2b2475e6e451afce5" translate="yes" xml:space="preserve">
          <source>The parent instance, if the current instance has one.</source>
          <target state="translated">Родительский экземпляр,если он есть в текущем экземпляре.</target>
        </trans-unit>
        <trans-unit id="a213359cc7f926ecae5256c14d1f382a33b06e44" translate="yes" xml:space="preserve">
          <source>The problem is event flows that depend on a component&amp;rsquo;s tree structure can be hard to reason about and are very brittle when the tree becomes large. They don&amp;rsquo;t scale well and only set you up for pain later. &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; also do not solve communication between sibling components.</source>
          <target state="translated">Проблема в том, что потоки событий, зависящие от древовидной структуры компонента, могут быть трудными для понимания и очень хрупкими, когда дерево становится большим. Они плохо масштабируются и только позже настраивают вас на боль. &lt;code&gt;$dispatch&lt;/code&gt; и &lt;code&gt;$broadcast&lt;/code&gt; также не решают проблему связи между одноуровневыми компонентами.</target>
        </trans-unit>
        <trans-unit id="98399a72800d5002678971cac53da1533e26a6d2" translate="yes" xml:space="preserve">
          <source>The problem is that large numbers of &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;element-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;) will be considerably slower than &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;class-attribute selectors&lt;/a&gt; (e.g. &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt;), so class selectors should be preferred whenever possible.</source>
          <target state="translated">Проблема в том, что большое количество &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=a%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;селекторов атрибутов элементов&lt;/a&gt; (например, &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ) будет значительно медленнее, чем &lt;a href=&quot;http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;amp;sel=.class%5Bhref%5D&amp;amp;body=background%3A+%23CFD&amp;amp;ne=1000&quot;&gt;селекторы атрибутов класса&lt;/a&gt; (например, &lt;code&gt;.btn-close[data-v-f3f3eg9]&lt;/code&gt; ), поэтому селекторы классов должны быть предпочтительнее, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="3bc4b51815e1ca75817d438f9a75b79de4143526" translate="yes" xml:space="preserve">
          <source>The problem is, there are also many &lt;em&gt;simple&lt;/em&gt; cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</source>
          <target state="translated">Проблема в том, что во многих &lt;em&gt;простых&lt;/em&gt; случаях эти шаблоны могут быть удобными. Осторожно: не поддавайтесь соблазну простоты торговли (способности понимать ход своего состояния) ради краткосрочного удобства (написание меньшего количества кода).</target>
        </trans-unit>
        <trans-unit id="690eaa8b769a27585770a32b044820cae46112dd" translate="yes" xml:space="preserve">
          <source>The problem is, there are cases where it&amp;rsquo;s important not to delete elements that will remain in the DOM. For example, you may want to use &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; to animate list sorting, or maintain focus if the rendered element is an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In these cases, adding a unique key for each item (e.g. &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt;) will tell Vue how to behave more predictably.</source>
          <target state="translated">Проблема в том, что бывают случаи, когда важно не удалять элементы, которые останутся в DOM. Например, вы можете использовать &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; для анимации сортировки списка или поддерживать фокус, если визуализированный элемент является &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; . В этих случаях добавление уникального ключа для каждого элемента (например &lt;code&gt;:key=&quot;todo.id&quot;&lt;/code&gt; ) укажет Vue, как вести себя более предсказуемо.</target>
        </trans-unit>
        <trans-unit id="35549fb2854bdbc4b65652d62df1f1ddfa7a99ea" translate="yes" xml:space="preserve">
          <source>The problem is, this button doesn&amp;rsquo;t do anything:</source>
          <target state="translated">Проблема в том, что эта кнопка ничего не делает:</target>
        </trans-unit>
        <trans-unit id="361cd98689630fb5a124f5e83b5f388af1b8a1f3" translate="yes" xml:space="preserve">
          <source>The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Предусмотренный элемент служит лишь точкой крепления. В отличие от Vue 1.x, подключенный элемент будет заменен DOM, созданным Vue, во всех случаях. Поэтому не рекомендуется монтировать корневой экземпляр в &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34592f5fd4a2054ce0011f9d4e26a9c654b6f7b5" translate="yes" xml:space="preserve">
          <source>The reason for not automatically injecting &lt;code&gt;item&lt;/code&gt; into the component is because that makes the component tightly coupled to how &lt;code&gt;v-for&lt;/code&gt; works. Being explicit about where its data comes from makes the component reusable in other situations.</source>
          <target state="translated">Причина, по которой &lt;code&gt;item&lt;/code&gt; не вводится автоматически в компонент, заключается в том, что это делает компонент тесно связанным с тем, как работает &lt;code&gt;v-for&lt;/code&gt; . Явное указание источника данных делает компонент пригодным для повторного использования в других ситуациях.</target>
        </trans-unit>
        <trans-unit id="c532c908704eacdd705ddb6c7847a0bd40253f67" translate="yes" xml:space="preserve">
          <source>The reason is this is the equivalent JavaScript that the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; would compile to:</source>
          <target state="translated">Причина в том, что это эквивалентный JavaScript, в который &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; компилируется:</target>
        </trans-unit>
        <trans-unit id="78702fdec5c6b73fa78a98283262c3e3a610ea89" translate="yes" xml:space="preserve">
          <source>The reference will be HTMLElement when used with functional components because they&amp;rsquo;re stateless and instanceless.</source>
          <target state="translated">Ссылка будет HTMLElement при использовании с функциональными компонентами, поскольку они не имеют состояния и экземпляра.</target>
        </trans-unit>
        <trans-unit id="c0c42bbffd6116ac9f9aa2c29f718360da13a0c7" translate="yes" xml:space="preserve">
          <source>The rendered HTML will be:</source>
          <target state="translated">Отображаемый HTML будет:</target>
        </trans-unit>
        <trans-unit id="a426ede2112c009fbf616db449e0c6e3bc884e8e" translate="yes" xml:space="preserve">
          <source>The result is that many components may include long lists of base components:</source>
          <target state="translated">В результате многие компоненты могут включать длинные списки базовых компонентов:</target>
        </trans-unit>
        <trans-unit id="0894c1243efd2b6757cc56c901b4af230a9aac04" translate="yes" xml:space="preserve">
          <source>The returned object can be used directly inside &lt;a href=&quot;../guide/render-function&quot;&gt;render functions&lt;/a&gt; and &lt;a href=&quot;../guide/computed&quot;&gt;computed properties&lt;/a&gt;, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</source>
          <target state="translated">Возвращенный объект можно использовать непосредственно внутри &lt;a href=&quot;../guide/render-function&quot;&gt;функций рендеринга&lt;/a&gt; и &lt;a href=&quot;../guide/computed&quot;&gt;вычисляемых свойств&lt;/a&gt; , и он будет запускать соответствующие обновления при изменении. Его также можно использовать как минимальное межкомпонентное хранилище состояний для простых сценариев:</target>
        </trans-unit>
        <trans-unit id="f5f2182d5b9e1141097f081f69203ed474e7f51a" translate="yes" xml:space="preserve">
          <source>The root DOM element that the Vue instance is managing.</source>
          <target state="translated">Корневой элемент DOM,которым управляет экземпляр Vue.</target>
        </trans-unit>
        <trans-unit id="1fb1fe84422a22a87a20ac9a9db7f5aca1ce36fc" translate="yes" xml:space="preserve">
          <source>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</source>
          <target state="translated">Корневой экземпляр Vue текущего дерева компонентов.Если текущий экземпляр не имеет родителей,то это значение будет само по себе.</target>
        </trans-unit>
        <trans-unit id="7b232ff8c5c18691a5df8efcbaf774a1cbaab836" translate="yes" xml:space="preserve">
          <source>The same is true for class bindings:</source>
          <target state="translated">То же самое относится и к классовым переплетам:</target>
        </trans-unit>
        <trans-unit id="dd2c503caba50c997d7446df74ac0da742e9b8eb" translate="yes" xml:space="preserve">
          <source>The size of your app (small to medium-sized apps will probably be less than a day)</source>
          <target state="translated">Размер вашего приложения (малые и средние приложения,вероятно,будет меньше,чем за день).</target>
        </trans-unit>
        <trans-unit id="71c2733bfb43f78b87500262cd44c42870815508" translate="yes" xml:space="preserve">
          <source>The special case to note here is the &lt;code&gt;data&lt;/code&gt; option - it must be a function when used with &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">Особый случай, на который следует обратить внимание, - это опция &lt;code&gt;data&lt;/code&gt; - она ​​должна быть функцией при использовании с &lt;code&gt;Vue.extend()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="572f57cb3c88ad0c0b5d74b281c1e800b18bf5b8" translate="yes" xml:space="preserve">
          <source>The store instance no longer exposes the event emitter interface (&lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;emit&lt;/code&gt;). If you were previously using the store as a global event bus, &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;see this section&lt;/a&gt; for migration instructions.</source>
          <target state="translated">Экземпляр магазина больше не предоставляет интерфейс генератора событий ( &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;emit&lt;/code&gt; ). Если вы ранее использовали хранилище в качестве глобальной шины событий, &lt;a href=&quot;migration#dispatch-and-broadcast-removed&quot;&gt;см.&lt;/a&gt; Инструкции по миграции в этом разделе .</target>
        </trans-unit>
        <trans-unit id="77d67a6f8225d0df00a5fc5a901f8f424ef25e4a" translate="yes" xml:space="preserve">
          <source>The syntax has changed slightly, so &lt;code&gt;/category/*tags&lt;/code&gt; for example, should be updated to &lt;code&gt;/category/:tags+&lt;/code&gt;.</source>
          <target state="translated">Синтаксис немного изменился, поэтому, например, &lt;code&gt;/category/*tags&lt;/code&gt; следует обновить до &lt;code&gt;/category/:tags+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908884184f3cb4e8612386879bc128af52d0df9c" translate="yes" xml:space="preserve">
          <source>The target object cannot be a Vue instance, or the root data object of a Vue instance.</source>
          <target state="translated">Целевым объектом не может быть ни экземпляр Vue,ни корневой объект данных экземпляра Vue.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
