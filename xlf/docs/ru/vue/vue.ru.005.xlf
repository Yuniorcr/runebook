<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="be3c142060e44ba8c62b670b8883bcca7cd5a4cc" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read &lt;a href=&quot;component-provide-inject&quot;&gt;Provide / Inject&lt;/a&gt;, &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt;, and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b0a231c686d6b708f4d2d26c98389f653ba04e" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt; and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;. Read that first if you are new to Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a1f77be28de1f8cd112541c8e445f32b88426b" translate="yes" xml:space="preserve">
          <source>This guide is primarily for users with prior Vue 2 experience who want to learn about the new features and changes in Vue 3. &lt;strong&gt;This is not something you have to read from top to bottom before trying out Vue 3.&lt;/strong&gt; While it looks like a lot has changed, a lot of what you know and love about Vue is still the same; but we wanted to be as thorough as possible and provide detailed explanations and examples for every documented change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029497cad2c3a227399525b3094cb469885f9f59" translate="yes" xml:space="preserve">
          <source>This guide will provide an overview of different design elements that are available for your use in creating documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">Он был заменен &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;параметром &lt;/a&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; , который принимает функцию, так что поведение прокрутки полностью настраивается - даже для каждого маршрута. Это открывает много новых возможностей, но для воспроизведения старого поведения:</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">Это было переработано как &lt;a href=&quot;../api/index#delimiters&quot;&gt;опция на уровне компонентов&lt;/a&gt; . Это позволяет вам использовать альтернативные разделители в вашем приложении без нарушения сторонних компонентов.</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">Это быстро вышло из-под контроля. Вот почему для произвольного предоставления контекстной информации дочерним компонентам мы рекомендуем &lt;a href=&quot;#Dependency-Injection&quot;&gt;внедрение зависимостей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">У этого есть две потенциальные проблемы:</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">Это поможет вам быстрее найти компонент,когда вам нужно будет его отредактировать или просмотреть,как его использовать.</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">Такая повышенная модульность не только облегчает миграцию на Vue 2,но и позволяет осуществлять разбор и форматирование валюты:</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">Это надуманный пример, но нам удалось разделить наше приложение на две меньшие единицы, и дочерний элемент достаточно хорошо отделен от родителя через интерфейс props. Теперь мы можем дополнительно улучшить наш компонент &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; , добавив более сложный шаблон и логику, не затрагивая родительское приложение.</target>
        </trans-unit>
        <trans-unit id="0656ba279b49d46a5cdfd7935d734273e07a9de6" translate="yes" xml:space="preserve">
          <source>This is a great tip to remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e19f220c4bd03c63d74d3c19c553f790da9b66d" translate="yes" xml:space="preserve">
          <source>This is a low-level internal API change and does not affect most developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">Это определенно самая сложная страница в руководстве для написания, но мы считаем ее важной. Скорее всего, у вас были проблемы, которые вы пытались решить, и вы использовали другую библиотеку для их решения. Вы здесь, потому что хотите узнать, может ли Vue лучше решить ваши конкретные проблемы. Вот на что мы надеемся ответить за вас.</target>
        </trans-unit>
        <trans-unit id="ac302dcb2061f99b9d2af5d1c922a8db1ee40057" translate="yes" xml:space="preserve">
          <source>This is especially important because of &lt;a href=&quot;v-on-native-modifier-removed&quot;&gt;the removal of the &lt;code&gt;.native&lt;/code&gt; modifier&lt;/a&gt;. Any listeners for events that aren't declared with &lt;code&gt;emits&lt;/code&gt; will now be included in the component's &lt;code&gt;$attrs&lt;/code&gt;, which by default will be bound to the component's root node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">Теперь это &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;опция в определениях маршрутов&lt;/a&gt; . Так, например, вы обновите:</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">Теперь это &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;опция в определении маршрута&lt;/a&gt; , которому вы хотите присвоить псевдоним. Так, например, вы обновите:</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">Это часто бывает полезно, потому что даже с &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; значение входных элементов HTML всегда возвращает строку. Если значение не может быть проанализировано с помощью &lt;code&gt;parseFloat()&lt;/code&gt; , возвращается исходное значение.</target>
        </trans-unit>
        <trans-unit id="a70c72c5011c169a2c1648b6eacd7fc7b9c7fc32" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute (opens new window)&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM (opens new window)&lt;/a&gt;, or another library/convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">Это актуально только для &lt;a href=&quot;../guide/single-file-components&quot;&gt;однофайловых компонентов&lt;/a&gt; . Он &lt;em&gt;не&lt;/em&gt; требует, чтобы &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; атрибут&lt;/a&gt; используется. Определение объема может осуществляться через &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модули CSS&lt;/a&gt; , стратегию на основе классов, такую ​​как &lt;a href=&quot;http://getbem.com/&quot;&gt;БЭМ&lt;/a&gt; , или другую библиотеку / соглашение.</target>
        </trans-unit>
        <trans-unit id="e3ecbb65364f0fdf669d68bae076b4de3385cb21" translate="yes" xml:space="preserve">
          <source>This is our starting point, except it's not working yet because our &lt;code&gt;repositories&lt;/code&gt; variable is not reactive. This means from a user's perspective, the repository list would remain empty. Let's fix that!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">Это похоже на &lt;code&gt;mixins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d606ea96e61ab331639ff4a07074c626da1c5c" translate="yes" xml:space="preserve">
          <source>This is something to be cautious of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1427909eab695a82c73616bf6ca58eaea604e27" translate="yes" xml:space="preserve">
          <source>This is something we do not recommend. Use at your own risk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">Это &lt;strong&gt;псевдоним&lt;/strong&gt; глобального &lt;code&gt;Vue.delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">Это &lt;strong&gt;псевдоним&lt;/strong&gt; глобального &lt;code&gt;Vue.set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">Это цена перехода на более низкий уровень, но это также дает вам гораздо больший контроль над деталями взаимодействия по сравнению с &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">Это порядок по умолчанию, который мы рекомендуем для опций компонентов. Они разделены на категории, поэтому вы будете знать, куда добавлять настраиваемые атрибуты и директивы.</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">Это порядок по умолчанию, который мы рекомендуем для опций компонентов. Они разделены на категории, поэтому вы будете знать, куда добавлять новые свойства из плагинов.</target>
        </trans-unit>
        <trans-unit id="7a7f1cb949f47a835f88db5681466149b0c54598" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f223c43426961a4fb3c1457dda5eadb68ad78" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">Это официальное руководство по стилю для кода, специфичного для Vue. Если вы используете Vue в проекте, это отличный справочник, позволяющий избежать ошибок, сбоев и анти-шаблонов. Однако мы не считаем, что какое-либо руководство по стилю идеально подходит для всех команд или проектов, поэтому поощряются осознанные отклонения, основанные на прошлом опыте, окружающем технологическом стеке и личных ценностях.</target>
        </trans-unit>
        <trans-unit id="260db489520475eb4d9d940e59e1b8c6d90f9b1c" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dc851eaa2d4a0946dac12cbc41fef4c40d2c4e" translate="yes" xml:space="preserve">
          <source>This is the very essence of Vue's reactivity system. When you return an object from &lt;code&gt;data()&lt;/code&gt; in a component, it is internally made reactive by &lt;code&gt;reactive()&lt;/code&gt;. The template is compiled into a &lt;a href=&quot;render-function&quot;&gt;render function&lt;/a&gt; that makes use of these reactive properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">Вот как выглядит пример в действии:</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">Однако это не всегда желательно, поэтому Vue предлагает вам способ сказать: &amp;laquo;Эти два элемента полностью разделены - не используйте их повторно&amp;raquo;. Добавьте &lt;code&gt;key&lt;/code&gt; атрибут с уникальными значениями:</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">Это не рекомендуется, так как это приводит к:</target>
        </trans-unit>
        <trans-unit id="82d553ff76c7a0d3860ad174bd983d0f26df9bc2" translate="yes" xml:space="preserve">
          <source>This isn't recommended, as it results in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">Это позволяет использовать &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; для нескольких условных дочерних элементов:</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">Это упрощает переопределение внутренних стилей, с удобочитаемыми именами классов, которые не имеют слишком высокой специфичности, но все же очень маловероятно, что они приведут к конфликту.</target>
        </trans-unit>
        <trans-unit id="6039ba72679e27c3de3fe59517757185e2ef8639" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5bca688970af00ecf6916734fc1be51e2996ec" translate="yes" xml:space="preserve">
          <source>This may be useful when you want to, for example, programmatically focus this input on component mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbccff00d4246ffaab0d554ac15f4da6d514888" translate="yes" xml:space="preserve">
          <source>This means you &lt;strong&gt;can&lt;/strong&gt; install/import these deps individually without ending up with different instances of these dependencies, but you must make sure they all resolve to the same version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">Этот метод необходимо вызвать перед вызовом &lt;code&gt;new Vue()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0ddd876bb6fb1b94f32ad08f1b3a4e6d7b7cb98" translate="yes" xml:space="preserve">
          <source>This method should not be confused with the &lt;a href=&quot;options-composition#provide-inject&quot;&gt;provide component option&lt;/a&gt; or the &lt;a href=&quot;composition-api#provide-inject&quot;&gt;provide function&lt;/a&gt; in the composition API. While those are also part of the same &lt;code&gt;provide&lt;/code&gt;/&lt;code&gt;inject&lt;/code&gt; mechanism, they are used to configure values provided by a component rather than an application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbaf50c98606e0673b924b093900524e24db8aeb" translate="yes" xml:space="preserve">
          <source>This might be helpful when we have an HTML element with &lt;code&gt;change&lt;/code&gt; event as a root element of &lt;code&gt;date-picker&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90aee8ca6c8b63ccbcb1d903920d255bfac3961" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP (opens new window)&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">Это может показаться волшебством, но под капотом Vue использует технику анимации под названием &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; для плавного перехода элементов из их старого положения в новое с помощью преобразований.</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">Это не только документирует ваш компонент, но также предупреждает пользователей в консоли JavaScript браузера, если они передают неправильный тип. Вы узнаете гораздо больше о &lt;a href=&quot;#Prop-Validation&quot;&gt;проверках типов и других проверках свойств&lt;/a&gt; далее на этой странице.</target>
        </trans-unit>
        <trans-unit id="2eede98c99888e9e8fb70ceb48eb9cdf213e42e5" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about &lt;a href=&quot;#prop-validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">Эта опция не больше не нужно теперь, когда система перехода Vue имеет явно &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; контроль перехода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dda8e2bba6581f8fe39ba87ae1f467605782e672" translate="yes" xml:space="preserve">
          <source>This page applies only to Vue 2.x and below, and assumes you've already read the &lt;a href=&quot;reactivity&quot;&gt;Reactivity Section&lt;/a&gt;. Please read that section first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">На этой странице предполагается, что вы уже прочитали &lt;a href=&quot;components&quot;&gt;основы работы&lt;/a&gt; с компонентами . Прочтите это в первую очередь, если вы новичок в компонентах.</target>
        </trans-unit>
        <trans-unit id="2f257c4f8981d39250383dd3af755f3faa35ddba" translate="yes" xml:space="preserve">
          <source>This page assumes you've already read the &lt;a href=&quot;component-basics&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e672f7510e855eb83e9a420fd1aab887fa1937" translate="yes" xml:space="preserve">
          <source>This page is not required reading in order to learn how to use Vue well, but it provides more information, should you be curious how rendering works under the hood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">Эта пара параметров используется вместе, чтобы позволить компоненту-предку служить в качестве инжектора зависимостей для всех его потомков, независимо от того, насколько глубока иерархия компонентов, пока они находятся в одной родительской цепочке. Если вы знакомы с React, это очень похоже на контекстную функцию React.</target>
        </trans-unit>
        <trans-unit id="2a14bf9014246214857ff883acbf4909435d0e01" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's &lt;code&gt;context&lt;/code&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">Это передает каждое свойство в объекте &lt;code&gt;doc&lt;/code&gt; (например, &lt;code&gt;title&lt;/code&gt; ) как отдельную опору, а затем добавляет слушателей обновления &lt;code&gt;v-on&lt;/code&gt; для каждого из них.</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">Этот шаблон позволяет использовать базовые компоненты больше похожие на необработанные HTML-элементы,без необходимости заботиться о том,какой элемент на самом деле находится в их корне:</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">Этот шаблон может служить заменой &lt;code&gt;$dispatch&lt;/code&gt; и &lt;code&gt;$broadcast&lt;/code&gt; в простых сценариях, но для более сложных случаев рекомендуется использовать специальный уровень управления состоянием, такой как &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bcacf748b9af6a54554db3c2d36be4ed02362a9" translate="yes" xml:space="preserve">
          <source>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5586c0722db91f034d221a64e55d5829bf071baf" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c88f592f793e32dd9e76308d4a6ba8bd42fb51" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">Этот раздел предполагает знание &lt;a href=&quot;components&quot;&gt;компонентов&lt;/a&gt; . Не стесняйтесь пропустить его и вернуться позже.</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">Этот раздел предполагает знание &lt;a href=&quot;components&quot;&gt;компонентов Vue&lt;/a&gt; . Не стесняйтесь пропустить его и вернуться позже.</target>
        </trans-unit>
        <trans-unit id="fb5b15406f75921e192409d91ff1b17d27fd994a" translate="yes" xml:space="preserve">
          <source>This section contains the search functionality for the application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b7709525d03239edb056d669680878e9735ae" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd61b2e32ea112a3e4dcdeb333fabe9dfc18a2f7" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f775635fcd735f353cd0996d158644d66269c8fe" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; and makes outputting &lt;code&gt;aria-*&lt;/code&gt; attributes easier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df51509bdf6631bdbd029391b7a92d14a5f11a4f" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between normal non-boolean attributes and &amp;ldquo;enumerated attributes&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34f69dcd5eb3d4acee6efe3176754e358fc43d6" translate="yes" xml:space="preserve">
          <source>This template doesn't feel great. It's not only verbose, but we're duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level. And when we add the anchor element, we have to again duplicate it in every &lt;code&gt;v-if/v-else-if&lt;/code&gt; branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2671e140fbe7037587dd494d52b8c4c16af6fa" translate="yes" xml:space="preserve">
          <source>This term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it&amp;rsquo;s a great one, is an Excel spreadsheet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da345bd2efafe0aab297aeb02da75f10e9617d3e" translate="yes" xml:space="preserve">
          <source>This will allow you to check all the events that a component emits and optionally &lt;a href=&quot;component-custom-events#validate-emitted-events&quot;&gt;validate them&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cf660900b36fb7082d6da4112e034f7880c495" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but &lt;code&gt;activeClass&lt;/code&gt; will only be applied when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">Это всегда будет применять &lt;code&gt;errorClass&lt;/code&gt; , но будет применять &lt;code&gt;activeClass&lt;/code&gt; только тогда, когда &lt;code&gt;isActive&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="c7c41413208280e0438efd8becdf4788ac79009e" translate="yes" xml:space="preserve">
          <source>This will be a new top-level option in the Vue CLI config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">Это приведет к проблемам при использовании компонентов с элементами,имеющими такие ограничения.Например:</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">Это больше не сработает:</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">Это отобразит только последнее значение в массиве, поддерживаемом браузером. В этом примере он будет отображать &lt;code&gt;display: flex&lt;/code&gt; для браузеров, которые поддерживают версию flexbox без префикса.</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">Это даст тот же результат. Мы также можем выполнить привязку к &lt;a href=&quot;computed&quot;&gt;вычисляемому свойству,&lt;/a&gt; которое возвращает объект. Это распространенный и мощный паттерн:</target>
        </trans-unit>
        <trans-unit id="d7b864922bd15ed63c01468766857939d0bedd4b" translate="yes" xml:space="preserve">
          <source>This will tell webpack to treat the Vue module as an external library and not bundle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">Это работает хорошо, но следует помнить об одном предостережении:</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">Это закрепит элемент на расстоянии 200 пикселей от верха страницы. Но что произойдет, если мы столкнемся со сценарием, когда нам нужно закрепить элемент слева, а не сверху? Здесь очень удобен динамический аргумент, который можно обновлять для каждого экземпляра компонента:</target>
        </trans-unit>
        <trans-unit id="3e3f2385e5295eb0996806c6e44de1cd3bf29c86" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af979b8150c4855a484c40f48bb6c2a78e8cf7" translate="yes" xml:space="preserve">
          <source>Though the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component can be wonderful for components entering and leaving, you can also activate an animation without mounting a component, by adding a conditional class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de901ca4a37c13bd513536f6104058a8ebeab4" translate="yes" xml:space="preserve">
          <source>Though this provided some convenience in terms of root instances having a shared state, this has led to confusion due to the fact that its only possible on the root instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e255605141c6fd6ae34a1f00f4a710389219fe6" translate="yes" xml:space="preserve">
          <source>Though you can achieve great effects for simple animation with the two handles the cubic-bezier ease offers, JavaScript allows multiple handles, and therefore, allows for much more variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3296891d857a3b88e24b3a8f562ed3941e52be8" translate="yes" xml:space="preserve">
          <source>Though you might have seen labels wrapping the input fields like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">Таким образом, позволяя родительскому компоненту фокусировать ввод внутри &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; с помощью:</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">Названия тесно связанных компонентов</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать тесно&lt;/sup&gt; связанные имена компонентов&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="098024dc5537ca3623978ac7c0a6140ce39062b8" translate="yes" xml:space="preserve">
          <source>Timing</source>
          <target state="translated">Timing</target>
        </trans-unit>
        <trans-unit id="40b635fbbc82098772ee7e3177e62a9c14ea2014" translate="yes" xml:space="preserve">
          <source>Tips, Callouts, Alerts, and Line Highlights</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881f5e312126d5e8ea790db899552b0144c3c571" translate="yes" xml:space="preserve">
          <source>To access component instance properties, we need to convert &lt;code&gt;provide&lt;/code&gt; to be a function returning an object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19f5499c85a1ceeb0b480c98eff4e4346929cd2" translate="yes" xml:space="preserve">
          <source>To add line highlighting to your code blocks, you need to append the line number in curly braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddd888c6582ef9d6fa2ab28bf309c8d36b0be42" translate="yes" xml:space="preserve">
          <source>To add methods to a component instance we use the &lt;code&gt;methods&lt;/code&gt; option. This should be an object containing the desired methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20869228946fc9bfb3ec15b09cdff057ca44c507" translate="yes" xml:space="preserve">
          <source>To add reactivity between provided and injected values, we can use a &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;ref&lt;/a&gt; or &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; when providing a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0cfd696ee7275a932682ace8d519ee632cc69c" translate="yes" xml:space="preserve">
          <source>To add validation, the event is assigned a function that receives the arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call and returns a boolean to indicate whether the event is valid or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788042730e582de0e5c9cadbed06a9452fa7048a" translate="yes" xml:space="preserve">
          <source>To address these issues, we added a new way to organize code by logical concerns: the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">Чтобы решить эту проблему, Vue предоставляет &lt;strong&gt;модификаторы событий&lt;/strong&gt; для &lt;code&gt;v-on&lt;/code&gt; . Напомним, что модификаторы - это постфиксы директив, обозначаемые точкой.</target>
        </trans-unit>
        <trans-unit id="1f82c84ad360cae69c196ca0363ef72d7d1df639" translate="yes" xml:space="preserve">
          <source>To also build &lt;code&gt;umd&lt;/code&gt; and &lt;code&gt;cjs&lt;/code&gt; modules we can simply add a few lines of configuration to our &lt;code&gt;rollup.config.js&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">Чтобы также обнаруживать изменения вложенных значений внутри объектов, вам необходимо передать &lt;code&gt;deep: true&lt;/code&gt; в аргументе options. Обратите внимание, что вам не нужно этого делать, чтобы отслеживать мутации массива.</target>
        </trans-unit>
        <trans-unit id="cce00248496d96a2067177aed26ff61ce35a2340" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don't need to do so to listen for array mutations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">По одному определению оживить - значит оживить. К сожалению, когда дизайнеры создают значки, логотипы и талисманы, они обычно предоставляются в виде изображений или статических SVG-файлов. Таким образом, хотя октокот GitHub, птица Twitter и многие другие логотипы напоминают живых существ, на самом деле они не кажутся живыми.</target>
        </trans-unit>
        <trans-unit id="8a3a9f59e5420390dc20b2d39b4aad21d989a106" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they're usually delivered as images or static SVGs. So although GitHub's octocat, Twitter's bird, and many other logos resemble living creatures, they don't really seem alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b12f0b2b03b56612ac89d3a0da0c957181b463" translate="yes" xml:space="preserve">
          <source>To apply and &lt;em&gt;automatically re-apply&lt;/em&gt; a side effect based on reactive state, we can use the &lt;code&gt;watchEffect&lt;/code&gt; method. It runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">Чтобы избежать отображения списка, если он должен быть скрыт (например, &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ). В этих случаях переместите &lt;code&gt;v-if&lt;/code&gt; в элемент контейнера (например, &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;ol&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11af8c48788875166f2c82baaf2047c13709005d" translate="yes" xml:space="preserve">
          <source>To avoid these problems, in Vue 3 we introduce&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f959a2209cc4ae6dde0fc52d270647a756227800" translate="yes" xml:space="preserve">
          <source>To change a model name, instead of a &lt;code&gt;model&lt;/code&gt; component option, now we can pass an &lt;em&gt;argument&lt;/em&gt; to &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f16b9b50a22626214a8a2ce30432a9dda3b421" translate="yes" xml:space="preserve">
          <source>To configure our build with Rollup we will need to create a &lt;code&gt;rollup.config.js&lt;/code&gt; file in the root of our project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f956073caa60e7478f9715ae3f9c555d2f8969" translate="yes" xml:space="preserve">
          <source>To create a VNode for a component, the first argument passed to &lt;code&gt;h&lt;/code&gt; should be the component itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a4ddff02308f2d46c7bfb2cc80ec93a6254881" translate="yes" xml:space="preserve">
          <source>To create a reactive state from a JavaScript object, we can use a &lt;code&gt;reactive&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">Чтобы справиться с предостережением 2, вы можете использовать &lt;code&gt;splice&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">Чтобы объяснить, что происходит, назовем наши компоненты A и B. Модульная система видит, что ей нужен A, но сначала A нужен B, но B нужен A, но A нужен B и т. Д. Он застрял в цикле, не зная, как это сделать. полностью разрешить любой компонент без предварительного разрешения другого. Чтобы исправить это, нам нужно дать модульной системе точку, в которой она может сказать: &amp;laquo;В &lt;em&gt;конце концов&lt;/em&gt; А понадобится Б , но нет необходимости сначала решать Б&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">Для фильтрации элементов в списке (например, &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ). В этих случаях замените &lt;code&gt;users&lt;/code&gt; новым вычисляемым свойством, которое возвращает ваш отфильтрованный список (например, &lt;code&gt;activeUsers&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать работу с Vue, все, что вам нужно, - это знакомство с HTML и ES5 JavaScript (т.е. обычным JavaScript). Обладая этими базовыми навыками, вы можете начать создавать нетривиальные приложения менее чем за день после чтения &lt;a href=&quot;../index&quot;&gt;руководства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="776030a16d16967752ee7198797ade27b5d2a7fc" translate="yes" xml:space="preserve">
          <source>To get type inference for the arguments passed to &lt;code&gt;setup()&lt;/code&gt;, the use of &lt;a href=&quot;global-api#definecomponent&quot;&gt;defineComponent&lt;/a&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Чтобы дать Vue подсказку, чтобы он мог отслеживать идентичность каждого узла и, таким образом, повторно использовать и переупорядочивать существующие элементы, вам необходимо предоставить уникальный &lt;code&gt;key&lt;/code&gt; атрибут для каждого элемента:</target>
        </trans-unit>
        <trans-unit id="5fcb75ebf027b9d0a0175ff64ac67858b09230bc" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">Чтобы решить эту проблему, мы можем использовать &lt;strong&gt;шаблон магазина&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="6bab7ec362c384e83157e34842533353476c5f9b" translate="yes" xml:space="preserve">
          <source>To hide the link unless it is focused, you can add the following style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08b3c5e2c296cf501fe81d8b1fdad39e5bceb5" translate="yes" xml:space="preserve">
          <source>To keep the old behavior work, and as we will be coercing &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;'false'&lt;/code&gt;, in 3.x Vue developers need to make &lt;code&gt;v-bind&lt;/code&gt; expression resolve to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'false'&lt;/code&gt; for &lt;code&gt;contenteditable&lt;/code&gt; and &lt;code&gt;spellcheck&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше о программных прослушивателях, ознакомьтесь с API для &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;методов экземпляра событий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">Чтобы TypeScript мог правильно определять типы внутри параметров компонента Vue, вам необходимо определить компоненты с помощью &lt;code&gt;Vue.component&lt;/code&gt; или &lt;code&gt;Vue.extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5a0debe65b75107b626e13146620736020251e6" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;defineComponent&lt;/code&gt; global method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">Чтобы пользователи могли взаимодействовать с вашим приложением, мы можем использовать директиву &lt;code&gt;v-on&lt;/code&gt; для присоединения слушателей событий, которые вызывают методы в наших экземплярах Vue:</target>
        </trans-unit>
        <trans-unit id="d33212d2502112422cf740d702a092d37f765943" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b795d5e4656eb47b1b382ba73bb73ecac50f9c6e" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;item&lt;/code&gt; available to the slot content provided by the parent, we can add a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element and bind it as an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Чтобы сделать &lt;code&gt;user&lt;/code&gt; доступным для содержимого слота в родительском элементе , мы можем привязать &lt;code&gt;user&lt;/code&gt; как атрибут к элементу &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d5ee521751945f607f368f2972a7a5e30916787" translate="yes" xml:space="preserve">
          <source>To make Composition API feature-complete compared to Options API, we also need a way to register lifecycle hooks inside &lt;code&gt;setup&lt;/code&gt;. This is possible thanks to several new functions exported from Vue. Lifecycle hooks on composition API have the same name as for Options API but are prefixed with &lt;code&gt;on&lt;/code&gt;: i.e. &lt;code&gt;mounted&lt;/code&gt; would look like &lt;code&gt;onMounted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">Чтобы преодолеть оговорку 1, оба следующих действия будут выполнять то же самое, что и &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; , но также будут запускать обновления состояния в системе реактивности:</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">Чтобы передать содержимое в именованные слоты от родителя, используйте специальный атрибут &lt;code&gt;slot&lt;/code&gt; в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (используя компонент &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Named-Slots&quot;&gt;здесь в&lt;/a&gt; качестве примера):</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">Чтобы передать слоты с &lt;code&gt;scopedSlots&lt;/code&gt; областью дочернему компоненту с помощью функций рендеринга, используйте поле scopedSlots в данных VNode:</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">Чтобы предоставить контент для именованных слотов, мы можем использовать директиву &lt;code&gt;v-slot&lt;/code&gt; в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; , указав имя слота в качестве аргумента &lt;code&gt;v-slot&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="71b95472ceb5c02875dbc3b9d728b462388305b4" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we need to use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;'s argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">Чтобы получить реквизиты, переданные в слот, родительский компонент может использовать &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; с атрибутом &lt;code&gt;slot-scope&lt;/code&gt; (используя &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Scoped-Slots&quot;&gt;здесь в&lt;/a&gt; качестве примера):</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">Для определения стилей Vue добавляет уникальный атрибут к элементам компонента, например &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; . Затем селекторы изменяются так, что выбираются только совпадающие элементы с этим атрибутом (например, &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">Чтобы решить эту проблему, Vue предоставляет свойство &lt;code&gt;$listeners&lt;/code&gt; содержащее объект слушателей, используемых в компоненте. Например:</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">Чтобы задать тему для нашего плагина по выбору даты,нам,возможно,понадобится добавить конкретный класс,например,такой:</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">Чтобы указать проверки свойств, вы можете предоставить объекту с требованиями проверки значения &lt;code&gt;props&lt;/code&gt; вместо массива строк. Например:</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Чтобы начать переход к более надежному решению с использованием Vue 2.0, давайте сначала обернем этот фильтр в новый компонент &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69b37bec21337bb3fab748d90757734b339759ac" translate="yes" xml:space="preserve">
          <source>To take advantage of our newly created &lt;code&gt;esm&lt;/code&gt; module we need to add a few fields in our &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceeb4fc5def0e78eb9b247f42dfe35a650c1ee1" translate="yes" xml:space="preserve">
          <source>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать эти компоненты в шаблонах, они должны быть зарегистрированы, чтобы Vue знал о них. Существует два типа регистрации компонентов: &lt;strong&gt;глобальная&lt;/strong&gt; и &lt;strong&gt;локальная&lt;/strong&gt; . Пока что мы зарегистрировали компоненты только глобально, используя &lt;code&gt;Vue.component&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c646dfddede1e8b816398b2a45bcbd049b84852a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we've only registered components globally, using the &lt;code&gt;component&lt;/code&gt; method of our app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">Переключает свойство &lt;code&gt;display&lt;/code&gt; CSS элемента в зависимости от правдивости значения выражения.</target>
        </trans-unit>
        <trans-unit id="c759e0477d126a03e9d103eb8525e47fab0be4d4" translate="yes" xml:space="preserve">
          <source>Toggles the element's &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2062eeee29d80bbd790b6b1c6949a13f04e9706" translate="yes" xml:space="preserve">
          <source>Track the function that changes it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">Ошибки отслеживания времени выполнения</target>
        </trans-unit>
        <trans-unit id="a176cdd957b46dda003cee3ad2c254dd6615b0eb" translate="yes" xml:space="preserve">
          <source>Transform and Opacity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Атрибут &lt;code&gt;stagger&lt;/code&gt; перехода &lt;sup&gt;удален&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="da0592cf78795180a4901cee778a25e6a87d50a4" translate="yes" xml:space="preserve">
          <source>Transition Class Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">Переходные классы</target>
        </trans-unit>
        <trans-unit id="e11311738d4c6ffea274c409ecdda9e0756654ab" translate="yes" xml:space="preserve">
          <source>Transition Group Root Element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">Переходные режимы</target>
        </trans-unit>
        <trans-unit id="c63dd8b039c9bc74f39dc660f1a5dd0332bdb933" translate="yes" xml:space="preserve">
          <source>Transition Modes so that you can orchestrate ordering during a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">Переход между компонентами</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">Переход между элементами</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">Переходные отдельные элементы/компоненты</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">Переход между компонентами еще проще - нам даже не нужен &lt;code&gt;key&lt;/code&gt; атрибут. Вместо этого мы оборачиваем &lt;a href=&quot;components#Dynamic-Components&quot;&gt;динамический компонент&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3ebf68016515c38ab5d5bb14e02906e976906a37" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don't even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;component-basics#dynamic-components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e93cce4e6bbda7187841b2d8bb8c9ea9bb591d" translate="yes" xml:space="preserve">
          <source>Transitioning different states in an application, with &lt;code&gt;watchers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">Переходы можно повторно использовать через систему компонентов Vue. Чтобы создать многократно используемый переход, все, что вам нужно сделать, это поместить компонент &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; в корень, а затем передать всех дочерних элементов в компонент перехода.</target>
        </trans-unit>
        <trans-unit id="3389419ab0dc8619c42e92046a205d6cbaad10df" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue's component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">Переходы на первичного арендатора</target>
        </trans-unit>
        <trans-unit id="ea9b9a14750b0c53f7e4ae9826cc61972586d91e" translate="yes" xml:space="preserve">
          <source>Transitions with Style Bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">Перевести Документы</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">Запуск события в текущем экземпляре. Любые дополнительные аргументы будут переданы в функцию обратного вызова слушателя.</target>
        </trans-unit>
        <trans-unit id="ff7ce3c92d4d6dbb6b2b78de21280fe459138d0f" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc40b121c3b5e2b8c970420d2e421c9a7ed7cd" translate="yes" xml:space="preserve">
          <source>Trigger the function so it can update the final value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">триггерные переходы</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">Запускает &lt;code&gt;beforeDestroy&lt;/code&gt; и &lt;code&gt;destroyed&lt;/code&gt; крючки.</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Правдивость / ложность с &lt;code&gt;v-bind&lt;/code&gt; &lt;sup&gt;изменена&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Попробуйте этот урок на Scrimba</target>
        </trans-unit>
        <trans-unit id="32ae11a86cc97e517601b6c7e4ad185de28233ca" translate="yes" xml:space="preserve">
          <source>Try to change the value of &lt;code&gt;books&lt;/code&gt; array in the application &lt;code&gt;data&lt;/code&gt; and you will see how &lt;code&gt;publishedBooksMessage&lt;/code&gt; is changing accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">Включить режим производства</target>
        </trans-unit>
        <trans-unit id="6ad6b070d8858ef9034c2b27714131daa17dc2f1" translate="yes" xml:space="preserve">
          <source>Two of the most commonly used directives in Vue.js are &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;. So it's no surprise that there comes a time when developers want to use both together. While this is not a recommended practice, there may be times when this is necessary, so we wanted to provide guidance for how it works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Двусторонние фильтры &lt;sup&gt;заменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">Типовые проверки</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">Поддержка TypeScript</target>
        </trans-unit>
        <trans-unit id="8170f1ce20dc21f163cf51322861b52a4e97389f" translate="yes" xml:space="preserve">
          <source>TypeScript should be able to infer most of the types without defining types explicitly. For example, if you have a component with a number &lt;code&gt;count&lt;/code&gt; property, you will have an error if you try to call a string-specific method on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55ceb4ee3907ab73fac7e8e26ce07c11d3e0af7" translate="yes" xml:space="preserve">
          <source>Typically this is done on the top of &lt;code&gt;App.vue&lt;/code&gt; as it will be the first focusable element on all your pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c49cff5528c3adc7123ea4b4bd10c092f423a6" translate="yes" xml:space="preserve">
          <source>Typically this is used to avoid conflicting with server-side frameworks that also use mustache syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5614fd83d7c12176ea9d23d0a9a55af15cb1297f" translate="yes" xml:space="preserve">
          <source>Typing</source>
          <target state="translated">Typing</target>
        </trans-unit>
        <trans-unit id="008b2efd937ff1c3483ebcd86c95416cf9a4fc6a" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;computed&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b08374e53ad50d899f5b39f4b437e0d89dd152" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;reactive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78cd4e8a3266b63fc59c7788f1a2d9d235e682" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;refs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="57c74547c7338aa72bc084a3800f580c969f4939" translate="yes" xml:space="preserve">
          <source>Under no circumstances should 2 alerts be used next to one another, it's a sign that we're not able to explain context well enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">Под капотом Vue компилирует шаблоны в виртуальные функции рендеринга DOM.В сочетании с системой реактивности Vue способна грамотно вычислить минимальное количество компонентов для повторной отрисовки и применить минимальное количество манипуляций с DOM при изменении состояния приложения.</target>
        </trans-unit>
        <trans-unit id="1a1ce3521c0de87c0b96c0765bcfe6f68f1f6e9e" translate="yes" xml:space="preserve">
          <source>Understandable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">К сожалению, HTML не позволяет настраиваемым элементам самозакрываться - только &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;официальные &amp;laquo;пустые&amp;raquo; элементы&lt;/a&gt; . Вот почему эта стратегия возможна только тогда, когда компилятор шаблонов Vue может достичь шаблона до DOM, а затем обслужить HTML, соответствующий спецификации DOM.</target>
        </trans-unit>
        <trans-unit id="98c83482c6886ad1473a05cf5f78dcfee5bc89dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn't allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &quot;void&quot; elements (opens new window)&lt;/a&gt;. That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">К сожалению, из-за нечувствительности к регистру в HTML шаблоны DOM по-прежнему должны использовать kebab-case.</target>
        </trans-unit>
        <trans-unit id="b10a452c474e61495690e111a7011d55f17f26b9" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5fadc81ad6c9be68633a21c0b94f28044dc294" translate="yes" xml:space="preserve">
          <source>Unfortunately, with such a destructuring the reactivity for both properties would be lost. For such a case, we need to convert our reactive object to a set of refs. These refs will retain the reactive connection to the source object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">Единичные испытания</target>
        </trans-unit>
        <trans-unit id="fa4ba8e0a89b5b3663d1a20fd16ffec2b04f9510" translate="yes" xml:space="preserve">
          <source>Unit testing a Vue application does not significantly differ from testing other types of applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fab82db2414bfb4495b150b0fb016a74e7217d8" translate="yes" xml:space="preserve">
          <source>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">Если вы не распределяете компоненты по нескольким файлам (например, с &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;помощью модулей CSS&lt;/a&gt; ), определение области видимости CSS в React часто выполняется с помощью решений CSS-in-JS (например, &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;стилизованные компоненты&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;гламурность&lt;/a&gt; и &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;эмоции&lt;/a&gt; ). Это вводит новую парадигму стиля, ориентированную на компоненты, которая отличается от обычного процесса разработки CSS. Кроме того, несмотря на то, что существует поддержка извлечения CSS в единую таблицу стилей во время сборки, по-прежнему часто требуется включить среду выполнения в пакет для правильной работы стилей. Хотя при построении стилей вы получаете доступ к динамизму JavaScript, часто приходится сталкиваться с увеличением размера пакета и стоимости выполнения.</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">В отличие от &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; , он отображает реальный элемент: по умолчанию &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; . Вы можете изменить отображаемый элемент с помощью атрибута &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6acb74ac65b8a5066968b3279fd2e776accbabb" translate="yes" xml:space="preserve">
          <source>Unlike attributes, directives can't be passed to a different element with &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">В отличие от компонентов и свойств, имена событий не обеспечивают автоматического преобразования регистра. Вместо этого имя генерируемого события должно точно соответствовать имени, используемому для прослушивания этого события. Например, если генерируется имя события camelCased:</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">В отличие от компонентов и свойств, имена событий никогда не будут использоваться в качестве имен переменных или свойств в JavaScript, поэтому нет причин использовать camelCase или PascalCase. Кроме того, слушатели событий &lt;code&gt;v-on&lt;/code&gt; внутри шаблонов DOM будут автоматически преобразованы в нижний регистр (из-за нечувствительности HTML к регистру), поэтому &lt;code&gt;v-on:myEvent&lt;/code&gt; станет &lt;code&gt;v-on:myevent&lt;/code&gt; , что &lt;code&gt;myEvent&lt;/code&gt; невозможным для прослушивания.</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">В отличие от 1.x, эти &lt;code&gt;$refs&lt;/code&gt; не являются реактивными, потому что они регистрируются / обновляются во время самого процесса рендеринга. Чтобы сделать их реактивными, потребовалось бы дублировать рендеры для каждого изменения.</target>
        </trans-unit>
        <trans-unit id="fcbebe457290f0fc4402b0c59876bcbdda0f2d4e" translate="yes" xml:space="preserve">
          <source>Unlike most of the application methods, &lt;code&gt;mount&lt;/code&gt; does not return the application. Instead it returns the root component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2884ecb559d2fe9248396c1892b61a7ac7c3279" translate="yes" xml:space="preserve">
          <source>Unlike single root node components, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If &lt;code&gt;$attrs&lt;/code&gt; are not bound explicitly, a runtime warning will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a11b676273740dcc6b273657283a0efe154b9e" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;component-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven't read about components yet, don't worry about this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">В отличие от других модификаторов, которые являются эксклюзивными для собственных событий DOM, модификатор &lt;code&gt;.once&lt;/code&gt; также может использоваться для &lt;a href=&quot;components-custom-events&quot;&gt;событий компонентов&lt;/a&gt; . Если вы еще не читали о компонентах, не беспокойтесь об этом.</target>
        </trans-unit>
        <trans-unit id="d465ac61f7785357bc3939f874106ce910c0065e" translate="yes" xml:space="preserve">
          <source>Unmounts a root component of the application instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">Обновлено в 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;См. Здесь&lt;/a&gt; устаревший синтаксис с использованием атрибута &lt;code&gt;slot-scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">Обновлено в 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;См.&lt;/a&gt; Устаревший синтаксис с использованием атрибута &lt;code&gt;slot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">Обновляет &lt;code&gt;innerHTML&lt;/code&gt; элемента . &lt;strong&gt;Обратите внимание, что содержимое вставляется как простой HTML - они не будут скомпилированы как шаблоны Vue&lt;/strong&gt; . Если вы обнаружите, что пытаетесь составлять шаблоны с помощью &lt;code&gt;v-html&lt;/code&gt; , попробуйте переосмыслить решение, используя вместо этого компоненты.</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">&lt;code&gt;textContent&lt;/code&gt; элемента . Если вам нужно обновить часть &lt;code&gt;textContent&lt;/code&gt; , вы должны использовать интерполяцию &lt;code&gt;{{ Mustache }}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0dca31a6bb9b094601cb2bf5c3fb308c6b17b07" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML (opens new window)&lt;/a&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56a36977305fbcc90290b7281ac8a8f0c3bd604" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent&quot;&gt;textContent (opens new window)&lt;/a&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;a href=&quot;../guide/template-syntax#text&quot;&gt;mustache interpolations&lt;/a&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c47365d1a0fe7112a5f7aa0465ebbfe1515656" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, we never have to do it manually. Instead, we tell Vue what HTML we want on the page, in a template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">Обновление всех этих узлов эффективно может быть затруднительным,но,к счастью,вам никогда не придется делать это вручную.Вместо этого вы сообщаете Vue,какой HTML вы хотите видеть на странице,в шаблоне:</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">Путь обновления</target>
        </trans-unit>
        <trans-unit id="ec1b871568c8f9b96404fba4999e4bb30bebeba0" translate="yes" xml:space="preserve">
          <source>Usage in Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4904a06bbdeb879018def05329454362a6b30d64" translate="yes" xml:space="preserve">
          <source>Usage inside &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a7118317b50bdd15b995e3d624b912b5b2b04f" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e644418d310386dee848ceb934d28e9af6afeacb" translate="yes" xml:space="preserve">
          <source>Usage on Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f552ba1fe9fac09e7847e64d87dc1587fbb26d11" translate="yes" xml:space="preserve">
          <source>Usage with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba388099a4f8ff3ba8295c16666928b0c410e2" translate="yes" xml:space="preserve">
          <source>Usage with Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74099084c0693149248e8ca16d0bd6b67bb5c59" translate="yes" xml:space="preserve">
          <source>Usage with Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ee016fea5ce9a71d77f20f1124659e54e0db2b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/plugins/tree/master/packages/replace&quot;&gt;@rollup/plugin-replace (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt; &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; (или, возможно, &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ) lodash, чтобы напрямую ограничить вызов дорогостоящего метода. Вы можете добиться того же, что и выше, следующим образом:</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; (или, возможно, &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; ) в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt; используйте в компоненте beforeRouteEnter .</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt; используйте beforeRouteLeave в компоненте.</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt; используйте beforeEnter в маршруте.</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">С осторожностью используйте &lt;code&gt;$parent&lt;/code&gt; и &lt;code&gt;$children&lt;/code&gt; - они в основном служат для эвакуации. Предпочитайте использовать реквизиты и события для общения родителей и детей.</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">&lt;code&gt;Array.prototype.splice&lt;/code&gt; этого используйте Array.prototype.splice . Например:</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Vue.set&lt;/code&gt; этого используйте Vue.set .</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">Используйте встроенный в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; метод .filter&lt;/a&gt; в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">Используйте встроенный в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; метод .slice&lt;/a&gt; в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">Используйте пользовательскую проверку in-DOM для других крючков.Например,для замены:</target>
        </trans-unit>
        <trans-unit id="181538426a8718fe366424835db6e5717dd50aee" translate="yes" xml:space="preserve">
          <source>Use actual heading tags instead of styling text to give the visual appearance of headings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">Вместо этого используйте компоненты.</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">Используйте глобальные миксины редко и осторожно, потому что это влияет на каждый созданный экземпляр Vue, включая сторонние компоненты. В большинстве случаев вы должны использовать его только для обработки настраиваемых параметров, как показано в примере выше. Также рекомендуется отправлять их как &lt;a href=&quot;plugins&quot;&gt;плагины,&lt;/a&gt; чтобы избежать дублирования приложений.</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">Используйте плагины, вызывая глобальный метод &lt;code&gt;Vue.use()&lt;/code&gt; . Это необходимо сделать до того, как вы запустите приложение, вызвав &lt;code&gt;new Vue()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">Используйте &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; для оптимальной отладки.</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;created&lt;/code&gt; хук.</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">Использование компонента &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; вместо крючков.</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">Используйте родной DOM API:</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">&lt;code&gt;beforeCreate&lt;/code&gt; этого используйте новый хук beforeCreate , что по сути то же самое. Он был переименован для согласования с другими методами жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">Вместо этого используйте новый &lt;code&gt;mounted&lt;/code&gt; крюк.</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">Вместо этого используйте новый &lt;code&gt;mounted&lt;/code&gt; крюк. Однако следует отметить, что с &lt;code&gt;mounted&lt;/code&gt; файлом нет гарантии, что он будет в документе. Для этого также &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b4605b49670d374a5aa51ee71b7ef52006c5d7a3" translate="yes" xml:space="preserve">
          <source>Use the official &lt;a href=&quot;#cli&quot;&gt;CLI&lt;/a&gt; to scaffold a project, which provides batteries-included build setups for a modern frontend workflow (e.g., hot-reload, lint-on-save, and much more)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160b6d69d6038c85412ab8171ce4aea2da0fb502" translate="yes" xml:space="preserve">
          <source>Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; component instance created afterwards in the given app (for example, child components):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f909c50760bc08f177877869663a7491252c658f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;dynamic components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">Используется для &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;динамических компонентов&lt;/a&gt; и для обхода &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;ограничений шаблонов в DOM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">Используется на контенте,вставленном в дочерние компоненты для указания,к какому именованному слоту принадлежит контент.</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">Используется для обозначения элемента &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; как слота с заданной областью действия.</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">Используется для обозначения элемента или компонента как слота с заданной областью действия. Значение атрибута должно быть допустимым выражением JavaScript, которое может отображаться в позиции аргумента сигнатуры функции. Это означает, что в поддерживаемых средах вы также можете использовать деструктуризацию ES2015 в выражении. Служит заменой &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; в 2.5.0+.</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">Используется для программного доступа к &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;слотам&lt;/a&gt; с заданной областью . Для каждого слота, в том числе слота по &lt;code&gt;default&lt;/code&gt; , объект содержит соответствующую функцию, возвращающую VNodes.</target>
        </trans-unit>
        <trans-unit id="76072ee6b19562b61739da43c75a8552a434c5d4" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/component-basics#content-distribution-with-slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/component-slots#named-slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;this.$slots.foo()&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">Используется для программного доступа к контенту, &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;распределенному по слотам&lt;/a&gt; . Каждый &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;именованный слот&lt;/a&gt; имеет собственное соответствующее свойство (например, содержимое &lt;code&gt;v-slot:foo&lt;/code&gt; будет найдено в &lt;code&gt;vm.$slots.foo&lt;/code&gt; ). Свойство по &lt;code&gt;default&lt;/code&gt; содержит либо узлы, не включенные в именованный слот, либо содержимое &lt;code&gt;v-slot:default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e6bf115dec713a7c40e6db8b7a9b940453656d5" translate="yes" xml:space="preserve">
          <source>User Agent Accessibility Guidelines (UAAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="88c450bf7dc4b899fc608077fc184ec1727d8b1a" translate="yes" xml:space="preserve">
          <source>Users can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2aa5abde13c9a2b4d796246137c973fbb88554" translate="yes" xml:space="preserve">
          <source>Users must be able to access the content as technologies advance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a271e1f44586e5083fc1918fdaffbb8a054342" translate="yes" xml:space="preserve">
          <source>Users must be able to perceive the information being presented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589f322b8166b58e4896f447ee126a460ba0bbe3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt; is similar to &lt;code&gt;aria-label&lt;/code&gt; expect it is used if the label text is visible on screen. It is paired to other elements by their &lt;code&gt;id&lt;/code&gt; and you can link multiple &lt;code&gt;id&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">Использование &lt;code&gt;$emit&lt;/code&gt; с дополнительными аргументами:</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">Использование &lt;code&gt;$emit&lt;/code&gt; только с именем события:</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">Также разрешено использование атрибутов &lt;code&gt;keyCode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08b4f74f4b29aefd57fecf9253958e21fc91a467" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; (discussed &lt;a href=&quot;#provide-inject&quot;&gt;below&lt;/a&gt;) should also be considered as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d71127137c4c4cd4e9d9a52e044f00ece5fd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; is especially useful when writing a plugin, as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86076651686c0fbe2de9bc0df0db687049714e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">Использование &lt;code&gt;v-bind.sync&lt;/code&gt; с литеральным объектом, например, в &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; , не будет работать, потому что существует слишком много крайних случаев, которые следует учитывать при синтаксическом анализе сложного выражения, подобного этому. .</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">Используя &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; , мы перебираем &lt;em&gt;только&lt;/em&gt; активных пользователей во время рендеринга, делая рендеринг намного более эффективным.</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">Совместное использование &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; &lt;strong&gt;не рекомендуется&lt;/strong&gt; . См. &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;Руководство&lt;/a&gt; по стилю для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e65c164b999421d82c5e3d232a414fe76b72cd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">Использование &lt;code&gt;v-model&lt;/code&gt; для компонентов</target>
        </trans-unit>
        <trans-unit id="61103105b06a8a12d7a44547eb3823dbfa7110a6" translate="yes" xml:space="preserve">
          <source>Using Inject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">Использование JavaScript выражений</target>
        </trans-unit>
        <trans-unit id="132307a32976d23c3e63eb2beb64895a6f3b8113" translate="yes" xml:space="preserve">
          <source>Using Provide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">Совместное использование переходов и анимации</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">Использование плагина</target>
        </trans-unit>
        <trans-unit id="9cf1549aea5e4ae2e67b0407f6b2344a0f1eb294" translate="yes" xml:space="preserve">
          <source>Using a watcher to compare values of an array or object that are reactive requires that it has a copy made of just the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">Использование введенного значения для ввода данных:</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">Использование впрыскиваемого значения по умолчанию для реквизита:</target>
        </trans-unit>
        <trans-unit id="cadb29867f8bf5340110eea6965faf58a3f6b48a" translate="yes" xml:space="preserve">
          <source>Using multiple teleports on the same target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e60545192243d051978512aa4ed96cc42d4d52" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; example from before, here is how it would look now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59268f2ba7d914bcab2c86e53d4606060ae7fc63" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our code can be updated as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc842072bfc033f9a866308b4dcf7050475c4957" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our provided values can be refactored as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e1a63d9acef5fd371c928b3e6b7280614408e1" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMarker&lt;/code&gt; component, we can refactor it with the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86942fa2e2d5d629468c3dd32e1a6910c8344b97" translate="yes" xml:space="preserve">
          <source>Using our date-picker component example from the &lt;a href=&quot;#attribute-inheritance&quot;&gt;previous section&lt;/a&gt;, in the event we need to apply all non-prop attributes to the &lt;code&gt;input&lt;/code&gt; element rather than the root &lt;code&gt;div&lt;/code&gt; element, this can be accomplished by using the &lt;code&gt;v-bind&lt;/code&gt; shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">Используя свойство &lt;code&gt;$listeners&lt;/code&gt; , вы можете перенаправить все прослушиватели событий в компоненте конкретному дочернему элементу с помощью &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; . Для таких элементов, как &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , с которыми вы также хотите работать с &lt;code&gt;v-model&lt;/code&gt; , часто бывает полезно создать новое вычисляемое свойство для слушателей, например &lt;code&gt;inputListeners&lt;/code&gt; ниже:</target>
        </trans-unit>
        <trans-unit id="a02a4af8d1e455a687fdc66fdceb59a54e15b8f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, which is responsible for rendering out the appropriate heading (i.e., &lt;code&gt;h1&lt;/code&gt;, &lt;code&gt;h2&lt;/code&gt;, &lt;code&gt;h3&lt;/code&gt;, etc.), this could have been written as a single-file component in 2.x as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">Используя &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Other-Examples&quot;&gt;здесь&lt;/a&gt; в качестве примера, вот эквивалентное использование с использованием &lt;code&gt;slot-scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">Используя атрибут &lt;code&gt;debounce&lt;/code&gt; , не было бы возможности обнаружить состояние &amp;laquo;Typing&amp;raquo;, потому что мы теряем доступ к состоянию ввода в реальном времени. Однако, отделив функцию debounce от Vue, мы можем устранить только ту операцию, которую хотим ограничить, снимая ограничения на функции, которые мы можем разработать:</target>
        </trans-unit>
        <trans-unit id="a87de46920f91d20c4a8374d7b0a5c7e603757dc" translate="yes" xml:space="preserve">
          <source>Using the example above, here is one example of how it could be implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3341dcb36ab8af8d89b35f44cc440d1a7d17430" translate="yes" xml:space="preserve">
          <source>Using the example above, there would only be one possible implementation of the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d5a2cbab66f55349694e4719943675255a69f1" translate="yes" xml:space="preserve">
          <source>Using the previously mentioned example of a &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, here is how it looks now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">Используя эту стратегию,мы даже могли бы использовать Pikaday с несколькими входными элементами,при этом каждый новый экземпляр будет автоматически очищаться после себя:</target>
        </trans-unit>
        <trans-unit id="420b1d24b2826ff84b27e5503c9d5fa275794cf8" translate="yes" xml:space="preserve">
          <source>Using with Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c2de355d1860ca4480d839a4fbef456709fc8" translate="yes" xml:space="preserve">
          <source>Using with Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1305a554f414402ea39d6c0eec337641f1f80daa" translate="yes" xml:space="preserve">
          <source>Using with Suspense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e76ca31176d1fccdd6bf8f9d90b0ddb005901f" translate="yes" xml:space="preserve">
          <source>Using with Vue components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceea66ab4211a7caa0a8bc0030f6869c29b5f77" translate="yes" xml:space="preserve">
          <source>Usually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">Однако обычно вам нужно, чтобы каждая опора имела определенный тип значения. В этих случаях вы можете указать реквизиты как объект, где имена и значения свойств содержат имена и типы свойств, соответственно:</target>
        </trans-unit>
        <trans-unit id="2c03a1928d0df3b20ddcf6357f95f4926b46174c" translate="yes" xml:space="preserve">
          <source>Usually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f363e5aa689f12e08f65b4262f0add9ceb5a0b70" translate="yes" xml:space="preserve">
          <source>Usually, when we need to pass data from the parent to child component, we use &lt;a href=&quot;component-props&quot;&gt;props&lt;/a&gt;. Imagine the structure where you have some deeply nested components and you only need something from the parent component in the deep nested child. In this case, you still need to pass the prop down the whole component chain which might be annoying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">интерфейс VNode</target>
        </trans-unit>
        <trans-unit id="d7fdca34045c394bdf9bbb0a0408e559b64e8a0a" translate="yes" xml:space="preserve">
          <source>VNode Props Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodes должны быть уникальными</target>
        </trans-unit>
        <trans-unit id="49ce46f211c09d9aa88ca4b4b3542fca5ed37ba1" translate="yes" xml:space="preserve">
          <source>VNodes now have a flat props structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084ea9ddae2c0ecd015b716116978e8325213232" translate="yes" xml:space="preserve">
          <source>Validate Emitted Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">Переплеты по стоимости</target>
        </trans-unit>
        <trans-unit id="942a2054dbdb4f692ee9d24cdf0ad9184052d0e9" translate="yes" xml:space="preserve">
          <source>Via CDN: &lt;code&gt;&amp;lt;script src=&quot;https://unpkg.com/vue@next&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32f685e7efba1be35060ac9fdaec19c6efdb60f" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">Видео от &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt; . Посмотрите бесплатный &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;курс&lt;/a&gt; Vue Mastery Intro to Vue .</target>
        </trans-unit>
        <trans-unit id="cab0d7e1c96c3ea19c16733af4fdea5420773df9" translate="yes" xml:space="preserve">
          <source>Virtual DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4ad933224c9c018075556e20e9443504c60df4" translate="yes" xml:space="preserve">
          <source>Visibility in headless mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">Посетители &lt;em&gt;в&lt;/em&gt; музее</target>
        </trans-unit>
        <trans-unit id="47e69e75f6b5116df912c06bde68d77a66e8ffd9" translate="yes" xml:space="preserve">
          <source>Vite</source>
          <target state="translated">Vite</target>
        </trans-unit>
        <trans-unit id="3dee610647aa7d97b936e215cc6e8fa092669039" translate="yes" xml:space="preserve">
          <source>VoiceOver (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df144818169dcae305b2c6ce5856caa779bc88c2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-component&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue (произносится как / vjuː /, как &lt;strong&gt;вид&lt;/strong&gt; ) - это &lt;strong&gt;прогрессивный фреймворк&lt;/strong&gt; для создания пользовательских интерфейсов. В отличие от других монолитных фреймворков, Vue разработан с нуля для постепенного внедрения. Основная библиотека ориентирована только на слой представления, и ее легко выбрать и интегрировать с другими библиотеками или существующими проектами. С другой стороны, Vue также отлично поддерживает сложные одностраничные приложения при использовании в сочетании с &lt;a href=&quot;guide/single-file-components&quot;&gt;современными инструментами&lt;/a&gt; и &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;вспомогательными библиотеками&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd79eece92c5ffe4c720051711e0f90d551d945b" translate="yes" xml:space="preserve">
          <source>Vue 2.x has a number of global APIs and configurations that globally mutate Vue&amp;rsquo;s behavior. For instance, to register a global component, you would use the &lt;code&gt;Vue.component&lt;/code&gt; API like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893d303c551ebb9fe5672e80454924e163f7fe29" translate="yes" xml:space="preserve">
          <source>Vue 3 now offers an &lt;code&gt;emits&lt;/code&gt; option, similar to the existing &lt;code&gt;props&lt;/code&gt; option. This option can be used to define the events that a component can emit to its parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7940d725dbd937d9de670c4768fc0ccd47788f" translate="yes" xml:space="preserve">
          <source>Vue CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="9b4162890a260c6325ca0e85fd029f15d2319406" translate="yes" xml:space="preserve">
          <source>Vue Docs Writing Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf53a6c36521f7bfb85181c1e488fc3bdefe2160" translate="yes" xml:space="preserve">
          <source>Vue Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1581d8a5ef292e49547c61633956998a288fd6aa" translate="yes" xml:space="preserve">
          <source>Vue Router 4.0 provides Vue 3 support and has a number of breaking changes of its own. Check out its &lt;a href=&quot;https://next.router.vuejs.org/guide/migration/&quot;&gt;migration guide (opens new window)&lt;/a&gt; for full details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e18b7a4f3086a13d2a0b9179ebded28163c885" translate="yes" xml:space="preserve">
          <source>Vue Test Utils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d1880504f36bb5a94fba498a0a0cfb67577f83" translate="yes" xml:space="preserve">
          <source>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d701148514b6b1195422aa314e247a9c6ce4ed" translate="yes" xml:space="preserve">
          <source>Vue Testing Library (@testing-library/vue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d00cb6f0b01ec3c037dd727f0b00f8ee2ebbd46" translate="yes" xml:space="preserve">
          <source>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue достигает этого, создавая &lt;strong&gt;виртуальную&lt;/strong&gt; модель &lt;strong&gt;DOM,&lt;/strong&gt; чтобы отслеживать изменения, которые необходимо внести в реальную модель DOM. Присмотревшись к этой строке:</target>
        </trans-unit>
        <trans-unit id="3c67c991de8300834c38a25c1ca2498be450c64f" translate="yes" xml:space="preserve">
          <source>Vue also exposes some built-in properties via the component instance, such as &lt;code&gt;$attrs&lt;/code&gt; and &lt;code&gt;$emit&lt;/code&gt;. These properties all have a &lt;code&gt;$&lt;/code&gt; prefix to avoid conflicting with user-defined property names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vue также предлагает &lt;code&gt;.passive&lt;/code&gt; модификатор, соответствующий &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &amp;laquo;s &lt;code&gt;passive&lt;/code&gt; вариант&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adf689defceb2bc071b35560777fed6fba514f1f" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;'s &lt;code&gt;passive&lt;/code&gt; option (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vue также предоставляет директиву &lt;code&gt;v-model&lt;/code&gt; , которая упрощает двустороннюю привязку между вводом формы и состоянием приложения:</target>
        </trans-unit>
        <trans-unit id="885b8f9999638cb0ba7b84d6b1e20f2e73c6af0f" translate="yes" xml:space="preserve">
          <source>Vue automatically binds the &lt;code&gt;this&lt;/code&gt; value for &lt;code&gt;methods&lt;/code&gt; so that it always refers to the component instance. This ensures that a method retains the correct &lt;code&gt;this&lt;/code&gt; value if it's used as an event listener or callback. You should avoid using arrow functions when defining &lt;code&gt;methods&lt;/code&gt;, as that prevents Vue from binding the appropriate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Вью может помочь.Поскольку SVG-это всего лишь данные,нам нужны только примеры того,как выглядят эти существа,когда они возбуждены,думают или встревожены.Тогда Vue может помочь в переходе между этими состояниями,делая ваши приветственные страницы,загрузку индикаторов и уведомления более эмоциональными.</target>
        </trans-unit>
        <trans-unit id="f789efe555358e086dec2286a04d16497d60bbf4" translate="yes" xml:space="preserve">
          <source>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the &lt;code&gt;data&lt;/code&gt; object in order for Vue to convert it and make it reactive. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76acf301d7c1d195a8e6c80016f7abf03185310" translate="yes" xml:space="preserve">
          <source>Vue cannot detect the following changes to an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Компоненты Vue предоставляют важные функции,которые недоступны в простых пользовательских элементах,в частности,межкомпонентный поток данных,пользовательская коммуникация по событиям и интеграция инструментов построения.</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vue &lt;strong&gt;не&lt;/strong&gt; поддерживает IE8 и ниже, потому что он использует функции ECMAScript 5, которые нельзя использовать в IE8. Однако он поддерживает все &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;браузеры, совместимые с ECMAScript 5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcde1702db5cf00f14ae819af084b9d5e13e847d" translate="yes" xml:space="preserve">
          <source>Vue does a runtime validation on props with a &lt;code&gt;type&lt;/code&gt; defined. To provide these types to TypeScript, we need to cast the constructor with &lt;code&gt;PropType&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vue не позволяет динамически добавлять новые реактивные свойства корневого уровня к уже созданному экземпляру. Однако можно добавить реактивные свойства к вложенному объекту с помощью &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; . Например, учитывая:</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vue не позволяет динамически добавлять новые реактивные свойства корневого уровня к уже созданному экземпляру. Однако можно добавить реактивные свойства к вложенному объекту с помощью &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="343af74f45c6d504ae330328dd8b0a9201ec2a40" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vue предоставляет более общий способ наблюдать и реагировать на изменения данных в экземпляре Vue: &lt;strong&gt;смотреть свойства&lt;/strong&gt; . Когда у вас есть данные, которые необходимо изменить на основе других данных, возникает соблазн злоупотреблять &lt;code&gt;watch&lt;/code&gt; особенно если вы работаете с AngularJS. Однако часто лучше использовать вычисляемое свойство, чем обязательный обратный вызов &lt;code&gt;watch&lt;/code&gt; . Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="c5264d84d3913aaee37aae0efaf21239b2f1ce3b" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a current active instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vue совершенно не страдает от этого, потому что он использует прозрачную систему наблюдения за зависимостями с асинхронной постановкой в ​​очередь - все изменения запускаются независимо, если у них нет явных отношений зависимости.</target>
        </trans-unit>
        <trans-unit id="3b2be91f79d826fa58f7ebe4ed4e0d032247230c" translate="yes" xml:space="preserve">
          <source>Vue doesn't include built-in support for debouncing or throttling but it can be implemented using libraries such as &lt;a href=&quot;https://lodash.com/&quot;&gt;Lodash (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vue использует классические веб-технологии и опирается на них. Чтобы показать вам, что это означает, мы рассмотрим несколько примеров.</target>
        </trans-unit>
        <trans-unit id="a951ea402d433567bd65b048725a50d77f19283f" translate="yes" xml:space="preserve">
          <source>Vue encourages us to build our UIs by encapsulating UI and related behavior into components. We can nest them inside one another to build a tree that makes up an application UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue имеет более четкое разделение между директивами и компонентами.Директивы предназначены только для инкапсуляции манипуляций DOM,в то время как компоненты являются автономными единицами,которые имеют свою собственную логику представления и данных.В AngularJS директивы делают все,а компоненты являются лишь специфическим видом директив.</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vue уже распространился по всему миру, и даже основная команда работает как минимум в полдюжине часовых поясов. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;Форум&lt;/a&gt; включает 7 языков и их количество растет, и многие из наших документов &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;активно поддерживают переводы&lt;/a&gt; . Мы очень гордимся международным охватом Vue, но мы можем добиться большего.</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vue имеет лучшую производительность и его намного проще оптимизировать, поскольку он не использует грязную проверку. AngularJS становится медленным, когда есть много наблюдателей, потому что каждый раз, когда что-либо в области видимости изменяется, все эти наблюдатели должны быть повторно оценены. Кроме того, цикл дайджеста может выполняться несколько раз для &amp;laquo;стабилизации&amp;raquo;, если какой-либо наблюдатель запускает другое обновление. Пользователям AngularJS часто приходится прибегать к эзотерическим методам, чтобы обойти цикл дайджеста, а в некоторых ситуациях нет возможности оптимизировать область действия с большим количеством наблюдателей.</target>
        </trans-unit>
        <trans-unit id="2605f10b94203eb3d7c6121d24fd706b16d41799" translate="yes" xml:space="preserve">
          <source>Vue has spread across the globe, with the core team being in at least half a dozen different timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum (opens new window)&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;q=vuejs.org&quot;&gt;actively-maintained translations (opens new window)&lt;/a&gt;. We're very proud of Vue's international reach, but we can do even better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c550aa4342c74e83ae493691c6ae0befcbbd2d7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft (opens new window)&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue реализует API распространения контента, вдохновленный &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;черновиком спецификации веб-компонентов&lt;/a&gt; , используя элемент &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; в качестве точек распространения контента.</target>
        </trans-unit>
        <trans-unit id="3a793e8d661b43bbe34ed4b73bb734bc567f99e0" translate="yes" xml:space="preserve">
          <source>Vue internally tracks all objects that have been made reactive, so it always returns the same proxy for the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vue также доступен на &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; и &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs требует некоторого времени для синхронизации, поэтому последняя версия может быть недоступна).</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue гораздо менее категорична,чем Angular,предлагая официальную поддержку различных сборочных систем,без ограничений на то,как вы структурируете ваше приложение.Многие разработчики пользуются этой свободой,в то время как некоторые предпочитают иметь только один правильный способ сборки любого приложения.</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vue намного проще,чем AngularJS,как с точки зрения API,так и дизайна.Обучение,достаточное для сборки нетривиальных приложений,обычно занимает меньше дня,что не верно для AngularJS.</target>
        </trans-unit>
        <trans-unit id="cffec81f79bb5fd465edfb05ca6c6a20e73cd65d" translate="yes" xml:space="preserve">
          <source>Vue keeps the page updated by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vue необходимо подключить прослушиватели событий, чтобы знать, когда переход закончился. Это может быть &lt;code&gt;transitionend&lt;/code&gt; или завершение &lt;code&gt;animationend&lt;/code&gt; , в зависимости от типа применяемых правил CSS. Если вы используете только один или другой, Vue может автоматически определить правильный тип.</target>
        </trans-unit>
        <trans-unit id="365212719322a63f4e306455d5f27b8a3966dc5d" translate="yes" xml:space="preserve">
          <source>Vue offers some abstractions that can help work with transitions and animations, particularly in response to something changing. Some of these abstractions include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abff090748f024b1aa003637a4b72dd4dc06e5f" translate="yes" xml:space="preserve">
          <source>Vue projects can quickly be set up with Vite by running the following commands in your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vue предоставляет компонент-оболочку &lt;code&gt;transition&lt;/code&gt; , позволяющий добавлять переходы входа / выхода для любого элемента или компонента в следующих контекстах:</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue предоставляет различные способы применения эффектов перехода при вставке,обновлении или удалении элементов с флэш-накопителя.Сюда входят инструменты для:</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue предоставляет псевдонимы для наиболее часто используемых ключевых кодов,когда это необходимо для поддержки устаревшего браузера:</target>
        </trans-unit>
        <trans-unit id="c90e634ab0c74f1d079a1c75ea53bce697797633" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a311fa8fbae830ba1eadba1b420d03469cdf2806" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI (opens new window)&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs (opens new window)&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vue предоставляет &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;официальный интерфейс командной строки&lt;/a&gt; для быстрого создания амбициозных одностраничных приложений. Он предоставляет настройки сборки с батарейками для современного рабочего процесса. Подготовка к работе со сборками с горячей перезагрузкой, сохранением с сохранением и готовыми к работе сборками занимает всего несколько минут. Дополнительную информацию см. &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;В документации Vue CLI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="198884e2076bf367c22dbd13bc52339d681396a7" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;code&gt;InjectionKey&lt;/code&gt; interface which is a generic type that extends &lt;code&gt;Symbol&lt;/code&gt;. It can be used to sync the type of the injected value between the provider and the consumer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue обеспечивает ненавязчивую реактивность на простые объекты JavaScript и полностью автоматические вычисляемые свойства.В Ember необходимо обернуть все в Ember Objects и вручную объявить зависимости для вычисляемых свойств.</target>
        </trans-unit>
        <trans-unit id="5a53f20609320f4a24cb94f7b4da549347f4bbbd" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the &lt;strong&gt;render function&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vue рекомендует использовать шаблоны для создания вашего HTML в подавляющем большинстве случаев. Однако бывают ситуации, когда вам действительно нужна вся программная мощь JavaScript. Здесь вы можете использовать &lt;strong&gt;функцию рендеринга&lt;/strong&gt; , более близкую к компилятору альтернативу шаблонам.</target>
        </trans-unit>
        <trans-unit id="8156b77f1cb02753b763c4feb44d817ea36bfdc0" translate="yes" xml:space="preserve">
          <source>Vue should not be bundled into the library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue старается рендерить элементы максимально эффективно,часто используя их повторно вместо рендеринга с нуля.Помимо того,что Vue помогает сделать рендеринг очень быстрым,это может иметь некоторые полезные преимущества.Например,если вы позволяете пользователям переключаться между несколькими типами входа:</target>
        </trans-unit>
        <trans-unit id="1bfea290ac9ffe33c850d1b0a939949cd7dfe376" translate="yes" xml:space="preserve">
          <source>Vue uses a &lt;code&gt;$&lt;/code&gt; prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix &lt;code&gt;_&lt;/code&gt; for internal properties. You should avoid using names for top-level &lt;code&gt;data&lt;/code&gt; properties that start with either of these characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vue использует префикс &lt;code&gt;_&lt;/code&gt; для определения своих собственных частных свойств, поэтому использование того же префикса (например, &lt;code&gt;_update&lt;/code&gt; ) может привести к перезаписи свойства экземпляра. Даже если вы проверяете, а Vue в настоящее время не использует конкретное имя свойства, нет гарантии, что конфликт не возникнет в более поздней версии.</target>
        </trans-unit>
        <trans-unit id="85dd560a9154cd8cc040ca30f4c194c517655b32" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue автоматически пронюхает,применяются ли к целевому элементу CSS-переходы или анимации.Если это так,то классы CSS-переходов будут добавлены/удалены в соответствующие тайминги.</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue обертывает методы мутации наблюдаемого массива, поэтому они также будут запускать обновления представления. Обернутые методы:</target>
        </trans-unit>
        <trans-unit id="052994ca379981542bf778170c739a04a769c1d8" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Сообщество Vue растет невероятно быстро, и если вы читаете это, есть хороший шанс, что вы готовы к нему присоединиться. Итак&amp;hellip; добро пожаловать!</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Синтаксис шаблона Vue использует всю мощь выражений JavaScript, в то время как синтаксис выражений Handlebars и вспомогательный синтаксис намеренно сильно ограничены в сравнении.</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Система перехода Vue сильно изменилась и теперь использует элементы оболочки &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; , а не атрибут &lt;code&gt;transition&lt;/code&gt; . Чтобы узнать больше , рекомендуется прочитать новое &lt;a href=&quot;transitions&quot;&gt;руководство&lt;/a&gt; по переходам .</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Система переходов Vue предлагает множество простых способов анимировать вход, выход и списки, но как насчет анимации самих данных? Например:</target>
        </trans-unit>
        <trans-unit id="b31ca06d3a5f393764ec4e9c8ef653d752ddc802" translate="yes" xml:space="preserve">
          <source>Vue's reactivity system buffers invalidated effects and flushes them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same &quot;tick&quot;. Internally, a component's &lt;code&gt;update&lt;/code&gt; function is also a watched effect. When a user effect is queued, it is by default invoked &lt;strong&gt;before&lt;/strong&gt; all component &lt;code&gt;update&lt;/code&gt; effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a97b271690906d44d32706aa7062d75c719e21d" translate="yes" xml:space="preserve">
          <source>Vue's transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49720efe6c6aa6c85c1ae9a211e82f72036b89c2" translate="yes" xml:space="preserve">
          <source>Vue's usage of the &lt;code&gt;is&lt;/code&gt; special prop was simulating what the native attribute does before it was made universally available in browsers. However, in 2.x it was interpreted as rendering a Vue component with the name &lt;code&gt;plastic-button&lt;/code&gt;. This blocks the native usage of Customized Built-in Element mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile(template )</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="b7ea66a12347f6ffc2b94442e80c35d15d597413" translate="yes" xml:space="preserve">
          <source>Vue.component</source>
          <target state="translated">Vue.component</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component(id,[определение])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="fa7c2ad2da40c783fe07fb4836f3bda4a2b8cf11" translate="yes" xml:space="preserve">
          <source>Vue.config</source>
          <target state="translated">Vue.config</target>
        </trans-unit>
        <trans-unit id="fbf8d19b7eb0ae647266f2c96abf99945277ea9e" translate="yes" xml:space="preserve">
          <source>Vue.config.ignoredElements</source>
          <target state="translated">Vue.config.ignoredElements</target>
        </trans-unit>
        <trans-unit id="5b4f8634a75bc7bfd88be1dd891c9ea29cfa97f5" translate="yes" xml:space="preserve">
          <source>Vue.config.productionTip</source>
          <target state="translated">Vue.config.productionTip</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete(target,propertyName/index )</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="580b85815fc398d542e95ec7b5e861e1e012763f" translate="yes" xml:space="preserve">
          <source>Vue.directive</source>
          <target state="translated">Vue.directive</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive(id,[definition])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extension(options )</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter(id,[определение])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.js позволяет определять фильтры, которые можно использовать для применения общего форматирования текста. Фильтры можно использовать в двух местах: &lt;strong&gt;интерполяция усов и выражения &lt;code&gt;v-bind&lt;/code&gt; &lt;/strong&gt; (последнее поддерживается в 2.1.0+). Фильтры должны быть добавлены в конец выражения JavaScript, обозначенного символом &amp;laquo;вертикальная черта&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="9050802f5567e26ffa96732c93096ee9dcffa91f" translate="yes" xml:space="preserve">
          <source>Vue.js is built by design to be incrementally adoptable. This means that it can be integrated into a project multiple ways depending on the requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js использует синтаксис шаблона на основе HTML, который позволяет вам декларативно привязать визуализированную DOM к данным базового экземпляра Vue. Все шаблоны Vue.js представляют собой допустимый HTML-код, который может анализироваться браузерами, соответствующими спецификациям, и анализаторами HTML.</target>
        </trans-unit>
        <trans-unit id="89a8a92dc46a36b0e2b8305728a1f8aaf8a88b78" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42311314f611dc7df4fd1777e98448bb4c96ecdb" translate="yes" xml:space="preserve">
          <source>Vue.mixin</source>
          <target state="translated">Vue.mixin</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin(mixin )</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick([обратный вызов,контекст])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable(object )</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="7ea3574e637178c673386a1b01019ea3760cf139" translate="yes" xml:space="preserve">
          <source>Vue.prototype</source>
          <target state="translated">Vue.prototype</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set(target,propertyName/index,value )</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="5a623310c41e9f9c01feb186a71709087e21e7da" translate="yes" xml:space="preserve">
          <source>Vue.use</source>
          <target state="translated">Vue.use</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">View.use(plugin )</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="58df3887d367d6a05cae0279723a97a86100bfeb" translate="yes" xml:space="preserve">
          <source>VuePress provides a custom container plugin to create alert boxes. There are four types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fde70f98c4cbf6a7b48ee19696e129152a7fb55" translate="yes" xml:space="preserve">
          <source>VuePress uses Prism to provide language syntax highlighting by appending the language to the beginning backticks of a code block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Выпущен Vuex 2.0, но в этом руководстве рассматривается только переход на 1.0? Это опечатка? Кроме того, похоже, что Vuex 1.0 и 2.0 были выпущены одновременно. В чем дело? Что мне следует использовать и что совместимо с Vue 2.0?</target>
        </trans-unit>
        <trans-unit id="c8b618e05a2594cc2596f0d284d48d16432c525a" translate="yes" xml:space="preserve">
          <source>Vuex 4.0 provides Vue 3 support with largely the same API as 3.x. The only breaking change is &lt;a href=&quot;https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html#breaking-changes&quot;&gt;how the plugin is installed (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd40be6d96cb39a60cc6c39b8ea11e9937c18f8" translate="yes" xml:space="preserve">
          <source>Vuex is the &lt;a href=&quot;../guide/state-management#official-flux-like-implementation&quot;&gt;official flux-like implementation&lt;/a&gt; for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full &lt;a href=&quot;../guide/installation#vue-devtools&quot;&gt;Vue DevTools&lt;/a&gt; support).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d11819e7a1d9589b690ec06234450093f24c627" translate="yes" xml:space="preserve">
          <source>W3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066e0172350e0754c39de0933398067fbaebdf66" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices 1.2 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45649ea79803ea52f28827ee4e547e4085b9b0c5" translate="yes" xml:space="preserve">
          <source>WAVE (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43059526c7805cadcc812c12f2c0f217edb0caf4" translate="yes" xml:space="preserve">
          <source>WCAG 2.0 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7254fa8467e45dc2111643677937dc826c7381" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bd5df2f8313fd0f66a6834ec679fec70aa231e" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Посмотрите бесплатный урок на Vue School</target>
        </trans-unit>
        <trans-unit id="62e0a695e7ccab369a0f49419284d104f98c2575" translate="yes" xml:space="preserve">
          <source>Watch a free video about Lifecycle Hooks on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e7187cdc04cab3317a2d6229024de7b88422b" translate="yes" xml:space="preserve">
          <source>Watch a free video about the Composition API on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Посмотрите бесплатный видеокурс Vue Mastery.</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Посмотрите бесплатный видеокурс на Vue School</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Посмотрите бесплатный видеоурок на Vue School</target>
        </trans-unit>
        <trans-unit id="0b642e69ff5dd94afbc4e677ac7245afd2b75050" translate="yes" xml:space="preserve">
          <source>Watch a free video on Reactivity in Depth on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2a20165ccd85b019b022c5d12f356aa7e7ddb2" translate="yes" xml:space="preserve">
          <source>Watch a free video on how to define custom events on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ef5fd200efa5ea9f0c8791591c28f563aa2607" translate="yes" xml:space="preserve">
          <source>Watch a free video on setup on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a603438f7073cd71b9f2b8f7c700ac8737ed9345" translate="yes" xml:space="preserve">
          <source>Watch a reactive property or a computed function on the component instance for changes. The callback gets called with the new value and the old value for the given property. We can only pass top-level &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, or &lt;code&gt;computed&lt;/code&gt; property name as a string. For more complex expressions or nested properties, use a function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Посмотрите видео объяснение на Vue Mastery</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Следите за выражением или вычисленной функцией на экземпляре Vue за изменениями.Обратный вызов вызывается с новым значением и старым значением.Выражение принимает только разделенные точками пути.Для более сложных выражений используйте функцию.</target>
        </trans-unit>
        <trans-unit id="aa35ca415d20b9f4a53f5d20f60b4e2506e17dc4" translate="yes" xml:space="preserve">
          <source>Watch on Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a37889e8f85fb3cc8ac5b854d904e40ddf13894" translate="yes" xml:space="preserve">
          <source>Watcher Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">Наблюдатели позволяют нам анимировать изменения любого числового свойства в другое свойство. Абстрактно это может показаться сложным, поэтому давайте рассмотрим пример с использованием &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e3b9441a3e5ab81aea2316854b5cd4f81568ab3" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let's dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">Наблюдатели, созданные с помощью &lt;code&gt;vm.$watch&lt;/code&gt; , теперь запускаются перед повторной визуализацией связанного компонента. Это дает вам возможность дополнительно обновить состояние перед повторной визуализацией компонента, что позволяет избежать ненужных обновлений. Например, вы можете наблюдать за опорой компонента и обновлять собственные данные компонента при изменении опоры.</target>
        </trans-unit>
        <trans-unit id="9c56f7248c60849f85774dec247f8195050af1aa" translate="yes" xml:space="preserve">
          <source>Watching Multiple Sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059a180684023e522c315cea524c6d4c3c650aaf" translate="yes" xml:space="preserve">
          <source>Watching Reactive Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8debcbf1f849cc32580625667ebbdeef8f8eeb6a" translate="yes" xml:space="preserve">
          <source>Watching Template Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bace31b55ee998845b6d5b8e3891e59a6675d64c" translate="yes" xml:space="preserve">
          <source>Watching a Single Source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d17151eadf5c934a94706826860753d855216f0" translate="yes" xml:space="preserve">
          <source>Watching a template ref for changes can be an alternative to the use of lifecycle hooks that was demonstrated in the previous examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">Мы также очень стараемся избегать предвзятости. Очевидно, что нам, как основной команде, очень нравится Vue. Есть некоторые проблемы, которые, по нашему мнению, он решает лучше, чем что-либо еще. Если бы мы в это не верили, мы бы не работали над этим. Однако мы хотим быть честными и точными. Там, где другие библиотеки предлагают значительные преимущества, такие как обширная экосистема альтернативных средств визуализации React или поддержка браузеров Knockout вплоть до IE6, мы также стараемся перечислить их.</target>
        </trans-unit>
        <trans-unit id="145d670173003080c2dd95e109d6624af3091f7c" translate="yes" xml:space="preserve">
          <source>We appreciate small, focused PRs. If you'd like to make an extremely large change, please communicate with team members prior to a pull request. Here's a &lt;a href=&quot;https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/&quot;&gt;writeup that details why this is so critical (opens new window)&lt;/a&gt; for us to work well on this team. Please understand that though we always appreciate contributions, ultimately we have to prioritize what works best for the project as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ddf11e5b6912a4511915ec63b40d6843a024e4" translate="yes" xml:space="preserve">
          <source>We are registering the invalidation callback via a passed-in function instead of returning it from the callback because the return value is important for async error handling. It is very common for the effect function to be an async function when performing data fetching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf15350412bdd57a1ba478919853106222c77d2" translate="yes" xml:space="preserve">
          <source>We are still working on a dedicated Migration Build of Vue 3 with Vue 2 compatible behavior and runtime warnings of incompatible usage. If you are planning to migrate a non-trivial Vue 2 app, we strongly recommend waiting for the Migration Build for a smoother experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b413666b6609e2e923f9dac7f2dbb73deb11598" translate="yes" xml:space="preserve">
          <source>We are working on a new version of the Devtools with a new UI and refactored internals to support multiple Vue versions. The new version is currently in beta and only supports Vue 3 (for now). Vuex and Router integration is also work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4590c53baf3d1bcb7b3f91125ba505380d0c3454" translate="yes" xml:space="preserve">
          <source>We can access slot contents as arrays of VNodes from &lt;a href=&quot;../api/instance-properties#slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19325bef373c7011977b1dc1240632398096e83b" translate="yes" xml:space="preserve">
          <source>We can annotate a payload for the emitted event. Also, all non-declared emitted events will throw a type error when called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded0fe3886c210ed1f69601603a576fff08f9afa" translate="yes" xml:space="preserve">
          <source>We can check resources like &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS-Triggers (opens new window)&lt;/a&gt; to see which properties will trigger repaints if we animate them. Here, if you look under &lt;code&gt;transform&lt;/code&gt;, you will see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">Мы можем объединить эту технику с нашей предыдущей реализацией,чтобы оживить все возможные изменения в нашем списке!</target>
        </trans-unit>
        <trans-unit id="cd1d61172e00dd1e1c488b575a87db8e2cda970e" translate="yes" xml:space="preserve">
          <source>We can create extremely smooth animations on the web by being aware of performance. We want to hardware accelerate elements when we can, and use properties that don't trigger repaints. Let's go over some of how we can accomplish this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b738e997b0df8d616d9cdb2cc5977352977ba792" translate="yes" xml:space="preserve">
          <source>We can do this because the search button will help visual users identify the purpose of the input field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ccaba9c04ab4407d0e1982d8ccf1d0a6b7d5a" translate="yes" xml:space="preserve">
          <source>We can list emitted events in the component's &lt;code&gt;emits&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;v-model&lt;/code&gt; непосредственно в наших пользовательских входных данных, что не только более согласовано с обычными входами, но также означает, что наш компонент совместим с Vuex.</target>
        </trans-unit>
        <trans-unit id="8e665af7b29d480225aa1952784d4bbf8b4eb21b" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">Мы можем передать массив в &lt;code&gt;v-bind:class&lt;/code&gt; , чтобы применить список классов:</target>
        </trans-unit>
        <trans-unit id="406b9892cf3e59eeb19dc1064b0235c19adccc7c" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;:class&lt;/code&gt; (short for &lt;code&gt;v-bind:class&lt;/code&gt;) to dynamically toggle classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">Мы можем передать объект в &lt;code&gt;v-bind:class&lt;/code&gt; для динамического переключения классов:</target>
        </trans-unit>
        <trans-unit id="977e7623c17ea7ebe75cd4f565824983dde786be" translate="yes" xml:space="preserve">
          <source>We can see from the table above, current implementation coerces &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;'true'&lt;/code&gt; but removes the attribute if it's &lt;code&gt;false&lt;/code&gt;. This also led to inconsistency and required users to manually coerce boolean values to string in very common use cases like &lt;code&gt;aria-*&lt;/code&gt; attributes like &lt;code&gt;aria-selected&lt;/code&gt;, &lt;code&gt;aria-hidden&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4415051c820f469ebda2e174386196145ce7433" translate="yes" xml:space="preserve">
          <source>We can use &lt;a href=&quot;component-provide-inject&quot;&gt;provide / inject&lt;/a&gt; with the Composition API as well. Both can only be called during &lt;a href=&quot;composition-api-setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; with a current active instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df72788c45d87bd5e47825b2ad8e91055d4e9ce1" translate="yes" xml:space="preserve">
          <source>We can use CSS to visually hide elements but keep them available for assistive technology:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">Мы можем использовать директиву &lt;code&gt;v-for&lt;/code&gt; для отображения списка элементов на основе массива. &lt;code&gt;v-for&lt;/code&gt; директивы требует специального синтаксиса в виде &lt;code&gt;item in items&lt;/code&gt; , где &lt;code&gt;items&lt;/code&gt; является массивом источника данных и &lt;code&gt;item&lt;/code&gt; является &lt;strong&gt;псевдонимом&lt;/strong&gt; для элемента массива итерируемого на:</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">Мы можем использовать директиву &lt;code&gt;v-on&lt;/code&gt; для прослушивания событий DOM и запуска некоторого JavaScript, когда они запускаются.</target>
        </trans-unit>
        <trans-unit id="99b3e0b88025a1cd9dd1aa491f0dd2bc179180f4" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive, which we typically shorten to the &lt;code&gt;@&lt;/code&gt; symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be &lt;code&gt;v-on:click=&quot;methodName&quot;&lt;/code&gt; or with the shortcut, &lt;code&gt;@click=&quot;methodName&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b6da1cf882bfbaa28b18476abab8f6ff6b7b6e" translate="yes" xml:space="preserve">
          <source>We can use this to coordinate more expressive movement, such as a folding card, as demonstrated below. It's actually two elements transitioning between each other, but since the beginning and end states are scaling the same: horizontally to 0, it appears like one fluid movement. This type of sleight-of-hand can be very useful for realistic UI microinteractions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817f50bdc2a016379b436c13b4b442890443585f" translate="yes" xml:space="preserve">
          <source>We could do the same for other &lt;strong&gt;logical concerns&lt;/strong&gt; but you might be already asking the question &amp;ndash; &lt;em&gt;Isn&amp;rsquo;t this just moving the code to the &lt;code&gt;setup&lt;/code&gt; option and making it extremely big?&lt;/em&gt; Well, that&amp;rsquo;s true. That&amp;rsquo;s why before moving on with the other responsibilities, we will first extract the above code into a standalone &lt;strong&gt;composition function&lt;/strong&gt;. Let's start with creating &lt;code&gt;useUserRepositories&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">Мы могли бы управлять коммуникацией между компонентами с помощью этого единого центра событий:</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">Мы обсудим &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;переход между компонентами&lt;/a&gt; позже, но вы также можете переходить между необработанными элементами, используя &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; . Один из наиболее распространенных двухэлементных переходов - между контейнером списка и сообщением, описывающим пустой список:</target>
        </trans-unit>
        <trans-unit id="e2e7b18ff8837f7d2c779646a84e95769cc3303b" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#transitioning-between-components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">Мы получаем аналогичные преимущества от обновления:</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">Мы получаем следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">У нас есть отдельная секция для нового Angular,потому что это действительно совершенно другой каркас по сравнению с AngularJS.Например,он имеет первоклассную компонентную систему,многие детали реализации были полностью переписаны,и API также сильно изменился.</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">Мы уже создали наше самое первое приложение Vue! Это выглядит очень похоже на рендеринг строкового шаблона, но Vue проделал большую внутреннюю работу. Теперь данные и DOM связаны, и теперь все является &lt;strong&gt;реактивным&lt;/strong&gt; . Откуда нам знать? Откройте консоль JavaScript вашего браузера (прямо сейчас на этой странице) и установите для &lt;code&gt;app.message&lt;/code&gt; другое значение. Вы должны увидеть обновленный обновленный пример выше.</target>
        </trans-unit>
        <trans-unit id="a3de3e0ebfec380551325c5d2024c30336332771" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Take a look at the example below where &lt;code&gt;counter&lt;/code&gt; property increments every second and you will see how rendered DOM changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9882cb189eb18be1f8b18353e20480e68691217f" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">Мы создали отдельное руководство по созданию приложений Vue, отрисовываемых на сервере. Это очень подробное руководство для тех, кто уже знаком с разработкой Vue на стороне клиента, разработкой на стороне сервера Node.js и веб-пакетами. Проверьте это на &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2d326202574eaf0a4b0a6f118cf078e50093fa" translate="yes" xml:space="preserve">
          <source>We have moved several pieces of our first logical concern into the &lt;code&gt;setup&lt;/code&gt; method, nicely put close to each other. What&amp;rsquo;s left is calling &lt;code&gt;getUserRepositories&lt;/code&gt; in the &lt;code&gt;mounted&lt;/code&gt; hook and setting up a watcher to do that whenever the &lt;code&gt;user&lt;/code&gt; prop changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f49be9e4b4a0bd2cc13f3ef887bdbb56e8ea881" translate="yes" xml:space="preserve">
          <source>We have some dedicated styles to denote something that's worth highlighting in a particular way. These are captured &lt;a href=&quot;../doc-style-guide#alerts&quot;&gt;on this page (opens new window)&lt;/a&gt;. &lt;strong&gt;They are to be used sparingly.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2365bbdeaabeff7b76c97dd6062eceb546eae44b" translate="yes" xml:space="preserve">
          <source>We have to provide a proper prop name for the event handler, e.g., to handle &lt;code&gt;click&lt;/code&gt; events, the prop name would be &lt;code&gt;onClick&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b667182eef0a9564fcc136526a19be6641183fb" translate="yes" xml:space="preserve">
          <source>We intend to drop this internal concept of &quot;enumerated attributes&quot; and treat them as normal non-boolean HTML attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3eea1c16de0a8e9cf42e189bd675df96a77366" translate="yes" xml:space="preserve">
          <source>We make a copy of the DOM in JavaScript called the Virtual DOM, we do this because touching the DOM with JavaScript is computationally expensive. While performing updates in JavaScript is cheap, finding the required DOM nodes and updating them with JavaScript is expensive. So we batch calls, and change the DOM all at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a6f46a302366b1b4d268e8a2baf4204e756c65" translate="yes" xml:space="preserve">
          <source>We mentioned before that in order to have an API that updates a final value when something changes, we&amp;rsquo;re going to have to set new values when something changes. We do this in the handler, in a function called &lt;code&gt;track&lt;/code&gt;, where we pass in the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd40e61c317c21b5589b1855722a4f76630a6a7" translate="yes" xml:space="preserve">
          <source>We might want the text &quot;Submit&quot; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &quot;Submit&quot; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">Нам может потребоваться, чтобы текст &amp;laquo;Отправить&amp;raquo; большую часть времени отображался внутри &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; . Чтобы &amp;laquo;отправить&amp;raquo; резервный контент, мы можем поместить его между тегами &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ea4d2b2947c843536ed2a98837450506cc32476" translate="yes" xml:space="preserve">
          <source>We might want to replace the &lt;code&gt;{{ item }}&lt;/code&gt; with a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; to customize it on parent component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">Мы могли бы захотеть заменить этот резервный контент, чтобы отображать имя пользователя вместо последнего, например:</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">Мы могли бы захотеть повторно использовать этот компонент, позволяя пользователям вести несколько списков (например, для покупок, списков желаний, повседневных дел и т. Д.). Но есть проблема. Поскольку каждый экземпляр компонента ссылается на один и тот же объект данных, изменение заголовка одного списка также изменит заголовок каждого другого списка. То же самое верно для добавления / редактирования / удаления задачи.</target>
        </trans-unit>
        <trans-unit id="d78b76b13dec2d9479f1cfb4f190e2eb6e217389" translate="yes" xml:space="preserve">
          <source>We recommend replacing any complex expressions with a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt;, one of the most fundamental pieces of Vue, which we'll cover shortly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b734f82d47813efa3a6806ce727611d03115657d" translate="yes" xml:space="preserve">
          <source>We recommend:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9d55967630e0ffef70ef9b3f460a567135d1e5" translate="yes" xml:space="preserve">
          <source>We removed &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt; methods from the instance completely. &lt;code&gt;$emit&lt;/code&gt; is still a part of the existing API as it's used to trigger event handlers declaratively attached by a parent component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">Мы окружаем аргументы круглыми скобками и делим аргументы запятыми:</target>
        </trans-unit>
        <trans-unit id="3f6388f12bd97827e87f720eb7e6528b0cdd918b" translate="yes" xml:space="preserve">
          <source>We use it like this: &lt;code&gt;new Proxy(target, handler)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866e301e87de4875c510e32c3de7ad212732a107" translate="yes" xml:space="preserve">
          <source>We want to make a function to translate keys available to the whole application, so we will expose it using &lt;code&gt;app.config.globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bb8d549018405cd3717be9cfc0482cf533a00b" translate="yes" xml:space="preserve">
          <source>We will assume that our users will pass in an object containing the translated keys in the &lt;code&gt;options&lt;/code&gt; parameter when they use the plugin. Our &lt;code&gt;$translate&lt;/code&gt; function will take a string such as &lt;code&gt;greetings.hello&lt;/code&gt;, look inside the user provided configuration and return the translated value - in this case, &lt;code&gt;Bonjour!&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2d79d26a57c657532cfa93323b5aa7856a950f" translate="yes" xml:space="preserve">
          <source>We will cover all of these and more in the next three sections in this Guide. However, aside from these useful API offerings, it's worth mentioning that the class and style declarations we covered earlier can be used to apply animations and transitions as well, for more simple use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0330d8076787db736d1163a550844572651d3ec8" translate="yes" xml:space="preserve">
          <source>We will need to install Rollup and a few dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9990a125d88c5ba238d041e04854bb4b051a20bc" translate="yes" xml:space="preserve">
          <source>We will start with the lifecycle hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bee3c68a3f59f9dbc34ec660b948ec6a34b4f2" translate="yes" xml:space="preserve">
          <source>We will start with the most obvious parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34746e60611d8ce199ba5e1744dcd31fcb6189c0" translate="yes" xml:space="preserve">
          <source>We will use the &lt;code&gt;i18nPlugin&lt;/code&gt; we created in the &lt;a href=&quot;#writing-a-plugin&quot;&gt;Writing a Plugin&lt;/a&gt; section for demo purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">Мы также хотели бы, чтобы &lt;strong&gt;вы&lt;/strong&gt; помогали поддерживать этот документ в актуальном состоянии, потому что мир JavaScript быстро развивается! Если вы заметили неточность или что-то, что вам кажется не совсем правильным, сообщите нам об этом, &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;открыв вопрос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">Мы рассмотрим VNodes более подробно &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;позже&lt;/a&gt; , когда будем обсуждать &lt;a href=&quot;render-function&quot;&gt;функции рендеринга&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">В следующем разделе мы рассмотрим аргументы, передаваемые в эти хуки (например, &lt;code&gt;el&lt;/code&gt; , &lt;code&gt;binding&lt;/code&gt; , &lt;code&gt;vnode&lt;/code&gt; и &lt;code&gt;oldVnode&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">Подробнее о &lt;a href=&quot;components&quot;&gt;компонентной системе&lt;/a&gt; мы поговорим позже. На данный момент просто знайте, что все компоненты Vue также являются экземплярами Vue и поэтому принимают один и тот же объект параметров (за исключением нескольких параметров, связанных с корнем).</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">Мы просто следуем соглашениям каждого языка. В JavaScript camelCase более естественен. В HTML kebab-case есть.</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">Однако мы все еще ограничены фильтрами и Vue 1.0 в целом, поэтому давайте завершим обновление до Vue 2.0:</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Мы кратко представили самые основные функции ядра Vue.js - остальная часть этого руководства будет охватывать их и другие расширенные функции с гораздо более мелкими деталями, поэтому обязательно прочтите все это!</target>
        </trans-unit>
        <trans-unit id="eb8b82ed49a41a1aeaad51c988296a83c46302ad" translate="yes" xml:space="preserve">
          <source>We'll be using GreenSock in some of the examples in the sections following. They have a great &lt;a href=&quot;https://greensock.com/ease-visualizer&quot;&gt;ease visualizer (opens new window)&lt;/a&gt; that will help you build nicely crafted eases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abdbdf8ec29be45ff4f5a54f8824c87ed93395f" translate="yes" xml:space="preserve">
          <source>We'll cover VNodes in more detail &lt;a href=&quot;render-function#the-virtual-dom-tree&quot;&gt;later&lt;/a&gt;, when we discuss render functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11cb422fd9a8827a4bee9296e2eefeb8799791f" translate="yes" xml:space="preserve">
          <source>We'll talk about &lt;a href=&quot;component-basics&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just be aware that the root component isn't really any different from any other component. The configuration options are the same, as is the behavior of the corresponding component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4763cc35fb84a23678cf26a9f7a29bb762c52dee" translate="yes" xml:space="preserve">
          <source>We're showing you a simple example here, but in a typical Vue application we use Single File Components instead of a string template. You can find more information about them &lt;a href=&quot;single-file-component&quot;&gt;in this section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902ee1e6bc3aa622843aa289195cfdd213ac8ef1" translate="yes" xml:space="preserve">
          <source>We're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3ca188b1df773cfd1eeb0376541bfa59686bfe" translate="yes" xml:space="preserve">
          <source>We've briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96cc25eb05f1274ae7b9eebefd157220abac3ca" translate="yes" xml:space="preserve">
          <source>Web Accessibility Initiative &amp;ndash; Accessible Rich Internet Applications (WAI-ARIA)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf30cbd1ee6db2c9121250baf622ac22c881128" translate="yes" xml:space="preserve">
          <source>Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff265f994041ba5e431f8222c5c1ba6691182894" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83aec0744d18b3272452883bc73b55a421d84c62" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279f4a441a4b12f3b9de64ff7f0e63d1f6fc5d06" translate="yes" xml:space="preserve">
          <source>Web accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone &amp;mdash; be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8917af5cf347fb6a6fe194798f4f56a85c811a01" translate="yes" xml:space="preserve">
          <source>WebAim Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca0768e3dfd8cfbe2c2bff1e16645bb18dbfe9b" translate="yes" xml:space="preserve">
          <source>WebAim Link Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="b0f63abab58780fc9096086a11d8c4fd44969c50" translate="yes" xml:space="preserve">
          <source>Webpack Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">А как же разделение опасений?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">Что ты можешь сделать</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">Что на самом деле возвращает &lt;code&gt;createElement&lt;/code&gt; ? Это не &lt;em&gt;совсем&lt;/em&gt; настоящий элемент DOM. Возможно, более точно его можно было бы назвать &lt;code&gt;createNodeDescription&lt;/code&gt; , поскольку он содержит информацию, описывающую Vue, какой тип узла он должен отображать на странице, включая описания любых дочерних узлов. Мы называем это описание узла &amp;laquo;виртуальным узлом&amp;raquo;, обычно сокращенно &lt;strong&gt;VNode&lt;/strong&gt; . &amp;laquo;Виртуальная модель DOM&amp;raquo; - это то, что мы называем всем деревом виртуальных узлов, построенным на основе дерева компонентов Vue.</target>
        </trans-unit>
        <trans-unit id="c23944cd8d26c2cb26b60dd0d1caadba140c80c6" translate="yes" xml:space="preserve">
          <source>What is Reactivity?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Что такое Vue.js?</target>
        </trans-unit>
        <trans-unit id="6762984b105eb8b517b607b726e8ea600efa2e2a" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;h()&lt;/code&gt; function returning? It's not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It returns a plain object which contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &quot;virtual node&quot;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &quot;Virtual DOM&quot; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">Когда &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; имеет несколько дочерних элементов, в конечном итоге они должны оценивать одного ребенка. Любой дочерний элемент, кроме первого, будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="4fa4fac2c46b4a9cb5fd7f97a6be2dad1bbe60c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is mutated, the callback will be called &lt;strong&gt;before&lt;/strong&gt; the component has updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">Когда &lt;code&gt;isActive&lt;/code&gt; истинно, обработанный HTML будет:</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">При изменении &lt;code&gt;isActive&lt;/code&gt; или &lt;code&gt;hasError&lt;/code&gt; список классов будет соответственно обновлен. Например, если &lt;code&gt;hasError&lt;/code&gt; становится &lt;code&gt;true&lt;/code&gt; , список классов станет &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">Когда &lt;code&gt;ref&lt;/code&gt; используется вместе с &lt;code&gt;v-for&lt;/code&gt; , полученный вами ref будет массивом, содержащим дочерние компоненты, отражающие источник данных.</target>
        </trans-unit>
        <trans-unit id="68799a9bc72bc5436c612e032f0302797e50e850" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setup&lt;/code&gt; is executed, the component instance has not been created yet. As a result, you will only be able to access the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">При изменении &lt;code&gt;text&lt;/code&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; всегда будет заменен, а не исправлен, поэтому переход будет запущен.</target>
        </trans-unit>
        <trans-unit id="e9a272c5ffb0265f805ce14ec56031bc1589886c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; are both used on the same element, &lt;code&gt;v-if&lt;/code&gt; will be evaluated first. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc1cc0e7f7cb99eda1ea39c8e59b8e52d17b215" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;watchEffect&lt;/code&gt; is called during a component's &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt; function or &lt;a href=&quot;composition-api-lifecycle-hooks&quot;&gt;lifecycle hooks&lt;/a&gt;, the watcher is linked to the component's lifecycle and will be automatically stopped when the component is unmounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6c45281f0e9295693c785e9c077ccf9de2ef90" translate="yes" xml:space="preserve">
          <source>When Vue 2.0 was released, the &lt;code&gt;v-model&lt;/code&gt; directive required developers to always use the &lt;code&gt;value&lt;/code&gt; prop. And if developers required different props for different purposes, they would have to resort to using &lt;code&gt;v-bind.sync&lt;/code&gt;. In addition, this hard-coded relationship between &lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; led to issues with how native elements and custom elements were handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c133285af76b6277f0041e5a1b902c2f3bc7a50" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &quot;in-place patch&quot; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Когда Vue обновляет список элементов, отображаемых с помощью &lt;code&gt;v-for&lt;/code&gt; , по умолчанию он использует стратегию &amp;laquo;исправления на месте&amp;raquo;. Если порядок элементов данных изменился, вместо перемещения элементов DOM в соответствии с порядком элементов, Vue исправит каждый элемент на месте и убедитесь, что он отражает то, что должно отображаться в этом конкретном индексе. Это похоже на поведение &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; в Vue 1.x.</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Когда Vue обрабатывает директивы, &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; , поэтому этот шаблон:</target>
        </trans-unit>
        <trans-unit id="b259e9996f2602892d2efd59722e6bdb4ae4ddf9" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;, so that this template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee4a8778693915a3019bc1ea6f3a54f6005a00f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ref&lt;/code&gt; is accessed or mutated as a property of a reactive object, it automatically unwraps to the inner value so it behaves like a normal property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">Когда ViewModel уничтожается, все прослушиватели событий автоматически удаляются. Вам не нужно беспокоиться о том, чтобы очистить его самостоятельно.</target>
        </trans-unit>
        <trans-unit id="ea83eee9db8590cd8fc96e20bb41e31cb11921cd" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Когда создается экземпляр Vue, он добавляет все свойства, найденные в его объекте &lt;code&gt;data&lt;/code&gt; в систему &lt;strong&gt;реактивности&lt;/strong&gt; Vue . Когда значения этих свойств изменятся, представление &amp;laquo;отреагирует&amp;raquo;, обновившись, чтобы соответствовать новым значениям.</target>
        </trans-unit>
        <trans-unit id="e10ac371624472fea62e8a9b8d7a32ccc5fd883e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &quot;DOM nodes&quot; (opens new window)&lt;/a&gt; to help it keep track of everything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">Когда браузер читает этот код, он строит &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;дерево &amp;laquo;узлов DOM&amp;raquo;,&lt;/a&gt; чтобы помочь ему отслеживать все, точно так же, как вы могли бы построить генеалогическое древо, чтобы отслеживать свою расширенную семью.</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">Когда компонент переключается внутри &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; , его &lt;code&gt;activated&lt;/code&gt; и &lt;code&gt;deactivated&lt;/code&gt; хуки жизненного цикла будут вызваны соответственно.</target>
        </trans-unit>
        <trans-unit id="421b8a98b1760ead672f1b77216c67fcc30374a6" translate="yes" xml:space="preserve">
          <source>When a component returns a single root node, non-prop attributes will automatically be added to the root node's attributes. For example, in the instance of a date-picker component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4093e40e3a7a628dc648fbb3e9f015f5439f571" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &quot;merged&quot; using appropriate strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">Когда миксин и сам компонент содержат перекрывающиеся параметры, они будут &amp;laquo;объединены&amp;raquo; с использованием соответствующих стратегий.</target>
        </trans-unit>
        <trans-unit id="15a4799ba709de314050c2aeb417d1c062407080" translate="yes" xml:space="preserve">
          <source>When a native event (e.g., &lt;code&gt;click&lt;/code&gt;) is defined in the &lt;code&gt;emits&lt;/code&gt; option, the component event will be used &lt;strong&gt;instead&lt;/strong&gt; of a native event listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f72c8ed98813c97629aa3dff3ba23fdf14af142" translate="yes" xml:space="preserve">
          <source>When a nested object is accessed from a reactive proxy, that object is &lt;em&gt;also&lt;/em&gt; converted into a proxy before being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db172a75e05ba77d82b2612c1d789b4232b4b0f" translate="yes" xml:space="preserve">
          <source>When a parent listens for the &lt;code&gt;click&lt;/code&gt; event on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0801ddea4aa0f45998c371d842fd8cd4d1bfcbd5" translate="yes" xml:space="preserve">
          <source>When a ref is returned as a property on the render context (the object returned from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;) and accessed in the template, it automatically unwraps to the inner value. There is no need to append &lt;code&gt;.value&lt;/code&gt; in the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00843c9d85b596ab87a52656147b09febbd8f473" translate="yes" xml:space="preserve">
          <source>When a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template, just like any other component property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c053395d17d13ce80a0364c9ff5e250131f80f75" translate="yes" xml:space="preserve">
          <source>When adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt;. This allows for more flexible design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">Когда элемент, заключенный в компонент &lt;code&gt;transition&lt;/code&gt; вставляется или удаляется, происходит следующее:</target>
        </trans-unit>
        <trans-unit id="a6231838dcc377e59b6f7a45b72b3be9da61805a" translate="yes" xml:space="preserve">
          <source>When assigning a &lt;a href=&quot;refs-api#ref&quot;&gt;ref&lt;/a&gt; to a &lt;code&gt;reactive&lt;/code&gt; property, that ref will be automatically unwrapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">При создании компонента &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; ваш шаблон в конечном итоге будет содержать больше, чем просто заголовок:</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">Когда компоненты начинают чувствовать себя стесненными или трудночитаемыми,добавление промежутков между многострочными свойствами может сделать их легче снимать снова.В некоторых редакторах,таких как Vim,такие опции форматирования также могут облегчить навигацию с помощью клавиатуры.</target>
        </trans-unit>
        <trans-unit id="309c2a92544230a15a51f890171560d2c2b0da32" translate="yes" xml:space="preserve">
          <source>When creating a form, you can use the following elements: &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">Когда пользовательские параметры объединяются, они используют стратегию по умолчанию, которая перезаписывает существующее значение. Если вы хотите, чтобы настраиваемый параметр был объединен с использованием настраиваемой логики, вам необходимо прикрепить функцию к &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a48b042d07d089f8ac425b2bfbb816b814258e35" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;app.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">При определении &lt;strong&gt;компонента&lt;/strong&gt; , &lt;code&gt;data&lt;/code&gt; должны быть объявлены как функция , которая возвращает исходный объект данных, потому что будет много случаев , созданных с использованием того же определения. Если мы используем простой объект для &lt;code&gt;data&lt;/code&gt; , этот же объект будет &lt;strong&gt;использоваться по ссылке&lt;/strong&gt; для всех созданных экземпляров! Предоставляя функцию &lt;code&gt;data&lt;/code&gt; , каждый раз, когда создается новый экземпляр, мы можем вызывать его, чтобы вернуть новую копию исходных данных.</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">При определении компонента с помощью PascalCase вы можете использовать любой случай при ссылке на его настраиваемый элемент. Это означает , что допустимы как &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; ,так и &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; . Обратите внимание, однако, что только имена kebab-case действительны непосредственно в DOM (т.е. не строковые шаблоны).</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">При определении компонента с помощью kebab-case вы также должны использовать kebab-case при ссылке на его настраиваемый элемент, например, в &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b21b5775a35c4109c91409425882806e5dcafab" translate="yes" xml:space="preserve">
          <source>When defining components in a string template or a single-file component, you have two options when defining component names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066a19ef89f904a34f15aab25b5aa44f5d2acef0" translate="yes" xml:space="preserve">
          <source>When dynamically binding attributes on an element, a common scenario involves using both the &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; syntax as well as individual properties in the same element. However, this raises questions as far as the priority of merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">Когда каждое вычисляемое свойство содержит только очень простое выражение с очень небольшим количеством зависимостей, гораздо проще написать тесты, подтверждающие, что оно работает правильно.</target>
        </trans-unit>
        <trans-unit id="7941adba64b48e32e845c4386f579d258e69a4db" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df23522a9402466e18df90100856fe06a436e73c" translate="yes" xml:space="preserve">
          <source>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">При включении имени / ключа свойства порядок аргументов для объектов был &lt;code&gt;(name, value)&lt;/code&gt; . Теперь &lt;code&gt;(value, name)&lt;/code&gt; больше соответствует обычным итераторам объектов, таким как lodash.</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">При включении &lt;code&gt;index&lt;/code&gt; порядок аргументов для массивов был &lt;code&gt;(index, value)&lt;/code&gt; . Теперь &lt;code&gt;(value, index)&lt;/code&gt; более согласовано с такими методами массива JavaScript, как &lt;code&gt;forEach&lt;/code&gt; и &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c307aa08a2101632c0ad4b3a6317b17bab92e104" translate="yes" xml:space="preserve">
          <source>When it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">При итерации по объекту порядок основан на порядке перечисления &lt;code&gt;Object.keys()&lt;/code&gt; , что &lt;strong&gt;не&lt;/strong&gt; гарантирует единообразия во всех реализациях механизма JavaScript.</target>
        </trans-unit>
        <trans-unit id="fab3293fcdc1fc50ed0d6ad7581641eed28e2498" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which isn't guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230ed0a7a0be6695cb0d232f9093b7cd6c4fcf5a" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; when listening for key events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">При прослушивании событий клавиатуры нам часто нужно проверять наличие определенных клавиш. Vue позволяет добавлять ключевые модификаторы для &lt;code&gt;v-on&lt;/code&gt; при прослушивании ключевых событий:</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">При прослушивании собственных событий DOM метод получает собственное событие как единственный аргумент. Если используется встроенный оператор, он имеет доступ к специальному свойству &lt;code&gt;$event&lt;/code&gt; : &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">При организации в редакторах в алфавитном порядке все базовые компоненты вашего приложения перечислены вместе, что упрощает их идентификацию.</target>
        </trans-unit>
        <trans-unit id="74937f5b6caa6e834c6f6b061e657dfd695c54c2" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">При передаче массивов в параметры запроса синтаксис QueryString больше не &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; , вместо этого используется новый синтаксис &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; . Внутренне &lt;code&gt;$route.query.users&lt;/code&gt; прежнему будет массивом, но если в запросе есть только один параметр: &lt;code&gt;/foo?users=Tom&lt;/code&gt; , при прямом доступе к этому маршруту маршрутизатор не сможет узнать, ожидали ли мы &lt;code&gt;users&lt;/code&gt; быть массивом. По этой &lt;code&gt;$route.query.users&lt;/code&gt; рассмотрите возможность добавления вычисляемого свойства и замены им каждой ссылки $ route.query.users :</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">Когда проверка prop не проходит,Vue выдает консольное предупреждение (если используется сборка разработки).</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">При регистрации компонента ему всегда будет присвоено имя. Например, в глобальной регистрации мы видели:</target>
        </trans-unit>
        <trans-unit id="23d3b8893cae1a97943ce59e8f17a3cc54c4a8d8" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we've seen so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , будут сохраняться и отображаться HTML-комментарии, найденные в шаблонах. По умолчанию они отбрасываются.</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">Однако при переключении между этими компонентами вам иногда может потребоваться сохранить их состояние или избежать повторного рендеринга по соображениям производительности. Например, при небольшом расширении нашего интерфейса с вкладками:</target>
        </trans-unit>
        <trans-unit id="651beb4b3e6f062a8bc7db612ca2ba6b3d198430" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d915145995bbbbc905958405c390550f8e65e" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746d16bd5abc3a9c7e4d55d39555ad4b65929566" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">Когда специальный атрибут &lt;code&gt;inline-template&lt;/code&gt; присутствует в дочернем компоненте, компонент будет использовать его внутреннее содержимое в качестве своего шаблона, а не рассматривать его как распределенное содержимое. Это позволяет более гибко создавать шаблоны.</target>
        </trans-unit>
        <trans-unit id="5c0db747b0eba54fa03d888a984d7c54baac77f8" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &quot;Add Todo&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">Когда компонент отрисовывается, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; будет заменен на &amp;laquo;Ваш профиль&amp;raquo;. Слоты могут содержать любой шаблонный код, включая HTML:</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">Когда глобальный фильтр имеет то же имя,что и локальный фильтр,предпочтение будет отдано локальному фильтру.</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">Когда страница загружается, этот элемент получает фокус (примечание: &lt;code&gt;autofocus&lt;/code&gt; не работает в мобильном Safari). Фактически, если вы не нажимали ни на что другое с момента посещения этой страницы, то теперь необходимо сфокусировать внимание на вводе выше. Теперь давайте создадим директиву, которая выполняет это:</target>
        </trans-unit>
        <trans-unit id="53fa055e2ff552cf0106e82aee9a9ceb3b099fb5" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Also, you can click on the &lt;code&gt;Rerun&lt;/code&gt; button and input will be focused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">Когда значение &lt;code&gt;data&lt;/code&gt; является объектом, оно совместно используется всеми экземплярами компонента. Представьте себе, например, компонент &lt;code&gt;TodoList&lt;/code&gt; с такими данными:</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">Когда они существуют на одном узле, &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; . Это означает, что &lt;code&gt;v-if&lt;/code&gt; будет запускаться на каждой итерации цикла отдельно. Это может быть полезно, когда вы хотите визуализировать узлы только для &lt;em&gt;некоторых&lt;/em&gt; элементов, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="4b3806336239800c5ec794a9d3907163b07e9915" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; condition will not have access to variables from the scope of the &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">Когда эти данные изменятся, представление будет повторно визуализировано. Следует отметить, что свойства &lt;code&gt;data&lt;/code&gt; являются &lt;strong&gt;реактивными&lt;/strong&gt; только в том случае, если они существовали при создании экземпляра. Это означает, что если вы добавите новое свойство, например:</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">При многократном вызове этого метода на одном и том же плагине,плагин будет установлен только один раз.</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">При переключении между элементами, имеющими &lt;strong&gt;одинаковое имя тега&lt;/strong&gt; , вы должны сообщить Vue, что они являются разными элементами, дав им уникальные &lt;code&gt;key&lt;/code&gt; атрибуты. В противном случае компилятор Vue заменит только содержимое элемента для повышения эффективности. Однако даже в тех случаях, когда это технически необязательно, &lt;strong&gt;считается хорошей практикой всегда использовать несколько элементов в компоненте &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd996911a0f54f846028a84e8762021497009a" translate="yes" xml:space="preserve">
          <source>When typing a &lt;code&gt;reactive&lt;/code&gt; property, we can use interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">При использовании для крепления реквизита,реквизит должен быть надлежащим образом декларирован в детском компоненте.</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">При использовании в компоненте &lt;code&gt;v-model&lt;/code&gt; вместо этого делает следующее:</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">При использовании в компоненте &lt;code&gt;v-on&lt;/code&gt; теперь слушает только пользовательские события &lt;code&gt;$emit&lt;/code&gt; генерируемые этим компонентом. Чтобы прослушивать собственное событие DOM в корневом элементе, вы можете использовать модификатор &lt;code&gt;.native&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="39c2818e21858b65998b9cb9c792d34b526f9165" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt; (opens new window)&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">При использовании с обычным элементом он слушает только &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;собственные события DOM&lt;/strong&gt;&lt;/a&gt; . При использовании в компоненте настраиваемого элемента он прослушивает &lt;strong&gt;настраиваемые события,&lt;/strong&gt; генерируемые этим дочерним компонентом.</target>
        </trans-unit>
        <trans-unit id="7424a99bcccbebcb1704239527c00d6ecfad0963" translate="yes" xml:space="preserve">
          <source>When used on components, custom directive will always apply to component's root node, similarly to &lt;a href=&quot;component-attrs&quot;&gt;non-prop attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">При использовании с элементами / компонентами с &lt;code&gt;v-for&lt;/code&gt; , зарегистрированная ссылка будет массивом, содержащим узлы DOM или экземпляры компонентов.</target>
        </trans-unit>
        <trans-unit id="f4a7dad4c6cfc5b01fc8733a0ec4ecb22ab51d3e" translate="yes" xml:space="preserve">
          <source>When used on normal components, it will behave like a normal prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e732a1c52ca8cf754429434fdc2c9d76e59a40b" translate="yes" xml:space="preserve">
          <source>When used on plain elements, it will be passed to the &lt;code&gt;createElement&lt;/code&gt; call as the &lt;code&gt;is&lt;/code&gt; option, and also rendered as a native attribute. This supports the usage of customized built-in elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351a36d6e4d3bd7a9ce7236de933a0d2d3934ac" translate="yes" xml:space="preserve">
          <source>When used on the reserved &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag, it will behave exactly the same as in 2.x;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">При использовании для привязки атрибута &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;style&lt;/code&gt; он поддерживает дополнительные типы значений, такие как массив или объекты. Дополнительную информацию см. В разделе связанного руководства ниже.</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">При использовании вместе с &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; не забудьте вложить его внутрь:</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;v-if&lt;/code&gt; , &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; . Подробности см. В &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;руководстве&lt;/a&gt; по отображению списка .</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">При использовании вместе с v-if, v-for имеет более высокий приоритет, чем v-if. Подробности см. В &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;руководстве&lt;/a&gt; по отображению списка .</target>
        </trans-unit>
        <trans-unit id="b5bb95376e672859dca4d4310ff771e83f090090" translate="yes" xml:space="preserve">
          <source>When used together, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. We don't recommend using these two directives together on one element &amp;mdash; see the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">При использовании с &lt;code&gt;v-bind&lt;/code&gt; теперь единственными ложными значениями являются: &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Это означает, что &lt;code&gt;0&lt;/code&gt; и пустые строки будут отображаться как правдивые. Так, например, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; будет отображаться как &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">При использовании без аргумента может использоваться для привязки объекта, содержащего пары имя-значение атрибута. Обратите внимание, что в этом режиме &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;style&lt;/code&gt; не поддерживают массив или объекты.</target>
        </trans-unit>
        <trans-unit id="c92b86613bb50d0d3909045ae62372cbd0ba73dc" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../api/options-data#watch&quot;&gt;the &lt;code&gt;watch&lt;/code&gt; option&lt;/a&gt; to watch an array, the callback will only trigger when the array is replaced. In other words, the watch callback will no longer be triggered on array mutation. To trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37ce001f85a01806e0a868532afd28214a23c8d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../guide/component-registration#local-registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">При использовании &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;локальной регистрации&lt;/a&gt; вы также можете напрямую предоставить функцию, которая возвращает &lt;code&gt;Promise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="155dd72290bb5a75b47cd1b727e2637716b8c1c8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;inject&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we also need to explicitly import it from &lt;code&gt;vue&lt;/code&gt;. Once we do so, this allows us to invoke it to define how we want to expose it to our component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71dd171ffdf07ffc560f972b60c7a451789477b7" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;provide&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we start by explicitly importing the method from &lt;code&gt;vue&lt;/code&gt;. This allows us to define each property with its own invocation of &lt;code&gt;provide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">При использовании &lt;code&gt;vue-loader&lt;/code&gt; или &lt;code&gt;vueify&lt;/code&gt; шаблоны внутри файлов &lt;code&gt;*.vue&lt;/code&gt; предварительно компилируются в JavaScript во время сборки. Вам действительно не нужен компилятор в окончательном комплекте, и поэтому вы можете использовать сборку только во время выполнения.</target>
        </trans-unit>
        <trans-unit id="49fe6055e1baf5ecb1fa9c79e5109c02c820ea28" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">При использовании JavaScript-только переходов, &lt;strong&gt;то &lt;code&gt;done&lt;/code&gt; обратных вызовы необходимы для &lt;code&gt;enter&lt;/code&gt; и &lt;code&gt;leave&lt;/code&gt; крючков&lt;/strong&gt; . В противном случае хуки будут вызываться синхронно, и переход завершится немедленно.</target>
        </trans-unit>
        <trans-unit id="492a825e70975417fd58f060648eb43809c5835c" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately. Adding &lt;code&gt;:css=&quot;false&quot;&lt;/code&gt; will also let Vue know to skip CSS detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8e11afcc19c58163c7f043d414ef7a0a2eb199" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &quot;flash of unstyled content&quot;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">При использовании однофайловых компонентов внутренние компоненты CSS вводятся динамически как теги &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; через JavaScript. Это требует небольших затрат времени выполнения, и если вы используете рендеринг на стороне сервера, это вызовет &amp;laquo;мигание нестилизованного содержимого&amp;raquo;. Извлечение CSS из всех компонентов в один и тот же файл позволит избежать этих проблем, а также улучшит минификацию и кеширование CSS.</target>
        </trans-unit>
        <trans-unit id="6ae9007703022fa5cb7c0cd322bf3a50ec4cecf4" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools (opens new window)&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">При использовании Vue мы рекомендуем также установить &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; в вашем браузере, что позволит вам проверять и отлаживать свои приложения Vue в более удобном интерфейсе.</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">При использовании таких инструментов сборки, как Webpack или Browserify, рабочий режим будет определяться параметром &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; внутри исходного кода Vue, и по умолчанию он будет находиться в режиме разработки. Оба инструмента сборки предоставляют способы перезаписать эту переменную, чтобы включить рабочий режим Vue, а предупреждения будут удалены минификаторами во время сборки. Все шаблоны &lt;code&gt;vue-cli&lt;/code&gt; предварительно настроены для вас, но было бы полезно знать, как это делается:</target>
        </trans-unit>
        <trans-unit id="73ab3894a5373b24631fe2355bde56549085fb2c" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. Vue CLI has this pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feb3981a84943e5fbab5765c5ec53aded8a95c4" translate="yes" xml:space="preserve">
          <source>When using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">При использовании шаблонов in-DOM (шаблонов,непосредственно написанных в HTML-файле)также следует избегать именования ключей прописными символами,так как браузеры будут заставлять имена атрибутов записывать в нижний регистр:</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">При использовании шаблонов in-DOM или строк шаблонов в JavaScript компиляция функции &quot;Шаблоны на возврат&quot; выполняется &quot;на лету&quot;.Обычно в большинстве случаев это происходит достаточно быстро,но этого лучше всего избегать,если ваше приложение чувствительно к производительности.</target>
        </trans-unit>
        <trans-unit id="52a194f1e41a6a5db000b3e319f51a2d953f4422" translate="yes" xml:space="preserve">
          <source>When using outside of &lt;a href=&quot;#setup&quot;&gt;setup&lt;/a&gt; or &lt;a href=&quot;#lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt;, please call &lt;code&gt;getCurrentInstance()&lt;/code&gt; on &lt;code&gt;setup&lt;/code&gt; and use the instance instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8268513fd3714a6bb1e18655deb42d64d8195501" translate="yes" xml:space="preserve">
          <source>When using reactive provide / inject values, &lt;strong&gt;it is recommended to keep any mutations to reactive properties inside of the &lt;em&gt;provider&lt;/em&gt; whenever possible&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">При использовании свойства &lt;code&gt;data&lt;/code&gt; в компоненте (то есть где угодно, кроме &lt;code&gt;new Vue&lt;/code&gt; ) значение должно быть функцией, возвращающей объект.</target>
        </trans-unit>
        <trans-unit id="29cfa5029bb45e9515038e53406ba42c15ddb95c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;setup&lt;/code&gt; function, it will take two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe17ea531d76bcff516416b2c63a3806ff1db39b" translate="yes" xml:space="preserve">
          <source>When using the Composition API, the concept of &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;reactive refs&lt;/a&gt; and &lt;a href=&quot;component-template-refs&quot;&gt;template refs&lt;/a&gt; are unified. In order to obtain a reference to an in-template element or component instance, we can declare a ref as usual and return it from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2325636eb7899967fe90bf565cfdf8509e2423d9" translate="yes" xml:space="preserve">
          <source>When using the render function, i.e., &lt;code&gt;h&lt;/code&gt;, 2.x used to define the &lt;code&gt;slot&lt;/code&gt; data property on the content nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b53ab6a7a09c723aad6b1a3af71ea61e4b6a3b8" translate="yes" xml:space="preserve">
          <source>When using this component inside the initial HTML structure, we can see a problem - the modal is being rendered inside the deeply nested &lt;code&gt;div&lt;/code&gt; and the &lt;code&gt;position: absolute&lt;/code&gt; of the modal takes the parent relatively positioned &lt;code&gt;div&lt;/code&gt; as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b443edf845e80ba0a827955e7f9e75dfd908e2cd" translate="yes" xml:space="preserve">
          <source>When watched value is an object or array, any changes to its properties or elements won't trigger the watcher because they reference the same object/array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3115fa755473f700797db8a3eaa25ac70279399a" translate="yes" xml:space="preserve">
          <source>When watching an array, the callback will only trigger when the array is replaced. If you need to trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">Когда мы нажимаем на кнопку, нам нужно сообщить родителю, что он должен увеличить текст всех сообщений. К счастью, экземпляры Vue предоставляют настраиваемую систему событий для решения этой проблемы. Родитель может выбрать прослушивание любого события в экземпляре дочернего компонента с помощью &lt;code&gt;v-on&lt;/code&gt; , так же, как мы это сделали бы с собственным событием DOM:</target>
        </trans-unit>
        <trans-unit id="56b6480e99f62d0b0a2594baeb4025339f0556be" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. To solve this problem, component instances provide a custom events system. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">Когда мы определили компонент &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; , вы могли заметить, что &lt;code&gt;data&lt;/code&gt; не были напрямую предоставлены объектом, например:</target>
        </trans-unit>
        <trans-unit id="07b462f32af9d739921941c237aa3a2d6e82914c" translate="yes" xml:space="preserve">
          <source>When we want to use a few properties of the large reactive object, it could be tempting to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring (opens new window)&lt;/a&gt; to get properties we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25563d9cbbe500885b8017f11094dbe20ce5416" translate="yes" xml:space="preserve">
          <source>When we were learning about form input bindings, we saw that &lt;code&gt;v-model&lt;/code&gt; has &lt;a href=&quot;forms#modifiers&quot;&gt;built-in modifiers&lt;/a&gt; - &lt;code&gt;.trim&lt;/code&gt;, &lt;code&gt;.number&lt;/code&gt; and &lt;code&gt;.lazy&lt;/code&gt;. In some cases, however, you might also want to add your own custom modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">При наложении на динамический компонент &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; кэширует экземпляры неактивных компонентов, не уничтожая их. Подобно &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; является абстрактным компонентом: он не отображает сам элемент DOM и не отображается в родительской цепочке компонента.</target>
        </trans-unit>
        <trans-unit id="6024fe4000d9406c04c3b8e635b2733012f8d604" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Когда вы создаете экземпляр Vue, вы передаете &lt;strong&gt;объект параметров&lt;/strong&gt; . Большая часть этого руководства описывает, как вы можете использовать эти параметры для создания желаемого поведения. Для справки вы также можете просмотреть полный список параметров в &lt;a href=&quot;../api/index#Options-Data&quot;&gt;справочнике&lt;/a&gt; по API .</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">Когда вы напрямую устанавливаете элемент с индексом, например &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">Когда вы начинаете работу с компонентом, который генерирует только заголовок на основе свойства &lt;code&gt;level&lt;/code&gt; , вы быстро приходите к следующему:</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">Присмотревшись, вы увидите, что эти компоненты на самом деле будут потомками &lt;em&gt;и&lt;/em&gt; предками друг друга в дереве рендеринга - парадокс! При глобальной регистрации компонентов с помощью &lt;code&gt;Vue.component&lt;/code&gt; этот парадокс разрешается автоматически. Если это ты, можешь перестать читать здесь.</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">Когда вы изменяете длину массива, например &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">Когда вы передаете простой объект JavaScript экземпляру Vue в качестве параметра &lt;code&gt;data&lt;/code&gt; , Vue просматривает все его свойства и преобразует их в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt; / установки&lt;/a&gt; с помощью Object.defineProperty . Это функция, предназначенная только для ES5 и не имеющая шиммирования, поэтому Vue не поддерживает IE8 и ниже.</target>
        </trans-unit>
        <trans-unit id="933b3b1c3bc981ed309ab3c1c26b343f83550c6c" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to an application or component instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;Proxies (opens new window)&lt;/a&gt; using a handler with getters and setters. This is an ES6-only feature, but we offer a version of Vue 3 that uses the older &lt;code&gt;Object.defineProperty&lt;/code&gt; to support IE browsers. Both have the same surface API, but the Proxy version is slimmer and offers improved performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc08c055658d2907306b28227fc08089b9c9d0b" translate="yes" xml:space="preserve">
          <source>When you pass an object to a component instance as data, Vue converts it to a proxy. This proxy enables Vue to perform dependency-tracking and change-notification when properties are accessed or modified. Each property is considered a dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">Когда вы регистрируете компонент глобально с помощью &lt;code&gt;Vue.component&lt;/code&gt; , глобальный идентификатор автоматически устанавливается в качестве опции &lt;code&gt;name&lt;/code&gt; компонента .</target>
        </trans-unit>
        <trans-unit id="3a59415917e0f7bce0c1e1ce588bc65642dde4e2" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">Когда вы обновляете номер, изменение анимируется под полем ввода. Это хорошая демонстрация, но как насчет того, что не хранится напрямую как число, например, любого допустимого цвета CSS? Вот как этого добиться с помощью &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; и &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e0e5cc8bd4dbd3f0f73f17bc44dd88fc965b701e" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes (opens new window)&lt;/a&gt; in &lt;code&gt;:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">Когда вы используете свойство CSS, которое требует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;префиксов поставщика&lt;/a&gt; в &lt;code&gt;v-bind:style&lt;/code&gt; , например, &lt;code&gt;transform&lt;/code&gt; , Vue автоматически обнаружит и добавит соответствующие префиксы к применяемым стилям.</target>
        </trans-unit>
        <trans-unit id="6b1215d8f619fb72cc267754d02609941e493e8b" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component with a single root element, those classes will be added to this element. Existing classes on this element will not be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">Когда вы используете атрибут &lt;code&gt;class&lt;/code&gt; в пользовательском компоненте, эти классы будут добавлены к корневому элементу компонента. Существующие классы этого элемента не будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">Когда вы хотите использовать данные внутри слота,например in:</target>
        </trans-unit>
        <trans-unit id="5224afaf87d02d75b63b7c58580593c3450a4bdb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;counter&lt;/code&gt; is modified, for example &lt;code&gt;counter.value = 5&lt;/code&gt;, the watch will trigger and execute the callback (second argument) which in this case will log &lt;code&gt;'The new counter value is: 5'&lt;/code&gt; into our console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">Когда есть несколько слотов, используйте полный синтаксис на основе &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; для &lt;em&gt;всех&lt;/em&gt; слотов:</target>
        </trans-unit>
        <trans-unit id="3c59757a70411453c39e9877f5bd40fa36fe8fd5" translate="yes" xml:space="preserve">
          <source>Whenever this plugin is added to an application, the &lt;code&gt;install&lt;/code&gt; method will be called if it is an object. If it is a &lt;code&gt;function&lt;/code&gt;, the function itself will be called. In both cases, it will receive two parameters - the &lt;code&gt;app&lt;/code&gt; object resulting from Vue's &lt;code&gt;createApp&lt;/code&gt;, and the options passed in by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">Если существует несколько одинаково хороших вариантов, можно сделать произвольный выбор для обеспечения согласованности. В этих правилах мы описываем каждый приемлемый вариант и предлагаем вариант по умолчанию. Это означает, что вы можете свободно делать другой выбор в своей собственной кодовой базе, если вы последовательны и имеете веские основания. Пожалуйста, имейте вескую причину! Адаптируясь к общественному стандарту, вы:</target>
        </trans-unit>
        <trans-unit id="40389be7b40b64109eb2a221c81a64962b25ce29" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">С чего мне начать в миграции?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">Везде, где что-то может быть легко выполнено с помощью простого JavaScript, функции рендеринга Vue не предоставляют проприетарной альтернативы. Например, в шаблоне с использованием &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">Работает ли текущий экземпляр Vue на сервере.</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">Который может быть использован в шаблоне для контроля размера шрифта всех сообщений блога:</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">Который также может быть написан как:</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">Что может сделать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">Какие устаревшие функции вы используете. Большинство из них можно обновить с помощью функции &quot;найти и заменить&quot;, но другие могут занять несколько минут. Если вы в настоящее время не следуете лучшим практикам, Vue 2.0 также постарается вас заставить. В долгосрочной перспективе это хорошо, но также может означать значительный (хотя, возможно, запоздалый) рефакторинг.</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">Который окажет:</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">Хотя Vue масштабируется так же хорошо, как и React, он также масштабируется так же хорошо, как jQuery. Правильно - для начала все, что вам нужно сделать, это добавить на страницу один тег скрипта:</target>
        </trans-unit>
        <trans-unit id="67526a3ad5381ad5a3d17e38178b4ebbd75ccade" translate="yes" xml:space="preserve">
          <source>While Vue.js does not natively support mobile app development, there are a number of solutions for creating native iOS and Android apps with Vue.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d93357bd259acbade7c18b02dac0a7c343f7e5" translate="yes" xml:space="preserve">
          <source>While all the examples on this page only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">Хотя значения атрибутов без пробелов не обязательно должны заключаться в кавычки в HTML, эта практика часто приводит к тому, &lt;em&gt;что&lt;/em&gt; пробелы не используются, что делает значения атрибутов менее читаемыми.</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">Хотя вычисляемые свойства более подходят в большинстве случаев, бывают случаи, когда требуется настраиваемый наблюдатель. Вот почему Vue предоставляет более общий способ реагировать на изменения данных с помощью опции &lt;code&gt;watch&lt;/code&gt; . Это наиболее полезно, когда вы хотите выполнять асинхронные или дорогостоящие операции в ответ на изменение данных.</target>
        </trans-unit>
        <trans-unit id="fd4fac6fce5850105ed2b54389e0980507751bfb" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58ceb4be486c0d3bcb8a6914f2874907486034f" translate="yes" xml:space="preserve">
          <source>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd77b96c3d24d46385ee19732ac45b61f33bee8a" translate="yes" xml:space="preserve">
          <source>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">Хотя явно определенные свойства предпочтительнее для передачи информации дочернему компоненту, авторы библиотек компонентов не всегда могут предвидеть контексты, в которых могут использоваться их компоненты. Вот почему компоненты могут принимать произвольные атрибуты, которые добавляются к корневому элементу компонента.</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">Хотя шаблоны отлично подходят для большинства компонентов, ясно, что это не один из них. Итак, давайте попробуем переписать его с помощью функции &lt;code&gt;render&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dccd95c62bd449380bb4f7810be214fe6f2cc294" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a &lt;code&gt;render()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f53a61720d34f8deb200583fb4293a0b28f026" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4a80a732fb32a76bcecd383d1d0a7ebd43cd2" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d958d9d37ed58a5f1f97ee679c1620d781626e" translate="yes" xml:space="preserve">
          <source>While this approach is convenient, it leads to a couple of problems. Technically, Vue 2 doesn't have a concept of an &quot;app&quot;. What we define as an app is simply a root Vue instance created via &lt;code&gt;new Vue()&lt;/code&gt;. Every root instance created from the same Vue constructor &lt;strong&gt;shares the same global configuration&lt;/strong&gt;. As a result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26388458f8fca7cd6a63de038df2a21f485dd436" translate="yes" xml:space="preserve">
          <source>While this seems like a convenience, it requires a custom syntax that breaks the assumption of expressions inside of curly braces being &quot;just JavaScript,&quot; which has both learning and implementation costs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaa3f23ca2ee3059b2128051891a6ae3197f8a2" translate="yes" xml:space="preserve">
          <source>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008a9bd1fd351881294a8ab7c58eff00ecd921e6" translate="yes" xml:space="preserve">
          <source>Why Composition API?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">Почему слушатели в HTML?</target>
        </trans-unit>
        <trans-unit id="d05a9a10126e300cca0827aed2703aed49fcd394" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;code&gt;list&lt;/code&gt;, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;code&gt;list&lt;/code&gt;. Without caching, we would be executing &lt;code&gt;list&lt;/code&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a &lt;code&gt;method&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">Зачем нам кеширование? Представьте, что у нас есть дорогостоящее вычисляемое свойство &lt;strong&gt;A&lt;/strong&gt; , которое требует перебора огромного массива Array и выполнения большого количества вычислений. Тогда мы можем иметь другие вычисляемые свойства , которые в свою очередь зависят от &lt;strong&gt;А&lt;/strong&gt; . Без кеширования мы бы выполняли получатель &lt;strong&gt;A&lt;/strong&gt; гораздо больше раз, чем необходимо! В случаях, когда вам не нужно кеширование, используйте вместо этого метод.</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">будет эквивалентно:</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">Будет оцениваться аналогично:</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">Вместо этого будет определено с:</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">В результате:</target>
        </trans-unit>
        <trans-unit id="5bcd42cce76c522e00acc375bb83a386e44895e9" translate="yes" xml:space="preserve">
          <source>Will throw an error, because the &lt;code&gt;v-if&lt;/code&gt; directive will be evaluated first and the iteration variable &lt;code&gt;user&lt;/code&gt; does not exist at this moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b523d2bcf5fca866ffcaea5c846072e6f454e3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2972362a724a19189b0c528b9c31cb4d552d316e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;migration/fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root nodes. When applied to a multi-root component, directive will be ignored and the warning will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3c68936845bcadd633acd3c5e92f54a35dd57a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&amp;lt;template v-for&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">С компонентами &lt;code&gt;.vue&lt;/code&gt; мы входим в область передовых приложений JavaScript. Это означает научиться пользоваться несколькими дополнительными инструментами, если вы еще не сделали этого:</target>
        </trans-unit>
        <trans-unit id="e3840f18f3809fb17a5fc20b99dd0f910da3163d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">С помощью &lt;code&gt;inheritAttrs: false&lt;/code&gt; и &lt;code&gt;$attrs&lt;/code&gt; вы можете вручную решить, в какой элемент вы хотите пересылать атрибуты, что часто желательно для &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;базовых компонентов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">Со строительными инструментами</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">С компонентами</target>
        </trans-unit>
        <trans-unit id="e94afd24abb64d9b90f7248caba76323b7bd6df5" translate="yes" xml:space="preserve">
          <source>With Composition API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">В символах ES2015 функция &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; объект :</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">С MobX</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">С синтаксисом,основанным на объектах,вы можете использовать следующие опции:</target>
        </trans-unit>
        <trans-unit id="0ddaa6dc6d7bbbc58f451bb92e742747f8a0ad5d" translate="yes" xml:space="preserve">
          <source>With Options API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">С PascalCase</target>
        </trans-unit>
        <trans-unit id="8e3c02906d7a5cad13118eea9109a6e2b7c11fa1" translate="yes" xml:space="preserve">
          <source>With Vue 3, the API for two-way data binding is being standardized in order to reduce confusion and to allow developers more flexibility with the &lt;code&gt;v-model&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6e8d5c594ae0eeedbf57f7bb713ef9a3488318" translate="yes" xml:space="preserve">
          <source>With a Bundler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c796447490b9562e329b4eb4f3c1a45c3a13ab" translate="yes" xml:space="preserve">
          <source>With all these changes, the component and directive we have at the beginning of the guide will be rewritten into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f67259032ce5e6a9b51cd6c8ee262fb5c3605c" translate="yes" xml:space="preserve">
          <source>With global tree-shaking, the user only &amp;ldquo;pay&amp;rdquo; for the features they actually use. Even better, knowing that optional features won't increase the bundle size for applications not using them, framework size has become much less a concern for additional core features in the future, if at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">С кебабом</target>
        </trans-unit>
        <trans-unit id="5262fdf2404668ac87ace7bc5320c88ae3fec32d" translate="yes" xml:space="preserve">
          <source>With npm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">Добавив один атрибут, мы исправили исходный переход, не добавляя никаких специальных стилей.</target>
        </trans-unit>
        <trans-unit id="689393a6c1bd0377fbe965e3cad93231017b2f2b" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we've fixed that original transition without having to add any special styling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36361bcb7732d5e11757dbbeec045c06c4c7e7ac" translate="yes" xml:space="preserve">
          <source>With render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">С учетом сказанного, сравнение неизбежно покажется некоторым пользователям React смещенным в сторону Vue, поскольку многие из исследуемых тем в некоторой степени субъективны. Мы признаем существование различных технических предпочтений, и это сравнение в первую очередь направлено на то, чтобы очертить причины, по которым Vue потенциально может быть более подходящим, если ваши предпочтения совпадают с нашими.</target>
        </trans-unit>
        <trans-unit id="74293b552f92b191f072c0da0451d95393b6de4a" translate="yes" xml:space="preserve">
          <source>With the behavior change of &lt;code&gt;is&lt;/code&gt;, we introduce a new directive &lt;code&gt;v-is&lt;/code&gt; for working around these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">С новой системой переходов теперь вы можете &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;использовать компоненты для многоразовых переходов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3828ac5cca844bde7e12cdc97494a2e145077de0" translate="yes" xml:space="preserve">
          <source>With the second parameter, we can pass root props to the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d2800ca9c44c02e89db888766c57a4c894655" translate="yes" xml:space="preserve">
          <source>With the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5db4b3ecbbcef145192161b4e8a9adf72f34af" translate="yes" xml:space="preserve">
          <source>With this change, provided the module bundler supports tree-shaking, global APIs that are not used in a Vue application will be eliminated from the final bundle, resulting in an optimal file size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">С этими знаниями мы теперь можем закончить начатый нами компонент:</target>
        </trans-unit>
        <trans-unit id="c0b51b14ed767e15b6133cfad9870cba3b70f4a4" translate="yes" xml:space="preserve">
          <source>With this new configuration, our &lt;code&gt;data-status&lt;/code&gt; attribute will be applied to our &lt;code&gt;input&lt;/code&gt; element!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d064e70d3aeb0eac7d3ba972b7156b0acdc5ed48" translate="yes" xml:space="preserve">
          <source>With those changes in place, we've just moved the whole first logical concern into a single place. We can now do the same with the second concern &amp;ndash; filtering based on &lt;code&gt;searchQuery&lt;/code&gt;, this time with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">В дочерних компонентах мы можем использовать любую комбинацию стратегий перехода, описанных на этой странице, наряду со стратегиями, предлагаемыми &lt;a href=&quot;transitions&quot;&gt;встроенной системой перехода&lt;/a&gt; Vue . Вместе есть очень мало пределов того, что может быть достигнуто.</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">Без строительных инструментов</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">Вау - это супер длинная страница! Означает ли это, что версия 2.0 совершенно другая, мне придется заново изучать основы и миграция будет практически невозможна?</target>
        </trans-unit>
        <trans-unit id="c9e02cb643a613f1c79faab9079d2f3e58edae60" translate="yes" xml:space="preserve">
          <source>Working with reactivity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3413e9fc86a733fea321b8d4f5dce2cd96c7c946" translate="yes" xml:space="preserve">
          <source>Wrapping values inside an object might seem unnecessary but is required to keep the behavior unified across different data types in JavaScript. That&amp;rsquo;s because in JavaScript, primitive types like &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; are passed by value, not by reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357865535aa2a476144e9beb3464ba1cbdbcf27" translate="yes" xml:space="preserve">
          <source>Writing &amp;amp; Grammar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">Пишите настраиваемые компоненты</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">Написание плагина</target>
        </trans-unit>
        <trans-unit id="4835d6c16769322c715842b97457649636213963" translate="yes" xml:space="preserve">
          <source>Writing documentation is an exercise in empathy. We're not describing an objective reality - the source code already does that. Our job is to help shape the relationship between users and the Vue ecosystem. This ever-evolving guide provides some rules and recommendations on how to do that consistently within the Vue ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="3da53c899f2de058d0a78dc035fc82fa4168e261" translate="yes" xml:space="preserve">
          <source>Yes! We are ready for translation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">Да, даже переходы во Vue управляются данными! Самый простой пример динамического перехода связывает атрибут &lt;code&gt;name&lt;/code&gt; с динамическим свойством.</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">На самом деле вам больше не нужно отлаживать, поскольку Vue автоматически форматирует вывод, будь то строка, число, массив или простой объект. Если вам нужна точно такая же функциональность, что и у JavaScript &lt;code&gt;JSON.stringify&lt;/code&gt; , вы можете использовать это в методе или вычисляемом свойстве.</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">Вы вынуждены быть более явным,давая вашему вынужденному значение имя,которое отличает его от значения,переданного в опоре.</target>
        </trans-unit>
        <trans-unit id="259bd96ca0effe183387e9e5f024f56b5205a591" translate="yes" xml:space="preserve">
          <source>You can access a component's lifecycle hook by prefixing the lifecycle hook with &quot;on&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете получить доступ к статическому содержимому слота в виде массивов виртуальных узлов из &lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt; Slots :</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">Вы также можете &lt;a href=&quot;../api/index#keyCodes&quot;&gt;определить пользовательские псевдонимы модификаторов клавиш&lt;/a&gt; через глобальный объект &lt;code&gt;config.keyCodes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1813d70fbaf8bba2c2a5a3785639129921bc5052" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally for a Vue application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">Вы также можете применить миксин глобально. Используйте с осторожностью! Как только вы примените миксин глобально, он повлияет на &lt;strong&gt;каждый&lt;/strong&gt; созданный впоследствии экземпляр Vue. При правильном использовании это можно использовать для внедрения логики обработки для настраиваемых параметров:</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">Вы также можете объявить дополнительные глобальные свойства и параметры компонентов:</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">Вы также можете определить JavaScript хуки в атрибутах:</target>
        </trans-unit>
        <trans-unit id="beebaf9986e9097a2444f204aa81ae1c568b7cbd" translate="yes" xml:space="preserve">
          <source>You can also give the input an accessible name with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute&quot;&gt;&lt;code&gt;aria-label&lt;/code&gt; (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503a3e28cf5a8489e2b8f7a242ab27389b2b6691" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/directives#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">Вы также можете выполнять одноразовые интерполяции, которые не обновляются при изменении данных, с помощью &lt;a href=&quot;../api/index#v-once&quot;&gt;директивы v-once&lt;/a&gt; , но имейте в виду, что это также повлияет на любые другие привязки на том же узле:</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">Вы также можете указать второй аргумент для имени свойства (он же ключ):</target>
        </trans-unit>
        <trans-unit id="7e590ee53b15356b15c6804307c06fa95680eb6f" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property's name (a.k.a. key):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">Вы также можете вернуть &lt;code&gt;Promise&lt;/code&gt; в заводской функции, поэтому с синтаксисом Webpack 2 и ES2015 вы можете:</target>
        </trans-unit>
        <trans-unit id="2f9cab99bb92ad04f5fd1ef133a533bca320077d" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 or later and ES2015 syntax you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">Вы также можете указать пользовательские переходные классы,предоставив следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">Вы также можете указать отдельные значения для продолжительности входа и выхода:</target>
        </trans-unit>
        <trans-unit id="b708002bf5e4f269767c152c0103659f003ed958" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;defineAsyncComponent&lt;/code&gt; when &lt;a href=&quot;component-registration#local-registration&quot;&gt;registering a component locally&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;of&lt;/code&gt; качестве разделителя вместо &lt;code&gt;in&lt;/code&gt; , чтобы он был ближе к синтаксису JavaScript для итераторов:</target>
        </trans-unit>
        <trans-unit id="56680b86213ebfab218348e1f259349ba40ffdea" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript's syntax for iterators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;v-for&lt;/code&gt; для перебора свойств объекта.</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt; , который является псевдонимом для глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="caa2f5e4a5e7cb8569f06fc887bf75bbeb1e905a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://vuejs.org/v2/api/#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt; (opens new window)&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7016af3cddf281827fcb1fb635902cd99d67f65c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;is&lt;/code&gt; attribute to create regular HTML elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;code&gt;vm.$set&lt;/code&gt; , который является псевдонимом для глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;code&gt;vm.$set&lt;/code&gt; , который является псевдонимом глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">Вы можете утверждать его вывод рендеринга с помощью разных &lt;code&gt;propsData&lt;/code&gt; используя параметр propsData :</target>
        </trans-unit>
        <trans-unit id="a1723b0ed33c8953b91ffd8fc42e598875ee5aa7" translate="yes" xml:space="preserve">
          <source>You can bind as many attributes to the &lt;code&gt;slot&lt;/code&gt; as you need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9450a9423cc08d4d6f86fddb51f97f1895339a" translate="yes" xml:space="preserve">
          <source>You can browse the full application API in the &lt;a href=&quot;../api/application-api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">Вы можете просмотреть исходный код пакета NPM по адресу &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a50584cf2f28b29d5933a7806dfd6c8fe93a173" translate="yes" xml:space="preserve">
          <source>You can chain other methods after &lt;code&gt;createApp&lt;/code&gt;, they can be found in &lt;a href=&quot;application-api&quot;&gt;Application API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a108d1490b085325e471f3c57d3e9dc0f3ae2bc3" translate="yes" xml:space="preserve">
          <source>You can change &lt;code&gt;seen&lt;/code&gt; from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the sandbox below to check the effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb59a77a247c2d91532f11b2a60d478be4cab66" translate="yes" xml:space="preserve">
          <source>You can check &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; component options in the &lt;a href=&quot;../api/built-in-components#teleport&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48aa82a368ad205d3da3994cb186cdc0a22d46d8" translate="yes" xml:space="preserve">
          <source>You can check the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;prevVnode&lt;/code&gt;) in &lt;a href=&quot;../api/application-api#directive&quot;&gt;Custom Directive API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a321e28dae8c3d2b4ba9a95524f5a758d218685" translate="yes" xml:space="preserve">
          <source>You can check the list of available options in the &lt;a href=&quot;../api/global-api#arguments-4&quot;&gt;API Reference&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498c9c8804cc7d12217ea3d9f3524d82346ca9db" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; depends on &lt;code&gt;vm.author.books&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; when &lt;code&gt;vm.author.books&lt;/code&gt; changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">Вы можете привязать данные к вычисляемым свойствам в шаблонах, как обычное свойство. Vue знает, что &lt;code&gt;vm.reversedMessage&lt;/code&gt; зависит от &lt;code&gt;vm.message&lt;/code&gt; , поэтому он будет обновлять любые привязки, которые зависят от &lt;code&gt;vm.reversedMessage&lt;/code&gt; , при изменении &lt;code&gt;vm.message&lt;/code&gt; . И самое приятное то, что мы создали это отношение зависимости декларативно: вычисляемая функция получения не имеет побочных эффектов, что упрощает тестирование и понимание.</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">Вы можете определить локальные фильтры в параметрах компонента:</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">Вы определенно можете включить эти соединительные слова в названия компонентов, если хотите, но порядок по-прежнему важен.</target>
        </trans-unit>
        <trans-unit id="f39a90801437ef44d3dae3a0d0e800d9fa37f7c2" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you'd like, but the order is still important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">Вы можете напрямую использовать &lt;code&gt;v-for&lt;/code&gt; в пользовательском компоненте, как и любой обычный элемент:</target>
        </trans-unit>
        <trans-unit id="a0f496ff2b9d3f296d22a7febb3e4014d60fe282" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt; (opens new window)&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">Вы можете напрямую использовать любые допустимые имена клавиш, представленные через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; ,в&lt;/a&gt; качестве модификаторов, преобразовав их в kebab-case.</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">Вы даже можете определить откаты,которые будут использоваться в случае,если слот реквизит не определен:</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">Вы даже можете заказать по нескольким столбцам:</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Вы даже можете использовать препроцессоры,такие как Pug (ранее известный как Jade),для создания шаблонов Vue.</target>
        </trans-unit>
        <trans-unit id="bcde8b53cf3059c4972d20e4534b1e469ee4c5fb" translate="yes" xml:space="preserve">
          <source>You can find more information at this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b95ad424054751a98acdcf21d4dc4035ab20f" translate="yes" xml:space="preserve">
          <source>You can get a lot of unique effects and make your animation very stylish by adjusting your easing. CSS allows you to modify this by adjusting a cubic bezier property, &lt;a href=&quot;https://cubic-bezier.com/#.17,.67,.83,.67&quot;&gt;this playground (opens new window)&lt;/a&gt; by Lea Verou is very helpful for exploring this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df595af00721f8288076a5f9fba469b9a917832" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">Вы можете переключать несколько классов, если в объекте будет больше полей. Кроме того, директива &lt;code&gt;v-bind:class&lt;/code&gt; также может сосуществовать с атрибутом plain &lt;code&gt;class&lt;/code&gt; . Итак, учитывая следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="8aa030b589eee93625f4864d21a641f8663ff7c6" translate="yes" xml:space="preserve">
          <source>You can have multiple methods in an event handler separated by a comma operator like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56c7af523fb7e0763535f3902c25d971d409bc6" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;reactive&lt;/code&gt; in the &lt;a href=&quot;../api/basic-reactivity&quot;&gt;Basic Reactivity API's&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08c4fe759a5cd0a79d2084a4f5a83a750978591" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;refs&lt;/code&gt; in the &lt;a href=&quot;../api/refs-api#ref&quot;&gt;Refs API&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bd14a02b45ad31d79cd406616fc79e061cec94" translate="yes" xml:space="preserve">
          <source>You can learn more about component attribute inheritance in &lt;a href=&quot;component-attrs&quot;&gt;Non-Prop Attributes&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">Вы можете использовать возможности полноценного языка программирования (JavaScript)для построения своего вида.Сюда входят временные переменные,средства управления потоком и прямые ссылки на значения JavaScript в области видимости.</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">Вы можете изменить состояние компонентов в этом крючке.Однако,важно,чтобы в вашем шаблоне были условия или функция рендеринга,которая замыкает другое содержимое,когда была перехвачена ошибка;в противном случае компонент будет брошен в бесконечный цикл рендеринга.</target>
        </trans-unit>
        <trans-unit id="483010467e7b1520e8252c976ccc95f6183b6a3a" translate="yes" xml:space="preserve">
          <source>You can modify its properties, listed below, before mounting your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">Вы можете открыть консоль и самостоятельно поиграть с примером vm. Значение &lt;code&gt;vm.reversedMessage&lt;/code&gt; всегда зависит от значения &lt;code&gt;vm.message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">Вы можете открыть консоль и поиграть с массивом &lt;code&gt;items&lt;/code&gt; из предыдущих примеров , вызвав их методы мутации. Например: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7275711fe53486de9349eeef7453708059692c43" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples' &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">По желанию вы можете пройти некоторые опции:</target>
        </trans-unit>
        <trans-unit id="69df9eda77fa786bedb0320c7efdaa4e55ad2623" translate="yes" xml:space="preserve">
          <source>You can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">Ты можешь заменить его:</target>
        </trans-unit>
        <trans-unit id="f3ebee5b6a0c8de1d1b75a459aa211a5e7be2130" translate="yes" xml:space="preserve">
          <source>You can see how we could use this for data visualization, for physics effects, for character animations and interactions, the sky's the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть другие рекомендации по именам компонентов в &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Руководстве&lt;/a&gt; по стилю .</target>
        </trans-unit>
        <trans-unit id="c82861be683435cc1668ccd7f2e6b81cafe38300" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">Вы можете увидеть &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;полный пример здесь&lt;/a&gt; . Преимущество перед использованием &lt;code&gt;$parent&lt;/code&gt; заключается в том, что мы можем получить доступ к &lt;code&gt;getMap&lt;/code&gt; в &lt;em&gt;любом &lt;/em&gt;дочернем компоненте, не открывая весь экземпляр &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; . Это позволяет нам более безопасно продолжать разработку этого компонента, не опасаясь, что мы можем изменить / удалить что-то, на что полагается дочерний компонент. Интерфейс между этими компонентами остается четко определенным, как и в случае с &lt;code&gt;props&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16bcf864fb3aac6cb97fde8cea277e3092eccb3c" translate="yes" xml:space="preserve">
          <source>You can see the description by inspecting Chrome DevTools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4d8ebb6112a000f5549eb59e46ddfbf5ba539c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &quot;else block&quot; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать директиву &lt;code&gt;v-else&lt;/code&gt; , чтобы указать &amp;laquo;блок else&amp;raquo; для &lt;code&gt;v-if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">Вы можете использовать директиву &lt;code&gt;v-model&lt;/code&gt; для создания двусторонних привязок данных для ввода формы, текстового поля и элементов выбора. Он автоматически выбирает правильный способ обновления элемента в зависимости от типа ввода. Хотя это немного волшебно, &lt;code&gt;v-model&lt;/code&gt; по сути, является синтаксическим сахаром для обновления данных о событиях ввода пользователя, плюс особая осторожность в некоторых крайних случаях.</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">Вы можете использовать следующие модификаторы для запуска слушателей событий мыши или клавиатуры только при нажатии соответствующей клавиши-модификатора:</target>
        </trans-unit>
        <trans-unit id="8ddb37f26a92a06753b285b9c9c11e196959baab" translate="yes" xml:space="preserve">
          <source>You can use this technique to create functional images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">Ты можешь использовать:</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">Вы можете добавить новое свойство &lt;code&gt;age&lt;/code&gt; во вложенный объект &lt;code&gt;userProfile&lt;/code&gt; с помощью:</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">Вы можете решить обе проблемы с программным слушателем:</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">Тебе бы не помешало:</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">Ты можешь писать:</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">Вам не нужно делать ничего особенного в ваших компонентах, чтобы сделать их тестируемыми. Экспортируйте исходные параметры:</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">У вас есть два варианта при определении имен компонентов:</target>
        </trans-unit>
        <trans-unit id="32c890526e2b50fb6ddd6a47a453deb3b5176a87" translate="yes" xml:space="preserve">
          <source>You may also find that entrances look better with slightly more time than an exit. The user typically is being guided during the entrance, and is a little less patient upon exit because they want to go on their way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Возможно, вам будет интересно узнать, что шаблоны Vue на самом деле компилируются для рендеринга функций. Это деталь реализации, о которой обычно не нужно знать, но если вы хотите увидеть, как компилируются определенные функции шаблона, это может показаться вам интересным. Ниже приведена небольшая демонстрация использования &lt;code&gt;Vue.compile&lt;/code&gt; для живой компиляции строки шаблона:</target>
        </trans-unit>
        <trans-unit id="8cd17a8f30e925013013a4351cf5807785289ba1" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">Вам может быть интересно:</target>
        </trans-unit>
        <trans-unit id="143b9f4f1dc7d1bfde27bde6e896dca625ded097" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec (opens new window)&lt;/a&gt;. That's because Vue's component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API (opens new window)&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Вы могли заметить, что компоненты Vue очень похожи на &lt;strong&gt;настраиваемые элементы&lt;/strong&gt; , которые являются частью &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;спецификации веб-компонентов&lt;/a&gt; . Это потому, что синтаксис компонентов Vue в общих чертах смоделирован после спецификации. Например, компоненты Vue реализуют &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; и специальный атрибут &lt;code&gt;is&lt;/code&gt; . Однако есть несколько ключевых отличий:</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">Вы,возможно,заметили,что мы можем достичь того же результата,используя метод в выражении:</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">Возможно, вы не учли предостережения об обнаружении изменений &lt;a href=&quot;list#Caveats&quot;&gt;с массивами&lt;/a&gt; или &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;объектами&lt;/a&gt; , или вы можете полагаться на состояние, которое не отслеживается системой реактивности Vue, например, с &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f78a45e93ff614ad4d560280cdd81744a9547eeb" translate="yes" xml:space="preserve">
          <source>You may notice that the animations shown above are using things like &lt;code&gt;transforms&lt;/code&gt;, and applying strange properties like &lt;code&gt;perspective&lt;/code&gt;- why were they built that way instead of just using &lt;code&gt;margin&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; etc?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">Вы можете это заметить:</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">Вы можете спросить, зачем нам и &lt;code&gt;slots()&lt;/code&gt; и &lt;code&gt;children&lt;/code&gt; . Разве &lt;code&gt;slots().default&lt;/code&gt; будут такими же, как &lt;code&gt;children&lt;/code&gt; ? В некоторых случаях да - но что, если у вас есть функциональный компонент со следующими дочерними элементами?</target>
        </trans-unit>
        <trans-unit id="f4b169dfdbff18ce5e5cf4146c1cf33c657dfab8" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &quot;separation of concerns&quot;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">Вы можете быть обеспокоены тем, что весь этот подход к прослушиванию событий нарушает старые добрые правила &amp;laquo;разделения ответственности&amp;raquo;. Будьте уверены - поскольку все функции и выражения обработчика Vue строго привязаны к ViewModel, который обрабатывает текущее представление, это не вызовет каких-либо трудностей с обслуживанием. Фактически, использование &lt;code&gt;v-on&lt;/code&gt; дает несколько преимуществ :</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">Возможно,у вас возникнет соблазн решить эту проблему,вложив дочерние компоненты в каталоги,названные в честь их родителей.Например:</target>
        </trans-unit>
        <trans-unit id="a47591adc396778366644573330c716aad893852" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &quot;search&quot; directory, then all the settings components under a &quot;settings&quot; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">У вас может возникнуть соблазн решить эту проблему по-другому, вложив все компоненты поиска в каталог &amp;laquo;search&amp;raquo;, а затем все компоненты настроек в каталог &amp;laquo;settings&amp;raquo;. Мы рекомендуем рассматривать этот подход только в очень больших приложениях (например, более 100 компонентов) по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">Вы можете подумать,что это заставит Vue выбросить существующий DOM и перемотать весь список-к счастью,это не так.Vue реализует некоторые умные эвристики для максимизации повторного использования DOM-элементов,поэтому замена массива на другой массив,содержащий перекрывающиеся объекты,является очень эффективной операцией.</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">Обычно вам не нужно их использовать, но они доступны в случаях, когда вам нужно вручную прослушивать события в экземпляре компонента. Они также могут быть полезны как инструмент организации кода. Например, вы часто можете увидеть этот шаблон для интеграции сторонней библиотеки:</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">Вы передаете свойство маршрутизатора экземпляру Vue:</target>
        </trans-unit>
        <trans-unit id="efb25a0ae9444bc1df853a464d4343356ffb5415" translate="yes" xml:space="preserve">
          <source>You probably have noticed the use of &lt;code&gt;toRefs&lt;/code&gt; at the top of our &lt;code&gt;setup&lt;/code&gt;. This is to ensure our watcher will react to changes made to the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6607184e34ec98c705e8936d4bd119debd7a5883" translate="yes" xml:space="preserve">
          <source>You should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">Вы должны убедиться, что ваше начальное значение для &lt;code&gt;text&lt;/code&gt; - &amp;laquo;привет, мир&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0388064a0faab22748fe939b523209cc3a4161d9" translate="yes" xml:space="preserve">
          <source>You should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">Вы все еще имеете доступ к исходному значению реквизита.</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">Вы бы добавили новые,реактивные свойства с:</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">Теперь ты будешь писать:</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">Тебе бы пригодилось:</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">Вам нужно будет обновить его так:</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">Вы заметите , что если вы выбираете запись, переключатель в &lt;em&gt;архиве&lt;/em&gt; вкладку, а затем переключиться обратно на &lt;em&gt;сообщения&lt;/em&gt; , он больше не показывает выбранную запись. Это потому, что каждый раз, когда вы переключаетесь на новую вкладку, Vue создает новый экземпляр &lt;code&gt;currentTabComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">Позже вы увидите другие примеры модификаторов &lt;a href=&quot;events#Event-Modifiers&quot;&gt;для &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;forms#Modifiers&quot;&gt;для &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt; , когда мы исследуем эти функции.</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">Вы также видели реквизиты, динамически назначаемые с помощью &lt;code&gt;v-bind&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="e7be35175595e36028a58566d499b0922b290b29" translate="yes" xml:space="preserve">
          <source>You'll find very quickly that &lt;code&gt;out-in&lt;/code&gt; is the state you will want most of the time 😃</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534161e1c7e94319d05a92ec6723a8bacc8c01a4" translate="yes" xml:space="preserve">
          <source>You'll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daeca355004e5e6b6695c8995c5901fed3362699" translate="yes" xml:space="preserve">
          <source>You'll see other examples of modifiers later, &lt;a href=&quot;events#event-modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a835cf811b8522c8db0e1f6d873fc28bdc60bb" translate="yes" xml:space="preserve">
          <source>You've also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt; or its shortcut, the &lt;code&gt;:&lt;/code&gt; character, such as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b27e33e416edbd67daffe51a424c0c9ef6b0f3" translate="yes" xml:space="preserve">
          <source>Your browser does not support the video tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">Ваш встраиваемый шаблон должен быть определен внутри DOM-элемента,к которому прикреплена Vue.</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">Ваш x-шаблон должен быть определен вне DOM-элемента,к которому прикреплен Vue.</target>
        </trans-unit>
        <trans-unit id="719b3279429110b4281221c4c4d4388f5c5f6d57" translate="yes" xml:space="preserve">
          <source>ZoomText (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954963c855d044c40d394debb8685e798d25e0c3" translate="yes" xml:space="preserve">
          <source>Zooming Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a221925ebff8ab7b21b8e492fd8afd314da61e41" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/eslint-plugin-vue&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b02ba7769882289f391dd6032af22b8a8bcfc" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/jsx-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25af989e02d5c99908ae438d2926502894ee2e7e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/rollup-plugin-vue/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baa16f6d48ca446fc08d35723e042c4ab28008f" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-class-component/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36204eda54f3ff6c52797fd1a52e5a030c6b5463" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-loader/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8ba12c942b8b26403cd1f4cc7f6445d6ba6cd3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-test-utils-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[] Синтаксис для массивов в запросах &lt;sup&gt;удален.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">объект параметров компонента</target>
        </trans-unit>
        <trans-unit id="aac58ea6af883add3a2d5783edf0931a374353ca" translate="yes" xml:space="preserve">
          <source>a component's options object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">расчётное имущество</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">свойство данных,с помощью реквизита,используемого для установки его значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">массив строк,или</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">объект,где ключами являются локальное имя привязки,а значением-либо то,либо другое:</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">объект,где:</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">компоненты-предки не должны знать, какие потомки используют предоставляемые им свойства</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">и пользовательские JavaScript-крючки:</target>
        </trans-unit>
        <trans-unit id="467081e5090da9dbbbeef46980aa3215471c51a8" translate="yes" xml:space="preserve">
          <source>app.component</source>
          <target state="translated">app.component</target>
        </trans-unit>
        <trans-unit id="5242c228688e376d238375da2e61daa4d72f01db" translate="yes" xml:space="preserve">
          <source>app.config</source>
          <target state="translated">app.config</target>
        </trans-unit>
        <trans-unit id="18219ca7f262cc06aea854c86b553561b308e57f" translate="yes" xml:space="preserve">
          <source>app.config.globalProperties (&lt;a href=&quot;#vue-prototype-replaced-by-config-globalproperties&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a870440d8c7f82a6a1f2568c003080c77c5339e" translate="yes" xml:space="preserve">
          <source>app.config.isCustomElement (&lt;a href=&quot;#config-ignoredelements-is-now-config-iscustomelement&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85ceb7e6fd9d135c221589e806583d76513472" translate="yes" xml:space="preserve">
          <source>app.directive</source>
          <target state="translated">app.directive</target>
        </trans-unit>
        <trans-unit id="4c693e55b34812b4bae7c65ed8632f25ecb7dd87" translate="yes" xml:space="preserve">
          <source>app.mixin</source>
          <target state="translated">app.mixin</target>
        </trans-unit>
        <trans-unit id="1f2300b97dba467c4a8c4a56ebdb0ce97fcb714d" translate="yes" xml:space="preserve">
          <source>app.use (&lt;a href=&quot;#a-note-for-plugin-authors&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e046efd172457735b44f7929fe7efc0747f1" translate="yes" xml:space="preserve">
          <source>aria-describedby</source>
          <target state="translated">aria-describedby</target>
        </trans-unit>
        <trans-unit id="e4f0ab341d5e8e82e3d8dc99926c2333f783f688" translate="yes" xml:space="preserve">
          <source>aria-hidden=&quot;true&quot;</source>
          <target state="translated">aria-hidden=&quot;true&quot;</target>
        </trans-unit>
        <trans-unit id="c399d0d9385cb50ef9a74487c5e1ea13ac3f984e" translate="yes" xml:space="preserve">
          <source>aria-label</source>
          <target state="translated">aria-label</target>
        </trans-unit>
        <trans-unit id="ec0bffb04210018ec41d270900cc33a6714de325" translate="yes" xml:space="preserve">
          <source>aria-labelledby</source>
          <target state="translated">aria-labelledby</target>
        </trans-unit>
        <trans-unit id="f68ce285b8377013d64f60cad53e6825b9961b6a" translate="yes" xml:space="preserve">
          <source>as a performance optimization, because they initialized much faster than stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77cad1467608c98b4675073084c13ea3aba2ffb" translate="yes" xml:space="preserve">
          <source>aside</source>
          <target state="translated">aside</target>
        </trans-unit>
        <trans-unit id="394bb07928a366287168902c26665311049fa093" translate="yes" xml:space="preserve">
          <source>authoring tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">автоматически применять классы для CSS-переходов и анимации</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">подкрепленные этими данными:</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">иметь возможность копировать и вставлять большинство примеров кода сообщества без модификации</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="8acebefba44388f598e2b99e8302ab67d355632c" translate="yes" xml:space="preserve">
          <source>beforeUnmount</source>
          <target state="translated">beforeUnmount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="77c5f425bb928c51b842ddf1e44748f43c932105" translate="yes" xml:space="preserve">
          <source>bind &amp;rarr; &lt;strong&gt;beforeMount&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fb8d92972382b39b524ce7f8cdc6213d95500" translate="yes" xml:space="preserve">
          <source>binding</source>
          <target state="translated">binding</target>
        </trans-unit>
        <trans-unit id="8e2b6e21dfdfc190c998d11093ac469ffd7f3aed" translate="yes" xml:space="preserve">
          <source>breaking</source>
          <target state="translated">breaking</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">флажки и радиокнопки используют свойство &lt;code&gt;checked&lt;/code&gt; и событие &lt;code&gt;change&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="db88192ef37fddf9df1a8a94d3fa600728fa8e81" translate="yes" xml:space="preserve">
          <source>checking your codebase for &lt;code&gt;.sync&lt;/code&gt; usage and replace it with &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cbf9910961b7b720be422c5227a48b45481be1" translate="yes" xml:space="preserve">
          <source>child components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42685f11da91a55b1f5c5b782edb2f0fc1dd5148" translate="yes" xml:space="preserve">
          <source>children</source>
          <target state="translated">children</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">отображаемые цвета</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="ddcc491de82ebec3c03853395e5b60c154cbc452" translate="yes" xml:space="preserve">
          <source>componentUpdated &amp;rarr; &lt;strong&gt;updated&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f568e3b2e689e9753b26737cdc027b1633a22b7e" translate="yes" xml:space="preserve">
          <source>createApp</source>
          <target state="translated">createApp</target>
        </trans-unit>
        <trans-unit id="43caa510c0daadd6d3dc4ad43a5427148c2e6d9c" translate="yes" xml:space="preserve">
          <source>createRenderer</source>
          <target state="translated">createRenderer</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="d8844c3455799a9155c640b8dcfd223ef31c8542" translate="yes" xml:space="preserve">
          <source>defineAsyncComponent</source>
          <target state="translated">defineAsyncComponent</target>
        </trans-unit>
        <trans-unit id="0b351e6c4acf449188607d84ef9ac58fe7aff147" translate="yes" xml:space="preserve">
          <source>defineComponent</source>
          <target state="translated">defineComponent</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">дочерним компонентам не нужно знать, откуда берутся внедренные свойства</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="3d981bf920ab98c455a9796d062745b9d6b5cbfb" translate="yes" xml:space="preserve">
          <source>directive</source>
          <target state="translated">directive</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">делает то же самое:</target>
        </trans-unit>
        <trans-unit id="72ef9ecc0ee2490979708ebb01e137eae4c8f425" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;.enter&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="01b78ec3ef69d582c34c04fd02137b4b2a0b2057" translate="yes" xml:space="preserve">
          <source>ensure that all your components document their events with the &lt;code&gt;emits&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="72f59f31388477ad92fbebfc6b623eb3ba553f3e" translate="yes" xml:space="preserve">
          <source>eslint-plugin-vue</source>
          <target state="translated">eslint-plugin-vue</target>
        </trans-unit>
        <trans-unit id="e9922bd8a80da72306d79eeaf9a6b98cb64268db" translate="yes" xml:space="preserve">
          <source>event: &lt;code&gt;input&lt;/code&gt; -&amp;gt; &lt;code&gt;update:modelValue&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">предоставляет те же события, что и &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">предоставляет те же свойства, что и &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; за исключением &lt;code&gt;mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="d7eb6b340a11a367a1bec55e4a421d949214759f" translate="yes" xml:space="preserve">
          <source>footer</source>
          <target state="translated">footer</target>
        </trans-unit>
        <trans-unit id="acb51e7c16264c729e7521b40c23a4b9d8986b65" translate="yes" xml:space="preserve">
          <source>for all &lt;code&gt;v-model&lt;/code&gt;s without arguments, make sure to change props and events name to &lt;code&gt;modelValue&lt;/code&gt; and &lt;code&gt;update:modelValue&lt;/code&gt; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b39815c187d832cef3239eb7a77580728dc47" translate="yes" xml:space="preserve">
          <source>form</source>
          <target state="translated">form</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">полностью поддерживает как Vue 1.0,так и 2.0.</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="8574ae3fb0102e604b132e245a7a13501af7382a" translate="yes" xml:space="preserve">
          <source>globalProperties</source>
          <target state="translated">globalProperties</target>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="594fd1615a341c77829e83ed988f137e1ba96231" translate="yes" xml:space="preserve">
          <source>header</source>
          <target state="translated">header</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="33651e92d7f8755c3775bf7e6f2865577e7988de" translate="yes" xml:space="preserve">
          <source>how to build our package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">в 2.6.0+. См. &lt;a href=&quot;#Named-Slots&quot;&gt;Здесь&lt;/a&gt; новый рекомендуемый синтаксис.</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">в 2.6.0+. См. &lt;a href=&quot;#Scoped-Slots&quot;&gt;Здесь&lt;/a&gt; новый рекомендуемый синтаксис.</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="3014bf5a29cbc2f5b4c95b4c0f384113201b257e" translate="yes" xml:space="preserve">
          <source>inserted &amp;rarr; &lt;strong&gt;mounted&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9587db9f8e8a4535e8dcb6eaa79c2cf675a7519b" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as &lt;a href=&quot;https://animate.style/&quot;&gt;Animate.css (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">интегрировать сторонние CSS-анимационные библиотеки,такие как Animate.css.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
