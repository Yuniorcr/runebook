<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3018c9188b3b3d4a23f0075a78973fd85df51141" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;app.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">Однако, если вам требуется / импортировать компоненты с помощью &lt;strong&gt;модульной системы&lt;/strong&gt; , например, через Webpack или Browserify, вы получите сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Однако, если вы исключили вышеуказанное и оказались в чрезвычайно редкой ситуации, когда вам нужно вручную принудительно обновить обновление, вы можете сделать это с помощью &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d036c8bdba9e735ef24169304153c34c8f3b798" translate="yes" xml:space="preserve">
          <source>However, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/instance-methods#forceupdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3610b4f1219dad3d7eab3e3d1d0df611f8efc2" translate="yes" xml:space="preserve">
          <source>However, in Vue 3, the performance of stateful components has improved to the point that the difference is negligible. In addition, stateful components now also include the ability to return multiple root nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">Однако в некоторых случаях вы можете захотеть использовать оба элемента в одном элементе, например, иметь анимацию CSS, запускаемую Vue, вместе с эффектом перехода CSS при наведении курсора. В этих случаях вам нужно будет явно объявить тип, о котором Vue будет заботиться, в атрибуте &lt;code&gt;type&lt;/code&gt; со значением &lt;code&gt;animation&lt;/code&gt; или &lt;code&gt;transition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">Однако,как и в случае с другими директивами,сокращение доступно только при наличии аргумента.Это означает,что следующий синтаксис недействителен:</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">Однако не все хотят использовать TypeScript. Во многих случаях использования меньшего масштаба внедрение системы типов может привести к большим накладным расходам, чем к увеличению производительности. В таких случаях лучше использовать Vue, поскольку использование Angular без TypeScript может оказаться сложной задачей.</target>
        </trans-unit>
        <trans-unit id="73e089bb95641b06647f01ce72a8df5b24a857f3" translate="yes" xml:space="preserve">
          <source>However, sometimes a part of a component's template belongs to this component logically, while from a technical point of view, it would be preferable to move this part of the template somewhere else in the DOM, outside of the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a38a0e30cb26490e5f05809a78f3a4c9e4964e" translate="yes" xml:space="preserve">
          <source>However, that level of flexibility is usually not required. It's often possible to replace &lt;code&gt;resolveDynamicComponent&lt;/code&gt; with a more direct alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">Однако у внедрения зависимостей есть и обратные стороны. Он связывает компоненты вашего приложения с их текущей организацией, что затрудняет рефакторинг. Предоставленные свойства также не являются реактивными. Это сделано намеренно, потому что их использование для создания центрального хранилища данных масштабируется так же плохо, как и &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;использование &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt; для той же цели. Если свойства, которыми вы хотите поделиться, являются специфическими для вашего приложения, а не общими, или если вы когда-нибудь захотите обновить предоставленные данные внутри предков, то это хороший признак того, что вам, вероятно, понадобится реальное решение для управления состоянием, такое как &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a5d7767d7e276c46e20eda1a815bca70a1441e7" translate="yes" xml:space="preserve">
          <source>However, there are times where we need to update the data inside of the component where the data is injected. In this scenario, we recommend providing a method that is responsible for mutating the reactive property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eff740b8e2a37ddfa14b1eb95316301f5907a17" translate="yes" xml:space="preserve">
          <source>However, this approach is potentially problematic for components that are reused because they'll all share the same debounced function. To keep the component instances independent from each other, we can add the debounced function in the &lt;code&gt;created&lt;/code&gt; lifecycle hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">Однако это может быть немного многословным, если у вас несколько условных классов. Вот почему также можно использовать синтаксис объекта внутри синтаксиса массива:</target>
        </trans-unit>
        <trans-unit id="85cd8c9d4719bfdd0176caad9283969d3ff23830" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">Однако это не будет автоматически передавать какие-либо данные в компонент, поскольку компоненты имеют собственные изолированные области действия. Чтобы передать итерированные данные в компонент, мы также должны использовать props:</target>
        </trans-unit>
        <trans-unit id="fc101cca76508ab598f5b4b585c1e6780fad8310" translate="yes" xml:space="preserve">
          <source>However, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0c334fd910aa57b2a33967cd21852214b1f058" translate="yes" xml:space="preserve">
          <source>However, this won't work if we try to provide some component instance property here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004b32fe588f88c41b42b4992994b442c861a69c" translate="yes" xml:space="preserve">
          <source>However, watching a reactive object or array will always return a reference to the current value of that object for both the current and previous value of the state. To fully watch deeply nested objects and arrays, a deep copy of values may be required. This can be achieved with a utility such as &lt;a href=&quot;https://lodash.com/docs/4.17.15#cloneDeep&quot;&gt;lodash.cloneDeep (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">Однако при общении между далекими потомками / предками &lt;code&gt;$emit&lt;/code&gt; вам не поможет. Вместо этого простейшим возможным обновлением было бы использование централизованного концентратора событий. Это дает дополнительное преимущество, позволяя вам обмениваться данными между компонентами независимо от того, где они находятся в дереве компонентов - даже между братьями и сестрами! Поскольку экземпляры Vue реализуют интерфейс генератора событий, вы можете использовать для этой цели пустой экземпляр Vue.</target>
        </trans-unit>
        <trans-unit id="a6f9aa6296c86949de208bc5300b04f5bbd8e693" translate="yes" xml:space="preserve">
          <source>However, when using the composition API to explicitly create reactive objects, the best practice is to never hold a reference to the original raw object and only work with the reactive version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">Однако вы все равно можете обернуть содержимое слота по умолчанию в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; , если хотите быть явным:</target>
        </trans-unit>
        <trans-unit id="29e3b3dcfde111c535bca8f3776cc120ca6d19c2" translate="yes" xml:space="preserve">
          <source>Hybrid-App Development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">Я надеюсь, что прямо сейчас вы читаете это предложение на предпочитаемом вами языке. Если нет, не могли бы вы помочь нам туда добраться?</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">Рад, что ты спросил! Ответ - нет. Около 90% API осталось прежним, а основные концепции не изменились. Это длинно, потому что мы предлагаем очень подробные объяснения и включать множество примеров. Будьте уверены, &lt;strong&gt;это не то, что вам нужно читать сверху вниз!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc4427647cd69fcbdf57ea287139ca162e4fbe9" translate="yes" xml:space="preserve">
          <source>IDE Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615578cf02895b5ceadb54ba5821d7c10372fcdc" translate="yes" xml:space="preserve">
          <source>IDL attr &amp;amp; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb8f6c14252759cd8673c61a24376d32e17b93a" translate="yes" xml:space="preserve">
          <source>Icons</source>
          <target state="translated">Icons</target>
        </trans-unit>
        <trans-unit id="31aa3a07a8b9c23bb9e5b73c71b5e12fcbbbc57f" translate="yes" xml:space="preserve">
          <source>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">Если шаблон &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; содержал элемента &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; , любое содержимое, предоставленное между его открывающим и закрывающим тегами, будет отброшено.</target>
        </trans-unit>
        <trans-unit id="74b581a78f3cd91716bbaddac8b29eb9776b03b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; contains a Vue component, it will remain a logical child component of the &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt;'s parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b06f1fcb96eb40ac85f5cac5c66c2b155891fcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;todo-button&amp;gt;&lt;/code&gt;'s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201ba7f76ed37c8b5c2f564825de9c9ebb281704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;config.isCustomElement&lt;/code&gt; is assigned to when using a runtime-only build, a warning will be emitted instructing the user to pass the option in the build setup instead;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">Если аргумент &lt;code&gt;elementOrSelector&lt;/code&gt; не указан , шаблон будет отображаться как элемент вне документа, и вам придется использовать собственный DOM API, чтобы вставить его в документ самостоятельно.</target>
        </trans-unit>
        <trans-unit id="0b1be49ac332b8febaafa2d94f48398afa699acf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flush&lt;/code&gt; is set to &lt;code&gt;'sync'&lt;/code&gt;, the callback will be called synchronously, as soon as the value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Если &lt;code&gt;isButtonDisabled&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;disabled&lt;/code&gt; атрибут даже не будет включен в отображаемый элемент &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1c53b1161887bd5b64d08a53a8b025bd8d8769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object can be accessed in the component's template, as well as the properties of the &lt;code&gt;props&lt;/code&gt; passed into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72354f5499649f8d82fce993f6a021a2603b963e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object will be merged on to the render context for the component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eb06e2e36786f2679f43f6de53626bf2d00da9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;title&lt;/code&gt; is an optional prop, it could be missing from &lt;code&gt;props&lt;/code&gt;. In that case, &lt;code&gt;toRefs&lt;/code&gt; won't create a ref for &lt;code&gt;title&lt;/code&gt;. Instead you'd need to use &lt;code&gt;toRef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Если я обновлю Vue 2,нужно ли мне также обновить Vuex и Vue Router?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Если бы у Vue не было этого правила, нажатие одной кнопки повлияло бы на данные &lt;em&gt;всех других экземпляров&lt;/em&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Если экземпляр Vue не получил опцию &lt;code&gt;el&lt;/code&gt; при создании, он будет в &amp;laquo;размонтированном&amp;raquo; состоянии без связанного элемента DOM. &lt;code&gt;vm.$mount()&lt;/code&gt; можно использовать для ручного запуска монтирования отключенного экземпляра Vue.</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">Если компонент имеет смысл только в контексте одного родительского компонента,то эта связь должна быть очевидна в его названии.Поскольку редакторы обычно упорядочивают файлы в алфавитном порядке,это также позволяет хранить эти связанные файлы рядом друг с другом.</target>
        </trans-unit>
        <trans-unit id="d6080ced28d2ad5267aab8c60cb9e3ee41fcc9d3" translate="yes" xml:space="preserve">
          <source>If a component receives slots from its parent, they can be passed on directly to a child component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed6b31ac8ff605e55f7cdbf21aabd756efc8bb1" translate="yes" xml:space="preserve">
          <source>If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">Если во время рендеринга компонента возникает ошибка времени выполнения, она будет передана в глобальную &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; конфигурации Vue.config.errorHandler, если она была установлена. Было бы неплохо использовать этот хук вместе с сервисом отслеживания ошибок, таким как &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt; , который обеспечивает &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;официальную интеграцию&lt;/a&gt; для Vue.</target>
        </trans-unit>
        <trans-unit id="642e3ac102c57674c11d312a80ed33358ce20b95" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component's render, it will be passed to the global &lt;code&gt;app.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry (opens new window)&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration (opens new window)&lt;/a&gt; for Vue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec559a16f0238f7c29fe23c19c2dec1b891987a" translate="yes" xml:space="preserve">
          <source>If an object is assigned as a ref's value, the object is made deeply reactive by the &lt;a href=&quot;basic-reactivity#reactive&quot;&gt;reactive&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">Если даны и событие,и обратный вызов,удалите слушателя только для этого конкретного вызова.</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">Если вместо этого вы намерены условно пропустить выполнение цикла, вы можете поместить &lt;code&gt;v-if&lt;/code&gt; в элемент оболочки (или &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">Если его нужно ввести из свойства с другим именем, используйте &lt;code&gt;from&lt;/code&gt; для обозначения исходного свойства:</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">Если в цепочке наследования или родительской цепочке компонента существует несколько хуков &lt;code&gt;errorCaptured&lt;/code&gt; , все они будут вызываться при одной и той же ошибке.</target>
        </trans-unit>
        <trans-unit id="9f4ae8d54b54e963413f7f1cfbf43652de62cd55" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">Если ни функция &lt;code&gt;render&lt;/code&gt; ни параметр &lt;code&gt;template&lt;/code&gt; не указаны, встроенный в DOM HTML-код монтируемого элемента DOM будет извлечен как шаблон. В этом случае следует использовать сборку Vue Runtime + Compiler.</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">Если переходы / анимация CSS не обнаружены и не предусмотрены перехватчики JavaScript, операции DOM для вставки и / или удаления будут выполняться немедленно в следующем кадре (Примечание: это кадр анимации браузера, отличный от концепции &lt;code&gt;nextTick&lt;/code&gt; во Vue ).</target>
        </trans-unit>
        <trans-unit id="b064733da54289be43813af974ffc4066d5f06c7" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue's concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">Если аргументов нет,удалите всех слушателей мероприятия;</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">Если предоставляется только данное мероприятие,удалите всех слушателей для данного мероприятия;</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Если функция render присутствует в опции Vue,то шаблон будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">При необходимости можно получить глубокий клон исходного объекта, передав &lt;code&gt;vm.$data&lt;/code&gt; через &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">Если это так, пожалуйста, создайте вилку репозитория для &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;этих документов&lt;/a&gt; или любой другой официально поддерживаемой документации, а затем приступайте к переводу. Как только вы добьетесь некоторого прогресса, откройте проблему или запрос на вытягивание в основном репозитории, и мы обратимся к другим участникам, которые помогут вам.</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;errorCaptured&lt;/code&gt; сам выдает ошибку, и эта ошибка, и исходная зафиксированная ошибка отправляются в глобальный &lt;code&gt;config.errorHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="009579549300fafa52dbcc22a4317c4e5cd4cffe" translate="yes" xml:space="preserve">
          <source>If the VNode is always an HTML element then we can pass its name directly to &lt;code&gt;h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20828a01491d3d176994e014e8243f15e5cec364" translate="yes" xml:space="preserve">
          <source>If the bound value is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; then the attribute will not be included on the rendered element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">Если компонент является функциональным, функция рендеринга также получает дополнительный аргумент &lt;code&gt;context&lt;/code&gt; , который обеспечивает доступ к контекстным данным, поскольку функциональные компоненты не имеют экземпляров.</target>
        </trans-unit>
        <trans-unit id="778a0693bfbcff846a92b8e406613e51b0ccd2e7" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &quot;unselected&quot; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">Если начальное значение вашего выражения &lt;code&gt;v-model&lt;/code&gt; не соответствует ни одной из опций, элемент &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; будет отображаться в &amp;laquo;невыделенном&amp;raquo; состоянии. В iOS это приведет к тому, что пользователь не сможет выбрать первый элемент, потому что iOS в этом случае не запускает событие изменения. Поэтому рекомендуется указать отключенный параметр с пустым значением, как показано в примере выше.</target>
        </trans-unit>
        <trans-unit id="e40b666fff5068ba41fcb1fb1d0acd4ce7a992d8" translate="yes" xml:space="preserve">
          <source>If the methods &lt;code&gt;toTitleDate&lt;/code&gt; or &lt;code&gt;formatDate&lt;/code&gt; access any reactive data then it will be tracked as a rendering dependency, just as if it had been used in the template directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c148d9a336221fd54485bc5ad61e9a1e229c73a" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a &lt;code&gt;querySelector&lt;/code&gt; and use the selected element's innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">Если строка начинается с символа &lt;code&gt;#&lt;/code&gt; , она будет использоваться как querySelector и использовать innerHTML выбранного элемента в качестве строки шаблона. Это позволяет использовать обычный трюк &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; для включения шаблонов.</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">Если компонент перехода предоставил &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;перехватчики JavaScript&lt;/a&gt; , эти перехватчики будут вызываться в соответствующее время.</target>
        </trans-unit>
        <trans-unit id="2ecd8a7c716c95da925d56a24dbff68dbe3cb732" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#javascript-hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db2c73fe7d859c72406458c11b699f22e3d0c62" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0743f97ca671f5c9ea8b899455cd80afbfe69b8a" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b75b60aea9cf846f97bdc9f59bd5b35161f3f" translate="yes" xml:space="preserve">
          <source>If there are no props then the children can usually be passed as the second argument. In cases where that would be ambiguous, &lt;code&gt;null&lt;/code&gt; can be passed as the second argument to keep the children as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">Если вы предпочитаете использовать сторонний маршрутизатор, например &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; или &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt; , интеграция &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;также проста&lt;/a&gt; . Вот &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;полный пример&lt;/a&gt; использования Page.js.</target>
        </trans-unit>
        <trans-unit id="4a4deb4463100ef774d066f03629b21cdc02fb26" translate="yes" xml:space="preserve">
          <source>If there's a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js (opens new window)&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director (opens new window)&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly straightforward (opens new window)&lt;/a&gt;. Here's a &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/tree/pagejs&quot;&gt;complete example (opens new window)&lt;/a&gt; using Page.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c1c9810ed91033d943c8c7395ef1ff554427a5" translate="yes" xml:space="preserve">
          <source>If this component received an &lt;code&gt;id&lt;/code&gt; attribute and a &lt;code&gt;v-on:close&lt;/code&gt; listener, the &lt;code&gt;$attrs&lt;/code&gt; object will now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">Если эта опция доступна при создании экземпляра, экземпляр немедленно перейдет в режим компиляции; в противном случае пользователю придется явно вызвать &lt;code&gt;vm.$mount()&lt;/code&gt; чтобы вручную запустить компиляцию.</target>
        </trans-unit>
        <trans-unit id="31295f224ed5601010e4bf662145dc4776218b9c" translate="yes" xml:space="preserve">
          <source>If using a build step: pass the &lt;code&gt;isCustomElement&lt;/code&gt; option to the Vue template compiler. If using &lt;code&gt;vue-loader&lt;/code&gt;, this should be passed via &lt;code&gt;vue-loader&lt;/code&gt;'s &lt;code&gt;compilerOptions&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a7080e683c7a64c86aa780d504104684e2c8cf" translate="yes" xml:space="preserve">
          <source>If using on-the-fly template compilation, pass it via &lt;code&gt;app.config.isCustomElement&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330f73efd7b8fa6913e10b944928e9083afdfa3e" translate="yes" xml:space="preserve">
          <source>If using string keys or non-typed symbols, the type of the injected value will need to be explicitly declared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cd39cc6503370abf981fdea53d1f2a726cdba6" translate="yes" xml:space="preserve">
          <source>If we need to resolve a component by name then we can call &lt;code&gt;resolveComponent&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8df13c30163597104a70bd9ea70be42706e226" translate="yes" xml:space="preserve">
          <source>If we need to update the list items, we do so in JavaScript, using the reactivity we mentioned earlier. We then make all the changes to the JavaScript copy, the virtual DOM, and perform a diff between this and the actual DOM. Only then do we make our updates to just what has changed. The Virtual DOM allows us to make performant updates to our UIs!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46541c29071775d267576f2d4f8b07035cf486fe" translate="yes" xml:space="preserve">
          <source>If we update the first value, the sum is not adjusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf205117227a86a1eb58ae18d3718adb780a6c9" translate="yes" xml:space="preserve">
          <source>If we want to add a custom element defined outside of Vue (e.g. using the Web Components API), we need to 'instruct' Vue to treat it as a custom element. Let's use the following template as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fcea7a8afcf7157ecc5757dd89328f51812842" translate="yes" xml:space="preserve">
          <source>If we want to pass the length of todo-items directly to &lt;code&gt;TodoListStatistics&lt;/code&gt;, we would pass the prop down the hierarchy: &lt;code&gt;TodoList&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListFooter&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListStatistics&lt;/code&gt;. With provide/inject approach, we can do this directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb928534fcb45cb1f88d282a370e12143b6fe8" translate="yes" xml:space="preserve">
          <source>If we wanted to change prop or event names to something different, we would need to add a &lt;code&gt;model&lt;/code&gt; option to &lt;code&gt;ChildComponent&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150e823a3a8131b7c978145134a1ff444cb639e" translate="yes" xml:space="preserve">
          <source>If we were to apply these states to a transition, it would look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498688a211069d7a5c4191f5c3fef214e9f67f92" translate="yes" xml:space="preserve">
          <source>If we're writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2fb212b41d06f075a5186ea4df933d818c54bc" translate="yes" xml:space="preserve">
          <source>If you already have the &lt;code&gt;tag&lt;/code&gt; prop defined in your Vue 2 code, like in the example above, everything will work as before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">Если вы также хотите применить переход к начальному рендерингу узла, вы можете добавить атрибут &lt;code&gt;appear&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">Если вы поклонник CSS-in-JS, многие популярные библиотеки CSS-in-JS поддерживают Vue (например, &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; и &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-Emotion&lt;/a&gt; ). Основное различие между React и Vue заключается в том, что метод стилизации по умолчанию в Vue заключается в использовании более знакомых тегов &lt;code&gt;style&lt;/code&gt; в &lt;a href=&quot;single-file-components&quot;&gt;однофайловых компонентах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">Если вы опытный фронтенд-разработчик и хотите узнать, как Vue сравнивается с другими библиотеками / фреймворками, ознакомьтесь со &lt;a href=&quot;guide/comparison&quot;&gt;статьей Сравнение с другими фреймворками&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">Если вы разрабатываете большой проект,работаете с другими разработчиками или иногда включаете HTML/CSS сторонних разработчиков (например,из Auth0),последовательное определение границ проекта гарантирует,что ваши стили будут применяться только к тем компонентам,для которых они предназначены.</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">Если вы знакомы с концепциями Virtual DOM и предпочитаете грубую мощь JavaScript, вы также можете &lt;a href=&quot;render-function&quot;&gt;напрямую писать функции рендеринга&lt;/a&gt; вместо шаблонов с дополнительной поддержкой JSX.</target>
        </trans-unit>
        <trans-unit id="4e11ad49faa82bff233bacdfdaea43495b37d7cb" translate="yes" xml:space="preserve">
          <source>If you are relying on this override functionality for &lt;code&gt;v-bind&lt;/code&gt;, we currently recommend ensuring that your &lt;code&gt;v-bind&lt;/code&gt; attribute is defined before individual properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f259b9cb4dd6eabd10bd96771a986250a3f5c4" translate="yes" xml:space="preserve">
          <source>If you are using Vue 2.x and below, you may be interested in some of the change detection caveats that exist for those versions, &lt;a href=&quot;change-detection&quot;&gt;explored in more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa108116f2ee5b4db44f6418ab708557dafa0b" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader (opens new window)&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Если вы используете Webpack и предпочитаете разделять файлы JavaScript и шаблонов, вы можете использовать &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt; , который также преобразует файлы шаблонов в функции рендеринга JavaScript на этапе сборки.</target>
        </trans-unit>
        <trans-unit id="b51a0d95775f6901a19eb4a518eb8294d6f3dd90" translate="yes" xml:space="preserve">
          <source>If you are using a custom Webpack configuration &lt;code&gt;ts-loader&lt;/code&gt; needs to be configured to parse &lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;/code&gt; blocks in &lt;code&gt;.vue&lt;/code&gt; files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9339c27c9dc6e2ed60dd362c87632e60f6c3e6b" translate="yes" xml:space="preserve">
          <source>If you are using filters that were globally registered and then used throughout your app, it's likely not convenient to replace them with computed properties or methods in each individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">Если вы используете родные Модули ES,существует также сборка,совместимая с Модулями ES:</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">Если вы используете функциональные компоненты на основе шаблонов, вам также придется вручную добавить атрибуты и слушатели. Поскольку у нас есть доступ к индивидуальному содержимому контекста, мы можем использовать &lt;code&gt;data.attrs&lt;/code&gt; для передачи любых HTML-атрибутов и &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;(псевдоним для &lt;code&gt;data.on&lt;/code&gt; )&lt;/em&gt; для передачи любых слушателей событий.</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">Если вы используете полную сборку, то есть напрямую включаете Vue через тег скрипта без инструмента сборки, убедитесь, что вы используете уменьшенную версию ( &lt;code&gt;vue.min.js&lt;/code&gt; ) для производства. Обе версии можно найти в &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Руководстве&lt;/a&gt; по установке .</target>
        </trans-unit>
        <trans-unit id="5a4b189cf522ce6e29c54b33668d5386275afda1" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version for production. This can be found in the &lt;a href=&quot;../installation#cdn&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b60cd1fba6c46a688fbdbb235e044cb83c5b7b5" translate="yes" xml:space="preserve">
          <source>If you are using third party plugins such as &lt;code&gt;Vuex&lt;/code&gt; or &lt;code&gt;Vue Router&lt;/code&gt;, always check the documentation to know what that particular plugin expects to receive as a second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e4fd881ce2746ee5cbf62bd67517fc2f4914a1" translate="yes" xml:space="preserve">
          <source>If you bundle your app with webpack with &lt;code&gt;target: 'node'&lt;/code&gt; and properly externalize &lt;code&gt;vue&lt;/code&gt;, this is the build that will be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2fe8b591e825c2bd65db72f8f115e0c3a56502" translate="yes" xml:space="preserve">
          <source>If you didn't have one defined &lt;em&gt;and&lt;/em&gt; your styling or other behaviors relied on the presence of the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; root element to work properly, simply add &lt;code&gt;tag=&quot;span&quot;&lt;/code&gt; to the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb198153df2b83a6a3a26e2ebd225100fb4f2173" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want a component to automatically inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component's options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">Если вы &lt;strong&gt;не&lt;/strong&gt; хотите, чтобы корневой элемент компонента наследовал атрибуты, вы можете установить &lt;code&gt;inheritAttrs: false&lt;/code&gt; в параметрах компонента. Например:</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">Если вы не объявляете &lt;code&gt;message&lt;/code&gt; в параметре данных, Vue предупредит вас, что функция рендеринга пытается получить доступ к несуществующему свойству.</target>
        </trans-unit>
        <trans-unit id="16f2472fe4831b78a6cfd9861a2ec950de0ec835" translate="yes" xml:space="preserve">
          <source>If you don't declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">Если вы обнаружите, что выведение типа или завершение членов не работают, аннотирование определенных методов может помочь решить эти проблемы. Использование параметра &lt;code&gt;--noImplicitAny&lt;/code&gt; поможет найти многие из этих неаннотированных методов.</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Если вам нужно принудительно обновить Vue, в 99,99% случаев вы где-то ошиблись.</target>
        </trans-unit>
        <trans-unit id="69e34e7997217094f6f692152e0f58e36b5ef7b7" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere. For example, you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt; property added after component creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">Если вы используете партиалы в важной для производительности части приложения, вам следует перейти на &lt;a href=&quot;render-function#Functional-Components&quot;&gt;функциональные компоненты&lt;/a&gt; . Они должны быть в простом файле JS / JSX (а не в файле &lt;code&gt;.vue&lt;/code&gt; ) и не иметь состояния и экземпляров, как частичные. Это делает рендеринг чрезвычайно быстрым.</target>
        </trans-unit>
        <trans-unit id="a40b516039aedc82e1c9170530033902c12726ed" translate="yes" xml:space="preserve">
          <source>If you have a complex type or interface, you can cast it using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions&quot;&gt;type assertion (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">Если у вас есть какие-либо вопросы о том, как вы можете более активно участвовать в жизни местного сообщества Vue, &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;обращайтесь&lt;/a&gt; на @Vuejs_Events !</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">Если у вас есть какие-либо тесты, запустите их и посмотрите, что по-прежнему не работает. Если у вас нет тестов, просто откройте приложение в браузере и следите за предупреждениями или ошибками во время навигации.</target>
        </trans-unit>
        <trans-unit id="96e155ed303418e4faa49bd76ee26339a7c63a25" translate="yes" xml:space="preserve">
          <source>If you inspect this element in your chrome developer tools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">Если вам нужно несколько псевдонимов,вы также можете использовать синтаксис массива:</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">Если вам нужно добавить новые маршруты после создания экземпляра маршрутизатора, вы можете заменить сопоставитель маршрутизатора новым, который включает маршрут, который вы хотите добавить:</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">Если вам нужно скомпилировать шаблоны на клиенте (например, передать строку в параметр &lt;code&gt;template&lt;/code&gt; или подключиться к элементу, используя его HTML-код в DOM в качестве шаблона), вам понадобится компилятор и, следовательно, полная сборка:</target>
        </trans-unit>
        <trans-unit id="ff7acc8749dfed6e4ff7f305eea543f1d2a84302" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the template option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c99f87095091faefdae01d0f1c8e79606b30cab" translate="yes" xml:space="preserve">
          <source>If you need to destructure your props, you can do this by utilizing the &lt;a href=&quot;reactivity-fundamentals#destructuring-reactive-state&quot;&gt;toRefs&lt;/a&gt; inside of the &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">Если вам необходимо программно генерировать маршруты при запуске приложения,вы можете сделать это,динамически проталкивая определения в массив маршрутов.Например:</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно сгруппировать переходы списка, вы можете контролировать время, установив и получив доступ к &lt;code&gt;data-index&lt;/code&gt; (или аналогичному атрибуту) для элемента. См. &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;Пример здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">Если вам нужна только очень простая маршрутизация и вы не хотите использовать полнофункциональную библиотеку маршрутизатора,вы можете сделать это,динамически отрисовав компонент уровня страниц,подобный этому:</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">Если вы снова &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; консоль JavaScript и введете app2.message = 'some new message' , вы снова увидите, что связанный HTML - в данном случае атрибут &lt;code&gt;title&lt;/code&gt; - был обновлен.</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">Если вы предпочитаете API на основе классов при объявлении компонентов, вы можете использовать официально поддерживаемый декоратор &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">Если вы предпочитаете что-то более интерактивное, вы также можете ознакомиться с &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;этой серией руководств по Scrimba&lt;/a&gt; , где вы найдете сочетание скринкастов и площадок для кода, которые вы можете приостановить и поиграть в любое время.</target>
        </trans-unit>
        <trans-unit id="026a80f81fcc351d7fe1000884a4c6e0166e6fc9" translate="yes" xml:space="preserve">
          <source>If you put the number two in the first cell, and the number 3 in the second and asked for the SUM, the spreadsheet would give it to you. No surprises there. But if you update that first number, the SUM automagically updates too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">Если вам действительно нужно переопределить другой &lt;code&gt;!important&lt;/code&gt; , вы должны использовать строковый синтаксис:</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">Если вы действительно хотите многократно дублировать один и тот же элемент/компонент,вы можете сделать это с помощью заводской функции.Например,следующая функция рендеринга является отличным способом отрисовки 20 идентичных параграфов:</target>
        </trans-unit>
        <trans-unit id="82b8fa8fd3b7f04299490484030ca94869913190" translate="yes" xml:space="preserve">
          <source>If you rely on watching array mutations, add the &lt;code&gt;deep&lt;/code&gt; property to ensure that your callback is triggered correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">Если вы все еще хотите вызвать функцию разворота внутри обратного вызова,сначала проверьте ее доступность:</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">Однако, если вы попробуете это в своем шаблоне, Vue покажет ошибку, объясняя, что &lt;strong&gt;каждый компонент должен иметь единственный корневой элемент&lt;/strong&gt; . Вы можете исправить эту ошибку, заключив шаблон в родительский элемент, например:</target>
        </trans-unit>
        <trans-unit id="14259c72550c39ee6e4f5a0f4cc02294d8e66215" translate="yes" xml:space="preserve">
          <source>If you use a module bundle like webpack, this may cause Vue&amp;rsquo;s source code to be bundled into the plugin, and more often than not that&amp;rsquo;s not what you'd expect. A common practice to prevent this from happening is to configure the module bundler to exclude Vue from the final bundle. In webpack's case, you can use the &lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot;&gt;&lt;code&gt;externals&lt;/code&gt; (opens new window)&lt;/a&gt; configuration option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">Если Вы используете в своих шаблонах какие-либо пользовательские элементы,отличные от Vue,например,веб-компонент,то PascalCase гарантирует,что Ваши компоненты Vue останутся отчетливо видимыми.</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">Если вы хотите принудить реквизит,установите вместо него локальное вычисленное значение.Например,вместо:</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">Если вы хотите сразу погрузиться в работу и начать играть с однофайловыми компонентами, ознакомьтесь с &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;этим простым приложением-&lt;/a&gt; делом на CodeSandbox.</target>
        </trans-unit>
        <trans-unit id="19c4d2e8e9b44f23f256752921c6f56b3515e01e" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/vue-todo-list-app-with-single-file-component-vzkl3?file=/src/App.vue&quot;&gt;this simple todo app (opens new window)&lt;/a&gt; on CodeSandbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221bedd32adb2426b2b5127135897cde8d509422" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">Если вы хотите передать все свойства объекта как свойства, вы можете использовать &lt;code&gt;v-bind&lt;/code&gt; без аргумента ( &lt;code&gt;v-bind&lt;/code&gt; вместо &lt;code&gt;v-bind:prop-name&lt;/code&gt; ). Например, для объекта &lt;code&gt;post&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">Если вместо этого вы хотите зарегистрировать директиву локально, компоненты также принимают параметр &lt;code&gt;directives&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">Если вы хотите, чтобы пользовательский ввод автоматически приводился к типу числа, вы можете добавить модификатор &lt;code&gt;number&lt;/code&gt; к управляемым входам &lt;code&gt;v-model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">Если вы хотите, чтобы пробелы из пользовательского ввода были обрезаны автоматически, вы можете добавить модификатор &lt;code&gt;trim&lt;/code&gt; к входам, управляемым &lt;code&gt;v-model&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">Если вы ранее полагались на &lt;code&gt;vm.$watch&lt;/code&gt; чтобы что-то делать с DOM после обновления компонента, вы можете вместо этого сделать это в &lt;code&gt;updated&lt;/code&gt; хуке жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="43daed9c097353737805c1bf2ab9ef52cfa52fb5" translate="yes" xml:space="preserve">
          <source>If you wish to hardware-accelerate an element, you can apply any of these properties (not all are necessary, only one):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">Если вы хотите также условно переключить класс в списке,вы можете сделать это с помощью тернарного выражения:</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">Если вы хотите узнать больше о Vue перед тем, как погрузиться в него, мы создали видео, в котором рассматриваются основные принципы и пример проекта.</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">Если вы пользователь &lt;strong&gt;Browserify,&lt;/strong&gt; который хотел бы использовать асинхронные компоненты, его создатель, к сожалению, &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;ясно дал понять,&lt;/a&gt; что асинхронная загрузка &amp;laquo;это не то, что Browserify когда-либо будет поддерживать&amp;raquo;. По крайней мере, официально. Сообщество Browserify нашло &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;несколько обходных путей&lt;/a&gt; , которые могут быть полезны для существующих и сложных приложений. Для всех других сценариев мы рекомендуем использовать Webpack для встроенной первоклассной поддержки async.</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">Если вы работаете с React, вам может быть интересно, как vuex сравнивается с &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt; , самой популярной реализацией Flux в этой экосистеме. Redux фактически не зависит от уровня представления, поэтому его можно легко использовать с Vue с помощью &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;простых привязок&lt;/a&gt; . Vuex отличается тем, что &lt;em&gt;знает,&lt;/em&gt; что находится в приложении Vue. Это позволяет ему лучше интегрироваться с Vue, предлагая более интуитивно понятный API и улучшенный опыт разработки.</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">Если вы не будете осторожны, рекурсивные компоненты также могут привести к бесконечным циклам:</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">Если вы не используете модульную систему с &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; , вы, вероятно, можете пока пропустить этот раздел. Если да, у нас есть специальные инструкции и советы специально для вас.</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">Если вы еще не знакомы с компонентами Vue, вы можете пропустить это сейчас.</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">Если вы все еще здесь, то, вероятно, вы используете модульную систему, например, с Babel и Webpack. В этих случаях мы рекомендуем создать каталог &lt;code&gt;components&lt;/code&gt; , в котором каждый компонент находится в отдельном файле.</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">Если вы пишете много функций &lt;code&gt;render&lt;/code&gt; , вам может быть больно писать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="609a6f861acf12bf2b5f3b2a6f3ec765be8efafd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever had to manually manipulate DOM in Vue, you might have come across this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ecc2bc675d03a98476e9bf350d5918a55d45a0" translate="yes" xml:space="preserve">
          <source>If you're coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux (opens new window)&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings (opens new window)&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4383a33376cb43b8f9f3a34ad4ebc3a22a32fdbb" translate="yes" xml:space="preserve">
          <source>If you're not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d391b26209861300899a2add1af08ef09f4194f8" translate="yes" xml:space="preserve">
          <source>If you're not yet familiar with Vue's components, you can skip this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913e0a49efe5be77ae2656044ce4cc773b612ae8" translate="yes" xml:space="preserve">
          <source>If you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f123dacf3d9e21f599eddd3ec553d8bc240c00ee" translate="yes" xml:space="preserve">
          <source>If you're using a &lt;a href=&quot;../installation#cdn&quot;&gt;CDN&lt;/a&gt; build of Vue then &lt;code&gt;createApp&lt;/code&gt; is exposed via the global &lt;code&gt;Vue&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256d7614924d2b75c2300fd933e837e95c0b7657" translate="yes" xml:space="preserve">
          <source>If your component has multiple root elements, you would need to define which component will receive this class. You can do this using &lt;code&gt;$attrs&lt;/code&gt; component property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">Если вашей директиве нужно несколько значений,то вы также можете передать их в литературе объекта JavaScript.Помните,что директивы могут принимать любые допустимые выражения JavaScript.</target>
        </trans-unit>
        <trans-unit id="242aaacd829f9f99856dd2793dfdfc9507666410" translate="yes" xml:space="preserve">
          <source>If your module bundler of choice happens to be &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup (opens new window)&lt;/a&gt;, you basically get the same effect for free, as by default Rollup will treat absolute module IDs (&lt;code&gt;'vue'&lt;/code&gt; in our case) as external dependencies and not include them in the final bundle. During bundling though, it might emit a &lt;a href=&quot;https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency&quot;&gt;&amp;ldquo;Treating vue as external dependency&amp;rdquo; (opens new window)&lt;/a&gt; warning, which can be suppressed with the &lt;code&gt;external&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a721aa3beb5717086550f15e05596fdcd9ca355" translate="yes" xml:space="preserve">
          <source>If your plugin relies on an affected Vue 2.x global API, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8119918563dea634ba032ddd3981c094251dbb90" translate="yes" xml:space="preserve">
          <source>Imagine the case where we have a standalone primitive value (for example, a string) and we want to make it reactive. Of course, we could make an object with a single property equal to our string, and pass it to &lt;code&gt;reactive&lt;/code&gt;. Vue has a method that will do the same for us - it's a &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">Представьте, что это шаблон для &lt;code&gt;bootstrap-date-input&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b5a9cca298c2ad31236d51c99a03c78bea9e1757" translate="yes" xml:space="preserve">
          <source>Implementation-wise &lt;code&gt;defineComponent&lt;/code&gt; does nothing but return the object passed to it. However, in terms of typing, the returned value has a synthetic type of a constructor for manual render function, TSX and IDE tooling support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">Неявное общение между родителями и детьми</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">Неявное общение между родителями и детьми следует &lt;sup&gt;использовать с осторожностью&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="28826b0d2e02701105ec50963d8f7e90554a6576" translate="yes" xml:space="preserve">
          <source>Import it as a &lt;a href=&quot;#cdn&quot;&gt;CDN package&lt;/a&gt; on the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9992581d590be676f25bb4ed76a8393ef92057e" translate="yes" xml:space="preserve">
          <source>Imported dependencies are also esm-bundler builds and will in turn import their dependencies (e.g. @vue/runtime-core imports @vue/reactivity)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836e63c09fd6ddabcf1825ec759e9e296d10a1ec" translate="yes" xml:space="preserve">
          <source>Imports dependencies (e.g. &lt;code&gt;@vue/runtime-core&lt;/code&gt;, &lt;code&gt;@vue/runtime-compiler&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5200b178a45fe7d68a514c32e5d600863251de0" translate="yes" xml:space="preserve">
          <source>In 2.2 we introduced the &lt;code&gt;model&lt;/code&gt; component option that allows the component to customize the prop and event to use for &lt;code&gt;v-model&lt;/code&gt;. However, this still only allowed a single &lt;code&gt;v-model&lt;/code&gt; to be used on the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">В 2.2.0+ и выше, &lt;code&gt;activated&lt;/code&gt; и &lt;code&gt;deactivated&lt;/code&gt; будут срабатывать для всех вложенных компонентов внутри дерева &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">В версии 2.2.0+ эта ловушка также фиксирует ошибки в хуках жизненного цикла компонентов. Кроме того, когда этот перехватчик не &lt;code&gt;undefined&lt;/code&gt; , захваченные ошибки будут регистрироваться с помощью &lt;code&gt;console.error&lt;/code&gt; вместо сбоя приложения.</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">В версии 2.2.0+ при использовании &lt;code&gt;v-for&lt;/code&gt; с компонентом теперь требуется &lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">В версии 2.4.0+этот крючок также перехватывает ошибки,брошенные внутри обработчиков событий Vue.</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">В 2.5.0+инъекции могут быть опциональными со значением по умолчанию:</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">В версии 2.5.0+, если вы используете однофайловые &lt;a href=&quot;single-file-components&quot;&gt;компоненты&lt;/a&gt; , функциональные компоненты на основе шаблонов могут быть объявлены с помощью:</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">В версии 2.6+ &lt;code&gt;v-for&lt;/code&gt; также может работать со значениями, реализующими &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt; , включая собственные &lt;code&gt;Map&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt; . Однако следует отметить, что Vue 2.x в настоящее время не поддерживает реактивность &lt;code&gt;Set&lt;/code&gt; значений &lt;code&gt;Map&lt;/code&gt; и Set , поэтому не может автоматически обнаруживать изменения.</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">В версии 2.6.0+ этот перехватчик также перехватывает ошибки, возникающие в слушателях &lt;code&gt;v-on&lt;/code&gt; DOM. Вдобавок, если какой-либо из охваченных хуков или обработчиков возвращает цепочку обещаний (например, асинхронные функции), ошибка из этой цепочки обещаний также будет обработана.</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">В версии 2.6.0 мы представили новый унифицированный синтаксис ( директива &lt;code&gt;v-slot&lt;/code&gt; ) для именованных и ограниченных слотов. Он заменяет атрибуты &lt;code&gt;slot&lt;/code&gt; и &lt;code&gt;slot-scope&lt;/code&gt; , которые теперь устарели, но &lt;em&gt;не&lt;/em&gt; были удалены и все еще задокументированы &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;здесь&lt;/a&gt; . Обоснование введения нового синтаксиса описано в этом &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256728aff9fb16c0f4d2df842f2c3e5ad55c5e9b" translate="yes" xml:space="preserve">
          <source>In 2.x, &lt;code&gt;domProps&lt;/code&gt; contained a nested list within the VNode props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ccc8617c6c0b63bdc2bf15b8a89fb2407da706" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue instance could be used to trigger handlers attached imperatively via the event emitter API (&lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt;). This was used to create &lt;em&gt;event hubs&lt;/em&gt; to create global event listeners used across the whole application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dd1fdaef79b3831922864fd8d39f0ad9deb676" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue provided the &lt;code&gt;inline-template&lt;/code&gt; attribute on child components to use its inner content as its template instead of treating it as distributed content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2328f43db77fe0efd8f47e998984f47eac46ba" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could access direct child components of the current instance with &lt;code&gt;this.$children&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9424ae231a6fda6ed873b7a8e6ae8e39088d9d" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could define the &lt;code&gt;data&lt;/code&gt; option with either an &lt;code&gt;object&lt;/code&gt; or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dd71f6a7a373cd112dab134b7ff3db3d648f20" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could use filters in order to apply common text formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7063d13de2f5ae058926813bdf953c4a105676c" translate="yes" xml:space="preserve">
          <source>In 2.x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the individual property would always overwrite bindings in the &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea559fa1a9771817cc8e8333085080656e09848" translate="yes" xml:space="preserve">
          <source>In 2.x, invalid values were coerced to &lt;code&gt;'true'&lt;/code&gt; for enumerated attributes. This was usually unintended and unlikely to be relied upon on a large scale. In 3.x &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;'true'&lt;/code&gt; should be explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69daab13ee1934deef652bdaaf6f2e3de088df88" translate="yes" xml:space="preserve">
          <source>In 2.x, multi-root components were not supported and would emit a warning when a user accidentally created one. As a result, many components are wrapped in a single &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in order to fix this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd9ee258c65347ba2ff8b78a2b85cee0fc8e414" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function automatically received arguments such as &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d01321951def977b78828f17cb248ccea9ad7" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function would automatically receive the &lt;code&gt;h&lt;/code&gt; function (which is a conventional alias for &lt;code&gt;createElement&lt;/code&gt;) as an argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9729a27f715ad913ceb2a7d973c83313e4f3c50f" translate="yes" xml:space="preserve">
          <source>In 2.x, using a &lt;code&gt;v-model&lt;/code&gt; on a component was an equivalent of passing a &lt;code&gt;value&lt;/code&gt; prop and emitting an &lt;code&gt;input&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46afcbced92e335f7123d55a58b836b7295afd1d" translate="yes" xml:space="preserve">
          <source>In 2.x, we had the following strategies for coercing &lt;code&gt;v-bind&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5a25ed12428fc14990ccb2e9c191fa49adb981" translate="yes" xml:space="preserve">
          <source>In 2.x, when a component has been registered, the render function would work well when passing the component's name as a string to the first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe8f6026316d3a73f1bd42ee8c89d43dee6ad5b" translate="yes" xml:space="preserve">
          <source>In 2.x, when using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; on the same element, &lt;code&gt;v-for&lt;/code&gt; would take precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2fe7a68d07b5928c0025bf237e90e00d49b1ff" translate="yes" xml:space="preserve">
          <source>In 3.0, the result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d272f52a84ee8fe9eda14c5af6c7e7e9aea55cf" translate="yes" xml:space="preserve">
          <source>In 3.0, we are limiting Vue's special treatment of the &lt;code&gt;is&lt;/code&gt; prop to the &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03706ae0b18cf04d0e1184566cc22dd43bd8796" translate="yes" xml:space="preserve">
          <source>In 3.x &lt;code&gt;v-model&lt;/code&gt; on the custom component is an equivalent of passing a &lt;code&gt;modelValue&lt;/code&gt; prop and emitting an &lt;code&gt;update:modelValue&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaffa537c62e5c878c892ad624027bd74bf34114" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;h&lt;/code&gt; is now globally imported instead of being automatically passed as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cbfb34fe6f9b877113b6bdc0dd73e927141d87" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; should be used to explicitly remove an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bef6847fad523068826498b632dcae11c29c52" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;v-if&lt;/code&gt; will always have the higher precedence than &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c1b7ac08bfa5b7cc8606dcd35f2331e4abc8e3" translate="yes" xml:space="preserve">
          <source>In 3.x, components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af3acd686b51e5d6705eac439e47596866c1ce8" translate="yes" xml:space="preserve">
          <source>In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53eba82a86ea2e9f0b2f6f6cfedb74733b2d04f" translate="yes" xml:space="preserve">
          <source>In 3.x, since the &lt;code&gt;render&lt;/code&gt; function no longer receives any arguments, it will primarily be used inside of the &lt;code&gt;setup()&lt;/code&gt; function. This has the added benefit of gaining access to reactive state and functions declared in scope, as well as the arguments passed to &lt;code&gt;setup()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46410326ff00ce7f5b9a576648a6b047f922589a" translate="yes" xml:space="preserve">
          <source>In 3.x, slots are defined as children of the current node as an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a39c3c93b98afd50fbd7886344976a75f0114a1" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;$children&lt;/code&gt; property is removed and no longer supported. Instead, if you need to access a child component instance, we recommend using &lt;a href=&quot;../component-template-refs#template-refs&quot;&gt;$refs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4eb8d2b66bb84443ed0a747129452a3b8f78766" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;data&lt;/code&gt; option has been standardized to only accept a &lt;code&gt;function&lt;/code&gt; that returns an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0577d8ad30ab5a25ec81d48069dddfe6636d8797" translate="yes" xml:space="preserve">
          <source>In 3.x, the entire VNode props structure is flattened. Using the example from above, here is what it would look like now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c698a95795682a639eda0b4dab592ffcd0ccbfd" translate="yes" xml:space="preserve">
          <source>In 3.x, the performance difference between stateful and functional components has been drastically reduced and will be insignificant in most use cases. As a result, the migration path for developers using &lt;code&gt;functional&lt;/code&gt; on SFCs is to remove the attribute and rename all references of &lt;code&gt;props&lt;/code&gt; to &lt;code&gt;$props&lt;/code&gt; and &lt;code&gt;attrs&lt;/code&gt; to &lt;code&gt;$attrs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b6c70c99847e99bd40a423d7f7e30f14d0d1e" translate="yes" xml:space="preserve">
          <source>In 3.x, with VNodes being context-free, we can no longer use a string ID to implicitly lookup registered components. Instead, we need to use an imported &lt;code&gt;resolveComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1649eb8974b30107ef48d872705e3f78ccfacc0f" translate="yes" xml:space="preserve">
          <source>In 3x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the order of how the bindings are declared determines how they are merged. In other words, rather than assuming developers want the individual property to always override what is defined in the &lt;code&gt;object&lt;/code&gt;, developers now have more control over the desired merging behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feb4596eedd196dbf2408c8aca99b22823b66c2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue's template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">В &lt;a href=&quot;../guide/single-file-components&quot;&gt;компонентах одного файла&lt;/a&gt; , &lt;code&gt;scoped&lt;/code&gt; стили не будут применяться к содержимому внутри &lt;code&gt;v-html&lt;/code&gt; , потому что HTML не обрабатываются шаблон компилятором Vue в. Если вы хотите настроить таргетинг на &lt;code&gt;v-html&lt;/code&gt; - контент с помощью CSS с ограниченной областью видимости, вы можете вместо этого использовать &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модули CSS&lt;/a&gt; или дополнительный глобальный элемент &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; с ручной стратегией определения области, например БЭМ.</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">В JavaScript,PascalCase является соглашением для классов и конструкторов прототипов-по сути,все,что может иметь отдельные экземпляры.Компоненты Vue также имеют экземпляры,поэтому имеет смысл использовать PascalCase.Как дополнительное преимущество,использование PascalCase в JSX (и шаблонах)позволяет читателям кода легче различать компоненты и HTML-элементы.</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">В JavaScript разделение объектов с несколькими свойствами на несколько строк широко считается хорошим соглашением, потому что его гораздо легче читать. Наши шаблоны и &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; заслуживают того же внимания.</target>
        </trans-unit>
        <trans-unit id="c13d73a2ddf37e7463ec10f8ded7afc62e432e0e" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#jsx&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1511320f9fca1ecdb726d3628235620054c333a" translate="yes" xml:space="preserve">
          <source>In Object-based syntax, the value of each property can either be &lt;code&gt;null&lt;/code&gt; or a validator function. The validation function will receive the additional arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call. For example, if &lt;code&gt;this.$emit('foo', 1)&lt;/code&gt; is called, the corresponding validator for &lt;code&gt;foo&lt;/code&gt; will receive the argument &lt;code&gt;1&lt;/code&gt;. The validator function should return a boolean to indicate whether the event arguments are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">В компании Polymer команда также сделала свою систему привязки данных очень ограниченной для того,чтобы компенсировать производительность.Например,единственными выражениями,поддерживаемыми в шаблонах Polymer,являются булевое отрицание и вызовы одиночных методов.Его вычислительная реализация свойств также не очень гибкая.</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">В React,все компоненты выражают свой пользовательский интерфейс внутри рендер-функций,используя JSX,декларативный XML-подобный синтаксис,который работает внутри JavaScript.</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">На самом деле,все это просто JavaScript.Мало того,что HTML-структуры выражаются через JSX,последние тенденции также имеют тенденцию помещать CSS-управление внутри JavaScript.Такой подход имеет свои преимущества,но и поставляется с различными компромиссами,которые могут показаться не очень выгодными для каждого разработчика.</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">В React, когда состояние компонента изменяется, он запускает повторный рендеринг всего поддерева компонента, начиная с этого компонента как корневого. Чтобы избежать ненужного повторного рендеринга дочерних компонентов, вам нужно либо использовать &lt;code&gt;PureComponent&lt;/code&gt; , либо реализовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , когда это возможно. Вам также может потребоваться использовать неизменяемые структуры данных, чтобы сделать изменения вашего состояния более удобными для оптимизации. Однако в некоторых случаях вы не сможете полагаться на такую ​​оптимизацию, потому что &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; предполагает, что вывод рендеринга всего поддерева определяется свойствами текущего компонента. Если это не так, то такая оптимизация может привести к несогласованному состоянию DOM.</target>
        </trans-unit>
        <trans-unit id="2cfb65095765445c51ed3990754a7aea8c4e09af" translate="yes" xml:space="preserve">
          <source>In Vue 2 we recommended working around with these restrictions by using the &lt;code&gt;is&lt;/code&gt; prop on a native tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d17b0d924f04ce8ace3de17c7feceb2d55c631" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;, like other custom components, needed a root element, which by default was a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; but was customizable via the &lt;code&gt;tag&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eee5e53bb1e22d2f1df0e9f8eff653441f88183" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;Vue.prototype&lt;/code&gt; was commonly used to add properties that would be accessible in all components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623539054d5afbfeafa88a7593570669aa7a26b8" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;keyCodes&lt;/code&gt; were supported as a way to modify a &lt;code&gt;v-on&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714deb450dd9f768ce9fb1850ea76c03a9c0b8ff" translate="yes" xml:space="preserve">
          <source>In Vue 2, custom directives were created by using the hooks listed below to target an element&amp;rsquo;s lifecycle, all of which are optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427f3cc45180bf04421bacb75902b51bf88d889a" translate="yes" xml:space="preserve">
          <source>In Vue 2, functional components had two primary use cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4027dc7058f32b3afa9b989de298f0e1274c6387" translate="yes" xml:space="preserve">
          <source>In Vue 2, mixins were the primary tool to abstract parts of component logic into reusable chunks. However, they have a few issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49b054972b109d8d92e090576574f314196d960" translate="yes" xml:space="preserve">
          <source>In Vue 2, the component instance had to be accessed through the &lt;code&gt;vnode&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf60ceefe843452e7ace61c7f5d7fb5a10e2c5" translate="yes" xml:space="preserve">
          <source>In Vue 2, using the &lt;code&gt;ref&lt;/code&gt; attribute inside &lt;code&gt;v-for&lt;/code&gt; will populate the corresponding &lt;code&gt;$refs&lt;/code&gt; property with an array of refs. This behavior becomes ambiguous and inefficient when there are nested &lt;code&gt;v-for&lt;/code&gt;s present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a36b69d1b9520442812684a11396300f78b7ba" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can access attributes passed to your components with &lt;code&gt;this.$attrs&lt;/code&gt;, and event listeners with &lt;code&gt;this.$listeners&lt;/code&gt;. In combination with &lt;code&gt;inheritAttrs: false&lt;/code&gt;, they allow the developer to apply these attributes and listeners to some other element instead of the root element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d3795b44e395241dad3f754562828449a79603" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can define the props that a component receives, but you can't declare which events it can emit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">В Vue 2.x &lt;code&gt;Vue.observable&lt;/code&gt; напрямую изменяет переданный ему объект, чтобы он был эквивалентен возвращаемому объекту, как &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;показано здесь&lt;/a&gt; . В Vue 3.x вместо этого будет возвращен реактивный прокси, оставляя исходный объект не реактивным при непосредственном изменении. Поэтому для будущей совместимости мы рекомендуем всегда работать с объектом, возвращаемым &lt;code&gt;Vue.observable&lt;/code&gt; , а не с первоначально переданным ему объектом.</target>
        </trans-unit>
        <trans-unit id="04a1b8d86ca382e0241c1abe50e3ee3fb8996f94" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag could not have a &lt;code&gt;key&lt;/code&gt;. Instead, you could place the &lt;code&gt;key&lt;/code&gt;s on each of its children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cb196394bb87ca2a8e06b2510d6358e84a7776" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, application root container's &lt;code&gt;outerHTML&lt;/code&gt; is replaced with root component template (or eventually compiled to a template, if root component has no template/render option). Vue 3.x now uses application container's &lt;code&gt;innerHTML&lt;/code&gt; instead - this means the container itself is no longer considered part of the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ecd8d4cc17aab927b205f633e4d33dda883445" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, it was recommended to use &lt;code&gt;key&lt;/code&gt;s on &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d36ea70a8bf1cfdc715d58ac1911e3fd754fa1" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, the resulting &lt;code&gt;$data&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61abdd8d6816689fd4d5efd6b7f0f6d0421fa89e" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, whitelisting tags as custom elements was done via &lt;code&gt;Vue.config.ignoredElements&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a2d802b261d3390a36b39b1e88da6952ae1bfe" translate="yes" xml:space="preserve">
          <source>In Vue 3's virtual DOM, event listeners are now just attributes, prefixed with &lt;code&gt;on&lt;/code&gt;, and as such are part of the &lt;code&gt;$attrs&lt;/code&gt; object, so &lt;code&gt;$listeners&lt;/code&gt; has been removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8ffd46210564bab462dab866e0a61658c85fd" translate="yes" xml:space="preserve">
          <source>In Vue 3, APIs that globally mutate Vue's behavior are now moved to application instances created by the new &lt;code&gt;createApp&lt;/code&gt; method. In addition, their effects are now scoped to that specific application's instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724f98bfd4825d659b3ef73bec24c9d1b1bd8450" translate="yes" xml:space="preserve">
          <source>In Vue 3, components now have official support for multi-root node components, i.e., fragments!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3d29f7ef97ea630c136e861259ef7779f3f469" translate="yes" xml:space="preserve">
          <source>In Vue 3, however, we&amp;rsquo;ve created a more cohesive API for custom directives. As you can see, they differ greatly from our component lifecycle methods even though we&amp;rsquo;re hooking into similar events. We&amp;rsquo;ve now unified them like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6331f262fcf12a91763745c6aeed71d9b733b3c" translate="yes" xml:space="preserve">
          <source>In Vue 3, such usage will no longer automatically create an array in &lt;code&gt;$refs&lt;/code&gt;. To retrieve multiple refs from a single binding, bind &lt;code&gt;ref&lt;/code&gt; to a function which provides more flexibility (this is a new feature):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ecfbda9c9364a4d1cfde77270eb84b68591725" translate="yes" xml:space="preserve">
          <source>In Vue 3, the check of whether an element is a component or not has been moved to the template compilation phase, therefore this config option is only respected when using the runtime compiler. If you are using the runtime-only build, &lt;code&gt;isCustomElement&lt;/code&gt; must be passed to &lt;code&gt;@vue/compiler-dom&lt;/code&gt; in the build setup instead - for example, via the &lt;a href=&quot;https://vue-loader.vuejs.org/options.html#compileroptions&quot;&gt;&lt;code&gt;compilerOptions&lt;/code&gt; option in vue-loader (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b845930e81b44f047a329d5c6204f7f931bd74" translate="yes" xml:space="preserve">
          <source>In Vue 3, the global and internal APIs have been restructured with tree-shaking support in mind. As a result, the global APIs can now only be accessed as named exports for the ES Modules build. For example, our previous snippets should now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e9367bc712cd5e99e214445d49ec8f87dc977" translate="yes" xml:space="preserve">
          <source>In Vue 3, the instance is now part of the &lt;code&gt;binding&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73645e0f3791358bf3f0d6ad20122b90a31ffd47" translate="yes" xml:space="preserve">
          <source>In Vue 3, we have &lt;a href=&quot;fragments&quot;&gt;fragment support&lt;/a&gt;, so components no longer &lt;em&gt;need&lt;/em&gt; a root node. Consequently, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; no longer renders one by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7bdcdf994f4cc1a00dd74f8f22ad2f859a405b" translate="yes" xml:space="preserve">
          <source>In Vue 3, you&amp;rsquo;ll have to import it explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2bc8b0bef1be017e069553012e806d6ad3eeb6" translate="yes" xml:space="preserve">
          <source>In Vue 3.0 we can make any variable reactive anywhere with a new &lt;code&gt;ref&lt;/code&gt; function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1261249a8779a24fb5636b8856b66bfb7e4d50aa" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &quot;use production build&quot; tip will only show up when using the &quot;dev + full build&quot; (the build that includes the runtime compiler and has warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9927c60d35977a34e50e99413e889e84532170" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &lt;code&gt;key&lt;/code&gt; should be placed on the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">В Vue компонент,по сути,является экземпляром Vue с предустановленными опциями.Регистрация компонента в Vue проста:</target>
        </trans-unit>
        <trans-unit id="9c55128700791de0665f1315237d38efdb9e6612" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially an instance with pre-defined options. Registering a component in Vue is straightforward: we create a component object as we did with &lt;code&gt;App&lt;/code&gt; objects and we define it in parent's &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Во Vue зависимости компонента автоматически отслеживаются во время его рендеринга, поэтому система точно знает, какие компоненты действительно нужно повторно рендерить при изменении состояния. Можно считать, что каждый компонент должен автоматически реализовать &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , без оговорок о вложенных компонентах.</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Во Vue у нас также есть &lt;a href=&quot;render-function&quot;&gt;функции рендеринга&lt;/a&gt; и даже &lt;a href=&quot;render-function#JSX&quot;&gt;поддержка JSX&lt;/a&gt; , потому что иногда вам действительно нужна такая мощь. Однако по умолчанию мы предлагаем шаблоны как более простую альтернативу. Любой допустимый HTML-код также является допустимым шаблоном Vue, и это дает несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">В Webpack 4+ вы можете использовать опцию &lt;code&gt;mode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4f0bbfd3f2e8bb6462aabfac3883c560be6e8a5" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/component-basics&quot;&gt;later in the guide&lt;/a&gt;, but here's an (imaginary) example of what an app's template might look like with components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">В большом приложении необходимо разделить все приложение на компоненты, чтобы сделать разработку управляемой. Мы еще поговорим о компонентах &lt;a href=&quot;guide/components&quot;&gt;позже в руководстве&lt;/a&gt; , но вот (воображаемый) пример того, как шаблон приложения может выглядеть с компонентами:</target>
        </trans-unit>
        <trans-unit id="cce007380584fe599b155e880cbf38a37b8c5865" translate="yes" xml:space="preserve">
          <source>In a template it can be useful to use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag to hold a &lt;code&gt;v-if&lt;/code&gt; or &lt;code&gt;v-for&lt;/code&gt; directive. When migrating to a &lt;code&gt;render&lt;/code&gt; function, the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag is no longer required and can be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">Однако в типичном приложении у вас, скорее всего, будет массив сообщений в &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f0341aaa53b971cc7f7cd6eab8ea717e277b0a1" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you'll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8dde57e2c8045db642f017abe87ff72fbc20c" translate="yes" xml:space="preserve">
          <source>In addition to 2.x hard-coded &lt;code&gt;v-model&lt;/code&gt; modifiers like &lt;code&gt;.trim&lt;/code&gt;, now 3.x supports custom modifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">В дополнение к свойствам данных, экземпляры Vue предоставляют ряд полезных свойств и методов экземпляра. Они имеют префикс &lt;code&gt;$&lt;/code&gt; , чтобы отличать их от свойств, определяемых пользователем. Например:</target>
        </trans-unit>
        <trans-unit id="30b7afc0333bb298c35216e487d1e9e77e4192ca" translate="yes" xml:space="preserve">
          <source>In addition to public APIs, many of the internal components/helpers are now exported as named exports as well. This allows the compiler to output code that only imports features when they are used. For example the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">В дополнение к текстовой интерполяции,мы также можем связать атрибуты элементов таким образом:</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">В дополнение к опции &lt;code&gt;watch&lt;/code&gt; вы также можете использовать императивный &lt;a href=&quot;../api/index#vm-watch&quot;&gt;API vm. $ Watch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5150e3e352b277b1ba1aa7eeef457bb44d050905" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/instance-methods#watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">В дополнение к стандартному набору директив, поставляемых в ядре ( &lt;code&gt;v-model&lt;/code&gt; и &lt;code&gt;v-show&lt;/code&gt; ), Vue также позволяет вам регистрировать свои собственные пользовательские директивы. Обратите внимание, что в Vue 2.0 основной формой повторного использования и абстракции кода являются компоненты, однако могут быть случаи, когда вам понадобится некоторый низкоуровневый доступ к DOM для простых элементов, и именно здесь пользовательские директивы по-прежнему будут полезны. Примером может быть элемент ввода, например этот:</target>
        </trans-unit>
        <trans-unit id="0565e3d1e3c82f3b31c0ab6ec47170e5dc305765" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (like &lt;code&gt;v-model&lt;/code&gt; or &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue, the primary form of code reuse and abstraction is components - however, there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">Кроме того, &lt;code&gt;type&lt;/code&gt; также может быть функцией настраиваемого конструктора, и утверждение будет выполняться с проверкой &lt;code&gt;instanceof&lt;/code&gt; . Например, если существует следующая функция-конструктор:</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">Кроме того,каждый экземпляр/компонент все еще может владеть и управлять своим собственным частным состоянием:</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">Кроме того, каждый раз, когда обновляется родительский компонент, все свойства дочернего компонента будут обновляться до последнего значения. Это означает, что вы &lt;strong&gt;не&lt;/strong&gt; должны пытаться &lt;strong&gt;изменить&lt;/strong&gt; опору внутри дочернего компонента. Если вы это сделаете, Vue предупредит вас в консоли.</target>
        </trans-unit>
        <trans-unit id="b81d142d3c922310cfbb8a89684dac0a487a2272" translate="yes" xml:space="preserve">
          <source>In addition, rather than implicitly provide &lt;code&gt;h&lt;/code&gt; in a &lt;code&gt;render&lt;/code&gt; function, &lt;code&gt;h&lt;/code&gt; is now imported globally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85215d9d308bd40086a0e1662ab21ebbec8c5c6d" translate="yes" xml:space="preserve">
          <source>In addition, since the &lt;code&gt;createApp&lt;/code&gt; method returns the application instance itself, you can chain other methods after it which can be found in the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65713f74baf60786834c58f72d45052056f1fa2d" translate="yes" xml:space="preserve">
          <source>In addition, unlike 2.x, the loader function no longer receives the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must always return a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21451e63b33f7fd3f9f0613a2eed3c9fd082315c" translate="yes" xml:space="preserve">
          <source>In addition, when &lt;code&gt;data()&lt;/code&gt; from a component and its mixins or extends base are merged, the merge is now performed &lt;em&gt;shallowly&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3636deb3b0c4953ecaa1f52798bd8dc37c3b5533" translate="yes" xml:space="preserve">
          <source>In addition, when referencing scoped slots, they could be referenced using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5985a88954adf2a60500ab64ac8c41d6f599d628" translate="yes" xml:space="preserve">
          <source>In addition, you could define your own aliases via the global &lt;code&gt;config.keyCodes&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">Если вы еще не заметили, Vue выполняет обновления DOM &lt;strong&gt;асинхронно&lt;/strong&gt; . Всякий раз, когда наблюдается изменение данных, он открывает очередь и буферизует все изменения данных, которые происходят в том же цикле событий. Если один и тот же наблюдатель запускается несколько раз, он будет помещен в очередь только один раз. Эта буферизованная дедупликация важна для предотвращения ненужных вычислений и манипуляций с DOM. Затем в следующем цикле событий &amp;laquo;тик&amp;raquo; Vue очищает очередь и выполняет фактическую (уже удаленную) работу. Внутренне Vue пробует собственные &lt;code&gt;Promise.then&lt;/code&gt; , &lt;code&gt;MutationObserver&lt;/code&gt; и &lt;code&gt;setImmediate&lt;/code&gt; для асинхронной организации очереди и возвращается к &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="613464b2036a68a6ebb2b0e396760bb7f079d24b" translate="yes" xml:space="preserve">
          <source>In case you haven't noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &quot;tick&quot;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cd65af0c1ac7f1a471b3ebe14997d44c5a24c9" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader (opens new window)&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;webpack learning academy (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">Если вы предпочитаете настраивать собственную сборку с нуля, вам нужно будет вручную настроить webpack с помощью &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt; . Чтобы узнать больше о самом webpack, ознакомьтесь с &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;их официальной документацией&lt;/a&gt; и &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">В случаях, подобных описанным выше, когда контент предоставляется &lt;em&gt;только&lt;/em&gt; для слота по умолчанию, теги компонента могут использоваться в качестве шаблона слота. Это позволяет нам использовать &lt;code&gt;v-slot&lt;/code&gt; непосредственно в компоненте:</target>
        </trans-unit>
        <trans-unit id="afdc559a28e8fc0df8af77b29c0a99f33040dfa0" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">В таких случаях мы можем пометить компоненты как &lt;code&gt;functional&lt;/code&gt; , что означает, что они не имеют состояния (без &lt;a href=&quot;../api/index#Options-Data&quot;&gt;реактивных данных&lt;/a&gt; ) и без экземпляров (без &lt;code&gt;this&lt;/code&gt; контекста). А &lt;strong&gt;функциональный компонент&lt;/strong&gt; выглядит следующим образом :</target>
        </trans-unit>
        <trans-unit id="fa13d1c0d73e56359fd93a07fd88a5c686b9d9da" translate="yes" xml:space="preserve">
          <source>In cases where a component is only used once, the debouncing can be applied directly within &lt;code&gt;methods&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afbf4c975278f424bbb47c6b13d6c21a3be2dbb" translate="yes" xml:space="preserve">
          <source>In cases where a watcher effect needs to be re-run &lt;strong&gt;after&lt;/strong&gt; component updates (i.e. when working with &lt;a href=&quot;composition-api-template-refs#watching-template-refs&quot;&gt;Template Refs&lt;/a&gt;), we can pass an additional &lt;code&gt;options&lt;/code&gt; object with the &lt;code&gt;flush&lt;/code&gt; option (default is &lt;code&gt;'pre'&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">В коде фиксации определения опоры всегда должны быть как можно более подробными,с указанием,по крайней мере,типа(ов).</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">Для сравнения, &lt;code&gt;v-show&lt;/code&gt; намного проще - элемент всегда отображается независимо от начального состояния с переключением на основе CSS.</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">Для сравнения: вызов метода &lt;strong&gt;всегда&lt;/strong&gt; запускает функцию всякий раз, когда происходит повторный рендеринг.</target>
        </trans-unit>
        <trans-unit id="bb1736ea3b5962d2582e096afba361a049ac9d2c" translate="yes" xml:space="preserve">
          <source>In components that use &lt;code&gt;inheritAttrs: false&lt;/code&gt;, make sure that styling still works as intended. If you previously relied on the special behavior of &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, some visuals might be broken as these attributes might now be applied to another element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">В процессе разработки Vue предупредит вас,если компонент когда-нибудь будет предоставлен неверно отформатированный реквизит,что поможет вам поймать потенциальные источники ошибок.</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">В каждом подкомпоненте &lt;code&gt;new Vue&lt;/code&gt; экземпляра Vue к этому корневому экземпляру можно получить доступ с помощью свойства &lt;code&gt;$root&lt;/code&gt; . Например, в этом корневом экземпляре:</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">Фактически, вы можете думать о внедрении зависимостей как о своего рода &amp;laquo;дальнобойных опорах&amp;raquo;, за исключением:</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">В общем, всякий раз, когда что-то может быть достигнуто с помощью простого JavaScript, мы не хотим вводить специальный синтаксис, такой как фильтры, чтобы решить ту же проблему. Вот как вы можете заменить встроенные фильтры директив Vue:</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">В больших приложениях нам может потребоваться разделить приложение на более мелкие части и загружать компонент с сервера только тогда, когда это необходимо. Чтобы упростить это, Vue позволяет вам определить ваш компонент как фабричную функцию, которая асинхронно разрешает определение вашего компонента. Vue будет запускать фабричную функцию только тогда, когда компонент нужно отрендерить, и кэширует результат для будущих повторных отрисовок. Например:</target>
        </trans-unit>
        <trans-unit id="0e1a8f47d0de2c3d5f962fb51601c60c71a4205c" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a &lt;code&gt;defineAsyncComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">Во многих проектах Vue глобальные компоненты будут определяться с помощью &lt;code&gt;Vue.component&lt;/code&gt; , за которым следует &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; для нацеливания на элемент контейнера в теле каждой страницы.</target>
        </trans-unit>
        <trans-unit id="46c352f653c2ccd99c8d1eeb1bac3b46074aed40" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;app.component()&lt;/code&gt;, followed by &lt;code&gt;app.mount('#app')&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">Однако во многих случаях вы все равно &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; странным поведением (например, 0,035.toFixed (2) округляет до &lt;code&gt;0.04&lt;/code&gt; , а &lt;code&gt;0.045&lt;/code&gt; округляется до &lt;code&gt;0.04&lt;/code&gt; ). Чтобы обойти эти проблемы, вы можете использовать &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt; библиотеку для более надежного форматирования валют.</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">Во многих случаях вам может потребоваться такое же поведение при &lt;code&gt;bind&lt;/code&gt; и &lt;code&gt;update&lt;/code&gt; , но не заботиться о других хуках. Например:</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">В большинстве случаев Vue может автоматически определить, когда переход завершен. По умолчанию Vue ожидает первого события &lt;code&gt;transitionend&lt;/code&gt; или &lt;code&gt;animationend&lt;/code&gt; в корневом элементе перехода. Однако это не всегда может быть желательным - например, у нас может быть хореографическая последовательность переходов, в которой некоторые вложенные внутренние элементы имеют отложенный переход или более длительную продолжительность перехода, чем корневой переходный элемент.</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">В большинстве случаев лучше избегать обращения к другим экземплярам компонентов или ручного манипулирования элементами DOM. Однако есть случаи, когда это может быть целесообразным.</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">В большинстве случаев,обращение к родителю затрудняет отладку и понимание вашего приложения,особенно если вы мутируете данные в родителе.При последующем рассмотрении этого компонента будет очень сложно понять,откуда взялась эта мутация.</target>
        </trans-unit>
        <trans-unit id="d68b5e8d96b9910b923cbe675afd9e3c75b80ac2" translate="yes" xml:space="preserve">
          <source>In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">В естественном английском языке прилагательные и другие дескрипторы обычно появляются перед существительными,в то время как исключения требуют соединительных слов.Например:</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">В обычных случаях вам не нужно вызывать этот метод самостоятельно. Предпочитайте управлять жизненным циклом дочерних компонентов на основе данных с помощью &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9689e82d55bf91d0bdb0a6e4890e0cb8c481ba5f" translate="yes" xml:space="preserve">
          <source>In order to be more explicit and legible, we have now renamed these initial state classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7967705f3df6230388a8007a18675ebf06f8935f" translate="yes" xml:space="preserve">
          <source>In order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays &lt;code&gt;i18n&lt;/code&gt; ready strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f3b2527a93cc83ec0b5cf78ef1f46a48fed02f" translate="yes" xml:space="preserve">
          <source>In other cases, it returns a stop handle which can be called to explicitly stop the watcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3930e2dc2ac43f310bce905c8d03f08738173196" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;ref&lt;/code&gt; creates a &lt;strong&gt;Reactive Reference&lt;/strong&gt; to our value. The concept of working with &lt;strong&gt;References&lt;/strong&gt; will be used often throughout the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26030f8aadd2fe6b946e53d81af4d02ba1edcf5f" translate="yes" xml:space="preserve">
          <source>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b63ec681a094ed6d524d075cda699de0092770" translate="yes" xml:space="preserve">
          <source>In other words, you &lt;strong&gt;will not have access&lt;/strong&gt; to the following component options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">В нашем случае, давайте укажем на компонент &lt;code&gt;tree-folder&lt;/code&gt; . Мы знаем, что дочерним элементом, который создает парадокс, является компонент &lt;code&gt;tree-folder-contents&lt;/code&gt; , поэтому мы подождем, пока &lt;code&gt;beforeCreate&lt;/code&gt; жизненного цикла beforeCreate не зарегистрирует его:</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">По нашему опыту, лучше &lt;em&gt;всегда&lt;/em&gt; добавлять уникальный ключ, чтобы вам и вашей команде просто не приходилось беспокоиться об этих крайних случаях. Затем в редких, критичных к производительности сценариях, когда постоянство объекта не требуется, вы можете сделать сознательное исключение.</target>
        </trans-unit>
        <trans-unit id="78698544f2ebea81bf74621176fba4067b232946" translate="yes" xml:space="preserve">
          <source>In our experience, it's better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9363da25541b78e6af0972c3f9bb895597ac0" translate="yes" xml:space="preserve">
          <source>In previous example, you may want the same behavior on &lt;code&gt;mounted&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt;, but don't care about the other hooks. You can do it by passing the callback to directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">В ситуациях, когда вычисленные свойства невозможны (например, внутри вложенных циклов &lt;code&gt;v-for&lt;/code&gt; ), вы можете использовать метод:</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">В некоторых случаях нам может потребоваться &amp;laquo;двусторонняя привязка&amp;raquo; для опоры. К сожалению, истинная двусторонняя привязка может создать проблемы с обслуживанием, поскольку дочерние компоненты могут изменять родительский элемент, при этом источник этой мутации не является очевидным как для родительского, так и для дочернего компонентов.</target>
        </trans-unit>
        <trans-unit id="d3a61aecf34702fc3ac15dbd55af0193cd0d21b7" translate="yes" xml:space="preserve">
          <source>In some cases, we might need &quot;two-way binding&quot; for a prop (sometimes in addition to existing &lt;code&gt;v-model&lt;/code&gt; for the different prop). To do so, we recommended emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, for &lt;code&gt;ChildComponent&lt;/code&gt; from the previous example with the &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">В таких случаях вы можете указать явную продолжительность перехода (в миллисекундах), используя свойство &lt;code&gt;duration&lt;/code&gt; в компоненте &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a26c3605ae94474098786b85b0faf6c2e5c873c" translate="yes" xml:space="preserve">
          <source>In terms of what has changed, at a high level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">В этом случае прослушиватель &lt;code&gt;.native&lt;/code&gt; в родительском элементе будет молча прерван . &lt;code&gt;onFocus&lt;/code&gt; не будет , но обработчик onFocus не будет вызван, когда мы этого ожидали.</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">В &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;каталоге &lt;/a&gt; &lt;code&gt;dist/&lt;/code&gt; пакета NPM вы найдете множество различных сборок Vue.js. Вот обзор разницы между ними:</target>
        </trans-unit>
        <trans-unit id="096cc70c4fb5904b4142f8704ac2119fe695246e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the npm package (opens new window)&lt;/a&gt; you will find many different builds of Vue.js. Here is an overview of which &lt;code&gt;dist&lt;/code&gt; file should be used depending on the use-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере обработчик будет вызываться только в том случае, если &lt;code&gt;$event.key&lt;/code&gt; равно &lt;code&gt;'PageDown'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3446d8a02b83d478e2220ffc2e826c8e079f0f9" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">В случае булевых атрибутов, где их простое существование подразумевает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;v-bind&lt;/code&gt; работает немного иначе. В этом примере:</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">В консоли введите &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; . Вы должны увидеть новый элемент, добавленный к списку.</target>
        </trans-unit>
        <trans-unit id="baf8e367f46b7e0b83ce3e0f831c56fb3167cb4c" translate="yes" xml:space="preserve">
          <source>In the event we need to define the status of the date-picker component via a &lt;code&gt;data-status&lt;/code&gt; property, it will be applied to the root node (i.e., &lt;code&gt;div.date-picker&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;currentTabComponent&lt;/code&gt; может содержать:</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">В приведенном выше примере либо атрибут &amp;laquo; &lt;code&gt;appear&lt;/code&gt; , либо хук &lt;code&gt;v-on:appear&lt;/code&gt; вызовет переход &amp;laquo;появление&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="483be1a650754b9854fa661d0a114900f298cd73" translate="yes" xml:space="preserve">
          <source>In the example above, if we change the list of &lt;code&gt;todos&lt;/code&gt;, this change won't be reflected in the injected &lt;code&gt;todoLength&lt;/code&gt; property. This is because &lt;code&gt;provide/inject&lt;/code&gt; bindings are &lt;em&gt;not&lt;/em&gt; reactive by default. We can change this behavior by passing a &lt;code&gt;ref&lt;/code&gt; property or &lt;code&gt;reactive&lt;/code&gt; object to &lt;code&gt;provide&lt;/code&gt;. In our case, if we wanted to react to changes in the ancestor component, we would need to assign a Composition API &lt;code&gt;computed&lt;/code&gt; property to our provided &lt;code&gt;todoLength&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2def93c9e7b3255befa3e7efa09f860a33357348" translate="yes" xml:space="preserve">
          <source>In the example above, the method &lt;code&gt;increment&lt;/code&gt; will be called when the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">В будущем вы можете обратиться к &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;справочнику&lt;/a&gt; по API для получения полного списка свойств и методов экземпляра.</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">В родительском &lt;code&gt;postFontSize&lt;/code&gt; мы можем поддерживать эту функцию, добавив свойство данных postFontSize :</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">В двух приведенных выше примерах мы передаем строковые значения, но на самом деле в опору можно передать значение &lt;em&gt;любого&lt;/em&gt; типа.</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">В этих случаях вы также можете использовать &lt;code&gt;key&lt;/code&gt; атрибут для перехода между разными состояниями одного и того же элемента. Вместо использования &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-else&lt;/code&gt; приведенный выше пример можно переписать как:</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">В этих случаях вы можете определить ваши компоненты как простые JavaScript-объекты:</target>
        </trans-unit>
        <trans-unit id="ba09958fde7b27bfaf33999c7469e63cc8666df2" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;change&lt;/code&gt; event listener is passed from the parent component to the child and it will be triggered on native &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;code&gt;change&lt;/code&gt; event. We won't need to emit an event from the &lt;code&gt;date-picker&lt;/code&gt; explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">В этом случае &lt;code&gt;filterA&lt;/code&gt; , определенный с одним аргументом, получит значение &lt;code&gt;message&lt;/code&gt; , а затем будет &lt;code&gt;filterB&lt;/code&gt; функция filterB с результатом &lt;code&gt;filterA&lt;/code&gt; , переданным в единственный аргумент &lt;code&gt;filterB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b094d0f631f3cc4f6960b2f03d3f031dd3ba5545" translate="yes" xml:space="preserve">
          <source>In this case, child component will expect a &lt;code&gt;title&lt;/code&gt; prop and emits &lt;code&gt;update:title&lt;/code&gt; event to sync:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87475fd1d00b371cef287b525052f62f24411b8f" translate="yes" xml:space="preserve">
          <source>In this case, even when &lt;code&gt;child-component&lt;/code&gt; is rendered in the different place, it will remain a child of &lt;code&gt;parent-component&lt;/code&gt; and will receive a &lt;code&gt;name&lt;/code&gt; prop from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">В этом случае для &lt;code&gt;class&lt;/code&gt; определены два разных значения :</target>
        </trans-unit>
        <trans-unit id="35bd1cc27abd4ba52e44235a43fbbdc36c5c6e07" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API) and sets a condition for performing this operation. None of that would be possible with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">В этом случае использование опции &lt;code&gt;watch&lt;/code&gt; позволяет нам выполнять асинхронную операцию (доступ к API), ограничивать частоту выполнения этой операции и устанавливать промежуточные состояния до тех пор, пока мы не получим окончательный ответ. Ничего из этого было бы невозможно с вычисляемым свойством.</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">В этом компоненте всем потомкам &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; нужен доступ к методу &lt;code&gt;getMap&lt;/code&gt; , чтобы знать, с какой картой взаимодействовать. К сожалению, использование свойства &lt;code&gt;$parent&lt;/code&gt; плохо масштабировалось для более глубоко вложенных компонентов. Вот где может быть полезно внедрение зависимостей с использованием двух новых параметров экземпляра: &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f4bcb81fce1b99e6d7bcbd862cd7e2191686fff" translate="yes" xml:space="preserve">
          <source>In this example, we are creating animation through the use of interpolation, attached to the mouse movement. The CSS transition is applied to the element as well, to let the element know what kind of easing to use while it's updating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">В этом примере мы решили назвать объект, содержащий все наши реквизиты &lt;code&gt;slotProps&lt;/code&gt; , slotProps , но вы можете использовать любое имя, какое захотите.</target>
        </trans-unit>
        <trans-unit id="b16da33edc850538e8b64bc474cfc99b18b1ed65" translate="yes" xml:space="preserve">
          <source>In this example, we've chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">В этом примере, когда значение &lt;code&gt;eventName&lt;/code&gt; равно &lt;code&gt;&quot;focus&quot;&lt;/code&gt; , &lt;code&gt;v-on:[eventName]&lt;/code&gt; будет эквивалентно &lt;code&gt;v-on:focus&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee4d6d04f3346c2de61ff6305b7eecf8246b8e0" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;'s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301b4eda5dbc41617be06964e971e23018f19d78" translate="yes" xml:space="preserve">
          <source>In this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e78735239ecbe7e73bb9d8e2936f204860e9c" translate="yes" xml:space="preserve">
          <source>In this next section, we'll go over some web animation and transitions basics, and link off to some resources for further exploration. If you're already familiar with web animation and how those principles might work with some of Vue's directives, feel free to skip this next section. For anyone else looking to learn a little more about web animation basics before diving in, read on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90fada6407b38a0e73129e45014412d2857eb5" translate="yes" xml:space="preserve">
          <source>In this, any change to &lt;code&gt;todos.length&lt;/code&gt; will be reflected correctly in the components, where &lt;code&gt;todoLength&lt;/code&gt; is injected. Read more about &lt;code&gt;computed&lt;/code&gt; in the &lt;a href=&quot;reactivity-computed-watchers#computed-values&quot;&gt;Computed and Watch section&lt;/a&gt; and &lt;code&gt;reactive&lt;/code&gt; provide/inject in the &lt;a href=&quot;composition-api-provide-inject#reactivity&quot;&gt;Composition API section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83141900cc37f0045fe7fc8eeac34df78525c24e" translate="yes" xml:space="preserve">
          <source>In v2.1.8, we introduced &lt;code&gt;v-enter-to&lt;/code&gt; to address the timing gap between enter/leave transitions. However, for backward compatibility, the &lt;code&gt;v-enter&lt;/code&gt; name was untouched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a932790edae9a805888ba88043f905fae94eda92" translate="yes" xml:space="preserve">
          <source>In-browser Sandbox on &lt;a href=&quot;https://v3.vue.new&quot;&gt;CodeSandbox (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18af7a938545bae476e6597aaaf4d9729f2bb10a" translate="yes" xml:space="preserve">
          <source>In-browser playground on &lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot;&gt;Codepen (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b54df78801726764e7a6e4a3da6b7ab270929d" translate="yes" xml:space="preserve">
          <source>In-browser template compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb555d4f2dd9b0c24bb7bd03390992336ca209c" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">Выражения внутри шаблона очень удобны,но предназначены для простых операций.Слишком много логики в ваших шаблонах может сделать их раздутыми и сложными в обслуживании.Например:</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">Отдельные узлы</target>
        </trans-unit>
        <trans-unit id="8a0e39acb1c9c6d6a7975a0cc9ac25b374494a2e" translate="yes" xml:space="preserve">
          <source>Information about the parent document: footnotes/copyrights/links to privacy statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7754e67b3434e8bddbe642373114506a298fbefb" translate="yes" xml:space="preserve">
          <source>Information and the operation of user interface must be understandable to all users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">Информация для разработчиков реакторов</target>
        </trans-unit>
        <trans-unit id="f7fe66c9daa7dc6cfca9b6a287a3553348c8c87d" translate="yes" xml:space="preserve">
          <source>Injecting a property into the root component, with a value provided by the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bfac40439f515d418c73435ab088df8607873d" translate="yes" xml:space="preserve">
          <source>Injections can be optional with default value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55df74fbab3d4d77132f63aeb4395de7ec9a282" translate="yes" xml:space="preserve">
          <source>Inline Template Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">Интернет-шаблоны</target>
        </trans-unit>
        <trans-unit id="b59e8ce6b81b97e1c066f696c45f14d51b2387b4" translate="yes" xml:space="preserve">
          <source>Inline templates attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351cce80f83cbfe40944664026f6d9aab7cb539" translate="yes" xml:space="preserve">
          <source>Inlines all Vue core internal packages - i.e. it's a single file with no dependencies on other files. This means you must import everything from this file and this file only to ensure you are getting the same instance of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef635bdfe6ae64380c953e554f1a2566d43a6f8" translate="yes" xml:space="preserve">
          <source>Input fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">Внутри блоков &lt;code&gt;v-for&lt;/code&gt; у нас есть полный доступ к свойствам родительской области. &lt;code&gt;v-for&lt;/code&gt; также поддерживает необязательный второй аргумент для индекса текущего элемента.</target>
        </trans-unit>
        <trans-unit id="916038a23e13909a2f75bbe445827872088c10bc" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Установите плагин Vue.js. Если плагин является объектом, он должен предоставлять метод &lt;code&gt;install&lt;/code&gt; . Если это сама функция, она будет рассматриваться как метод установки. Будет вызван метод установки с аргументом Vue.</target>
        </trans-unit>
        <trans-unit id="d8a20feef8f2799f45b48c087bb1f2c9b59bf8bd" translate="yes" xml:space="preserve">
          <source>Install it using &lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d6d358674017f8697b8b19f7ff45ce7429f3312b" translate="yes" xml:space="preserve">
          <source>Installing Rollup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">Экземпляр DOM-параметры</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">Крюки для жизненного цикла</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">Экземпляры Методы/Данные</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">Экстраординационные методы/события</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">Экстраординарные методы/Жизненный цикл</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">Свойства вещества</target>
        </trans-unit>
        <trans-unit id="8e111ccced14747a0574e33ed0b08f79642573af" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;author.books&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;publishedBooksMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">Вместо вычисляемого свойства мы можем определить ту же функцию как метод. Для конечного результата эти два подхода действительно абсолютно одинаковы. Однако разница в том, что &lt;strong&gt;вычисляемые свойства кэшируются на основе их реактивных зависимостей. &lt;/strong&gt;Вычисляемое свойство будет повторно оцениваться только после изменения некоторых его реактивных зависимостей. Это означает, что, пока &lt;code&gt;message&lt;/code&gt; не изменилось, множественный доступ к вычисляемому свойству &lt;code&gt;reversedMessage&lt;/code&gt; немедленно вернет ранее вычисленный результат без необходимости повторного запуска функции.</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">Вместо привязки непосредственно к названию метода,мы можем также использовать методы в встроенном операторе JavaScript:</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">Вместо того, чтобы жестко кодировать содержимое для каждой задачи, мы можем позволить родительскому компоненту взять на себя управление, сделав каждую задачу в слот, а затем &lt;code&gt;todo&lt;/code&gt; как свойство слота:</target>
        </trans-unit>
        <trans-unit id="4b69ebfba064bf598fe0cf47768da6d783b96402" translate="yes" xml:space="preserve">
          <source>Instead of using filters, we recommend replacing them with computed properties or methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">Вместо использования этого интерфейса для отслеживания событий, &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; самим хранилищем (например, store.on ('mutation', callback) ), вводится новый метод &lt;code&gt;store.subscribe&lt;/code&gt; . Типичное использование внутри плагина:</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">Вместо этого &lt;strong&gt;параметр &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;data&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; компонента должен быть функцией&lt;/strong&gt; , чтобы каждый экземпляр мог поддерживать независимую копию возвращаемого объекта данных:</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">Вместо этого,извлекайте реактивные данные напрямую.</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">Вместо этого мы рекомендуем объединить два префикса в &lt;code&gt;$_&lt;/code&gt; в качестве соглашения для определяемых пользователем частных свойств, которые гарантируют отсутствие конфликтов с Vue.</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">Вместо этого мы хотим,чтобы каждый экземпляр компонента управлял только своими данными.Для этого каждый экземпляр должен сгенерировать уникальный объект данных.В JavaScript это можно сделать,вернув объект в функцию:</target>
        </trans-unit>
        <trans-unit id="96b563c3c711449585b436481ceb793428c3903f" translate="yes" xml:space="preserve">
          <source>Instead, you can make your global filters available to all components through &lt;a href=&quot;../../api/application-config#globalproperties&quot;&gt;globalProperties&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">Вместо этого,вы должны всегда указывать имя слота,если вы хотите использовать сокращение:</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">Вместо этого вы должны использовать массив &lt;strong&gt;объектов,&lt;/strong&gt; чтобы &lt;code&gt;v-model&lt;/code&gt; могла обновлять поле объекта. Например:</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">Интеграция сторонних маршрутизаторов</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">Интересно,что существует довольно много сходства в том,как Angular и Vue решают эти вопросы AngularJS.</target>
        </trans-unit>
        <trans-unit id="99dbe2588887c00092f294adc50297fc9daf034b" translate="yes" xml:space="preserve">
          <source>Interface forms, controls, and navigation are operable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd4997099c9dd515cd8fce4f842d086b138a78e" translate="yes" xml:space="preserve">
          <source>Internal Helpers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">Внутренне скопированные слоты работают,обертывая содержимое слота в функцию,передающую один единственный аргумент:</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">Интерполяция &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; полей ( &amp;lt;textarea&amp;gt; {{text}} &amp;lt;/textarea&amp;gt; ) не работает. Вместо этого используйте &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="722656fd1f60b606e49464736f37b7a9d40935be" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Интерполяция в атрибутах &lt;sup&gt;удалена.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">Интерполяция внутри атрибутов больше недействительна.Например:</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="9ac25b7dbef348b38cd7447ba00e5e06fcb8b0d0" translate="yes" xml:space="preserve">
          <source>It also automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">Кроме того,это значительно облегчает дизайнерам и менее опытным разработчикам анализ и внесение вклада в разработку кодовой базы.</target>
        </trans-unit>
        <trans-unit id="a407600c5553a0b6afce3b2e7009380cff190cf2" translate="yes" xml:space="preserve">
          <source>It also makes it possible to use values other than &lt;code&gt;'true'&lt;/code&gt; and &lt;code&gt;'false'&lt;/code&gt;, or even keywords yet to come, for attributes like &lt;code&gt;contenteditable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50744937982614ead76f6bef3b2eb792cfd3c531" translate="yes" xml:space="preserve">
          <source>It also returns &lt;code&gt;true&lt;/code&gt; if the proxy is created by &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, but is wrapping another proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">Его также можно использовать для принудительной замены элемента/компонента вместо повторного использования.Это может быть полезно,когда вы этого хотите:</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">Он не может создавать проекты из пользовательских &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;предустановок&lt;/a&gt; , что может быть особенно полезно для корпоративных сред с заранее установленными соглашениями.</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">Это зависит от нескольких факторов:</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Он не допускает никакой конфигурации во время генерации проекта, в то время как Vue CLI работает поверх обновляемой зависимости времени выполнения, которая может быть расширена с помощью &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;плагинов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">Обычно перемещение по вложенным подкаталогам занимает больше времени, чем прокрутка отдельного каталога &lt;code&gt;components&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338465a67b58e6eaa9650c8e5d83c288832f2b5a" translate="yes" xml:space="preserve">
          <source>It is a common practice for plugin authors to install the plugins automatically in their UMD builds using &lt;code&gt;Vue.use&lt;/code&gt;. For instance, this is how the official &lt;code&gt;vue-router&lt;/code&gt; plugin installs itself in a browser environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">Очень часто необходимо вызывать &lt;code&gt;event.preventDefault()&lt;/code&gt; или &lt;code&gt;event.stopPropagation()&lt;/code&gt; внутри обработчиков событий. Хотя мы можем легко сделать это внутри методов, было бы лучше, если бы методы могли быть связаны исключительно с логикой данных, а не иметь дело с деталями событий DOM.</target>
        </trans-unit>
        <trans-unit id="b9b82ff6a9ecc8371804166f686dd29269fd8e00" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &quot;else block&quot; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">Также можно добавить &amp;laquo;блок else&amp;raquo; с помощью &lt;code&gt;v-else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2528b05b485478cec60d8b3a4617e597495c046e" translate="yes" xml:space="preserve">
          <source>It is also possible to call a method directly from a template. As we'll see shortly, it's usually better to use a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; instead. However, using a method can be useful in scenarios where computed properties aren't a viable option. You can call a method anywhere that a template supports JavaScript expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821ab047e92b1bb797a359c27dd615c7dcb8237f" translate="yes" xml:space="preserve">
          <source>It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11aad10ac88ab1f4f9941c1804dfd826b7419eb" translate="yes" xml:space="preserve">
          <source>It is best to provide all the information the user needs to fill out forms outside any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c0231656f976858a53174ef4b684db8fe6384f" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you document all of the events emitted by each of your components using &lt;code&gt;emits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">Больше не поддерживается использование &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; с тем же именем в одном шаблоне. Когда слот визуализируется, он &amp;laquo;израсходован&amp;raquo; и не может быть визуализирован где-либо еще в том же дереве визуализации. Если вам необходимо отобразить один и тот же контент в нескольких местах, передайте это содержимое как опору.</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">Теперь запрещено заменять root $ data экземпляра компонента. Это предотвращает некоторые крайние случаи в системе реактивности и делает состояние компонента более предсказуемым (особенно с системами проверки типов).</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">Часто бывает хорошей идеей связать с объектом стиля напрямую так,чтобы шаблон был чище:</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Часто упускается из виду, что источником истины в приложениях Vue является необработанный объект &lt;code&gt;data&lt;/code&gt; - экземпляр Vue только передает к нему доступ. Следовательно, если у вас есть часть состояния, которая должна совместно использоваться несколькими экземплярами, вы можете поделиться ею по идентификатору:</target>
        </trans-unit>
        <trans-unit id="bc0742430bf64e7ed852fa2fe5b348a0bbd7e7ff" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the reactive &lt;code&gt;data&lt;/code&gt; object - a component instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can use a &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; method to make an object reactive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5941b8bede80f37fd666d64ae0a8585594d8e00a" translate="yes" xml:space="preserve">
          <source>It is possible to add a new property directly to the component instance without including it in &lt;code&gt;data&lt;/code&gt;. However, because this property isn't backed by the reactive &lt;code&gt;$data&lt;/code&gt; object, it won't automatically be tracked by &lt;a href=&quot;reactivity&quot;&gt;Vue's reactivity system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37285a48f031be7bbbf86e2ffcd3313292517a4b" translate="yes" xml:space="preserve">
          <source>It is recommended to avoid using both on the same element due to the syntax ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751efadc9528a2e4327d95ba9475fe587b4ec316" translate="yes" xml:space="preserve">
          <source>It is recommended to define all emitted events in order to better document how a component should work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">Рекомендуется по возможности предоставлять &lt;code&gt;key&lt;/code&gt; атрибут с &lt;code&gt;v-for&lt;/code&gt; , если только повторяющееся содержимое DOM не является простым или если вы намеренно не полагаетесь на поведение по умолчанию для повышения производительности.</target>
        </trans-unit>
        <trans-unit id="9f05d3baca3585e87a234c817a735dc07843bbe4" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode (opens new window)&lt;/a&gt; with our official extension &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=octref.vetur&quot;&gt;Vetur (opens new window)&lt;/a&gt;, which provides comprehensive IDE support for Vue 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7779dc053f2ed486b907c53be703697ec71f15b" translate="yes" xml:space="preserve">
          <source>It is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy &lt;a href=&quot;https://caniuse.com/#feat=html5semantic&quot;&gt;browsers that don&amp;rsquo;t support HTML5 semantic elements (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">В основном это работает хорошо, но отложенные обновления состояния могут вызвать странное поведение. Например, щелкните вкладку &amp;laquo; &lt;code&gt;Result&lt;/code&gt; &amp;raquo; и попробуйте ввести &lt;code&gt;9.999&lt;/code&gt; в один из этих входов. Когда вход теряет фокус, его значение обновляется до &lt;code&gt;$10.00&lt;/code&gt; . Однако, посмотрев на рассчитанную сумму, вы увидите, что &lt;code&gt;9.999&lt;/code&gt; - это то, что хранится в наших данных. Версия реальности, которую видит пользователь, не синхронизирована!</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">Он предлагает только один шаблон, который предполагает, что вы создаете одностраничное приложение, в то время как Vue предлагает широкий спектр параметров по умолчанию для различных целей и систем сборки.</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">Для этого требуется сохранить &lt;code&gt;picker&lt;/code&gt; в экземпляре компонента, если возможно, что доступ к нему потребуется только хукам жизненного цикла. Это не страшно, но это можно считать беспорядком.</target>
        </trans-unit>
        <trans-unit id="4498754208578dfe241aa59ce513436b21cdefe3" translate="yes" xml:space="preserve">
          <source>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c27ec712f1c3f7f2e2036cb2ee97cb69409b690" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;these limitations do &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">Следует отметить, что &lt;strong&gt;это ограничение &lt;em&gt;не&lt;/em&gt; применяется, если вы используете строковые шаблоны из одного из следующих источников&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">Он сделает:</target>
        </trans-unit>
        <trans-unit id="13566b680265d72cb595dc1be3858a3b3f978e1f" translate="yes" xml:space="preserve">
          <source>It would be much nicer if we could collocate code related to the same logical concern. And this is exactly what the Composition API enables us to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">На самом деле можно переходить между любым количеством элементов, используя несколько &lt;code&gt;v-if&lt;/code&gt; или привязав один элемент к динамическому свойству. Например:</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">Также неплохо явно добавить &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; для переходов только для JavaScript, чтобы Vue мог пропустить обнаружение CSS. Это также предотвращает случайное вмешательство правил CSS в переход.</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">Обычно приложение организовано в виде дерева вложенных компонентов:</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">Проще найти реализации функций обработчика в коде JS, просмотрев HTML-шаблон.</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">Также легко переключить наличие элемента:</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">Важно отметить, что многие из этих ограничений являются намеренными дизайнерскими решениями, принимаемыми командой create-react-app, и у них есть свои преимущества. Например, если потребности вашего проекта очень просты и вам никогда не нужно &amp;laquo;извлекать&amp;raquo; для настройки процесса сборки, вы сможете обновить его как зависимость. Вы можете узнать больше о &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;различных философиях здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">Важно отметить, что вы никогда не должны заменять исходный объект состояния в своих действиях - компоненты и хранилище должны совместно использовать ссылку на один и тот же объект, чтобы можно было наблюдать мутации.</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">В JavaScript редко когда-либо упоминаются глобальные компоненты, поэтому соблюдение соглашения для JavaScript не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">Рекомендуется обернуть все содержимое в новый элемент, например:</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">Иногда бывает полезно передать определенное значение с событием. Например, мы можем захотеть, чтобы компонент &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; отвечал за то, на сколько увеличивать текст. В таких случаях мы можем использовать второй параметр &lt;code&gt;$emit&lt;/code&gt; для предоставления этого значения:</target>
        </trans-unit>
        <trans-unit id="8852ff75403c297afd1a8a3cdb0552cf73fe06bf" translate="yes" xml:space="preserve">
          <source>It's actually possible to transition between any number of elements, either by using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt; or binding a single element to a dynamic property. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad47c16fba81b79a86241bf8888fad85c94ce363" translate="yes" xml:space="preserve">
          <source>It's common for an app to be organized into a tree of nested components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af319375896cfcb2ac29299a5aeee693d621695" translate="yes" xml:space="preserve">
          <source>It's easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17ba0c11ce9ca8328a5aebef189aaa88d9ead34" translate="yes" xml:space="preserve">
          <source>It's easy to toggle the presence of an element, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cd7c29493393f218043384194d7b5510c8dde1" translate="yes" xml:space="preserve">
          <source>It's generally recommended to keep directives independent of the component instance they are used in. Accessing the instance from within a custom directive is often a sign that the directive should rather be a component itself. However, there are situations where this actually makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f29b81017a607c886e9905a378f2d9bd55f8c75" translate="yes" xml:space="preserve">
          <source>It's important to note the runtime config only affects runtime template compilation - it won't affect pre-compiled templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd4ae770137b3e9b3a6d876b8827f3129a2fcc" translate="yes" xml:space="preserve">
          <source>It's much more common for a component to use &lt;code&gt;props&lt;/code&gt; than the other properties, and very often a component uses only &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebac3eeeb53ba07a891673ff03acf90d6ccc73e" translate="yes" xml:space="preserve">
          <source>It's now much clearer what the difference between these states is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a696ed981dd37807dbf8cb59239f76cfd4a209" translate="yes" xml:space="preserve">
          <source>It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320f04e4adc498746e8285c25d0174bb0a242c0d" translate="yes" xml:space="preserve">
          <source>It's sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can pass a second parameter to &lt;code&gt;$emit&lt;/code&gt; to provide this value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7d46141f064bc144bcd65cad47e0b1500c6ec5" translate="yes" xml:space="preserve">
          <source>Iteration &amp;amp; Communication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab84ddacf62192827bb778b54f0d73df28c81a56" translate="yes" xml:space="preserve">
          <source>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cc248e464b2aea646387386136d3ee2f3468fd" translate="yes" xml:space="preserve">
          <source>JAWS (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX против Шаблонов</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScript Hooks</target>
        </trans-unit>
        <trans-unit id="6cea98e1f2bba3a82d53ff16b1849c803f2e2665" translate="yes" xml:space="preserve">
          <source>JavaScript doesn&amp;rsquo;t usually work like this -- If we were to write something comparable in JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">Собственный &lt;code&gt;.filter&lt;/code&gt; JavaScript также может управлять гораздо более сложными операциями фильтрации, поскольку у вас есть доступ ко всей мощи JavaScript в рамках вычисляемых свойств. Например, если вы хотите найти всех активных пользователей и сопоставить их имя и адрес электронной почты без учета регистра:</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="a46d5413cffceb72c83f4112df056475b52ee003" translate="yes" xml:space="preserve">
          <source>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Присоединяйтесь к сообществу Vue.js!</target>
        </trans-unit>
        <trans-unit id="b05d0122984642cf7090c52ffdac8dd94d5f6d18" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;resolveDynamicComponent&lt;/code&gt; supports passing a component name, an HTML element name, or a component options object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b48b329205efd9bbd9fce3544a036c29c0a8fa" translate="yes" xml:space="preserve">
          <source>Just like all other properties of the component instance, the &lt;code&gt;methods&lt;/code&gt; are accessible from within the component's template. Inside a template they are most commonly used as event listeners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa1596972789e18182ccfc21abdfcfd9e0ff36e" translate="yes" xml:space="preserve">
          <source>Just like how we set up a watcher on the &lt;code&gt;user&lt;/code&gt; property inside our component using the &lt;code&gt;watch&lt;/code&gt; option, we can do the same using the &lt;code&gt;watch&lt;/code&gt; function imported from Vue. It accepts 3 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">Как и в случае с элементами HTML, часто бывает полезно иметь возможность передавать контент в компонент, например:</target>
        </trans-unit>
        <trans-unit id="a98b5180199c5ab496bb93100cd4afe9c3a4168f" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it's often useful to be able to pass content to a component, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">Просто для поддержки относительно небольшой разметки в шаблоне:</target>
        </trans-unit>
        <trans-unit id="ba65d86ead17c56d628584a8788a419c56876378" translate="yes" xml:space="preserve">
          <source>Keep in mind that we've only scratched the surface of Composition API and what it allows us to do. To learn more about it, refer to the in-depth guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">Однако имейте в виду, что компоненты, построенные по этому шаблону, все еще хрупки по своей природе. Например, представьте, что мы добавляем новый компонент &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; , и когда в нем появляется &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; , он должен отображать только маркеры, попадающие в эту область:</target>
        </trans-unit>
        <trans-unit id="467e7f276ee2b9a2f53b3949e288efde8bd26ea9" translate="yes" xml:space="preserve">
          <source>Key Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">Ключевые коды</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">Ключевые модификаторы</target>
        </trans-unit>
        <trans-unit id="6c5f93229012cbadeede1c515b6352e435db9e2b" translate="yes" xml:space="preserve">
          <source>KeyCode Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Keyed &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;essential&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">Ключ v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">Knockout был пионером в области MVVM и отслеживания зависимостей, и его система реактивности очень похожа на Vue. Его &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;поддержка браузером&lt;/a&gt; также очень впечатляет, учитывая все, что он делает, с поддержкой IE6! Vue, с другой стороны, поддерживает только IE9 +.</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="e61cef41ba854e90306988f5c1e5bd34137d6595" translate="yes" xml:space="preserve">
          <source>Labels are typically placed on top or to the left of the form fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24edb29b6ba5554a247bb7953f4370fb8f7aae0" translate="yes" xml:space="preserve">
          <source>Landmark Purpose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626b6c1d454d11a862220dbe8b7b34d0bcd6de9d" translate="yes" xml:space="preserve">
          <source>Landmarks</source>
          <target state="translated">Landmarks</target>
        </trans-unit>
        <trans-unit id="ec1be2a3865871adce929dfefc2959c96918a558" translate="yes" xml:space="preserve">
          <source>Landmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles&quot;&gt;ARIA roles (opens new window)&lt;/a&gt; to help you achieve this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">Большие приложения часто могут усложняться из-за множества частей состояния, разбросанных по многим компонентам, и взаимодействия между ними. Чтобы решить эту проблему, Vue предлагает &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt; : нашу собственную библиотеку управления состоянием, вдохновленную Elm. Он даже интегрируется в &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; , обеспечивая нулевой доступ к настройке для &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;отладки&lt;/a&gt; во времени .</target>
        </trans-unit>
        <trans-unit id="af32dbeca45c38e1ab5bbca67861fc2b513411a7" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://next.vuex.vuejs.org/&quot;&gt;Vuex (opens new window)&lt;/a&gt;, our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (opens new window)&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Наконец, стили в однофайловых компонентах Vue очень гибкие. С помощью &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt; вы можете использовать любой препроцессор, постпроцессор и даже глубокую интеграцию с &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модулями CSS&lt;/a&gt; - все в элементе &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">Последняя стабильная версия:2.6.10</target>
        </trans-unit>
        <trans-unit id="25f41560444b01511b3f085284b9287b245c68e3" translate="yes" xml:space="preserve">
          <source>Latest version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc4535d8b22b1a2065eb7b3e8da9f8806324bc4" translate="yes" xml:space="preserve">
          <source>Learn how to use teleport with a free lesson on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о внедрении зависимостей см. В документации &lt;a href=&quot;../api/index#provide-inject&quot;&gt;по API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">Кривая обучения</target>
        </trans-unit>
        <trans-unit id="c8de89461bb526135e97877a49d087c4f8f53917" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV guards&lt;/code&gt; (must be replaced by bundler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fa6a52f9f95d2228d742b21a7f9256e534287a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add &lt;code&gt;setup&lt;/code&gt; to our component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d915f196841018fe83a9580c35cc5af5850df5c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add it to our &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">Давайте погрузимся в простой пример, в котором функция &lt;code&gt;render&lt;/code&gt; будет практичной. Предположим, вы хотите создать привязанные заголовки:</target>
        </trans-unit>
        <trans-unit id="17834c351c272bdff2a7fbc013f9102fea710211" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that in our app, we have a view to show a list of repositories of a certain user. On top of that, we want to apply search and filter capabilities. Our component handling this view could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97599b335f4e992e78c12be5dd024497eba4df8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move our search functionality into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">Допустим, у вас есть список задач:</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">Допустим, вы хотите создать специальную директиву, которая позволяет закреплять элементы на странице с помощью фиксированного позиционирования. Мы могли бы создать специальную директиву, значение которой обновляет вертикальное позиционирование в пикселях, например:</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Допустим, вы строите дерево каталогов файлов, как в Finder или File Explorer. У вас может быть компонент &lt;code&gt;tree-folder&lt;/code&gt; с этим шаблоном:</target>
        </trans-unit>
        <trans-unit id="6c99d3d3fdfa8bd3e1baa14373a303cb25022aea" translate="yes" xml:space="preserve">
          <source>Let's assume that we want to rewrite the following code, which contains a &lt;code&gt;MyMap&lt;/code&gt; component that provides a &lt;code&gt;MyMarker&lt;/code&gt; component with the user's location, using the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad199543d13fb602b1787ea12617af19cdac14b3" translate="yes" xml:space="preserve">
          <source>Let's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a4107dc8befffcdc08d9bfc4c038af7438f2a1" translate="yes" xml:space="preserve">
          <source>Let's create an example custom modifier, &lt;code&gt;capitalize&lt;/code&gt;, that capitalizes the first letter of the string provided by the &lt;code&gt;v-model&lt;/code&gt; binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efaf7a4338ac2db9e77c15bcbe109038634f1e0" translate="yes" xml:space="preserve">
          <source>Let's dive deeper into how each argument can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965ee87d9a7fdfe5a2fefa407fc1fd4f95ef4d94" translate="yes" xml:space="preserve">
          <source>Let's dive into an example where a &lt;code&gt;render()&lt;/code&gt; function would be practical. Say we want to generate anchored headings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f68db1406bc20e0022ac27f2ee63637a48856" translate="yes" xml:space="preserve">
          <source>Let's look at this search field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b719b12c1068d11a2e6d04fa1b3077e20bd35b" translate="yes" xml:space="preserve">
          <source>Let's modify our &lt;code&gt;modal-button&lt;/code&gt; to use &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; and tell Vue &quot;&lt;strong&gt;teleport&lt;/strong&gt; this HTML &lt;strong&gt;to&lt;/strong&gt; the &quot;&lt;strong&gt;body&lt;/strong&gt;&quot; tag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098aabc545a2bc27663da4a434b6c0b7fe35c63e" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of todos:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3669759690ca7d10550e7dab45e8ba8a6d06189" translate="yes" xml:space="preserve">
          <source>Let's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16967b5d529c071e7c31b4b0d1d25c9f1bdbe5b1" translate="yes" xml:space="preserve">
          <source>Let's take a look at &lt;code&gt;modal-button&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67530659cbfc12250ac15b4825a7142987ed4730" translate="yes" xml:space="preserve">
          <source>Library Authors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">Диаграмма жизненного цикла</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">События жизненного цикла (в порядке их наименования)</target>
        </trans-unit>
        <trans-unit id="e15c95b3b57b4bc9945881310c2f7fa52f895a6d" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Registration Inside &lt;code&gt;setup&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">Крюки для жизненного цикла</target>
        </trans-unit>
        <trans-unit id="37857eb2e2aa8efab7a0ac716f62d18f83e34871" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76af71af244f2f6db8f83760d5be272f79f446b" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks can be registered with directly-imported &lt;code&gt;onX&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260f808c2d6d1ca9299afb5f45b0231a77889ebf" translate="yes" xml:space="preserve">
          <source>Lighthouse (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47cbdd94a999f599791f292c086fca7922c6de4" translate="yes" xml:space="preserve">
          <source>Like components and props, event names provide an automatic case transformation. If you emit an event from the child component in camel case, you will be able to add a kebab-cased listener in the parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aded01a7c9673b7fc6a79a471f805a19e31546" translate="yes" xml:space="preserve">
          <source>Likewise for &lt;code&gt;altKey&lt;/code&gt;, &lt;code&gt;shiftKey&lt;/code&gt;, and &lt;code&gt;metaKey&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df77b1e0de2b6983ce6696ce595e7de4eec752e" translate="yes" xml:space="preserve">
          <source>Line Highlighting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">Внесение в список/вынесение из него Переходы</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">Список Перемещение Переходы</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">Рендеринг списка</target>
        </trans-unit>
        <trans-unit id="7a1568935f8a040f0ddeb7118a253e76a0ba1ee0" translate="yes" xml:space="preserve">
          <source>List Rendering - &lt;code&gt;v-for&lt;/code&gt; with &lt;code&gt;v-if&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b44b03037bd0f155ca305c63ebd74b1d0758424" translate="yes" xml:space="preserve">
          <source>List Rendering - Displaying Filtered/Sorted Results</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014a81574bf11dd8c3a37e832221bd011f6da627" translate="yes" xml:space="preserve">
          <source>List Rendering: Maintaining State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">Список Переходов</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">Прослушивание настраиваемого события на текущей виртуальной машине. События могут запускаться с помощью &lt;code&gt;vm.$emit&lt;/code&gt; . Обратный вызов получит все дополнительные аргументы, переданные этим методам запуска событий.</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">Слушайте пользовательское мероприятие,но только один раз.Слушатель будет удален после первого срабатывания.</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">Слушайте событие только один раз с помощью &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">Прослушивание события с помощью &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Прослушивание собственных событий на компонентах с &lt;sup&gt;измененным &lt;/sup&gt; &lt;code&gt;v-on&lt;/code&gt; &lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">Прослушивание детских компонентов События</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">Прослушивание событий</target>
        </trans-unit>
        <trans-unit id="a5bab41dbcd17d889c6e2f819506e9dcf076f282" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &quot;my-event&quot; is emitted on the child):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">Прослушивание пользовательских событий в дочернем компоненте (обработчик вызывается, когда дочерний компонент генерирует &amp;laquo;my-event&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">Прослушивание версии на базе кебабаба не даст никакого эффекта:</target>
        </trans-unit>
        <trans-unit id="6674c82db55a9741fe74df825e79591da8cece35" translate="yes" xml:space="preserve">
          <source>Loader function does not inherently receive &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must return a Promise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">Локальная регистрация</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">Локальная регистрация в модульной системе</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">Логика теперь отделена от уровня представления,что значительно облегчает обслуживание (изменение/расширение логики).</target>
        </trans-unit>
        <trans-unit id="972ab90613dd62fd50f5c7d4e44d82a2703fc0da" translate="yes" xml:space="preserve">
          <source>MAGic (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9061dc1c4c01489f1dced5faf2e16a1e14bb1c24" translate="yes" xml:space="preserve">
          <source>Magnifier (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">Поддержание государства</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Заставьте Vue игнорировать пользовательские элементы, определенные вне Vue (например, с помощью API веб-компонентов). В противном случае будет выдано предупреждение о &lt;code&gt;Unknown custom element&lt;/code&gt; , если вы забыли зарегистрировать глобальный компонент или неправильно написали имя компонента.</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">Сделайте объект реактивным. Внутри Vue использует это для объекта, возвращаемого функцией &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7801d7d110e57ae1f3c6effb3b2240aea5dc9f4f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;script&lt;/code&gt; part of the component has TypeScript set as a language:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">Убедитесь в том , чтобы прочитать о &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;различных сборках Vue&lt;/a&gt; и использовать &lt;strong&gt;производственную &lt;br/&gt;версию&lt;/strong&gt; в опубликованном сайте, заменив &lt;code&gt;vue.js&lt;/code&gt; с &lt;code&gt;vue.min.js&lt;/code&gt; . Это меньшая сборка, оптимизированная для скорости, а не для удобства разработки.</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">Управление множеством переходов между состояниями может быстро усложнить экземпляр или компонент Vue. К счастью, многие анимации можно выделить в специальные дочерние компоненты. Сделаем это с анимированным целым числом из нашего предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="6d84634068387565bc44457e74c1fb936b41ea6b" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a component instance. Fortunately, many animations can be extracted out into dedicated child components. Let's do this with the animated integer from our earlier example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">Управление состоянием &lt;code&gt;this.$root&lt;/code&gt; и / или использование &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;глобальной шины событий&lt;/a&gt; может быть удобным для очень простых случаев, но не подходит для большинства приложений. Vuex предлагает не только центральное место для управления состоянием, но также инструменты для организации, отслеживания и отладки изменений состояния.</target>
        </trans-unit>
        <trans-unit id="345f632fb618327d0737b3e43648e569b92b65d3" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a global event bus can be convenient for very simple cases, but it is not appropriate for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">Манипулировать детьми,реквизитом или данными перед передачей их детскому компоненту.</target>
        </trans-unit>
        <trans-unit id="ef483ab0b23465192e501c234b66b1aaf6d75a30" translate="yes" xml:space="preserve">
          <source>Many JS libraries like GreenSock will assume you want hardware acceleration and will apply them by default, so you do not need to set them manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">Множество файлов со схожими именами,что затрудняет быстрое переключение файлов в редакторах кода.</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">Множество вложенных подкаталогов, что увеличивает время, необходимое для просмотра компонентов на боковой панели редактора.</target>
        </trans-unit>
        <trans-unit id="16185e750a239f48af50dd807d021ebe27373d96" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">Многие из ваших компонентов будут относительно общими, возможно, только для обертывания элемента, такого как ввод или кнопка. Мы иногда называем их &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;базовыми компонентами,&lt;/a&gt; и они, как правило, очень часто используются в ваших компонентах.</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">Отображение массива на элементы с помощью &lt;code&gt;v-for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="985fac5003727ca9f43295099936da1f418deb05" translate="yes" xml:space="preserve">
          <source>Marks an object so that it will never be converted to a proxy. Returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">Мета-методы инстанций</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">Обработчики событий метода</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d7d319f93f2d93a0aa10747398e65d855aff93ad" translate="yes" xml:space="preserve">
          <source>Methods called from a template should not have any side effects, such as changing data or triggering asynchronous processes. If you find yourself tempted to do that you should probably use a &lt;a href=&quot;instance#lifecycle-hooks&quot;&gt;lifecycle hook&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">Методы в онлайн обработчиках</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Методы, которые нужно добавить в экземпляр Vue. Вы можете получить доступ к этим методам непосредственно на экземпляре виртуальной машины или использовать их в выражениях директив. Контекст &lt;code&gt;this&lt;/code&gt; у всех методов будет автоматически привязан к экземпляру Vue.</target>
        </trans-unit>
        <trans-unit id="6fde24be2acb622eb42db4cc92f8e9d97e13fc25" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the component instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Промежуточное ПО &lt;sup&gt;заменено&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">Среднее оборудование заменяется плагинами.Плагин-это функция,которая принимает хранилище в качестве единственного аргумента и может прослушивать событие мутации на хранилище:</target>
        </trans-unit>
        <trans-unit id="a6b3e991aad9c53aed3b0912de764a87bdc4c052" translate="yes" xml:space="preserve">
          <source>Migration Strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Миграция с Vue 1.x</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Миграция с маршрутизатора Vue Router 0.7.x</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Миграция с Vuex 0.6.x на 1.0</target>
        </trans-unit>
        <trans-unit id="27e6c208056129d07214b4839a815039f22c4fbb" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt; includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7041841fb6a16a593419ba9210aa34bce92e8" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt;includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c410c172a6db22b44797723b74a9f97cbe8cbd47" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$listeners&lt;/code&gt; removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635802e8d697afd466dea0285928d4c2564eeacf" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;.native&lt;/code&gt; modifier removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0b41dde0e20543a039acd14df0e338cbee9d6" translate="yes" xml:space="preserve">
          <source>Migration guide - Changes in the Render Functions API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5be8322a9bb8f637fd7d36053e4e1060c3e536" translate="yes" xml:space="preserve">
          <source>Migration guide - New Emits Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2363ce7759901b489bcaeaac53540d1809dbe21" translate="yes" xml:space="preserve">
          <source>Migration: Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="01468459ec2045f5366f9299c5e3667f7a39c98e" translate="yes" xml:space="preserve">
          <source>Mixin Merge Behavior Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Перехватчики Mixin вызываются в том порядке, в котором они указаны, и вызываются перед собственными перехватчиками компонента.</target>
        </trans-unit>
        <trans-unit id="696c1c53029e4a11c64d6af9a07cc08ca71e59d3" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component's own hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Миксины - это гибкий способ распространять повторно используемые функции для компонентов Vue. Объект миксина может содержать любые параметры компонента. Когда компонент использует миксин, все параметры миксина будут &amp;laquo;смешаны&amp;raquo; с собственными опциями компонента.</target>
        </trans-unit>
        <trans-unit id="41c21dcea103087b7aa285323c1c82e7014cf7e0" translate="yes" xml:space="preserve">
          <source>Mixins are conflict-prone: Since properties from each feature are merged into the same component, you still have to know about every other feature to avoid property name conflicts and for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f849d0cf8da656a7c4361043b523a5ce2e1fc1e" translate="yes" xml:space="preserve">
          <source>Mixins distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &quot;mixed&quot; into the component's own options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX стал довольно популярным в сообществе React и фактически использует систему реактивности, почти идентичную Vue. В некоторой степени рабочий процесс React + MobX можно рассматривать как более подробный Vue, поэтому, если вы используете эту комбинацию и получаете от нее удовольствие, переход на Vue, вероятно, станет следующим логическим шагом.</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="814d5c9075ac58da08deb4e3d88f6089a78f380d" translate="yes" xml:space="preserve">
          <source>Mocha</source>
          <target state="translated">Mocha</target>
        </trans-unit>
        <trans-unit id="20716d7589116671fbeb6c4a74532bdfef915478" translate="yes" xml:space="preserve">
          <source>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f243cbe64caef0641a9876a4078a94f8defc16" translate="yes" xml:space="preserve">
          <source>Modifier Keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">Клавиши модификаторов:</target>
        </trans-unit>
        <trans-unit id="42425619360ca471965f2dfefff097e5132ba384" translate="yes" xml:space="preserve">
          <source>Modifiers added to a component &lt;code&gt;v-model&lt;/code&gt; will be provided to the component via the &lt;code&gt;modelModifiers&lt;/code&gt; prop. In the below example, we have created a component that contains a &lt;code&gt;modelModifiers&lt;/code&gt; prop that defaults to an empty object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">Модификаторы - это специальные постфиксы, обозначаемые точкой, которые указывают, что директива должна быть связана каким-то особым образом. Например, модификатор &lt;code&gt;.prevent&lt;/code&gt; указывает директиве &lt;code&gt;v-on&lt;/code&gt; вызвать &lt;code&gt;event.preventDefault()&lt;/code&gt; для инициированного события:</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">Модульные системы</target>
        </trans-unit>
        <trans-unit id="2333c18157c24df8052238f52f365426ca0dbb73" translate="yes" xml:space="preserve">
          <source>Module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack (opens new window)&lt;/a&gt; support &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree-shaking (opens new window)&lt;/a&gt;, which is a fancy term for &amp;ldquo;dead code elimination.&amp;rdquo; Unfortunately, due to how the code is written in previous Vue versions, global APIs like &lt;code&gt;Vue.nextTick()&lt;/code&gt; are not tree-shakeable and will be included in the final bundle regardless of where they are actually used or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">Более зрелая поддержка инструментов. Vue обеспечивает официальную поддержку &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; и &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt; , а Riot полагается на поддержку сообщества для интеграции системы сборки.</target>
        </trans-unit>
        <trans-unit id="bd951adc5c3182ed45f637e554b6230120cad548" translate="yes" xml:space="preserve">
          <source>Most of the methods exposed by the application instance return that same instance, allowing for chaining:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51829624f8ae979b2184273f19ad9bb547f0cb2e" translate="yes" xml:space="preserve">
          <source>Most of the time when developing a third-party library we want to build it in a way that allows the consumers of the library to &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree shake (opens new window)&lt;/a&gt; it. To enable tree-shaking we need to build &lt;code&gt;esm&lt;/code&gt; modules. Since webpack and, in turn, vue-cli do not support building &lt;code&gt;esm&lt;/code&gt; modules we need to rely on &lt;a href=&quot;https://rollupjs.org/&quot;&gt;rollup (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd700564f82afc8781e8c7bd3517f4f9cfa75b4" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI (opens new window)&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">Большинство приведенных ниже советов включены по умолчанию, если вы используете &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt; . Этот раздел актуален только в том случае, если вы используете настраиваемую настройку сборки.</target>
        </trans-unit>
        <trans-unit id="5e26a19f206db5f80980c1565b38336a5204a51f" translate="yes" xml:space="preserve">
          <source>Most of the use cases for &lt;code&gt;inline-template&lt;/code&gt; assumes a no-build-tool setup, where all templates are written directly inside the HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">Большинство случаев использования мутирующего опоры могут быть заменены одним из этих вариантов:</target>
        </trans-unit>
        <trans-unit id="2c94530449d59bc0026f72f09d5cab721902ce23" translate="yes" xml:space="preserve">
          <source>Mounting App Instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f67e8c3b01357d6a48d990b7305e54d0bf81af" translate="yes" xml:space="preserve">
          <source>Mounts a root component of the application instance on the provided DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">Модификаторы кнопок мыши</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">Намного лучше, не правда ли?</target>
        </trans-unit>
        <trans-unit id="47ce4ea06250a3aebfb8fdef175fa9bb75c62c5f" translate="yes" xml:space="preserve">
          <source>Much better, isn't it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f57c7776187e52ab80734a4cd047017fdbc252" translate="yes" xml:space="preserve">
          <source>Much like a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag, a &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag is only required in templates as a syntactical placeholder and should be discarded when migrating to a &lt;code&gt;render&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">Намного проще! Вроде, как бы, что-то вроде. Код короче, но также требует большего знакомства со свойствами экземпляра Vue. В этом случае вы должны знать, что когда вы передаете дочерние элементы без директивы &lt;code&gt;v-slot&lt;/code&gt; в компонент, например &lt;code&gt;Hello world!&lt;/code&gt; внутри &lt;code&gt;anchored-heading&lt;/code&gt; эти дочерние элементы хранятся в экземпляре компонента в &lt;code&gt;$slots.default&lt;/code&gt; . Если вы еще этого не сделали, &lt;strong&gt;рекомендуется прочитать &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API свойств экземпляра,&lt;/a&gt; прежде чем углубляться в функции рендеринга.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">Мульти-атрибутные элементы</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать&lt;/sup&gt; элементы с несколькими атрибутами&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">Многословные имена компонентов</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Названия компонентов из нескольких слов &lt;sup&gt;необходимы&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">Многострочный текст</target>
        </trans-unit>
        <trans-unit id="9a85758f90e2757c68d0fceaab52f21c4531a196" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;v-model&lt;/code&gt; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4871212ed8d1d6698fc58f7b90833df012ebc65c" translate="yes" xml:space="preserve">
          <source>Multiple Event Handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df30563657ae4c69b0249bc2ce91dacff84cf5a3" translate="yes" xml:space="preserve">
          <source>Multiple Sections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">Многочисленные значения</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">Несколько флажков,привязанных к одному и тому же массиву:</target>
        </trans-unit>
        <trans-unit id="ec5f3b4f279a5fac1d619ddd625a66c322263084" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">Несколько узлов,в которых за один раз отображается только 1.</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">Множественный выбор (привязан к массиву):</target>
        </trans-unit>
        <trans-unit id="ba3eb3692fb6af84e61cce398babaf5e0445cbe0" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to array):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0467cdaf45c60b95eca56ed7e05421c4b98185" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/directives#v-bind&quot;&gt;&lt;code&gt;v-bind&lt;/code&gt; directive&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">Усы нельзя использовать внутри атрибутов HTML. Вместо этого используйте &lt;a href=&quot;../api/index#v-bind&quot;&gt;директиву v-bind&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="678c5ab9e821362e494de6bbb3ed5d891d1e67f1" translate="yes" xml:space="preserve">
          <source>Mutating Reactive Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">Локальное изменение свойства теперь считается анти-шаблоном, например, объявление &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; и последующая установка this.myProp = 'someOtherValue' в компоненте. Благодаря новому механизму рендеринга всякий раз, когда родительский компонент повторно рендерит, локальные изменения дочернего компонента будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">Мутационные методы</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">Методы мутации, как следует из названия, изменяют исходный массив, для которого они вызываются. Для сравнения, существуют также немутантные методы, например &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;concat()&lt;/code&gt; и &lt;code&gt;slice()&lt;/code&gt; , которые не изменяют исходный массив, но &lt;strong&gt;всегда возвращают новый массив&lt;/strong&gt; . При работе с немутантными методами старый массив можно заменить новым:</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">NPM - рекомендуемый метод установки при создании крупномасштабных приложений с помощью Vue. Он прекрасно сочетается с такими сборщиками модулей, как &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; или &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; . Vue также предоставляет сопутствующие инструменты для создания &lt;a href=&quot;single-file-components&quot;&gt;однофайловых компонентов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69a28f26a2d6401b08eedd57c6a1a5681efe2332" translate="yes" xml:space="preserve">
          <source>NVDA (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">Имя Корпус</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">Конфликты имен (например, несколько компонентов &lt;code&gt;ButtonDelete.vue&lt;/code&gt; ) затрудняют быстрый переход к определенному компоненту в редакторе кода.</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">Именованные слоты</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">Слотс-блокнот</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">Именованные слоты с атрибутом &lt;code&gt;slot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">местное население</target>
        </trans-unit>
        <trans-unit id="26068455a90075c00bf4839b741d52af3487813b" translate="yes" xml:space="preserve">
          <source>NativeScript</source>
          <target state="translated">NativeScript</target>
        </trans-unit>
        <trans-unit id="1877cf043460c0f80e9625a96954e7851b08330d" translate="yes" xml:space="preserve">
          <source>NativeScript + Vue.js Guide (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f940a2947c24bf59462a669f4fe8ca87501b7ae3" translate="yes" xml:space="preserve">
          <source>NerdeFocus (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826fdcb80bf0630de536146d505abc527b2a01df" translate="yes" xml:space="preserve">
          <source>Nest headings in their ranking order: &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248d641e1dd50d8e9bc4a5ff4268e7392bab4e5d" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper method that explicitly defines async components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">Новое в 2.1.0+</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">Новое в версии 2.1.0+: возвращает Promise, если обратный вызов не предоставлен и Promise поддерживается в среде выполнения. Обратите внимание, что Vue не поставляется с полифилом Promise, поэтому, если вы нацеливаетесь на браузеры, которые изначально не поддерживают Promises (глядя на вас, IE), вам придется предоставить полифил самостоятельно.</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">Новое в 2.1.4+</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">Новое в 2.2.0</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">Новое в 2.2.0+</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">Новое в 2.3.0+</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">Новое в 2.4.0+</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">Новое в 2.5.0+</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">Новое в 2.6.0+</target>
        </trans-unit>
        <trans-unit id="be41335dc7a0ff9171513e80c9b33fbd4144bd7a" translate="yes" xml:space="preserve">
          <source>New to Vue.js? Check out our &lt;a href=&quot;../../index&quot;&gt;Essentials Guide&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1bc63fa69d5b8906a90d616cc23894236797b1" translate="yes" xml:space="preserve">
          <source>Nightwatch's Official Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce8836503e7153aa1a402805b5adb8e46245b8f" translate="yes" xml:space="preserve">
          <source>Nightwatch.js</source>
          <target state="translated">Nightwatch.js</target>
        </trans-unit>
        <trans-unit id="7fa11e6f2aa3af114b0e34eb2cd5e3891fde04fd" translate="yes" xml:space="preserve">
          <source>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">В этом больше нет необходимости,так как теперь по умолчанию предупреждения поставляются со стековыми трассами.</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">Никакого реального использования. Если вы так или иначе полагаетесь на эту функцию и не знаете, как ее обойти, отправьте сообщение на &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;форум&lt;/a&gt; для получения идей.</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">Узлы,деревья и виртуальное хранилище.</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">Атрибуты,не относящиеся к урожаю</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">Внеплановое государственное управление</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;С осторожностью используйте&lt;/sup&gt; управление состоянием без потока&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7522eb1254b40f819eb00d0f412303761a8a0ac4" translate="yes" xml:space="preserve">
          <source>Not needed*</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63d0df42b260685a2a9914a2f95611f71b33e28" translate="yes" xml:space="preserve">
          <source>Notable New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">Обратите внимание, что каждый дочерний элемент в &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; должен иметь &lt;strong&gt;уникальный ключ,&lt;/strong&gt; чтобы анимация работала правильно.</target>
        </trans-unit>
        <trans-unit id="ca49da0909b8a4408a3a2c4586e5b1467d69929a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../api/refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are &lt;a href=&quot;reactivity-fundamentals#ref-unwrapping&quot;&gt;automatically unwrapped&lt;/a&gt; when accessed in the template so you shouldn't use &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc23cd0cef0d3813fd341bfd31bf6563a5bf5c6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are automatically unwrapped when accessed in the template so there's no need for &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; требует, чтобы все переключаемые компоненты имели имена, либо с использованием параметра &lt;code&gt;name&lt;/code&gt; в компоненте, либо посредством локальной / глобальной регистрации.</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;inheritAttrs: false&lt;/code&gt; вариант не &lt;strong&gt;не&lt;/strong&gt; влияет на &lt;code&gt;style&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt; привязок.</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;mounted&lt;/code&gt; вовсе &lt;strong&gt;не&lt;/strong&gt; гарантирует , что все дочерние компоненты также были установлены. Если вы хотите подождать, пока все представление будет отрисовано, вы можете использовать &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ NextTick&lt;/a&gt; внутри &lt;code&gt;mounted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb05a4351598578542e96c7b1ebb606ca8a12371" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; не поддерживается в &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; , поэтому, если вам нужно открыть ссылку в новой вкладке, вы должны вместо этого использовать &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;updated&lt;/code&gt; вовсе &lt;strong&gt;не&lt;/strong&gt; гарантирует , что все дочерние компоненты также были повторно вынесено. Если вы хотите дождаться повторного рендеринга всего представления, вы можете использовать &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ NextTick&lt;/a&gt; внутри &lt;code&gt;updated&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="736452a7cde671c4028bd0f51d1cfa315c95c76a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;v-bind&lt;/code&gt; с модификатором &lt;code&gt;.sync&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; работает с выражениями (например, &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; Недействителен). Вместо этого вы должны указать только имя свойства, которое вы хотите привязать, аналогично &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;v-show&lt;/code&gt; не поддерживает элемент &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; и не работает с &lt;code&gt;v-else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b9184088f073256f499eaedf7653670276bb736" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;you should not use an arrow function to define a watcher&lt;/em&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; можно добавить только в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt; (за &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;одним исключением&lt;/a&gt; ), в отличие от устаревшего &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;атрибута &lt;/a&gt; &lt;code&gt;slot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da6d6a25d31f792c92e4d4f94e109dce6aa1ce03" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#abbreviated-syntax-for-lone-default-slots&quot;&gt;one exception&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">Обратите внимание , что &lt;strong&gt;локально зарегистрированные компоненты &lt;em&gt;не&lt;/em&gt; также доступны в подкомпонентов&lt;/strong&gt; . Например, если вы хотите, чтобы &lt;code&gt;ComponentA&lt;/code&gt; был доступен в &lt;code&gt;ComponentB&lt;/code&gt; , вам нужно было бы использовать:</target>
        </trans-unit>
        <trans-unit id="bf48dec89b052e2c67a866740d5df77b8220622a" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you'd have to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;вы не должны использовать стрелочную функцию для определения метода&lt;/strong&gt; (например, &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ). Причина в том, что стрелочные функции связывают родительский контекст, поэтому &lt;code&gt;this&lt;/code&gt; не будет экземпляр Vue, как вы ожидаете, а &lt;code&gt;this.a&lt;/code&gt; будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="641353cb3566fc5149312b741e1f12c37e6b249c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;вы не должны использовать функцию стрелки для определения наблюдателя&lt;/strong&gt; (например, &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ). Причина в том, что стрелочные функции связывают родительский контекст, поэтому &lt;code&gt;this&lt;/code&gt; не будет экземпляр Vue, как вы ожидаете, а &lt;code&gt;this.updateAutocomplete&lt;/code&gt; будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что система событий Vue отличается от &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt; браузера . Хотя они работают аналогично, &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; и &lt;code&gt;$off&lt;/code&gt; &lt;strong&gt;не&lt;/strong&gt; являются псевдонимами для &lt;code&gt;dispatchEvent&lt;/code&gt; , &lt;code&gt;addEventListener&lt;/code&gt; и &lt;code&gt;removeEventListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="081986e34f15d320aaefef70aa73f69abdde7609" translate="yes" xml:space="preserve">
          <source>Note that all native HTML and SVG tags don't need to be matched in this function - Vue parser performs this check automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34975db8bc1ca3043980cfeb4c62b733ac3c9bed" translate="yes" xml:space="preserve">
          <source>Note that every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;a href=&quot;special-attributes#key&quot;&gt;&lt;strong&gt;uniquely keyed&lt;/strong&gt;&lt;/a&gt; for the animations to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">Обратите внимание, что для других директив (например, &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-show&lt;/code&gt; ) нормальная правдивость JavaScript все еще применяется.</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">Обратите внимание: если вы используете стрелочную функцию с вычисляемым свойством, &lt;code&gt;this&lt;/code&gt; не будет экземпляр компонента, но вы все равно можете получить доступ к экземпляру в качестве первого аргумента функции:</target>
        </trans-unit>
        <trans-unit id="56e9ff50c8f4d3af5530daf6166e647efccff678" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">Обратите внимание, что если вы используете стрелочную функцию со свойством &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; не будет экземпляр компонента, но вы все равно можете получить доступ к экземпляру в качестве первого аргумента функции:</target>
        </trans-unit>
        <trans-unit id="b844a1894b3639cf8e6947f52c1732f36fa3f2ea" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">Обратите внимание, что в ES2015 + размещение имени переменной, например &lt;code&gt;ComponentA&lt;/code&gt; , внутри объекта является сокращением для &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; , что означает, что имя переменной одновременно:</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">Обратите внимание,что в этом методе мы обновляем состояние нашего приложения,не касаясь DOM-все манипуляции с DOM обрабатываются Vue,а написанный вами код сфокусирован на основной логике.</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание, что &lt;strong&gt;не&lt;/strong&gt; рекомендуется использовать &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; вместе. См. Подробности в &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;руководстве&lt;/a&gt; по стилю .</target>
        </trans-unit>
        <trans-unit id="faa9c0503d39b650734e81c8480f148f8158dc6a" translate="yes" xml:space="preserve">
          <source>Note that it's &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание , что клавиши - модификаторы отличаются от обычных ключей и при использовании &lt;code&gt;keyup&lt;/code&gt; событий, они должны быть нажаты , когда событие генерируется. Другими словами, &lt;code&gt;keyup.ctrl&lt;/code&gt; сработает, только если вы отпустите клавишу, удерживая &lt;code&gt;ctrl&lt;/code&gt; . Он не сработает, если вы отпустите только клавишу &lt;code&gt;ctrl&lt;/code&gt; . Если вы хотите , такое поведение, используйте &lt;code&gt;keyCode&lt;/code&gt; для &lt;code&gt;ctrl&lt;/code&gt; вместо: &lt;code&gt;keyup.17&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a575c0c184061dc0e5bebafa17e97ed49b8df32d" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won't trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">Обратите внимание , что объекты и массивы в JavaScript передаются по ссылке, так что, если опора представляет собой массив или объект, видоизменяется объект или сам массив внутри компонента ребенка &lt;strong&gt;будет&lt;/strong&gt; влиять на родительское состояние.</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">Обратите внимание, что свойства проверяются &lt;strong&gt;до&lt;/strong&gt; создания экземпляра компонента, поэтому свойства экземпляра (например, &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; и т. Д.) Не будут доступны внутри функций по &lt;code&gt;default&lt;/code&gt; или функций &lt;code&gt;validator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">Обратите внимание, что элементы &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; по-прежнему эффективно повторно используются, поскольку у них нет &lt;code&gt;key&lt;/code&gt; атрибутов.</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">Обратите внимание, что сокращенный синтаксис слота по умолчанию &lt;strong&gt;нельзя&lt;/strong&gt; смешивать с именованными слотами, так как это приведет к неоднозначности области видимости:</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что те же стратегии слияния используются в &lt;code&gt;Vue.extend()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">Обратите внимание, что с &lt;code&gt;immediate&lt;/code&gt; опцией вы не сможете отменить отслеживание данного свойства при первом вызове обратного вызова.</target>
        </trans-unit>
        <trans-unit id="a7894715668a9552d744e1da5cfc8208dcef0a9e" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won't be able to unwatch the given property on the first callback call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d1222c87974bff7446442d086ef17e96241dd6" translate="yes" xml:space="preserve">
          <source>Note that with this approach, you can only use methods, not computed properties, as the latter only make sense when defined in the context of an individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Обратите внимание, что вы должны включить &lt;code&gt;strict: true&lt;/code&gt; (или, по крайней мере, &lt;code&gt;noImplicitThis: true&lt;/code&gt; который является частью &lt;code&gt;strict&lt;/code&gt; флага), чтобы использовать проверку типа &lt;code&gt;this&lt;/code&gt; в методах компонентов, иначе он всегда обрабатывается как &lt;code&gt;any&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">Обратите внимание, что вы должны использовать &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+, если хотите использовать приведенный выше синтаксис для компонентов маршрута.</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">Обратите внимание , что вы все еще должны объявить &lt;code&gt;checked&lt;/code&gt; опору в компоненте &lt;code&gt;props&lt;/code&gt; варианта.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">Обратите внимание на атрибут &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; . Это необходимо в шаблонах DOM, потому что внутри &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; допустим только элемент &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; &amp;gt; . Он делает то же самое, что и &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; , но устраняет потенциальную ошибку синтаксического анализа браузера. Смотрите &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM разбор шаблон предостережения&lt;/a&gt; , чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="dd73b9ea52e1db8097dc7a516386c176573e1dbe" translate="yes" xml:space="preserve">
          <source>Note this &lt;code&gt;props&lt;/code&gt; object is reactive - i.e. it is updated when new props are passed in, and can be observed and reacted upon using &lt;code&gt;watchEffect&lt;/code&gt; or &lt;code&gt;watch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; разработан для случая, когда у него есть один прямой дочерний компонент, который переключается. Это не работает, если внутри у вас есть &lt;code&gt;v-for&lt;/code&gt; . Когда есть несколько условных дочерних элементов, как указано выше, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; требует, чтобы одновременно отображался только один дочерний элемент.</target>
        </trans-unit>
        <trans-unit id="da58435f34b35b1887295eb16c900d592e7442c7" translate="yes" xml:space="preserve">
          <source>Note: In 3.x, slots can be rendered as the root with native &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; support!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">Примечание. На клавиатурах Macintosh мета - это командная клавиша (⌘). На клавиатуре Windows мета - это клавиша Windows (⊞). На клавиатурах Sun Microsystems мета отмечена сплошным ромбиком (◆). На некоторых клавиатурах, особенно на клавиатурах MIT и Lisp, а также на их последователях, таких как клавиатура Knight, клавиатура Space-cadet, мета помечена как &amp;laquo;META&amp;raquo;. На клавиатурах Symbolics мета помечена как &amp;laquo;МЕТА&amp;raquo; или &amp;laquo;Мета&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">Примечание: в версиях до 2.3.0 опция &lt;code&gt;props&lt;/code&gt; требуется, если вы хотите принимать реквизиты в функциональном компоненте. В 2.3.0+ можно опустить &lt;code&gt;props&lt;/code&gt; опцию и все атрибуты , найденные на компоненте узла будут неявно извлекаются в качестве реквизита.</target>
        </trans-unit>
        <trans-unit id="334bf93841cedfd326dcac54017cd67d04bd2494" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">Примечание: привязки &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; НЕ являются реактивными. Это сделано намеренно. Однако, если вы передаете наблюдаемый объект, свойства этого объекта остаются реактивными.</target>
        </trans-unit>
        <trans-unit id="0908b002b159b7c5ec7a450ce89576a7ca8ba515" translate="yes" xml:space="preserve">
          <source>Note: the beta channel may conflict with the stable version of devtools so you may need to temporarily disable the stable version for the beta channel to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">Примечание: этот параметр &lt;strong&gt;не&lt;/strong&gt; влияет на привязки &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;style&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08b75004d7b0e0a6d3825e3c52c9e938d2e8a019" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6381b17960004aa9578834992d92eb41037168d9" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML. When using in-DOM templates, the template is subject to native HTML parsing rules. Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">Примечание: при изменении (а не замене) объекта или массива старое значение будет таким же, как новое значение, потому что они ссылаются на один и тот же объект / массив. Vue не хранит копию значения перед изменением.</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">Обратите внимание, что все действия, изменяющие состояние хранилища, помещаются внутри самого хранилища. Такой тип централизованного управления состоянием упрощает понимание того, какие мутации могут произойти и как они запускаются. Теперь, когда что-то пойдет не так, у нас также будет журнал того, что привело к ошибке.</target>
        </trans-unit>
        <trans-unit id="571333a47c31bbee3623511f092d63b988f1b343" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd794a6843de7d3ad1a1df1f2c8c06559b41eae" translate="yes" xml:space="preserve">
          <source>Notice how you can include &lt;code&gt;autocomplete='on'&lt;/code&gt; on the form element and it will apply to all inputs in your form. You can also set different &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete&quot;&gt;values for autocomplete attribute (opens new window)&lt;/a&gt; for each input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73647a8d9626dfeb015e786688a6df3934b4f805" translate="yes" xml:space="preserve">
          <source>Notice that this will move the actual DOM nodes instead of being destroyed and recreated, and it will keep any component instances alive as well. All stateful HTML elements (i.e. a playing video) will keep their state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">Обратите внимание, что при нажатии на кнопки для каждой из них ведется отдельный &lt;code&gt;count&lt;/code&gt; . Это потому, что каждый раз, когда вы используете компонент, создается его новый &lt;strong&gt;экземпляр&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6d30d0e0ff05d60e422be32271f1e21965033ef6" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That's because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc80ae205fd608099bd57a38126221c490c9a421" translate="yes" xml:space="preserve">
          <source>Notice that when the component's &lt;code&gt;created&lt;/code&gt; lifecycle hook triggers, the &lt;code&gt;modelModifiers&lt;/code&gt; prop contains &lt;code&gt;capitalize&lt;/code&gt; and its value is &lt;code&gt;true&lt;/code&gt; - due to it being set on the &lt;code&gt;v-model&lt;/code&gt; binding &lt;code&gt;v-model.capitalize=&quot;myText&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">Теперь &lt;code&gt;v-model&lt;/code&gt; должен отлично работать с этим компонентом:</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">Теперь и &lt;code&gt;ComponentA&lt;/code&gt; , и &lt;code&gt;ComponentC&lt;/code&gt; можно использовать внутри шаблона &lt;code&gt;ComponentB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d88909194979ead139b391709a958720c86553b7" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;'s template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caffa3b79738c5125111f76c75b50ac902d4aecd" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">Теперь все внутри элементов &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; будет передано в соответствующие слоты. Предполагается, что любой контент, не заключенный в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; с использованием &lt;code&gt;v-slot&lt;/code&gt; , предназначен для слота по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3e4140c0dde663257b36afdec9358a935995f01d" translate="yes" xml:space="preserve">
          <source>Now in Vue 3, all functional components are created with a plain function. In other words, there is no need to define the &lt;code&gt;{ functional: true }&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">Теперь в компоненте, в котором вы определили эту &lt;code&gt;ref&lt;/code&gt; , вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">Пришло время совершить глубокое погружение! Одна из самых отличительных особенностей Vue - ненавязчивая система реактивности. Модели - это просто объекты JavaScript. Когда вы их изменяете, вид обновляется. Это делает управление состоянием простым и интуитивно понятным, но также важно понимать, как оно работает, чтобы избежать некоторых распространенных ошибок. В этом разделе мы собираемся углубиться в некоторые низкоуровневые детали системы реактивности Vue.</target>
        </trans-unit>
        <trans-unit id="416cefac38d5a91dc03601ff2321b1747824eafd" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are proxied JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">Теперь давайте добавим кнопку для увеличения текста прямо перед содержанием каждого сообщения:</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">Теперь давайте рассмотрим пример перехода на вход и выход с использованием тех же классов CSS, которые мы использовали ранее:</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">Теперь давайте рассмотрим пример. Вот переход JavaScript с использованием Velocity.js:</target>
        </trans-unit>
        <trans-unit id="88e72442353d1cc70a649bbfb7fde5fcd5a0942a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start with extracting the first logical concern (marked as &quot;1&quot; in the original snippet).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">Теперь давайте обновим переход для наших кнопок включения / выключения с помощью &lt;code&gt;out-in&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61d7e41c0d0afefd3a6e0b42734a3aa3ca5ebe0d" translate="yes" xml:space="preserve">
          <source>Now let's add a button to enlarge the text right before the content of every post:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56027a462aa3978a9b96d4374ca36d15fa649ef8" translate="yes" xml:space="preserve">
          <source>Now let's build the directive that accomplishes this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f599733aef531ac3cec8a9e1bc4b342515b0f147" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example, transitioning entering and leaving using the same CSS classes we've used previously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3324adaea061622687d6176489328922e25a0701" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example. Here's a JavaScript transition using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f77a5a07be37fa843c2b64e4b6651919be0542c" translate="yes" xml:space="preserve">
          <source>Now let's extend our directive logic to recalculate the distance to pin on component update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b244b43642c6b5693f8cc0207f277488e09d82e" translate="yes" xml:space="preserve">
          <source>Now let's update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b586c00a91f7688367b4cacd0212bee0c1ca54f" translate="yes" xml:space="preserve">
          <source>Now that the custom directive lifecycle hooks mirror those of the components themselves, they become easier to reason about and remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aacb98515307b9797f4efe520f56ffcc9d7f5e" translate="yes" xml:space="preserve">
          <source>Now that we have our prop set up, we can check the &lt;code&gt;modelModifiers&lt;/code&gt; object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; element fires an &lt;code&gt;input&lt;/code&gt; event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf65b7d19a965e9b08bfa030c0b0ce8f415f6a3" translate="yes" xml:space="preserve">
          <source>Now that we know how watchers are updating the components, you might ask how those changes eventually make it to the DOM! Perhaps you&amp;rsquo;ve heard of the Virtual DOM before, many frameworks including Vue use this paradigm to make sure our interfaces reflect the changes we&amp;rsquo;re updating in JavaScript effectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f0e4739b10c5c53576af812b04069f5b1133df" translate="yes" xml:space="preserve">
          <source>Now that we know the &lt;strong&gt;why&lt;/strong&gt; we can get to the &lt;strong&gt;how&lt;/strong&gt;. To start working with the Composition API we first need a place where we can actually use it. In a Vue component, we call this place the &lt;code&gt;setup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">Теперь компонент &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; является &lt;strong&gt;полностью прозрачной оболочкой&lt;/strong&gt; , что означает, что его можно использовать точно так же, как обычный элемент &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; : все те же атрибуты и слушатели будут работать без модификатора &lt;code&gt;.native&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5577e953820ec1b24aed02306173d947e4a546b7" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;focus&lt;/code&gt; directive will be available in both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; instances and their descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">Теперь вкладка &amp;laquo; &lt;em&gt;Сообщения&lt;/em&gt; &amp;raquo; сохраняет свое состояние (выбранная запись), даже если она не отображается. См. &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;Этот скрипт&lt;/a&gt; для получения полного кода.</target>
        </trans-unit>
        <trans-unit id="fa9b9e0ccefb495f319a6491a7e676d9dacfb2b2" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it's not rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">Теперь эти входы будут отображаться с нуля каждый раз,когда вы переключаете.Убедитесь сами:</target>
        </trans-unit>
        <trans-unit id="0c9d8ea18bd7c1be0ebb6900315a3a7aaedea656" translate="yes" xml:space="preserve">
          <source>Now we can compose multiple states with these child components. It's exciting- we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue's &lt;a href=&quot;transitions-enterleave&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">Теперь мы можем передать задачу каждому повторяющемуся компоненту с помощью &lt;code&gt;v-bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">Теперь мы поняли:</target>
        </trans-unit>
        <trans-unit id="3ca602ef2620d2d54650ef4ef89bcc645f4b53a2" translate="yes" xml:space="preserve">
          <source>Now we need to react to the changes made to the &lt;code&gt;user&lt;/code&gt; prop. For that we will use the standalone &lt;code&gt;watch&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">Теперь мы ответим как на то, что сообщество может сделать для вас, так и на то, что вы можете сделать для него.</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">Теперь при использовании &lt;code&gt;v-model&lt;/code&gt; на этом компоненте:</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">Теперь, когда мы используем &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; в родительском компоненте, не предоставляя содержимого для слота:</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">Теперь, когда мы используем компонент &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; , мы можем дополнительно определить альтернативный &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; для элементов списка задач, но с доступом к данным от дочернего элемента:</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">Теперь, когда вы запускаете &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; , будет вызываться установщик, и &lt;code&gt;vm.firstName&lt;/code&gt; и &lt;code&gt;vm.lastName&lt;/code&gt; будут соответственно обновлены.</target>
        </trans-unit>
        <trans-unit id="99a7fc3db6e58b44e0a648173eebd65a414924c6" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;appA&lt;/code&gt; and &lt;code&gt;appB&lt;/code&gt; will update their views automatically. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">Теперь всякий раз, когда &lt;code&gt;sourceOfTruth&lt;/code&gt; изменяется , и &lt;code&gt;vmA&lt;/code&gt; , и &lt;code&gt;vmB&lt;/code&gt; будут обновлять свои представления автоматически. Подкомпоненты в каждом из этих экземпляров также будут иметь доступ через &lt;code&gt;this.$root.$data&lt;/code&gt; . Теперь у нас есть единый источник истины, но отладка будет кошмаром. Любая часть данных может быть изменена любой частью нашего приложения в любое время, не оставляя следов.</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">Теперь вы можете скомпоновать его в шаблоне другого компонента:</target>
        </trans-unit>
        <trans-unit id="a045cd84f5be21505ce08157ae51e1f45c687302" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1476c1cb56c53ca2f243a141ad4a636da2115a2b" translate="yes" xml:space="preserve">
          <source>Now, if anything changes in either property, the &lt;code&gt;MyMarker&lt;/code&gt; component will automatically be updated as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93161c9554bdbf350b67c1c62a2064b5a47aa2d" translate="yes" xml:space="preserve">
          <source>Now, in Vue 3, since functional components are defined as pure functions, async components definitions need to be explicitly defined by wrapping it in a new &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь, когда новое свойство добавляется к объектам &lt;code&gt;post&lt;/code&gt; , оно автоматически становится доступным внутри &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">Обнаружение изменения объекта Пещеры</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">Буквы объекта</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">Синтаксис объекта</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">Официальная декларация в пакетах НПМ</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">Официальное внедрение Flux-Like</target>
        </trans-unit>
        <trans-unit id="253fefc301bfd7132218b7557a6391250b616a46" translate="yes" xml:space="preserve">
          <source>Official Jest Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e814049718b1d932cec7462837ebe879f922b" translate="yes" xml:space="preserve">
          <source>Official Mocha Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">Официальный маршрутизатор</target>
        </trans-unit>
        <trans-unit id="25d0bd72df27202461d0c5f9c7e08418ec21f91d" translate="yes" xml:space="preserve">
          <source>Official Vue 2 CLI Plugin - Jest (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b102013e2e4e3b2a122cd90521f7abb18b815e29" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Cypress Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4283002bfc2991c088ab89cd2443eafba975ab6b" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Nightwatch Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e38d4cb7819fb2b7ca582192edc9ff4825e473e" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Plugin - Mocha (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5bc6dab6176b349e0ef77df3008fa9ea3cb2b1" translate="yes" xml:space="preserve">
          <source>Official Vue Test Utils Documentation (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e4e38b0d8be787a92f6532c519c8963542cb77" translate="yes" xml:space="preserve">
          <source>Official Vue Testing Library Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fafe60967df029303e74079e269747316a51820" translate="yes" xml:space="preserve">
          <source>Ok, so far, we&amp;rsquo;re just wrapping that object and returning it. Cool, but not that useful yet. But watch this, we can also intercept this object while we wrap it in the Proxy. This interception is called a trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5c4c2f29b26dd8b70d7595e8bde56c7c36488" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit an &lt;code&gt;update:modelValue&lt;/code&gt; event with the new value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">При &lt;code&gt;input&lt;/code&gt; генерировать собственное пользовательское событие &lt;code&gt;input&lt;/code&gt; с новым значением</target>
        </trans-unit>
        <trans-unit id="8353eb035df2b7f6ca17019debdf96a3f22eb88a" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;setup()&lt;/code&gt; function, you don't need to pass a typing to &lt;code&gt;props&lt;/code&gt; parameter as it will infer types from &lt;code&gt;props&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf41ca9bc7d54b6c5ac4b857c3027240934a3189" translate="yes" xml:space="preserve">
          <source>On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">На более высоком уровне можно разделить компоненты на две категории:презентационные и логические.Мы рекомендуем использовать шаблоны для презентационных компонентов и функцию рендеринга/JSX для логических компонентов.Процент этих компонентов зависит от типа создаваемого приложения,но в целом мы находим презентационные компоненты гораздо более распространенными.</target>
        </trans-unit>
        <trans-unit id="6c3d3824299b5122ad70d07d38a8fd8a0336c35b" translate="yes" xml:space="preserve">
          <source>On conditional branches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">В обычных компонентах атрибуты, не определенные как реквизиты, автоматически добавляются к корневому элементу компонента, заменяя или &lt;a href=&quot;class-and-style&quot;&gt;разумно объединяя&lt;/a&gt; любые существующие атрибуты с тем же именем.</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">Корневые Vue экземпляров (то есть экземпляры , созданные с &lt;code&gt;new Vue({ ... })&lt;/code&gt; ), вы должны использовать &lt;code&gt;propsData&lt;/code&gt; вместо &lt;code&gt;props&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">С другой стороны, &lt;code&gt;$refs&lt;/code&gt; предназначены в первую очередь для программного доступа в JavaScript - не рекомендуется полагаться на них в шаблонах, потому что это будет означать ссылку на состояние, которое не принадлежит самому экземпляру. Это нарушит модель представления Vue, управляемую данными.</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">С другой стороны, сборка только во время выполнения полностью совместима с CSP. При использовании сборки только во время выполнения с &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; или &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt; ваши шаблоны будут предварительно скомпилированы в функции &lt;code&gt;render&lt;/code&gt; которые отлично работают в средах CSP.</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">На этой странице мы рассмотрим только переходы входа, выхода и списка, но вы можете увидеть следующий раздел для &lt;a href=&quot;transitioning-state&quot;&gt;управления переходами состояний&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4cdb09dd5b26c91e66320cefa8ce757b9de6879" translate="yes" xml:space="preserve">
          <source>On this page, we'll only cover entering, and leaving, but you can see the next sections for &lt;a href=&quot;transitions-list&quot;&gt;list transitions&lt;/a&gt; and &lt;a href=&quot;transitions-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">Как только реквизит зарегистрирован,вы можете передать ему данные в качестве пользовательского атрибута,например,вот так:</target>
        </trans-unit>
        <trans-unit id="d2e7a62de13ea6daf472e90fd22d2267995fceed" translate="yes" xml:space="preserve">
          <source>Once a user changes route, bring focus back to the skip link. This can be achieved by calling focus to the &lt;code&gt;ref&lt;/code&gt; provided below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">Еще раз, постарайтесь не злоупотреблять этим шаблоном. Хотя это удобно в тех редких случаях, когда вам нужно отрендерить много статического контента, это просто необязательно, если вы действительно не заметите медленную визуализацию - плюс, это может вызвать много путаницы позже. Например, представьте другого разработчика, который не знаком с &lt;code&gt;v-once&lt;/code&gt; или просто пропустил его в шаблоне. Они могут часами пытаться понять, почему шаблон не обновляется правильно.</target>
        </trans-unit>
        <trans-unit id="e74c60c8736c1be5dff55d13ab945f687b554058" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering - plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167f3f5ddd7e9428d499efaab9f381bdb3ed2c55" translate="yes" xml:space="preserve">
          <source>Once from &lt;code&gt;$emit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c922783f828b42530826b639b30161731661fae" translate="yes" xml:space="preserve">
          <source>Once from a native event listener applied to the root element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">После наблюдения вы больше не можете добавлять реактивные свойства к объекту корневых данных.Поэтому рекомендуется объявить все реактивные свойства корневого объекта перед созданием экземпляра.</target>
        </trans-unit>
        <trans-unit id="e8b9b74226ba51585f69fe08ce0443127353058d" translate="yes" xml:space="preserve">
          <source>Once the file is created we will need to open it with our editor of choice and add the following code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">Как только вы почувствуете себя комфортно с только что усвоенными знаниями, мы рекомендуем вернуться, чтобы прочитать полное руководство по &lt;a href=&quot;components-dynamic-async&quot;&gt;динамическим и асинхронным компонентам&lt;/a&gt; , а также другие страницы в разделе &amp;laquo;Подробные сведения о компонентах&amp;raquo; на боковой панели.</target>
        </trans-unit>
        <trans-unit id="60acc179819cc9885eb67653fbd8f4d03d08954a" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on &lt;a href=&quot;component-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">Одно важное замечание: эти переходы FLIP не работают с элементами, установленными на &lt;code&gt;display: inline&lt;/code&gt; . В качестве альтернативы вы можете использовать &lt;code&gt;display: inline-block&lt;/code&gt; или размещать элементы в гибком контексте.</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">Следует отметить одну важную вещь: &lt;strong&gt;разделение проблем не равно разделению типов файлов. &lt;/strong&gt;В современной разработке пользовательского интерфейса мы обнаружили, что вместо разделения кодовой базы на три огромных слоя, которые переплетаются друг с другом, имеет смысл разделить их на слабо связанные компоненты и составить их. Внутри компонента его шаблон, логика и стили неразрывно связаны, и их совместное размещение фактически делает компонент более связным и удобным в обслуживании.</target>
        </trans-unit>
        <trans-unit id="b2c093743cd92f3eef8061e180eeec927b862729" translate="yes" xml:space="preserve">
          <source>One of the issues with placeholders is that they don't meet the &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html&quot;&gt;color contrast criteria (opens new window)&lt;/a&gt; by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">Один из наиболее распространенных типов переходов использует переходы CSS. Вот пример:</target>
        </trans-unit>
        <trans-unit id="f3084514831f9a3660901b496859b78c114ded95" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">Одно из наиболее распространенных применений этих методов - связь между родителем и его прямыми потомками. В этих случаях вы действительно можете &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;прослушать &lt;code&gt;$emit&lt;/code&gt; от ребенка с помощью &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; . Это позволяет сохранить удобство событий с добавленной явностью.</target>
        </trans-unit>
        <trans-unit id="f582da9a59b59f7794fc88389aa5092b1a4c440b" translate="yes" xml:space="preserve">
          <source>One of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5441c2b16e737c07dfa65dd03fc760dc9068959" translate="yes" xml:space="preserve">
          <source>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1aa62162a2a83d170cfdbdcd416abaeb0b419" translate="yes" xml:space="preserve">
          <source>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Один или несколько именованных параметров &lt;sup&gt;изменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">Одно замечание: подобно тому, как &lt;code&gt;v-bind:class&lt;/code&gt; и &lt;code&gt;v-bind:style&lt;/code&gt; имеют особую обработку в шаблонах, у них есть свои собственные поля верхнего уровня в объектах данных VNode. Этот объект также позволяет связывать обычные атрибуты HTML, а также свойства DOM, такие как &lt;code&gt;innerHTML&lt;/code&gt; (это заменит директиву &lt;code&gt;v-html&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">Одноразовые привязки ( &lt;code&gt;{{* foo }}&lt;/code&gt; ) были заменены новой &lt;a href=&quot;../api/index#v-once&quot;&gt;директивой &lt;/a&gt; &lt;code&gt;v-once&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15ca056f8f4ec061aff57aa3f191e7c02753b7c" translate="yes" xml:space="preserve">
          <source>One way to share configurations e.g. components or directives among apps is to create a factory function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Одноразовые привязки &lt;sup&gt;заменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">Односторонний поток данных</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">С Bower доступны только сборки UMD.</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Только Vue Router 2 совместим с Vue 2, поэтому, если вы обновляете Vue, вам также придется обновить Vue Router. Вот почему мы включили подробную информацию о пути миграции сюда, в основные документы. Полное руководство по использованию нового Vue Router см. В &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;документации Vue Router&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Только Vue Router 2 совместим с Vue 2, так что да, вам также придется следовать &lt;a href=&quot;migration-vue-router&quot;&gt;путем миграции для Vue Router&lt;/a&gt; . К счастью, в большинстве приложений не так много кода маршрутизатора, поэтому это, скорее всего, не займет больше часа.</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">Только в версии 2.2.0+:Также работает с массивом+индексом.</target>
        </trans-unit>
        <trans-unit id="1c17fd71b6108eae91a98b2783d1ada7a72eca67" translate="yes" xml:space="preserve">
          <source>Opacity behaves similarly. Thus, they are ideal candidates for movement on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c41eb847c8622b8581eed87c208351ff18e6769" translate="yes" xml:space="preserve">
          <source>Operable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caec8acecc60ba151e62b5850f83574dfd99c0d7" translate="yes" xml:space="preserve">
          <source>Optimal compatibility with the Vue ecosystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">Усилия по оптимизации</target>
        </trans-unit>
        <trans-unit id="e4b9f85b5d7b01dca8287331249e33d3c5156887" translate="yes" xml:space="preserve">
          <source>Option #1: Use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6301bb50d7829f5c1bc253cc74ede56ad6a957e0" translate="yes" xml:space="preserve">
          <source>Option #2: Default Slot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">вариант объединения</target>
        </trans-unit>
        <trans-unit id="f674131a41d74d291985eeac34569e45a2796480" translate="yes" xml:space="preserve">
          <source>Optional configuration options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">Опции/Активы</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">Опции/Состав</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">Опции/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">Опции/Данные</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">Опции/Крюки жизненного цикла</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">Опции/Ошибки</target>
        </trans-unit>
        <trans-unit id="b30e44ad585ea6e546f21a0445864b10944795c8" translate="yes" xml:space="preserve">
          <source>Options / Misc - inheritAttrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474ba12c459599d7f3d05d19597c94aa345c6ae6" translate="yes" xml:space="preserve">
          <source>Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">Такие параметры, как &lt;code&gt;acceptStatement&lt;/code&gt; , &lt;code&gt;deep&lt;/code&gt; , &lt;code&gt;priority&lt;/code&gt; и т. Д. Были удалены. Чтобы заменить директивы &lt;code&gt;twoWay&lt;/code&gt; , см. &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;Этот пример&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">Параметры, которые ожидают значения объекта, например &lt;code&gt;methods&lt;/code&gt; , &lt;code&gt;components&lt;/code&gt; и &lt;code&gt;directives&lt;/code&gt; , будут объединены в один и тот же объект. Параметры компонента будут иметь приоритет, если в этих объектах есть конфликтующие ключи:</target>
        </trans-unit>
        <trans-unit id="2cf7aafc0cf21a0635200b597f31b1c9a97361eb" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cccb1cf88b26495b712b582b1851dcc7cb203e2" translate="yes" xml:space="preserve">
          <source>Or a &lt;code&gt;setup&lt;/code&gt; function, function name will be used as component name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">Или данные/считанные свойства:</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">Или функция рендеринга:</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">Или, в качестве альтернативы, вы можете использовать асинхронный &lt;code&gt;import&lt;/code&gt; Webpack при локальной регистрации компонента:</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">Или,что еще лучше,передайте методы удаления индексу:</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">Или даже другие компоненты:</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">Или, если &lt;code&gt;myElement&lt;/code&gt; является последним дочерним элементом :</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">Или, если вы используете модули ES2015, например, через Babel и Webpack, это может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="b481ed2ba5dbbc7e0f7386d267111e8bdfabf1ae" translate="yes" xml:space="preserve">
          <source>Or if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8ab6aa568615f78c04477ef62787486065b5dc" translate="yes" xml:space="preserve">
          <source>Or in a render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4959514a6e663f87294927771d85f57df1ba3c86" translate="yes" xml:space="preserve">
          <source>Or with Yarn:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">Или с функцией рендеринга:</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">Или с помощью компонентных методов:</target>
        </trans-unit>
        <trans-unit id="af14db0c16953bef3557a6e30a1aace5e18d1edd" translate="yes" xml:space="preserve">
          <source>Or, for the more advanced component syntax with options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e16431e1f0d282812696aa421107f6f8ecec16e" translate="yes" xml:space="preserve">
          <source>Or, for those who preferred the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; in a single-file component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">Или,если обработчик событий-это метод:</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">Или, если вы используете сборку Vue только для времени выполнения:</target>
        </trans-unit>
        <trans-unit id="1ce87eef2b959ce134a14284177345e12a8eb332" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve been unit-testing an application involving &lt;a href=&quot;../component-dynamic-async&quot;&gt;async components&lt;/a&gt;, chances are you&amp;rsquo;ve written something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">Или атрибут &lt;code&gt;slot&lt;/code&gt; также можно использовать непосредственно в обычном элементе:</target>
        </trans-unit>
        <trans-unit id="2ab1ce11bd9c8abf32d55c7982f3dae620e8cb0a" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c548ba963676210f5bfb2bdd1152c86a09840f88" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Gulp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">Или, используя &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; с Grunt и &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">Или, используя &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; с Gulp:</target>
        </trans-unit>
        <trans-unit id="f1956be0d3870d999ee378a0178cc016dd3ada0f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;@click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;@click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">Порядок имеет значение при использовании модификаторов, потому что соответствующий код генерируется в том же порядке. Поэтому использование &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; предотвратит &lt;strong&gt;все щелчки,&lt;/strong&gt; а &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; предотвратит только щелчки по самому элементу.</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">Порядок слов в названиях компонентов</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется&lt;/sup&gt; порядок слов в названиях компонентов.&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">Организационные компоненты</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">Организация переходов на компоненты</target>
        </trans-unit>
        <trans-unit id="360d7d42956f7872b9ede3cea3c30a3ba0acec02" translate="yes" xml:space="preserve">
          <source>Organizing logics with component's options (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;) works in most cases. However, when our components get bigger, the list of &lt;strong&gt;logical concerns&lt;/strong&gt; also grows. This can lead to components that are hard to read and understand, especially for people who didn't write them in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">Другие примеры</target>
        </trans-unit>
        <trans-unit id="c3d0ce766708c752c9789d75994b0abdc210827b" translate="yes" xml:space="preserve">
          <source>Other Helpful Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f144ccf73f0c206f299610267139c1512e90bc" translate="yes" xml:space="preserve">
          <source>Other Minor Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12ddde082114607d0effddf28c1425f7adad67d" translate="yes" xml:space="preserve">
          <source>Other Projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8096cf3d3237b4ba8c7121f2a65c1398f3cfa1d7" translate="yes" xml:space="preserve">
          <source>Other non-boolean attrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">Наш &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Кодекс поведения&lt;/a&gt; - это руководство, которое упростит обогащение всех нас и технических сообществ, в которых мы участвуем.</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">Наша пользовательская директива теперь достаточно гибкая для поддержки нескольких различных случаев использования.</target>
        </trans-unit>
        <trans-unit id="6914ca8cedbdd86cdefec4f8279bb23f3c749797" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases. To make it even more dynamic, we can also allow to modify a bound value. Let's create an additional property &lt;code&gt;pinPadding&lt;/code&gt; and bind it to the &lt;code&gt;&amp;lt;input type=&quot;range&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">Наш установочный код хранится отдельно от кода очистки,что затрудняет программную очистку всего,что мы устанавливаем.</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">Однако со временем развитие Knockout замедлилось, и он начал немного показывать свой возраст. Например, в его компонентной системе отсутствует полный набор хуков жизненного цикла, и, хотя это очень распространенный вариант использования, интерфейс для передачи дочерних элементов компоненту кажется немного неуклюжим по сравнению с &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">В целом это устраняет необходимость в целом классе оптимизаций производительности с планшета разработчика и позволяет им больше сосредоточиться на создании самого приложения по мере его масштабирования.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">Частичные данные были удалены в пользу более явного потока данных между компонентами с использованием свойств. Если вы не используете партиал в области, критичной к производительности, рекомендуется использовать вместо него &lt;a href=&quot;components&quot;&gt;обычный компонент&lt;/a&gt; . Если вы динамически связывали &lt;code&gt;name&lt;/code&gt; партиала, вы можете использовать &lt;a href=&quot;components#Dynamic-Components&quot;&gt;динамический компонент&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">У PascalCase есть несколько преимуществ по сравнению с кебабом:</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase лучше всего работает с автозаполнением в редакторах кода, поскольку он соответствует тому, как мы ссылаемся на компоненты в JS (X) и шаблонах, где это возможно. Однако имена файлов со смешанным регистром иногда могут создавать проблемы в файловых системах без учета регистра, поэтому kebab-case также вполне приемлем.</target>
        </trans-unit>
        <trans-unit id="030bc27225285970757d5743a8972ff008b358d3" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">Передайте реквизит экземпляру во время его создания.Это в первую очередь предназначено для облегчения юнит-тестирования.</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">Передача атрибутов и событий детским элементам/компонентам</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">Передача данных в детские компоненты с реквизитами</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">Проходящие статические или динамические реквизиты</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">Проходя мимо булева</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">Передача номера</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">Проходя через массив</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">Передача предмета</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">Передача &lt;code&gt;immediate: true&lt;/code&gt; в опции вызовет обратный вызов немедленно с текущим значением выражения:</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">Передача свойств объекта</target>
        </trans-unit>
        <trans-unit id="c6e21e8099f57238a0c9760ebd07a5a614584331" translate="yes" xml:space="preserve">
          <source>People need to feel safe asking questions when contributing/reviewing content. Here's how you can do that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e116a18efa00a0e0767d89a0a941c40133b88a" translate="yes" xml:space="preserve">
          <source>Perceivable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf952b12947766273332fa80b06a64c003fbf12" translate="yes" xml:space="preserve">
          <source>Perform the side effect lazily;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="93bd1b9f8459e0acda65f78340bb55e6188adccd" translate="yes" xml:space="preserve">
          <source>Performance gains from 2.x for functional components are now negligible in 3.x, so we recommend just using stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">С точки зрения производительности, Vue обгоняет Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;с перевесом справедливой&lt;/a&gt; , даже после последнего обновления Glimmer двигателя в Ember 3.x. Vue автоматически пакетирует обновления, а в Ember вам нужно вручную управлять циклами выполнения в критических для производительности ситуациях.</target>
        </trans-unit>
        <trans-unit id="ed212fa164b940b935ec0a25b32878a0917c7268" translate="yes" xml:space="preserve">
          <source>Placeholder</source>
          <target state="translated">Placeholder</target>
        </trans-unit>
        <trans-unit id="11275f5de90c26fd6cc8ef9a7af920c6f1101f2b" translate="yes" xml:space="preserve">
          <source>Please note we used &lt;code&gt;model-value&lt;/code&gt; with kebab-case here because we are working with in-DOM templates. You can find a detailed explanation on kebab-cased vs camelCased attributes in the &lt;a href=&quot;#dom-template-parsing-caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;Объявление класса VNode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;Документацию по пакету vue-server-renderer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dadf730922f5cc0e3cc5b34354923331bd7cd59" translate="yes" xml:space="preserve">
          <source>Plugin users will now be able to &lt;code&gt;inject['i18n']&lt;/code&gt; into their components and access the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="a39e5a3d43de88abead0db5ad2318b757a0d742a" translate="yes" xml:space="preserve">
          <source>Plugins also allow us to use &lt;code&gt;inject&lt;/code&gt; to provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the &lt;code&gt;options&lt;/code&gt; parameter to be able to use the translations object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd12b92cd6c82b740fa6a101861368f2df9e451" translate="yes" xml:space="preserve">
          <source>Plugins are self-contained code that usually add global-level functionality to Vue. It is either an &lt;code&gt;object&lt;/code&gt; that exposes an &lt;code&gt;install()&lt;/code&gt; method, or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">Плагины могут добавлять к глобальным свойствам / экземплярам Vue и параметрам компонентов. В этих случаях объявления типов необходимы для компиляции подключаемых модулей в TypeScript. К счастью, есть функция TypeScript для расширения существующих типов, называемая &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;расширением модулей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">Плагины обычно добавляют в Vue функциональность глобального уровня.Для плагина нет строго определенной области применения-обычно существует несколько типов плагинов:</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer - еще один проект, спонсируемый Google, и на самом деле он также послужил источником вдохновения для Vue. Компоненты Vue можно легко сравнить с пользовательскими элементами Polymer, и оба обеспечивают очень похожий стиль разработки. Самая большая разница в том, что Polymer основан на последних функциях веб-компонентов и требует нетривиальных полифиллов для работы (с пониженной производительностью) в браузерах, которые изначально не поддерживают эти функции. Напротив, Vue работает без каких-либо зависимостей или полифиллов вплоть до IE9.</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">Предварительная компиляция шаблонов</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Библиотеки предсказаний и другие библиотеки реактивного типа</target>
        </trans-unit>
        <trans-unit id="8329b838710df96576166a6b1eb910a04281650a" translate="yes" xml:space="preserve">
          <source>Precautions</source>
          <target state="translated">Precautions</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">В стилях с &lt;code&gt;scoped&lt;/code&gt; селекторам классов, а не селекторам элементов , поскольку большое количество селекторов элементов выполняется медленно.</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">Довольно круто,да?</target>
        </trans-unit>
        <trans-unit id="1f991a95af1936160af34e1fab9584d14813afc2" translate="yes" xml:space="preserve">
          <source>Prevent Mutating Reactive Objects with &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">Раньше &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; в сочетании с &lt;code&gt;v-for&lt;/code&gt; создавал массив элементов / компонентов, потому что не было возможности дать каждому элементу уникальное имя. Вы по-прежнему можете добиться этого, задав каждому элементу одну и ту же &lt;code&gt;ref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">Раньше &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; имел &lt;code&gt;number&lt;/code&gt; начинающийся с 0 и заканчивающийся 9. Теперь он начинается с 1 и заканчивается на 10.</target>
        </trans-unit>
        <trans-unit id="23b9c4376379f9e662432b9880582c302a480f64" translate="yes" xml:space="preserve">
          <source>Previously, async components were created by simply defining a component as a function that returned a promise, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">В основном используется для сохранения состояния компонентов или во избежание повторного использования.</target>
        </trans-unit>
        <trans-unit id="dcdf83698ed6217a7ad9789255b8e995292e5ef5" translate="yes" xml:space="preserve">
          <source>Prime heading: title of the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">Правила Приоритета А:Существенный (предотвращение ошибок)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">Приоритет А:Существенный</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">Правила приоритета В:Настоятельно рекомендуемые (улучшение читабельности)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">Приоритет В:настоятельно рекомендуется</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">Правила приоритета С:Рекомендуемые (Сведение к минимуму произвольного выбора и когнитивной надбавки)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">Приоритет С:Рекомендуется</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">Правила приоритета D:Использовать с осторожностью (потенциально опасные образцы).</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">Приоритет D:Использовать с осторожностью</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">Имена частных владений</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">Названия частной собственности &lt;sup&gt;необходимы&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">Проблема решена!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">Развертывание производства</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">Слушатели программных мероприятий</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">Программная навигация</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">Программно выбрать один из нескольких других компонентов для делегирования на</target>
        </trans-unit>
        <trans-unit id="f6f4da8d93e88a08220e03b7810451d3ba540a34" translate="yes" xml:space="preserve">
          <source>Project</source>
          <target state="translated">Project</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">Создание проекта</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">Корпус реквизита (кейс верблюда против кебабаба)</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">Prop Mutation &lt;sup&gt;устарел&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
