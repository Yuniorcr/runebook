<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3b52d24461e93aad361aa8a10329f3c23cc49031" translate="yes" xml:space="preserve">
          <source>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what&amp;rsquo;s currently available for Vue templates.</source>
          <target state="translated">Поддержка инструментов (например, линтинг, проверка типов, автозаполнение редактора) для JSX в некотором смысле более продвинута, чем то, что сейчас доступно для шаблонов Vue.</target>
        </trans-unit>
        <trans-unit id="da2a622928cb7fb2119351d71d4d29385b2f0b02" translate="yes" xml:space="preserve">
          <source>The tree of DOM nodes for the HTML above looks like this:</source>
          <target state="translated">Дерево DOM-узлов для приведенного выше HTML выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1e0938b17616f7c664547dd22e0644ffdf02a08b" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;keyCode&lt;/code&gt; events &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;is deprecated&lt;/a&gt; and may not be supported in new browsers.</source>
          <target state="translated">Использование событий &lt;code&gt;keyCode&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode&quot;&gt;устарело&lt;/a&gt; и может не поддерживаться в новых браузерах.</target>
        </trans-unit>
        <trans-unit id="c973f4080ca50bd81b6cff2d0a6ded9905288da4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;slot-scope&lt;/code&gt; can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (&lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;modern browsers&lt;/a&gt;) you can also use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;ES2015 destructuring&lt;/a&gt; in the expression, like so:</source>
          <target state="translated">Значение области &lt;code&gt;slot-scope&lt;/code&gt; может принимать любое допустимое выражение JavaScript, которое может появляться в позиции аргумента определения функции. Это означает, что в поддерживаемых средах ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring&quot;&gt;однофайловые &lt;/a&gt;&lt;a href=&quot;single-file-components&quot;&gt;компоненты&lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility&quot;&gt;современные браузеры&lt;/a&gt; ) вы также можете использовать деструктуризацию ES2015 в выражении, например:</target>
        </trans-unit>
        <trans-unit id="44c95331b851049a94d5aa5d023b6e2ddaca60d8" translate="yes" xml:space="preserve">
          <source>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</source>
          <target state="translated">Обходным путем является либо использование выражений без пробелов или кавычек,либо замена сложного выражения вычисляемым свойством.</target>
        </trans-unit>
        <trans-unit id="d02680275f323eda2de9d2d7078001372e594964" translate="yes" xml:space="preserve">
          <source>Their names often include the name of an element they wrap (e.g. &lt;code&gt;BaseButton&lt;/code&gt;, &lt;code&gt;BaseTable&lt;/code&gt;), unless no element exists for their specific purpose (e.g. &lt;code&gt;BaseIcon&lt;/code&gt;). If you build similar components for a more specific context, they will almost always consume these components (e.g. &lt;code&gt;BaseButton&lt;/code&gt; may be used in &lt;code&gt;ButtonSubmit&lt;/code&gt;).</source>
          <target state="translated">Их имена часто включают имя элемента, который они &lt;code&gt;BaseButton&lt;/code&gt; &lt;code&gt;BaseTable&lt;/code&gt; (например, BaseButton , BaseTable ), если только элемент не существует для их конкретной цели (например, &lt;code&gt;BaseIcon&lt;/code&gt; ). Если вы создаете аналогичные компоненты для более конкретного контекста, они почти всегда будут использовать эти компоненты (например, &lt;code&gt;BaseButton&lt;/code&gt; может использоваться в &lt;code&gt;ButtonSubmit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cac8885ec5589429c1668b6076e0b655b65a0072" translate="yes" xml:space="preserve">
          <source>Then a &lt;code&gt;tree-folder-contents&lt;/code&gt; component with this template:</source>
          <target state="translated">Затем компонент &lt;code&gt;tree-folder-contents&lt;/code&gt; с этим шаблоном:</target>
        </trans-unit>
        <trans-unit id="12ff53d6c9683fe8bc4c3c3ebe06eaf2daa8b2b3" translate="yes" xml:space="preserve">
          <source>Then add some classes when using it:</source>
          <target state="translated">Затем добавьте несколько классов при его использовании:</target>
        </trans-unit>
        <trans-unit id="bdb3d0b6c8743a01fad092b8628997433e226d02" translate="yes" xml:space="preserve">
          <source>Then changes to &lt;code&gt;b&lt;/code&gt; will not trigger any view updates. If you know you&amp;rsquo;ll need a property later, but it starts out empty or non-existent, you&amp;rsquo;ll need to set some initial value. For example:</source>
          <target state="translated">Тогда изменения в &lt;code&gt;b&lt;/code&gt; не вызовут никаких обновлений представления. Если вы знаете, что вам понадобится свойство позже, но оно изначально пустое или не существует, вам нужно будет установить какое-то начальное значение. Например:</target>
        </trans-unit>
        <trans-unit id="d716ba19ef13983399aba7a4f9b4f99bdb1a5cc3" translate="yes" xml:space="preserve">
          <source>Then define the components you&amp;rsquo;d like to use in a &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="translated">Затем определите компоненты, которые вы хотите использовать в опции &lt;code&gt;components&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="89b993f413d7a3516733e84da6538330a9b561e6" translate="yes" xml:space="preserve">
          <source>Then import the component options along with Vue, and you can make many common assertions (here we are using Jasmine/Jest style &lt;code&gt;expect&lt;/code&gt; assertions just as an example):</source>
          <target state="translated">Затем импортировать компонент варианты вместе с Vue, и вы можете сделать много общих утверждений (здесь мы используем жасмин / шутя стиль &lt;code&gt;expect&lt;/code&gt; утверждения только в качестве примера):</target>
        </trans-unit>
        <trans-unit id="742a07eca2247a701f3fe69d736358f9945a7047" translate="yes" xml:space="preserve">
          <source>Then in a template, you can use the new &lt;code&gt;v-focus&lt;/code&gt; attribute on any element, like this:</source>
          <target state="translated">Затем в шаблоне вы можете использовать новый атрибут &lt;code&gt;v-focus&lt;/code&gt; для любого элемента, например:</target>
        </trans-unit>
        <trans-unit id="d651621f023beec6364c642e7684b35f30f1b1df" translate="yes" xml:space="preserve">
          <source>Then in any descendants, we can use the &lt;code&gt;inject&lt;/code&gt; option to receive specific properties we&amp;rsquo;d like to add to that instance:</source>
          <target state="translated">Затем в любых потомках мы можем использовать опцию &lt;code&gt;inject&lt;/code&gt; для получения определенных свойств, которые мы хотели бы добавить к этому экземпляру:</target>
        </trans-unit>
        <trans-unit id="07a1a769eabe4ce95fd548704bfe1a9036dff3fe" translate="yes" xml:space="preserve">
          <source>Then in our components, we can use &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; to emit events, listen for events, and clean up event listeners, respectively:</source>
          <target state="translated">Затем в наших компонентах мы можем использовать &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; , &lt;code&gt;$off&lt;/code&gt; для генерации событий, прослушивания событий и очистки прослушивателей событий соответственно:</target>
        </trans-unit>
        <trans-unit id="e5a24c495cff3ba785929f2d1f1232971575aecc" translate="yes" xml:space="preserve">
          <source>Then in the template for &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;, you might have:</source>
          <target state="translated">Тогда в шаблоне для &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; у вас может быть:</target>
        </trans-unit>
        <trans-unit id="06c17e2b180b30e57b025d1baba4010bf150e5ff" translate="yes" xml:space="preserve">
          <source>Then inside &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; you might find yourself reaching for a hack like this:</source>
          <target state="translated">Затем внутри &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; вы можете найти такой взлом:</target>
        </trans-unit>
        <trans-unit id="6cb73bd95447c7f774f020d38dc4e977b5d7f966" translate="yes" xml:space="preserve">
          <source>Then switching the &lt;code&gt;loginType&lt;/code&gt; in the code above will not erase what the user has already entered. Since both templates use the same elements, the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; is not replaced - just its &lt;code&gt;placeholder&lt;/code&gt;.</source>
          <target state="translated">Тогда переключение &lt;code&gt;loginType&lt;/code&gt; в приведенном выше коде не приведет к удалению того, что пользователь уже ввел. Поскольку оба шаблона используют одни и те же элементы, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; не заменяется - только его &lt;code&gt;placeholder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6afded1525a7e22ff2f90a6400204ea03039f331" translate="yes" xml:space="preserve">
          <source>Then the child component can emit an event on itself by calling the built-in &lt;a href=&quot;../api/index#vm-emit&quot;&gt;&lt;strong&gt;&lt;code&gt;$emit&lt;/code&gt;&lt;/strong&gt; method&lt;/a&gt;, passing the name of the event:</source>
          <target state="translated">Затем дочерний компонент может генерировать событие для себя, вызывая встроенный &lt;a href=&quot;../api/index#vm-emit&quot;&gt;метод &lt;/a&gt;&lt;strong&gt; &lt;code&gt;$emit&lt;/code&gt; &lt;/strong&gt; , передавая имя события:</target>
        </trans-unit>
        <trans-unit id="fa6a05a02bb2743e63986fe5978b02e07581ae91" translate="yes" xml:space="preserve">
          <source>Then the parent can listen to that event and update a local data property, if it wants to. For example:</source>
          <target state="translated">Тогда родитель может прослушать это событие и при желании обновить локальное свойство данных.Например:</target>
        </trans-unit>
        <trans-unit id="6a4b4fbfbeb2382afaa428f3aa7171b1ee657214" translate="yes" xml:space="preserve">
          <source>Then the provided content will be rendered instead:</source>
          <target state="translated">Затем вместо этого будет предоставлено предоставленное содержание:</target>
        </trans-unit>
        <trans-unit id="894b33adf4423b8e17178e298c582eff7b692b2f" translate="yes" xml:space="preserve">
          <source>Then the value will be passed as the first parameter of that method:</source>
          <target state="translated">Затем в качестве первого параметра этого метода будет передано значение:</target>
        </trans-unit>
        <trans-unit id="e40f0a46552f37df14dd5aec3ff5064babdeaea5" translate="yes" xml:space="preserve">
          <source>Then want to render a component for each one:</source>
          <target state="translated">Тогда нужно отрисовать компонент для каждого из них:</target>
        </trans-unit>
        <trans-unit id="e77b5195b094315391d1471e49e775352de3ff46" translate="yes" xml:space="preserve">
          <source>Then when later accessing this property on a route, you will still go through meta. For example:</source>
          <target state="translated">Затем,при последующем доступе к этому объекту по маршруту,вы все равно пройдете через метамфетамины.Например:</target>
        </trans-unit>
        <trans-unit id="db6fb96dd889a51b383d80ca6045c8aa43c69291" translate="yes" xml:space="preserve">
          <source>Then when we listen to the event in the parent, we can access the emitted event&amp;rsquo;s value with &lt;code&gt;$event&lt;/code&gt;:</source>
          <target state="translated">Затем, когда мы прослушиваем событие в родительском элементе, мы можем получить доступ к значению отправленного события с помощью &lt;code&gt;$event&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb930daa712d8e2eb8fe97e59c6f27531e9b1c3e" translate="yes" xml:space="preserve">
          <source>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.</source>
          <target state="translated">Затем вы можете начать писать код Vue и даже отправить уменьшенную версию в производство,не чувствуя себя виноватым и не беспокоясь о проблемах с производительностью.</target>
        </trans-unit>
        <trans-unit id="ebf3c9e7f553f2151cca31494ec2e2f25d6a17ab" translate="yes" xml:space="preserve">
          <source>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</source>
          <target state="translated">Потом ты сортируешь их по алфавиту.При обновлении DOM,Vue оптимизирует рендеринг для выполнения самых дешевых мутаций DOM.Это может означать удаление первого элемента todo,а затем добавление его снова в конце списка.</target>
        </trans-unit>
        <trans-unit id="60891cf748e8a5cfa058d96629753adac1a276a6" translate="yes" xml:space="preserve">
          <source>Then you would now update it to:</source>
          <target state="translated">Тогда вы бы обновили его:</target>
        </trans-unit>
        <trans-unit id="29dfab044dfc1294ff91b939dd91ab9260db5d9f" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll need to import each component you&amp;rsquo;d like to use, before you locally register it. For example, in a hypothetical &lt;code&gt;ComponentB.js&lt;/code&gt; or &lt;code&gt;ComponentB.vue&lt;/code&gt; file:</source>
          <target state="translated">Затем вам нужно будет импортировать каждый компонент, который вы хотите использовать, прежде чем регистрировать его локально. Например, в гипотетическом файле &lt;code&gt;ComponentB.js&lt;/code&gt; или &lt;code&gt;ComponentB.vue&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a02df39977359aa3a054dc03aa4a5ab9829f85e" translate="yes" xml:space="preserve">
          <source>There also seem to be philosophical differences in the API design which if you&amp;rsquo;re curious, can be demonstrated by how each handles the creation of a &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;simple todo list&lt;/a&gt;. It&amp;rsquo;s definitely somewhat subjective, but many consider Vue&amp;rsquo;s API to be less complex and better structured.</source>
          <target state="translated">Также, похоже, существуют философские различия в дизайне API, которые, если вам интересно, могут быть продемонстрированы тем, как каждый обрабатывает создание &lt;a href=&quot;https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89&quot;&gt;простого списка задач&lt;/a&gt; . Это определенно несколько субъективно, но многие считают API Vue менее сложным и лучше структурированным.</target>
        </trans-unit>
        <trans-unit id="00ee1410ff14873dae0595e837c501a60becd79c" translate="yes" xml:space="preserve">
          <source>There are a few advantages:</source>
          <target state="translated">Есть несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="a278039d12ee8bace65331079237ab972774e0f6" translate="yes" xml:space="preserve">
          <source>There are also a few array-related caveats, which were discussed earlier in the &lt;a href=&quot;list#Caveats&quot;&gt;list rendering section&lt;/a&gt;.</source>
          <target state="translated">Есть также несколько предостережений, связанных с массивами, которые обсуждались ранее в разделе &lt;a href=&quot;list#Caveats&quot;&gt;отрисовки списков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8355a914d86b23056657ff75f59f4f4811dbbe1e" translate="yes" xml:space="preserve">
          <source>There are also other hooks which will be called at different stages of the instance&amp;rsquo;s lifecycle, such as &lt;a href=&quot;../api/index#mounted&quot;&gt;&lt;code&gt;mounted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#updated&quot;&gt;&lt;code&gt;updated&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt;. All lifecycle hooks are called with their &lt;code&gt;this&lt;/code&gt; context pointing to the Vue instance invoking it.</source>
          <target state="translated">Есть также другие хуки, которые будут вызываться на разных этапах жизненного цикла экземпляра, например, при &lt;a href=&quot;../api/index#mounted&quot;&gt; &lt;code&gt;mounted&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#updated&quot;&gt; &lt;code&gt;updated&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; . Все хуки жизненного цикла вызываются с их контекстом &lt;code&gt;this&lt;/code&gt; , указывающим на вызывающий его экземпляр Vue.</target>
        </trans-unit>
        <trans-unit id="595e87e7a707cb9f54dea4bd06abe43f491c5b96" translate="yes" xml:space="preserve">
          <source>There are cases however, particularly shared component libraries, when this &lt;em&gt;might&lt;/em&gt; be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</source>
          <target state="translated">Однако в некоторых случаях, особенно в библиотеках общих компонентов, это &lt;em&gt;может&lt;/em&gt; быть целесообразно. Например, в абстрактных компонентах, которые взаимодействуют с API JavaScript вместо рендеринга HTML, таких как эти гипотетические компоненты Карт Google:</target>
        </trans-unit>
        <trans-unit id="3876196be292a6f75aaef350c2cf3fa6064ad6ee" translate="yes" xml:space="preserve">
          <source>There are cases when it&amp;rsquo;s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Бывают случаи, когда полезно указать резервный (то есть по умолчанию) контент для слота, который будет отображаться только тогда, когда контент не предоставлен. Например, в компоненте &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b097d3f1a1272b7a886d701f8e65981ad1d92968" translate="yes" xml:space="preserve">
          <source>There are quite a few other directives, each with its own special functionality. For example, the &lt;code&gt;v-for&lt;/code&gt; directive can be used for displaying a list of items using the data from an Array:</source>
          <target state="translated">Есть довольно много других директив, каждая из которых имеет свои особые функции. Например, директива &lt;code&gt;v-for&lt;/code&gt; может использоваться для отображения списка элементов с использованием данных из массива:</target>
        </trans-unit>
        <trans-unit id="301d312bbcc93ad24cc77d82516195cad4b40d9a" translate="yes" xml:space="preserve">
          <source>There are six classes applied for enter/leave transitions.</source>
          <target state="translated">Существует шесть классов,применяемых для входных/выходных переходов.</target>
        </trans-unit>
        <trans-unit id="68ec2c8ded7b22cd2bc4c88259f22e650546ce9b" translate="yes" xml:space="preserve">
          <source>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the &lt;code&gt;data&lt;/code&gt; object is like the schema for your component&amp;rsquo;s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</source>
          <target state="translated">У этого ограничения есть технические причины - оно устраняет класс крайних случаев в системе отслеживания зависимостей, а также позволяет экземплярам Vue лучше взаимодействовать с системами проверки типов. Но есть также важное соображение с точки зрения ремонтопригодности кода: объект &lt;code&gt;data&lt;/code&gt; похож на схему для состояния вашего компонента. Предварительное объявление всех реактивных свойств упрощает понимание кода компонента при повторном посещении позже или чтении другим разработчиком.</target>
        </trans-unit>
        <trans-unit id="db30e092cad90bed9c249d97be67dad62ff063c2" translate="yes" xml:space="preserve">
          <source>There are times when it&amp;rsquo;s useful to have multiple slots. For example, in a &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component with the following template:</source>
          <target state="translated">Бывают случаи, когда полезно иметь несколько слотов. Например, в компоненте &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; со следующим шаблоном:</target>
        </trans-unit>
        <trans-unit id="d66a662b2b692933bc8923306e3e5688421626cb" translate="yes" xml:space="preserve">
          <source>There are two common cases where this can be tempting:</source>
          <target state="translated">Есть два распространенных случая,когда это может быть заманчиво:</target>
        </trans-unit>
        <trans-unit id="4be534cacf73464a26b8c69ecc68abf4cebc095f" translate="yes" xml:space="preserve">
          <source>There are usually two cases where it&amp;rsquo;s tempting to mutate a prop:</source>
          <target state="translated">Обычно есть два случая, когда возникает соблазн изменить опору:</target>
        </trans-unit>
        <trans-unit id="9a46df346eecefc8c5696a405d0623a7868c6f68" translate="yes" xml:space="preserve">
          <source>There can still be one unnamed slot, which is the &lt;strong&gt;default slot&lt;/strong&gt; that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</source>
          <target state="translated">По-прежнему может быть один безымянный слот, который является &lt;strong&gt;слотом&lt;/strong&gt; по &lt;strong&gt;умолчанию,&lt;/strong&gt; который служит для сбора любого несопоставленного контента. В обоих приведенных выше примерах отображаемый HTML-код будет:</target>
        </trans-unit>
        <trans-unit id="892e9605b3eb99a1e8758152c0f0d14bd50018ba" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;vm.$nextTick()&lt;/code&gt; instance method, which is especially handy inside components, because it doesn&amp;rsquo;t need global &lt;code&gt;Vue&lt;/code&gt; and its callback&amp;rsquo;s &lt;code&gt;this&lt;/code&gt; context will be automatically bound to the current Vue instance:</source>
          <target state="translated">Существует также метод экземпляра &lt;code&gt;vm.$nextTick()&lt;/code&gt; , который особенно удобен внутри компонентов, потому что ему не нужен глобальный &lt;code&gt;Vue&lt;/code&gt; , а контекст &lt;code&gt;this&lt;/code&gt; его обратного вызова будет автоматически привязан к текущему экземпляру Vue:</target>
        </trans-unit>
        <trans-unit id="e795677faa92646e68896f4fa2d153d1c6b3dad9" translate="yes" xml:space="preserve">
          <source>There is no direct &lt;code&gt;v-model&lt;/code&gt; counterpart in render functions - you will have to implement the logic yourself:</source>
          <target state="translated">В функциях рендеринга нет прямого аналога &lt;code&gt;v-model&lt;/code&gt; - вам придется реализовать логику самостоятельно:</target>
        </trans-unit>
        <trans-unit id="a3dc3c28e5738e838da6dece3bd69b468532f5bd" translate="yes" xml:space="preserve">
          <source>There is no longer a special API to initialize an app with Vue Router. That means instead of:</source>
          <target state="translated">Больше нет специального API для инициализации приложения с помощью Vue Router.Это значит,что вместо:</target>
        </trans-unit>
        <trans-unit id="e786ab8525d61c08d5edd49d36eaafa66121f1c6" translate="yes" xml:space="preserve">
          <source>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the &lt;code&gt;.native&lt;/code&gt; modifier for &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">Бывают случаи, когда вы хотите прослушивать собственное событие непосредственно в корневом элементе компонента. В этих случаях вы можете использовать модификатор &lt;code&gt;.native&lt;/code&gt; для &lt;code&gt;v-on&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e13a2b6d1fa69f970582ef7c30a8696baaa1caf0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot you can do to help Vue grow in your community:</source>
          <target state="translated">Вы можете многое сделать, чтобы помочь Vue расти в вашем сообществе:</target>
        </trans-unit>
        <trans-unit id="c70dcc11c00ce0163cd6cf08b8dae423423a248d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no longer a use case for this in the new Vue Router.</source>
          <target state="translated">В новом маршрутизаторе Vue больше нет варианта использования.</target>
        </trans-unit>
        <trans-unit id="163f368f2bf083cc1079a14cd05b50989be0cc02" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We&amp;rsquo;ll fix that later.</source>
          <target state="translated">В этом примере есть одна проблема. Когда вы добавляете или удаляете элемент, все вокруг мгновенно фиксируются на новом месте вместо плавного перехода. Мы исправим это позже.</target>
        </trans-unit>
        <trans-unit id="5d85fbe7675b4e4ec3b50bf7054fe53d2209ebb4" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still one problem though. Try clicking the button below:</source>
          <target state="translated">Однако есть еще одна проблема. Попробуйте нажать кнопку ниже:</target>
        </trans-unit>
        <trans-unit id="e6396f41a177bd681652c0e5df217826f32aabe7" translate="yes" xml:space="preserve">
          <source>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;transitioned too&lt;/a&gt;:</source>
          <target state="translated">Эти анимации FLIP также не ограничиваются одной осью. Элементы в многомерной сетке тоже можно &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sLrhk1bc/&quot;&gt;перемещать&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="101fa3129d0c59027806566e19bcb27a91fd6013" translate="yes" xml:space="preserve">
          <source>These applications always include many in-DOM templates, where &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;kebab-case &lt;strong&gt;must&lt;/strong&gt; be used&lt;/a&gt;.</source>
          <target state="translated">Эти приложения всегда включают множество шаблонов в DOM, где &lt;a href=&quot;#Component-name-casing-in-templates-strongly-recommended&quot;&gt;&lt;strong&gt;необходимо&lt;/strong&gt;&lt;/a&gt; использовать kebab-case&lt;strong&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="79c4f8a294a999f0a432548c8b4a47252ba3a153" translate="yes" xml:space="preserve">
          <source>These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</source>
          <target state="translated">Они могут быть полезны для демо-версий с большими шаблонами или в очень маленьких приложениях,но в остальном их следует избегать,так как они отделяют шаблоны от остального определения компонента.</target>
        </trans-unit>
        <trans-unit id="4eda46855e3962039e549f3d03f1e9beb23fa48b" translate="yes" xml:space="preserve">
          <source>These components are &lt;strong&gt;globally registered&lt;/strong&gt;. That means they can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created after registration. For example:</source>
          <target state="translated">Эти компоненты &lt;strong&gt;зарегистрированы глобально&lt;/strong&gt; . Это означает, что их можно использовать в шаблоне любого корневого экземпляра Vue ( &lt;code&gt;new Vue&lt;/code&gt; ), созданного после регистрации. Например:</target>
        </trans-unit>
        <trans-unit id="c11fba5bbbf86f45897e779c4584d6721b0b2522" translate="yes" xml:space="preserve">
          <source>These components lay the foundation for consistent styling and behavior in your application. They may &lt;strong&gt;only&lt;/strong&gt; contain:</source>
          <target state="translated">Эти компоненты закладывают основу для согласованного стиля и поведения вашего приложения. Они могут содержать &lt;strong&gt;только&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c208483eb8caab5ce32ce55aa9ca8d4751b6d7ab" translate="yes" xml:space="preserve">
          <source>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain &lt;strong&gt;one single expression&lt;/strong&gt;, so the following will &lt;strong&gt;NOT&lt;/strong&gt; work:</source>
          <target state="translated">Эти выражения будут оцениваться как JavaScript в области данных экземпляра Vue владельца. Одно ограничение заключается в том, что каждая привязка может содержать только &lt;strong&gt;одно выражение&lt;/strong&gt; , поэтому следующее &lt;strong&gt;НЕ&lt;/strong&gt; будет работать:</target>
        </trans-unit>
        <trans-unit id="894c317239a0c7a65a9e88455fd9ec3ef7ebc237" translate="yes" xml:space="preserve">
          <source>These hooks can be used in combination with CSS transitions/animations or on their own.</source>
          <target state="translated">Эти крючки могут использоваться в сочетании с CSS-переходами/анимациями или самостоятельно.</target>
        </trans-unit>
        <trans-unit id="18eb93efc44d56c2080356f2acd2adc1588f6912" translate="yes" xml:space="preserve">
          <source>These limitations become apparent when designing a search indicator, like this one for example:</source>
          <target state="translated">Эти ограничения становятся очевидными при проектировании поискового индикатора,как,например,этот:</target>
        </trans-unit>
        <trans-unit id="44f058292bf91d7fdc0c19b30d4f231d10c8ffce" translate="yes" xml:space="preserve">
          <source>These modifiers restrict the handler to events triggered by a specific mouse button.</source>
          <target state="translated">Эти модификаторы ограничивают обработчик событиями,вызванными определенной кнопкой мыши.</target>
        </trans-unit>
        <trans-unit id="d2b0e629392045530844771affeff7b43f8ec099" translate="yes" xml:space="preserve">
          <source>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</source>
          <target state="translated">Эти правила были найдены,чтобы улучшить читабельность и/или опыт разработчиков в большинстве проектов.Ваш код все равно будет работать,если вы его нарушите,но нарушения должны быть редкими и хорошо обоснованными.</target>
        </trans-unit>
        <trans-unit id="91af92ef53fdf34200de7e0b28db35745ed2a1ae" translate="yes" xml:space="preserve">
          <source>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</source>
          <target state="translated">Эти правила помогают предотвратить ошибки,поэтому учитесь и соблюдайте их любой ценой.Исключения могут существовать,но они должны быть очень редкими и делаться только теми,кто хорошо знает JavaScript и Vue.</target>
        </trans-unit>
        <trans-unit id="e30564da6ab88875780c5728faa3632ae18dc83a" translate="yes" xml:space="preserve">
          <source>These specific languages are only examples. You could as easily use Bubl&amp;eacute;, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with &lt;code&gt;vue-loader&lt;/code&gt;, it also has first-class support for CSS Modules.</source>
          <target state="translated">Эти конкретные языки являются лишь примерами. С таким же успехом вы можете использовать Bubl&amp;eacute;, TypeScript, SCSS, PostCSS - или любые другие препроцессоры, которые помогут вам работать продуктивно. Если вы используете Webpack с &lt;code&gt;vue-loader&lt;/code&gt; , он также имеет первоклассную поддержку CSS-модулей.</target>
        </trans-unit>
        <trans-unit id="fdd9827028ef750f7255fe5fc506af18a8fb1368" translate="yes" xml:space="preserve">
          <source>These will override the conventional class names. This is especially useful when you want to combine Vue&amp;rsquo;s transition system with an existing CSS animation library, such as &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt;.</source>
          <target state="translated">Они переопределят обычные имена классов. Это особенно полезно, когда вы хотите объединить систему переходов Vue с существующей библиотекой анимации CSS, такой как &lt;a href=&quot;https://daneden.github.io/animate.css/&quot;&gt;Animate.css&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d1026e768f545462812038bf11ac5597aa461a" translate="yes" xml:space="preserve">
          <source>They document the API of the component, so that it&amp;rsquo;s easy to see how the component is meant to be used.</source>
          <target state="translated">Они документируют API компонента, так что легко увидеть, как компонент предназначен для использования.</target>
        </trans-unit>
        <trans-unit id="ee9fb3a66c9bf09491269055d05e63e8daff7baf" translate="yes" xml:space="preserve">
          <source>They have slightly different target users however.</source>
          <target state="translated">Однако у них несколько разные целевые пользователи.</target>
        </trans-unit>
        <trans-unit id="dddb496772a8230c124e4f06a214f032833805d2" translate="yes" xml:space="preserve">
          <source>They may look a bit different from normal HTML, but &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</source>
          <target state="translated">Они могут немного отличаться от обычного HTML, но &lt;code&gt;:&lt;/code&gt; и &lt;code&gt;@&lt;/code&gt; являются допустимыми символами для имен атрибутов, и все браузеры, поддерживающие Vue, могут правильно их проанализировать. Кроме того, они не отображаются в окончательной разметке. Сокращенный синтаксис не является обязательным, но вы, вероятно, оцените его, когда узнаете больше о его использовании позже.</target>
        </trans-unit>
        <trans-unit id="6a9f42e561d875ba212a21ce976d18f88707fb7e" translate="yes" xml:space="preserve">
          <source>They&amp;rsquo;re also very useful as wrapper components. For example, when you need to:</source>
          <target state="translated">Они также очень полезны в качестве компонентов оболочки. Например, когда вам нужно:</target>
        </trans-unit>
        <trans-unit id="36292b3c039d104e965d98c8c9a093ed70eee710" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;prevents conflicts&lt;/a&gt; with existing and future HTML elements, since all HTML elements are a single word.</source>
          <target state="translated">Это &lt;a href=&quot;http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name&quot;&gt;предотвращает конфликты&lt;/a&gt; с существующими и будущими элементами HTML, поскольку все элементы HTML состоят из одного слова.</target>
        </trans-unit>
        <trans-unit id="1ece11c20b0e27793001fdeec7df491259c0b914" translate="yes" xml:space="preserve">
          <source>This allows us add behavior that a filter alone couldn&amp;rsquo;t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;&lt;code&gt;currencyValidator&lt;/code&gt; object&lt;/a&gt;:</source>
          <target state="translated">Это позволяет нам добавить поведение, которое один фильтр не может инкапсулировать, например, выбор содержимого ввода в фокусе. Теперь следующим шагом будет извлечение бизнес-логики из фильтра. Ниже мы вытаскиваем все во внешний &lt;a href=&quot;https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e&quot;&gt;объект &lt;/a&gt; &lt;code&gt;currencyValidator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="74e149b933b7f933e9d6e2560dceac8830da4733" translate="yes" xml:space="preserve">
          <source>This allows you to compose components like this:</source>
          <target state="translated">Это позволяет составлять такие компоненты:</target>
        </trans-unit>
        <trans-unit id="2b017e21cf180432f227f352528adf7beedafa7a" translate="yes" xml:space="preserve">
          <source>This also means the following computed property will never update, because &lt;code&gt;Date.now()&lt;/code&gt; is not a reactive dependency:</source>
          <target state="translated">Это также означает, что следующее вычисленное свойство никогда не будет обновляться, потому что &lt;code&gt;Date.now()&lt;/code&gt; не является реактивной зависимостью:</target>
        </trans-unit>
        <trans-unit id="d966b066638dcbfbeb5f7c1fa054b2b9f4ac88e1" translate="yes" xml:space="preserve">
          <source>This attribute does not support dynamic binding.</source>
          <target state="translated">Данный атрибут не поддерживает динамическую привязку.</target>
        </trans-unit>
        <trans-unit id="85db9f37abb47bdae5f9736eb1fa18d771e503d8" translate="yes" xml:space="preserve">
          <source>This brings us full circle back to &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;, so if you&amp;rsquo;ve read this far it&amp;rsquo;s probably time to try it out!</source>
          <target state="translated">Это возвращает нас к &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt; , поэтому, если вы дочитали до этого места, возможно, самое время попробовать!</target>
        </trans-unit>
        <trans-unit id="e208871e834d455a504dbc7b4789f62b8d51dbdf" translate="yes" xml:space="preserve">
          <source>This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; to manage state in most cases.</source>
          <target state="translated">Это может быть удобно для демонстраций или очень небольших приложений с небольшим количеством компонентов. Однако шаблон плохо масштабируется для средних или крупных приложений, поэтому в большинстве случаев мы настоятельно рекомендуем использовать &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; для управления состоянием.</target>
        </trans-unit>
        <trans-unit id="f3ae7f80927899cd62140ba3ac91c1a272907e8a" translate="yes" xml:space="preserve">
          <source>This can be especially useful in combination with the &lt;code&gt;$attrs&lt;/code&gt; instance property, which contains the attribute names and values passed to a component, such as:</source>
          <target state="translated">Это может быть особенно полезно в сочетании со свойством экземпляра &lt;code&gt;$attrs&lt;/code&gt; , которое содержит имена атрибутов и значения, передаваемые компоненту, например:</target>
        </trans-unit>
        <trans-unit id="dc35e91b7f0ddcd858a9ed54df8c331d12068bc2" translate="yes" xml:space="preserve">
          <source>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, &lt;code&gt;v-slot&lt;/code&gt; without an argument is assumed to refer to the default slot:</source>
          <target state="translated">Его можно сократить еще больше. Так же, как неуказанный контент предполагается для слота по умолчанию, предполагается, что &lt;code&gt;v-slot&lt;/code&gt; без аргумента относится к слоту по умолчанию:</target>
        </trans-unit>
        <trans-unit id="e890dd0b9a03e7b18eb3ea7a9ab2b112967c585d" translate="yes" xml:space="preserve">
          <source>This can be useful sometimes, but it&amp;rsquo;s not a good idea when you&amp;rsquo;re trying to listen on a very specific element, like an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. For example, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component above might refactor so that the root element is actually a &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Иногда это может быть полезно, но это не очень хорошая идея, когда вы пытаетесь прослушивать очень конкретный элемент, например &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; . Например, приведенный выше компонент &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; может рефакторинговаться так, чтобы корневой элемент на самом деле был элементом &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef2288cfa9c5bb1049786a028d410bf6a81d1c49" translate="yes" xml:space="preserve">
          <source>This can be useful when you&amp;rsquo;ve defined CSS transitions/animations using Vue&amp;rsquo;s transition class conventions and want to switch between them.</source>
          <target state="translated">Это может быть полезно, когда вы определили переходы / анимацию CSS с использованием соглашений о классах переходов Vue и хотите переключаться между ними.</target>
        </trans-unit>
        <trans-unit id="22ed18f22c3147e4d4b605b99a8c886bf36867ed" translate="yes" xml:space="preserve">
          <source>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. &lt;code&gt;user&lt;/code&gt; to &lt;code&gt;person&lt;/code&gt;:</source>
          <target state="translated">Это может сделать шаблон намного чище, особенно когда в слоте есть много реквизита. Это также открывает другие возможности, такие как переименование реквизита, например, от &lt;code&gt;user&lt;/code&gt; к &lt;code&gt;person&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91d37bc2f925538550750ba2e9fce0b6e7858848" translate="yes" xml:space="preserve">
          <source>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</source>
          <target state="translated">Это может очень хорошо работать для малых и средних проектов,где JavaScript используется только для улучшения определенных представлений.Однако,в более сложных проектах,или когда ваш фронтенд полностью управляется с помощью JavaScript,эти недостатки становятся очевидными:</target>
        </trans-unit>
        <trans-unit id="552c6085e6177cea581b90083d77773efb3e8be2" translate="yes" xml:space="preserve">
          <source>This class is mostly useful for specifying the transition timing and easing curve, as you&amp;rsquo;ll see below:</source>
          <target state="translated">Этот класс в основном полезен для указания времени перехода и кривой замедления, как вы увидите ниже:</target>
        </trans-unit>
        <trans-unit id="a64fb541d6cf03a309471b66f62b3cc4e9df105f" translate="yes" xml:space="preserve">
          <source>This could be rewritten with JavaScript&amp;rsquo;s &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; in a render function:</source>
          <target state="translated">Это можно переписать с помощью JavaScript &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; и &lt;code&gt;map&lt;/code&gt; в функции рендеринга:</target>
        </trans-unit>
        <trans-unit id="dc281e6afa265cb93fadcfb1141b35d1dc6b8178" translate="yes" xml:space="preserve">
          <source>This default mode is efficient, but &lt;strong&gt;only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)&lt;/strong&gt;.</source>
          <target state="translated">Этот режим по умолчанию эффективен, но &lt;strong&gt;подходит только в том случае, если вывод рендеринга вашего списка не зависит от состояния дочернего компонента или временного состояния DOM (например, входных значений формы)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83c6bcc5ab3c17077a142a2b9547158e591eb788" translate="yes" xml:space="preserve">
          <source>This directive triggers transitions when its condition changes.</source>
          <target state="translated">Эта директива запускает переходы при изменении своего состояния.</target>
        </trans-unit>
        <trans-unit id="bcf9f3835622e83dc060967041ab679cca48d307" translate="yes" xml:space="preserve">
          <source>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt;, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</source>
          <target state="translated">Эта директива останется в элементе, пока связанный экземпляр Vue не завершит компиляцию. В сочетании с правилами CSS, такими как &lt;code&gt;[v-cloak] { display: none }&lt;/code&gt; , эту директиву можно использовать для скрытия нескомпилированных привязок усов, пока экземпляр Vue не будет готов.</target>
        </trans-unit>
        <trans-unit id="3e343af564058d721599d1f9e8b019d300435ac7" translate="yes" xml:space="preserve">
          <source>This does not mean the component is only used in a single page, but it will only be used once &lt;em&gt;per page&lt;/em&gt;. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it&amp;rsquo;s a good indication that this is actually a reusable component that is only used once per page &lt;em&gt;for now&lt;/em&gt;.</source>
          <target state="translated">Это не означает, что компонент используется только на одной странице, но он будет использоваться только один раз &lt;em&gt;на странице&lt;/em&gt; . Эти компоненты никогда не принимают никаких реквизитов, поскольку они относятся к вашему приложению, а не к их контексту в вашем приложении. Если вы обнаружите необходимость добавить реквизит, это хороший признак того, что это на самом деле многократно используемый компонент , который используется только один раз на странице &lt;em&gt;сейчас&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="045411f2b2e7825926721bc11467177b95eff687" translate="yes" xml:space="preserve">
          <source>This even applies to all subcomponents, meaning all three of these components will also be available &lt;em&gt;inside each other&lt;/em&gt;.</source>
          <target state="translated">Это применимо даже ко всем подкомпонентам, то есть все три этих компонента также будут доступны &lt;em&gt;друг в друге&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="82b2832a220d04d77924bc1b878abfa24eacde86" translate="yes" xml:space="preserve">
          <source>This example demonstrates that we can bind data to not only text and attributes, but also the &lt;strong&gt;structure&lt;/strong&gt; of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply &lt;a href=&quot;guide/transitions&quot;&gt;transition effects&lt;/a&gt; when elements are inserted/updated/removed by Vue.</source>
          <target state="translated">Этот пример демонстрирует, что мы можем привязать данные не только к тексту и атрибутам, но и к &lt;strong&gt;структуре&lt;/strong&gt; DOM. Более того, Vue также предоставляет мощную систему эффектов перехода, которая может автоматически применять &lt;a href=&quot;guide/transitions&quot;&gt;эффекты перехода,&lt;/a&gt; когда элементы вставляются / обновляются / удаляются с помощью Vue.</target>
        </trans-unit>
        <trans-unit id="28f4e1203d764412549f6b1974ffcd1631f009dd" translate="yes" xml:space="preserve">
          <source>This gives you more complete control over the reactive properties you&amp;rsquo;d like to watch.</source>
          <target state="translated">Это дает вам более полный контроль над реактивными свойствами, которые вы хотите отслеживать.</target>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">Он был заменен &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;параметром &lt;/a&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; , который принимает функцию, так что поведение прокрутки полностью настраивается - даже для каждого маршрута. Это открывает много новых возможностей, но для воспроизведения старого поведения:</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">Это было переработано как &lt;a href=&quot;../api/index#delimiters&quot;&gt;опция на уровне компонентов&lt;/a&gt; . Это позволяет вам использовать альтернативные разделители в вашем приложении без нарушения сторонних компонентов.</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">Это быстро вышло из-под контроля. Вот почему для произвольного предоставления контекстной информации дочерним компонентам мы рекомендуем &lt;a href=&quot;#Dependency-Injection&quot;&gt;внедрение зависимостей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">У этого есть две потенциальные проблемы:</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">Это поможет вам быстрее найти компонент,когда вам нужно будет его отредактировать или просмотреть,как его использовать.</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">Такая повышенная модульность не только облегчает миграцию на Vue 2,но и позволяет осуществлять разбор и форматирование валюты:</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">Это надуманный пример, но нам удалось разделить наше приложение на две меньшие единицы, и дочерний элемент достаточно хорошо отделен от родителя через интерфейс props. Теперь мы можем дополнительно улучшить наш компонент &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; , добавив более сложный шаблон и логику, не затрагивая родительское приложение.</target>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">Это определенно самая сложная страница в руководстве для написания, но мы считаем ее важной. Скорее всего, у вас были проблемы, которые вы пытались решить, и вы использовали другую библиотеку для их решения. Вы здесь, потому что хотите узнать, может ли Vue лучше решить ваши конкретные проблемы. Вот на что мы надеемся ответить за вас.</target>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">Теперь это &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;опция в определениях маршрутов&lt;/a&gt; . Так, например, вы обновите:</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">Теперь это &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;опция в определении маршрута&lt;/a&gt; , которому вы хотите присвоить псевдоним. Так, например, вы обновите:</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">Это часто бывает полезно, потому что даже с &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; значение входных элементов HTML всегда возвращает строку. Если значение не может быть проанализировано с помощью &lt;code&gt;parseFloat()&lt;/code&gt; , возвращается исходное значение.</target>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">Это актуально только для &lt;a href=&quot;../guide/single-file-components&quot;&gt;однофайловых компонентов&lt;/a&gt; . Он &lt;em&gt;не&lt;/em&gt; требует, чтобы &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; атрибут&lt;/a&gt; используется. Определение объема может осуществляться через &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;модули CSS&lt;/a&gt; , стратегию на основе классов, такую ​​как &lt;a href=&quot;http://getbem.com/&quot;&gt;БЭМ&lt;/a&gt; , или другую библиотеку / соглашение.</target>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">Это похоже на &lt;code&gt;mixins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">Это &lt;strong&gt;псевдоним&lt;/strong&gt; глобального &lt;code&gt;Vue.delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">Это &lt;strong&gt;псевдоним&lt;/strong&gt; глобального &lt;code&gt;Vue.set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">Это цена перехода на более низкий уровень, но это также дает вам гораздо больший контроль над деталями взаимодействия по сравнению с &lt;code&gt;v-model&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">Это порядок по умолчанию, который мы рекомендуем для опций компонентов. Они разделены на категории, поэтому вы будете знать, куда добавлять настраиваемые атрибуты и директивы.</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">Это порядок по умолчанию, который мы рекомендуем для опций компонентов. Они разделены на категории, поэтому вы будете знать, куда добавлять новые свойства из плагинов.</target>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">Это официальное руководство по стилю для кода, специфичного для Vue. Если вы используете Vue в проекте, это отличный справочник, позволяющий избежать ошибок, сбоев и анти-шаблонов. Однако мы не считаем, что какое-либо руководство по стилю идеально подходит для всех команд или проектов, поэтому поощряются осознанные отклонения, основанные на прошлом опыте, окружающем технологическом стеке и личных ценностях.</target>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">Вот как выглядит пример в действии:</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">Однако это не всегда желательно, поэтому Vue предлагает вам способ сказать: &amp;laquo;Эти два элемента полностью разделены - не используйте их повторно&amp;raquo;. Добавьте &lt;code&gt;key&lt;/code&gt; атрибут с уникальными значениями:</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">Это не рекомендуется, так как это приводит к:</target>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">Это позволяет использовать &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; для нескольких условных дочерних элементов:</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">Это упрощает переопределение внутренних стилей, с удобочитаемыми именами классов, которые не имеют слишком высокой специфичности, но все же очень маловероятно, что они приведут к конфликту.</target>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">Этот метод необходимо вызвать перед вызовом &lt;code&gt;new Vue()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">Это может показаться волшебством, но под капотом Vue использует технику анимации под названием &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; для плавного перехода элементов из их старого положения в новое с помощью преобразований.</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">Это не только документирует ваш компонент, но также предупреждает пользователей в консоли JavaScript браузера, если они передают неправильный тип. Вы узнаете гораздо больше о &lt;a href=&quot;#Prop-Validation&quot;&gt;проверках типов и других проверках свойств&lt;/a&gt; далее на этой странице.</target>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">Эта опция не больше не нужно теперь, когда система перехода Vue имеет явно &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; контроль перехода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">На этой странице предполагается, что вы уже прочитали &lt;a href=&quot;components&quot;&gt;основы работы&lt;/a&gt; с компонентами . Прочтите это в первую очередь, если вы новичок в компонентах.</target>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">Эта пара параметров используется вместе, чтобы позволить компоненту-предку служить в качестве инжектора зависимостей для всех его потомков, независимо от того, насколько глубока иерархия компонентов, пока они находятся в одной родительской цепочке. Если вы знакомы с React, это очень похоже на контекстную функцию React.</target>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">Это передает каждое свойство в объекте &lt;code&gt;doc&lt;/code&gt; (например, &lt;code&gt;title&lt;/code&gt; ) как отдельную опору, а затем добавляет слушателей обновления &lt;code&gt;v-on&lt;/code&gt; для каждого из них.</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">Этот шаблон позволяет использовать базовые компоненты больше похожие на необработанные HTML-элементы,без необходимости заботиться о том,какой элемент на самом деле находится в их корне:</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">Этот шаблон может служить заменой &lt;code&gt;$dispatch&lt;/code&gt; и &lt;code&gt;$broadcast&lt;/code&gt; в простых сценариях, но для более сложных случаев рекомендуется использовать специальный уровень управления состоянием, такой как &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">Этот раздел предполагает знание &lt;a href=&quot;components&quot;&gt;компонентов&lt;/a&gt; . Не стесняйтесь пропустить его и вернуться позже.</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">Этот раздел предполагает знание &lt;a href=&quot;components&quot;&gt;компонентов Vue&lt;/a&gt; . Не стесняйтесь пропустить его и вернуться позже.</target>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">Это всегда будет применять &lt;code&gt;errorClass&lt;/code&gt; , но будет применять &lt;code&gt;activeClass&lt;/code&gt; только тогда, когда &lt;code&gt;isActive&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">Это приведет к проблемам при использовании компонентов с элементами,имеющими такие ограничения.Например:</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">Это больше не сработает:</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">Это отобразит только последнее значение в массиве, поддерживаемом браузером. В этом примере он будет отображать &lt;code&gt;display: flex&lt;/code&gt; для браузеров, которые поддерживают версию flexbox без префикса.</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">Это даст тот же результат. Мы также можем выполнить привязку к &lt;a href=&quot;computed&quot;&gt;вычисляемому свойству,&lt;/a&gt; которое возвращает объект. Это распространенный и мощный паттерн:</target>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">Это работает хорошо, но следует помнить об одном предостережении:</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">Это закрепит элемент на расстоянии 200 пикселей от верха страницы. Но что произойдет, если мы столкнемся со сценарием, когда нам нужно закрепить элемент слева, а не сверху? Здесь очень удобен динамический аргумент, который можно обновлять для каждого экземпляра компонента:</target>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">Таким образом, позволяя родительскому компоненту фокусировать ввод внутри &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; с помощью:</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">Названия тесно связанных компонентов</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Настоятельно рекомендуется использовать тесно&lt;/sup&gt; связанные имена компонентов&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">Чтобы решить эту проблему, Vue предоставляет &lt;strong&gt;модификаторы событий&lt;/strong&gt; для &lt;code&gt;v-on&lt;/code&gt; . Напомним, что модификаторы - это постфиксы директив, обозначаемые точкой.</target>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">Чтобы также обнаруживать изменения вложенных значений внутри объектов, вам необходимо передать &lt;code&gt;deep: true&lt;/code&gt; в аргументе options. Обратите внимание, что вам не нужно этого делать, чтобы отслеживать мутации массива.</target>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">По одному определению оживить - значит оживить. К сожалению, когда дизайнеры создают значки, логотипы и талисманы, они обычно предоставляются в виде изображений или статических SVG-файлов. Таким образом, хотя октокот GitHub, птица Twitter и многие другие логотипы напоминают живых существ, на самом деле они не кажутся живыми.</target>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">Чтобы избежать отображения списка, если он должен быть скрыт (например, &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ). В этих случаях переместите &lt;code&gt;v-if&lt;/code&gt; в элемент контейнера (например, &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;ol&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">Чтобы справиться с предостережением 2, вы можете использовать &lt;code&gt;splice&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">Чтобы объяснить, что происходит, назовем наши компоненты A и B. Модульная система видит, что ей нужен A, но сначала A нужен B, но B нужен A, но A нужен B и т. Д. Он застрял в цикле, не зная, как это сделать. полностью разрешить любой компонент без предварительного разрешения другого. Чтобы исправить это, нам нужно дать модульной системе точку, в которой она может сказать: &amp;laquo;В &lt;em&gt;конце концов&lt;/em&gt; А понадобится Б , но нет необходимости сначала решать Б&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">Для фильтрации элементов в списке (например, &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ). В этих случаях замените &lt;code&gt;users&lt;/code&gt; новым вычисляемым свойством, которое возвращает ваш отфильтрованный список (например, &lt;code&gt;activeUsers&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Чтобы начать работу с Vue, все, что вам нужно, - это знакомство с HTML и ES5 JavaScript (т.е. обычным JavaScript). Обладая этими базовыми навыками, вы можете начать создавать нетривиальные приложения менее чем за день после чтения &lt;a href=&quot;../index&quot;&gt;руководства&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Чтобы дать Vue подсказку, чтобы он мог отслеживать идентичность каждого узла и, таким образом, повторно использовать и переупорядочивать существующие элементы, вам необходимо предоставить уникальный &lt;code&gt;key&lt;/code&gt; атрибут для каждого элемента:</target>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">Чтобы решить эту проблему, мы можем использовать &lt;strong&gt;шаблон магазина&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше о программных прослушивателях, ознакомьтесь с API для &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;методов экземпляра событий&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">Чтобы TypeScript мог правильно определять типы внутри параметров компонента Vue, вам необходимо определить компоненты с помощью &lt;code&gt;Vue.component&lt;/code&gt; или &lt;code&gt;Vue.extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">Чтобы пользователи могли взаимодействовать с вашим приложением, мы можем использовать директиву &lt;code&gt;v-on&lt;/code&gt; для присоединения слушателей событий, которые вызывают методы в наших экземплярах Vue:</target>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">Чтобы сделать &lt;code&gt;user&lt;/code&gt; доступным для содержимого слота в родительском элементе , мы можем привязать &lt;code&gt;user&lt;/code&gt; как атрибут к элементу &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">Чтобы преодолеть оговорку 1, оба следующих действия будут выполнять то же самое, что и &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; , но также будут запускать обновления состояния в системе реактивности:</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">Чтобы передать содержимое в именованные слоты от родителя, используйте специальный атрибут &lt;code&gt;slot&lt;/code&gt; в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (используя компонент &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Named-Slots&quot;&gt;здесь в&lt;/a&gt; качестве примера):</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">Чтобы передать слоты с &lt;code&gt;scopedSlots&lt;/code&gt; областью дочернему компоненту с помощью функций рендеринга, используйте поле scopedSlots в данных VNode:</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">Чтобы предоставить контент для именованных слотов, мы можем использовать директиву &lt;code&gt;v-slot&lt;/code&gt; в &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; , указав имя слота в качестве аргумента &lt;code&gt;v-slot&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">Чтобы получить реквизиты, переданные в слот, родительский компонент может использовать &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; с атрибутом &lt;code&gt;slot-scope&lt;/code&gt; (используя &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Scoped-Slots&quot;&gt;здесь в&lt;/a&gt; качестве примера):</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">Для определения стилей Vue добавляет уникальный атрибут к элементам компонента, например &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; . Затем селекторы изменяются так, что выбираются только совпадающие элементы с этим атрибутом (например, &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">Чтобы решить эту проблему, Vue предоставляет свойство &lt;code&gt;$listeners&lt;/code&gt; содержащее объект слушателей, используемых в компоненте. Например:</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">Чтобы задать тему для нашего плагина по выбору даты,нам,возможно,понадобится добавить конкретный класс,например,такой:</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">Чтобы указать проверки свойств, вы можете предоставить объекту с требованиями проверки значения &lt;code&gt;props&lt;/code&gt; вместо массива строк. Например:</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Чтобы начать переход к более надежному решению с использованием Vue 2.0, давайте сначала обернем этот фильтр в новый компонент &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать эти компоненты в шаблонах, они должны быть зарегистрированы, чтобы Vue знал о них. Существует два типа регистрации компонентов: &lt;strong&gt;глобальная&lt;/strong&gt; и &lt;strong&gt;локальная&lt;/strong&gt; . Пока что мы зарегистрировали компоненты только глобально, используя &lt;code&gt;Vue.component&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">Переключает свойство &lt;code&gt;display&lt;/code&gt; CSS элемента в зависимости от правдивости значения выражения.</target>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">Ошибки отслеживания времени выполнения</target>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">Атрибут &lt;code&gt;stagger&lt;/code&gt; перехода &lt;sup&gt;удален&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">Переходные классы</target>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">Переходные режимы</target>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">Переход между компонентами</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">Переход между элементами</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">Переходные отдельные элементы/компоненты</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">Переход между компонентами еще проще - нам даже не нужен &lt;code&gt;key&lt;/code&gt; атрибут. Вместо этого мы оборачиваем &lt;a href=&quot;components#Dynamic-Components&quot;&gt;динамический компонент&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">Переходы можно повторно использовать через систему компонентов Vue. Чтобы создать многократно используемый переход, все, что вам нужно сделать, это поместить компонент &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; в корень, а затем передать всех дочерних элементов в компонент перехода.</target>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">Переходы на первичного арендатора</target>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">Перевести Документы</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">Запуск события в текущем экземпляре. Любые дополнительные аргументы будут переданы в функцию обратного вызова слушателя.</target>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">триггерные переходы</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">Запускает &lt;code&gt;beforeDestroy&lt;/code&gt; и &lt;code&gt;destroyed&lt;/code&gt; крючки.</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">Правдивость / ложность с &lt;code&gt;v-bind&lt;/code&gt; &lt;sup&gt;изменена&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Попробуйте этот урок на Scrimba</target>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">Включить режим производства</target>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">Двусторонние фильтры &lt;sup&gt;заменены&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">Типовые проверки</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">Поддержка TypeScript</target>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">Под капотом Vue компилирует шаблоны в виртуальные функции рендеринга DOM.В сочетании с системой реактивности Vue способна грамотно вычислить минимальное количество компонентов для повторной отрисовки и применить минимальное количество манипуляций с DOM при изменении состояния приложения.</target>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">К сожалению, HTML не позволяет настраиваемым элементам самозакрываться - только &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;официальные &amp;laquo;пустые&amp;raquo; элементы&lt;/a&gt; . Вот почему эта стратегия возможна только тогда, когда компилятор шаблонов Vue может достичь шаблона до DOM, а затем обслужить HTML, соответствующий спецификации DOM.</target>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">К сожалению, из-за нечувствительности к регистру в HTML шаблоны DOM по-прежнему должны использовать kebab-case.</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">Единичные испытания</target>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">Если вы не распределяете компоненты по нескольким файлам (например, с &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;помощью модулей CSS&lt;/a&gt; ), определение области видимости CSS в React часто выполняется с помощью решений CSS-in-JS (например, &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;стилизованные компоненты&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;гламурность&lt;/a&gt; и &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;эмоции&lt;/a&gt; ). Это вводит новую парадигму стиля, ориентированную на компоненты, которая отличается от обычного процесса разработки CSS. Кроме того, несмотря на то, что существует поддержка извлечения CSS в единую таблицу стилей во время сборки, по-прежнему часто требуется включить среду выполнения в пакет для правильной работы стилей. Хотя при построении стилей вы получаете доступ к динамизму JavaScript, часто приходится сталкиваться с увеличением размера пакета и стоимости выполнения.</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">В отличие от &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; , он отображает реальный элемент: по умолчанию &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; . Вы можете изменить отображаемый элемент с помощью атрибута &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">В отличие от компонентов и свойств, имена событий не обеспечивают автоматического преобразования регистра. Вместо этого имя генерируемого события должно точно соответствовать имени, используемому для прослушивания этого события. Например, если генерируется имя события camelCased:</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">В отличие от компонентов и свойств, имена событий никогда не будут использоваться в качестве имен переменных или свойств в JavaScript, поэтому нет причин использовать camelCase или PascalCase. Кроме того, слушатели событий &lt;code&gt;v-on&lt;/code&gt; внутри шаблонов DOM будут автоматически преобразованы в нижний регистр (из-за нечувствительности HTML к регистру), поэтому &lt;code&gt;v-on:myEvent&lt;/code&gt; станет &lt;code&gt;v-on:myevent&lt;/code&gt; , что &lt;code&gt;myEvent&lt;/code&gt; невозможным для прослушивания.</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">В отличие от 1.x, эти &lt;code&gt;$refs&lt;/code&gt; не являются реактивными, потому что они регистрируются / обновляются во время самого процесса рендеринга. Чтобы сделать их реактивными, потребовалось бы дублировать рендеры для каждого изменения.</target>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">В отличие от других модификаторов, которые являются эксклюзивными для собственных событий DOM, модификатор &lt;code&gt;.once&lt;/code&gt; также может использоваться для &lt;a href=&quot;components-custom-events&quot;&gt;событий компонентов&lt;/a&gt; . Если вы еще не читали о компонентах, не беспокойтесь об этом.</target>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">Обновлено в 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;См. Здесь&lt;/a&gt; устаревший синтаксис с использованием атрибута &lt;code&gt;slot-scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">Обновлено в 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;См.&lt;/a&gt; Устаревший синтаксис с использованием атрибута &lt;code&gt;slot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">Обновляет &lt;code&gt;innerHTML&lt;/code&gt; элемента . &lt;strong&gt;Обратите внимание, что содержимое вставляется как простой HTML - они не будут скомпилированы как шаблоны Vue&lt;/strong&gt; . Если вы обнаружите, что пытаетесь составлять шаблоны с помощью &lt;code&gt;v-html&lt;/code&gt; , попробуйте переосмыслить решение, используя вместо этого компоненты.</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">&lt;code&gt;textContent&lt;/code&gt; элемента . Если вам нужно обновить часть &lt;code&gt;textContent&lt;/code&gt; , вы должны использовать интерполяцию &lt;code&gt;{{ Mustache }}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">Обновление всех этих узлов эффективно может быть затруднительным,но,к счастью,вам никогда не придется делать это вручную.Вместо этого вы сообщаете Vue,какой HTML вы хотите видеть на странице,в шаблоне:</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">Путь обновления</target>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt; &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; (или, возможно, &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ) lodash, чтобы напрямую ограничить вызов дорогостоящего метода. Вы можете добиться того же, что и выше, следующим образом:</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; (или, возможно, &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; ) в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt; используйте в компоненте beforeRouteEnter .</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt; используйте beforeRouteLeave в компоненте.</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt; используйте beforeEnter в маршруте.</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">С осторожностью используйте &lt;code&gt;$parent&lt;/code&gt; и &lt;code&gt;$children&lt;/code&gt; - они в основном служат для эвакуации. Предпочитайте использовать реквизиты и события для общения родителей и детей.</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">&lt;code&gt;Array.prototype.splice&lt;/code&gt; этого используйте Array.prototype.splice . Например:</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;Vue.set&lt;/code&gt; этого используйте Vue.set .</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">Используйте встроенный в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; метод .filter&lt;/a&gt; в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">Используйте встроенный в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; метод .slice&lt;/a&gt; в вычисляемом свойстве:</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">Используйте пользовательскую проверку in-DOM для других крючков.Например,для замены:</target>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">Вместо этого используйте компоненты.</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">Используйте глобальные миксины редко и осторожно, потому что это влияет на каждый созданный экземпляр Vue, включая сторонние компоненты. В большинстве случаев вы должны использовать его только для обработки настраиваемых параметров, как показано в примере выше. Также рекомендуется отправлять их как &lt;a href=&quot;plugins&quot;&gt;плагины,&lt;/a&gt; чтобы избежать дублирования приложений.</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">Используйте плагины, вызывая глобальный метод &lt;code&gt;Vue.use()&lt;/code&gt; . Это необходимо сделать до того, как вы запустите приложение, вызвав &lt;code&gt;new Vue()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">Используйте &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; для оптимальной отладки.</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;created&lt;/code&gt; хук.</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">Использование компонента &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; вместо крючков.</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">Используйте родной DOM API:</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">&lt;code&gt;beforeCreate&lt;/code&gt; этого используйте новый хук beforeCreate , что по сути то же самое. Он был переименован для согласования с другими методами жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">Вместо этого используйте новый &lt;code&gt;mounted&lt;/code&gt; крюк.</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">Вместо этого используйте новый &lt;code&gt;mounted&lt;/code&gt; крюк. Однако следует отметить, что с &lt;code&gt;mounted&lt;/code&gt; файлом нет гарантии, что он будет в документе. Для этого также &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">Используется для &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;динамических компонентов&lt;/a&gt; и для обхода &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;ограничений шаблонов в DOM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">Используется на контенте,вставленном в дочерние компоненты для указания,к какому именованному слоту принадлежит контент.</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">Используется для обозначения элемента &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; как слота с заданной областью действия.</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">Используется для обозначения элемента или компонента как слота с заданной областью действия. Значение атрибута должно быть допустимым выражением JavaScript, которое может отображаться в позиции аргумента сигнатуры функции. Это означает, что в поддерживаемых средах вы также можете использовать деструктуризацию ES2015 в выражении. Служит заменой &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; в 2.5.0+.</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">Используется для программного доступа к &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;слотам&lt;/a&gt; с заданной областью . Для каждого слота, в том числе слота по &lt;code&gt;default&lt;/code&gt; , объект содержит соответствующую функцию, возвращающую VNodes.</target>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">Используется для программного доступа к контенту, &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;распределенному по слотам&lt;/a&gt; . Каждый &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;именованный слот&lt;/a&gt; имеет собственное соответствующее свойство (например, содержимое &lt;code&gt;v-slot:foo&lt;/code&gt; будет найдено в &lt;code&gt;vm.$slots.foo&lt;/code&gt; ). Свойство по &lt;code&gt;default&lt;/code&gt; содержит либо узлы, не включенные в именованный слот, либо содержимое &lt;code&gt;v-slot:default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">Использование &lt;code&gt;$emit&lt;/code&gt; с дополнительными аргументами:</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">Использование &lt;code&gt;$emit&lt;/code&gt; только с именем события:</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">Также разрешено использование атрибутов &lt;code&gt;keyCode&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">Использование &lt;code&gt;v-bind.sync&lt;/code&gt; с литеральным объектом, например, в &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; , не будет работать, потому что существует слишком много крайних случаев, которые следует учитывать при синтаксическом анализе сложного выражения, подобного этому. .</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">Используя &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; , мы перебираем &lt;em&gt;только&lt;/em&gt; активных пользователей во время рендеринга, делая рендеринг намного более эффективным.</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">Совместное использование &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; &lt;strong&gt;не рекомендуется&lt;/strong&gt; . См. &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;Руководство&lt;/a&gt; по стилю для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">Использование &lt;code&gt;v-model&lt;/code&gt; для компонентов</target>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">Использование JavaScript выражений</target>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">Совместное использование переходов и анимации</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">Использование плагина</target>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">Использование введенного значения для ввода данных:</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">Использование впрыскиваемого значения по умолчанию для реквизита:</target>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">Используя свойство &lt;code&gt;$listeners&lt;/code&gt; , вы можете перенаправить все прослушиватели событий в компоненте конкретному дочернему элементу с помощью &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; . Для таких элементов, как &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , с которыми вы также хотите работать с &lt;code&gt;v-model&lt;/code&gt; , часто бывает полезно создать новое вычисляемое свойство для слушателей, например &lt;code&gt;inputListeners&lt;/code&gt; ниже:</target>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">Используя &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; , описанный &lt;a href=&quot;#Other-Examples&quot;&gt;здесь&lt;/a&gt; в качестве примера, вот эквивалентное использование с использованием &lt;code&gt;slot-scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">Используя атрибут &lt;code&gt;debounce&lt;/code&gt; , не было бы возможности обнаружить состояние &amp;laquo;Typing&amp;raquo;, потому что мы теряем доступ к состоянию ввода в реальном времени. Однако, отделив функцию debounce от Vue, мы можем устранить только ту операцию, которую хотим ограничить, снимая ограничения на функции, которые мы можем разработать:</target>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">Используя эту стратегию,мы даже могли бы использовать Pikaday с несколькими входными элементами,при этом каждый новый экземпляр будет автоматически очищаться после себя:</target>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">Однако обычно вам нужно, чтобы каждая опора имела определенный тип значения. В этих случаях вы можете указать реквизиты как объект, где имена и значения свойств содержат имена и типы свойств, соответственно:</target>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">интерфейс VNode</target>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodes должны быть уникальными</target>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">Переплеты по стоимости</target>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">Видео от &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt; . Посмотрите бесплатный &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;курс&lt;/a&gt; Vue Mastery Intro to Vue .</target>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">Посетители &lt;em&gt;в&lt;/em&gt; музее</target>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue (произносится как / vjuː /, как &lt;strong&gt;вид&lt;/strong&gt; ) - это &lt;strong&gt;прогрессивный фреймворк&lt;/strong&gt; для создания пользовательских интерфейсов. В отличие от других монолитных фреймворков, Vue разработан с нуля для постепенного внедрения. Основная библиотека ориентирована только на слой представления, и ее легко выбрать и интегрировать с другими библиотеками или существующими проектами. С другой стороны, Vue также отлично поддерживает сложные одностраничные приложения при использовании в сочетании с &lt;a href=&quot;guide/single-file-components&quot;&gt;современными инструментами&lt;/a&gt; и &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;вспомогательными библиотеками&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue достигает этого, создавая &lt;strong&gt;виртуальную&lt;/strong&gt; модель &lt;strong&gt;DOM,&lt;/strong&gt; чтобы отслеживать изменения, которые необходимо внести в реальную модель DOM. Присмотревшись к этой строке:</target>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vue также предлагает &lt;code&gt;.passive&lt;/code&gt; модификатор, соответствующий &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &amp;laquo;s &lt;code&gt;passive&lt;/code&gt; вариант&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vue также предоставляет директиву &lt;code&gt;v-model&lt;/code&gt; , которая упрощает двустороннюю привязку между вводом формы и состоянием приложения:</target>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Вью может помочь.Поскольку SVG-это всего лишь данные,нам нужны только примеры того,как выглядят эти существа,когда они возбуждены,думают или встревожены.Тогда Vue может помочь в переходе между этими состояниями,делая ваши приветственные страницы,загрузку индикаторов и уведомления более эмоциональными.</target>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Компоненты Vue предоставляют важные функции,которые недоступны в простых пользовательских элементах,в частности,межкомпонентный поток данных,пользовательская коммуникация по событиям и интеграция инструментов построения.</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vue &lt;strong&gt;не&lt;/strong&gt; поддерживает IE8 и ниже, потому что он использует функции ECMAScript 5, которые нельзя использовать в IE8. Однако он поддерживает все &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;браузеры, совместимые с ECMAScript 5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vue не позволяет динамически добавлять новые реактивные свойства корневого уровня к уже созданному экземпляру. Однако можно добавить реактивные свойства к вложенному объекту с помощью &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; . Например, учитывая:</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vue не позволяет динамически добавлять новые реактивные свойства корневого уровня к уже созданному экземпляру. Однако можно добавить реактивные свойства к вложенному объекту с помощью &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vue предоставляет более общий способ наблюдать и реагировать на изменения данных в экземпляре Vue: &lt;strong&gt;смотреть свойства&lt;/strong&gt; . Когда у вас есть данные, которые необходимо изменить на основе других данных, возникает соблазн злоупотреблять &lt;code&gt;watch&lt;/code&gt; особенно если вы работаете с AngularJS. Однако часто лучше использовать вычисляемое свойство, чем обязательный обратный вызов &lt;code&gt;watch&lt;/code&gt; . Рассмотрим этот пример:</target>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vue совершенно не страдает от этого, потому что он использует прозрачную систему наблюдения за зависимостями с асинхронной постановкой в ​​очередь - все изменения запускаются независимо, если у них нет явных отношений зависимости.</target>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vue использует классические веб-технологии и опирается на них. Чтобы показать вам, что это означает, мы рассмотрим несколько примеров.</target>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue имеет более четкое разделение между директивами и компонентами.Директивы предназначены только для инкапсуляции манипуляций DOM,в то время как компоненты являются автономными единицами,которые имеют свою собственную логику представления и данных.В AngularJS директивы делают все,а компоненты являются лишь специфическим видом директив.</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vue уже распространился по всему миру, и даже основная команда работает как минимум в полдюжине часовых поясов. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;Форум&lt;/a&gt; включает 7 языков и их количество растет, и многие из наших документов &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;активно поддерживают переводы&lt;/a&gt; . Мы очень гордимся международным охватом Vue, но мы можем добиться большего.</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vue имеет лучшую производительность и его намного проще оптимизировать, поскольку он не использует грязную проверку. AngularJS становится медленным, когда есть много наблюдателей, потому что каждый раз, когда что-либо в области видимости изменяется, все эти наблюдатели должны быть повторно оценены. Кроме того, цикл дайджеста может выполняться несколько раз для &amp;laquo;стабилизации&amp;raquo;, если какой-либо наблюдатель запускает другое обновление. Пользователям AngularJS часто приходится прибегать к эзотерическим методам, чтобы обойти цикл дайджеста, а в некоторых ситуациях нет возможности оптимизировать область действия с большим количеством наблюдателей.</target>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue реализует API распространения контента, вдохновленный &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;черновиком спецификации веб-компонентов&lt;/a&gt; , используя элемент &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; в качестве точек распространения контента.</target>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vue также доступен на &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; и &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs требует некоторого времени для синхронизации, поэтому последняя версия может быть недоступна).</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue гораздо менее категорична,чем Angular,предлагая официальную поддержку различных сборочных систем,без ограничений на то,как вы структурируете ваше приложение.Многие разработчики пользуются этой свободой,в то время как некоторые предпочитают иметь только один правильный способ сборки любого приложения.</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vue намного проще,чем AngularJS,как с точки зрения API,так и дизайна.Обучение,достаточное для сборки нетривиальных приложений,обычно занимает меньше дня,что не верно для AngularJS.</target>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vue необходимо подключить прослушиватели событий, чтобы знать, когда переход закончился. Это может быть &lt;code&gt;transitionend&lt;/code&gt; или завершение &lt;code&gt;animationend&lt;/code&gt; , в зависимости от типа применяемых правил CSS. Если вы используете только один или другой, Vue может автоматически определить правильный тип.</target>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vue предоставляет компонент-оболочку &lt;code&gt;transition&lt;/code&gt; , позволяющий добавлять переходы входа / выхода для любого элемента или компонента в следующих контекстах:</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue предоставляет различные способы применения эффектов перехода при вставке,обновлении или удалении элементов с флэш-накопителя.Сюда входят инструменты для:</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue предоставляет псевдонимы для наиболее часто используемых ключевых кодов,когда это необходимо для поддержки устаревшего браузера:</target>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vue предоставляет &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;официальный интерфейс командной строки&lt;/a&gt; для быстрого создания амбициозных одностраничных приложений. Он предоставляет настройки сборки с батарейками для современного рабочего процесса. Подготовка к работе со сборками с горячей перезагрузкой, сохранением с сохранением и готовыми к работе сборками занимает всего несколько минут. Дополнительную информацию см. &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;В документации Vue CLI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue обеспечивает ненавязчивую реактивность на простые объекты JavaScript и полностью автоматические вычисляемые свойства.В Ember необходимо обернуть все в Ember Objects и вручную объявить зависимости для вычисляемых свойств.</target>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vue рекомендует использовать шаблоны для создания вашего HTML в подавляющем большинстве случаев. Однако бывают ситуации, когда вам действительно нужна вся программная мощь JavaScript. Здесь вы можете использовать &lt;strong&gt;функцию рендеринга&lt;/strong&gt; , более близкую к компилятору альтернативу шаблонам.</target>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue старается рендерить элементы максимально эффективно,часто используя их повторно вместо рендеринга с нуля.Помимо того,что Vue помогает сделать рендеринг очень быстрым,это может иметь некоторые полезные преимущества.Например,если вы позволяете пользователям переключаться между несколькими типами входа:</target>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vue использует префикс &lt;code&gt;_&lt;/code&gt; для определения своих собственных частных свойств, поэтому использование того же префикса (например, &lt;code&gt;_update&lt;/code&gt; ) может привести к перезаписи свойства экземпляра. Даже если вы проверяете, а Vue в настоящее время не использует конкретное имя свойства, нет гарантии, что конфликт не возникнет в более поздней версии.</target>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue автоматически пронюхает,применяются ли к целевому элементу CSS-переходы или анимации.Если это так,то классы CSS-переходов будут добавлены/удалены в соответствующие тайминги.</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue обертывает методы мутации наблюдаемого массива, поэтому они также будут запускать обновления представления. Обернутые методы:</target>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Сообщество Vue растет невероятно быстро, и если вы читаете это, есть хороший шанс, что вы готовы к нему присоединиться. Итак&amp;hellip; добро пожаловать!</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Синтаксис шаблона Vue использует всю мощь выражений JavaScript, в то время как синтаксис выражений Handlebars и вспомогательный синтаксис намеренно сильно ограничены в сравнении.</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Система перехода Vue сильно изменилась и теперь использует элементы оболочки &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; , а не атрибут &lt;code&gt;transition&lt;/code&gt; . Чтобы узнать больше , рекомендуется прочитать новое &lt;a href=&quot;transitions&quot;&gt;руководство&lt;/a&gt; по переходам .</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Система переходов Vue предлагает множество простых способов анимировать вход, выход и списки, но как насчет анимации самих данных? Например:</target>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile(template )</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component(id,[определение])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete(target,propertyName/index )</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive(id,[definition])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extension(options )</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter(id,[определение])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.js позволяет определять фильтры, которые можно использовать для применения общего форматирования текста. Фильтры можно использовать в двух местах: &lt;strong&gt;интерполяция усов и выражения &lt;code&gt;v-bind&lt;/code&gt; &lt;/strong&gt; (последнее поддерживается в 2.1.0+). Фильтры должны быть добавлены в конец выражения JavaScript, обозначенного символом &amp;laquo;вертикальная черта&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js использует синтаксис шаблона на основе HTML, который позволяет вам декларативно привязать визуализированную DOM к данным базового экземпляра Vue. Все шаблоны Vue.js представляют собой допустимый HTML-код, который может анализироваться браузерами, соответствующими спецификациям, и анализаторами HTML.</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin(mixin )</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick([обратный вызов,контекст])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable(object )</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set(target,propertyName/index,value )</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">View.use(plugin )</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Выпущен Vuex 2.0, но в этом руководстве рассматривается только переход на 1.0? Это опечатка? Кроме того, похоже, что Vuex 1.0 и 2.0 были выпущены одновременно. В чем дело? Что мне следует использовать и что совместимо с Vue 2.0?</target>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Посмотрите бесплатный урок на Vue School</target>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Посмотрите бесплатный видеокурс Vue Mastery.</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Посмотрите бесплатный видеокурс на Vue School</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Посмотрите бесплатный видеоурок на Vue School</target>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Посмотрите видео объяснение на Vue Mastery</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Следите за выражением или вычисленной функцией на экземпляре Vue за изменениями.Обратный вызов вызывается с новым значением и старым значением.Выражение принимает только разделенные точками пути.Для более сложных выражений используйте функцию.</target>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">Наблюдатели позволяют нам анимировать изменения любого числового свойства в другое свойство. Абстрактно это может показаться сложным, поэтому давайте рассмотрим пример с использованием &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">Наблюдатели, созданные с помощью &lt;code&gt;vm.$watch&lt;/code&gt; , теперь запускаются перед повторной визуализацией связанного компонента. Это дает вам возможность дополнительно обновить состояние перед повторной визуализацией компонента, что позволяет избежать ненужных обновлений. Например, вы можете наблюдать за опорой компонента и обновлять собственные данные компонента при изменении опоры.</target>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">Мы также очень стараемся избегать предвзятости. Очевидно, что нам, как основной команде, очень нравится Vue. Есть некоторые проблемы, которые, по нашему мнению, он решает лучше, чем что-либо еще. Если бы мы в это не верили, мы бы не работали над этим. Однако мы хотим быть честными и точными. Там, где другие библиотеки предлагают значительные преимущества, такие как обширная экосистема альтернативных средств визуализации React или поддержка браузеров Knockout вплоть до IE6, мы также стараемся перечислить их.</target>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">Мы можем объединить эту технику с нашей предыдущей реализацией,чтобы оживить все возможные изменения в нашем списке!</target>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;v-model&lt;/code&gt; непосредственно в наших пользовательских входных данных, что не только более согласовано с обычными входами, но также означает, что наш компонент совместим с Vuex.</target>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">Мы можем передать массив в &lt;code&gt;v-bind:class&lt;/code&gt; , чтобы применить список классов:</target>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">Мы можем передать объект в &lt;code&gt;v-bind:class&lt;/code&gt; для динамического переключения классов:</target>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">Мы можем использовать директиву &lt;code&gt;v-for&lt;/code&gt; для отображения списка элементов на основе массива. &lt;code&gt;v-for&lt;/code&gt; директивы требует специального синтаксиса в виде &lt;code&gt;item in items&lt;/code&gt; , где &lt;code&gt;items&lt;/code&gt; является массивом источника данных и &lt;code&gt;item&lt;/code&gt; является &lt;strong&gt;псевдонимом&lt;/strong&gt; для элемента массива итерируемого на:</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">Мы можем использовать директиву &lt;code&gt;v-on&lt;/code&gt; для прослушивания событий DOM и запуска некоторого JavaScript, когда они запускаются.</target>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">Мы могли бы управлять коммуникацией между компонентами с помощью этого единого центра событий:</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">Мы обсудим &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;переход между компонентами&lt;/a&gt; позже, но вы также можете переходить между необработанными элементами, используя &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; . Один из наиболее распространенных двухэлементных переходов - между контейнером списка и сообщением, описывающим пустой список:</target>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">Мы получаем аналогичные преимущества от обновления:</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">Мы получаем следующие преимущества:</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">У нас есть отдельная секция для нового Angular,потому что это действительно совершенно другой каркас по сравнению с AngularJS.Например,он имеет первоклассную компонентную систему,многие детали реализации были полностью переписаны,и API также сильно изменился.</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">Мы уже создали наше самое первое приложение Vue! Это выглядит очень похоже на рендеринг строкового шаблона, но Vue проделал большую внутреннюю работу. Теперь данные и DOM связаны, и теперь все является &lt;strong&gt;реактивным&lt;/strong&gt; . Откуда нам знать? Откройте консоль JavaScript вашего браузера (прямо сейчас на этой странице) и установите для &lt;code&gt;app.message&lt;/code&gt; другое значение. Вы должны увидеть обновленный обновленный пример выше.</target>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">Мы создали отдельное руководство по созданию приложений Vue, отрисовываемых на сервере. Это очень подробное руководство для тех, кто уже знаком с разработкой Vue на стороне клиента, разработкой на стороне сервера Node.js и веб-пакетами. Проверьте это на &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">Нам может потребоваться, чтобы текст &amp;laquo;Отправить&amp;raquo; большую часть времени отображался внутри &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; . Чтобы &amp;laquo;отправить&amp;raquo; резервный контент, мы можем поместить его между тегами &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">Мы могли бы захотеть заменить этот резервный контент, чтобы отображать имя пользователя вместо последнего, например:</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">Мы могли бы захотеть повторно использовать этот компонент, позволяя пользователям вести несколько списков (например, для покупок, списков желаний, повседневных дел и т. Д.). Но есть проблема. Поскольку каждый экземпляр компонента ссылается на один и тот же объект данных, изменение заголовка одного списка также изменит заголовок каждого другого списка. То же самое верно для добавления / редактирования / удаления задачи.</target>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">Мы окружаем аргументы круглыми скобками и делим аргументы запятыми:</target>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">Мы также хотели бы, чтобы &lt;strong&gt;вы&lt;/strong&gt; помогали поддерживать этот документ в актуальном состоянии, потому что мир JavaScript быстро развивается! Если вы заметили неточность или что-то, что вам кажется не совсем правильным, сообщите нам об этом, &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;открыв вопрос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">Мы рассмотрим VNodes более подробно &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;позже&lt;/a&gt; , когда будем обсуждать &lt;a href=&quot;render-function&quot;&gt;функции рендеринга&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">В следующем разделе мы рассмотрим аргументы, передаваемые в эти хуки (например, &lt;code&gt;el&lt;/code&gt; , &lt;code&gt;binding&lt;/code&gt; , &lt;code&gt;vnode&lt;/code&gt; и &lt;code&gt;oldVnode&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">Подробнее о &lt;a href=&quot;components&quot;&gt;компонентной системе&lt;/a&gt; мы поговорим позже. На данный момент просто знайте, что все компоненты Vue также являются экземплярами Vue и поэтому принимают один и тот же объект параметров (за исключением нескольких параметров, связанных с корнем).</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">Мы просто следуем соглашениям каждого языка. В JavaScript camelCase более естественен. В HTML kebab-case есть.</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">Однако мы все еще ограничены фильтрами и Vue 1.0 в целом, поэтому давайте завершим обновление до Vue 2.0:</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Мы кратко представили самые основные функции ядра Vue.js - остальная часть этого руководства будет охватывать их и другие расширенные функции с гораздо более мелкими деталями, поэтому обязательно прочтите все это!</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">А как же разделение опасений?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">Что ты можешь сделать</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">Что на самом деле возвращает &lt;code&gt;createElement&lt;/code&gt; ? Это не &lt;em&gt;совсем&lt;/em&gt; настоящий элемент DOM. Возможно, более точно его можно было бы назвать &lt;code&gt;createNodeDescription&lt;/code&gt; , поскольку он содержит информацию, описывающую Vue, какой тип узла он должен отображать на странице, включая описания любых дочерних узлов. Мы называем это описание узла &amp;laquo;виртуальным узлом&amp;raquo;, обычно сокращенно &lt;strong&gt;VNode&lt;/strong&gt; . &amp;laquo;Виртуальная модель DOM&amp;raquo; - это то, что мы называем всем деревом виртуальных узлов, построенным на основе дерева компонентов Vue.</target>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Что такое Vue.js?</target>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">Когда &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; имеет несколько дочерних элементов, в конечном итоге они должны оценивать одного ребенка. Любой дочерний элемент, кроме первого, будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">Когда &lt;code&gt;isActive&lt;/code&gt; истинно, обработанный HTML будет:</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">При изменении &lt;code&gt;isActive&lt;/code&gt; или &lt;code&gt;hasError&lt;/code&gt; список классов будет соответственно обновлен. Например, если &lt;code&gt;hasError&lt;/code&gt; становится &lt;code&gt;true&lt;/code&gt; , список классов станет &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">Когда &lt;code&gt;ref&lt;/code&gt; используется вместе с &lt;code&gt;v-for&lt;/code&gt; , полученный вами ref будет массивом, содержащим дочерние компоненты, отражающие источник данных.</target>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">При изменении &lt;code&gt;text&lt;/code&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; всегда будет заменен, а не исправлен, поэтому переход будет запущен.</target>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Когда Vue обновляет список элементов, отображаемых с помощью &lt;code&gt;v-for&lt;/code&gt; , по умолчанию он использует стратегию &amp;laquo;исправления на месте&amp;raquo;. Если порядок элементов данных изменился, вместо перемещения элементов DOM в соответствии с порядком элементов, Vue исправит каждый элемент на месте и убедитесь, что он отражает то, что должно отображаться в этом конкретном индексе. Это похоже на поведение &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; в Vue 1.x.</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Когда Vue обрабатывает директивы, &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; , поэтому этот шаблон:</target>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">Когда ViewModel уничтожается, все прослушиватели событий автоматически удаляются. Вам не нужно беспокоиться о том, чтобы очистить его самостоятельно.</target>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Когда создается экземпляр Vue, он добавляет все свойства, найденные в его объекте &lt;code&gt;data&lt;/code&gt; в систему &lt;strong&gt;реактивности&lt;/strong&gt; Vue . Когда значения этих свойств изменятся, представление &amp;laquo;отреагирует&amp;raquo;, обновившись, чтобы соответствовать новым значениям.</target>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">Когда браузер читает этот код, он строит &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;дерево &amp;laquo;узлов DOM&amp;raquo;,&lt;/a&gt; чтобы помочь ему отслеживать все, точно так же, как вы могли бы построить генеалогическое древо, чтобы отслеживать свою расширенную семью.</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">Когда компонент переключается внутри &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; , его &lt;code&gt;activated&lt;/code&gt; и &lt;code&gt;deactivated&lt;/code&gt; хуки жизненного цикла будут вызваны соответственно.</target>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">Когда миксин и сам компонент содержат перекрывающиеся параметры, они будут &amp;laquo;объединены&amp;raquo; с использованием соответствующих стратегий.</target>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">Когда элемент, заключенный в компонент &lt;code&gt;transition&lt;/code&gt; вставляется или удаляется, происходит следующее:</target>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">При создании компонента &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; ваш шаблон в конечном итоге будет содержать больше, чем просто заголовок:</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">Когда компоненты начинают чувствовать себя стесненными или трудночитаемыми,добавление промежутков между многострочными свойствами может сделать их легче снимать снова.В некоторых редакторах,таких как Vim,такие опции форматирования также могут облегчить навигацию с помощью клавиатуры.</target>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">Когда пользовательские параметры объединяются, они используют стратегию по умолчанию, которая перезаписывает существующее значение. Если вы хотите, чтобы настраиваемый параметр был объединен с использованием настраиваемой логики, вам необходимо прикрепить функцию к &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">При определении &lt;strong&gt;компонента&lt;/strong&gt; , &lt;code&gt;data&lt;/code&gt; должны быть объявлены как функция , которая возвращает исходный объект данных, потому что будет много случаев , созданных с использованием того же определения. Если мы используем простой объект для &lt;code&gt;data&lt;/code&gt; , этот же объект будет &lt;strong&gt;использоваться по ссылке&lt;/strong&gt; для всех созданных экземпляров! Предоставляя функцию &lt;code&gt;data&lt;/code&gt; , каждый раз, когда создается новый экземпляр, мы можем вызывать его, чтобы вернуть новую копию исходных данных.</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">При определении компонента с помощью PascalCase вы можете использовать любой случай при ссылке на его настраиваемый элемент. Это означает , что допустимы как &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; ,так и &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; . Обратите внимание, однако, что только имена kebab-case действительны непосредственно в DOM (т.е. не строковые шаблоны).</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">При определении компонента с помощью kebab-case вы также должны использовать kebab-case при ссылке на его настраиваемый элемент, например, в &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">Когда каждое вычисляемое свойство содержит только очень простое выражение с очень небольшим количеством зависимостей, гораздо проще написать тесты, подтверждающие, что оно работает правильно.</target>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">При включении имени / ключа свойства порядок аргументов для объектов был &lt;code&gt;(name, value)&lt;/code&gt; . Теперь &lt;code&gt;(value, name)&lt;/code&gt; больше соответствует обычным итераторам объектов, таким как lodash.</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">При включении &lt;code&gt;index&lt;/code&gt; порядок аргументов для массивов был &lt;code&gt;(index, value)&lt;/code&gt; . Теперь &lt;code&gt;(value, index)&lt;/code&gt; более согласовано с такими методами массива JavaScript, как &lt;code&gt;forEach&lt;/code&gt; и &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">При итерации по объекту порядок основан на порядке перечисления &lt;code&gt;Object.keys()&lt;/code&gt; , что &lt;strong&gt;не&lt;/strong&gt; гарантирует единообразия во всех реализациях механизма JavaScript.</target>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">При прослушивании событий клавиатуры нам часто нужно проверять наличие определенных клавиш. Vue позволяет добавлять ключевые модификаторы для &lt;code&gt;v-on&lt;/code&gt; при прослушивании ключевых событий:</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">При прослушивании собственных событий DOM метод получает собственное событие как единственный аргумент. Если используется встроенный оператор, он имеет доступ к специальному свойству &lt;code&gt;$event&lt;/code&gt; : &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">При организации в редакторах в алфавитном порядке все базовые компоненты вашего приложения перечислены вместе, что упрощает их идентификацию.</target>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">При передаче массивов в параметры запроса синтаксис QueryString больше не &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; , вместо этого используется новый синтаксис &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; . Внутренне &lt;code&gt;$route.query.users&lt;/code&gt; прежнему будет массивом, но если в запросе есть только один параметр: &lt;code&gt;/foo?users=Tom&lt;/code&gt; , при прямом доступе к этому маршруту маршрутизатор не сможет узнать, ожидали ли мы &lt;code&gt;users&lt;/code&gt; быть массивом. По этой &lt;code&gt;$route.query.users&lt;/code&gt; рассмотрите возможность добавления вычисляемого свойства и замены им каждой ссылки $ route.query.users :</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">Когда проверка prop не проходит,Vue выдает консольное предупреждение (если используется сборка разработки).</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">При регистрации компонента ему всегда будет присвоено имя. Например, в глобальной регистрации мы видели:</target>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">Если установлено значение &lt;code&gt;true&lt;/code&gt; , будут сохраняться и отображаться HTML-комментарии, найденные в шаблонах. По умолчанию они отбрасываются.</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">Однако при переключении между этими компонентами вам иногда может потребоваться сохранить их состояние или избежать повторного рендеринга по соображениям производительности. Например, при небольшом расширении нашего интерфейса с вкладками:</target>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">Когда специальный атрибут &lt;code&gt;inline-template&lt;/code&gt; присутствует в дочернем компоненте, компонент будет использовать его внутреннее содержимое в качестве своего шаблона, а не рассматривать его как распределенное содержимое. Это позволяет более гибко создавать шаблоны.</target>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">Когда компонент отрисовывается, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; будет заменен на &amp;laquo;Ваш профиль&amp;raquo;. Слоты могут содержать любой шаблонный код, включая HTML:</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">Когда глобальный фильтр имеет то же имя,что и локальный фильтр,предпочтение будет отдано локальному фильтру.</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">Когда страница загружается, этот элемент получает фокус (примечание: &lt;code&gt;autofocus&lt;/code&gt; не работает в мобильном Safari). Фактически, если вы не нажимали ни на что другое с момента посещения этой страницы, то теперь необходимо сфокусировать внимание на вводе выше. Теперь давайте создадим директиву, которая выполняет это:</target>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">Когда значение &lt;code&gt;data&lt;/code&gt; является объектом, оно совместно используется всеми экземплярами компонента. Представьте себе, например, компонент &lt;code&gt;TodoList&lt;/code&gt; с такими данными:</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">Когда они существуют на одном узле, &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; . Это означает, что &lt;code&gt;v-if&lt;/code&gt; будет запускаться на каждой итерации цикла отдельно. Это может быть полезно, когда вы хотите визуализировать узлы только для &lt;em&gt;некоторых&lt;/em&gt; элементов, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">Когда эти данные изменятся, представление будет повторно визуализировано. Следует отметить, что свойства &lt;code&gt;data&lt;/code&gt; являются &lt;strong&gt;реактивными&lt;/strong&gt; только в том случае, если они существовали при создании экземпляра. Это означает, что если вы добавите новое свойство, например:</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">При многократном вызове этого метода на одном и том же плагине,плагин будет установлен только один раз.</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">При переключении между элементами, имеющими &lt;strong&gt;одинаковое имя тега&lt;/strong&gt; , вы должны сообщить Vue, что они являются разными элементами, дав им уникальные &lt;code&gt;key&lt;/code&gt; атрибуты. В противном случае компилятор Vue заменит только содержимое элемента для повышения эффективности. Однако даже в тех случаях, когда это технически необязательно, &lt;strong&gt;считается хорошей практикой всегда использовать несколько элементов в компоненте &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">При использовании для крепления реквизита,реквизит должен быть надлежащим образом декларирован в детском компоненте.</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">При использовании в компоненте &lt;code&gt;v-model&lt;/code&gt; вместо этого делает следующее:</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">При использовании в компоненте &lt;code&gt;v-on&lt;/code&gt; теперь слушает только пользовательские события &lt;code&gt;$emit&lt;/code&gt; генерируемые этим компонентом. Чтобы прослушивать собственное событие DOM в корневом элементе, вы можете использовать модификатор &lt;code&gt;.native&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">При использовании с обычным элементом он слушает только &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;собственные события DOM&lt;/strong&gt;&lt;/a&gt; . При использовании в компоненте настраиваемого элемента он прослушивает &lt;strong&gt;настраиваемые события,&lt;/strong&gt; генерируемые этим дочерним компонентом.</target>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">При использовании с элементами / компонентами с &lt;code&gt;v-for&lt;/code&gt; , зарегистрированная ссылка будет массивом, содержащим узлы DOM или экземпляры компонентов.</target>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">При использовании для привязки атрибута &lt;code&gt;class&lt;/code&gt; или &lt;code&gt;style&lt;/code&gt; он поддерживает дополнительные типы значений, такие как массив или объекты. Дополнительную информацию см. В разделе связанного руководства ниже.</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">При использовании вместе с &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; не забудьте вложить его внутрь:</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;v-if&lt;/code&gt; , &lt;code&gt;v-for&lt;/code&gt; имеет более высокий приоритет, чем &lt;code&gt;v-if&lt;/code&gt; . Подробности см. В &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;руководстве&lt;/a&gt; по отображению списка .</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">При использовании вместе с v-if, v-for имеет более высокий приоритет, чем v-if. Подробности см. В &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;руководстве&lt;/a&gt; по отображению списка .</target>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">При использовании с &lt;code&gt;v-bind&lt;/code&gt; теперь единственными ложными значениями являются: &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; . Это означает, что &lt;code&gt;0&lt;/code&gt; и пустые строки будут отображаться как правдивые. Так, например, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; будет отображаться как &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">При использовании без аргумента может использоваться для привязки объекта, содержащего пары имя-значение атрибута. Обратите внимание, что в этом режиме &lt;code&gt;class&lt;/code&gt; и &lt;code&gt;style&lt;/code&gt; не поддерживают массив или объекты.</target>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">При использовании &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;локальной регистрации&lt;/a&gt; вы также можете напрямую предоставить функцию, которая возвращает &lt;code&gt;Promise&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">При использовании &lt;code&gt;vue-loader&lt;/code&gt; или &lt;code&gt;vueify&lt;/code&gt; шаблоны внутри файлов &lt;code&gt;*.vue&lt;/code&gt; предварительно компилируются в JavaScript во время сборки. Вам действительно не нужен компилятор в окончательном комплекте, и поэтому вы можете использовать сборку только во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">При использовании JavaScript-только переходов, &lt;strong&gt;то &lt;code&gt;done&lt;/code&gt; обратных вызовы необходимы для &lt;code&gt;enter&lt;/code&gt; и &lt;code&gt;leave&lt;/code&gt; крючков&lt;/strong&gt; . В противном случае хуки будут вызываться синхронно, и переход завершится немедленно.</target>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">При использовании однофайловых компонентов внутренние компоненты CSS вводятся динамически как теги &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; через JavaScript. Это требует небольших затрат времени выполнения, и если вы используете рендеринг на стороне сервера, это вызовет &amp;laquo;мигание нестилизованного содержимого&amp;raquo;. Извлечение CSS из всех компонентов в один и тот же файл позволит избежать этих проблем, а также улучшит минификацию и кеширование CSS.</target>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">При использовании Vue мы рекомендуем также установить &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; в вашем браузере, что позволит вам проверять и отлаживать свои приложения Vue в более удобном интерфейсе.</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">При использовании таких инструментов сборки, как Webpack или Browserify, рабочий режим будет определяться параметром &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; внутри исходного кода Vue, и по умолчанию он будет находиться в режиме разработки. Оба инструмента сборки предоставляют способы перезаписать эту переменную, чтобы включить рабочий режим Vue, а предупреждения будут удалены минификаторами во время сборки. Все шаблоны &lt;code&gt;vue-cli&lt;/code&gt; предварительно настроены для вас, но было бы полезно знать, как это делается:</target>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">При использовании шаблонов in-DOM (шаблонов,непосредственно написанных в HTML-файле)также следует избегать именования ключей прописными символами,так как браузеры будут заставлять имена атрибутов записывать в нижний регистр:</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">При использовании шаблонов in-DOM или строк шаблонов в JavaScript компиляция функции &quot;Шаблоны на возврат&quot; выполняется &quot;на лету&quot;.Обычно в большинстве случаев это происходит достаточно быстро,но этого лучше всего избегать,если ваше приложение чувствительно к производительности.</target>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">При использовании свойства &lt;code&gt;data&lt;/code&gt; в компоненте (то есть где угодно, кроме &lt;code&gt;new Vue&lt;/code&gt; ) значение должно быть функцией, возвращающей объект.</target>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">Когда мы нажимаем на кнопку, нам нужно сообщить родителю, что он должен увеличить текст всех сообщений. К счастью, экземпляры Vue предоставляют настраиваемую систему событий для решения этой проблемы. Родитель может выбрать прослушивание любого события в экземпляре дочернего компонента с помощью &lt;code&gt;v-on&lt;/code&gt; , так же, как мы это сделали бы с собственным событием DOM:</target>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">Когда мы определили компонент &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; , вы могли заметить, что &lt;code&gt;data&lt;/code&gt; не были напрямую предоставлены объектом, например:</target>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">При наложении на динамический компонент &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; кэширует экземпляры неактивных компонентов, не уничтожая их. Подобно &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; является абстрактным компонентом: он не отображает сам элемент DOM и не отображается в родительской цепочке компонента.</target>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Когда вы создаете экземпляр Vue, вы передаете &lt;strong&gt;объект параметров&lt;/strong&gt; . Большая часть этого руководства описывает, как вы можете использовать эти параметры для создания желаемого поведения. Для справки вы также можете просмотреть полный список параметров в &lt;a href=&quot;../api/index#Options-Data&quot;&gt;справочнике&lt;/a&gt; по API .</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">Когда вы напрямую устанавливаете элемент с индексом, например &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">Когда вы начинаете работу с компонентом, который генерирует только заголовок на основе свойства &lt;code&gt;level&lt;/code&gt; , вы быстро приходите к следующему:</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">Присмотревшись, вы увидите, что эти компоненты на самом деле будут потомками &lt;em&gt;и&lt;/em&gt; предками друг друга в дереве рендеринга - парадокс! При глобальной регистрации компонентов с помощью &lt;code&gt;Vue.component&lt;/code&gt; этот парадокс разрешается автоматически. Если это ты, можешь перестать читать здесь.</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">Когда вы изменяете длину массива, например &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">Когда вы передаете простой объект JavaScript экземпляру Vue в качестве параметра &lt;code&gt;data&lt;/code&gt; , Vue просматривает все его свойства и преобразует их в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt; / установки&lt;/a&gt; с помощью Object.defineProperty . Это функция, предназначенная только для ES5 и не имеющая шиммирования, поэтому Vue не поддерживает IE8 и ниже.</target>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">Когда вы регистрируете компонент глобально с помощью &lt;code&gt;Vue.component&lt;/code&gt; , глобальный идентификатор автоматически устанавливается в качестве опции &lt;code&gt;name&lt;/code&gt; компонента .</target>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">Когда вы обновляете номер, изменение анимируется под полем ввода. Это хорошая демонстрация, но как насчет того, что не хранится напрямую как число, например, любого допустимого цвета CSS? Вот как этого добиться с помощью &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; и &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">Когда вы используете свойство CSS, которое требует &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;префиксов поставщика&lt;/a&gt; в &lt;code&gt;v-bind:style&lt;/code&gt; , например, &lt;code&gt;transform&lt;/code&gt; , Vue автоматически обнаружит и добавит соответствующие префиксы к применяемым стилям.</target>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">Когда вы используете атрибут &lt;code&gt;class&lt;/code&gt; в пользовательском компоненте, эти классы будут добавлены к корневому элементу компонента. Существующие классы этого элемента не будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">Когда вы хотите использовать данные внутри слота,например in:</target>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">Когда есть несколько слотов, используйте полный синтаксис на основе &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; для &lt;em&gt;всех&lt;/em&gt; слотов:</target>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">Если существует несколько одинаково хороших вариантов, можно сделать произвольный выбор для обеспечения согласованности. В этих правилах мы описываем каждый приемлемый вариант и предлагаем вариант по умолчанию. Это означает, что вы можете свободно делать другой выбор в своей собственной кодовой базе, если вы последовательны и имеете веские основания. Пожалуйста, имейте вескую причину! Адаптируясь к общественному стандарту, вы:</target>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">С чего мне начать в миграции?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">Везде, где что-то может быть легко выполнено с помощью простого JavaScript, функции рендеринга Vue не предоставляют проприетарной альтернативы. Например, в шаблоне с использованием &lt;code&gt;v-if&lt;/code&gt; и &lt;code&gt;v-for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">Работает ли текущий экземпляр Vue на сервере.</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">Который может быть использован в шаблоне для контроля размера шрифта всех сообщений блога:</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">Который также может быть написан как:</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">Что может сделать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">Какие устаревшие функции вы используете. Большинство из них можно обновить с помощью функции &quot;найти и заменить&quot;, но другие могут занять несколько минут. Если вы в настоящее время не следуете лучшим практикам, Vue 2.0 также постарается вас заставить. В долгосрочной перспективе это хорошо, но также может означать значительный (хотя, возможно, запоздалый) рефакторинг.</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">Который окажет:</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">Хотя Vue масштабируется так же хорошо, как и React, он также масштабируется так же хорошо, как jQuery. Правильно - для начала все, что вам нужно сделать, это добавить на страницу один тег скрипта:</target>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">Хотя значения атрибутов без пробелов не обязательно должны заключаться в кавычки в HTML, эта практика часто приводит к тому, &lt;em&gt;что&lt;/em&gt; пробелы не используются, что делает значения атрибутов менее читаемыми.</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">Хотя вычисляемые свойства более подходят в большинстве случаев, бывают случаи, когда требуется настраиваемый наблюдатель. Вот почему Vue предоставляет более общий способ реагировать на изменения данных с помощью опции &lt;code&gt;watch&lt;/code&gt; . Это наиболее полезно, когда вы хотите выполнять асинхронные или дорогостоящие операции в ответ на изменение данных.</target>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">Хотя явно определенные свойства предпочтительнее для передачи информации дочернему компоненту, авторы библиотек компонентов не всегда могут предвидеть контексты, в которых могут использоваться их компоненты. Вот почему компоненты могут принимать произвольные атрибуты, которые добавляются к корневому элементу компонента.</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">Хотя шаблоны отлично подходят для большинства компонентов, ясно, что это не один из них. Итак, давайте попробуем переписать его с помощью функции &lt;code&gt;render&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">Почему слушатели в HTML?</target>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">Зачем нам кеширование? Представьте, что у нас есть дорогостоящее вычисляемое свойство &lt;strong&gt;A&lt;/strong&gt; , которое требует перебора огромного массива Array и выполнения большого количества вычислений. Тогда мы можем иметь другие вычисляемые свойства , которые в свою очередь зависят от &lt;strong&gt;А&lt;/strong&gt; . Без кеширования мы бы выполняли получатель &lt;strong&gt;A&lt;/strong&gt; гораздо больше раз, чем необходимо! В случаях, когда вам не нужно кеширование, используйте вместо этого метод.</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">будет эквивалентно:</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">Будет оцениваться аналогично:</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">Вместо этого будет определено с:</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">В результате:</target>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">С компонентами &lt;code&gt;.vue&lt;/code&gt; мы входим в область передовых приложений JavaScript. Это означает научиться пользоваться несколькими дополнительными инструментами, если вы еще не сделали этого:</target>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">С помощью &lt;code&gt;inheritAttrs: false&lt;/code&gt; и &lt;code&gt;$attrs&lt;/code&gt; вы можете вручную решить, в какой элемент вы хотите пересылать атрибуты, что часто желательно для &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;базовых компонентов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">Со строительными инструментами</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">С компонентами</target>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">В символах ES2015 функция &lt;code&gt;provide&lt;/code&gt; и &lt;code&gt;inject&lt;/code&gt; объект :</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">С MobX</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">С синтаксисом,основанным на объектах,вы можете использовать следующие опции:</target>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">С PascalCase</target>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">С кебабом</target>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">Добавив один атрибут, мы исправили исходный переход, не добавляя никаких специальных стилей.</target>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">С учетом сказанного, сравнение неизбежно покажется некоторым пользователям React смещенным в сторону Vue, поскольку многие из исследуемых тем в некоторой степени субъективны. Мы признаем существование различных технических предпочтений, и это сравнение в первую очередь направлено на то, чтобы очертить причины, по которым Vue потенциально может быть более подходящим, если ваши предпочтения совпадают с нашими.</target>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">С новой системой переходов теперь вы можете &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;использовать компоненты для многоразовых переходов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">С этими знаниями мы теперь можем закончить начатый нами компонент:</target>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">В дочерних компонентах мы можем использовать любую комбинацию стратегий перехода, описанных на этой странице, наряду со стратегиями, предлагаемыми &lt;a href=&quot;transitions&quot;&gt;встроенной системой перехода&lt;/a&gt; Vue . Вместе есть очень мало пределов того, что может быть достигнуто.</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">Без строительных инструментов</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">Вау - это супер длинная страница! Означает ли это, что версия 2.0 совершенно другая, мне придется заново изучать основы и миграция будет практически невозможна?</target>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">Пишите настраиваемые компоненты</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">Написание плагина</target>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">Да, даже переходы во Vue управляются данными! Самый простой пример динамического перехода связывает атрибут &lt;code&gt;name&lt;/code&gt; с динамическим свойством.</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">На самом деле вам больше не нужно отлаживать, поскольку Vue автоматически форматирует вывод, будь то строка, число, массив или простой объект. Если вам нужна точно такая же функциональность, что и у JavaScript &lt;code&gt;JSON.stringify&lt;/code&gt; , вы можете использовать это в методе или вычисляемом свойстве.</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">Вы вынуждены быть более явным,давая вашему вынужденному значение имя,которое отличает его от значения,переданного в опоре.</target>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вы можете получить доступ к статическому содержимому слота в виде массивов виртуальных узлов из &lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt; Slots :</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">Вы также можете &lt;a href=&quot;../api/index#keyCodes&quot;&gt;определить пользовательские псевдонимы модификаторов клавиш&lt;/a&gt; через глобальный объект &lt;code&gt;config.keyCodes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">Вы также можете применить миксин глобально. Используйте с осторожностью! Как только вы примените миксин глобально, он повлияет на &lt;strong&gt;каждый&lt;/strong&gt; созданный впоследствии экземпляр Vue. При правильном использовании это можно использовать для внедрения логики обработки для настраиваемых параметров:</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">Вы также можете объявить дополнительные глобальные свойства и параметры компонентов:</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">Вы также можете определить JavaScript хуки в атрибутах:</target>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">Вы также можете выполнять одноразовые интерполяции, которые не обновляются при изменении данных, с помощью &lt;a href=&quot;../api/index#v-once&quot;&gt;директивы v-once&lt;/a&gt; , но имейте в виду, что это также повлияет на любые другие привязки на том же узле:</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">Вы также можете указать второй аргумент для имени свойства (он же ключ):</target>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">Вы также можете вернуть &lt;code&gt;Promise&lt;/code&gt; в заводской функции, поэтому с синтаксисом Webpack 2 и ES2015 вы можете:</target>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">Вы также можете указать пользовательские переходные классы,предоставив следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">Вы также можете указать отдельные значения для продолжительности входа и выхода:</target>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;of&lt;/code&gt; качестве разделителя вместо &lt;code&gt;in&lt;/code&gt; , чтобы он был ближе к синтаксису JavaScript для итераторов:</target>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;v-for&lt;/code&gt; для перебора свойств объекта.</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt; , который является псевдонимом для глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;code&gt;vm.$set&lt;/code&gt; , который является псевдонимом для глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать метод экземпляра &lt;code&gt;vm.$set&lt;/code&gt; , который является псевдонимом глобального &lt;code&gt;Vue.set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">Вы можете утверждать его вывод рендеринга с помощью разных &lt;code&gt;propsData&lt;/code&gt; используя параметр propsData :</target>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">Вы можете просмотреть исходный код пакета NPM по адресу &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">Вы можете привязать данные к вычисляемым свойствам в шаблонах, как обычное свойство. Vue знает, что &lt;code&gt;vm.reversedMessage&lt;/code&gt; зависит от &lt;code&gt;vm.message&lt;/code&gt; , поэтому он будет обновлять любые привязки, которые зависят от &lt;code&gt;vm.reversedMessage&lt;/code&gt; , при изменении &lt;code&gt;vm.message&lt;/code&gt; . И самое приятное то, что мы создали это отношение зависимости декларативно: вычисляемая функция получения не имеет побочных эффектов, что упрощает тестирование и понимание.</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">Вы можете определить локальные фильтры в параметрах компонента:</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">Вы определенно можете включить эти соединительные слова в названия компонентов, если хотите, но порядок по-прежнему важен.</target>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">Вы можете напрямую использовать &lt;code&gt;v-for&lt;/code&gt; в пользовательском компоненте, как и любой обычный элемент:</target>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">Вы можете напрямую использовать любые допустимые имена клавиш, представленные через &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; ,в&lt;/a&gt; качестве модификаторов, преобразовав их в kebab-case.</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">Вы даже можете определить откаты,которые будут использоваться в случае,если слот реквизит не определен:</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">Вы даже можете заказать по нескольким столбцам:</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Вы даже можете использовать препроцессоры,такие как Pug (ранее известный как Jade),для создания шаблонов Vue.</target>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">Вы можете переключать несколько классов, если в объекте будет больше полей. Кроме того, директива &lt;code&gt;v-bind:class&lt;/code&gt; также может сосуществовать с атрибутом plain &lt;code&gt;class&lt;/code&gt; . Итак, учитывая следующий шаблон:</target>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">Вы можете использовать возможности полноценного языка программирования (JavaScript)для построения своего вида.Сюда входят временные переменные,средства управления потоком и прямые ссылки на значения JavaScript в области видимости.</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">Вы можете изменить состояние компонентов в этом крючке.Однако,важно,чтобы в вашем шаблоне были условия или функция рендеринга,которая замыкает другое содержимое,когда была перехвачена ошибка;в противном случае компонент будет брошен в бесконечный цикл рендеринга.</target>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">Вы можете открыть консоль и самостоятельно поиграть с примером vm. Значение &lt;code&gt;vm.reversedMessage&lt;/code&gt; всегда зависит от значения &lt;code&gt;vm.message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">Вы можете открыть консоль и поиграть с массивом &lt;code&gt;items&lt;/code&gt; из предыдущих примеров , вызвав их методы мутации. Например: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">По желанию вы можете пройти некоторые опции:</target>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">Ты можешь заменить его:</target>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть другие рекомендации по именам компонентов в &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Руководстве&lt;/a&gt; по стилю .</target>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">Вы можете увидеть &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;полный пример здесь&lt;/a&gt; . Преимущество перед использованием &lt;code&gt;$parent&lt;/code&gt; заключается в том, что мы можем получить доступ к &lt;code&gt;getMap&lt;/code&gt; в &lt;em&gt;любом &lt;/em&gt;дочернем компоненте, не открывая весь экземпляр &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; . Это позволяет нам более безопасно продолжать разработку этого компонента, не опасаясь, что мы можем изменить / удалить что-то, на что полагается дочерний компонент. Интерфейс между этими компонентами остается четко определенным, как и в случае с &lt;code&gt;props&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать директиву &lt;code&gt;v-else&lt;/code&gt; , чтобы указать &amp;laquo;блок else&amp;raquo; для &lt;code&gt;v-if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">Вы можете использовать директиву &lt;code&gt;v-model&lt;/code&gt; для создания двусторонних привязок данных для ввода формы, текстового поля и элементов выбора. Он автоматически выбирает правильный способ обновления элемента в зависимости от типа ввода. Хотя это немного волшебно, &lt;code&gt;v-model&lt;/code&gt; по сути, является синтаксическим сахаром для обновления данных о событиях ввода пользователя, плюс особая осторожность в некоторых крайних случаях.</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">Вы можете использовать следующие модификаторы для запуска слушателей событий мыши или клавиатуры только при нажатии соответствующей клавиши-модификатора:</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">Ты можешь использовать:</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">Вы можете добавить новое свойство &lt;code&gt;age&lt;/code&gt; во вложенный объект &lt;code&gt;userProfile&lt;/code&gt; с помощью:</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">Вы можете решить обе проблемы с программным слушателем:</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">Тебе бы не помешало:</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">Ты можешь писать:</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">Вам не нужно делать ничего особенного в ваших компонентах, чтобы сделать их тестируемыми. Экспортируйте исходные параметры:</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">У вас есть два варианта при определении имен компонентов:</target>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Возможно, вам будет интересно узнать, что шаблоны Vue на самом деле компилируются для рендеринга функций. Это деталь реализации, о которой обычно не нужно знать, но если вы хотите увидеть, как компилируются определенные функции шаблона, это может показаться вам интересным. Ниже приведена небольшая демонстрация использования &lt;code&gt;Vue.compile&lt;/code&gt; для живой компиляции строки шаблона:</target>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">Вам может быть интересно:</target>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Вы могли заметить, что компоненты Vue очень похожи на &lt;strong&gt;настраиваемые элементы&lt;/strong&gt; , которые являются частью &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;спецификации веб-компонентов&lt;/a&gt; . Это потому, что синтаксис компонентов Vue в общих чертах смоделирован после спецификации. Например, компоненты Vue реализуют &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; и специальный атрибут &lt;code&gt;is&lt;/code&gt; . Однако есть несколько ключевых отличий:</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">Вы,возможно,заметили,что мы можем достичь того же результата,используя метод в выражении:</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">Возможно, вы не учли предостережения об обнаружении изменений &lt;a href=&quot;list#Caveats&quot;&gt;с массивами&lt;/a&gt; или &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;объектами&lt;/a&gt; , или вы можете полагаться на состояние, которое не отслеживается системой реактивности Vue, например, с &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">Вы можете это заметить:</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">Вы можете спросить, зачем нам и &lt;code&gt;slots()&lt;/code&gt; и &lt;code&gt;children&lt;/code&gt; . Разве &lt;code&gt;slots().default&lt;/code&gt; будут такими же, как &lt;code&gt;children&lt;/code&gt; ? В некоторых случаях да - но что, если у вас есть функциональный компонент со следующими дочерними элементами?</target>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">Вы можете быть обеспокоены тем, что весь этот подход к прослушиванию событий нарушает старые добрые правила &amp;laquo;разделения ответственности&amp;raquo;. Будьте уверены - поскольку все функции и выражения обработчика Vue строго привязаны к ViewModel, который обрабатывает текущее представление, это не вызовет каких-либо трудностей с обслуживанием. Фактически, использование &lt;code&gt;v-on&lt;/code&gt; дает несколько преимуществ :</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">Возможно,у вас возникнет соблазн решить эту проблему,вложив дочерние компоненты в каталоги,названные в честь их родителей.Например:</target>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">У вас может возникнуть соблазн решить эту проблему по-другому, вложив все компоненты поиска в каталог &amp;laquo;search&amp;raquo;, а затем все компоненты настроек в каталог &amp;laquo;settings&amp;raquo;. Мы рекомендуем рассматривать этот подход только в очень больших приложениях (например, более 100 компонентов) по следующим причинам:</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">Вы можете подумать,что это заставит Vue выбросить существующий DOM и перемотать весь список-к счастью,это не так.Vue реализует некоторые умные эвристики для максимизации повторного использования DOM-элементов,поэтому замена массива на другой массив,содержащий перекрывающиеся объекты,является очень эффективной операцией.</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">Обычно вам не нужно их использовать, но они доступны в случаях, когда вам нужно вручную прослушивать события в экземпляре компонента. Они также могут быть полезны как инструмент организации кода. Например, вы часто можете увидеть этот шаблон для интеграции сторонней библиотеки:</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">Вы передаете свойство маршрутизатора экземпляру Vue:</target>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">Вы должны убедиться, что ваше начальное значение для &lt;code&gt;text&lt;/code&gt; - &amp;laquo;привет, мир&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">Вы все еще имеете доступ к исходному значению реквизита.</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">Вы бы добавили новые,реактивные свойства с:</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">Теперь ты будешь писать:</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">Тебе бы пригодилось:</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">Вам нужно будет обновить его так:</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">Вы заметите , что если вы выбираете запись, переключатель в &lt;em&gt;архиве&lt;/em&gt; вкладку, а затем переключиться обратно на &lt;em&gt;сообщения&lt;/em&gt; , он больше не показывает выбранную запись. Это потому, что каждый раз, когда вы переключаетесь на новую вкладку, Vue создает новый экземпляр &lt;code&gt;currentTabComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">Позже вы увидите другие примеры модификаторов &lt;a href=&quot;events#Event-Modifiers&quot;&gt;для &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;forms#Modifiers&quot;&gt;для &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt; , когда мы исследуем эти функции.</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">Вы также видели реквизиты, динамически назначаемые с помощью &lt;code&gt;v-bind&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">Ваш встраиваемый шаблон должен быть определен внутри DOM-элемента,к которому прикреплена Vue.</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">Ваш x-шаблон должен быть определен вне DOM-элемента,к которому прикреплен Vue.</target>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[] Синтаксис для массивов в запросах &lt;sup&gt;удален.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">объект параметров компонента</target>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">расчётное имущество</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">свойство данных,с помощью реквизита,используемого для установки его значения по умолчанию</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">массив строк,или</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">объект,где ключами являются локальное имя привязки,а значением-либо то,либо другое:</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">объект,где:</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">компоненты-предки не должны знать, какие потомки используют предоставляемые им свойства</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">и пользовательские JavaScript-крючки:</target>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">автоматически применять классы для CSS-переходов и анимации</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">подкрепленные этими данными:</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">иметь возможность копировать и вставлять большинство примеров кода сообщества без модификации</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">флажки и радиокнопки используют свойство &lt;code&gt;checked&lt;/code&gt; и событие &lt;code&gt;change&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">отображаемые цвета</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">дочерним компонентам не нужно знать, откуда берутся внедренные свойства</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">делает то же самое:</target>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">предоставляет те же события, что и &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">предоставляет те же свойства, что и &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; за исключением &lt;code&gt;mode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">полностью поддерживает как Vue 1.0,так и 2.0.</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">в 2.6.0+. См. &lt;a href=&quot;#Named-Slots&quot;&gt;Здесь&lt;/a&gt; новый рекомендуемый синтаксис.</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">в 2.6.0+. См. &lt;a href=&quot;#Scoped-Slots&quot;&gt;Здесь&lt;/a&gt; новый рекомендуемый синтаксис.</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">интегрировать сторонние CSS-анимационные библиотеки,такие как Animate.css.</target>
        </trans-unit>
        <trans-unit id="640a88fb22096bdf6bd9b9dad17ad19528e33c74" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</source>
          <target state="translated">интегрировать сторонние анимационные библиотеки JavaScript,такие как Velocity.js.</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="6ac4338bb79ac3c4906ce72bafa4a59d6e305be8" translate="yes" xml:space="preserve">
          <source>keep-alive</source>
          <target state="translated">keep-alive</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="1a12478dec83ed6e780245cdd0f96617dd7741bb" translate="yes" xml:space="preserve">
          <source>keyCodes</source>
          <target state="translated">keyCodes</target>
        </trans-unit>
        <trans-unit id="d1f56baedcca5a5064e2a4af53cc11a0ed1c0853" translate="yes" xml:space="preserve">
          <source>maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries</source>
          <target state="translated">поддерживать фокус в основной библиотеке,при этом такие вопросы,как маршрутизация и глобальное управление состоянием,решаются библиотеками-компаньонами.</target>
        </trans-unit>
        <trans-unit id="b85dac7f646475d4018a5c35390352f94773c821" translate="yes" xml:space="preserve">
          <source>methods</source>
          <target state="translated">methods</target>
        </trans-unit>
        <trans-unit id="759733aacfdf4712b7e0071157fe636694093bf6" translate="yes" xml:space="preserve">
          <source>mixins</source>
          <target state="translated">mixins</target>
        </trans-unit>
        <trans-unit id="1d06a0d76f000e6edd18de492383983feefced4e" translate="yes" xml:space="preserve">
          <source>model</source>
          <target state="translated">model</target>
        </trans-unit>
        <trans-unit id="ce7af53b728aacb666b36f215a21ab0dd6a5bce4" translate="yes" xml:space="preserve">
          <source>mounted</source>
          <target state="translated">mounted</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="efa63f31b95d88d80597fd77df60f57d92b5656c" translate="yes" xml:space="preserve">
          <source>numbers and calculations</source>
          <target state="translated">числа и расчёты</target>
        </trans-unit>
        <trans-unit id="c4f9f9085b98cae6ac4e1ed2d080effcc14c1a1b" translate="yes" xml:space="preserve">
          <source>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</source>
          <target state="translated">часто находят новых сотрудников,уже привыкших к предпочитаемому вами стилю кодирования,по крайней мере,в отношении Vue</target>
        </trans-unit>
        <trans-unit id="06dc8f8ac9432bbb240e210daed5bff3b05abccb" translate="yes" xml:space="preserve">
          <source>optionMergeStrategies</source>
          <target state="translated">optionMergeStrategies</target>
        </trans-unit>
        <trans-unit id="5460c4665adcba7eae90a69c7fa5c8c721706518" translate="yes" xml:space="preserve">
          <source>or define a filter globally before creating the Vue instance:</source>
          <target state="translated">или определить фильтр глобально перед созданием экземпляра Vue:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="274a7e4ebee8f7f6dc6992677f3c27d94a3001cb" translate="yes" xml:space="preserve">
          <source>other base components, and</source>
          <target state="translated">другие базовые компоненты,и</target>
        </trans-unit>
        <trans-unit id="d8fd39d0bbdd2dcf322d8b11390a4c5825b11495" translate="yes" xml:space="preserve">
          <source>parent</source>
          <target state="translated">parent</target>
        </trans-unit>
        <trans-unit id="476ee0f6af1d78aa2a3d9a587e8d5ee7e31229f6" translate="yes" xml:space="preserve">
          <source>performance</source>
          <target state="translated">performance</target>
        </trans-unit>
        <trans-unit id="901b0f26761a219ec847f2e563ee7d645ffb0fe8" translate="yes" xml:space="preserve">
          <source>productionTip</source>
          <target state="translated">productionTip</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="9b653d2097967639889ca93223335f45baa750ff" translate="yes" xml:space="preserve">
          <source>propsData</source>
          <target state="translated">propsData</target>
        </trans-unit>
        <trans-unit id="009ec702007827315f19dc796c2a231a2e05c4dc" translate="yes" xml:space="preserve">
          <source>provide / inject</source>
          <target state="translated">обеспечить/впрыснуть</target>
        </trans-unit>
        <trans-unit id="559d8d669c33e3c83eb857ddab7a7179a755573e" translate="yes" xml:space="preserve">
          <source>provide reactive and composable view components</source>
          <target state="translated">обеспечивают реактивные и композитные обзорные компоненты</target>
        </trans-unit>
        <trans-unit id="69449f994d55805535b9e8fab16f6c39934e9ba4" translate="yes" xml:space="preserve">
          <source>ref</source>
          <target state="translated">ref</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="a0a5278a6cefc309b63b0c4c5fd7593743828a31" translate="yes" xml:space="preserve">
          <source>renderError</source>
          <target state="translated">renderError</target>
        </trans-unit>
        <trans-unit id="ceb562ce431745788c5bafaa3720a09b81bd457a" translate="yes" xml:space="preserve">
          <source>scope &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">сфера &lt;sup&gt;удалена&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0e973bd3838898bd325ed8ba837f26d730a7ed56" translate="yes" xml:space="preserve">
          <source>scope removed</source>
          <target state="translated">удалённая область</target>
        </trans-unit>
        <trans-unit id="2a788a1972f648a6486eea37112a19c4fd342950" translate="yes" xml:space="preserve">
          <source>select fields use &lt;code&gt;value&lt;/code&gt; as a prop and &lt;code&gt;change&lt;/code&gt; as an event.</source>
          <target state="translated">поля выбора используют &lt;code&gt;value&lt;/code&gt; как опору и &lt;code&gt;change&lt;/code&gt; как событие.</target>
        </trans-unit>
        <trans-unit id="b32285bf14101379e596fd61f24637951f17e78f" translate="yes" xml:space="preserve">
          <source>silent</source>
          <target state="translated">silent</target>
        </trans-unit>
        <trans-unit id="462854f9c73adf5f5d5c411adb6b929ecc19693a" translate="yes" xml:space="preserve">
          <source>slot</source>
          <target state="translated">slot</target>
        </trans-unit>
        <trans-unit id="d3ccd068b20d8bc8c899d2419acc4756a32eabf3" translate="yes" xml:space="preserve">
          <source>slot &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">слот &lt;sup&gt;устарел&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ac938ccaaee0471d9ba1ad826420fb07fe19599" translate="yes" xml:space="preserve">
          <source>slot deprecated</source>
          <target state="translated">устаревший</target>
        </trans-unit>
        <trans-unit id="9705201399b16c1d9892866519b1fde59ee14c4d" translate="yes" xml:space="preserve">
          <source>slot-scope &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">область слота &lt;sup&gt;устарела&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="70251443cfbe27230429f393dbeeabf3a5a1141c" translate="yes" xml:space="preserve">
          <source>slot-scope deprecated</source>
          <target state="translated">устаревший щелевойскоп</target>
        </trans-unit>
        <trans-unit id="3226ecbe650213a49cd03ae67140750e4f340083" translate="yes" xml:space="preserve">
          <source>template</source>
          <target state="translated">template</target>
        </trans-unit>
        <trans-unit id="77bc0357bd1e93d68d50895d6a8281eb11026db0" translate="yes" xml:space="preserve">
          <source>text and textarea elements use &lt;code&gt;value&lt;/code&gt; property and &lt;code&gt;input&lt;/code&gt; event;</source>
          <target state="translated">элементы text и textarea используют свойство &lt;code&gt;value&lt;/code&gt; и событие &lt;code&gt;input&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="26d762e47535d9d6a0e3b1ec719e818e5029f523" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;default&lt;/code&gt; property is used as fallback value</source>
          <target state="translated">свойство по &lt;code&gt;default&lt;/code&gt; используется как резервное значение</target>
        </trans-unit>
        <trans-unit id="025b0f9e93dda2558b27a2297f4ef94cbbc066a0" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;from&lt;/code&gt; property is the key (string or Symbol) to search for in available injections, and</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; собственности ключа (строка или символ) для поиска в доступных инъекциях, и</target>
        </trans-unit>
        <trans-unit id="cad1b9675290b91d92988abdefef24cfeea2451c" translate="yes" xml:space="preserve">
          <source>the custom element name to use in the template, and</source>
          <target state="translated">имя пользовательского элемента для использования в шаблоне,и</target>
        </trans-unit>
        <trans-unit id="b70d4d793e7c9fcdde8b56387ec8f9f5324536a6" translate="yes" xml:space="preserve">
          <source>the key (string or Symbol) to search for in available injections, or</source>
          <target state="translated">ключ (строка или символ)для поиска в доступных инъекциях,или</target>
        </trans-unit>
        <trans-unit id="771279a0962f67af2fa5fac029cdf6d9cedebe88" translate="yes" xml:space="preserve">
          <source>the name of a registered component, or</source>
          <target state="translated">название зарегистрированного компонента,или</target>
        </trans-unit>
        <trans-unit id="ab4b389f6b8b2c135e895d4f7ee4d31afb1a7b7b" translate="yes" xml:space="preserve">
          <source>the name of the variable containing the component options</source>
          <target state="translated">имя переменной,содержащей параметры компонента</target>
        </trans-unit>
        <trans-unit id="cb42e295aed62d3d9b5bec47d01a8b0244b984bf" translate="yes" xml:space="preserve">
          <source>the positions of SVG nodes</source>
          <target state="translated">позиции SVG-узлов</target>
        </trans-unit>
        <trans-unit id="412017c454240f4269a3e3d69329a8001d1bc3a8" translate="yes" xml:space="preserve">
          <source>the sizes and other properties of elements</source>
          <target state="translated">размеры и другие свойства элементов</target>
        </trans-unit>
        <trans-unit id="bb128da92e34868c02da7d99c67f861bac948e2f" translate="yes" xml:space="preserve">
          <source>the value of &lt;code&gt;lovingVue&lt;/code&gt; will be passed to the &lt;code&gt;checked&lt;/code&gt; prop. The &lt;code&gt;lovingVue&lt;/code&gt; property will then be updated when &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; emits a &lt;code&gt;change&lt;/code&gt; event with a new value.</source>
          <target state="translated">значение &lt;code&gt;lovingVue&lt;/code&gt; будет передано &lt;code&gt;checked&lt;/code&gt; свойству. Затем свойство &lt;code&gt;lovingVue&lt;/code&gt; будет обновлено, когда &lt;code&gt;&amp;lt;base-checkbox&amp;gt;&lt;/code&gt; испускает событие &lt;code&gt;change&lt;/code&gt; с новым значением.</target>
        </trans-unit>
        <trans-unit id="7a5ae87823ef730b40c73e6882ce9d81869d692b" translate="yes" xml:space="preserve">
          <source>to a definition like below in your &lt;code&gt;routes&lt;/code&gt; configuration:</source>
          <target state="translated">к определению, как показано ниже, в конфигурации ваших &lt;code&gt;routes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a356bc545ab21a71c127b739b139dcbccc68d5e" translate="yes" xml:space="preserve">
          <source>to access the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component may similarly use a &lt;code&gt;ref&lt;/code&gt; to provide access to specific elements inside it, such as:</source>
          <target state="translated">для доступа к экземпляру &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; . Это может быть полезно, если вы хотите, например, программно сфокусировать этот ввод от родителя. В этом случае компонент &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; может аналогичным образом использовать &lt;code&gt;ref&lt;/code&gt; для предоставления доступа к определенным элементам внутри него, например:</target>
        </trans-unit>
        <trans-unit id="8b44c248ec32b071a1a7aafa16b55a17a8feb834" translate="yes" xml:space="preserve">
          <source>to this:</source>
          <target state="translated">к этому:</target>
        </trans-unit>
        <trans-unit id="b624aaa273eeda72c40e568d21fcbbeb5497dae7" translate="yes" xml:space="preserve">
          <source>to validate that the value of the &lt;code&gt;author&lt;/code&gt; prop was created with &lt;code&gt;new Person&lt;/code&gt;.</source>
          <target state="translated">чтобы проверить, что значение свойства &lt;code&gt;author&lt;/code&gt; было создано с помощью &lt;code&gt;new Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1cfdcd865f3b87bcc9595dd395087b084ac080" translate="yes" xml:space="preserve">
          <source>to:</source>
          <target state="translated">to:</target>
        </trans-unit>
        <trans-unit id="4652e1358ea64fd28779917099faee9815f39f5a" translate="yes" xml:space="preserve">
          <source>train your brain to more easily parse most of the community code you encounter</source>
          <target state="translated">научить свой мозг легче разбирать большую часть общественного кода,с которым вы сталкиваетесь.</target>
        </trans-unit>
        <trans-unit id="56bf8ae82a107d348a5ad5b650394e3f79340670" translate="yes" xml:space="preserve">
          <source>transition</source>
          <target state="translated">transition</target>
        </trans-unit>
        <trans-unit id="0346b11d87b24e82ab5c649ad2ca732f998681d6" translate="yes" xml:space="preserve">
          <source>transition-group</source>
          <target state="translated">transition-group</target>
        </trans-unit>
        <trans-unit id="2439417750083132eec5533d66db361a6f33c86c" translate="yes" xml:space="preserve">
          <source>unit tested in isolation from your Vue code</source>
          <target state="translated">устройство,протестированное изолированно от вашего кода Vue</target>
        </trans-unit>
        <trans-unit id="13a1891af75c642306a6b695377d16e4a91f0e1b" translate="yes" xml:space="preserve">
          <source>updated</source>
          <target state="translated">updated</target>
        </trans-unit>
        <trans-unit id="47c1dcbefaa84b21d8f1b4cacb6d96a2389f8d6c" translate="yes" xml:space="preserve">
          <source>use JavaScript to directly manipulate the DOM during transition hooks</source>
          <target state="translated">использовать JavaScript для прямого манипулирования DOM во время переходных крючков</target>
        </trans-unit>
        <trans-unit id="2ffb3e7b8b54e93fa9c9e2c85136cd36872ebac8" translate="yes" xml:space="preserve">
          <source>used by other parts of your application, such as to validate the payload to an API endpoint</source>
          <target state="translated">используется другими частями вашего приложения,например,для проверки полезной нагрузки на конечной точке API</target>
        </trans-unit>
        <trans-unit id="71e87a583e04a8c8e91247ed090ea050ff05d929" translate="yes" xml:space="preserve">
          <source>utilize a virtual DOM</source>
          <target state="translated">использовать виртуальный DOM</target>
        </trans-unit>
        <trans-unit id="121c33ea7d2fbab17fddc40d29520aa060292a3f" translate="yes" xml:space="preserve">
          <source>v-bind</source>
          <target state="translated">v-bind</target>
        </trans-unit>
        <trans-unit id="61446caf9cec66418312b8afce77b95f760c1542" translate="yes" xml:space="preserve">
          <source>v-cloak</source>
          <target state="translated">v-cloak</target>
        </trans-unit>
        <trans-unit id="9211fc21d367807ce01b01aeaa155eceb994ff10" translate="yes" xml:space="preserve">
          <source>v-else</source>
          <target state="translated">v-else</target>
        </trans-unit>
        <trans-unit id="aad798ca5693051aa59b6d5515d414fb382e1b9d" translate="yes" xml:space="preserve">
          <source>v-else-if</source>
          <target state="translated">v-else-if</target>
        </trans-unit>
        <trans-unit id="d8d5f6f2691961dbe62b3963ea44db6840a098b2" translate="yes" xml:space="preserve">
          <source>v-for</source>
          <target state="translated">v-for</target>
        </trans-unit>
        <trans-unit id="1c21399d4bae3d211e796bf024c68edbb55e3bc3" translate="yes" xml:space="preserve">
          <source>v-html</source>
          <target state="translated">v-html</target>
        </trans-unit>
        <trans-unit id="da1ef073ed7cfaabd197c053859f5aa2996547bc" translate="yes" xml:space="preserve">
          <source>v-if</source>
          <target state="translated">v-if</target>
        </trans-unit>
        <trans-unit id="5c02585ece6d24ec42b855e409120cc1caeae510" translate="yes" xml:space="preserve">
          <source>v-if/v-else-if/v-else without key</source>
          <target state="translated">v-if/v-else-if/v-else без ключа</target>
        </trans-unit>
        <trans-unit id="e6aa5be18818de68afb647ef7683640c0ccc6f9b" translate="yes" xml:space="preserve">
          <source>v-model</source>
          <target state="translated">v-model</target>
        </trans-unit>
        <trans-unit id="465db0034f4a4aa82a200f7a5acabc5c6dad8449" translate="yes" xml:space="preserve">
          <source>v-on</source>
          <target state="translated">v-on</target>
        </trans-unit>
        <trans-unit id="fb93d4822889186d62901f1d0c2937ba09afb073" translate="yes" xml:space="preserve">
          <source>v-once</source>
          <target state="translated">v-once</target>
        </trans-unit>
        <trans-unit id="8723014a826e07ee1d36588c6cd2790ee471ba3c" translate="yes" xml:space="preserve">
          <source>v-pre</source>
          <target state="translated">v-pre</target>
        </trans-unit>
        <trans-unit id="54272dd05aa79ca6da35bbefacf8c3d5701dea3b" translate="yes" xml:space="preserve">
          <source>v-show</source>
          <target state="translated">v-show</target>
        </trans-unit>
        <trans-unit id="285a211f0f9d5799f4ec4b2694fc5040a7a120fc" translate="yes" xml:space="preserve">
          <source>v-slot</source>
          <target state="translated">v-slot</target>
        </trans-unit>
        <trans-unit id="a3f5fd55c07ee5fe5da9b61ede51058b6932a8ba" translate="yes" xml:space="preserve">
          <source>v-text</source>
          <target state="translated">v-text</target>
        </trans-unit>
        <trans-unit id="9e8c4326a3e5802b6bd32bdeb38f5ea9b5029432" translate="yes" xml:space="preserve">
          <source>vm.$attrs</source>
          <target state="translated">vm.$attrs</target>
        </trans-unit>
        <trans-unit id="af70cd66d8f463ff0c1b87333de9f7abb083bbcb" translate="yes" xml:space="preserve">
          <source>vm.$children</source>
          <target state="translated">vm.$children</target>
        </trans-unit>
        <trans-unit id="92036bba3d6520305ca4419e64187c8bacb4d53b" translate="yes" xml:space="preserve">
          <source>vm.$data</source>
          <target state="translated">vm.$data</target>
        </trans-unit>
        <trans-unit id="0c6c5f8f8645a9e8953886d60d3d38fc9d7e3813" translate="yes" xml:space="preserve">
          <source>vm.$delete( target, propertyName/index )</source>
          <target state="translated">vm.$delete(target,propertyName/index )</target>
        </trans-unit>
        <trans-unit id="85945dbc9f317e87e1ebe95aacd2d097e0aadd5e" translate="yes" xml:space="preserve">
          <source>vm.$delete()</source>
          <target state="translated">vm.$delete()</target>
        </trans-unit>
        <trans-unit id="494349fee667e22074020faf32a0d4824e463b58" translate="yes" xml:space="preserve">
          <source>vm.$destroy()</source>
          <target state="translated">vm.$destroy()</target>
        </trans-unit>
        <trans-unit id="eb3d8ad0a5a691e540f0cae8b5f4c35c39bed85b" translate="yes" xml:space="preserve">
          <source>vm.$el</source>
          <target state="translated">vm.$el</target>
        </trans-unit>
        <trans-unit id="01e0f31da340e252fe35bb687b3a8604096a8617" translate="yes" xml:space="preserve">
          <source>vm.$emit( eventName, [&amp;hellip;args] )</source>
          <target state="translated">vm. $ emit (eventName, [&amp;hellip; args])</target>
        </trans-unit>
        <trans-unit id="f7a594be4c584e06c7738c18556378cc4dca84e2" translate="yes" xml:space="preserve">
          <source>vm.$emit()</source>
          <target state="translated">vm.$emit()</target>
        </trans-unit>
        <trans-unit id="86a5433d32c4d79baf0873f0e23a3bf1d6a26d26" translate="yes" xml:space="preserve">
          <source>vm.$forceUpdate()</source>
          <target state="translated">vm.$forceUpdate()</target>
        </trans-unit>
        <trans-unit id="0cedbd040ea3774df4b69fa4ae663ee646bab0f3" translate="yes" xml:space="preserve">
          <source>vm.$isServer</source>
          <target state="translated">vm.$isServer</target>
        </trans-unit>
        <trans-unit id="05326313026d4f80968b293f9a29cb767e2674ca" translate="yes" xml:space="preserve">
          <source>vm.$listeners</source>
          <target state="translated">vm.$listeners</target>
        </trans-unit>
        <trans-unit id="baab4fd1f32671646717fa9dc37e706a4aa9fc7d" translate="yes" xml:space="preserve">
          <source>vm.$mount( [elementOrSelector] )</source>
          <target state="translated">vm.$mount([elementOrSelector])</target>
        </trans-unit>
        <trans-unit id="57b0780f274178234dca2bf0f994ee7dfc389a4e" translate="yes" xml:space="preserve">
          <source>vm.$mount()</source>
          <target state="translated">vm.$mount()</target>
        </trans-unit>
        <trans-unit id="5c40836793cc9b36ae1e44c2bf0c9d0973b1cb62" translate="yes" xml:space="preserve">
          <source>vm.$nextTick( [callback] )</source>
          <target state="translated">vm.$nextTick([обратный звонок])</target>
        </trans-unit>
        <trans-unit id="3f2f493de9594ab85ab997f6f445b21f8bf32608" translate="yes" xml:space="preserve">
          <source>vm.$nextTick()</source>
          <target state="translated">vm.$nextTick()</target>
        </trans-unit>
        <trans-unit id="c4320c5ab4595a1512d09e454b2afc1e30f53f99" translate="yes" xml:space="preserve">
          <source>vm.$off( [event, callback] )</source>
          <target state="translated">vm.$off([событие,обратный вызов])</target>
        </trans-unit>
        <trans-unit id="8659b7c176051de19b834751c71d64c023e531f8" translate="yes" xml:space="preserve">
          <source>vm.$off()</source>
          <target state="translated">vm.$off()</target>
        </trans-unit>
        <trans-unit id="faeea08725a5801e45b45e8d9044c3d2edda645d" translate="yes" xml:space="preserve">
          <source>vm.$on( event, callback )</source>
          <target state="translated">vm.$on(событие,обратный вызов )</target>
        </trans-unit>
        <trans-unit id="47dd05c213dfee7e3bf78c8e68b730713e6c7872" translate="yes" xml:space="preserve">
          <source>vm.$on()</source>
          <target state="translated">vm.$on()</target>
        </trans-unit>
        <trans-unit id="5ddf55fd8c65e0c64370564ac67c71a598011755" translate="yes" xml:space="preserve">
          <source>vm.$once( event, callback )</source>
          <target state="translated">vm.$once(событие,обратный вызов )</target>
        </trans-unit>
        <trans-unit id="95a71f9912a16c82dc4a770971c999acc1c481a4" translate="yes" xml:space="preserve">
          <source>vm.$once()</source>
          <target state="translated">vm.$once()</target>
        </trans-unit>
        <trans-unit id="0413cd705f160430c6855f79f80a44ed08a489dc" translate="yes" xml:space="preserve">
          <source>vm.$options</source>
          <target state="translated">vm.$options</target>
        </trans-unit>
        <trans-unit id="513e55e5a687797c62836b5b87c3bc78152500fe" translate="yes" xml:space="preserve">
          <source>vm.$parent</source>
          <target state="translated">vm.$parent</target>
        </trans-unit>
        <trans-unit id="96a7cb38d4e51f5a9a8a6369eb2854d54f31fd3a" translate="yes" xml:space="preserve">
          <source>vm.$props</source>
          <target state="translated">vm.$props</target>
        </trans-unit>
        <trans-unit id="d07c6d69732e9d49ba257f3637d225a5aed4c96d" translate="yes" xml:space="preserve">
          <source>vm.$refs</source>
          <target state="translated">vm.$refs</target>
        </trans-unit>
        <trans-unit id="ddead883ad1628e96ca570e4221dfc38903f3db2" translate="yes" xml:space="preserve">
          <source>vm.$root</source>
          <target state="translated">vm.$root</target>
        </trans-unit>
        <trans-unit id="77be545f1df363cacfd93eb0c9831ef3c95102f4" translate="yes" xml:space="preserve">
          <source>vm.$scopedSlots</source>
          <target state="translated">vm.$scopedSlots</target>
        </trans-unit>
        <trans-unit id="445f58422508541995e32fe0dceb823dcbaaf2f3" translate="yes" xml:space="preserve">
          <source>vm.$set( target, propertyName/index, value )</source>
          <target state="translated">vm.$set(target,propertyName/index,value )</target>
        </trans-unit>
        <trans-unit id="12697644997ccacfcfb893110ee18b99abc39f50" translate="yes" xml:space="preserve">
          <source>vm.$set()</source>
          <target state="translated">vm.$set()</target>
        </trans-unit>
        <trans-unit id="3e09115bb4ccfaa59031cd594a8725f9ddff4efe" translate="yes" xml:space="preserve">
          <source>vm.$slots</source>
          <target state="translated">vm.$slots</target>
        </trans-unit>
        <trans-unit id="0b7eb695b0a861c10e273101dd3381aea047bf00" translate="yes" xml:space="preserve">
          <source>vm.$watch( expOrFn, callback, [options] )</source>
          <target state="translated">vm.$watch(expOrFn,обратный вызов,[опции])</target>
        </trans-unit>
        <trans-unit id="fe0401584870a2346a744fe847cf8a6bd902dfbe" translate="yes" xml:space="preserve">
          <source>vm.$watch()</source>
          <target state="translated">vm.$watch()</target>
        </trans-unit>
        <trans-unit id="abc4eb915d83966c3c028e2808e22bda2146ff20" translate="yes" xml:space="preserve">
          <source>vue.common.js</source>
          <target state="translated">vue.common.js</target>
        </trans-unit>
        <trans-unit id="8bc5b029cab40d453cf86de8c720dd795e2a79c0" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.js</source>
          <target state="translated">vue.esm.browser.js</target>
        </trans-unit>
        <trans-unit id="d3ffd20876becca44053e10a61c39d904267ac9f" translate="yes" xml:space="preserve">
          <source>vue.esm.browser.min.js</source>
          <target state="translated">vue.esm.browser.min.js</target>
        </trans-unit>
        <trans-unit id="c117006aa30745b1641f5393741c01bb708cc6db" translate="yes" xml:space="preserve">
          <source>vue.esm.js</source>
          <target state="translated">vue.esm.js</target>
        </trans-unit>
        <trans-unit id="3f7227146eb759f801a054462cc6de123c9a354c" translate="yes" xml:space="preserve">
          <source>vue.js</source>
          <target state="translated">vue.js</target>
        </trans-unit>
        <trans-unit id="99a1d389faffdd980b71470664af47bc6458b2b3" translate="yes" xml:space="preserve">
          <source>vue.min.js</source>
          <target state="translated">vue.min.js</target>
        </trans-unit>
        <trans-unit id="293bf1049872f5a192d03a09bffe06f69b51091d" translate="yes" xml:space="preserve">
          <source>vue.runtime.common.js</source>
          <target state="translated">vue.runtime.common.js</target>
        </trans-unit>
        <trans-unit id="4e9d385e35e8eca60fb7e6083bf2726bc638f977" translate="yes" xml:space="preserve">
          <source>vue.runtime.esm.js</source>
          <target state="translated">vue.runtime.esm.js</target>
        </trans-unit>
        <trans-unit id="2b84e57a624eece08bd137eb6a2c3e4c53c4e1a1" translate="yes" xml:space="preserve">
          <source>vue.runtime.js</source>
          <target state="translated">vue.runtime.js</target>
        </trans-unit>
        <trans-unit id="f4c3c79918026bc22af5b5db5c14b417b1839be0" translate="yes" xml:space="preserve">
          <source>vue.runtime.min.js</source>
          <target state="translated">vue.runtime.min.js</target>
        </trans-unit>
        <trans-unit id="bcbb79f097d6df57f152dc61e8151e0a00cefb2d" translate="yes" xml:space="preserve">
          <source>warnHandler</source>
          <target state="translated">warnHandler</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
        <trans-unit id="b84bfe360a66993ae5d35ff845e9df46ef696052" translate="yes" xml:space="preserve">
          <source>will be maintained for the foreseeable future</source>
          <target state="translated">будет сохраняться в обозримом будущем</target>
        </trans-unit>
        <trans-unit id="9d57f6d32929205f7b53a7328ce8817af26246a6" translate="yes" xml:space="preserve">
          <source>will render the fallback content, &amp;ldquo;Submit&amp;rdquo;:</source>
          <target state="translated">отобразит резервный контент &amp;laquo;Отправить&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="032b3d049c6766e15673ecd6348f41e6baaa865b" translate="yes" xml:space="preserve">
          <source>will render with a value of &amp;ldquo;bar&amp;rdquo; instead of &amp;ldquo;foo&amp;rdquo;. The same goes for a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; with existing content. Instead of:</source>
          <target state="translated">будет отображаться со значением &amp;laquo;bar&amp;raquo; вместо &amp;laquo;foo&amp;raquo;. То же самое касается &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; с существующим контентом. Вместо того:</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
