<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="requirejs">
    <body>
      <group id="requirejs">
        <trans-unit id="814fdfdfe0abc73fb5e44e5bb62fa796ea1bc9e0" translate="yes" xml:space="preserve">
          <source>&amp;copy; jQuery Foundation and other contributors</source>
          <target state="translated">&amp;copy; jQuery Foundation и другие участники</target>
        </trans-unit>
        <trans-unit id="116e2c1fd2ece058c5a0364364bae279336cc7e2" translate="yes" xml:space="preserve">
          <source>(If you are familiar with or are using CommonJS modules, then please also see &lt;a href=&quot;commonjs&quot;&gt;CommonJS Notes&lt;/a&gt; for information on how the RequireJS module format maps to CommonJS modules).</source>
          <target state="translated">(Если вы знакомы с модулями CommonJS или используете их, см. Также &lt;a href=&quot;commonjs&quot;&gt;CommonJS Notes&lt;/a&gt; для получения информации о том, как формат модуля RequireJS сопоставляется с модулями CommonJS).</target>
        </trans-unit>
        <trans-unit id="82a7890eefbb42f66ffb0b96e79f6fd89b2c9340" translate="yes" xml:space="preserve">
          <source>1) You can download the tool on &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt;.</source>
          <target state="translated">1) Вы можете скачать инструмент на &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;странице загрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1eb492f8580ac62cf180d901b6d8d9ab286301" translate="yes" xml:space="preserve">
          <source>2) If you are using Node with NPM, you can install r.js globally as part of the &quot;requirejs&quot; package in NPM:</source>
          <target state="translated">2)Если вы используете Node с NPM,вы можете установить r.js глобально как часть пакета &quot;requirejs&quot; в NPM:</target>
        </trans-unit>
        <trans-unit id="223001ca9c5d92a15b5242e49eab360fc3a6ab3d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Додзё&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="185e9a68b4bd25da9cafad697c5012278e9b03b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7+</source>
          <target state="translated">&lt;a href=&quot;http://dojotoolkit.org/&quot;&gt;Додзё&lt;/a&gt; 1.7+</target>
        </trans-unit>
        <trans-unit id="29b5095018a8842d228b2cf94f9f94d1950bd084" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; - это способ вызова некоторых служб в JavaScript. Он работает в разных доменах и представляет собой устоявшийся подход к вызову служб, для которых просто требуется HTTP GET через тег скрипта.</target>
        </trans-unit>
        <trans-unit id="7bed7dfdba5bcd46587bab55a31fdd8625cb4cb7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://enderjs.com/&quot;&gt;Ender&lt;/a&gt;-associated modules like &lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt;, &lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt;, &lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt; and &lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://enderjs.com/&quot;&gt;&lt;/a&gt;Модули, связанные с Ender, такие как &lt;a href=&quot;https://github.com/ded/bonzo&quot;&gt;bonzo&lt;/a&gt; , &lt;a href=&quot;https://github.com/ded/qwery&quot;&gt;qwery&lt;/a&gt; , &lt;a href=&quot;https://github.com/fat/bean&quot;&gt;bean&lt;/a&gt; и &lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df0d4377cf36918105d53b70e20a99e1ebeb6fa6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</target>
        </trans-unit>
        <trans-unit id="d6339a4aaa1eb888ae1c20dc485879c790507768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt; defines &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;a module format&lt;/a&gt;. Unfortunately, it was defined without giving browsers equal footing to other JavaScript environments. Because of that, there are CommonJS spec proposals for &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Transport formats&lt;/a&gt; and an &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;asynchronous require&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.commonjs.org/&quot;&gt;CommonJS&lt;/a&gt; определяет &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;формат модуля&lt;/a&gt; . К сожалению, он был определен без предоставления браузерам равных с другими средами JavaScript. Из-за этого есть предложения спецификации CommonJS для &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;транспортных форматов&lt;/a&gt; и &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Async/A&quot;&gt;асинхронного требования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="169caf5485a51e42978bcea9564913573efbfa82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d4af46f9ebdadab5fefa4632360a2278fffd09" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://dojotoolkit.org/&quot;&gt;Dojo&lt;/a&gt; 1.7+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74294756b9d6920b0915c8538a76d59ebe267ac3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2374aadda0e5d5c377cdbfce99e8a569d63134ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt; is a great tool to that adds easy feature detection for your project. There is some optimizer support for optimizing code paths for has.js tests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/phiggins42/has.js&quot;&gt;has.js&lt;/a&gt; - отличный инструмент, добавляющий легкое обнаружение функций для вашего проекта. Существует некоторая поддержка оптимизатора для оптимизации путей кода для тестов has.js.</target>
        </trans-unit>
        <trans-unit id="8a3b8ef35a670bbe9cdf3e050dd3299ce78d4cba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs/example-multipage&lt;/a&gt; is an example of a project that has multiple pages, but shares a common configuration and a common optimized build layer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/requirejs/example-multipage&quot;&gt;requirejs / example-multipage&lt;/a&gt; - это пример проекта с несколькими страницами, но с общей конфигурацией и общим оптимизированным слоем сборки.</target>
        </trans-unit>
        <trans-unit id="197f40cae363a637d221e795d930e25e35b4402d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Optionally call define()&lt;/a&gt; if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;При необходимости вызовите define (),&lt;/a&gt; если он доступен. Приятно то, что вы все еще можете кодировать свою библиотеку, не полагаясь на AMD, просто участвуйте, если она доступна. Это позволяет потребителям ваших модулей:</target>
        </trans-unit>
        <trans-unit id="d837c5645dc6d885d6f5f17697f12c5bf3eae3a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 1.7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03d6178a0b3f875875c504ed71a5ca8ab1663e0" translate="yes" xml:space="preserve">
          <source>&lt;b id=&quot;loadBuildInfo&quot;&gt;Build considerations&lt;/b&gt;: The optimizer traces dependencies &lt;b&gt;synchronously&lt;/b&gt; to simplify the optimization logic. This is different from how require.js in the browser works, and it means that only plugins that can satisfy their dependencies synchronously should participate in the optimization steps that allow inlining of loader plugin values. Otherwise, the plugin should just call load() immediately if &lt;code&gt;config.isBuild&lt;/code&gt; is true:</source>
          <target state="translated">&lt;b id=&quot;loadBuildInfo&quot;&gt;Рекомендации по сборке&lt;/b&gt; : оптимизатор отслеживает зависимости &lt;b&gt;синхронно,&lt;/b&gt; чтобы упростить логику оптимизации. Это отличается от того, как работает require.js в браузере, и означает, что только плагины, которые могут удовлетворять свои зависимости синхронно, должны участвовать в шагах оптимизации, которые позволяют встраивать значения плагинов загрузчика. В противном случае плагин должен сразу вызвать load (), если &lt;code&gt;config.isBuild&lt;/code&gt; истинен:</target>
        </trans-unit>
        <trans-unit id="506bd15924c41f4004b36be9eb39edff02ffe729" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt;: A function that is called to load a resource. This is the only mandatory API method that needs to be implemented for the plugin to be useful.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiload&quot;&gt;load&lt;/a&gt;&lt;/b&gt; : функция, вызываемая для загрузки ресурса. Это единственный обязательный метод API, который необходимо реализовать, чтобы плагин был полезен.</target>
        </trans-unit>
        <trans-unit id="5c05204e40494673270518722d3577d844352a0f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt;: A function to normalize the resource name. This is useful in providing optimal caching and optimization, but only needed if the resource name is not a module name.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apinormalize&quot;&gt;normalize&lt;/a&gt;&lt;/b&gt; : функция для нормализации имени ресурса. Это полезно для обеспечения оптимального кэширования и оптимизации, но необходимо только в том случае, если имя ресурса не является именем модуля.</target>
        </trans-unit>
        <trans-unit id="67620f32dc794387af4268db0a195d2c0bec7533" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt;: A module name string for a module that should be used in the optimizer to do optimization work. That module is used instead of the plugin module when the optimizer runs.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apipluginbuilder&quot;&gt;pluginBuilder&lt;/a&gt;&lt;/b&gt; : строка имени модуля для модуля, который должен использоваться в оптимизаторе для выполнения работы по оптимизации. Этот модуль используется вместо подключаемого модуля при запуске оптимизатора.</target>
        </trans-unit>
        <trans-unit id="05c890f5aa6072a9d2a6646bd5b851f257e269fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt;: used by the optimizer to indicate when the plugin should write out a representation of the resource in the optimized file.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt;&lt;/b&gt; : используется оптимизатором, чтобы указать, когда плагин должен записать представление ресурса в оптимизированный файл.</target>
        </trans-unit>
        <trans-unit id="a2110dc4f9c4fa811fea913d44cc4b46b8d448f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;However&lt;/b&gt;, it will not remove the module from other modules that are already defined and got a handle on that module as a dependency when they executed. So it is really only useful to use in error situations when no other modules have gotten a handle on a module value, or as part of any future module loading that may use that module. See the &lt;a href=&quot;#errbacks&quot;&gt;errback section&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;b&gt;Однако&lt;/b&gt; он не удалит модуль из других модулей, которые уже определены и получили дескриптор этого модуля в качестве зависимости при их выполнении. Таким образом, действительно полезно использовать только в ситуациях с ошибками, когда никакие другие модули не получили дескриптор значения модуля, или как часть любой будущей загрузки модуля, которая может использовать этот модуль. См. &lt;a href=&quot;#errbacks&quot;&gt;Пример в разделе&lt;/a&gt; об ошибках .</target>
        </trans-unit>
        <trans-unit id="cd0efe11af170b5b34fae3a5768842f92021a2f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important notes for &quot;shim&quot; config:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Важные примечания для конфигурации &quot;прокладки&quot;:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e6d7e23c20b9c92a38f7ebaf9c629b50c1c46ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Important optimizer notes for &quot;shim&quot; config&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;Важные примечания оптимизатора для конфигурации &quot;прокладки&quot;&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="5452f95ab3f5431d3e0d9ea5bc5eb65ed9d54dbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;NOTE&lt;/b&gt;: If you do set enforceDefine: true, and you use data-main=&quot;&quot; to load your main JS module, then that main JS module &lt;b&gt;must call define()&lt;/b&gt; instead of require() to load the code it needs. The main JS module can still call require/requirejs to set config values, but for loading modules it should use define().</source>
          <target state="translated">&lt;b&gt;ПРИМЕЧАНИЕ&lt;/b&gt; . Если вы действительно устанавливаете enforceDefine: true и используете data-main = &quot;&quot; для загрузки вашего основного модуля JS, то этот основной модуль JS &lt;b&gt;должен вызывать define ()&lt;/b&gt; вместо require () для загрузки необходимого кода. Основной модуль JS все еще может вызывать require / requirejs для установки значений конфигурации, но для загрузки модулей он должен использовать define ().</target>
        </trans-unit>
        <trans-unit id="5013e4ed689d2a3ffaaa1dc5f688b4fa1c3b1c08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS &quot;timeout&quot; error. If this is a problem either increase the &lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt; configuration, or just use domReady as a module and call domReady() inside the require() callback.</source>
          <target state="translated">&lt;b&gt;Примечание.&lt;/b&gt; Если для загрузки документа требуется время (возможно, это очень большой документ или есть теги HTML-скрипта, загружающие большие файлы JS, которые блокируют завершение DOM до их завершения), использование domReady в качестве плагина загрузчика может привести к запросу RequireJS &quot; тайм-аут &quot;ошибка. Если это проблема, либо &lt;a href=&quot;#config-waitSeconds&quot;&gt;увеличьте&lt;/a&gt; конфигурацию waitSeconds , либо просто используйте domReady в качестве модуля и вызовите domReady () внутри обратного вызова require ().</target>
        </trans-unit>
        <trans-unit id="df71ff1e089733f190c702e16b09f3771f6c4081" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note:&lt;/b&gt; It is best to use &lt;code&gt;var require = {}&lt;/code&gt; and do not use &lt;code&gt;window.require = {}&lt;/code&gt;, it will not behave correctly in IE.</source>
          <target state="translated">&lt;b&gt;Примечание:&lt;/b&gt; лучше всего использовать &lt;code&gt;var require = {}&lt;/code&gt; и не использовать &lt;code&gt;window.require = {}&lt;/code&gt; , это не будет правильно работать в IE.</target>
        </trans-unit>
        <trans-unit id="4470cd3f81024ca53c77a075e808184e3d5f48ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: errbacks only work with callback-style require calls, not define() calls. define() is only for declaring modules.</source>
          <target state="translated">&lt;b&gt;Примечание&lt;/b&gt; : ошибки errback работают только с вызовами require в стиле обратного вызова, но не с вызовами define (). define () предназначен только для объявления модулей.</target>
        </trans-unit>
        <trans-unit id="1658d751a5e1864b6645a9132816926270ff006e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: paths fallbacks only work for exact module ID matches. This is different from normal paths config which can apply to any part of a module ID prefix segment. Fallbacks are targeted more for unusual error recovery, not a generic path search path solution, since those are inefficient in the browser.</source>
          <target state="translated">&lt;b&gt;Примечание&lt;/b&gt; : резервные пути работают только для точных совпадений идентификаторов модулей. Это отличается от конфигурации обычных путей, которая может применяться к любой части сегмента префикса идентификатора модуля. Резервные варианты больше нацелены на восстановление необычных ошибок, а не на решение общего пути поиска пути, поскольку они неэффективны в браузере.</target>
        </trans-unit>
        <trans-unit id="2213308d4ce3eb444b284f69d04a49e1e39fe908" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: the plugin and its dependencies should be able to run in non-browser environments like Node and Nashorn. If they cannot, you should use an alternate &lt;a href=&quot;#apipluginbuilder&quot;&gt;plugin builder&lt;/a&gt; module that can run in those environments so that they can participate in optimization builds.</source>
          <target state="translated">&lt;b&gt;Примечание&lt;/b&gt; : плагин и его зависимости должны иметь возможность работать в средах без браузера, таких как Node и Nashorn. Если они не могут, вам следует использовать альтернативный &lt;a href=&quot;#apipluginbuilder&quot;&gt;модуль&lt;/a&gt; построения плагинов, который может работать в этих средах, чтобы они могли участвовать в оптимизационных сборках.</target>
        </trans-unit>
        <trans-unit id="d1562ca8e4b27fe43c636be687ba000c82b1a7e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;config&lt;/b&gt;: Object. A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. The i18n! plugin uses this to get the current locale, if the web app wants to force a specific locale. The optimizer will set an &lt;b&gt;isBuild&lt;/b&gt; property in the config to true if this plugin (or pluginBuilder) is being called as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;config&lt;/b&gt; : Объект. Объект конфигурации. Это способ для оптимизатора и веб-приложения передать информацию о конфигурации плагину. I18n! плагин использует это, чтобы получить текущий языковой стандарт, если веб-приложение хочет принудительно установить конкретный языковой стандарт. Оптимизатор установит для свойства &lt;b&gt;isBuild&lt;/b&gt; в конфигурации значение true, если этот плагин (или pluginBuilder) вызывается как часть сборки оптимизатора.</target>
        </trans-unit>
        <trans-unit id="0633fd52ca339aa36fe803e1e7c1e235a965582c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;data&lt;/b&gt;: Object. Information about the layer. Only has two properties:</source>
          <target state="translated">&lt;b&gt;данные&lt;/b&gt; : Объект. Информация о слое. Имеет только два свойства:</target>
        </trans-unit>
        <trans-unit id="d4ae9f09e83410324efa2c5c493968846e5a710b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;fileName&lt;/b&gt;: String. The name of the file to write. You can use parentRequire.toUrl() with a relative path to generate a file name that will be inside the build output directory.</source>
          <target state="translated">&lt;b&gt;имя_файла&lt;/b&gt; : Строка. Имя файла для записи. Вы можете использовать parentRequire.toUrl () с относительным путем для создания имени файла, который будет находиться в каталоге вывода сборки.</target>
        </trans-unit>
        <trans-unit id="7d42af54c2cce4f8e3c824aa7095ba8adac48e63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;moduleName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;moduleName&lt;/b&gt; : String. &lt;b&gt;Нормализуется&lt;/b&gt; имя ресурса.</target>
        </trans-unit>
        <trans-unit id="f4fa4b373e19cffd64c341b383157951022e7fb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; resource name.</source>
          <target state="translated">&lt;b&gt;имя&lt;/b&gt; : Строка. &lt;b&gt;Нормализуется&lt;/b&gt; имя ресурса.</target>
        </trans-unit>
        <trans-unit id="c9b575c2614edbef93cb7cf9187a273ac90b40ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The name of the resource to load. This is the part after the ! separator in the name. So, if a module asks for 'foo!something/for/foo', the foo module's load function will receive 'something/for/foo' as the name.</source>
          <target state="translated">&lt;b&gt;имя&lt;/b&gt; : Строка. Имя загружаемого ресурса. Это часть после символа! разделитель в названии. Итак, если модуль запрашивает &amp;laquo;foo! Something / for / foo&amp;raquo;, функция загрузки модуля foo получит в качестве имени &amp;laquo;something / for / foo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a7e430f692ddd0f1696c7bf9d5e7600c2702e144" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: String. The resource name to normalize.</source>
          <target state="translated">&lt;b&gt;имя&lt;/b&gt; : Строка. Имя ресурса для нормализации.</target>
        </trans-unit>
        <trans-unit id="1de1ad4fff586a6f009688331bf3dac19f43a9e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;name&lt;/b&gt;: the module name of the layer. May be undefined.</source>
          <target state="translated">&lt;b&gt;name&lt;/b&gt; : &lt;b&gt;имя&lt;/b&gt; модуля слоя. Может быть неопределенным.</target>
        </trans-unit>
        <trans-unit id="e8637b053ea38a61892113ae66f0bdad8cc69085" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt; is called to normalize the name used to identify a resource. Some resources could use relative paths, and need to be normalized to the full path. normalize is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;normalize&lt;/b&gt; вызывается для нормализации имени, используемого для идентификации ресурса. Некоторые ресурсы могут использовать относительные пути, и их необходимо нормализовать до полного пути. normalize вызывается со следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="9c155f866c3dfbd6ddcaf1a21d533bc69c8f253f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;normalize&lt;/b&gt;: Function. A function that can be called to normalize a regular module name.</source>
          <target state="translated">&lt;b&gt;нормализовать&lt;/b&gt; : Функция. Функция, которая может быть вызвана для нормализации имени обычного модуля.</target>
        </trans-unit>
        <trans-unit id="518ae45a2c4e092a30ef6d374445ebbbc375d6cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onLayerEnd&lt;/b&gt; is only used by the optimizer, and is only supported in 2.1.0 or later of the optimizer. It is called after the modules for the layer have been written to the layer. It is useful to use if you need some code that should go at the end of the layer, or if the plugin needs to reset some internal state.</source>
          <target state="translated">&lt;b&gt;onLayerEnd&lt;/b&gt; используется только оптимизатором и поддерживается только в версии 2.1.0 или более поздней версии оптимизатора. Он вызывается после того, как модули для слоя были записаны в слой. Его полезно использовать, если вам нужен какой-то код, который должен идти в конце уровня, или если плагину нужно сбросить какое-то внутреннее состояние.</target>
        </trans-unit>
        <trans-unit id="624c08fd16b69bcc3349bb27e754504d9e657892" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;onload&lt;/b&gt;: Function. A function to call with the value for name. This tells the loader that the plugin is done loading the resource. &lt;b&gt;onload.error()&lt;/b&gt; can be called, passing an error object to it, if the plugin detects an error condition that means the resource will fail to load correctly.</source>
          <target state="translated">&lt;b&gt;onload&lt;/b&gt; : Функция. Функция, которую нужно вызвать со значением имени. Это сообщает загрузчику, что плагин завершил загрузку ресурса. &lt;b&gt;Можно вызвать onload.error ()&lt;/b&gt; , передав ему объект ошибки, если плагин обнаруживает состояние ошибки, что означает, что ресурс не сможет правильно загрузиться.</target>
        </trans-unit>
        <trans-unit id="c2f84b038f0ab819e5b8274b7f2ce93bdce6a23e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.defined(moduleName)&lt;/b&gt;: Returns true if the module has already been loaded and defined. Used to be called require.isDefined before RequireJS 0.25.0.</source>
          <target state="translated">&lt;b&gt;parentRequire.defined (moduleName)&lt;/b&gt; : возвращает true, если модуль уже был загружен и определен. Раньше назывался require.isDefined до RequireJS 0.25.0.</target>
        </trans-unit>
        <trans-unit id="015e07ffad07b4f74fe69ffc5fd5e560ba778a7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.specified(moduleName)&lt;/b&gt;: Returns true if the module has already been requested or is in the process of loading and should be available at some point.</source>
          <target state="translated">&lt;b&gt;parentRequire.specified (moduleName)&lt;/b&gt; : возвращает true, если модуль уже был запрошен или находится в процессе загрузки и должен быть доступен в какой-то момент.</target>
        </trans-unit>
        <trans-unit id="ba9bfc72098ec06b30b3641b2ed5add4ee4d4b6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire.toUrl(moduleResource)&lt;/b&gt;:where moduleResource is a module name plus an extension. For instance &quot;view/templates/main.html&quot;. It will return a full path to the resource, obeying any RequireJS configuration.</source>
          <target state="translated">&lt;b&gt;parentRequire.toUrl (moduleResource)&lt;/b&gt; : где moduleResource - это имя модуля плюс расширение. Например, &amp;laquo;view / templates / main.html&amp;raquo;. Он вернет полный путь к ресурсу в соответствии с любой конфигурацией RequireJS.</target>
        </trans-unit>
        <trans-unit id="622d5743c01e802124c82780fd2ca472a7445f78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function to use to load other modules. This function will resolve relative module names relative to the module name that asked for this plugin resource. If the loader plugin wants to &lt;code&gt;require()&lt;/code&gt; something relative to its own ID, it can ask for a &lt;code&gt;require&lt;/code&gt; in its own &lt;code&gt;define&lt;/code&gt; call. This require function has some utilities on it:</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt; : функция. Локальная функция &amp;laquo;require&amp;raquo; для загрузки других модулей. Эта функция будет разрешать относительные имена модулей относительно имени модуля, который запросил этот ресурс плагина. Если плагин загрузчика хочет &lt;code&gt;require()&lt;/code&gt; что-то относительно его собственного идентификатора, он может запросить &lt;code&gt;require&lt;/code&gt; в своем собственном вызове &lt;code&gt;define&lt;/code&gt; . У этой функции require есть некоторые утилиты:</target>
        </trans-unit>
        <trans-unit id="1d2aac6b06f25bcc6a08613d6ff429b73be408fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;parentRequire&lt;/b&gt;: Function. A local &quot;require&quot; function. The main use of this in writeFile is for calling parentRequire.toUrl() to generate file paths that are inside the build directory.</source>
          <target state="translated">&lt;b&gt;parentRequire&lt;/b&gt; : функция. Локальная функция &quot;require&quot;. В основном это используется в writeFile для вызова parentRequire.toUrl () для генерации путей к файлам внутри каталога сборки.</target>
        </trans-unit>
        <trans-unit id="e0134a16548c6c6645647a4752ed2ea5efb6a857" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;path&lt;/b&gt;: the file path of the layer. May be undefined, particularly if the output is just to a string that is consumed by another script.</source>
          <target state="translated">&lt;b&gt;path&lt;/b&gt; : &lt;b&gt;путь&lt;/b&gt; к файлу слоя. Может быть неопределенным, особенно если вывод - это просто строка, которая используется другим скриптом.</target>
        </trans-unit>
        <trans-unit id="a02d39c2198b5eb062ebbbd692afeb0af5f4b077" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginBuilder&lt;/b&gt; can be a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.</source>
          <target state="translated">&lt;b&gt;pluginBuilder&lt;/b&gt; может быть строкой, указывающей на другой модуль для использования вместо текущего подключаемого модуля, когда подключаемый модуль используется как часть сборки оптимизатора.</target>
        </trans-unit>
        <trans-unit id="7bccfaebe5d20d93dbb92eac6c4e4c2755184488" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;pluginName&lt;/b&gt;: String. The &lt;b&gt;normalized&lt;/b&gt; name for the plugin. Most plugins will not be authored with a name (they will be anonymous plugins) so it is useful to know the normalized name for the plugin module for use in the optimized file.</source>
          <target state="translated">&lt;b&gt;pluginName&lt;/b&gt; : String. &lt;b&gt;Нормализуется&lt;/b&gt; имя плагина. Большинство плагинов не будут создаваться с именем (это будут анонимные плагины), поэтому полезно знать нормализованное имя для модуля плагина для использования в оптимизированном файле.</target>
        </trans-unit>
        <trans-unit id="806f2c5413bd1f88dda933d6d9bf4ca71182ed30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The contents of the file. Must be UTF-8 encoded.</source>
          <target state="translated">&lt;b&gt;текст&lt;/b&gt; : Строка. Содержимое файла. Должен быть в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="2b37b8befddf87d1488ad007823a5c1cb02a63b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;text&lt;/b&gt;: String. The string of JavaScript to evaluate.</source>
          <target state="translated">&lt;b&gt;текст&lt;/b&gt; : Строка. Строка JavaScript для оценки.</target>
        </trans-unit>
        <trans-unit id="2cb55635b083fecb23646b281888e2d3a8e8e1af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin can output something that would belong in an optimized layer. It is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;write&lt;/b&gt; используется только оптимизатором, и его нужно реализовать только в том случае, если плагин может выводить что-то, что должно принадлежать оптимизированному уровню. Он вызывается со следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="5685d5466354ace13f25dd4ff5fa42d06b2d956d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized file. This function also contains a property function, &lt;b&gt;write.asModule(moduleName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file. asModule is useful for text transform plugins, like a CoffeeScript plugin.</source>
          <target state="translated">&lt;b&gt;напишите&lt;/b&gt; : Функция. Функция, вызываемая со строкой вывода для записи в оптимизированный файл. Эта функция также содержит функцию свойства &lt;b&gt;write.asModule (moduleName, text)&lt;/b&gt; . asModule можно использовать для записи модуля, который может иметь анонимный вызов define, который требует вставки имени или / и содержит неявные зависимости require (&quot;&quot;), которые необходимо извлечь для оптимизированного файла. asModule полезен для плагинов преобразования текста, таких как плагин CoffeeScript.</target>
        </trans-unit>
        <trans-unit id="cddc0bc3ed4ecb0a91508e3c705f0c73d4bc5f66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with a string of output to write to the optimized layer. &lt;b&gt;Modules should not be written out&lt;/b&gt; in this call. They will not be normalized correctly for coexistence with other define() calls already in the file. It is useful only for writing out non-define() code.</source>
          <target state="translated">&lt;b&gt;напишите&lt;/b&gt; : Функция. Функция, вызываемая со строкой вывода для записи на оптимизированный уровень. &lt;b&gt;Модули не следует выписывать&lt;/b&gt; в этом вызове. Они не будут правильно нормализованы для сосуществования с другими вызовами define (), уже находящимися в файле. Это полезно только для написания кода non-define ().</target>
        </trans-unit>
        <trans-unit id="21d71fbeac0c9a9225a98971c14d9b7642d2ce1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;write&lt;/b&gt;: Function. A function to be called with two arguments:</source>
          <target state="translated">&lt;b&gt;напишите&lt;/b&gt; : Функция. Функция, вызываемая с двумя аргументами:</target>
        </trans-unit>
        <trans-unit id="e1d47299b04571e05be6b9f2db9c64d7f599202c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFile&lt;/b&gt; is only used by the optimizer, and it only needs to be implemented if the plugin needs to write out an alternate version of a dependency that is handled by the plugin. It is a bit expensive to scan all modules in a project to look for all plugin dependencies, so this writeFile method will only be called if &lt;b&gt;optimizeAllPluginResources: true&lt;/b&gt; is in the build profile for the RequireJS optimizer. writeFile is called with the following arguments:</source>
          <target state="translated">&lt;b&gt;writeFile&lt;/b&gt; используется только оптимизатором, и его нужно реализовать только в том случае, если плагину нужно записать альтернативную версию зависимости, которая обрабатывается плагином. Сканирование всех модулей в проекте для поиска всех зависимостей плагинов немного дорого, поэтому этот метод writeFile будет вызываться только в том случае, если &lt;b&gt;optimizeAllPluginResources: true&lt;/b&gt; находится в профиле сборки для оптимизатора RequireJS. writeFile вызывается со следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="7a9de7b1060504a09fced2340f4cefe3979e7d78" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;commandargs&quot;&gt;Command line arguments are interchangeable with a build profile properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;commandargs&quot;&gt;Аргументы командной строки взаимозаменяемы со свойствами профиля сборки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="63567fbc5013d2bad98217cd761076a9914f3555" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;mainConfigFile&quot;&gt;Config settings in your main JS module that is loaded in the browser at runtime &lt;strong&gt;are not read by default&lt;/strong&gt; by the optimizer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;mainConfigFile&quot;&gt;Параметры конфигурации в вашем основном модуле JS, который загружается в браузере во время выполнения &lt;strong&gt;, по умолчанию не считываются&lt;/strong&gt; оптимизатором.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd6a6e70e53ade44e72789a459c1f511a24523b4" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;optionpaths&quot;&gt;Relative path resolution rules:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong id=&quot;optionpaths&quot;&gt;Правила относительного разрешения пути&lt;/strong&gt; ::</target>
        </trans-unit>
        <trans-unit id="688e93c7f23b0016b30ae1c02fe374c99ad602c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt;: the root path to use for all module lookups. So in the above example, &quot;my/module&quot;'s script tag will have a src=&quot;/another/path/my/module.js&quot;. baseUrl is &lt;strong&gt;not&lt;/strong&gt; used when loading plain .js files (indicated by a dependency string &lt;a href=&quot;#jsfiles&quot;&gt;starting with a slash, has a protocol, or ends in .js&lt;/a&gt;), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;&lt;/strong&gt; : корневой путь, используемый для поиска всех модулей. Итак, в приведенном выше примере тег сценария my / module будет иметь src = &quot;/ another / path / my / module.js&quot;. baseUrl&lt;strong&gt; не&lt;/strong&gt; используется при загрузке простых файлов .js (обозначенных строкой зависимости,&lt;a href=&quot;#jsfiles&quot;&gt; начинающейся с косой черты, имеющей протокол или оканчивающейся на .js&lt;/a&gt; ), эти строки используются как есть, поэтому a.js и b.js будут загружается из того же каталога, что и HTML-страница, содержащая приведенный выше фрагмент.</target>
        </trans-unit>
        <trans-unit id="1acd662f148a50d547ed8ad4f98e479065a4f997" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;bundles&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.10: allows configuring multiple module IDs to be found in another script. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-bundles&quot;&gt;bundles&lt;/a&gt;&lt;/strong&gt; : введено в RequireJS 2.1.10: позволяет настроить несколько идентификаторов модулей, которые будут найдены в другом скрипте. Пример:</target>
        </trans-unit>
        <trans-unit id="085af28d539841cfe94239340a377b5e8edb553b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;callback&lt;/a&gt;&lt;/strong&gt;: A function to execute after &lt;strong&gt;deps&lt;/strong&gt; have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's &lt;strong&gt;deps&lt;/strong&gt; array has been loaded.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-callback&quot;&gt;callback&lt;/a&gt;&lt;/strong&gt; : функция, выполняемая послезагрузки&lt;strong&gt; deps&lt;/strong&gt; . Полезно, когда require определен как объект конфигурации перед загрузкой require.js, и вы хотите указать функцию, которая требуется послезагрузки массива&lt;strong&gt; deps&lt;/strong&gt; конфигурации.</target>
        </trans-unit>
        <trans-unit id="326db44e3cbe2964c4c00e3827eaeb99ed4c2e9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt;: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the &lt;a href=&quot;#multiversion&quot;&gt;Multiversion Support&lt;/a&gt; section.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-context&quot;&gt;context&lt;/a&gt;&lt;/strong&gt; : имя для контекста загрузки. Это позволяет require.js загружать несколько версий модулей на страницу, если каждый вызов верхнего уровня указывает уникальную строку контекста. Чтобы использовать его правильно, см.Раздел &amp;laquo;&lt;a href=&quot;#multiversion&quot;&gt; Поддержка нескольких версий&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ca0d7afdccb360dffa934a77db230250e50afaf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt;: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a &lt;code&gt;require([])&lt;/code&gt; call, but done as soon as the loader has processed the configuration. &lt;strong&gt;It does not block&lt;/strong&gt; any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-deps&quot;&gt;deps&lt;/a&gt;&lt;/strong&gt; : массив зависимостей для загрузки. Полезно, когда require определяется как объект конфигурации до загрузки require.js, и вы хотите указать зависимости для загрузки, как только будет определен require (). Использование deps аналогичновызову &lt;code&gt;require([])&lt;/code&gt; , но выполняется, как только загрузчик обработает конфигурацию. &lt;strong&gt;Он не блокирует&lt;/strong&gt; запуск каких-либо других вызовов require () своих запросов на модули, это просто способ указать некоторые модули для асинхронной загрузки как часть блока конфигурации.</target>
        </trans-unit>
        <trans-unit id="0d247940698d8e6f686c0bb77049d6c8da63c7da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;&lt;/strong&gt;: If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See &lt;a href=&quot;#ieloadfail&quot;&gt;Catching load failures in IE&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;&lt;/strong&gt; : если задано значение true, будет&lt;strong&gt; выдана&lt;/strong&gt; ошибка, если загружается сценарий, который не вызывает define () или имеет строковое значение экспорта оболочки, которое можно проверить. Дополнительные сведения см. В разделе &amp;laquo;&lt;a href=&quot;#ieloadfail&quot;&gt; Обнаружение сбоев загрузки в IE&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6138f55b500825f984e6dbb333dcd329837caa4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt;: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-map&quot;&gt;map&lt;/a&gt;&lt;/strong&gt; : для данного префикса модуля вместо загрузки модуля с данным идентификатором подставьте другой идентификатор модуля.</target>
        </trans-unit>
        <trans-unit id="95681aafd1c488d7f8f14732850e7d8b209998c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt;: There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the &lt;b&gt;config&lt;/b&gt; option for requirejs.config(). Modules can then read that info by asking for the special dependency &quot;module&quot; and calling &lt;b&gt;module.config()&lt;/b&gt;. Example:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-moduleconfig&quot;&gt;config&lt;/a&gt;&lt;/strong&gt; : Обычно требуется передать информацию о конфигурации модулю. Эта информация о конфигурации обычно известна как часть приложения, и должен быть способ передать ее модулю. В RequireJS это делается с помощьюпараметра&lt;b&gt; конфигурации&lt;/b&gt; для requirejs.config (). Затем модули могут прочитать эту информацию, запросив специальный &amp;laquo;модуль&amp;raquo; зависимости и вызвав&lt;b&gt; module.config ()&lt;/b&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="ac39bdc204ad820f4dd2e31dd8517ff27d56c927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt;: Node treats module ID &lt;code&gt;example.js&lt;/code&gt; and &lt;code&gt;example&lt;/code&gt; the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to &lt;code&gt;true&lt;/code&gt; to avoid resolution issues. This option only applies to treating the &quot;.js&quot; suffix differently, it does not do any other node resolution and evaluation matching such as .json file handling (JSON handling needs a 'json!' loader plugin anyway). Available in 2.1.10 and greater.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-nodeIdCompat&quot;&gt;nodeIdCompat&lt;/a&gt;&lt;/strong&gt; : Node обрабатывает ID модуля &lt;code&gt;example.js&lt;/code&gt; и &lt;code&gt;example&lt;/code&gt; одинаково. По умолчанию это два разных идентификатора в RequireJS. Если вы в конечном итоге используете модули, установленные из npm, вам может потребоваться установить для этого значения конфигурации значение &lt;code&gt;true&lt;/code&gt; , чтобы избежать проблем с разрешением. Этот параметр применяется только для обработки суффикса &amp;laquo;.js&amp;raquo; по-разному, он не выполняет никаких других разрешений и сопоставлений узлов, таких как обработка файлов .json (для обработки JSON в любом случае требуется плагин загрузчика &amp;laquo;json!&amp;raquo;). Доступно в версии 2.1.10 и выше.</target>
        </trans-unit>
        <trans-unit id="99510d1860c925d6763db57dff66af25efccbf3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;packages&lt;/a&gt;&lt;/strong&gt;: configures loading modules from CommonJS packages. See the &lt;a href=&quot;#packages&quot;&gt;packages topic&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-packages&quot;&gt;пакеты&lt;/a&gt;&lt;/strong&gt; : настраивает загрузку модулей из пакетов CommonJS. См. Раздел о&lt;a href=&quot;#packages&quot;&gt; пакетах&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="06ed9a797e36865b0f29ed4687132d5027a3f359" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;paths&lt;/a&gt;&lt;/strong&gt;: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a &quot;/&quot; or has a URL protocol in it (&quot;like http:&quot;). Using the above sample config, &quot;some/module&quot;'s script tag will be src=&quot;/another/path/some/v1.0/module.js&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-paths&quot;&gt;paths&lt;/a&gt;&lt;/strong&gt; : сопоставления путей для имен модулей, не найденных непосредственно в baseUrl. Предполагается, что параметры пути относятся к baseUrl, если только параметр пути не начинается с символа &amp;laquo;/&amp;raquo; или не содержит в себе протокола URL (например, http:). Используя приведенный выше пример конфигурации, тег скрипта some / module будет иметь вид src = &quot;/ another / path / some / v1.0 / module.js&quot;.</target>
        </trans-unit>
        <trans-unit id="cc259753f530f4d5d7cbdb6355d3a8dab3314d7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt;: Specify the value for the type=&quot;&quot; attribute used for script tags inserted into the document by RequireJS. Default is &quot;text/javascript&quot;. To use Firefox's JavaScript 1.8 features, use &quot;text/javascript;version=1.8&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-scriptType&quot;&gt;scriptType&lt;/a&gt;&lt;/strong&gt; : укажите значение атрибута type = &quot;&quot;, используемого для тегов сценария, вставленных в документ с помощью RequireJS. По умолчанию - &amp;laquo;текст / javascript&amp;raquo;. Чтобы использовать функции Firefox JavaScript 1.8, используйте &amp;laquo;text / javascript; version = 1.8&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="371b64def2675a68c091d43c2a65d306af3cb9b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt;: Configure the dependencies, exports, and custom initialization for older, traditional &quot;browser globals&quot; scripts that do not use define() to declare the dependencies and set a module value.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt;&lt;/strong&gt; : Настройте зависимости, экспорт и пользовательскую инициализацию для старых традиционных сценариев &amp;laquo;глобальных браузеров&amp;raquo;, которые не используют define () для объявления зависимостей и установки значения модуля.</target>
        </trans-unit>
        <trans-unit id="5ae95b324cd867a143c0b42db1f26232e9890ce4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt;: Introduced in RequireJS 2.1.9: If set to &lt;code&gt;true&lt;/code&gt;, skips the &lt;a href=&quot;#data-main&quot;&gt;data-main attribute scanning&lt;/a&gt; done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-skipDataMain&quot;&gt;skipDataMain&lt;/a&gt;&lt;/strong&gt; :&lt;strong&gt; введено&lt;/strong&gt; в RequireJS 2.1.9: если установлено значение &lt;code&gt;true&lt;/code&gt; , пропускает&lt;a href=&quot;#data-main&quot;&gt; сканирование основных атрибутов данных,&lt;/a&gt; выполняемое для начала загрузки модуля. Полезно, если RequireJS встроен в служебную библиотеку, которая может взаимодействовать с другой библиотекой RequireJS на странице, а встроенная версия не должна выполнять загрузку основных данных.</target>
        </trans-unit>
        <trans-unit id="ca72d7e0434fdb9fead21c9434f101648dcbd013" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt;: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-urlArgs&quot;&gt;urlArgs&lt;/a&gt;&lt;/strong&gt; : дополнительные аргументы строки запроса, добавленные к URL-адресам, которые RequireJS использует для извлечения ресурсов. Наиболее полезно для кеширования бюста, когда браузер или сервер настроены неправильно. Пример настройки блокировки кеша для urlArgs:</target>
        </trans-unit>
        <trans-unit id="8edef7869b3aeadbaede9416bcfe954daf6b604d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt;: The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-waitSeconds&quot;&gt;waitSeconds&lt;/a&gt;&lt;/strong&gt; : количество секунд ожидания перед&lt;strong&gt; отказом&lt;/strong&gt; от загрузки скрипта. Установка его в 0 отключает тайм-аут. По умолчанию 7 секунд.</target>
        </trans-unit>
        <trans-unit id="b9f67b72412ffa73c5ba387b645c9c5325fe18bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt;: If set to true, document.createElementNS() will be used to create script elements.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;#config-xhtml&quot;&gt;xhtml&lt;/a&gt;&lt;/strong&gt; : если установлено значение true, document.createElementNS () будет использоваться для создания элементов скрипта.</target>
        </trans-unit>
        <trans-unit id="31f7abf9c4912797d9daf10910ecf7f88272e44b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;Loader plugins&lt;/a&gt;&lt;/strong&gt; are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;plugins&quot;&gt;Плагины загрузчика&lt;/a&gt;&lt;/strong&gt; невероятно полезны. Это помогает избежать использования вложенных фигурных скобок, обычно используемых в программировании на основе обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="ed6dad16503b3126795253aa8af8de2838d36717" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid optimization names that are outside the baseUrl&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Избегайте оптимизации имен вне baseUrl&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab1ba893f507bf37759ad63a03f08e7621aa0f0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice&lt;/strong&gt;: Use npm to install Node-only packages/modules into the projects &lt;strong&gt;node_modules&lt;/strong&gt; directory, but do not configure RequireJS to look inside the node_modules directory. Also avoid using relative module IDs to reference modules that are Node-only modules. So, &lt;strong&gt;do not&lt;/strong&gt; do something like &lt;strong&gt;require(&quot;./node_modules/foo/foo&quot;)&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Лучшая практика&lt;/strong&gt; : Использование НОГО для установки Node-только пакетов / модули в проектах &lt;strong&gt;node_modules&lt;/strong&gt; каталога, но не настраивать RequireJS заглянуть внутрь каталога node_modules. Также избегайте использования относительных идентификаторов модулей для ссылки на модули, которые являются модулями только для узла. Итак, &lt;strong&gt;не&lt;/strong&gt; делайте что-то вроде &lt;strong&gt;require (&quot;./ node_modules / foo / foo&quot;)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="be29faed16f9fe8a4c388fa7277c7a67d769cd29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser:&lt;/strong&gt; as of 2.1.2, the optimizer can run in a web browser that has &lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt;. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;the browser example&lt;/a&gt;. This option is really only useful for providing web-based custom builds of your library.</source>
          <target state="translated">&lt;strong&gt;Браузер:&lt;/strong&gt; начиная с версии 2.1.2, оптимизатор может работать в веб-браузере с &lt;a href=&quot;http://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;дополнительными функциями массива&lt;/a&gt; . Хотя параметры оптимизатора такие же, как показано ниже, он вызывается через JavaScript вместо параметров командной строки. Это также хорошо только для создания оптимизированных отдельных файлов, а не для оптимизации каталогов. См. &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;Пример браузера&lt;/a&gt; . Эта опция действительно полезна только для создания пользовательских веб-сборок вашей библиотеки.</target>
        </trans-unit>
        <trans-unit id="f16ee22e3883332888fc6fc8e00e88c6977796fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser:&lt;/strong&gt; as of 2.1.2, the optimizer can run in a web browser that has &lt;a href=&quot;https://dev.opera.com/articles/view/javascript-array-extras-in-detail/&quot;&gt;array extras&lt;/a&gt;. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/tests/browser/r.html&quot;&gt;the browser example&lt;/a&gt;. This option is really only useful for providing web-based custom builds of your library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f5e7e58829260a983728d562bc82651be3abf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Console debugging&lt;/strong&gt;: If you need to work with a module you already loaded via a &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; call in the JavaScript console, then you can use the require() form that just uses the string name of the module to fetch it:</source>
          <target state="translated">&lt;strong&gt;Отладка консоли&lt;/strong&gt; : если вам нужно работать с модулем, который вы уже загрузили с помощью вызова &lt;code&gt;require([&quot;module/name&quot;], function(){})&lt;/code&gt; в консоли JavaScript, вы можете использовать форму require (), которая просто использует строковое имя модуля для его выборки:</target>
        </trans-unit>
        <trans-unit id="8df639b0d629d79075271634c2a5642b4af733b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Definition&lt;/strong&gt;: how to encapsulate a piece of code into a useful unit, and how to register its capability/export a value for the module.</source>
          <target state="translated">&lt;strong&gt;Определение&lt;/strong&gt; : как инкапсулировать фрагмент кода в полезный блок и как зарегистрировать его возможности / экспортировать значение для модуля.</target>
        </trans-unit>
        <trans-unit id="e52f813a7533d3a816bf2bc5cc17f40154357c7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dependency References&lt;/strong&gt;: how to refer to other units of code.</source>
          <target state="translated">&lt;strong&gt;Ссылки на зависимости&lt;/strong&gt; : как ссылаться на другие блоки кода.</target>
        </trans-unit>
        <trans-unit id="76f910f2e7544ed69b4f3f77df13ab34a0a941a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not specify the output directory to within the source area for your JavaScript&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Не указывайте выходной каталог в пределах области исходного кода для вашего JavaScript.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15219d6fbf857eb4de9f2b5152e2cabd11fe6c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dynamic code loading&lt;/strong&gt; (done in AMD systems via &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require([], function (){})&lt;/a&gt;) is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(''), which is not portable to the web.</source>
          <target state="translated">&lt;strong&gt;Динамическая загрузка кода&lt;/strong&gt; (выполняется в системах AMD через &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;require ([], function () {})&lt;/a&gt; ) является основным требованием. CJS говорил об этом, у него были предложения, но они не были полностью приняты. Node не поддерживает эту потребность, вместо этого полагаясь на синхронное поведение require (''), который не переносится в Интернет.</target>
        </trans-unit>
        <trans-unit id="ccfc6e9f2a4e66e6e924a9d6243c5590996ab0ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generate URLs relative to module&lt;/strong&gt;: You may need to generate an URL that is relative to a module. To do so, ask for &quot;require&quot; as a dependency and then use require.toUrl() to generate the URL:</source>
          <target state="translated">&lt;strong&gt;Сгенерировать URL-адреса относительно модуля&lt;/strong&gt; : вам может потребоваться сгенерировать URL-адрес, относящийся к модулю. Для этого запросите &quot;require&quot; в качестве зависимости, а затем используйте require.toUrl () для генерации URL:</target>
        </trans-unit>
        <trans-unit id="ce7c6f510ef7b7a0a096cba1750438eff21c1680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT NOTES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВАЖНЫЕ ЗАМЕТКИ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="20972c6512a123816c889472eeaa7736b05ba276" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IMPORTANT&lt;/strong&gt;: The function arguments should always be listed as &lt;strong&gt;require, exports, module&lt;/strong&gt;, with those exact names and in that exact order, otherwise chaos will ensue. You can leave off exports and module from the list, but if they are needed, they need to be specified in the exact order illustrated here.</source>
          <target state="translated">&lt;strong&gt;ВАЖНО&lt;/strong&gt; : аргументы функции всегда должны быть указаны как &lt;strong&gt;require, exports, module&lt;/strong&gt; с этими точными именами и в таком точном порядке, иначе возникнет хаос. Вы можете не включать в список экспорт и модуль, но если они необходимы, их нужно указать в точном порядке, показанном здесь.</target>
        </trans-unit>
        <trans-unit id="6252e4d16b5ac8019cf35465c36d0d40ca17d8f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you are a script/library author&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Если вы автор скрипта / библиотеки&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4bc23c4166c7b23082f0e2749ca3e82ba7a59bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write applications:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если вы пишете приложения:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c2bf07821d29e12c974210b6ab52ee6b3ae192f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you write code loaders/engines/environments for JavaScript:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если вы пишете загрузчики кода / движки / среды для JavaScript:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="356892b8284923e6d2f5cc7f4d0a01e0ba3bdede" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the RequreJS 1.0.x releases&lt;/strong&gt;, there &lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;is a bug&lt;/a&gt; with having a space between the require and parens in WebKit browsers when using the simplified CommonJS wrapping (no dependency array):</source>
          <target state="translated">&lt;strong&gt;В выпусках RequreJS 1.0.x&lt;/strong&gt; есть &lt;a href=&quot;https://github.com/requirejs/requirejs/issues/265&quot;&gt;ошибка&lt;/a&gt; с наличием пробела между требованиями и скобками в браузерах WebKit при использовании упрощенной упаковки CommonJS (без массива зависимостей):</target>
        </trans-unit>
        <trans-unit id="e1ca9b023143e72afa4253fd458b6c0e03df2271" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java:&lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt; or later.</source>
          <target state="translated">&lt;strong&gt;Java: &lt;/strong&gt;&lt;a href=&quot;http://java.com/&quot;&gt;Java 1.6&lt;/a&gt; или новее.</target>
        </trans-unit>
        <trans-unit id="095354ee186c6d03ba39e984bc04ef3890ecaa9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java:&lt;/strong&gt;&lt;a href=&quot;https://java.com/&quot;&gt;Java 1.6&lt;/a&gt; or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19035fd62e2796fc9e71500430ed2729bd25794b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node:&lt;/strong&gt; (preferred) &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; 0.4.0 or later.</source>
          <target state="translated">&lt;strong&gt;Узел:&lt;/strong&gt; (предпочтительно) &lt;a href=&quot;http://nodejs.org&quot;&gt;Узел&lt;/a&gt; 0.4.0 или новее.</target>
        </trans-unit>
        <trans-unit id="0b4588887e6e03b3d61220053afd37fca3ad7b38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node:&lt;/strong&gt; (preferred) &lt;a href=&quot;https://nodejs.org&quot;&gt;Node&lt;/a&gt; 0.4.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0731eb1335fb5dce4ac6b95537018a342d2bb8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note the build limitations of shim config.&lt;/strong&gt; In particular, you cannot load dependencies for shimmed libraries from a CDN. See the &lt;a href=&quot;api#config-shim&quot;&gt;shim config section&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание на ограничения сборки shim config. &lt;/strong&gt;В частности, вы не можете загружать зависимости для совместимых библиотек из CDN. Дополнительную информацию см. В &lt;a href=&quot;api#config-shim&quot;&gt;разделе конфигурации оболочки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="333ae88975c3caac92e92e986a1a903f145fdd9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when doing builds with map config, the map config needs to be fed to the optimizer, and the build output must still contain a requirejs config call that sets up the map config. The optimizer does not do ID renaming during the build, because some dependency references in a project could depend on runtime variable state. So the optimizer does not invalidate the need for a map config after the build.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; при сборке с конфигурацией карты конфигурация карты должна быть передана оптимизатору, а вывод сборки по-прежнему должен содержать вызов конфигурации requirejs, который устанавливает конфигурацию карты. Оптимизатор не выполняет переименование идентификатора во время сборки, поскольку некоторые ссылки на зависимости в проекте могут зависеть от состояния переменной времени выполнения. Таким образом, оптимизатор не отменяет необходимость конфигурирования карты после сборки.</target>
        </trans-unit>
        <trans-unit id="ab9355b9cfcc01a8de70426e43051f8e16d1ea97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;requirejs([], function() {})&lt;/code&gt; will call the function callback asynchronously in RequireJS 2.1+ (for earlier versions it was synchronously called). However, when running in Node, module loading will be loaded using sync IO calls, and loader plugins should resolve calls to their load method synchronously. This allows sync uses of the requirejs module in node to work via requirejs('stringValue') calls:</source>
          <target state="translated">&lt;strong&gt;Примечание: &lt;/strong&gt; &lt;code&gt;requirejs([], function() {})&lt;/code&gt; будет вызывать обратный вызов функции асинхронно в RequireJS 2.1+ (для более ранних версий он вызывался синхронно). Однако при работе в Node загрузка модуля будет загружаться с использованием вызовов синхронизации ввода-вывода, а плагины загрузчика должны синхронно разрешать вызовы своего метода загрузки. Это позволяет синхронизировать использование модуля requirejs в узле для работы через вызовы requirejs ('stringValue'):</target>
        </trans-unit>
        <trans-unit id="f4d9ab191ead6e7068952ee09f25ad5ec231469d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание,&lt;/strong&gt; что RequireJS всегда будет использовать версию локали в нижнем регистре, чтобы избежать проблем с регистром, поэтому все каталоги и файлы на диске для пакетов i18n должны использовать локали в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="0ccc1238154db0c7afccdfc9988192b6769a2544" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One module per file.&lt;/strong&gt;: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. You shoud only use the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt; to group multiple modules into optimized files.</source>
          <target state="translated">&lt;strong&gt;Один модуль на файл. &lt;/strong&gt;: Для каждого файла JavaScript должен быть определен только один модуль, учитывая характер алгоритма поиска имени модуля и пути к файлу. Вы должны использовать &lt;a href=&quot;optimization&quot;&gt;инструмент оптимизации только&lt;/a&gt; для группировки нескольких модулей в оптимизированные файлы.</target>
        </trans-unit>
        <trans-unit id="d956212a5ca554b5c7226464fd11b8fe3d92afc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Only JSONP return values that are JSON objects are supported&lt;/strong&gt;. A JSONP response that is an array, a string or a number will not work.</source>
          <target state="translated">&lt;strong&gt;Поддерживаются только возвращаемые значения JSONP, которые являются объектами JSON&lt;/strong&gt; . Ответ JSONP, представляющий собой массив, строку или число, не будет работать.</target>
        </trans-unit>
        <trans-unit id="49a7d502c051d7f90a9322365968054abdce7daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names are relative to other names, not paths&lt;/strong&gt;: The loader stores modules by their name and not by their path internally. So for relative name references, those are resolved relative to the module name making the reference, then that module name, or ID, is converted to a path if needs to be loaded. Example code for a 'compute' package that has a 'main' and 'extras' modules in it:</source>
          <target state="translated">&lt;strong&gt;Относительные имена модулей относятся к другим именам, а не к путям&lt;/strong&gt; : загрузчик хранит модули по их имени, а не по пути внутри. Таким образом, для ссылок на относительные имена они разрешаются относительно имени модуля, составляющего ссылку, затем это имя модуля или идентификатор преобразуется в путь, если необходимо загрузить. Пример кода для пакета compute, в котором есть модули main и extra:</target>
        </trans-unit>
        <trans-unit id="11a170cfd674f6e39dc87345715cd0fbe306ab78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relative module names inside define()&lt;/strong&gt;: For require(&quot;./relative/name&quot;) calls that can happen inside a define() function call, be sure to ask for &quot;require&quot; as a dependency, so that the relative name is resolved correctly:</source>
          <target state="translated">&lt;strong&gt;Относительные имена модулей внутри define ()&lt;/strong&gt; : для вызовов require (&quot;./ relative / name&quot;), которые могут происходить внутри вызова функции define (), не забудьте запросить &quot;require&quot; в качестве зависимости, чтобы относительное имя было разрешено правильно:</target>
        </trans-unit>
        <trans-unit id="2ba09f23bfed021b25b590445886e93396c6841a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returning a function as the module value&lt;/strong&gt;, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use &quot;return function (){}&quot; is much cleaner. It means not having to get a handle on &quot;module&quot; to do module.exports, and it is a clearer code expression.</source>
          <target state="translated">&lt;strong&gt;Возврат функции в качестве значения модуля&lt;/strong&gt; , особенно функции конструктора, приводит к лучшему дизайну API. Для этого в Node есть module.exports, но возможность использовать &quot;return function () {}&quot; намного чище. Это означает, что для выполнения module.exports не нужно обращаться к &amp;laquo;модулю&amp;raquo;, и это более четкое кодовое выражение.</target>
        </trans-unit>
        <trans-unit id="d7f39288e5c973499ca8c5f2d0687e7cd917ff92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selectively mapping one module&lt;/strong&gt; to load from another location makes it easy to provide mock objects for testing.</source>
          <target state="translated">&lt;strong&gt;Выборочное отображение одного модуля&lt;/strong&gt; для загрузки из другого места упрощает предоставление фиктивных объектов для тестирования.</target>
        </trans-unit>
        <trans-unit id="e61d06563cca67b22b9eb8c2024e68101de86ae3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;location&lt;/strong&gt;: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</source>
          <target state="translated">&lt;strong&gt;расположение&lt;/strong&gt; : расположение на диске. Расположение указывается относительно значения конфигурации baseUrl, если оно не содержит протокол или не начинается с косой черты (/).</target>
        </trans-unit>
        <trans-unit id="d76ab03895b36d6cde2b56b5d8e63691bc784ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main&lt;/strong&gt;: The name of the module inside the package that should be used when someone does a require for &quot;packageName&quot;. The default value is &quot;main&quot;, so only specify it if it differs from the default. The value is relative to the package folder.</source>
          <target state="translated">&lt;strong&gt;main&lt;/strong&gt; : имя модуля внутри пакета, которое следует использовать, когда кто-то требует для &quot;packageName&quot;. Значение по умолчанию - &amp;laquo;main&amp;raquo;, поэтому указывайте его, только если оно отличается от значения по умолчанию. Значение указано относительно папки пакета.</target>
        </trans-unit>
        <trans-unit id="e9a96de3b237de28b3418486a2dfc515daa753cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt;: The name of the package (used for the module name/prefix mapping)</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; : имя пакета (используется для сопоставления имени модуля / префикса)</target>
        </trans-unit>
        <trans-unit id="e6c02a1abf8f5e3c3ca5c9b099c109ed745a20bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;project.html&lt;/strong&gt; will have a script tag like this:</source>
          <target state="translated">&lt;strong&gt;project.html&lt;/strong&gt; будет иметь такой тег скрипта:</target>
        </trans-unit>
        <trans-unit id="95c789276d7d4257fd905839da9ee26e33460a9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireModules&lt;/strong&gt;: an array of module names/URLs that timed out.</source>
          <target state="translated">&lt;strong&gt;requireModules&lt;/strong&gt; : массив имен модулей / URL-адресов, срок действия которых истек.</target>
        </trans-unit>
        <trans-unit id="b3a393e55d1a8e898134ecc9aee2b2dd26cb033b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;requireType&lt;/strong&gt;: A string value with a general classification, like &quot;timeout&quot;, &quot;nodefine&quot;, &quot;scripterror&quot;.</source>
          <target state="translated">&lt;strong&gt;requireType&lt;/strong&gt; : строковое значение с общей классификацией, например &amp;laquo;тайм-аут&amp;raquo;, &amp;laquo;nodefine&amp;raquo;, &amp;laquo;scripterror&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f81c83895ae3b9f711da071c21815fc034381a2b" translate="yes" xml:space="preserve">
          <source>A common use case for this is to use a CDN-hosted version of a library, but if that fails, switch to loading the file locally:</source>
          <target state="translated">Обычно для этого используется CDN-хостинговая версия библиотеки,но если это не удается,переключитесь на загрузку файла локально:</target>
        </trans-unit>
        <trans-unit id="aecc92efc37038c626a9898853eacec5623d807b" translate="yes" xml:space="preserve">
          <source>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;Module Pattern&lt;/a&gt;, with the benefit of not needing globals to refer to other modules.</source>
          <target state="translated">Модуль отличается от традиционного файла сценария тем, что он определяет объект с хорошей областью видимости, который позволяет избежать загрязнения глобального пространства имен. Он может явно перечислить свои зависимости и получить дескриптор этих зависимостей без необходимости ссылаться на глобальные объекты, но вместо этого получает зависимости в качестве аргументов функции, определяющей модуль. Модули в RequireJS являются расширением &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;шаблона модуля&lt;/a&gt; , с тем преимуществом, что не нужны глобальные переменные для ссылки на другие модули.</target>
        </trans-unit>
        <trans-unit id="4c775660143554c4a49c1424ff91639fea08f923" translate="yes" xml:space="preserve">
          <source>A package can be associated with a module name/prefix.</source>
          <target state="translated">Пакет может быть связан с именем/префиксом модуля.</target>
        </trans-unit>
        <trans-unit id="afcd892649c51aa04e79a2542db76913e80781c9" translate="yes" xml:space="preserve">
          <source>A plugin could have very specific logic that depends on a certain environment, like the browser. However, when run inside the optimizer, the environment is very different, and the plugin may have a &lt;b&gt;write&lt;/b&gt; plugin API implementation that it does not want to deliver as part of the normal plugin that is loaded in the browser. In those cases, specifying a pluginBuilder is useful.</source>
          <target state="translated">Плагин может иметь очень специфическую логику, которая зависит от определенной среды, например браузера. Однако при запуске внутри оптимизатора среда сильно отличается, и плагин может иметь реализацию API плагина &lt;b&gt;записи,&lt;/b&gt; которую он не хочет доставлять как часть обычного плагина, загружаемого в браузер. В таких случаях полезно указать pluginBuilder.</target>
        </trans-unit>
        <trans-unit id="4755581e13a8cfa7fccfd118cd85844167f076f6" translate="yes" xml:space="preserve">
          <source>A require of &quot;cart&quot; means that it will be loaded from &lt;strong&gt;scripts/cart/main.js&lt;/strong&gt;, since &quot;main&quot; is the default main module setting supported by RequireJS. A require of &quot;store/util&quot; will be loaded from &lt;strong&gt;scripts/store/util.js&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Требование&lt;/strong&gt; &amp;laquo;cart&amp;raquo; означает, что он будет загружен из &lt;strong&gt;scripts / cart / main.js&lt;/strong&gt; , поскольку &amp;laquo;main&amp;raquo; - это настройка основного модуля по умолчанию, поддерживаемая RequireJS. Требуют от &amp;laquo;магазина / Util&amp;raquo; будут загружены из &lt;strong&gt;сценариев / магазина / util.js&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc1b9b4bb07d1464277843f034100c63208665b6" translate="yes" xml:space="preserve">
          <source>AMD</source>
          <target state="translated">AMD</target>
        </trans-unit>
        <trans-unit id="cd5cf5473243e1d45d7719af8f41414a0e858e3d" translate="yes" xml:space="preserve">
          <source>AMD Used Today</source>
          <target state="translated">AMD Используется сегодня</target>
        </trans-unit>
        <trans-unit id="7756663774fb63eb9c802ee39b2964fe49d1000d" translate="yes" xml:space="preserve">
          <source>AMD addresses these issues by:</source>
          <target state="translated">AMD решает эти вопросы:</target>
        </trans-unit>
        <trans-unit id="2fbb6d8aa7490cd0fb9b3c2680eaeeb53140cf79" translate="yes" xml:space="preserve">
          <source>AMD and its related APIs, have helped show the following for any future JS module system:</source>
          <target state="translated">AMD и связанные с ним API,помогли показать следующее для любой будущей модульной системы JS:</target>
        </trans-unit>
        <trans-unit id="ad652546dd574e8e72a3108f5d47d4b2288b681a" translate="yes" xml:space="preserve">
          <source>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</source>
          <target state="translated">Модули AMD требуют меньше инструментов,меньше проблем с краем корпуса и лучшую отладочную поддержку.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="1461f8efdc9427af7da00c09555d68f10f4a74dd" translate="yes" xml:space="preserve">
          <source>Ability to load nested dependencies</source>
          <target state="translated">Способность загружать вложенные зависимости</target>
        </trans-unit>
        <trans-unit id="ec9c1eee60a6c8d412e86494c4538774b81ce815" translate="yes" xml:space="preserve">
          <source>Advanced Usage</source>
          <target state="translated">Расширенное использование</target>
        </trans-unit>
        <trans-unit id="c858288df721516bc4030ba55bfa6335a7f04d3c" translate="yes" xml:space="preserve">
          <source>All configuration options</source>
          <target state="translated">Все параметры конфигурации</target>
        </trans-unit>
        <trans-unit id="9f40cf04b3528dd358ff4509828b611ee71bca1f" translate="yes" xml:space="preserve">
          <source>All of them map to loading some/path/some/module.js. Ideally we could choose the CommonJS syntax, since it is likely to get more common over time, and we want to reuse code.</source>
          <target state="translated">Все они отображают карты для загрузки некоторых/пути/сома/модуля.js.В идеале мы могли бы выбрать синтаксис CommonJS,так как он,скорее всего,станет более распространенным со временем,и мы хотим повторно использовать код.</target>
        </trans-unit>
        <trans-unit id="d76cac34f72024eab757bb7877d36d4a84783e5f" translate="yes" xml:space="preserve">
          <source>All the example commands in this page assume Node usage, and running on a Linux/OS X command line. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt; for how to run it in Java.</source>
          <target state="translated">Все примеры команд на этой странице предполагают использование узла и запускаются в командной строке Linux / OS X. См. &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;R.js README,&lt;/a&gt; чтобы узнать, как запустить его на Java.</target>
        </trans-unit>
        <trans-unit id="e7add3732819f23846380c080edcf146c4d1b13a" translate="yes" xml:space="preserve">
          <source>Allows setting a function as the return value. This is really useful for constructor functions. In CommonJS this is more awkward, always having to set a property on the exports object. Node supports module.exports = function () {}, but that is not part of a CommonJS spec.</source>
          <target state="translated">Позволяет установить функцию в качестве возвращаемого значения.Это действительно полезно для конструкторских функций.В CommonJS это более неудобно,всегда нужно устанавливать свойство на экспортируемом объекте.Узел поддерживает модуль.export=функция (){},но это не является частью спецификации CommonJS.</target>
        </trans-unit>
        <trans-unit id="5c0b4dca99dd221c07f2823dbfc63078e8a6ae51" translate="yes" xml:space="preserve">
          <source>Also support &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;. Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</source>
          <target state="translated">Также поддерживаются &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;плагины &lt;/a&gt;&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; и loader . Плагины загрузчика - отличный способ уменьшить синдром вложенного обратного вызова, который может быть обычным в коде обратного вызова / асинхронного стиля.</target>
        </trans-unit>
        <trans-unit id="e2430ebce59431b0f6de636d393909781098343b" translate="yes" xml:space="preserve">
          <source>Also, document.write() does not work after page load. A great way to get perceived performance for your site is loading code on demand, as the user needs it for their next action.</source>
          <target state="translated">Также функция document.write()не работает после загрузки страницы.Отличный способ получить ощутимую производительность для вашего сайта-это загружать код по требованию,так как он нужен пользователю для их следующего действия.</target>
        </trans-unit>
        <trans-unit id="a15f74e2813a0e5e3d61a221d689634817920be6" translate="yes" xml:space="preserve">
          <source>Also, you can define the config object as the global variable &lt;code&gt;require&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; require.js is loaded, and have the values applied automatically. This example specifies some dependencies to load as soon as require.js defines require():</source>
          <target state="translated">Кроме того, вы можете определить объект конфигурации как глобальную переменную &lt;code&gt;require&lt;/code&gt; &lt;strong&gt;до&lt;/strong&gt; загрузки require.js и применить значения автоматически. В этом примере указываются некоторые зависимости для загрузки, как только require.js определяет require ():</target>
        </trans-unit>
        <trans-unit id="5180f71902ee087330414f177079b5a4dd04dc5e" translate="yes" xml:space="preserve">
          <source>Alternative Syntax</source>
          <target state="translated">Альтернативный синтаксис</target>
        </trans-unit>
        <trans-unit id="e8b3e3a9af7aa6f439fd569409a7504a25bbf037" translate="yes" xml:space="preserve">
          <source>An error occured when the define() function was called for the module given in the error message. It is an error with the code logic inside the define function. The error could happen inside a require callback.</source>
          <target state="translated">Ошибка возникла при вызове функции define()для модуля,указанного в сообщении об ошибке.Это ошибка с логикой кода внутри функции define.Ошибка может произойти внутри требуемого обратного вызова.</target>
        </trans-unit>
        <trans-unit id="98ed11116a42389468f7dc53908918bc380fc101" translate="yes" xml:space="preserve">
          <source>An example plugin that does not do anything interesting, just does a normal require to load a JS module:</source>
          <target state="translated">Пример плагина,который не делает ничего интересного,просто делает обычное требование для загрузки JS модуля:</target>
        </trans-unit>
        <trans-unit id="0538812e80ae1405069dd76f452c8a132050945b" translate="yes" xml:space="preserve">
          <source>An example plugin's load function that uses onload.fromText():</source>
          <target state="translated">Пример функции загрузки плагина,использующей onload.fromText():</target>
        </trans-unit>
        <trans-unit id="b4a866eb59039f47e37643f1a1f3ce8fc67b0a81" translate="yes" xml:space="preserve">
          <source>An example: suppose there is an &lt;b&gt;index!&lt;/b&gt; plugin that will load a module name given an index. This is a contrived example, just to illustrate the concept. A module may reference an index! resource like so:</source>
          <target state="translated">Пример: предположим, есть &lt;b&gt;индекс! &lt;/b&gt;плагин, который загрузит имя модуля по индексу. Это надуманный пример, просто чтобы проиллюстрировать концепцию. Модуль может ссылаться на индекс! ресурс вроде так:</target>
        </trans-unit>
        <trans-unit id="207a2adf208957c6bc485c22ac086554f8dec108" translate="yes" xml:space="preserve">
          <source>An object literal with a property of &quot;root&quot; defines this module. That is all you have to do to set the stage for later localization work.</source>
          <target state="translated">Объект-литерал со свойством &quot;root&quot; определяет этот модуль.Это все,что нужно сделать,чтобы подготовить почву для дальнейшей работы по локализации.</target>
        </trans-unit>
        <trans-unit id="099426cf6ef74281640e7d0c78dc622640eee3d9" translate="yes" xml:space="preserve">
          <source>And a &lt;code&gt;require(['compute'])&lt;/code&gt; is done, then lib/compute/main.js will have the module name of 'compute'. When it asks for './extras', that is resolved relative to 'compute', so 'compute/./extras', which normalizes to just 'extras'. Since there is no paths config for that module name, the path generated will be for 'lib/extras.js', which is incorrect.</source>
          <target state="translated">И &lt;code&gt;require(['compute'])&lt;/code&gt; выполнено, тогда lib / compute / main.js будет иметь имя модуля 'compute'. Когда он запрашивает './extras', он разрешается относительно 'compute', поэтому 'compute /./ extras', который нормализуется только до 'extras'. Поскольку для этого имени модуля нет конфигурации путей, сгенерированный путь будет для lib / extras.js, что неверно.</target>
        </trans-unit>
        <trans-unit id="70ae90af3ca9f9d0ea4a9db7f8c6a12852cd8aed" translate="yes" xml:space="preserve">
          <source>And this is the syntax used by RequireJS. There is also a simplified syntax if you just want to load some plain JavaScript files that do not define modules:</source>
          <target state="translated">И это синтаксис,используемый в RequireJS.Существует также упрощенный синтаксис,если вы просто хотите загрузить несколько простых JavaScript файлов,которые не определяют модули:</target>
        </trans-unit>
        <trans-unit id="4449f0268ad6ee8479ff9c7c4e2df6c1f1b9859d" translate="yes" xml:space="preserve">
          <source>Another option is to construct a module at lib/compute.js that is just &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt;, then there is no need for paths or packages config.</source>
          <target state="translated">Другой вариант - создать модуль в lib / compute.js, который будет просто &lt;code&gt;define(['./compute/main'], function(m) { return m; });&lt;/code&gt; , то нет необходимости в путях или конфигурации пакетов.</target>
        </trans-unit>
        <trans-unit id="fee85b56ae8d4b331dadd0c023881690c91edd87" translate="yes" xml:space="preserve">
          <source>Arguments for onload.fromText() (RequireJS 2.1.0 and later):</source>
          <target state="translated">Аргументы для onload.fromText()(RequireJS 2.1.0 и более поздние):</target>
        </trans-unit>
        <trans-unit id="5f9783b9a3d349980bcc48b99c893615afc66388" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#config&quot;&gt;Configuration Options&lt;/a&gt;, multiple versions of a module can be loaded in a page by using different &quot;context&quot; configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</source>
          <target state="translated">Как упоминалось в &lt;a href=&quot;#config&quot;&gt;разделе &amp;laquo;Параметры конфигурации&amp;raquo;&lt;/a&gt; , на страницу можно загрузить несколько версий модуля с помощью различных параметров конфигурации &amp;laquo;контекста&amp;raquo;. require.config () возвращает функцию require, которая будет использовать конфигурацию контекста. Вот пример, который загружает две разные версии альфа- и бета-модулей (этот пример взят из одного из тестовых файлов):</target>
        </trans-unit>
        <trans-unit id="ea7f9bd561b8a7ce517ee1f3cd30f4270f35e445" translate="yes" xml:space="preserve">
          <source>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until &lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;ticket 15616&lt;/a&gt; has been resolved.</source>
          <target state="translated">Начиная с Dojo 1.8, Dojo преобразовала свои модули в модули AMD. Однако Dojo использует некоторые плагины загрузчика, а API плагинов загрузчика все еще находятся в режиме черновика для AMD. Таким образом, хотя некоторые модули из Dojo можно использовать с RequireJS, будет сложно использовать весь Dojo. Лучше всего использовать загрузчик AMD Dojo, пока не будет разрешен &lt;a href=&quot;http://bugs.dojotoolkit.org/ticket/15616&quot;&gt;тикет 15616&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea33aedaa4d7ea4deb903138644e1b39c3f252e9" translate="yes" xml:space="preserve">
          <source>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until &lt;a href=&quot;https://bugs.dojotoolkit.org/ticket/15616&quot;&gt;ticket 15616&lt;/a&gt; has been resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f956f6f4e007b657480bf449c13457e00bbb46a" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.1.16, RequireJS can be used in &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn&lt;/a&gt;, Java 8+'s JavaScript engine, via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">По RequireJS 2.1.16, RequireJS может быть использован в &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html&quot;&gt;Nashorn&lt;/a&gt; , Java 8 + s JavaScript двигателя, через &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;адаптер r.js&lt;/a&gt; . Смотрите &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;в r.js README&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="60c4529d32d26fca43bdc4a391d37434329a4c47" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, the optimizer can generate the bundles config and insert it into the top level requirejs.config() call. See the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;bundlesConfigOutFile&lt;/a&gt; build config option for more details.</source>
          <target state="translated">Начиная с RequireJS 2.2.0, оптимизатор может генерировать конфигурацию пакетов и вставлять ее в вызов requirejs.config () верхнего уровня. Дополнительные &lt;a href=&quot;https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641&quot;&gt;сведения&lt;/a&gt; см. В параметре конфигурации сборки bundlesConfigOutFile .</target>
        </trans-unit>
        <trans-unit id="1ac12d0c37c15f175b2b09c1a99a6ea4b0d1db20" translate="yes" xml:space="preserve">
          <source>As of RequireJS 2.2.0, urlArgs can be a function. If a function, it will receive the module ID and the URL as parameters, and it should return a string that will be added to the end of the URL. Return an empty string if no args. Be sure to take care of adding the '?' or '&amp;amp;' depending on the existing state of the URL. Example:</source>
          <target state="translated">Начиная с RequireJS 2.2.0 urlArgs может быть функцией. Если функция, она получит идентификатор модуля и URL-адрес в качестве параметров и должна вернуть строку, которая будет добавлена ​​в конец URL-адреса. Если аргументов нет, вернуть пустую строку. Обязательно позаботьтесь о добавлении &quot;?&quot; или '&amp;amp;' в зависимости от существующего состояния URL-адреса. Пример:</target>
        </trans-unit>
        <trans-unit id="e7485868f6989d6066fcc487315af6201517447b" translate="yes" xml:space="preserve">
          <source>As of mid-October 2011, AMD already has good adoption on the web:</source>
          <target state="translated">По состоянию на середину октября 2011 года,драм уже хорошо принят в Интернете:</target>
        </trans-unit>
        <trans-unit id="80555381aeb072f79005f4cc1445ebb0289e5ba6" translate="yes" xml:space="preserve">
          <source>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</source>
          <target state="translated">Начиная с версии 0.12,RequireJS можно запускать внутри Web Worker.Просто используйте importScripts()внутри веб-работника для загрузки require.js (или JS-файла,содержащего определение require()),а затем вызывайте require.</target>
        </trans-unit>
        <trans-unit id="29459a7e5ab1b732a2e1cc31627dce05f38a47fa" translate="yes" xml:space="preserve">
          <source>As of version 2.1.2, there are some speed shortcuts the optimizer will take by default if &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;none&quot;&lt;/code&gt;. However, if you are using &lt;code&gt;&quot;none&quot;&lt;/code&gt; for &lt;strong&gt;optimize&lt;/strong&gt; and you are planning to minify the built files after the optimizer runs, then you should turn set &lt;strong&gt;normalizeDirDefines&lt;/strong&gt; to &lt;code&gt;&quot;all&quot;&lt;/code&gt; so that define() calls are normalized correctly to withstand minification. If you are doing minification via the &lt;strong&gt;optimize&lt;/strong&gt; option, then you do not need to worry about setting this option.</source>
          <target state="translated">Начиная с версии 2.1.2, оптимизатор будет использовать несколько сокращений скорости по умолчанию, если для параметра &lt;strong&gt;optimize&lt;/strong&gt; установлено значение &lt;code&gt;&quot;none&quot;&lt;/code&gt; . Однако, если вы используете &lt;code&gt;&quot;none&quot;&lt;/code&gt; для &lt;strong&gt;оптимизации&lt;/strong&gt; и планируете минимизировать созданные файлы после запуска оптимизатора, вам следует установить для set &lt;strong&gt;normalizeDirDefines&lt;/strong&gt; значение &lt;code&gt;&quot;all&quot;&lt;/code&gt; чтобы вызовы define () были нормализованы правильно, чтобы выдержать минимизацию. Если вы выполняете минификацию с помощью параметра &lt;strong&gt;оптимизации&lt;/strong&gt; , вам не нужно беспокоиться об установке этого параметра.</target>
        </trans-unit>
        <trans-unit id="9145a4861db481e2d9d34b18ece0513ecc45236b" translate="yes" xml:space="preserve">
          <source>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</source>
          <target state="translated">Как видно из приведенного выше комментария,если функция require()асинхронизирована,то этот код не будет работать.Однако,загрузка скриптов синхронно в браузере убивает производительность.Так что же делать?</target>
        </trans-unit>
        <trans-unit id="71cb8a746a0b21f126d1b3dc8bf16feb9f665d4a" translate="yes" xml:space="preserve">
          <source>Assembly gets harder</source>
          <target state="translated">Монтаж усложняется</target>
        </trans-unit>
        <trans-unit id="03af7d03d9d2928a8a7513419105d33c5a27b3b5" translate="yes" xml:space="preserve">
          <source>Async vs Sync</source>
          <target state="translated">Async vs Sync</target>
        </trans-unit>
        <trans-unit id="ee31840f6d717751adeb5c5c527bd4f26f71567c" translate="yes" xml:space="preserve">
          <source>Asynchronously loading dependencies should use an array to list the dependencies:</source>
          <target state="translated">Асинхронно загружаемые зависимости должны использовать массив для перечисления зависимостей:</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="cae1fefc0fed8a8035298bfca8fc8834c8f0ea50" translate="yes" xml:space="preserve">
          <source>Be sure that &lt;strong&gt;require('name')&lt;/strong&gt; only occurs inside a define() definition function or a require() callback function, never in the global space by its own.</source>
          <target state="translated">Убедитесь, что &lt;strong&gt;require ('name')&lt;/strong&gt; встречается только внутри функции определения define () или функции обратного вызова require (), а не в глобальном пространстве отдельно.</target>
        </trans-unit>
        <trans-unit id="061f3af77c543d3a0a6689e17f716e283cf79710" translate="yes" xml:space="preserve">
          <source>Be sure to load all scripts that call define() via the RequireJS API. Do not manually code script tags in HTML to load scripts that have define() calls in them.</source>
          <target state="translated">Обязательно загрузите все скрипты,которые вызывают функцию define()через API RequireJS.Не кодируйте вручную теги скриптов в HTML для загрузки скриптов,которые вызывают функцию define().</target>
        </trans-unit>
        <trans-unit id="647ec165a4f826f7e261c899585db87edb8c388d" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#2&quot;&gt;notes in section 2&lt;/a&gt; about configuring RequireJS so that it can load node-only modules installed via npm.</source>
          <target state="translated">Обязательно прочтите &lt;a href=&quot;#2&quot;&gt;примечания в разделе 2&lt;/a&gt; о настройке RequireJS, чтобы он мог загружать модули только для узлов, установленные через npm.</target>
        </trans-unit>
        <trans-unit id="7083451a53803294578ca8c94dc5e67867059b3f" translate="yes" xml:space="preserve">
          <source>Before RequireJS 2.1.0, onload.fromText accepted a moduleName as the first argument: &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt;, and the loader plugin had to manually call &lt;code&gt;require([moduleName], onload)&lt;/code&gt; after the onload.fromText() call.</source>
          <target state="translated">До RequireJS 2.1.0 onload.fromText принимал в качестве первого аргумента &lt;code&gt;onload.fromText(moduleName, text)&lt;/code&gt; : onload.fromText (имя модуля, текст) , а плагин загрузчика должен был вручную вызывать &lt;code&gt;require([moduleName], onload)&lt;/code&gt; после вызова onload.fromText () .</target>
        </trans-unit>
        <trans-unit id="d802c768c50f9cd38311161cb5506d85c95396c8" translate="yes" xml:space="preserve">
          <source>Building node modules with AMD or RequireJS</source>
          <target state="translated">Модули построения узлов с AMD или RequireJS</target>
        </trans-unit>
        <trans-unit id="f4bb57495a42320cd55e2ef64aa962be5895b225" translate="yes" xml:space="preserve">
          <source>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</source>
          <target state="translated">Но вот простая истина:воспринимаемая лишняя клавиатура и уровень отступов для использования драмов не имеют значения.Вот куда уходит ваше время при кодировании:</target>
        </trans-unit>
        <trans-unit id="d224d8e44c2e917cdc11b554285947074959608b" translate="yes" xml:space="preserve">
          <source>By properly normalizing the resource name, it allows the loader to cache the value effectively, and to properly build an optimized build layer in the optimizer.</source>
          <target state="translated">Правильно нормализовав имя ресурса,загрузчик может эффективно кэшировать значение и правильно построить оптимизированный слой сборки в оптимизаторе.</target>
        </trans-unit>
        <trans-unit id="5c5266679c4a1ae30bcf0a715ea74c102a8f5466" translate="yes" xml:space="preserve">
          <source>Can I use Node modules already written in the CommonJS module format?</source>
          <target state="translated">Могу ли я использовать модули Node,уже написанные в формате модулей CommonJS?</target>
        </trans-unit>
        <trans-unit id="603116a7697334dd761fc1e602d5cc446c9c6c52" translate="yes" xml:space="preserve">
          <source>Can I use server modules written in the CommonJS module format?</source>
          <target state="translated">Могу ли я использовать серверные модули,написанные в формате модулей CommonJS?</target>
        </trans-unit>
        <trans-unit id="443e9bde1a2ba8d69a35fe518f443310bf6d3b9c" translate="yes" xml:space="preserve">
          <source>Cannot use preserveLicenseComments and generateSourceMaps together</source>
          <target state="translated">Не могу использовать preserveLicenseComments и генерировать карты SourceMaps вместе.</target>
        </trans-unit>
        <trans-unit id="f4bce411019d5b31d73bb53b5b67559d1a3f5d72" translate="yes" xml:space="preserve">
          <source>Catching load failures in IE</source>
          <target state="translated">Обнаружение сбоев нагрузки в IE</target>
        </trans-unit>
        <trans-unit id="f0d0a5b7548043f512ca9ac123eb4d0049ee5dbc" translate="yes" xml:space="preserve">
          <source>Circular Dependencies</source>
          <target state="translated">Циркулярные зависимости</target>
        </trans-unit>
        <trans-unit id="1e8e388c38825d78c8b73b0376db04a076ce7646" translate="yes" xml:space="preserve">
          <source>Clear path to defining the module value. Either use &quot;return value;&quot; or the CommonJS &quot;exports&quot; idiom, which can be useful for circular dependencies.</source>
          <target state="translated">Очистить путь к определению значения модуля.Используйте либо &quot;возвращаемое значение&quot;,либо идиому CommonJS &quot;экспорт&quot;,которая может быть полезна для круговых зависимостей.</target>
        </trans-unit>
        <trans-unit id="680c117376f566afefa1f4b5c4233938c1c4a484" translate="yes" xml:space="preserve">
          <source>Code complexity grows as the site gets bigger</source>
          <target state="translated">Сложность кода растет по мере того,как сайт становится больше.</target>
        </trans-unit>
        <trans-unit id="d6d2ed617694b98c5bd0285a5f46f86c25d55847" translate="yes" xml:space="preserve">
          <source>Combines related scripts together into build layers and minifies them via &lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;UglifyJS&lt;/a&gt; (the default) or &lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt; (an option when using Java).</source>
          <target state="translated">Объединяет связанные скрипты в слои сборки и минимизирует их с помощью &lt;a href=&quot;https://github.com/mishoo/UglifyJS&quot;&gt;UglifyJS&lt;/a&gt; (по умолчанию) или &lt;a href=&quot;https://developers.google.com/closure/compiler/&quot;&gt;Closure Compiler&lt;/a&gt; (опция при использовании Java).</target>
        </trans-unit>
        <trans-unit id="07d154b3af13e40e6878df72ed9863bab9fe1fcc" translate="yes" xml:space="preserve">
          <source>Command line arguments take precedence over build profile settings, and you can mix them together:</source>
          <target state="translated">Аргументы командной строки имеют приоритет над параметрами построения профиля,и вы можете смешивать их вместе:</target>
        </trans-unit>
        <trans-unit id="fbaca3e324c7fb124fc3c0ca9ea74430023f8397" translate="yes" xml:space="preserve">
          <source>Common Errors</source>
          <target state="translated">Общие ошибки</target>
        </trans-unit>
        <trans-unit id="3598d7d42bce6e5debb8491d044313a6d4391ec5" translate="yes" xml:space="preserve">
          <source>Common pitfalls</source>
          <target state="translated">Общие ошибки</target>
        </trans-unit>
        <trans-unit id="377dd01e05316c6519d98a0022d6976f8e76be87" translate="yes" xml:space="preserve">
          <source>CommonJS</source>
          <target state="translated">CommonJS</target>
        </trans-unit>
        <trans-unit id="3dbc94c2a704e3fb93f6eb447d7eed414ca23e94" translate="yes" xml:space="preserve">
          <source>CommonJS Compatibility</source>
          <target state="translated">Совместимость с CommonJS</target>
        </trans-unit>
        <trans-unit id="f20da1f3f4e4045b9fc11b097d1c1c9323eec094" translate="yes" xml:space="preserve">
          <source>CommonJS Notes</source>
          <target state="translated">Обыкновенные облигации</target>
        </trans-unit>
        <trans-unit id="608fa7dcad5c38dcc088238a4da1277a62a4b39a" translate="yes" xml:space="preserve">
          <source>CommonJS: require(&quot;some/module&quot;)</source>
          <target state="translated">CommonJS:require(&quot;some/module&quot;)</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">Опции конфигурации</target>
        </trans-unit>
        <trans-unit id="da75073ccf64da23fa438255a3fdd6e84daac437" translate="yes" xml:space="preserve">
          <source>Contains an URL protocol, like &quot;http:&quot; or &quot;https:&quot;.</source>
          <target state="translated">Содержит URL-протокол,например &quot;http:&quot; или &quot;https:&quot;.</target>
        </trans-unit>
        <trans-unit id="3167f245cbc8d215c6976960c2754d80546e1bdf" translate="yes" xml:space="preserve">
          <source>Conversion Tool</source>
          <target state="translated">Преобразовательный инструмент</target>
        </trans-unit>
        <trans-unit id="cd66685d9cd6b2b42c2db11d0eba3d65d5d8a791" translate="yes" xml:space="preserve">
          <source>Create a build profile, call it app.build.js, and put it in the &lt;strong&gt;scripts&lt;/strong&gt; directory. The app.build.js file can live anywhere, but just be sure to adjust the paths accordingly in the example below -- all paths will be relative to where the app.build.js is located. Example app.build.js:</source>
          <target state="translated">Создайте профиль сборки, назовите его app.build.js и поместите в каталог &lt;strong&gt;скриптов&lt;/strong&gt; . Файл app.build.js может находиться где угодно, но только не забудьте соответствующим образом скорректировать пути в приведенном ниже примере - все пути будут относиться к месту, где находится app.build.js. Пример app.build.js:</target>
        </trans-unit>
        <trans-unit id="1a476a67e498299f27aae69b16e1128f1d91db0d" translate="yes" xml:space="preserve">
          <source>Define a Module</source>
          <target state="translated">Определить модуль</target>
        </trans-unit>
        <trans-unit id="189f4dfcede6fb3e70a016718942f39142659677" translate="yes" xml:space="preserve">
          <source>Define a Module as a Function</source>
          <target state="translated">Определить модуль как функцию</target>
        </trans-unit>
        <trans-unit id="66ccb9e013158fbc3a0890cc84a9136c73c36e93" translate="yes" xml:space="preserve">
          <source>Define a Module with Simplified CommonJS Wrapper</source>
          <target state="translated">Определить модуль с упрощенной Оберткой CommonJS</target>
        </trans-unit>
        <trans-unit id="78e56a3b87783e09008d96bc99a9b226632119a4" translate="yes" xml:space="preserve">
          <source>Define a Module with a Name</source>
          <target state="translated">Определите модуль с именем</target>
        </trans-unit>
        <trans-unit id="c64294aaf8b834dea9d34fbaf4321fc3a5b4f013" translate="yes" xml:space="preserve">
          <source>Define a Module with a name</source>
          <target state="translated">Определить модуль с именем</target>
        </trans-unit>
        <trans-unit id="8c8625f86972268a058a221c6d37f22a9e520f5b" translate="yes" xml:space="preserve">
          <source>Define an I18N Bundle</source>
          <target state="translated">Определите связку I18N</target>
        </trans-unit>
        <trans-unit id="fa75a5475ca40562532f5ffdf64a6ce1181c51de" translate="yes" xml:space="preserve">
          <source>Defined via an immediately executed factory function.</source>
          <target state="translated">Определяется через немедленно выполненную заводскую функцию.</target>
        </trans-unit>
        <trans-unit id="42997a499151458874dda0ecc25c9a1fcfa504a6" translate="yes" xml:space="preserve">
          <source>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a &quot;transport format&quot;, and that group has not agreed on a transport format.</source>
          <target state="translated">Определяет способ включения нескольких модулей в один файл.В терминах CommonJS это &quot;транспортный формат&quot;,и эта группа не согласовала транспортный формат.</target>
        </trans-unit>
        <trans-unit id="fdf3ec7d85deb7255fa2bef9b00a822a98bb25f3" translate="yes" xml:space="preserve">
          <source>Definition Functions</source>
          <target state="translated">Функции определения</target>
        </trans-unit>
        <trans-unit id="faf01da1eac83429ecc9c72c9146d7e09eb9a2f9" translate="yes" xml:space="preserve">
          <source>Definition Functions with Dependencies</source>
          <target state="translated">Функции определения с зависимостями</target>
        </trans-unit>
        <trans-unit id="d8d24b4df469c65b7393a388ec6cf5108cf5cc1b" translate="yes" xml:space="preserve">
          <source>Deployment techniques</source>
          <target state="translated">Методы развертывания</target>
        </trans-unit>
        <trans-unit id="e73a7a403dde32f64dd64c0324b5e45fd6828b65" translate="yes" xml:space="preserve">
          <source>Deployment wants optimized code in just one or a few HTTP calls</source>
          <target state="translated">Развертывание хочет оптимизированный код всего за один или несколько HTTP-вызовов.</target>
        </trans-unit>
        <trans-unit id="f146bd1e1b38bcbf234c5237e3addabe504d35c6" translate="yes" xml:space="preserve">
          <source>Developer wants discrete JS files/modules</source>
          <target state="translated">Разработчику нужны дискретные JS файлы/модули</target>
        </trans-unit>
        <trans-unit id="a481992d7ccb15bb38685fcea241700faca3a3bf" translate="yes" xml:space="preserve">
          <source>Developers have been taught that eval() is bad.</source>
          <target state="translated">Разработчиков учили,что eval()-это плохо.</target>
        </trans-unit>
        <trans-unit id="219a0f230ec1049125aed42d415e5e8b978de144" translate="yes" xml:space="preserve">
          <source>Did not call define() to declare a module.</source>
          <target state="translated">Не вызывала функцию define()для объявления модуля.</target>
        </trans-unit>
        <trans-unit id="328d3aebd3a0aa42c86f5ab59c01d68aa18233bf" translate="yes" xml:space="preserve">
          <source>Do not mix CDN loading with shim config in a build. Example scenario: you load jQuery from the CDN but use the shim config to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise, Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the shim config just delays loading of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the shim config cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory function that will not execute until dependencies are loaded. So the lesson: shim config is a stop-gap measure for non-modular code, legacy code. define()'d modules are better.</source>
          <target state="translated">Не смешивайте загрузку CDN с конфигурацией shim в сборке.Пример сценария:вы загружаете jQuery с CDN,но используете конфигурацию shim для загрузки чего-то вроде базовой версии Backbone,которая зависит от jQuery.Когда вы делаете сборку,убедитесь,что jQuery встроен в собранный файл и не загружайте его с CDN.В противном случае,Магистраль будет вставлена в встроенный файл и выполнится до того,как будет загружен jQuery с CDN.Это связано с тем,что shim-конфигурация просто задерживает загрузку файлов до тех пор,пока не будут загружены зависимости,но не делает никакой автоматической обертки определений.После сборки,зависимости уже обработаны,shim-конфигурация не может отложить выполнение не-define()'d кода до более позднего времени.define()'d модули работают с загруженным CDN кодом после сборки,потому что они правильно обертывают свой исходный код в функцию define factory,которая не будет выполняться до тех пор,пока не будут загружены зависимости.Так что урок:shim config-это стоп-гэп для не-модульного кода,устаревшего кода.Модули с функцией define()'d лучше.</target>
        </trans-unit>
        <trans-unit id="96b6222e1ddbeef44870965e7ae83e15408dd547" translate="yes" xml:space="preserve">
          <source>Do not use named modules for the plugin or the pluginBuilder. The pluginBuilder text contents are used instead of the contents of the plugin file, but that will only work if the files do not call define() with a name.</source>
          <target state="translated">Не используйте именованные модули для плагина или сборщика плагинов.Вместо содержимого файла плагина используется текстовое содержимое плагина,но это будет работать только если файлы не вызываются функцией define()с именем.</target>
        </trans-unit>
        <trans-unit id="939aac5818debe88f05652cab470ae8b364ea867" translate="yes" xml:space="preserve">
          <source>Doesn't Node already have a module loader?</source>
          <target state="translated">Разве у Node уже нет загрузчика модулей?</target>
        </trans-unit>
        <trans-unit id="5461862cf2987931cc425d89eae23192e1a26a75" translate="yes" xml:space="preserve">
          <source>Dojo has used an XHR-based loader with eval() and, while it works, it has been a source of frustration for developers. Dojo has an xdomain loader but it requires the modules to be modified via a build step to use a function wrapper, so that script src=&quot;&quot; tags can be used to load the modules. There are many edge cases and moving parts that create a tax on the developer.</source>
          <target state="translated">Dojo использовала загрузчик на основе XHR с функцией eval()и,хотя она работает,стала источником разочарования для разработчиков.У Dojo есть xdomain loader,но он требует,чтобы модули были модифицированы через этап сборки,чтобы использовать обертку функций,так что теги сценария src=&quot;&quot; могут быть использованы для загрузки модулей.Существует множество краевых случаев и подвижных частей,которые создают налог на разработчика.</target>
        </trans-unit>
        <trans-unit id="8c37874e83716706a25248b1cc2caab10d065981" translate="yes" xml:space="preserve">
          <source>Dojo: dojo.require(&quot;some.module&quot;)</source>
          <target state="translated">Dojo:dojo.require(&quot;некий.модуль&quot;)</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="7f08ea8e56c0fdd9a56781f715142185194a5510" translate="yes" xml:space="preserve">
          <source>Download r.js</source>
          <target state="translated">Скачать r.js</target>
        </trans-unit>
        <trans-unit id="772e282a4cefb734bdd20a55250e8c92a14780f7" translate="yes" xml:space="preserve">
          <source>Download r.js from the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;the download page&lt;/a&gt; and place it in your project.</source>
          <target state="translated">Загрузите r.js со &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;страницы загрузки&lt;/a&gt; и поместите его в свой проект.</target>
        </trans-unit>
        <trans-unit id="1e2c8e900ec69791d402b60b6aaf717dc5250f0a" translate="yes" xml:space="preserve">
          <source>During development it can be useful to use this, however &lt;strong&gt;be sure&lt;/strong&gt; to remove it before deploying your code.</source>
          <target state="translated">Это может быть полезно во время разработки, однако &lt;strong&gt;не забудьте&lt;/strong&gt; удалить его перед развертыванием кода.</target>
        </trans-unit>
        <trans-unit id="cfc0ea631ae7a283acdcc5aaa876bb753365d31e" translate="yes" xml:space="preserve">
          <source>Ease of use for developer but then backed by an optimization tool that helps deployment</source>
          <target state="translated">Простота использования для разработчика,но затем подкреплена инструментом оптимизации,который помогает развертыванию</target>
        </trans-unit>
        <trans-unit id="63b393cc9a4a0d5bf2d8a0ec0b4da8eff38350f3" translate="yes" xml:space="preserve">
          <source>Either use a server to translate CJS modules to something usable in the browser.</source>
          <target state="translated">Либо используйте сервер для перевода модулей CJS на что-нибудь удобное в браузере.</target>
        </trans-unit>
        <trans-unit id="84e9b67a6f981cdb4872ac5dac561f7cf07cccd4" translate="yes" xml:space="preserve">
          <source>EmbedJS</source>
          <target state="translated">EmbedJS</target>
        </trans-unit>
        <trans-unit id="f1f761ede057b4e84e4906c723905d89eef44ed3" translate="yes" xml:space="preserve">
          <source>Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.</source>
          <target state="translated">Инкапсулирует определение модуля.Предоставляет инструменты,позволяющие избежать загрязнения глобального пространства имён.</target>
        </trans-unit>
        <trans-unit id="cf740dd5d26c6fca83cd6c9187c2c8eab6ba10d1" translate="yes" xml:space="preserve">
          <source>Ends in &quot;.js&quot;.</source>
          <target state="translated">заканчивается на &quot;.js&quot;.</target>
        </trans-unit>
        <trans-unit id="ed11fe043f6b0340e5d82d2606fa460b6babef5a" translate="yes" xml:space="preserve">
          <source>Errbacks, when used with &lt;a href=&quot;#undef&quot;&gt;requirejs.undef()&lt;/a&gt;, will allow you to detect if a module fails to load, undefine that module, reset the config to a another location, then try again.</source>
          <target state="translated">Ошибки при использовании с &lt;a href=&quot;#undef&quot;&gt;requirejs.undef ()&lt;/a&gt; позволят вам определить, не загружается ли модуль, отменить определение этого модуля, сбросить конфигурацию в другое место и повторить попытку.</target>
        </trans-unit>
        <trans-unit id="7eaff2b36bd5390e86b360d0c7b6f28ed86dd972" translate="yes" xml:space="preserve">
          <source>Error evaluating module ...</source>
          <target state="translated">Модуль оценки ошибок ...</target>
        </trans-unit>
        <trans-unit id="70578c9a1e198f18d274db253ee3cafd1becb013" translate="yes" xml:space="preserve">
          <source>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the &lt;a href=&quot;#errors&quot;&gt;Handling Errors&lt;/a&gt; section.</source>
          <target state="translated">Ошибки при загрузке службы JSONP обычно обнаруживаются через тайм-ауты для службы, поскольку загрузка тега сценария не дает подробных сведений о сетевых проблемах. Чтобы обнаружить ошибки, вы можете переопределить requirejs.onError (), чтобы получить ошибки. Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;#errors&quot;&gt;Обработка ошибок&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="68e28ee55464a1d1e034b9c2cdd48aa0465e3768" translate="yes" xml:space="preserve">
          <source>Even though this sugared form is referred to as the &quot;simplified CommonJS wrapping&quot;, it is not 100% compatible with CommonJS modules. However, the cases that are not supported would likely break in the browser anyway, since they generally assume synchronous loading of dependencies.</source>
          <target state="translated">Несмотря на то,что эта sugared форма называется &quot;упрощенная упаковка CommonJS&quot;,она не на 100% совместима с модулями CommonJS.Однако,случаи,которые не поддерживаются,скорее всего,все равно сломаются в браузере,так как они обычно предполагают синхронную загрузку зависимостей.</target>
        </trans-unit>
        <trans-unit id="8bdd3805ee03a8fc687719101da0553ac851e064" translate="yes" xml:space="preserve">
          <source>Example loading jquery from a CDN</source>
          <target state="translated">Пример запроса на загрузку с CDN</target>
        </trans-unit>
        <trans-unit id="3efec32df92355a1ca633f6661b69247faea26e1" translate="yes" xml:space="preserve">
          <source>Example setup</source>
          <target state="translated">Пример настройки</target>
        </trans-unit>
        <trans-unit id="dc00f9209ed5fc486b962c6c879b21f1625ebcab" translate="yes" xml:space="preserve">
          <source>Example setup:</source>
          <target state="translated">Пример настройки:</target>
        </trans-unit>
        <trans-unit id="224b367055058734b170711429534306a8ffc7a6" translate="yes" xml:space="preserve">
          <source>Example using jQuery from a CDN</source>
          <target state="translated">Пример использования jQuery с CDN</target>
        </trans-unit>
        <trans-unit id="f4a368325467204d6eea61a556b25125bc35ae17" translate="yes" xml:space="preserve">
          <source>Example using jQuery with shim config</source>
          <target state="translated">Пример использования jQuery с конфигурацией shim</target>
        </trans-unit>
        <trans-unit id="6d4eadd1631e4c221838a04cf62b524bceedd734" translate="yes" xml:space="preserve">
          <source>Example using shim config</source>
          <target state="translated">Пример использования конфигурации shim</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="23b239cd6f051075d94afab2b814784cfd6d8712" translate="yes" xml:space="preserve">
          <source>Examples of existing loader plugins are the &lt;a href=&quot;api#text&quot;&gt;text!&lt;/a&gt; and &lt;a href=&quot;api#i18n&quot;&gt;i18n!&lt;/a&gt; plugins. The text! plugin handles loading text, and the i18n plugin handles loading a JavaScript object that is made up from objects from a few different modules. The object contains localized strings.</source>
          <target state="translated">Примеры существующих плагинов загрузчика - это &lt;a href=&quot;api#text&quot;&gt;текст! &lt;/a&gt;и &lt;a href=&quot;api#i18n&quot;&gt;i18n! &lt;/a&gt;плагины. Текст! плагин обрабатывает загрузку текста, а плагин i18n обрабатывает загрузку объекта JavaScript, который состоит из объектов из нескольких разных модулей. Объект содержит локализованные строки.</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="998f21f8963945821d88b707dca0b2a0f29fdd6f" translate="yes" xml:space="preserve">
          <source>Finally, scripts loaded via document.write() will block page rendering. When looking at reaching the very best performance for your site, this is undesirable.</source>
          <target state="translated">Наконец,скрипты,загруженные через document.write(),будут блокировать рендеринг страниц.Если вы хотите достичь максимальной производительности для вашего сайта,это нежелательно.</target>
        </trans-unit>
        <trans-unit id="175c805bfb026f6dd1ae25e3a67e08f4c3661d04" translate="yes" xml:space="preserve">
          <source>First thing to sort out is a script loading API. Here are some candidates:</source>
          <target state="translated">Первое,что нужно разобрать,это API загрузки скриптов.Вот несколько кандидатов:</target>
        </trans-unit>
        <trans-unit id="a90b34ff72906618ca01c653f046b57a18681b11" translate="yes" xml:space="preserve">
          <source>For &quot;modules&quot; that are just jQuery or Backbone plugins that do not need to export any module value, the shim config can just be an array of dependencies:</source>
          <target state="translated">Для &quot;модулей&quot;,которые являются просто jQuery или Backbone плагинами,которым не нужно экспортировать какое-либо значение модуля,конфигурация shim может быть просто массивом зависимостей:</target>
        </trans-unit>
        <trans-unit id="75ad7374cf0e0eba66583a00969ccff593147427" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;baseUrl&lt;/strong&gt;, it is relative to &lt;strong&gt;appDir&lt;/strong&gt;. If no appDir, then baseUrl is relative to the build.js file, or if just using command line arguments, the current working directory.</source>
          <target state="translated">Для &lt;strong&gt;baseUrl&lt;/strong&gt; это относительно &lt;strong&gt;appDir&lt;/strong&gt; . Если нет appDir, то baseUrl относится к файлу build.js или, если используются аргументы командной строки, к текущему рабочему каталогу.</target>
        </trans-unit>
        <trans-unit id="90082fa061b7ff8b7cd0a448136b2609a1f99a73" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;paths&lt;/strong&gt; and &lt;strong&gt;packages&lt;/strong&gt;, they are relative to &lt;strong&gt;baseUrl&lt;/strong&gt;, just as they are for require.js.</source>
          <target state="translated">Для &lt;strong&gt;путей&lt;/strong&gt; и &lt;strong&gt;пакетов&lt;/strong&gt; они относятся к &lt;strong&gt;baseUrl&lt;/strong&gt; , как и для require.js.</target>
        </trans-unit>
        <trans-unit id="b4888adc510c14f09052a4ead7056d06ab63e997" translate="yes" xml:space="preserve">
          <source>For a list of all options, see &lt;a href=&quot;#options&quot;&gt;all configuration options&lt;/a&gt;.</source>
          <target state="translated">Список всех параметров см. В разделе &lt;a href=&quot;#options&quot;&gt;все параметры конфигурации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41fba1fa8ce86f1c3d45cbe5777638d9c6ca8bd4" translate="yes" xml:space="preserve">
          <source>For command line use, Node is the preferred execution environment. The optimizer runs &lt;strong&gt;much faster&lt;/strong&gt; with Node.</source>
          <target state="translated">Для использования в командной строке предпочтительной средой выполнения является Node. Оптимизатор работает &lt;strong&gt;намного быстрее&lt;/strong&gt; с Node.</target>
        </trans-unit>
        <trans-unit id="46d18226ef9def86d3f91dfb4e33301be9de7112" translate="yes" xml:space="preserve">
          <source>For example, this arrangement will fail randomly when the require.config path for the 'foo' module has not been set prior to it being require()'d later:</source>
          <target state="translated">Например,такое расположение будет случайным,когда путь require.config для модуля 'foo' не был задан до того,как он был задан функцией require()'d позже:</target>
        </trans-unit>
        <trans-unit id="5a202a8b0743195728976863adc4266d26ad81f6" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js' and your build output goes into 'js/build', there will likely be problems with extra, nested files generated on each optimization run. This guidance is only for optimizations that are not single file optimizations.</source>
          <target state="translated">Например,если ваш baseUrl-это 'js',а вывод сборки идет в 'js/build',то,скорее всего,будут проблемы с дополнительными,вложенными файлами,генерируемыми при каждом запуске оптимизации.Это руководство предназначено только для тех оптимизаций,которые не являются однофайловыми оптимизациями.</target>
        </trans-unit>
        <trans-unit id="15a25512db354fba2b1c0f67a759cb1835854dc0" translate="yes" xml:space="preserve">
          <source>For instance, if your baseUrl is 'js', and your optimization targets:</source>
          <target state="translated">Например,если ваш baseUrl-&quot;js&quot;,и ваши цели оптимизации:</target>
        </trans-unit>
        <trans-unit id="ad7ee220a39b0c9430dff0ce64564e3baf2c7f3a" translate="yes" xml:space="preserve">
          <source>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies &lt;strong&gt;must&lt;/strong&gt; be loaded before the shimmed script executes. This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a &lt;code&gt;require([], function (){})&lt;/code&gt; call, then doing a nested &lt;code&gt;require([])&lt;/code&gt; call for the build layer that has the shimmed script.</source>
          <target state="translated">Для локальных многофайловых сборок также применимы приведенные выше рекомендации CDN. Для любого сценария с оболочкой оболочки его зависимости &lt;strong&gt;должны&lt;/strong&gt; быть загружены до выполнения сценария с оболочкой оболочки. Это означает либо создание зависимостей непосредственно на уровне сборки, который включает в себя сценарий с оболочкой, либо загрузку зависимостей с помощью вызова &lt;code&gt;require([], function (){})&lt;/code&gt; , а затем выполнение вложенного вызова &lt;code&gt;require([])&lt;/code&gt; для уровня сборки. который имеет скрипт с оболочкой.</target>
        </trans-unit>
        <trans-unit id="bf3894d920edb907a5af18ac327dfff2aab56c1c" translate="yes" xml:space="preserve">
          <source>For passing config to a &lt;a href=&quot;#packages&quot;&gt;package&lt;/a&gt;, target the main module in the package, not the package ID:</source>
          <target state="translated">Для передачи конфигурации в &lt;a href=&quot;#packages&quot;&gt;пакет&lt;/a&gt; нацелите основной модуль в пакете, а не идентификатор пакета:</target>
        </trans-unit>
        <trans-unit id="63a67215832883c72eac42d92074a84ae8301eb1" translate="yes" xml:space="preserve">
          <source>For properties that are module IDs, they should be module IDs, and not file paths. Examples are &lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;include&lt;/strong&gt;, &lt;strong&gt;exclude&lt;/strong&gt;, &lt;strong&gt;excludeShallow&lt;/strong&gt;, &lt;strong&gt;deps&lt;/strong&gt;.</source>
          <target state="translated">Для свойств, которые являются идентификаторами модулей, они должны быть идентификаторами модулей, а не путями к файлам. Примеры: &lt;strong&gt;name&lt;/strong&gt; , &lt;strong&gt;include&lt;/strong&gt; , &lt;strong&gt;exclude&lt;/strong&gt; , &lt;strong&gt;excludeShallow&lt;/strong&gt; , &lt;strong&gt;deps&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="da2e5f2fc604cad6e80ee143dc25482cb3f5fb40" translate="yes" xml:space="preserve">
          <source>For this case, &lt;a href=&quot;#packages&quot;&gt;packages config&lt;/a&gt; is a better option, since it allows setting the main module up as 'compute', but internally the loader will store the module with the ID of 'compute/main' so that the relative reference for './extras' works.</source>
          <target state="translated">В этом случае &lt;a href=&quot;#packages&quot;&gt;конфигурация пакетов&lt;/a&gt; является лучшим вариантом, поскольку она позволяет настроить основной модуль как 'compute', но внутри загрузчик сохранит модуль с идентификатором 'compute / main', так что относительная ссылка для './ массовки.</target>
        </trans-unit>
        <trans-unit id="daf2b5474bd3235184beeccc554c1df2bdeea4c4" translate="yes" xml:space="preserve">
          <source>Front-end developers need a solution with:</source>
          <target state="translated">Внешние разработчики нуждаются в решении:</target>
        </trans-unit>
        <trans-unit id="21caff7b3dd07a030f4af9d90202d8819054ac0e" translate="yes" xml:space="preserve">
          <source>Function Wrapping</source>
          <target state="translated">Функциональная упаковка</target>
        </trans-unit>
        <trans-unit id="9e47c58fdafb0242e1dee3bfbbe05dddb269aeb3" translate="yes" xml:space="preserve">
          <source>Function wrapping</source>
          <target state="translated">Функциональная упаковка</target>
        </trans-unit>
        <trans-unit id="f3a72ad6704d234f02a07df5cc8686bbb29dc1eb" translate="yes" xml:space="preserve">
          <source>Get the source from the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js repo&lt;/a&gt; and either generate the r.js via &quot;node dist.js&quot;, or grab a snapshot from the &lt;strong&gt;dist&lt;/strong&gt; directory.</source>
          <target state="translated">Получите исходный код из &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;репозитория r.js&lt;/a&gt; и либо сгенерируйте r.js через &amp;laquo;node dist.js&amp;raquo;, либо возьмите снимок из каталога &lt;strong&gt;dist&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74e2a80eaf85ea086577d0cfa162676f02820f46" translate="yes" xml:space="preserve">
          <source>Give an AMD loader a try. You have some choices:</source>
          <target state="translated">Дайте погрузчику AMD попробовать.У тебя есть выбор:</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">Глобальные функции</target>
        </trans-unit>
        <trans-unit id="ce96da2fcb6160b73a5d26f7189c13b3152539b9" translate="yes" xml:space="preserve">
          <source>Global requirejs.onError function</source>
          <target state="translated">Глобальная функция requirejs.onError</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">Обработка ошибок</target>
        </trans-unit>
        <trans-unit id="8997ec42b86be4e01e18491b00b453fd2e899587" translate="yes" xml:space="preserve">
          <source>Having a working, easy to debug module system that works in today's browsers means getting real world experience in making the best module system for JavaScript in the future.</source>
          <target state="translated">Наличие работающей,легко отлаживаемой модульной системы,которая работает в современных браузерах,означает получение реального мирового опыта в создании лучшей модульной системы для JavaScript в будущем.</target>
        </trans-unit>
        <trans-unit id="06408e9afad9005f462f690d3c05a26d7179cd63" translate="yes" xml:space="preserve">
          <source>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called &quot;callback&quot;, so &quot;callback=define&quot; tells the API to wrap the JSON response in a &quot;define()&quot; wrapper:</source>
          <target state="translated">Вот пример,который вызывает конечную точку JSONP API.В этом примере параметр JSONP callback называется &quot;callback&quot;,поэтому &quot;callback=define&quot; говорит API обернуть JSON-ответ в обертку &quot;define()&quot;:</target>
        </trans-unit>
        <trans-unit id="9e0c75f4aeccdb862eae83bcee4b7bc79aafb9f8" translate="yes" xml:space="preserve">
          <source>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths config for them:</source>
          <target state="translated">Вот пример.Он требует версии RequireJS 2.1.0+и предполагает,что backbone.js,underscore.js и jquery.js были установлены в каталоге baseUrl.Если нет,то,возможно,вам понадобится установить для них конфигурацию путей:</target>
        </trans-unit>
        <trans-unit id="d4a46fea6d88fd1965dfa2a0c927c5aaa89170d7" translate="yes" xml:space="preserve">
          <source>Here is how the example directory layout looks with two packages, &lt;strong&gt;cart&lt;/strong&gt; and &lt;strong&gt;store&lt;/strong&gt;:</source>
          <target state="translated">Вот как выглядит пример макета каталога с двумя пакетами, &lt;strong&gt;корзиной&lt;/strong&gt; и &lt;strong&gt;магазином&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="3a88db88697c21ef8d1cb42f13b3c0fb0771f81f" translate="yes" xml:space="preserve">
          <source>How are pieces of JavaScript code defined today?</source>
          <target state="translated">Как определяются куски JavaScript-кода сегодня?</target>
        </trans-unit>
        <trans-unit id="b05b322d83bfb47db730d9d1707bae561b692314" translate="yes" xml:space="preserve">
          <source>How do I use it?</source>
          <target state="translated">Как мне его использовать?</target>
        </trans-unit>
        <trans-unit id="736cbdabaf11b32da124d26c68a2525dfc0b63bc" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with Dojo</source>
          <target state="translated">Как использовать RequireJS с Dojo</target>
        </trans-unit>
        <trans-unit id="99584e4621acdc9224936d99361a8939fa2c7f71" translate="yes" xml:space="preserve">
          <source>How to use RequireJS with jQuery</source>
          <target state="translated">Как использовать RequireJS с jQuery</target>
        </trans-unit>
        <trans-unit id="baa492ec7a0eb06bdf669c1f811a659737516a9d" translate="yes" xml:space="preserve">
          <source>However, for the minifier to accurately construct a source map, the minified source cannot be modified in any way, so &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; is incompatible with &lt;strong&gt;generateSourceMaps&lt;/strong&gt;. generateSourceMaps was introduced in version 2.1.2 of the optimizer.</source>
          <target state="translated">Однако, чтобы минификатор мог точно построить исходную карту, минифицированный источник не может быть изменен каким-либо образом, поэтому &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; несовместима с &lt;strong&gt;generateSourceMaps&lt;/strong&gt; . generateSourceMaps был представлен в оптимизаторе версии 2.1.2.</target>
        </trans-unit>
        <trans-unit id="06764a60d7302cd5011c01b08065e6465af17bde" translate="yes" xml:space="preserve">
          <source>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the &lt;a href=&quot;#config-shim&quot;&gt;shim&lt;/a&gt; config to specify string exports for anything that does not use define(), then if you set the &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; config value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</source>
          <target state="translated">Однако, если вы находитесь в проекте, который, как вы знаете, использует define () для объявления всех своих модулей, или он использует конфигурацию &lt;a href=&quot;#config-shim&quot;&gt;прокладки&lt;/a&gt; для определения экспорта строк для всего, что не использует define (), тогда, если вы установите &lt;a href=&quot;#config-enforceDefine&quot;&gt;значение&lt;/a&gt; конфигурации enforceDefine значение true, загрузчик может подтвердить загрузку сценария, проверив вызов define () или наличие глобального значения экспорта оболочки.</target>
        </trans-unit>
        <trans-unit id="dec98a5a8a1a825635cf9d8999487f368e4da493" translate="yes" xml:space="preserve">
          <source>However, in the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; we cannot just execute that script directly. Ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first. But we do not have access to the script before it is executed.</source>
          <target state="translated">Однако в &lt;a href=&quot;#4&quot;&gt;примере Async vs Sync&lt;/a&gt; мы не можем просто выполнить этот сценарий напрямую. В идеале мы могли бы узнать зависимости require () до того, как выполнить скрипт, и убедиться, что эти зависимости загружаются первыми. Но у нас нет доступа к скрипту до его выполнения.</target>
        </trans-unit>
        <trans-unit id="dfbdab0a1069903e763d697a837c846906f023f0" translate="yes" xml:space="preserve">
          <source>However, it is more likely that you do not want to include that resource in the build. If the script does not have any dependencies, or you do not want to include its dependencies or will be including them in another way, then you can use the special &lt;strong&gt;'empty:' scheme&lt;/strong&gt; in the paths config to just skip the file when doing an optimization.</source>
          <target state="translated">Однако более вероятно, что вы не захотите включать этот ресурс в сборку. Если у скрипта нет никаких зависимостей, или вы не хотите включать его зависимости или будете включать их другим способом, то вы можете использовать специальную &lt;strong&gt;схему 'empty:'&lt;/strong&gt; в конфигурации путей, чтобы просто пропустить файл при выполнении оптимизация.</target>
        </trans-unit>
        <trans-unit id="d180421a35263e9cbc4e5f01cb5316f24e8911c5" translate="yes" xml:space="preserve">
          <source>However, it still has the &lt;a href=&quot;#4&quot;&gt;Async vs Sync example&lt;/a&gt; problem: ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first.</source>
          <target state="translated">Однако у него все еще есть проблема &lt;a href=&quot;#4&quot;&gt;примера Async vs Sync&lt;/a&gt; : в идеале мы могли бы знать зависимости require () до выполнения скрипта и убедиться, что эти зависимости загружаются первыми.</target>
        </trans-unit>
        <trans-unit id="37ed8422dc4b848a82f406f48365216fdc2513aa" translate="yes" xml:space="preserve">
          <source>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. &lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;Download the module&lt;/a&gt; and use it in your project like so:</source>
          <target state="translated">Однако не все используемые браузеры поддерживают DOMContentLoaded. Модуль domReady реализует кроссбраузерный метод для определения готовности DOM. &lt;a href=&quot;http://requirejs.org/docs/download.html#domReady&quot;&gt;Загрузите модуль&lt;/a&gt; и используйте его в своем проекте так:</target>
        </trans-unit>
        <trans-unit id="0251cde2be08202fcc02450703af91a17d8975c1" translate="yes" xml:space="preserve">
          <source>However, tools that combine multiple modules together for performance need a way to give names to each module in the optimized file. For that, AMD allows a string as the first argument to define():</source>
          <target state="translated">Тем не менее,инструменты,которые объединяют несколько модулей вместе для повышения производительности необходимо дать имена каждому модулю в оптимизированном файле.Для этого AMD позволяет использовать строку в качестве первого аргумента для определения():</target>
        </trans-unit>
        <trans-unit id="487b1f01c66606179dbf2f41be406387d07ea6c5" translate="yes" xml:space="preserve">
          <source>However, we need something that works well in the browser. The CommonJS require() is a synchronous call, it is expected to return the module immediately. This does not work well in the browser.</source>
          <target state="translated">Однако,нам нужно что-то,что хорошо работает в браузере.CommonJS require()является синхронным вызовом,ожидается,что модуль вернётся немедленно.Это не работает хорошо в браузере.</target>
        </trans-unit>
        <trans-unit id="6d820ffdc00059491579804e4bd96d555e261655" translate="yes" xml:space="preserve">
          <source>I believe it is important to not force the use of a runtime server process to transform code:</source>
          <target state="translated">Я считаю,что важно не форсировать использование серверного процесса для преобразования кода:</target>
        </trans-unit>
        <trans-unit id="ff857cf4b37b9b4eaa5dda5da862a37bf0231191" translate="yes" xml:space="preserve">
          <source>IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. For the above code sample, the code just expects something that implements the jQuery API and behavior. It does not have to be jQuery.</source>
          <target state="translated">Идентификаторы могут быть сопоставлены с различными путями.Это позволяет заменять реализацию.Это отлично подходит для создания макетов для юнит-тестирования.Для приведенного выше примера кода,код просто ожидает чего-то,что реализует jQuery API и поведение.Это не обязательно должен быть jQuery.</target>
        </trans-unit>
        <trans-unit id="ccf772d613332cb26f229f7f1c3711365b71cd6c" translate="yes" xml:space="preserve">
          <source>Ideally the scripts you load will be modules that are defined by calling &lt;a href=&quot;#define&quot;&gt;define()&lt;/a&gt;. However, you may need to use some traditional/legacy &quot;browser globals&quot; scripts that do not express their dependencies via define(). For those, you can use the &lt;a href=&quot;#config-shim&quot;&gt;shim config&lt;/a&gt;. To properly express their dependencies.</source>
          <target state="translated">В идеале загружаемые вами скрипты будут модулями, которые определяются путем вызова &lt;a href=&quot;#define&quot;&gt;define ()&lt;/a&gt; . Однако вам может потребоваться использовать некоторые традиционные / устаревшие сценарии &amp;laquo;глобальных браузеров&amp;raquo;, которые не выражают свои зависимости через define (). Для них вы можете использовать &lt;a href=&quot;#config-shim&quot;&gt;конфигурацию прокладки&lt;/a&gt; . Чтобы правильно выразить свои зависимости.</target>
        </trans-unit>
        <trans-unit id="8bc66eb67c7dbf88c0c91113e3a440efe63a9356" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;all of your modules&lt;/strong&gt; (including any third party jQuery plugins or library code that depend on jQuery) are AMD compatible and you want to avoid having $ or jQuery in the global namespace when they call &lt;code&gt;requirejs(['jquery'])&lt;/code&gt;, you can use the &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt; to map the use of jQuery to a module that calls noConflict and returns that value of jQuery for the 'jquery' module ID.</source>
          <target state="translated">Если &lt;strong&gt;все ваши модули&lt;/strong&gt; (включая любые сторонние плагины jQuery или код библиотеки, зависящие от jQuery) совместимы с AMD и вы не хотите, чтобы $ или jQuery &lt;code&gt;requirejs(['jquery'])&lt;/code&gt; в глобальном пространстве имен, когда они вызывают requirejs (['jquery']) , вы можете используйте &lt;a href=&quot;api#config-map&quot;&gt;конфигурацию карты&lt;/a&gt; для сопоставления использования jQuery с модулем, который вызывает noConflict и возвращает это значение jQuery для идентификатора модуля jquery.</target>
        </trans-unit>
        <trans-unit id="0d09b91ed8f5ecda7ebb9c933cb5789a594eb6c1" translate="yes" xml:space="preserve">
          <source>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;loader plugins&lt;/a&gt;, and paths-based module IDs.</source>
          <target state="translated">Если модульная система JS не может предоставить вышеуказанные функции, она находится в существенном невыгодном положении по сравнению с AMD и связанными с ней API-интерфейсами в отношении требований &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;обратного вызова&lt;/a&gt; , &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins&quot;&gt;подключаемых&lt;/a&gt; модулей загрузчика и идентификаторов модулей на основе путей.</target>
        </trans-unit>
        <trans-unit id="923ff2f6c2d2940aa6cfdc5a2817aaecc5e810e7" translate="yes" xml:space="preserve">
          <source>If a plugin does not implement normalize, then the loader will try to normalize the resource name using the normal module name rules.</source>
          <target state="translated">Если плагин не реализует нормализацию,то загрузчик попытается нормализовать имя ресурса,используя обычные правила именования модулей.</target>
        </trans-unit>
        <trans-unit id="e73a84c56940c8d1218f3e2d895a4872504fde03" translate="yes" xml:space="preserve">
          <source>If doing a whole project optimization, but only want to minify the build layers specified in &lt;strong&gt;modules&lt;/strong&gt; options and not the rest of the JS files in the build output directory, you can set &lt;strong&gt;skipDirOptimize&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если вы оптимизируете весь проект, но хотите минимизировать только слои сборки, указанные в параметрах &lt;strong&gt;модулей&lt;/strong&gt; , а не остальные файлы JS в выходном каталоге сборки, вы можете установить для &lt;strong&gt;skipDirOptimize&lt;/strong&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70533f68a7c93619cec8126932c9830808b8e124" translate="yes" xml:space="preserve">
          <source>If in IE, check for an HTTP 404 error or a JavaScript sytnax error by using a script debugger.</source>
          <target state="translated">Если в IE,проверьте наличие ошибки HTTP 404 или ошибки синтаксиса JavaScript с помощью отладчика скриптов.</target>
        </trans-unit>
        <trans-unit id="d06fb6574033aac10ae536e27b312a12a1437aa4" translate="yes" xml:space="preserve">
          <source>If it is not possible to upgrade the shimmed code to use AMD define() calls, as of RequireJS 2.1.11, the optimizer has a &lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;wrapShim build option&lt;/a&gt; that will try to automatically wrap the shimmed code in a define() for a build. This changes the scope of shimmed dependencies, so it is not guaranteed to always work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone, it can be helpful.</source>
          <target state="translated">Если невозможно обновить код с оболочкой оболочки для использования вызовов AMD define (), начиная с RequireJS 2.1.11, оптимизатор имеет &lt;a href=&quot;https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68&quot;&gt;параметр сборки wrapShim&lt;/a&gt; , который попытается автоматически обернуть код оболочки с помощью функции define () для сборки. Это изменяет объем совместимых с оболочкой зависимостей, поэтому не гарантируется, что она всегда будет работать, но, например, для зависимостей с оболочкой с оболочкой, которые зависят от версии Backbone AMD, это может быть полезно.</target>
        </trans-unit>
        <trans-unit id="cbcb9f444492d4850b289deb7e4380b5fd3bb621" translate="yes" xml:space="preserve">
          <source>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a &lt;strong&gt;data-main&lt;/strong&gt; attribute is used, that path will become the baseUrl.</source>
          <target state="translated">Если в конфигурации явно не задан baseUrl, значением по умолчанию будет расположение HTML-страницы, которая загружает require.js. Если используется атрибут &lt;strong&gt;data-main&lt;/strong&gt; , этот путь станет baseUrl.</target>
        </trans-unit>
        <trans-unit id="6404b1494958d7d6e06d6a9ab163934604e724f9" translate="yes" xml:space="preserve">
          <source>If on Windows, you may need to type &lt;code&gt;r.js.cmd&lt;/code&gt; instead of &lt;code&gt;r.js&lt;/code&gt;. Or, you can use &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;:</source>
          <target state="translated">Если на Windows, вам , возможно , потребуется ввести &lt;code&gt;r.js.cmd&lt;/code&gt; вместо &lt;code&gt;r.js&lt;/code&gt; . Или вы можете использовать &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c0bdb3e25708d8f7e044c7d3710e40bb157c105e" translate="yes" xml:space="preserve">
          <source>If on Windows, you may need to type &lt;code&gt;r.js.cmd&lt;/code&gt; instead of &lt;code&gt;r.js&lt;/code&gt;. Or, you can use &lt;a href=&quot;https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true&quot;&gt;DOSKEY&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6e5ec8125377aee196b4157ae031deb5846f14" translate="yes" xml:space="preserve">
          <source>If part of a require() callback, all the dependencies need to be listed in the array:</source>
          <target state="translated">Если часть вызова функции require(),то все зависимости должны быть перечислены в массиве:</target>
        </trans-unit>
        <trans-unit id="5e11c69c8bd44c98ec1a92bd548444b902083a8f" translate="yes" xml:space="preserve">
          <source>If part of a shim config, make sure the shim config's exports check is correct.</source>
          <target state="translated">Если это часть конфигурации shim,убедитесь,что проверка экспорта конфигурации shim правильна.</target>
        </trans-unit>
        <trans-unit id="0771fa68bc68f46c7cad59553f87fbed3015f4e1" translate="yes" xml:space="preserve">
          <source>If the &quot;store&quot; package did not follow the &quot;main.js&quot; convention, and looked more like this:</source>
          <target state="translated">Если пакет &quot;store&quot; не соответствовал конвенции &quot;main.js&quot;,а выглядел больше так:</target>
        </trans-unit>
        <trans-unit id="726b8059a1d692c8212c0606dec6c706d075cc32" translate="yes" xml:space="preserve">
          <source>If the error message includes &lt;strong&gt;Use require([])&lt;/strong&gt;, then it was a top-level require call (not a require call inside a define() call) that should be using the async, callback version of require to load the code:</source>
          <target state="translated">Если в сообщении об ошибке указано &lt;strong&gt;Use require ([])&lt;/strong&gt; , то это был вызов верхнего уровня (а не вызов require внутри вызова define ()), который должен использовать асинхронную версию с обратным вызовом require для загрузки кода:</target>
        </trans-unit>
        <trans-unit id="3da1558eec7d161ec9aeacf63f1947075ff1b3c4" translate="yes" xml:space="preserve">
          <source>If the module calls define(), make sure the define call was reached by debugging in a script debugger.</source>
          <target state="translated">Если вызовы модуля определяют(),убедитесь,что вызов определения был достигнут путем отладки в отладчике скрипта.</target>
        </trans-unit>
        <trans-unit id="d640768407ba7527782d61745268bcd8becf18d3" translate="yes" xml:space="preserve">
          <source>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</source>
          <target state="translated">Если модуль не имеет никаких зависимостей,и это просто набор пар имя/значение,то просто передайте объект literal для функции define():</target>
        </trans-unit>
        <trans-unit id="c4bc89c20098e3d217c9feeee11e6aefa259ab00" translate="yes" xml:space="preserve">
          <source>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</source>
          <target state="translated">Если модуль не имеет зависимостей,но должен использовать функцию для выполнения некоторой установочной работы,то определите себя,передайте функцию define():</target>
        </trans-unit>
        <trans-unit id="dd2976ac338c8b322312501c44533eea743a2006" translate="yes" xml:space="preserve">
          <source>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</source>
          <target state="translated">Если модуль имеет зависимости,то первым аргументом должен быть массив имен зависимостей,а вторым-функция определения.Функция будет вызвана для определения модуля после загрузки всех зависимостей.Функция должна возвращать объект,определяющий модуль.Зависимости будут переданы в функцию определения в качестве аргументов функции,перечисленные в том же порядке,что и порядок в массиве зависимостей:</target>
        </trans-unit>
        <trans-unit id="268886bdf3247e5fb6d83a42bdc3c1afdd1fc395" translate="yes" xml:space="preserve">
          <source>If the modules are laid out on disk like this:</source>
          <target state="translated">Если модули разложены на диске таким образом:</target>
        </trans-unit>
        <trans-unit id="3c3a7a2d48579a3fd24b6373c3334acc93d4649e" translate="yes" xml:space="preserve">
          <source>If the problem is the &lt;code&gt;var define&lt;/code&gt; lint approach, use &lt;code&gt;/*global define */&lt;/code&gt; (no space before &quot;global&quot;) comment style instead.</source>
          <target state="translated">Если проблема заключается в подходе &lt;code&gt;var define&lt;/code&gt; lint, используйте вместо него стиль комментария &lt;code&gt;/*global define */&lt;/code&gt; (без пробела перед &amp;laquo;global&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="fe055917e1738e441340d4fd7a9ee5b263683ac9" translate="yes" xml:space="preserve">
          <source>If the problem is the use of loader plugins or anonymous modules but the RequireJS optimizer is not used for file bundling, use the RequireJS optimizer.</source>
          <target state="translated">Если проблема заключается в использовании плагинов загрузчика или анонимных модулей,но для комплектации файла не используется оптимизатор RequireJS,используйте оптимизатор RequireJS.</target>
        </trans-unit>
        <trans-unit id="6afec34eee1181c090fdd3435b03454d82f91ced" translate="yes" xml:space="preserve">
          <source>If this was the paths config:</source>
          <target state="translated">Если бы это была конфигурация путей:</target>
        </trans-unit>
        <trans-unit id="3fe2042d352255fab2f771b63873d6c1d5d861d6" translate="yes" xml:space="preserve">
          <source>If we are creating a new script loader, we can do better.</source>
          <target state="translated">Если мы создадим новый загрузчик сценариев,то сможем сделать это лучше.</target>
        </trans-unit>
        <trans-unit id="c2471cbb8f701f4612ea9f0ec89dbe001ba98766" translate="yes" xml:space="preserve">
          <source>If you are familiar with CommonJS modules, you could instead use &lt;strong&gt;exports&lt;/strong&gt; to create an empty object for the module that is available immediately for reference by other modules. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module. This only works if each module is exporting an object for the module value, not a function:</source>
          <target state="translated">Если вы знакомы с модулями CommonJS, вместо этого вы можете использовать &lt;strong&gt;экспорт&lt;/strong&gt; для создания пустого объекта для модуля, который будет немедленно доступен для справки другими модулями. Делая это с обеих сторон круговой зависимости, вы можете безопасно удерживать другой модуль. Это работает, только если каждый модуль экспортирует объект для значения модуля, а не функцию:</target>
        </trans-unit>
        <trans-unit id="e8ab978d23a4c5d930f4a73ffb4cdaedcb9db803" translate="yes" xml:space="preserve">
          <source>If you are having trouble with the examples below, here are some common pitfalls that might be the source of the problem:</source>
          <target state="translated">Если у вас возникли проблемы с приведенными ниже примерами,вот некоторые общие подводные камни,которые могут быть источником проблемы:</target>
        </trans-unit>
        <trans-unit id="ba0cad9bd089cab72f65d9b6da275ca2f8067cc2" translate="yes" xml:space="preserve">
          <source>If you are listing dependencies in the dependency array, make sure that &lt;strong&gt;require&lt;/strong&gt; and &lt;strong&gt;name&lt;/strong&gt; are in the dependency array:</source>
          <target state="translated">Если вы перечисляете зависимости в массиве зависимостей, убедитесь, что &lt;strong&gt;require&lt;/strong&gt; и &lt;strong&gt;name&lt;/strong&gt; находятся в массиве зависимостей:</target>
        </trans-unit>
        <trans-unit id="ad022743a7df2ffdcd0557108ff5b38fd748951d" translate="yes" xml:space="preserve">
          <source>If you are using the simplified define wrapper, make sure you have &lt;strong&gt;require&lt;/strong&gt; as the first argument to the definition function:</source>
          <target state="translated">Если вы используете упрощенную оболочку определения, убедитесь, что у вас есть &lt;strong&gt;require&lt;/strong&gt; в качестве первого аргумента функции определения:</target>
        </trans-unit>
        <trans-unit id="4e0ee4abad95938db6b89b46529ee3dc2e95d105" translate="yes" xml:space="preserve">
          <source>If you are using uglifyjs to minify the code, &lt;strong&gt;do not&lt;/strong&gt; set the uglify option &lt;code&gt;toplevel&lt;/code&gt; to true, or if using the command line &lt;strong&gt;do not&lt;/strong&gt; pass &lt;code&gt;-mt&lt;/code&gt;. That option mangles the global names that shim uses to find exports.</source>
          <target state="translated">Если вы используете uglifyjs , чтобы Минимизировать код, &lt;strong&gt;не&lt;/strong&gt; установить уродовать вариант &lt;code&gt;toplevel&lt;/code&gt; истинно, или если с помощью командной строки &lt;strong&gt;не&lt;/strong&gt; проходят &lt;code&gt;-mt&lt;/code&gt; . Эта опция изменяет глобальные имена, которые shim использует для поиска экспортируемых файлов.</target>
        </trans-unit>
        <trans-unit id="31e99de161473edbb5082258b810e3d2c3da191c" translate="yes" xml:space="preserve">
          <source>If you define a circular dependency (&quot;a&quot; needs &quot;b&quot; and &quot;b&quot; needs &quot;a&quot;), then in this case when &quot;b&quot;'s module function is called, it will get an undefined value for &quot;a&quot;. &quot;b&quot; can fetch &quot;a&quot; later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up &quot;a&quot;):</source>
          <target state="translated">Если определить круговую зависимость (&quot;a&quot; нужно &quot;b&quot;,а &quot;b&quot; нужно &quot;a&quot;),то в этом случае при вызове модульной функции &quot;b&quot; она получит неопределенное значение для &quot;a&quot;.&quot;b&quot; может получить &quot;a&quot; позже после определения модулей с помощью метода require()(обязательно укажите require как зависимость,чтобы для поиска &quot;a&quot; использовался правильный контекст):</target>
        </trans-unit>
        <trans-unit id="c60a6779241f198cb0b63a3cd7149ce07e1aae79" translate="yes" xml:space="preserve">
          <source>If you do not express the dependencies, you will likely get loading errors since RequireJS loads scripts asynchronously and out of order for speed.</source>
          <target state="translated">Если вы не выразите зависимость,то,скорее всего,получите ошибки при загрузке,т.к.RequireJS загружает скрипты асинхронно и не в порядке для скорости.</target>
        </trans-unit>
        <trans-unit id="9663e162bea6d2fd2a76323abdb98db33154de78" translate="yes" xml:space="preserve">
          <source>If you do not want the main-build.js file minified, pass &lt;strong&gt;optimize=none&lt;/strong&gt; in the command above.</source>
          <target state="translated">Если вы не хотите, чтобы файл main-build.js был уменьшен, передайте &lt;strong&gt;optimize = none&lt;/strong&gt; в приведенной выше команде.</target>
        </trans-unit>
        <trans-unit id="001e6439bbf6aa885f14abd4880ee619763d737a" translate="yes" xml:space="preserve">
          <source>If you find you have a problem, and want to report it, use the &lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues page&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружите, что у вас возникла проблема, и хотите сообщить о ней, воспользуйтесь &lt;a href=&quot;http://github.com/requirejs/r.js/issues&quot;&gt;страницей r.js GitHub Issues&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84595edc012fcbdfa0cbccb569dfe1e9673c800c" translate="yes" xml:space="preserve">
          <source>If you find you have a problem, and want to report it, use the &lt;a href=&quot;https://github.com/requirejs/r.js/issues&quot;&gt;r.js GitHub Issues page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63d9b75d9f443bf6b7818c6648924354e9520f7" translate="yes" xml:space="preserve">
          <source>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</source>
          <target state="translated">Если вы получаете ошибку с requireModules,это,вероятно,означает,что другие модули,зависящие от модулей в массиве requireModules,не определены.</target>
        </trans-unit>
        <trans-unit id="6de57f65ff4fa1cadce3b83f694a69d1b4133325" translate="yes" xml:space="preserve">
          <source>If you have many modules to convert, the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js project&lt;/a&gt; has a converter tool built into the r.js file. Give it the path to the directory you want to convert and an output directory:</source>
          <target state="translated">Если вам нужно преобразовать много модулей, в &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;проект r.js&lt;/a&gt; встроен инструмент преобразования в файл r.js. Дайте ему путь к каталогу, который вы хотите преобразовать, и выходной каталог:</target>
        </trans-unit>
        <trans-unit id="9620284a6bc32590c3169f3f4b48d289a07d4f27" translate="yes" xml:space="preserve">
          <source>If you have modules that are in the traditional CommonJS module format, then you can easily convert them to work with RequireJS. Not all modules will convert cleanly to the new format. Types of modules that may not convert well:</source>
          <target state="translated">Если у вас есть модули в традиционном модульном формате CommonJS,то вы можете легко конвертировать их для работы с RequireJS.Не все модули будут преобразованы в новый формат в чистом виде.Типы модулей,которые могут плохо конвертироваться:</target>
        </trans-unit>
        <trans-unit id="5a0f889c91ca5d1dd6ba34bf9e33e0c53924951a" translate="yes" xml:space="preserve">
          <source>If you just have a few modules to convert, then all you need to do is wrap the module in this code:</source>
          <target state="translated">Если у вас есть всего несколько модулей для конвертирования,то все,что вам нужно сделать,это обернуть модуль в этот код:</target>
        </trans-unit>
        <trans-unit id="290bb6c87f9786e352e57820066a0d3e3282fb87" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script that has a few named modules, but then try to load an anonymous module that ends up having the same name as one of the named modules in the script loaded by the manually coded script tag.</source>
          <target state="translated">Если вы вручную кодируете тег скрипта в HTML,чтобы загрузить скрипт,имеющий несколько именованных модулей,но затем пытаетесь загрузить анонимный модуль,который в итоге получит то же имя,что и один из именованных модулей в скрипте,загруженном вручную кодируемым тегом скрипта.</target>
        </trans-unit>
        <trans-unit id="c79c7768de0828796b0344821b72ca7c31441ddb" translate="yes" xml:space="preserve">
          <source>If you manually code a script tag in HTML to load a script with an anonymous define() call, this error can occur.</source>
          <target state="translated">Если вручную закодировать тег скрипта в HTML для загрузки скрипта с анонимным вызовом функции define(),эта ошибка может произойти.</target>
        </trans-unit>
        <trans-unit id="e07cad218dbc58c61e09b42087ab5dc1921031f1" translate="yes" xml:space="preserve">
          <source>If you manually code an HTML script tag, be sure it only includes named modules, and that an anonymous module that will have the same name as one of the modules in that file is not loaded.</source>
          <target state="translated">Если вы вручную кодируете тег HTML-скрипта,убедитесь,что он включает только именованные модули,и что анонимный модуль,который будет иметь то же имя,что и один из модулей в этом файле,не загружается.</target>
        </trans-unit>
        <trans-unit id="eec9ccbb226e68d2a8826329d0764fb9286f03a7" translate="yes" xml:space="preserve">
          <source>If you need to set a path like the &quot;core/jquery.tabs&quot; one, use a build.js file with the build options specified as a JavaScript object instead of using command line arguments.</source>
          <target state="translated">Если вам нужно задать путь типа &quot;core/jquery.tabs&quot;,используйте файл build.js с параметрами сборки,указанными в качестве объекта JavaScript,вместо использования аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="9fe94189273fa0c665402c6a532f8ae2540a649a" translate="yes" xml:space="preserve">
          <source>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</source>
          <target state="translated">Если вы предпочитаете не включать корневой пакет в модуль верхнего уровня,вы можете определить его как обычный пакет локали.В этом случае модуль верхнего уровня будет выглядеть как:</target>
        </trans-unit>
        <trans-unit id="ea4e68f347851dad8c4c00882d4e80a08c8f8134" translate="yes" xml:space="preserve">
          <source>If you prefer to not use npm, you can get r.js directly:</source>
          <target state="translated">Если вы предпочитаете не использовать npm,вы можете получить r.js напрямую:</target>
        </trans-unit>
        <trans-unit id="7f9d6c4000e170c67495235bbeaafa76bd8b494d" translate="yes" xml:space="preserve">
          <source>If you then also use &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond&lt;/a&gt; to build your code without require.js, be sure to use the &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;insertRequire&lt;/a&gt; build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</source>
          <target state="translated">Если вы затем также используете &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;миндаль&lt;/a&gt; для создания своего кода без require.js, обязательно используйте &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413&quot;&gt;параметр&lt;/a&gt; сборки insertRequire, чтобы вставить вызов require для основного модуля - который служит той же цели, что и первоначальный вызов require (), что data-main делает.</target>
        </trans-unit>
        <trans-unit id="6d11834f478a454e47eae0e058c9489d1bdeb1ac" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;var define;&lt;/code&gt; at the top of your file for jshint/jslint purposes, this will cause a problem for the optimizer because it avoids parsing files that declare a &lt;code&gt;define&lt;/code&gt; variable, since that may indicate a script that was created by a concatenation of some scripts that use a local define.</source>
          <target state="translated">Если вы используете &lt;code&gt;var define;&lt;/code&gt; в верхней части вашего файла для целей jshint / jslint, это вызовет проблему для оптимизатора, поскольку он избегает синтаксического анализа файлов, объявляющих переменную &lt;code&gt;define&lt;/code&gt; , поскольку это может указывать на сценарий, созданный путем объединения некоторых сценариев, использующих локальный определить.</target>
        </trans-unit>
        <trans-unit id="ca847ebc0250cd99dec110fb3a5f58289151f4c3" translate="yes" xml:space="preserve">
          <source>If you use a similar project layout as specified in the &lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;Start Guide&lt;/a&gt;, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the &lt;strong&gt;scripts&lt;/strong&gt; directory as the top-level project directory):</source>
          <target state="translated">Если вы используете макет проекта, подобный указанному в &lt;a href=&quot;http://requirejs.org/docs/start.html&quot;&gt;Руководстве&lt;/a&gt; по началу работы, начало вашего веб-проекта будет выглядеть примерно так (проекты на основе Node / Rhino аналогичны, просто используйте содержимое каталога &lt;strong&gt;сценариев в&lt;/strong&gt; качестве каталога проекта верхнего уровня. ):</target>
        </trans-unit>
        <trans-unit id="4c692604f116595f04f5b8bd5d70ca44b5c8af4b" translate="yes" xml:space="preserve">
          <source>If you use the loader plugins or anonymous modules (modules that call define() with no string ID) but do not use the RequireJS optimizer to combine files together, this error can occur. The optimizer knows how to name anonymous modules correctly so that they can be combined with other modules in an optimized file.</source>
          <target state="translated">Если вы используете плагины загрузчика или анонимные модули (модули,которые вызывают функцию define()без идентификатора строки),но не используете оптимизатор RequireJS для объединения файлов вместе,эта ошибка может произойти.Оптимизатор знает,как правильно называть анонимные модули,чтобы они могли быть объединены с другими модулями в оптимизированном файле.</target>
        </trans-unit>
        <trans-unit id="feb5637a3fb0c000cd062fa3f3d6df8b64fe1e07" translate="yes" xml:space="preserve">
          <source>If you want to &lt;b&gt;exclude&lt;/b&gt; that file from being included, and just need to map &quot;dependency&quot; for the build (otherwise it will not build), then use the special &quot;empty:&quot; paths config:</source>
          <target state="translated">Если вы хотите &lt;b&gt;исключить&lt;/b&gt; этот файл из включения и вам просто нужно сопоставить &amp;laquo;зависимость&amp;raquo; для сборки (иначе сборка не будет), используйте специальную конфигурацию путей &amp;laquo;empty:&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="c4d84ae38cccd676fef602cccfe8d51ad757c1ac" translate="yes" xml:space="preserve">
          <source>If you want to code a module so that it works with RequireJS and in Node, without requiring users of your library in Node to use RequireJS, then you can use the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; package to do this:</source>
          <target state="translated">Если вы хотите закодировать модуль так, чтобы он работал с RequireJS и в Node, не требуя, чтобы пользователи вашей библиотеки в Node использовали RequireJS, вы можете использовать пакет &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; для этого:</target>
        </trans-unit>
        <trans-unit id="af5b2645f618b5644bc791db1e0847039d902272" translate="yes" xml:space="preserve">
          <source>If you want to do &lt;code&gt;require()&lt;/code&gt; calls in the HTML page, then it is best to not use data-main. data-main is only intended for use when the page just has one main entry point, the data-main script. For pages that want to do inline &lt;code&gt;require()&lt;/code&gt; calls, it is best to nest those inside a &lt;code&gt;require()&lt;/code&gt; call for the configuration:</source>
          <target state="translated">Если вы хотите выполнять вызовы &lt;code&gt;require()&lt;/code&gt; на HTML-странице, лучше не использовать data-main. data-main предназначен для использования только тогда, когда на странице есть только одна основная точка входа, сценарий data-main. Для страниц, которые хотят выполнять встроенные вызовы &lt;code&gt;require()&lt;/code&gt; , лучше всего вложить их внутри вызова &lt;code&gt;require()&lt;/code&gt; для конфигурации:</target>
        </trans-unit>
        <trans-unit id="e7664b7c0117630563d8b0ce1cf3190fcf1304bd" translate="yes" xml:space="preserve">
          <source>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;onResourceLoad API&lt;/a&gt; may be helpful.</source>
          <target state="translated">Если вы хотите выполнить более сложный анализ графа зависимостей для неопределенной работы, может оказаться полезным &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad&quot;&gt;получастный API onResourceLoad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="296789b3d29436db474fc5e4c49a54f6bfbe4190" translate="yes" xml:space="preserve">
          <source>If you want to include require.js with the main.js source, you can use this kind of command:</source>
          <target state="translated">Если вы хотите включить require.js в источник main.js,вы можете использовать команду такого типа:</target>
        </trans-unit>
        <trans-unit id="46ae1d084e30675108b6b0a3e880efee8585a650" translate="yes" xml:space="preserve">
          <source>If you want to include this dependency in the built/optimized file, download the JS file and in the build profile for the optimizer, put in a paths config that points to that local file.</source>
          <target state="translated">Если вы хотите включить эту зависимость в встроенный/оптимизированный файл,скачайте JS-файл и в сборочный профиль оптимизатора,вставьте конфигурацию путей,указывающую на этот локальный файл.</target>
        </trans-unit>
        <trans-unit id="3a65a8e36754343f29f91691e06b17764aa16a5d" translate="yes" xml:space="preserve">
          <source>If you want to install requirejs locally in a project as an npm package, instead of globally:</source>
          <target state="translated">Если вы хотите установить requirejs локально в проекте в виде пакета npm,а не глобально:</target>
        </trans-unit>
        <trans-unit id="164b3d635a3f7c3d266ffda4373f5819b2582504" translate="yes" xml:space="preserve">
          <source>If you want to use AMD but still use the &lt;strong&gt;load one script at the bottom of the HTML page&lt;/strong&gt; approach:</source>
          <target state="translated">Если вы хотите использовать AMD, но по-прежнему используете &lt;strong&gt;загрузку одного скрипта в нижней части HTML-страницы&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="977e480d5d183fc7ba40346f208e1b484206ed16" translate="yes" xml:space="preserve">
          <source>If you want to use RequireJS directly to code your module, and then export a module value to node so that it can be used in other Node programs without requiring that app to use RequireJS, you can use the approach listed in the next example.</source>
          <target state="translated">Если вы хотите использовать RequireJS непосредственно для кодирования вашего модуля,а затем экспортировать значение модуля на узел,чтобы его можно было использовать в других программах Node,не требуя,чтобы приложение использовало RequireJS,вы можете использовать подход,перечисленный в следующем примере.</target>
        </trans-unit>
        <trans-unit id="6f7cb349eb5ac9e5b57bf37db65dc198540d53a6" translate="yes" xml:space="preserve">
          <source>If you want to use define() for your modules but still run them in Node without needing to run RequireJS on the server, see &lt;a href=&quot;#nodeModules&quot;&gt;the section below&lt;/a&gt; about using &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите использовать define () для своих модулей, но по-прежнему запускать их в Node без необходимости запускать RequireJS на сервере, см. &lt;a href=&quot;#nodeModules&quot;&gt;Раздел ниже&lt;/a&gt; об использовании &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cedb40532461d188e89d12caa7374f46648787e1" translate="yes" xml:space="preserve">
          <source>If you want to wrap your built file so it can be used in pages that do not have an AMD loader like RequireJS, see the &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;Optimization FAQ&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите обернуть созданный файл, чтобы его можно было использовать на страницах, не имеющих загрузчика AMD, такого как RequireJS, см. &lt;a href=&quot;http://requirejs.org/docs/faq-optimization.html&quot;&gt;Часто задаваемые вопросы&lt;/a&gt; по оптимизации .</target>
        </trans-unit>
        <trans-unit id="f758dc21534ccb9894490766f0bb0a3354e675a0" translate="yes" xml:space="preserve">
          <source>If you wish to reuse some code that was written in the traditional &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;CommonJS module format&lt;/a&gt; it may be difficult to re-work to the array of dependencies used above, and you may prefer to have direct alignment of dependency name to the local variable used for that dependency. You can use the &lt;a href=&quot;commonjs&quot;&gt;simplified CommonJS wrapper&lt;/a&gt; for those cases:</source>
          <target state="translated">Если вы хотите повторно использовать какой-либо код, который был написан в традиционном &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/1.1.1&quot;&gt;формате модуля CommonJS,&lt;/a&gt; может быть сложно переделать массив зависимостей, использованный выше, и вы можете предпочесть прямое выравнивание имени зависимости с локальной переменной, используемой для этого. зависимость. В таких случаях можно использовать &lt;a href=&quot;commonjs&quot;&gt;упрощенную оболочку CommonJS&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1bbc88d8b7d0dba0bef2316c81d3257b395c963e" translate="yes" xml:space="preserve">
          <source>If your build profile looked like so:</source>
          <target state="translated">Если твой строительный профиль выглядел так:</target>
        </trans-unit>
        <trans-unit id="fa7030a64e81de81778033ae09c733651717e7a7" translate="yes" xml:space="preserve">
          <source>If your code uses tests like the following:</source>
          <target state="translated">Если в вашем коде используются следующие тесты:</target>
        </trans-unit>
        <trans-unit id="33134584d1a1bacbf328e47b02d9ac4ab14c6c31" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;the AMD API&lt;/a&gt;. There is &lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;a discussion list&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;compatibility tests&lt;/a&gt;. By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</source>
          <target state="translated">Реализуйте &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD API&lt;/a&gt; . Есть &lt;a href=&quot;https://groups.google.com/group/amd-implement&quot;&gt;список обсуждения&lt;/a&gt; и &lt;a href=&quot;https://github.com/amdjs/amdjs-tests&quot;&gt;тесты совместимости&lt;/a&gt; . Внедряя AMD, вы уменьшите количество шаблонов многомодульной системы и поможете доказать работоспособность модульной системы JavaScript в сети. Это можно передать обратно в процесс ECMAScript, чтобы улучшить поддержку собственных модулей.</target>
        </trans-unit>
        <trans-unit id="702c01eb821162396b5526b3e65d64751b303b3b" translate="yes" xml:space="preserve">
          <source>In Firefox and WebKit browsers, a line number and file name will be indicated in the error. It can be used to locate the source of the problem. Better isolation of the error can be done by using a debugger to place a breakpoint in the file that contains the error.</source>
          <target state="translated">В браузерах Firefox и WebKit в ошибке будет указан номер строки и имя файла.Это может быть использовано для определения источника проблемы.Лучшая изоляция ошибки может быть сделана с помощью отладчика,чтобы поместить точку останова в файл,который содержит ошибку.</target>
        </trans-unit>
        <trans-unit id="ff0f55e14256af8eb245096429abdcc074495ed5" translate="yes" xml:space="preserve">
          <source>In RequireJS 2.0.*, the &quot;exports&quot; property in the shim config could have been a function instead of a string. In that case, it functioned the same as the &quot;init&quot; property as shown above. The &quot;init&quot; pattern is used in RequireJS 2.1.0+ so a string value for &lt;code&gt;exports&lt;/code&gt; can be used for &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt;, but then allow functional work once the library is known to have loaded.</source>
          <target state="translated">В RequireJS 2.0. * Свойство &quot;exports&quot; в конфигурации оболочки могло быть функцией, а не строкой. В этом случае оно функционировало так же, как свойство &quot;init&quot;, как показано выше. Шаблон &amp;laquo;init&amp;raquo; используется в RequireJS 2.1.0+, поэтому строковое значение для &lt;code&gt;exports&lt;/code&gt; можно использовать для &lt;a href=&quot;#config-enforceDefine&quot;&gt;enforceDefine&lt;/a&gt; , но затем разрешить функциональную работу, как только известно, что библиотека загружена.</target>
        </trans-unit>
        <trans-unit id="ecc029984d4c8bb1667c1c77461dda09354dda68" translate="yes" xml:space="preserve">
          <source>In general though, it is best to use the baseUrl and &quot;paths&quot; config to set paths for module IDs. By doing so, it gives you more flexibility in renaming and configuring the paths to different locations for optimization builds.</source>
          <target state="translated">В общем же,для установки путей для идентификаторов модулей лучше всего использовать конфигурацию baseUrl и &quot;пути&quot;.Это позволит вам более гибко переименовывать и настраивать пути к различным местам сборки оптимизации.</target>
        </trans-unit>
        <trans-unit id="9a0fe9ee95c542b2027e2cf755a45d2afa25ff6e" translate="yes" xml:space="preserve">
          <source>In general, if it is a path, it is relative to the build.js file used to hold the build options, or if just using command line arguments, relative to the current working directory. Example of properties that are file paths: &lt;strong&gt;appDir&lt;/strong&gt;, &lt;strong&gt;dir&lt;/strong&gt;, &lt;strong&gt;mainConfigFile&lt;/strong&gt;, &lt;strong&gt;out&lt;/strong&gt;, &lt;strong&gt;wrap.startFile&lt;/strong&gt;, &lt;strong&gt;wrap.endFile&lt;/strong&gt;.</source>
          <target state="translated">В общем, если это путь, он относится к файлу build.js, который используется для хранения параметров сборки, или, если используется просто аргументы командной строки, относительно текущего рабочего каталога. Пример свойств, являющихся путями к файлам: &lt;strong&gt;appDir&lt;/strong&gt; , &lt;strong&gt;dir&lt;/strong&gt; , &lt;strong&gt;mainConfigFile&lt;/strong&gt; , &lt;strong&gt;out&lt;/strong&gt; , &lt;strong&gt;wrap.startFile&lt;/strong&gt; , &lt;strong&gt;wrap.endFile&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe96d7fff0f912ef23ce1a903bec59c1e061054" translate="yes" xml:space="preserve">
          <source>In particular, &lt;strong&gt;the following will not work&lt;/strong&gt;:</source>
          <target state="translated">В частности, &lt;strong&gt;не сработают&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f35ef7f938973ce790f5493a620318e22603f51d" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;modules&lt;/strong&gt; array, specify the module names that you want to optimize, in the example, &quot;main&quot;. &quot;main&quot; will be mapped to &lt;strong&gt;appdirectory/scripts/main.js&lt;/strong&gt; in your project. The build system will then trace the dependencies for main.js and inject them into the &lt;strong&gt;appdirectory-build/scripts/main.js&lt;/strong&gt; file.</source>
          <target state="translated">В массиве &lt;strong&gt;модулей&lt;/strong&gt; укажите имена модулей, которые вы хотите оптимизировать, в примере - &amp;laquo;main&amp;raquo;. &amp;laquo;main&amp;raquo; будет сопоставлен с &lt;strong&gt;appdirectory / scripts / main.js&lt;/strong&gt; в вашем проекте. Система сборки будет отслеживать зависимости для main.js и ввести их в &lt;strong&gt;/ скрипты / main.js appdirectory-сборка&lt;/strong&gt; файл.</target>
        </trans-unit>
        <trans-unit id="104b91c1bd0b54f7e9b0f9f56f1480a81283afad" translate="yes" xml:space="preserve">
          <source>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</source>
          <target state="translated">В будущем этот код может быть втянут в каталог require/как дополнительный модуль,который вы можете загрузить по своему усмотрению,чтобы получить правильное поведение при загрузке в зависимости от окружения хоста.</target>
        </trans-unit>
        <trans-unit id="ff2906dc76505cca03806c98590fb6c7fb3e8b67" translate="yes" xml:space="preserve">
          <source>In the r.js optimizer, &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; works as a pre- and post-processing step on a JS file. Various kinds of license comments are found, pulled out of the JS source, then that modified source is passed to the minifier. When the minifier is done, the comments are added to the top of the file by the r.js optimizer.</source>
          <target state="translated">В оптимизаторе r.js &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; работает как этап предварительной и последующей обработки файла JS. Находятся различные виды комментариев к лицензии, извлекаются из исходного кода JS, а затем этот измененный исходный код передается в минификатор. Когда минификатор готов, комментарии добавляются в начало файла оптимизатором r.js.</target>
        </trans-unit>
        <trans-unit id="bd30abf3900baa5cd5ba9bf23def7c8f59c6f6c1" translate="yes" xml:space="preserve">
          <source>In this case, the normalized names the './a', './b', and './c' will be determined relative to the module asking for this resource. Since RequireJS does not know how to inspect the 'index!2?./a:./b:./c' to normalize the names for './a', './b', and './c', it needs to ask the plugin. This is the purpose of the normalize call.</source>
          <target state="translated">В этом случае нормализованные имена './a','./b' и './c' будут определены относительно модуля,запрашивающего этот ресурс.Так как RequireJS не знает,как проверить 'index!2?/a:./b:./c' для нормализации имен для './a','./b' и './c',ему нужно запросить плагин.Это и есть цель нормализации вызова.</target>
        </trans-unit>
        <trans-unit id="af3920b5a279ff0e144ef6675ba1d61fbdb25e91" translate="yes" xml:space="preserve">
          <source>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</source>
          <target state="translated">В этом примере создается модуль &quot;моя/рубашка&quot;.Он зависит от моего/тележки и моего/инвентаря.На диске файлы структурированы следующим образом:</target>
        </trans-unit>
        <trans-unit id="55e27a4c9226afbe32b577671abb7f2cbde38000" translate="yes" xml:space="preserve">
          <source>In version 1.0.5+ of the optimizer, the &lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;mainConfigFile&lt;/a&gt;&lt;/strong&gt; option can be used to specify the location of the runtime config. If specified with the path to your main JS file, the first &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; found in that file will be parsed out and used as part of the configuration options passed to the optimizer:</source>
          <target state="translated">В оптимизаторе версии &lt;strong&gt;&lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27&quot;&gt;1.0.5+&lt;/a&gt;&lt;/strong&gt; параметр &lt;strong&gt;mainConfigFile&lt;/strong&gt; может использоваться для указания местоположения конфигурации времени выполнения. Если указан путь к вашему основному JS-файлу, первые &lt;code&gt;requirejs({}), requirejs.config({}), require({}), or require.config({})&lt;/code&gt; найденные в этом файле, будут проанализированы и используется как часть параметров конфигурации, передаваемых оптимизатору:</target>
        </trans-unit>
        <trans-unit id="677c97dead3af89beaae180f2b05fb0885038810" translate="yes" xml:space="preserve">
          <source>In your main.js file, create a paths config that gives the script a module name. This can be done even if the script does not define a module via a call to define(). paths config are just used to map short module/script IDs to an URL. This allows you to use a different paths config for the optimization. In main.js:</source>
          <target state="translated">В файле main.js создайте конфигурацию путей,которая дает имя модуля скрипту.Это может быть сделано,даже если скрипт не определяет модуль с помощью вызова функции define().Конфигурация путей просто используется для сопоставления коротких идентификаторов модулей/сценариев с URL.Это позволяет использовать для оптимизации различные конфигурационные пути.В main.js:</target>
        </trans-unit>
        <trans-unit id="a4f447bcdd3ea14912a0ab5851ae0c9a896b9bc5" translate="yes" xml:space="preserve">
          <source>Instead of using require() to get dependencies inside the function passed to define(), you can also specify them via a dependency array argument to define(). The order of the names in the dependency array match the order of arguments passed to the definition function passed to define(). So the above example that uses the module &lt;strong&gt;foo&lt;/strong&gt;:</source>
          <target state="translated">Вместо использования require () для получения зависимостей внутри функции, переданной в define (), вы также можете указать их с помощью аргумента массива зависимостей для define (). Порядок имен в массиве зависимостей соответствует порядку аргументов, переданных в функцию определения, переданную в define (). Итак, приведенный выше пример с использованием модуля &lt;strong&gt;foo&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7fcc07e4da729e4b4e9fcc19ccbda6fd0e667335" translate="yes" xml:space="preserve">
          <source>Integration with has.js</source>
          <target state="translated">Интеграция с has.js</target>
        </trans-unit>
        <trans-unit id="1f8eb79c06f41e4c3eb114f2a67df248c0294380" translate="yes" xml:space="preserve">
          <source>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</source>
          <target state="translated">Internet Explorer имеет ряд проблем,которые затрудняют обнаружение сбоев в загрузке для errbacks/paths fallbacks:</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="4ab560f11406cd0e8a158f69d8a4cedb4f432af2" translate="yes" xml:space="preserve">
          <source>Invalid require call</source>
          <target state="translated">Недействительный запрос</target>
        </trans-unit>
        <trans-unit id="37b0ca0680cdcc950b168ac80a44a59f649d995a" translate="yes" xml:space="preserve">
          <source>It also meant they placed more of a burden on web developers to implement the format, and the stop-gap measures meant debugging was worse. eval-based debugging or debugging multiple files that are concatenated into one file have practical weaknesses. Those weaknesses may be addressed in browser tooling at some point in the future, but the end result: using CommonJS modules in the most common of JS environments, the browser, is non-optimal today.</source>
          <target state="translated">Это также означало,что они возлагали большую нагрузку на веб-разработчиков по реализации формата,а меры по устранению пробелов означали,что отладка была хуже.Отладка на основе оценки или отладка нескольких файлов,которые объединены в один файл,имеет практические недостатки.Эти недостатки могут быть устранены в какой-то момент в будущем в браузере,но конечный результат:использование модулей CommonJS в наиболее распространенных JS-средах,браузер,является неоптимальным сегодня.</target>
        </trans-unit>
        <trans-unit id="06871a3ab0f9615b1d6fab6eac51a26791195668" translate="yes" xml:space="preserve">
          <source>It differs from the normal CommonJS syntax out of necessity to work well in the browser. There have been suggestions that the normal CommonJS syntax could be used with head.appendChild(script) type of loading if a server process transforms the modules to a transport format that has a function wrapper.</source>
          <target state="translated">Он отличается от обычного синтаксиса CommonJS необходимостью хорошо работать в браузере.Существуют предположения,что обычный синтаксис CommonJS может быть использован с типом загрузки head.appendChild(script),если серверный процесс преобразует модули в транспортный формат,который имеет обертку функций.</target>
        </trans-unit>
        <trans-unit id="5ffe27ee87a8206f32325462d1728096ff92ef70" translate="yes" xml:space="preserve">
          <source>It does not have strong cross browser support</source>
          <target state="translated">Он не имеет сильной поддержки кросс-браузера</target>
        </trans-unit>
        <trans-unit id="74a4bb6d4f0f076d77e09d55731eb64159c9e44d" translate="yes" xml:space="preserve">
          <source>It is a message-passing API, and the scripts likely want to interact with the DOM, so it means just using the worker to fetch the script text, but pass the text back to the main window then use eval/script with text body to execute the script. This has all of the problems as XHR mentioned above.</source>
          <target state="translated">Это API,передающий сообщения,и сценарии,скорее всего,захотят взаимодействовать с DOM,поэтому это означает,что нужно просто использовать работника,чтобы получить текст сценария,но передать текст обратно в главное окно,а затем использовать eval/script с текстовым телом для выполнения сценария.В этом есть все проблемы,упомянутые выше в XHR.</target>
        </trans-unit>
        <trans-unit id="933995d016ad7a4c199042da83eaec5d3cd9dac5" translate="yes" xml:space="preserve">
          <source>It is an improvement over CommonJS modules because:</source>
          <target state="translated">Это улучшение по сравнению с модулями CommonJS,потому что:</target>
        </trans-unit>
        <trans-unit id="730c4225b2d0d3fb0671ef8fe3e3739ed1d33110" translate="yes" xml:space="preserve">
          <source>It is an improvement over the web's current &quot;globals and script tags&quot; because:</source>
          <target state="translated">Это улучшение по сравнению с текущими &quot;глобусами и тегами сценариев&quot;,потому что:</target>
        </trans-unit>
        <trans-unit id="e91de952b822a7b9e601878fa68d2f21c35e3658" translate="yes" xml:space="preserve">
          <source>It is best if there is an &lt;strong&gt;&quot;opt-in&quot; call&lt;/strong&gt; that can be done so that older JS code can participate in the new system.</source>
          <target state="translated">Лучше всего, если есть &lt;strong&gt;вызов &amp;laquo;opt-in&amp;raquo;,&lt;/strong&gt; который можно сделать, чтобы старый код JS мог участвовать в новой системе.</target>
        </trans-unit>
        <trans-unit id="5366afdcae21e6c4f1d44ccd61b7c663f948c522" translate="yes" xml:space="preserve">
          <source>It is best to set the baseUrl specifically to the directory containing the module, so that it works properly when nested inside a node_modules heirarchy. Use the synchronous &lt;code&gt;requirejs('moduleId')&lt;/code&gt; to fetch the module using the config and rules in requirejs, then use Node's module.exports to export your module value:</source>
          <target state="translated">Лучше всего установить baseUrl специально для каталога, содержащего модуль, чтобы он работал правильно при вложении внутри иерархии node_modules. Используйте синхронный &lt;code&gt;requirejs('moduleId')&lt;/code&gt; чтобы получить модуль, используя конфигурацию и правила в requirejs, затем используйте Node module.exports для экспорта значения вашего модуля:</target>
        </trans-unit>
        <trans-unit id="36bb237f110735ba5fbb00d5eb1f96f64c6d37d5" translate="yes" xml:space="preserve">
          <source>It is harder to debug. Firebug and WebKit's inspector have an //@ sourceURL= convention, which helps give a name to evaled text, but this support is not universal across browsers.</source>
          <target state="translated">Его труднее отлаживать.В браузерах Firebug и WebKit's inspector есть соглашение //@ sourceURL=,которое помогает дать имя оценочному тексту,но эта поддержка не является универсальной во всех браузерах.</target>
        </trans-unit>
        <trans-unit id="9c87d9d9b05b11c9ab9a66ebf5b60f1a510690bd" translate="yes" xml:space="preserve">
          <source>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</source>
          <target state="translated">Приятно строить HTML,используя обычные HTML-теги,вместо того,чтобы строить DOM-структуры в скрипте.Однако,нет хорошего способа встроить HTML в файл JavaScript.Лучшее,что можно сделать,это использовать строку HTML,но это может быть трудно управляемым,особенно для многострочного HTML.</target>
        </trans-unit>
        <trans-unit id="d949986f91111b463d2e6c0b5b7a550aa5302d7b" translate="yes" xml:space="preserve">
          <source>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</source>
          <target state="translated">Это возможно при использовании системы RequireJS для загрузки скриптов достаточно быстро,чтобы они были завершены до того,как флэш-накопитель будет готов к работе.Любая работа,которая пытается взаимодействовать с флэшкой,должна ждать,пока флэшка будет готова.Для современных браузеров это делается путем ожидания события DOMContentLoaded.</target>
        </trans-unit>
        <trans-unit id="539c0da90c417fc4465e8833119b2d4679e2ab07" translate="yes" xml:space="preserve">
          <source>It is tempting to use XMLHttpRequest (XHR) to load the scripts. If XHR is used, then we can massage the text above -- we can do a regexp to find require() calls, make sure we load those scripts, then use eval() or script elements that have their body text set to the text of the script loaded via XHR.</source>
          <target state="translated">Соблазнительно использовать XMLHttpRequest (XHR)для загрузки скриптов.Если используется XHR,то мы можем массировать текст выше --мы можем сделать regexp,чтобы найти вызовы require(),убедиться,что мы загружаем эти скрипты,затем использовать eval()или элементы скрипта,у которых их текст установлен в текст скрипта,загруженного с помощью XHR.</target>
        </trans-unit>
        <trans-unit id="a5b8151a598bcb30cf8bfca9d33d4425d2cd203c" translate="yes" xml:space="preserve">
          <source>It makes debugging weird, line numbers will be off vs. the source file since the server is injecting a function wrapper.</source>
          <target state="translated">Это делает отладку странной,номера строк будут отключены по сравнению с исходным файлом,так как сервер вводит обертку функции.</target>
        </trans-unit>
        <trans-unit id="6d0cde0ae490de0408250a7f5a89a70bf23c8332" translate="yes" xml:space="preserve">
          <source>It requires extra tooling to substitute a set of script tags into one tag for optimized deployment.</source>
          <target state="translated">Она требует дополнительных инструментов для замены набора тегов сценариев в один тег для оптимизированного развертывания.</target>
        </trans-unit>
        <trans-unit id="aaa2ddf75cd4a6f214f39c8e40c3d4e378c489b4" translate="yes" xml:space="preserve">
          <source>It requires more gear. Front-end development should be possible with static files.</source>
          <target state="translated">Нужно больше передачи.Внешняя разработка должна быть возможна со статическими файлами.</target>
        </trans-unit>
        <trans-unit id="b532c07e09af6445d4a57ec51df56d53e00a8d20" translate="yes" xml:space="preserve">
          <source>It will also optimize any CSS files it finds inside &lt;strong&gt;appdirectory-build&lt;/strong&gt;.</source>
          <target state="translated">Он также оптимизирует любые файлы CSS, найденные внутри &lt;strong&gt;appdirectory-build&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1450cad84f11fb851a995a9dbe7cbd1a83b48017" translate="yes" xml:space="preserve">
          <source>It will not work, since jQuery registers itself with the name of 'jquery' and not 'lib/jquery'. In general, explicitly naming modules in the define() call are discouraged, but &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery has some special constraints&lt;/a&gt;.</source>
          <target state="translated">Это не сработает, поскольку jQuery регистрируется с именем jquery, а не lib / jquery. В общем случае явное именование модулей в вызове define () не рекомендуется, но &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon&quot;&gt;jQuery имеет некоторые особые ограничения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f07795f631a52c810ff74f35c0a35b8c0ee082f" translate="yes" xml:space="preserve">
          <source>It works better in the browser, it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</source>
          <target state="translated">Он лучше работает в браузере,у него наименьшее количество попаданий.Другие подходы имеют проблемы с отладкой,междоменным использованием/CDN,использованием file://и необходимостью серверной утилиты.</target>
        </trans-unit>
        <trans-unit id="8f95e6bcde84bb0ea04bd5f126835d355217e942" translate="yes" xml:space="preserve">
          <source>LABjs: $LAB.script(&quot;some/module.js&quot;)</source>
          <target state="translated">LABjs:$LAB.script(&quot;some/module.js&quot;)</target>
        </trans-unit>
        <trans-unit id="ae0daafd2a22a2600ed4ab6dde4b770824eeb963" translate="yes" xml:space="preserve">
          <source>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</source>
          <target state="translated">Позже,когда вы захотите добавить конкретный перевод в файл,например,для fr-fr локали,измените мой/nls/colors так,чтобы он выглядел именно так:</target>
        </trans-unit>
        <trans-unit id="a52b393d001eaf90fba4046093ec0e36ce9f892a" translate="yes" xml:space="preserve">
          <source>Latest Release: &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt;Open source: &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;new BSD or MIT licensed&lt;/a&gt;web design by &lt;a href=&quot;http://andychung.me/&quot;&gt;Andy Chung&lt;/a&gt; &amp;copy; 2011-2017</source>
          <target state="translated">Последний выпуск: &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;2.3.5&lt;/a&gt; Открытый исходный код: &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/LICENSE&quot;&gt;новый&lt;/a&gt; веб-дизайн под лицензией BSD или MIT, разработанный &lt;a href=&quot;http://andychung.me/&quot;&gt;Энди Чангом&lt;/a&gt; &amp;copy; 2011-2017</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="00849ea91859e8877efb5045590add6b11f850ad" translate="yes" xml:space="preserve">
          <source>Likely causes and fixes:</source>
          <target state="translated">Вероятно,вызывает и исправляет:</target>
        </trans-unit>
        <trans-unit id="f3c97333b24770acd81169479f77c402aa695485" translate="yes" xml:space="preserve">
          <source>Load JavaScript Files</source>
          <target state="translated">Загрузить файлы JavaScript</target>
        </trans-unit>
        <trans-unit id="847b5a6fad771caed85029fc26f6dc8da0260706" translate="yes" xml:space="preserve">
          <source>Load timeout for modules: ...</source>
          <target state="translated">Тайм-аут загрузки модулей:...</target>
        </trans-unit>
        <trans-unit id="f4ff6c36d65b86d4c62b59ce106dc00b3d1a41cb" translate="yes" xml:space="preserve">
          <source>Loader Plugins</source>
          <target state="translated">Плагины погрузчика</target>
        </trans-unit>
        <trans-unit id="b59783ddfeed5ace1aad0bc81fef1a12a200e068" translate="yes" xml:space="preserve">
          <source>Loader plugins are just another module, but they implement a specific API. Loader plugins can also participate in the optimizer optimizations, allowing the resources they load to be inlined in an optimized build.</source>
          <target state="translated">Плагины загрузчика-это всего лишь еще один модуль,но они реализуют специфический API.Плагины загрузчика также могут участвовать в оптимизации оптимизатора,позволяя загружаемым ими ресурсам быть встроенными в оптимизированный билд.</target>
        </trans-unit>
        <trans-unit id="eb74610ba82fc6a40764893dfb647bab016b939f" translate="yes" xml:space="preserve">
          <source>Loading Code After Page Load</source>
          <target state="translated">Код загрузки после загрузки страницы</target>
        </trans-unit>
        <trans-unit id="97455076de06f78a61344dec31b7d67a23e3d804" translate="yes" xml:space="preserve">
          <source>Loading Modules from CommonJS Packages</source>
          <target state="translated">Загрузка модулей из пакетов CommonJS</target>
        </trans-unit>
        <trans-unit id="41818361eaa130c5f3db544fd1f348f224b034fa" translate="yes" xml:space="preserve">
          <source>Loading Modules from Packages</source>
          <target state="translated">Загрузка модулей из пакетов</target>
        </trans-unit>
        <trans-unit id="cae51c36493d810a681b4c1e453b557e06e4c4c2" translate="yes" xml:space="preserve">
          <source>Make sure you reference the network dependency as a module name, not as a full URL, so that it can be mapped to a different during the build:</source>
          <target state="translated">Убедитесь,что вы ссылаетесь на сетевую зависимость как на имя модуля,а не как на полный URL,чтобы его можно было сопоставить с другим во время сборки:</target>
        </trans-unit>
        <trans-unit id="72fdd266ec722bc44dd8a620ed1d7614b77d8c0f" translate="yes" xml:space="preserve">
          <source>Manual Conversion</source>
          <target state="translated">Ручное преобразование</target>
        </trans-unit>
        <trans-unit id="fc64c3825f362079a2271f22c7bab206e4b4ae90" translate="yes" xml:space="preserve">
          <source>Mapping Modules to use noConflict</source>
          <target state="translated">Модули картирования для использования noConflict</target>
        </trans-unit>
        <trans-unit id="dc8cade7e5207678dc6256df2ecc9deb710e940d" translate="yes" xml:space="preserve">
          <source>Means that for any module except &quot;some/oldmodule&quot;, when &quot;foo&quot; is wanted, use &quot;foo1.2&quot; instead. For &quot;some/oldmodule&quot; only, use &quot;foo1.0&quot; when it asks for &quot;foo&quot;.</source>
          <target state="translated">Означает,что для любого модуля,кроме &quot;некоторого/большого модуля&quot;,когда разыскивается &quot;foo&quot;,используйте &quot;foo1.2&quot;.Для &quot;некоторых/больших модулей&quot; используйте &quot;foo1.0&quot;,когда он запрашивает &quot;foo&quot;.</target>
        </trans-unit>
        <trans-unit id="d4a20ddcf46cb8976dc06ca7169ae206a255437c" translate="yes" xml:space="preserve">
          <source>Mechanics</source>
          <target state="translated">Mechanics</target>
        </trans-unit>
        <trans-unit id="01de199a77285acc2ed16e687ed574c8aaa94327" translate="yes" xml:space="preserve">
          <source>Mismatched anonymous define() modules ...</source>
          <target state="translated">Несоответствующие анонимные модули define()...</target>
        </trans-unit>
        <trans-unit id="5d61c868611adf27496376e30ad6452373f98872" translate="yes" xml:space="preserve">
          <source>Module Definition</source>
          <target state="translated">Определение модуля</target>
        </trans-unit>
        <trans-unit id="4228b7603e50200006c8e380e2c2979ffdb82200" translate="yes" xml:space="preserve">
          <source>Module Name</source>
          <target state="translated">Имя модуля</target>
        </trans-unit>
        <trans-unit id="b73dbb3306e34de2871a62a55e786bcc07ac414a" translate="yes" xml:space="preserve">
          <source>Module Purposes</source>
          <target state="translated">Цели модуля</target>
        </trans-unit>
        <trans-unit id="f809bcc9566a363f7ba0c49a6077c47d41c5354c" translate="yes" xml:space="preserve">
          <source>Module name ... has not been loaded yet for context: ...</source>
          <target state="translated">Имя модуля ...еще не загружено для контекста:...</target>
        </trans-unit>
        <trans-unit id="1fceef3854242773f4046d420328f2e959bc28e6" translate="yes" xml:space="preserve">
          <source>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</source>
          <target state="translated">Модули не обязаны возвращать объекты.Любое действительное возвращаемое значение из функции разрешено.Вот модуль,который возвращает функцию в качестве своего определения модуля:</target>
        </trans-unit>
        <trans-unit id="d57cb3f463693d791c21a168e01d847f563c16b7" translate="yes" xml:space="preserve">
          <source>Modules in CommonJS packages can be loaded by RequireJS by setting up the RequireJS configuration to know about the location and package attributes. See the &lt;a href=&quot;api#packages&quot;&gt;packages API section&lt;/a&gt; for more information.</source>
          <target state="translated">Модули в пакетах CommonJS можно загрузить с помощью RequireJS, настроив конфигурацию RequireJS, чтобы знать о местоположении и атрибутах пакета. См. &lt;a href=&quot;api#packages&quot;&gt;Раздел API пакетов&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="320708dab0d8587885e54e25dc4ae497a36bacab" translate="yes" xml:space="preserve">
          <source>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see &lt;strong&gt;Advanced Usage&lt;/strong&gt;). Also, the order of the function arguments should match the order of the dependencies.</source>
          <target state="translated">Модули, которые определяют глобальные объекты, явно не рекомендуются, поэтому на странице могут существовать несколько версий модуля (см. &lt;strong&gt;Расширенное использование&lt;/strong&gt; ). Кроме того, порядок аргументов функции должен соответствовать порядку зависимостей.</target>
        </trans-unit>
        <trans-unit id="572cadc3a302f83a4dbd3c2a7cb42701a0b31b23" translate="yes" xml:space="preserve">
          <source>Modules that use conditional code to do a require call, like if(someCondition) require('a1') else require('a2');</source>
          <target state="translated">Модули,использующие условный код для выполнения вызова,например,if(someCondition)require('a1')else require('a2');</target>
        </trans-unit>
        <trans-unit id="e4fcd558836fffcd1fc66bb98d7e86b496b5b825" translate="yes" xml:space="preserve">
          <source>More details on the design forces and use cases for this function wrapping format, called Asynchronous Module Definition (AMD), can be found on the &lt;a href=&quot;whyamd&quot;&gt;Why AMD?&lt;/a&gt; page.</source>
          <target state="translated">Более подробную информацию о проектных силах и вариантах использования этого формата упаковки функций, называемого определением асинхронного модуля (AMD), можно найти в &lt;a href=&quot;whyamd&quot;&gt;статье Почему AMD? &lt;/a&gt;страница.</target>
        </trans-unit>
        <trans-unit id="c0d889e70d00bbeffd76cf22134b56f52ddb2126" translate="yes" xml:space="preserve">
          <source>More information is available on the &lt;a href=&quot;commonjs&quot;&gt;CommonJS page&lt;/a&gt;, and in the &lt;a href=&quot;whyamd#sugar&quot;&gt;&quot;Sugar&quot; section in the Why AMD page&lt;/a&gt;.</source>
          <target state="translated">Дополнительная информация доступна на &lt;a href=&quot;commonjs&quot;&gt;странице CommonJS&lt;/a&gt; и в разделе &lt;a href=&quot;whyamd#sugar&quot;&gt;&amp;laquo;Сахар&amp;raquo; на странице Почему AMD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db89c3e1579783898093f507ce3545538718b599" translate="yes" xml:space="preserve">
          <source>Most CJS modules, around 95% based on my (thoroughly unscientific) personal experience, are perfectly compatible with the simplified CommonJS wrapping.</source>
          <target state="translated">Большинство модулей CJS,около 95% основанных на моем (совершенно ненаучном)личном опыте,идеально совместимы с упрощенной упаковкой CommonJS.</target>
        </trans-unit>
        <trans-unit id="e2aa6e69266afb5745d704808b26d494d039aaad" translate="yes" xml:space="preserve">
          <source>Most web developers use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</source>
          <target state="translated">Большинство веб-разработчиков все равно используют обертку функций,чтобы не загрязнять страницу глобусами.Видение функции,обёрнутой вокруг функциональности,является очень распространённым видом и не добавляет стоимости чтения модуля.</target>
        </trans-unit>
        <trans-unit id="90065a157b088d30c73a343e6ee438e960ff65f0" translate="yes" xml:space="preserve">
          <source>Multiversion Support</source>
          <target state="translated">Поддержка нескольких версий</target>
        </trans-unit>
        <trans-unit id="7ad300de5360e2dba7612bcbbdd15e356bb1266b" translate="yes" xml:space="preserve">
          <source>Named Modules</source>
          <target state="translated">Именованные модули</target>
        </trans-unit>
        <trans-unit id="41ec1d4b4042c78b4e5c776ec46fb5f1495c5fe4" translate="yes" xml:space="preserve">
          <source>Nashorn Support</source>
          <target state="translated">Поддержка Нашорна</target>
        </trans-unit>
        <trans-unit id="865bc8f0637781f438fc8b01e57a8e62d66abea7" translate="yes" xml:space="preserve">
          <source>No define call for ...</source>
          <target state="translated">Нет определённого вызова для ...</target>
        </trans-unit>
        <trans-unit id="e5a7a586589f9cf9aff0c28e1e027268d23cbfd9" translate="yes" xml:space="preserve">
          <source>No matching script interactive for ...</source>
          <target state="translated">Нет подходящего интерактивного скрипта для ...</target>
        </trans-unit>
        <trans-unit id="e4c78dc7ccbc3875ab2f45f7d9dc57629a5b721b" translate="yes" xml:space="preserve">
          <source>Normally each run of a whole project optimization will delete the output build directory specified by &lt;strong&gt;dir&lt;/strong&gt; for cleanliness. Some build options, like &lt;strong&gt;onBuildWrite&lt;/strong&gt;, will modify the output directory in a way that is hazardous to do twice over the same files. However, if you are doing simple builds with no extra file transforms besides build layer minification, then you can set &lt;strong&gt;keepBuildDir&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt; to keep the build directory between runs. Then, only files that have changed between build runs will be copied.</source>
          <target state="translated">Обычно каждый прогон оптимизации всего проекта удаляет выходной каталог сборки, указанный &lt;strong&gt;dir&lt;/strong&gt; для чистоты. Некоторые параметры сборки, такие как &lt;strong&gt;onBuildWrite&lt;/strong&gt; , изменяют выходной каталог таким образом, что опасно делать дважды с одними и теми же файлами. Однако, если вы выполняете простые сборки без дополнительных преобразований файлов, кроме минификации уровня сборки, вы можете установить для &lt;strong&gt;keepBuildDir&lt;/strong&gt; значение &lt;code&gt;true&lt;/code&gt; , чтобы каталог сборки сохранялся между запусками. Затем будут скопированы только файлы, которые изменились между запусками сборки.</target>
        </trans-unit>
        <trans-unit id="63637860d1b09a9a35884674fd6b92b4169d387b" translate="yes" xml:space="preserve">
          <source>Normally you should &lt;strong&gt;not&lt;/strong&gt; save optimized files with your pristine project source. Normally you would save them to a copy of your project, but to make this example easier it is saved with the source. Change the &lt;strong&gt;out=&lt;/strong&gt; option to any directory you like, that has a copy of your source. Then, you can change the main-built.js file name to just main.js so the HTML page will load the optimized version of the file.</source>
          <target state="translated">Обычно вам &lt;strong&gt;не&lt;/strong&gt; следует сохранять оптимизированные файлы вместе с исходным исходным кодом проекта. Обычно вы сохраняете их в копии своего проекта, но для упрощения этого примера он сохраняется вместе с исходным кодом. Измените параметр &lt;strong&gt;out =&lt;/strong&gt; на любой понравившийся каталог, в котором есть копия вашего источника. Затем вы можете изменить имя файла main-built.js на main.js, чтобы HTML-страница загружала оптимизированную версию файла.</target>
        </trans-unit>
        <trans-unit id="5cd37647a9ff32456856beeb4b5a868e634c28ed" translate="yes" xml:space="preserve">
          <source>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</source>
          <target state="translated">Обычно вам не нужно использовать require()для получения модуля,а вместо этого полагаться на то,что модуль передается в функцию в качестве аргумента.Круговые зависимости встречаются редко,и обычно это признак того,что вы можете захотеть переосмыслить конструкцию.Однако,иногда они необходимы,и в этом случае используйте require(),как указано выше.</target>
        </trans-unit>
        <trans-unit id="55774be7c2eb30133e188a1e6f7e775499e3be75" translate="yes" xml:space="preserve">
          <source>Not all browsers give a usable Function.prototype.toString() results. As of October 2011, the PS 3 and older Opera Mobile browsers do not. Those browsers are more likely to need an optimized build of the modules for network/device limitations, so just do a build with an optimizer that knows how to convert these files to the normalized dependency array form, like the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt;.</source>
          <target state="translated">Не все браузеры выдают полезные результаты Function.prototype.toString (). По состоянию на октябрь 2011 года браузеры Opera Mobile для PS 3 и более ранних версий этого не сделали. Этим браузерам, скорее всего, потребуется оптимизированная сборка модулей для ограничений сети / устройства, поэтому просто выполните сборку с оптимизатором, который знает, как преобразовать эти файлы в форму нормализованного массива зависимостей, например &lt;a href=&quot;optimization&quot;&gt;оптимизатор RequireJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fcbd7ebdfa5c953e00172733331cfbb354ef3c" translate="yes" xml:space="preserve">
          <source>Note however if you want to get 404 load detection in IE so that you can use paths fallbacks or errbacks, then a string exports value should be given so the loader can check if the scripts actually loaded (a return from init is &lt;strong&gt;not&lt;/strong&gt; used for &lt;code&gt;enforceDefine&lt;/code&gt; checking):</source>
          <target state="translated">Однако обратите внимание, если вы хотите получить обнаружение загрузки 404 в IE, чтобы вы могли использовать резервные пути или ошибки ошибок, тогда следует указать значение экспорта строки, чтобы загрузчик мог проверить, действительно ли загружены скрипты (возврат из init &lt;strong&gt;не&lt;/strong&gt; используется для &lt;code&gt;enforceDefine&lt;/code&gt; проверка):</target>
        </trans-unit>
        <trans-unit id="789188496a0ed139c37a18268d1d7e75613d29f9" translate="yes" xml:space="preserve">
          <source>Note that &quot;require&quot; is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If &quot;require&quot; is not specified as a dependency, then there will likely be an error.</source>
          <target state="translated">Обратите внимание,что &quot;require&quot; указывается как зависимость для модуля.Это позволяет функции require(),которая передается обратному вызову функции,использовать правильный контекст для корректной загрузки модулей для поддержки мультиверсии.Если &quot;require&quot; не указан как зависимость,то,скорее всего,произойдет ошибка.</target>
        </trans-unit>
        <trans-unit id="a031cfd930d814fbea9159a6976e73d89cfd0031" translate="yes" xml:space="preserve">
          <source>Note this only works if &quot;module/name&quot; was previously loaded via the async version of require: &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt;. If using a relative path, like './module/name', those only work inside define</source>
          <target state="translated">Обратите внимание, что это работает, только если &amp;laquo;module / name&amp;raquo; был ранее загружен через асинхронную версию require: &lt;code&gt;require([&quot;module/name&quot;])&lt;/code&gt; . Если используется относительный путь, например './module/name', они работают только внутри определения</target>
        </trans-unit>
        <trans-unit id="73d8d234ee45af790eb832ba8c7d6006b1416af0" translate="yes" xml:space="preserve">
          <source>Note: The url() path fixing will always fix the paths relative to the &lt;strong&gt;cssIn&lt;/strong&gt; build option path, not the &lt;strong&gt;out&lt;/strong&gt; build option.</source>
          <target state="translated">Примечание. Исправление пути url () всегда будет исправлять пути относительно пути &lt;strong&gt;параметра&lt;/strong&gt; сборки &lt;strong&gt;cssIn&lt;/strong&gt; , а не параметра сборки &lt;strong&gt;out&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0c5badabbf2d099d71c93a7c71166c9738138220" translate="yes" xml:space="preserve">
          <source>Notice as part of that example, vendor libraries like jQuery did not have their version numbers in their file names. It is recommended to store that version info in a separate text file if you want to track it, or if you use a tool like &lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo&lt;/a&gt;, it will stamp the package.json with the version information but keep the file on disk as &quot;jquery.js&quot;. This allows you to have the very minimal configuration instead of having to put an entry in the &quot;paths&quot; config for each library. For instance, configure &quot;jquery&quot; to be &quot;jquery-1.7.2&quot;.</source>
          <target state="translated">Обратите внимание, что в рамках этого примера библиотеки поставщиков, такие как jQuery, не имеют номеров версий в именах файлов. Рекомендуется хранить эту информацию о версии в отдельном текстовом файле, если вы хотите отслеживать ее, или, если вы используете такой инструмент, как &lt;a href=&quot;https://github.com/volojs/volo&quot;&gt;volo&lt;/a&gt; , он отметит package.json информацией о версии, но сохранит файл на диске как &amp;laquo;jquery&amp;raquo;. js &quot;. Это позволяет вам иметь очень минимальную конфигурацию вместо того, чтобы помещать запись в конфигурацию &quot;paths&quot; для каждой библиотеки. Например, сконфигурируйте &quot;jquery&quot; как &quot;jquery-1.7.2&quot;.</target>
        </trans-unit>
        <trans-unit id="996ee768862a8be02370220efbb2ff9a6f2f8b5b" translate="yes" xml:space="preserve">
          <source>Notice that the above module does not declare a name for itself. This is what makes the module very portable. It allows a developer to place the module in a different path to give it a different ID/name. The AMD loader will give the module an ID based on how it is referenced by other scripts.</source>
          <target state="translated">Обратите внимание,что вышеуказанный модуль не объявляет имя для себя.Это то,что делает модуль очень портативным.Это позволяет разработчику разместить модуль по другому пути,чтобы дать ему другой ID/название.Загрузчик AMD выдаст модулю ID,основываясь на том,как на него ссылаются другие скрипты.</target>
        </trans-unit>
        <trans-unit id="993f59cc8fa52c4ddad7b03ed5bbcf3714d49d77" translate="yes" xml:space="preserve">
          <source>Now, when this page is loaded, the require() for &quot;main&quot; will load the main-built.js file. Since excludeShallow told it just to exclude two.js, two.js will still be loaded as a separate file, allowing you to see it as a separate file in the browser's debugger, so you can set breakpoints and better track its individual changes.</source>
          <target state="translated">Теперь,когда эта страница загружена,функция require()для &quot;main&quot; загрузит файл main-built.js.Так как функция excludShallow сказала ей просто исключить two.js,то two.js все равно будет загружен как отдельный файл,что позволит вам увидеть его как отдельный файл в отладчике браузера,так что вы сможете установить точки останова и лучше отслеживать его отдельные изменения.</target>
        </trans-unit>
        <trans-unit id="9a357ac26fa398f234d0d159a9d93322c7b4cb85" translate="yes" xml:space="preserve">
          <source>Once that optimization is done, you can change the script tag to reference &quot;main-built.js&quot; instead of &quot;require.js&quot;, and your optimized project will only need to make one script request.</source>
          <target state="translated">Как только эта оптимизация будет выполнена,вы можете изменить тег скрипта на ссылку &quot;main-built.js&quot; вместо &quot;require.js&quot;,и ваш оптимизированный проект должен будет сделать только один запрос скрипта.</target>
        </trans-unit>
        <trans-unit id="ef2b0cafc31915283c6f140afefded86a6a94d85" translate="yes" xml:space="preserve">
          <source>Once the build is done, you can use &lt;strong&gt;appdirectory-build&lt;/strong&gt; as your optimized project, ready for deployment.</source>
          <target state="translated">После завершения сборки вы можете использовать &lt;strong&gt;appdirectory-build в&lt;/strong&gt; качестве оптимизированного проекта, готового к развертыванию.</target>
        </trans-unit>
        <trans-unit id="687a77b17737ebb7701c40d0de5ac221cc75854d" translate="yes" xml:space="preserve">
          <source>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</source>
          <target state="translated">Как только ваше веб-приложение достигнет определенного размера и популярности,локализация строк в интерфейсе и предоставление другой специфической для данной местности информации станет более полезной.Однако,разработка схемы,хорошо масштабируемой для поддержки нескольких локалей,может оказаться трудоемкой задачей.</target>
        </trans-unit>
        <trans-unit id="6f5e918f3dd72c7755fe673e8aeaf5ae2e4034a2" translate="yes" xml:space="preserve">
          <source>One example: a plugin that needs to write out some utility functions at the beginning of a layer, as part of the first &lt;a href=&quot;#apiwrite&quot;&gt;write&lt;/a&gt; call, and the plugin needs to know when to reset the internal state to know when to write out the utilities for the next layer. If the plugin implements onLayerEnd, it can get notified when to reset its internal state.</source>
          <target state="translated">Один пример: плагин, которому необходимо записать некоторые служебные функции в начале уровня, как часть первого вызова &lt;a href=&quot;#apiwrite&quot;&gt;записи&lt;/a&gt; , и плагин должен знать, когда сбрасывать внутреннее состояние, чтобы знать, когда писать служебные программы для следующий слой. Если плагин реализует onLayerEnd, он может получить уведомление, когда нужно сбросить его внутреннее состояние.</target>
        </trans-unit>
        <trans-unit id="136a30d6a64759ec55feda3ab1525a1a3b34d9e6" translate="yes" xml:space="preserve">
          <source>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</source>
          <target state="translated">Одним из критических замечаний к AMD,по крайней мере по сравнению с модулями CJS,является то,что он требует уровня отступа и обертки функции.</target>
        </trans-unit>
        <trans-unit id="425ce3199a0f68e5f26534c0cd5b7ecada23b956" translate="yes" xml:space="preserve">
          <source>Only execute the factory function once all the dependencies have been loaded and executed.</source>
          <target state="translated">Выполняйте заводскую функцию только после загрузки и выполнения всех зависимостей.</target>
        </trans-unit>
        <trans-unit id="f5b213795860798e7ca26c8b8fd156f9d8034004" translate="yes" xml:space="preserve">
          <source>Only one version of a package can be used in a project context at a time. You can use RequireJS &lt;a href=&quot;#multiversion&quot;&gt;multiversion support&lt;/a&gt; to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</source>
          <target state="translated">Только одна версия пакета может использоваться в контексте проекта одновременно. Вы можете использовать &lt;a href=&quot;#multiversion&quot;&gt;многоверсионную поддержку&lt;/a&gt; RequireJS для загрузки двух разных контекстов модуля, но если вы хотите использовать пакеты A и B в одном контексте, и они зависят от разных версий пакета C, тогда это будет проблемой. Это может измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="d03cab42295a0ef773cb4c58414926ae22c7f099" translate="yes" xml:space="preserve">
          <source>Only use other &quot;shim&quot; modules as dependencies for shimmed scripts, or AMD libraries that have no dependencies and call define() after they also create a global (like jQuery or lodash). Otherwise, if you use an AMD module as a dependency for a shim config module, after a build, that AMD module may not be evaluated until after the shimmed code in the build executes, and an error will occur. The ultimate fix is to upgrade all the shimmed code to have optional AMD define() calls.</source>
          <target state="translated">Используйте другие модули &quot;shim&quot; в качестве зависимостей только для &quot;прошитых&quot; скриптов или библиотек AMD,которые не имеют зависимостей и вызывают функцию define()после того,как они также создадут глобальный (например,jQuery или lodash).В противном случае,если вы используете модуль AMD в качестве зависимости для модуля конфигурации shim,после сборки,этот модуль AMD не может быть оценен до тех пор,пока не будет выполнен прошитый код сборки,и произойдет ошибка.Окончательным исправлением является обновление всего шиммированного кода до необязательных вызовов функции AMD define().</target>
        </trans-unit>
        <trans-unit id="e52f63056d18f367435ae7f42b9e0e1b5ba47c94" translate="yes" xml:space="preserve">
          <source>Optimization Tool</source>
          <target state="translated">Инструмент оптимизации</target>
        </trans-unit>
        <trans-unit id="e1bf3840bdf455e89a6ccb39ca4b5ef36c34af9a" translate="yes" xml:space="preserve">
          <source>Optimizes CSS by inlining CSS files referenced by @import and removing comments.</source>
          <target state="translated">Оптимизирует CSS,вставляя CSS-файлы,на которые ссылается @импорт,и удаляя комментарии.</target>
        </trans-unit>
        <trans-unit id="645afdfe1831be73caed431c4985960a8ed23da8" translate="yes" xml:space="preserve">
          <source>Optimizing a multi-page project</source>
          <target state="translated">Оптимизация многостраничного проекта</target>
        </trans-unit>
        <trans-unit id="94406643fcbc9130f67c3a7df6529a75a5308c56" translate="yes" xml:space="preserve">
          <source>Optimizing a whole project</source>
          <target state="translated">Оптимизация всего проекта</target>
        </trans-unit>
        <trans-unit id="1b97e68f7e906d321f51c531c8135373f8051ae6" translate="yes" xml:space="preserve">
          <source>Optimizing one CSS file</source>
          <target state="translated">Оптимизация одного CSS-файла</target>
        </trans-unit>
        <trans-unit id="2020d5670f6972dff09b1dce4b6069fedaf819dd" translate="yes" xml:space="preserve">
          <source>Optimizing one JavaScript file</source>
          <target state="translated">Оптимизация одного файла JavaScript</target>
        </trans-unit>
        <trans-unit id="a83a52c3fb590de0dc3104c9c47bccb368ae4538" translate="yes" xml:space="preserve">
          <source>Or better yet, use the shortened syntax that is available for use with &lt;a href=&quot;commonjs&quot;&gt;translating CommonJS&lt;/a&gt; modules:</source>
          <target state="translated">Или, что еще лучше, используйте сокращенный синтаксис, который доступен для &lt;a href=&quot;commonjs&quot;&gt;перевода&lt;/a&gt; модулей CommonJS :</target>
        </trans-unit>
        <trans-unit id="439567bdbbd0efa69af61a769a5cca0a13682f69" translate="yes" xml:space="preserve">
          <source>Or there was a 404 error in IE where the script failed to load.</source>
          <target state="translated">Или была ошибка 404 в IE,где скрипт не смог загрузиться.</target>
        </trans-unit>
        <trans-unit id="902a0c43077fddb8868418fb133f6ea532f9cf74" translate="yes" xml:space="preserve">
          <source>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</source>
          <target state="translated">Или используйте XMLHttpRequest (XHR)для загрузки текста модулей и выполнения текстовых преобразований/парсинга в браузере.</target>
        </trans-unit>
        <trans-unit id="0a8b90507f83c83d06c60ecc35f83f8e249ecaaf" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that did not set a string value for the &lt;code&gt;exports&lt;/code&gt; config option.</source>
          <target state="translated">Или был частью &lt;a href=&quot;api#config-shim&quot;&gt;конфигурации прокладки&lt;/a&gt; , в которой не было задано строковое значение для параметра конфигурации &lt;code&gt;exports&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49b8afea31aaecf8ff90dc1b9c1a2348f0ea7f7f" translate="yes" xml:space="preserve">
          <source>Or was part of a &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; that specified a string &lt;code&gt;exports&lt;/code&gt; property that can be checked to verify loading, and that check failed.</source>
          <target state="translated">Или был частью &lt;a href=&quot;api#config-shim&quot;&gt;конфигурации прокладки, в&lt;/a&gt; которой указано свойство &lt;code&gt;exports&lt;/code&gt; строки, которое можно проверить для проверки загрузки, и эта проверка не удалась.</target>
        </trans-unit>
        <trans-unit id="a720b152f92f2ac4f80f1d33c29f053ea00d9d62" translate="yes" xml:space="preserve">
          <source>Or, baseUrl can be set manually via the &lt;a href=&quot;#config&quot;&gt;RequireJS config&lt;/a&gt;. If there is no explicit config and data-main is not used, then the default baseUrl is the directory that contains the HTML page running RequireJS.</source>
          <target state="translated">Или baseUrl можно установить вручную через &lt;a href=&quot;#config&quot;&gt;конфигурацию RequireJS&lt;/a&gt; . Если явной конфигурации нет и основные данные не используются, то по умолчанию baseUrl - это каталог, содержащий HTML-страницу, на которой выполняется RequireJS.</target>
        </trans-unit>
        <trans-unit id="5e6e5c0ac606b77ee930fbf12aa3eaf2fba80c55" translate="yes" xml:space="preserve">
          <source>Or, do not set that paths or packages config and do the top level require call as &lt;code&gt;require(['compute/main'])&lt;/code&gt;.</source>
          <target state="translated">Или не устанавливайте эти пути или конфигурацию пакетов и выполняйте вызов верхнего уровня по мере &lt;code&gt;require(['compute/main'])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88494ce1c87ce2ac5b556e14476243360620b7de" translate="yes" xml:space="preserve">
          <source>Or, if it was inside a package or directory, say bar/foo.js:</source>
          <target state="translated">Или,если он был внутри пакета или каталога,скажем bar/foo.js:</target>
        </trans-unit>
        <trans-unit id="c8545835771037daaa58fff1b8277d3939e13f00" translate="yes" xml:space="preserve">
          <source>Or, if the error shows up only in IE and not in other browsers (which may generate a &lt;a href=&quot;#scripterror&quot;&gt;Script error&lt;/a&gt;, the script probably:</source>
          <target state="translated">Или, если ошибка появляется только в IE, а не в других браузерах (что может вызвать &lt;a href=&quot;#scripterror&quot;&gt;ошибку&lt;/a&gt; сценария, вероятно, сценарий:</target>
        </trans-unit>
        <trans-unit id="29f29e827b24a3ffb1ab93d7db5bce55a6c4f1ce" translate="yes" xml:space="preserve">
          <source>Or, if you are using the dependency array approach, ask for the special &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;'exports' dependency:&lt;/a&gt;</source>
          <target state="translated">Или, если вы используете подход с использованием массива зависимостей, запросите специальную &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic&quot;&gt;зависимость &amp;laquo;экспорт&amp;raquo;:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44801d0d5cf3036fef8c533c5129460949cb61c" translate="yes" xml:space="preserve">
          <source>Or, in a &lt;a href=&quot;#wholeproject&quot;&gt;build profile&lt;/a&gt;:</source>
          <target state="translated">Или в &lt;a href=&quot;#wholeproject&quot;&gt;профиле сборки&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc0e1588bad559c25e336f4ce491e9bf9a9a02a1" translate="yes" xml:space="preserve">
          <source>Other Module Notes</source>
          <target state="translated">Другие примечания к модулю</target>
        </trans-unit>
        <trans-unit id="827ce3954d41bf64bd605c6e720e058b609bd8b9" translate="yes" xml:space="preserve">
          <source>Other notes:</source>
          <target state="translated">Другие заметки:</target>
        </trans-unit>
        <trans-unit id="66dbf063bcea03a792a7891f658c840f4e2eb8a5" translate="yes" xml:space="preserve">
          <source>Page Load Event Support/DOM Ready</source>
          <target state="translated">Страница Поддержка событий загрузки/Дом готов к работе</target>
        </trans-unit>
        <trans-unit id="9346ea1a2567e24e1999e03d291dbda3abc51506" translate="yes" xml:space="preserve">
          <source>Pass dependencies as an array of string values, do not grab globals.</source>
          <target state="translated">Передавайте зависимости как массив строковых значений,не захватывайте глобусы.</target>
        </trans-unit>
        <trans-unit id="0172d30c7aa6ed692ec90cac0a23592350107890" translate="yes" xml:space="preserve">
          <source>Pass the dependent modules as arguments to the factory function.</source>
          <target state="translated">Передайте зависимые модули в качестве аргументов в заводскую функцию.</target>
        </trans-unit>
        <trans-unit id="0c6289bda156d08308bc76ef1a76402bbe7a9d41" translate="yes" xml:space="preserve">
          <source>Pass the main js file's &quot;require&quot; function in the configuration to requirejs.</source>
          <target state="translated">Передайте в конфигурации функцию &quot;require&quot; главного js-файла,чтобы &quot;requirejs&quot;.</target>
        </trans-unit>
        <trans-unit id="98e5d7b826f13bc081a5c843c115d8bf9fcada6d" translate="yes" xml:space="preserve">
          <source>Path is not supported: ...</source>
          <target state="translated">Путь не поддерживается:...</target>
        </trans-unit>
        <trans-unit id="5fcfa1bf3e6a3af7d674727ac67b76e351e748ac" translate="yes" xml:space="preserve">
          <source>Plugin Names</source>
          <target state="translated">Плагинные имена</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="76bd11a64888afb8cf5d2330679e774342f2f928" translate="yes" xml:space="preserve">
          <source>Plugins and pluginBuilders that run as part of the build process have a very limited environment. The optimizer runs in a few different JS environments. Be careful of the environment assumptions if you want the plugin to run as part of the optimizer.</source>
          <target state="translated">Плагины и сборщики плагинов,которые работают как часть процесса сборки,имеют очень ограниченную среду.Оптимизатор работает в нескольких различных JS-средах.Будьте осторожны с предположениями об окружении,если вы хотите,чтобы плагин запускался как часть оптимизатора.</target>
        </trans-unit>
        <trans-unit id="a625e49b8ad0187e7c76b41bda6719cbf35d7410" translate="yes" xml:space="preserve">
          <source>Previously, we've been pointing to an example using a special require-jquery file, which consisted of require.js and jQuery concatenated. This is no longer the recommended way to use jQuery with require.js, but if you're looking for the (no longer maintained) example, &lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;you can find require-jquery here&lt;/a&gt;.</source>
          <target state="translated">Ранее мы указывали на пример использования специального файла require-jquery, который состоял из связанных файлов require.js и jQuery. Это больше не рекомендуемый способ использования jQuery с require.js, но если вы ищете (более не поддерживаемый) пример, &lt;a href=&quot;https://github.com/requirejs/require-jquery&quot;&gt;вы можете найти здесь require-jquery&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad33aa36988abe76a127defcbb28205f85bbb59" translate="yes" xml:space="preserve">
          <source>Reading code.</source>
          <target state="translated">Читаю код.</target>
        </trans-unit>
        <trans-unit id="8b982016d5900e602617c0bc1c12154c4598f912" translate="yes" xml:space="preserve">
          <source>References to dependencies are done via global variable names that were loaded via an HTML script tag.</source>
          <target state="translated">Ссылки на зависимости осуществляются через имена глобальных переменных,которые были загружены через тег HTML-скрипта.</target>
        </trans-unit>
        <trans-unit id="7bcd6090618479458d2c3f424394bc8a8a5e7003" translate="yes" xml:space="preserve">
          <source>Register the factory function by calling define(), instead of immediately executing it.</source>
          <target state="translated">Регистрация заводской функции производится вызовом функции define(),а не немедленным ее исполнением.</target>
        </trans-unit>
        <trans-unit id="0c284da9459af724aa990a40f8450015eebf6856" translate="yes" xml:space="preserve">
          <source>Relative paths are really useful if you are creating a few modules inside a directory, so that you can share the directory with other people or other projects, and you want to be able to get a handle on the sibling modules in that directory without having to know the directory's name.</source>
          <target state="translated">Относительные пути действительно полезны,если вы создаёте несколько модулей внутри каталога,так что вы можете поделиться этим каталогом с другими людьми или другими проектами,и вы хотите иметь возможность работать с модулями брата и сестры в этом каталоге без необходимости знать имя каталога.</target>
        </trans-unit>
        <trans-unit id="94cf16b1d96cb308c10ddb10fa3d66e5787888fd" translate="yes" xml:space="preserve">
          <source>RequireJS</source>
          <target state="translated">RequireJS</target>
        </trans-unit>
        <trans-unit id="47ca39fabb6dc307dd72900d813b8a172134c35a" translate="yes" xml:space="preserve">
          <source>RequireJS API</source>
          <target state="translated">Требовать JS API</target>
        </trans-unit>
        <trans-unit id="3aaf7cdebbaed3982494204c265ab9fb4280eca0" translate="yes" xml:space="preserve">
          <source>RequireJS Optimizer</source>
          <target state="translated">Оптимизатор RequireJS</target>
        </trans-unit>
        <trans-unit id="a00ba25e980ea1a174cd4c549d1dbf710ce875d4" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</source>
          <target state="translated">RequireJS позволяет настроить базовый модуль,имеющий локализованную информацию,не вынуждая вас заранее предоставлять всю локальную информацию.Он может быть добавлен с течением времени,и только строки/значения,которые меняются между локалями,могут быть определены в файле,специфичном для конкретной локали.</target>
        </trans-unit>
        <trans-unit id="2d3408430dbcb8ac254a29b55d04664b14b6f1c6" translate="yes" xml:space="preserve">
          <source>RequireJS allows you to write loader plugins that can load different types of resources as dependencies, and even include the dependencies in optimized builds.</source>
          <target state="translated">RequireJS позволяет писать плагины загрузчика,которые могут загружать различные типы ресурсов в качестве зависимостей,и даже включать зависимости в оптимизированные сборки.</target>
        </trans-unit>
        <trans-unit id="42a94b06ecd72ce8db95c0857bd11078a76ac052" translate="yes" xml:space="preserve">
          <source>RequireJS also assumes by default that all dependencies are scripts, so it does not expect to see a trailing &quot;.js&quot; suffix on module IDs. RequireJS will automatically add it when translating the module ID to a path. With the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt;, you can set up locations of a group of scripts. All of these capabilities allow you to use smaller strings for scripts as compared to traditional &amp;lt;script&amp;gt; tags.</source>
          <target state="translated">RequireJS также предполагает по умолчанию, что все зависимости являются сценариями, поэтому он не ожидает увидеть завершающий суффикс &amp;laquo;.js&amp;raquo; в идентификаторах модулей. RequireJS автоматически добавит его при переводе идентификатора модуля в путь. С помощью &lt;a href=&quot;#config-paths&quot;&gt;конфигурации путей&lt;/a&gt; вы можете настроить расположение группы скриптов. Все эти возможности позволяют использовать для скриптов строки меньшего размера по сравнению с традиционными тегами &amp;lt;script&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="55e10b7ae48550ca2e079e5fb7385a105125bd42" translate="yes" xml:space="preserve">
          <source>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</source>
          <target state="translated">RequireJS также комбинирует связки вместе,например,если французская связка была определена таким образом (опуская значение для красного цвета):</target>
        </trans-unit>
        <trans-unit id="fccadba92d8e64d1c63a0ead823d420a25b4223b" translate="yes" xml:space="preserve">
          <source>RequireJS can be used in Rhino via the &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js adapter&lt;/a&gt;. See &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;the r.js README&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS может быть использован в Rhino через &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;r.js адаптера&lt;/a&gt; . Смотрите &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/README.html&quot;&gt;в r.js README&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d54491027136cdb42cd2346edd319e96067f8363" translate="yes" xml:space="preserve">
          <source>RequireJS config options like map, packages, paths are only applied if RequireJS loads the module. If RequireJS needs to ask the node module system, the original ID is passed to Node. If you need a node module to work with a map config, inline define() calls work, as shown in &lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;this email list thread.&lt;/a&gt;</source>
          <target state="translated">Параметры конфигурации RequireJS, такие как карта, пакеты, пути, применяются только в том случае, если RequireJS загружает модуль. Если RequireJS необходимо запросить систему модуля узла, исходный идентификатор передается в Node. Если вам нужен модуль узла для работы с конфигурацией карты, работают встроенные вызовы define (), как показано в &lt;a href=&quot;https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ&quot;&gt;этой цепочке рассылки.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a4070e33492518f70bd423f5abfd334b6755" translate="yes" xml:space="preserve">
          <source>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text.js README&lt;/a&gt; for more information.</source>
          <target state="translated">У RequireJS есть плагин text.js, который может помочь с этой проблемой. Он автоматически загрузится, если текст! префикс используется для зависимости. См. &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;README&lt;/a&gt; для text.js для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5677da00d1c14ead1e4adea4966177511c24f3dc" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that can combine module definitions together into optimized bundles for browser delivery. It works as a command-line tool that you use as part of code deployment. See the &lt;a href=&quot;optimization&quot;&gt;optimization docs&lt;/a&gt; for more information.</source>
          <target state="translated">RequireJS имеет инструмент оптимизации, который может объединять определения модулей в оптимизированные пакеты для доставки через браузер. Он работает как инструмент командной строки, который вы используете как часть развертывания кода. Дополнительную информацию см. В &lt;a href=&quot;optimization&quot;&gt;документации&lt;/a&gt; по оптимизации .</target>
        </trans-unit>
        <trans-unit id="5ebed6cc24d0f8ed2a4a2bbd37a3e3109937f099" translate="yes" xml:space="preserve">
          <source>RequireJS has an optimization tool that does the following</source>
          <target state="translated">RequireJS имеет инструмент оптимизации,который делает следующее</target>
        </trans-unit>
        <trans-unit id="d2ae7c9c68ca1f789539282f1e0c6013fe1a4cab" translate="yes" xml:space="preserve">
          <source>RequireJS in Node</source>
          <target state="translated">ТребоватьJS в узле</target>
        </trans-unit>
        <trans-unit id="6c58998b40f6be8aaeb533c77012203955ebca3a" translate="yes" xml:space="preserve">
          <source>RequireJS in Node can only load modules that are on the local disk -- fetching modules across http, for instance, is not supported at this time.</source>
          <target state="translated">RequireJS в Node может загружать только те модули,которые находятся на локальном диске --загрузка модулей через http,например,в настоящее время не поддерживается.</target>
        </trans-unit>
        <trans-unit id="8789cfb66c2cb6baae8304b15d155ce3e4262022" translate="yes" xml:space="preserve">
          <source>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is &quot;en-us&quot;, then the &quot;root&quot; bundle will be used. If the locale is &quot;fr-fr-paris&quot; then the &quot;fr-fr&quot; bundle will be used.</source>
          <target state="translated">RequireJS также достаточно умно,чтобы выбрать правильный набор локалей,тот,который наиболее близко соответствует тем,которые предоставляются моими/nls/colors.Например,если локаль &quot;en-us&quot;,то будет использоваться связка &quot;root&quot;.Если локаль &quot;fr-fr-paris&quot;,то будет использоваться связка &quot;fr-fr&quot;.</target>
        </trans-unit>
        <trans-unit id="2fb4604a5e20f298faa5c59ab7ab5a36c146a3d9" translate="yes" xml:space="preserve">
          <source>RequireJS loads all code relative to a &lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt;. The baseUrl is normally set to the same directory as the script used in a data-main attribute for the top level script to load for a page. The &lt;a href=&quot;#data-main&quot;&gt;data-main attribute&lt;/a&gt; is a special attribute that require.js will check to start script loading. This example will end up with a baseUrl of &lt;strong&gt;scripts&lt;/strong&gt;:</source>
          <target state="translated">RequireJS загружает весь код относительно &lt;a href=&quot;#config-baseUrl&quot;&gt;baseUrl&lt;/a&gt; . BaseUrl обычно устанавливается в тот же каталог, что и сценарий, используемый в атрибуте data-main для сценария верхнего уровня, загружаемого для страницы. &lt;a href=&quot;#data-main&quot;&gt;Атрибут данных основных&lt;/a&gt; является специальным атрибутом , которым require.js будет проверять , чтобы начать загрузку скрипта. Этот пример будет в конечном итоге с BaseUrl из &lt;strong&gt;сценариев&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e9589541f36d742283d0c596376a86ca39ac9ec7" translate="yes" xml:space="preserve">
          <source>RequireJS loads each dependency as a script tag, using head.appendChild().</source>
          <target state="translated">RequireJS загружает каждую зависимость как тег сценария,используя head.appendChild().</target>
        </trans-unit>
        <trans-unit id="673463710a9bd2155fd9748361e294a2190a5632" translate="yes" xml:space="preserve">
          <source>RequireJS supports &lt;a href=&quot;plugins&quot;&gt;loader plugins&lt;/a&gt;. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;a list of plugins&lt;/a&gt;. This section talks about some specific plugins that are maintained alongside RequireJS:</source>
          <target state="translated">RequireJS поддерживает &lt;a href=&quot;plugins&quot;&gt;плагины загрузчика&lt;/a&gt; . Это способ поддержки зависимостей, которые не являются простыми файлами JS, но по-прежнему важны для загрузки сценария, прежде чем он сможет выполнять свою работу. В вики RequireJS есть &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;список плагинов&lt;/a&gt; . В этом разделе рассказывается о некоторых конкретных плагинах, которые поддерживаются вместе с RequireJS:</target>
        </trans-unit>
        <trans-unit id="6d58ff33f7bd1e7a83c19b7daf98cfdcff0a35f8" translate="yes" xml:space="preserve">
          <source>RequireJS supports loading modules that are in a &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS Packages&lt;/a&gt; directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</source>
          <target state="translated">RequireJS поддерживает загрузку модулей, находящихся в структуре каталогов &lt;a href=&quot;http://wiki.commonjs.org/wiki/Packages/1.1&quot;&gt;CommonJS Packages&lt;/a&gt; , но для ее работы необходимо указать дополнительную конфигурацию. В частности, есть поддержка следующих функций CommonJS Packages:</target>
        </trans-unit>
        <trans-unit id="b55dd4ac98c8bbc119acc87f176e4390a8c0ff91" translate="yes" xml:space="preserve">
          <source>RequireJS takes a different approach to script loading than traditional &amp;lt;script&amp;gt; tags. While it can also run fast and optimize well, the primary goal is to encourage modular code. As part of that, it encourages using &lt;strong&gt;module IDs&lt;/strong&gt; instead of URLs for script tags.</source>
          <target state="translated">RequireJS использует другой подход к загрузке скриптов, чем традиционные теги &amp;lt;script&amp;gt;. Хотя он также может работать быстро и хорошо оптимизироваться, основная цель - поощрять модульный код. В рамках этого он поощряет использование &lt;strong&gt;идентификаторов модулей&lt;/strong&gt; вместо URL-адресов для тегов скриптов.</target>
        </trans-unit>
        <trans-unit id="6436c4e607871db5db8f8455a8e83d61e8df8f6a" translate="yes" xml:space="preserve">
          <source>RequireJS tries to keep with the spirit of CommonJS, with using string names to refer to dependencies, and to avoid modules defining global objects, but still allow coding a module format that works well natively in the browser. RequireJS implements the &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;Asynchronous Module Definition&lt;/a&gt; (formerly Transport/C) proposal.</source>
          <target state="translated">RequireJS пытается придерживаться духа CommonJS, используя строковые имена для ссылки на зависимости и избегая модулей, определяющих глобальные объекты, но все же позволяет кодировать формат модуля, который хорошо работает в браузере. RequireJS реализует предложение определения &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;асинхронного модуля&lt;/a&gt; (ранее называвшееся Transport / C).</target>
        </trans-unit>
        <trans-unit id="8f29b8502f5345425b66e5f08837d689a07333d6" translate="yes" xml:space="preserve">
          <source>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions once the dependencies for those functions have been called. Note that the dependencies for a given module definition function could be called in any order, due to their sub-dependency relationships and network load order.</source>
          <target state="translated">RequireJS ожидает загрузки всех зависимостей,определяет правильный порядок вызова функций,определяющих модули,затем вызывает функции определения модулей после вызова зависимостей для этих функций.Обратите внимание,что зависимости для данной функции определения модулей могут быть вызваны в любом порядке,благодаря их зависимостям и порядку загрузки сети.</target>
        </trans-unit>
        <trans-unit id="8f0dfe99c16d5f457a6040729f397e4386f8b570" translate="yes" xml:space="preserve">
          <source>RequireJS will load the plugin module first, then pass the rest of the dependency name to a load() method on the plugin. There are also some methods to help with module name normalization and for making use of the plugin as part of the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt;.</source>
          <target state="translated">RequireJS сначала загрузит модуль подключаемого модуля, а затем передаст остальную часть имени зависимости методу load () подключаемого модуля. Есть также несколько методов, которые помогут с нормализацией имени модуля и для использования плагина как части &lt;a href=&quot;optimization&quot;&gt;оптимизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a29bbde38e6f3231cde9d0379103efa2d21c69b" translate="yes" xml:space="preserve">
          <source>RequireJS will use &lt;strong&gt;baseUrl&lt;/strong&gt; to resolve the paths for any module names. The &lt;strong&gt;baseUrl&lt;/strong&gt; should be relative to &lt;strong&gt;appDir&lt;/strong&gt;.</source>
          <target state="translated">RequireJS будет использовать &lt;strong&gt;baseUrl&lt;/strong&gt; для разрешения путей для любых имен модулей. &lt;strong&gt;BaseUrl&lt;/strong&gt; должен быть по отношению к &lt;strong&gt;AppDir&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="688bb14e2599e744cb6ca3a0873b76582ff0f536" translate="yes" xml:space="preserve">
          <source>RequireJS will use its &lt;a href=&quot;api#config&quot;&gt;Configuration Options&lt;/a&gt; first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like &lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt;, and do not configure their locations with RequireJS.</source>
          <target state="translated">RequireJS сначала будет использовать свои &lt;a href=&quot;api#config&quot;&gt;параметры конфигурации&lt;/a&gt; для поиска модулей. Если RequireJS не может найти модуль с его конфигурацией, предполагается, что это модуль, который использует тип модулей и конфигурацию Node. Итак, настраивайте расположение модулей с помощью RequireJS, только если они используют RequireJS API. Для модулей, которые ожидают API-интерфейсы Node и конфигурацию / пути, просто установите их с помощью диспетчера пакетов Node, например &lt;a href=&quot;http://npmjs.org/&quot;&gt;npm&lt;/a&gt; , и не настраивайте их расположение с помощью RequireJS.</target>
        </trans-unit>
        <trans-unit id="721bf008a2bc600d3c32a3b29e21d14cb20b6f23" translate="yes" xml:space="preserve">
          <source>RequireJS will use its &lt;a href=&quot;api#config&quot;&gt;Configuration Options&lt;/a&gt; first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like &lt;a href=&quot;https://npmjs.org/&quot;&gt;npm&lt;/a&gt;, and do not configure their locations with RequireJS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c839298d9c9623cb8e392c4497e969c4790ef6e" translate="yes" xml:space="preserve">
          <source>RequireJS will use the browser's navigator.languages, navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the &lt;a href=&quot;#config-moduleconfig&quot;&gt;module config&lt;/a&gt; to pass the locale to the plugin:</source>
          <target state="translated">RequireJS будет использовать свойство браузера navigator.languages, navigator.language или navigator.userLanguage, чтобы определить, какие значения языкового стандарта использовать для my / nls / colors, чтобы ваше приложение не менялось. Если вы предпочитаете устанавливать языковой стандарт, вы можете использовать &lt;a href=&quot;#config-moduleconfig&quot;&gt;конфигурацию модуля&lt;/a&gt; для передачи языкового стандарта плагину:</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3f10ab66132d869b60a146832a0c5b877741a373" translate="yes" xml:space="preserve">
          <source>Rhino Support</source>
          <target state="translated">Поддержка носорогов</target>
        </trans-unit>
        <trans-unit id="5cdeacc3fcee5a3d0cc852f72b086b0c1d3b1b46" translate="yes" xml:space="preserve">
          <source>Script Loading APIs</source>
          <target state="translated">API загрузки скрипта</target>
        </trans-unit>
        <trans-unit id="dd7fe2e96e7ebbf0541153c92fa3cd3835838976" translate="yes" xml:space="preserve">
          <source>Script Loading: Web Workers</source>
          <target state="translated">Загрузка сценария:Веб-работники</target>
        </trans-unit>
        <trans-unit id="28c6a0f178110b7c5ee9c71b12d4ecc6644a0cba" translate="yes" xml:space="preserve">
          <source>Script Loading: XHR</source>
          <target state="translated">Загрузка сценария:XHR</target>
        </trans-unit>
        <trans-unit id="806dde701e4839cc61a55b54f617f0476f1d3ee0" translate="yes" xml:space="preserve">
          <source>Script Loading: document.write()</source>
          <target state="translated">Загрузка скрипта:document.write()</target>
        </trans-unit>
        <trans-unit id="60346569fcbd6bf8b72d2ad70cffec0d959f65b5" translate="yes" xml:space="preserve">
          <source>Script Loading: head.appendChild(script)</source>
          <target state="translated">Сценарий Загрузка:head.appendChild(script)</target>
        </trans-unit>
        <trans-unit id="db54505af4dab7b72398b3e7754b587c923bd562" translate="yes" xml:space="preserve">
          <source>Script error</source>
          <target state="translated">ошибка сценария</target>
        </trans-unit>
        <trans-unit id="6875cba1ccf3cfd56f772e1129de1d0c7afb8560" translate="yes" xml:space="preserve">
          <source>Script loading APIs</source>
          <target state="translated">API загрузки скрипта</target>
        </trans-unit>
        <trans-unit id="31f0eeca69d93e11dcc7ab2a4e310b48538b63b1" translate="yes" xml:space="preserve">
          <source>Script loading: Web Workers</source>
          <target state="translated">Загрузка сценария:Веб-работники</target>
        </trans-unit>
        <trans-unit id="e9d88717ea3152125e41b249b9019556f13f241f" translate="yes" xml:space="preserve">
          <source>Script loading: XHR</source>
          <target state="translated">Загрузка сценария:XHR</target>
        </trans-unit>
        <trans-unit id="59f54191b9255eb86b70dd4cc8c5871f655716d3" translate="yes" xml:space="preserve">
          <source>Script loading: document.write()</source>
          <target state="translated">Загрузка скрипта:document.write()</target>
        </trans-unit>
        <trans-unit id="22646269707ddc713b377c7499e8bd2b5f3d4a7b" translate="yes" xml:space="preserve">
          <source>Script loading: head.appendchild(script)</source>
          <target state="translated">Загрузка скрипта:head.appendchild(script)</target>
        </trans-unit>
        <trans-unit id="61c2152b82f1ea69ef3fd9c78b7ef62b9bc77399" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;text! plugin&lt;/a&gt; for an example of writeFile.</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://github.com/requirejs/text&quot;&gt;текст! плагин&lt;/a&gt; для примера writeFile.</target>
        </trans-unit>
        <trans-unit id="40d3cc95499cba07de8b5028ea38fbb5a6869a5b" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;index&quot;&gt;API docs&lt;/a&gt; for more information on that syntax.</source>
          <target state="translated">Дополнительную информацию об этом синтаксисе см. В &lt;a href=&quot;index&quot;&gt;документации API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e200d0bc7ac72dc2a3ed047bd78b5d5acaa6d8d" translate="yes" xml:space="preserve">
          <source>See the notes for the &lt;a href=&quot;#onejs&quot;&gt;Optimizing one JavaScript file&lt;/a&gt; about avoiding saving optimized files in your pristine source tree. It is only done here to make the example simpler.</source>
          <target state="translated">См. Примечания к &lt;a href=&quot;#onejs&quot;&gt;Оптимизации одного файла JavaScript,&lt;/a&gt; чтобы избежать сохранения оптимизированных файлов в исходном дереве исходного кода. Это сделано здесь только для упрощения примера.</target>
        </trans-unit>
        <trans-unit id="c74306bac8e3a4dc448afdd8cae317b6caccd986" translate="yes" xml:space="preserve">
          <source>Setting Exported Value</source>
          <target state="translated">Установка экспортной стоимости</target>
        </trans-unit>
        <trans-unit id="e65edca48b8f7a17979616fa3db4cf39e464286e" translate="yes" xml:space="preserve">
          <source>Shallow exclusions for fast development</source>
          <target state="translated">Мелкие исключения для быстрого развития</target>
        </trans-unit>
        <trans-unit id="670595ae52d642feb7afce4692abba1e144a6acb" translate="yes" xml:space="preserve">
          <source>Shim config is not supported when running AMD modules in node via RequireJS (it works for optimizer use though). Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers. As of RequireJS 2.1.7, it will warn you in the console that shim config is not supported, and it may or may not work. If you wish to suppress that message, you can pass &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt;.</source>
          <target state="translated">Конфигурация Shim не поддерживается при запуске модулей AMD в узле через RequireJS (хотя она работает для использования оптимизатором). В зависимости от модуля, к которому применяется оболочка, может произойти сбой в Node, потому что Node не имеет той же глобальной среды, что и браузеры. Начиная с RequireJS 2.1.7, он будет предупреждать вас в консоли, что конфигурация оболочки совместимости не поддерживается и может работать, а может и не работать. Если вы хотите подавить это сообщение, вы можете передать &lt;code&gt;requirejs.config({ suppress: { nodeShim: true }});&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e449b95be2fea702382b47ae55a5f9733158675f" translate="yes" xml:space="preserve">
          <source>Similarly, to avoid a bunch of configuration, it is best to avoid deep folder hierarchies for scripts, and instead either keep all the scripts in baseUrl, or if you want to separate your library/vendor-supplied code from your app code, use a directory layout like this:</source>
          <target state="translated">Точно так же,чтобы избежать кучи конфигураций,лучше избегать глубоких иерархий папок для скриптов,и вместо этого либо держать все скрипты в baseUrl,либо,если вы хотите отделить ваш код библиотеки/поставщика от кода вашего приложения,используйте раскладку папок,подобную этой:</target>
        </trans-unit>
        <trans-unit id="0632c0bc11dc47cc43ee33aff39b70f96ab057b5" translate="yes" xml:space="preserve">
          <source>Simple Name/Value Pairs</source>
          <target state="translated">Простые Пары Имя/Ценность</target>
        </trans-unit>
        <trans-unit id="c430387334d60a570098cede5519da79215c2b16" translate="yes" xml:space="preserve">
          <source>Since &quot;require&quot; is a reserved dependency name, you create a &quot;requireLib&quot; dependency and map it to the require.js file.</source>
          <target state="translated">Поскольку &quot;require&quot;-это зарезервированное имя зависимости,вы создаете зависимость &quot;requireLib&quot; и привязываете ее к файлу require.js.</target>
        </trans-unit>
        <trans-unit id="dc83d3c0ed853600c8e42ef6d4d34068151435ec" translate="yes" xml:space="preserve">
          <source>Since DOM ready is a common application need, ideally the nested functions in the API above could be avoided. The domReady module also implements the &lt;a href=&quot;plugins&quot;&gt;Loader Plugin API&lt;/a&gt;, so you can use the loader plugin syntax (notice the &lt;b&gt;!&lt;/b&gt; in the domReady dependency) to force the require() callback function to wait for the DOM to be ready before executing.</source>
          <target state="translated">Поскольку DOM-готовность - это обычная потребность приложения, в идеале можно было бы избежать вложенных функций в API выше. Модуль domReady также реализует &lt;a href=&quot;plugins&quot;&gt;API плагина загрузчика&lt;/a&gt; , поэтому вы можете использовать синтаксис плагина загрузчика (обратите внимание на &lt;b&gt;!&lt;/b&gt; В зависимости domReady), чтобы заставить функцию обратного вызова require () дождаться готовности DOM перед выполнением.</target>
        </trans-unit>
        <trans-unit id="d0c10d513247ddb5f7d6111dfbb3f09b80b710d8" translate="yes" xml:space="preserve">
          <source>Since the number of browsers that cannot support this toString() scanning is very small, it is safe to use this sugared form for all your modules, particularly if you like to line up the dependency names with the variables that will hold their module values.</source>
          <target state="translated">Так как количество браузеров,которые не могут поддерживать это сканирование с помощью функцииString()очень мало,то безопасно использовать эту sugared форму для всех ваших модулей,особенно если вы хотите выстроить имена зависимостей в линию с переменными,которые будут хранить значения их модулей.</target>
        </trans-unit>
        <trans-unit id="52b854694bd5e5771964d6aeb56b3122adca21f7" translate="yes" xml:space="preserve">
          <source>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim config, always set &lt;b&gt;enforceDefine&lt;/b&gt; to be true. See the next section for an example.</source>
          <target state="translated">Поэтому, если вы хотите поддерживать Internet Explorer, перехватывать ошибки загрузки и иметь модульный код либо с помощью прямых вызовов define (), либо с помощью конфигурации &lt;b&gt;оболочки&lt;/b&gt; , всегда устанавливайте &lt;b&gt;enforceDefine&lt;/b&gt; равным true. См. Пример в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="adb1e49d3b56382dbb3da8e1388589dbfdb6edd8" translate="yes" xml:space="preserve">
          <source>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</source>
          <target state="translated">Поэтому с IE очень сложно разрешить как анонимные AMD-модули,которые являются основным преимуществом AMD-модулей,так и надежное обнаружение ошибок.</target>
        </trans-unit>
        <trans-unit id="ed198cdf72a10321f902977a45fe3402f281e373" translate="yes" xml:space="preserve">
          <source>So to reiterate, you will likely get an error if you refer to jQuery with another module name, like &lt;code&gt;'lib/jquery'&lt;/code&gt;. &lt;strong&gt;This example will not work&lt;/strong&gt;:</source>
          <target state="translated">Итак, повторюсь, вы, вероятно, получите ошибку, если обратитесь к jQuery с другим именем модуля, например &lt;code&gt;'lib/jquery'&lt;/code&gt; . &lt;strong&gt;Этот пример не сработает&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="7584d5a05b7d1c094e8b77096a5d326613084abd" translate="yes" xml:space="preserve">
          <source>So we need to know the dependencies and make sure we load them before executing our script. The best way to do that is construct our module loading API with function wrappers. Like so:</source>
          <target state="translated">Поэтому нам нужно знать зависимости и убедиться,что мы загрузили их перед выполнением нашего сценария.Лучший способ сделать это-сконструировать наш модуль,загружающий API с помощью обёртки функций.Так и есть:</target>
        </trans-unit>
        <trans-unit id="ca7eb5272fcc04433bcc053cb2963d977963db96" translate="yes" xml:space="preserve">
          <source>So, the plugin's module name comes before the ! separator. The part after the ! separator is called the &lt;b&gt;resource name&lt;/b&gt;. The resource name may look like a normal module name. The plugin's module name can be any valid module name, so for instance, you could use a relative indicator:</source>
          <target state="translated">Итак, имя модуля плагина стоит перед! разделитель. Часть после! разделитель называется &lt;b&gt;именем ресурса&lt;/b&gt; . Имя ресурса может выглядеть как обычное имя модуля. Имя модуля плагина может быть любым допустимым именем модуля, поэтому, например, вы можете использовать относительный индикатор:</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="5b1c2f328244970b14a382cc8a349babf5b6d91c" translate="yes" xml:space="preserve">
          <source>Some environments do not allow eval().</source>
          <target state="translated">Некоторые среды не позволяют использовать eval().</target>
        </trans-unit>
        <trans-unit id="07007bf416c3f4f988e538292cbda2590016887c" translate="yes" xml:space="preserve">
          <source>Some notes about using a pluginBuilder:</source>
          <target state="translated">Некоторые заметки об использовании плагин-конструктора:</target>
        </trans-unit>
        <trans-unit id="eec270a80e28815db46c4a348f8a91f7a7d65008" translate="yes" xml:space="preserve">
          <source>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using &lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; in Node, those also need to complete synchronously to match Node's synchronous module system.</source>
          <target state="translated">Некоторые плагины могут выполнять асинхронную операцию в браузере, но выбирают синхронную загрузку ресурсов при запуске в Node / Nashorn. Это то, что делает текстовый плагин. Если вы просто хотите запускать модули AMD и загружать зависимости плагинов с помощью &lt;a href=&quot;http://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; в Node, они также должны выполняться синхронно, чтобы соответствовать системе синхронных модулей Node.</target>
        </trans-unit>
        <trans-unit id="481dc38cae68c948e1d659f3b1dcfb25af737ad5" translate="yes" xml:space="preserve">
          <source>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine&lt;/a&gt; in Node, those also need to complete synchronously to match Node's synchronous module system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98e0c339cb5123126f2c87c4e5f5e975fbf4182" translate="yes" xml:space="preserve">
          <source>Some plugins may need to evaluate some JavaScript that was retrieved as text, and use that evaluated JavaScript as the value for the resource. There is a function off the onload() argument, &lt;strong&gt;onload.fromText()&lt;/strong&gt;, that can be used to evaluate the JavaScript. eval() is used by RequireJS to evaluate that JavaScript, and RequireJS will do the right work for any anonymous define() call in the evaluated text, and use that define() module as the value for the resource.</source>
          <target state="translated">Некоторым плагинам может потребоваться оценить некоторый JavaScript, который был получен как текст, и использовать этот оцениваемый JavaScript как значение для ресурса. В аргументе onload () есть функция &lt;strong&gt;onload.fromText ()&lt;/strong&gt; , которую можно использовать для оценки JavaScript. eval () используется RequireJS для оценки этого JavaScript, и RequireJS будет выполнять правильную работу для любого анонимного вызова define () в оцениваемом тексте и использовать этот модуль define () в качестве значения для ресурса.</target>
        </trans-unit>
        <trans-unit id="a77096861b93dda4c39daec387e1adc8966cb7b0" translate="yes" xml:space="preserve">
          <source>Some sort of #include/import/require</source>
          <target state="translated">Что-то вроде #include/импорта/требования</target>
        </trans-unit>
        <trans-unit id="bd025dec7c9eed165679f96d5db69313b876152d" translate="yes" xml:space="preserve">
          <source>Some types of circular dependencies.</source>
          <target state="translated">Некоторые типы круговых зависимостей.</target>
        </trans-unit>
        <trans-unit id="d937f64e544eafc99471358c2faba19abd5ae90a" translate="yes" xml:space="preserve">
          <source>Something similar is possible with paths config, but it is much wordier, and the paths config route does not allow loader plugin resource IDs in its configuration, since the paths config values are path segments, not IDs.</source>
          <target state="translated">Что-то похожее возможно при конфигурировании путей,но это гораздо сложнее,и конфигурационный маршрут путей не позволяет использовать идентификаторы ресурсов плагина загрузчика в его конфигурации,так как значения конфигурационных путей-это сегменты пути,а не идентификаторы.</target>
        </trans-unit>
        <trans-unit id="30e86ffbe954826823e73c12cfc55bea76005dff" translate="yes" xml:space="preserve">
          <source>Source maps</source>
          <target state="translated">Карты источников</target>
        </trans-unit>
        <trans-unit id="821968db542d3c05ea3a4f2fcda630b7acc0474b" translate="yes" xml:space="preserve">
          <source>Specify a JSONP Service Dependency</source>
          <target state="translated">Укажите зависимость от услуг JSONP</target>
        </trans-unit>
        <trans-unit id="578a43d52c70e40530d94cddc8363ce456449172" translate="yes" xml:space="preserve">
          <source>Specify a Text File Dependency</source>
          <target state="translated">Укажите текстовую зависимость файла</target>
        </trans-unit>
        <trans-unit id="d76e7ed422b0495466015a46e070fb6f00448162" translate="yes" xml:space="preserve">
          <source>Starts with a &quot;/&quot;.</source>
          <target state="translated">Начинается с &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="7e371c122fa82685d7671b68016968141187d2ec" translate="yes" xml:space="preserve">
          <source>Sugar</source>
          <target state="translated">Sugar</target>
        </trans-unit>
        <trans-unit id="8f97776b7c626d7c787bc588e92f2b2b737f5f55" translate="yes" xml:space="preserve">
          <source>Supported configuration options:</source>
          <target state="translated">Поддерживаемые опции конфигурации:</target>
        </trans-unit>
        <trans-unit id="1d3251f0fb778fe3a355e2f1674b59fed9ce6f5e" translate="yes" xml:space="preserve">
          <source>That config states: modules 'main', 'util', 'text' and 'text!template.html' will be found by loading module ID 'primary'. Module 'text!secondary.html' can be found by loading module ID 'secondary'.</source>
          <target state="translated">В этом конфигурационном состоянии:модули 'main','util','text' и 'text!template.html' будут найдены при загрузке идентификатора модуля 'primary'.Модуль 'text!secondary.html' можно найти,загрузив идентификатор модуля 'secondary'.</target>
        </trans-unit>
        <trans-unit id="66f7f17f0623e2b899f65569369b3f96996b2778" translate="yes" xml:space="preserve">
          <source>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</source>
          <target state="translated">Этот тип модуля полагается на прикрепление свойств к глобальному объекту для экспорта значения модуля,и объявление зависимостей с данной моделью затруднительно.Предполагается,что зависимости будут сразу же доступны при выполнении данной функции.Это ограничивает стратегии загрузки зависимостей.</target>
        </trans-unit>
        <trans-unit id="4b5f14ad5e1dddfd4e78fad824cde3595b71d76f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;index!&lt;/b&gt; plugin could be written like so:</source>
          <target state="translated">&lt;b&gt;Индекс! &lt;/b&gt;плагин можно было бы написать так:</target>
        </trans-unit>
        <trans-unit id="9079b459ee168c30bd095d64a00af0fccaf64255" translate="yes" xml:space="preserve">
          <source>The AMD execution model is better aligned with how ECMAScript Harmony modules are being specified. The CommonJS modules that would not work in an AMD wrapper will also not work as a Harmony module. AMD's code execution behavior is more future compatible.</source>
          <target state="translated">Модель исполнения AMD лучше согласуется с тем,как задаются модули гармонии ECMAScript.Модули CommonJS,которые не будут работать в AMD-обертке,также не будут работать в качестве модуля Harmony.Поведение выполнения кода в AMD более совместимо с будущим.</target>
        </trans-unit>
        <trans-unit id="0ea1b57a9458b65d966c291b92a6e5f40f3e9499" translate="yes" xml:space="preserve">
          <source>The AMD format comes from wanting a module format that was better than today's &quot;write a bunch of script tags with implicit dependencies that you have to manually order&quot; and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started. It grew out of Dojo's real world experience with using XHR+eval and wanting to avoid its weaknesses for the future.</source>
          <target state="translated">Формат AMD происходит от желания иметь модульный формат,который был бы лучше,чем сегодняшний &quot;писать кучу тегов сценариев с неявными зависимостями,которые нужно заказывать вручную&quot;,и что-то,что было бы легко использовать непосредственно в браузере.Что-то с хорошими отладочными характеристиками,не требующее для запуска специфических для сервера инструментов.Оно выросло из реального опыта Dojo по использованию XHR+eval и желания избежать его слабых мест в будущем.</target>
        </trans-unit>
        <trans-unit id="c808a506a2b1a1d3a8441fd50fe8872a13558f0e" translate="yes" xml:space="preserve">
          <source>The AMD loader will parse out the require('') calls by using Function.prototype.toString(), then internally convert the above define call into this:</source>
          <target state="translated">Загрузчик AMD будет разбирать вызовы require('')с помощью Function.prototype.toString(),а затем внутренне преобразовывать в это указанное выше определение вызова:</target>
        </trans-unit>
        <trans-unit id="11a4dc84c9d70c7ea727b71031d89d8fdc9c59e5" translate="yes" xml:space="preserve">
          <source>The CJS module format only allowed one module per file, so a &quot;transport format&quot; would be used for bundling more than one module in a file for optimization/bundling purposes.</source>
          <target state="translated">Формат модуля CJS разрешал только один модуль в архиве,так что &quot;транспортный формат&quot; был бы использован для связывания больше чем одного модуля в архиве для целей оптимизации/объединения.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">Проблема</target>
        </trans-unit>
        <trans-unit id="a39ad20def9de6ddadb36d4488aeb74ca38ea578" translate="yes" xml:space="preserve">
          <source>The RequireJS optimizer, as of version 1.0.3, will strip out the use of 'amdefine' above, so it is safe to use this module for your web-based projects too. Just be sure to use &lt;strong&gt;the exact 'amdefine' if() test and contents as shown above&lt;/strong&gt;. Differences in spaces/line breaks are allowed. See the &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;amdefine project&lt;/a&gt; for more information.</source>
          <target state="translated">Оптимизатор RequireJS, начиная с версии 1.0.3, исключает использование указанного выше amdefine, поэтому его можно безопасно использовать и для ваших веб-проектов. Просто убедитесь, что используете &lt;strong&gt;точный тест и содержимое amdefine if (), как показано выше&lt;/strong&gt; . Допускаются различия в пробелах / переносах строк. См. &lt;a href=&quot;https://github.com/jrburke/amdefine&quot;&gt;Проект amdefine&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b330aa0f4d280892b5122f26adc82cf344b78ceb" translate="yes" xml:space="preserve">
          <source>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to &lt;a href=&quot;#multiversion&quot;&gt;load multiple versions of a module in a page&lt;/a&gt;.</source>
          <target state="translated">Синтаксис RequireJS для модулей позволяет загружать их как можно быстрее, даже если они не в порядке, но оцениваются в правильном порядке зависимости, а поскольку глобальные переменные не создаются, это позволяет &lt;a href=&quot;#multiversion&quot;&gt;загружать несколько версий модуля на страницу.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef05a888778e04dcbd6355136af94fe3f21ee10" translate="yes" xml:space="preserve">
          <source>The RequireJS wiki has a longer &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;list of plugins&lt;/a&gt;.</source>
          <target state="translated">В вики RequireJS есть более длинный &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Plugins&quot;&gt;список плагинов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10037c39cb0572d4517b7b19be7e3b6e476d3924" translate="yes" xml:space="preserve">
          <source>The Web Today</source>
          <target state="translated">The Web Today</target>
        </trans-unit>
        <trans-unit id="d6f95b126d877e46f4ca85d50dfc9f3c59e1b78b" translate="yes" xml:space="preserve">
          <source>The above AMD example works in all browsers. However, there is a risk of mismatched dependency names with named function arguments, and it can start to look a bit strange if your module has many dependencies:</source>
          <target state="translated">Вышеприведенный пример AMD работает во всех браузерах.Однако существует риск несовпадения имен зависимостей с именованными аргументами функций,и это может выглядеть немного странно,если в вашем модуле много зависимостей:</target>
        </trans-unit>
        <trans-unit id="ea71ad89663a3826e96822644f48226e30ddba03" translate="yes" xml:space="preserve">
          <source>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths config allows array values:</source>
          <target state="translated">Вышеприведенный шаблон для обнаружения сбоя загрузки,undef()ing модуля,изменения путей и перезагрузки является достаточно распространенным запросом,что также является его сокращенным вариантом.Конфигурация путей позволяет получать значения массивов:</target>
        </trans-unit>
        <trans-unit id="86f2b9664fdda056e416ecb6be7e43754e30ec9f" translate="yes" xml:space="preserve">
          <source>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</source>
          <target state="translated">BaseUrl может быть URL на другом домене в качестве страницы,которая будет загружать require.js.Загрузка скрипта requireJS работает на всех доменах.Единственное ограничение-это текстовое содержимое,загружаемое текстовыми плагинами:эти пути должны быть на том же домене,что и страница,по крайней мере,во время разработки.Оптимизация инструмент будет встраиваемый текст! плагин ресурсов,так что после использования инструмента оптимизации,вы можете использовать ресурсы,которые ссылаются на текст! плагин ресурсов из другого домена.</target>
        </trans-unit>
        <trans-unit id="188d96d93a522f85db45464063c57eeed54c2581" translate="yes" xml:space="preserve">
          <source>The biggest time drain is minification. If you are just doing builds as part of a dev workflow, then set &lt;strong&gt;optimize&lt;/strong&gt; to &lt;code&gt;&quot;none&quot;&lt;/code&gt;.</source>
          <target state="translated">Самый большой расход времени - это минификация. Если вы просто делаете сборки как часть рабочего процесса разработчика, установите для параметра &lt;strong&gt;optimize&lt;/strong&gt; значение &lt;code&gt;&quot;none&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="833cfb3d9133e355fe39d334558fdb889f46740f" translate="yes" xml:space="preserve">
          <source>The complete Plugin API:</source>
          <target state="translated">Полный API плагина:</target>
        </trans-unit>
        <trans-unit id="fbf24dab70c96ad5b4a4111826b377d63c4b7d93" translate="yes" xml:space="preserve">
          <source>The contents of that file should look like so:</source>
          <target state="translated">Содержимое этого файла должно выглядеть так:</target>
        </trans-unit>
        <trans-unit id="57689d439b992bc5af51a359d8f6310514b900ad" translate="yes" xml:space="preserve">
          <source>The data-main attribute is a special attribute that require.js will check to start script loading:</source>
          <target state="translated">Атрибут data-main-это специальный атрибут,который требует,чтобы файл require.js проверял загрузку скрипта:</target>
        </trans-unit>
        <trans-unit id="7f1d6700235d757014c048a09c5572615308e47e" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is for &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to be true. So if using &lt;strong&gt;generateSourceMaps&lt;/strong&gt;, then explicitly set &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; to false. If you want to preserve some license comments, you can manually modify the license comments in the JS source to use the JSDoc-style &lt;code&gt;@license&lt;/code&gt; comment. See &quot;&lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;Annotating JavaScript for the Closure Compiler&lt;/a&gt;&quot; for more information. That same format works for UglifyJS2.</source>
          <target state="translated">По умолчанию оптимизатор принимает значение true для &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; . Поэтому, если вы используете &lt;strong&gt;generateSourceMaps&lt;/strong&gt; , явно установите для &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; значение false. Если вы хотите сохранить некоторые комментарии к лицензии, вы можете вручную изменить комментарии к лицензии в исходном коде JS, чтобы использовать комментарий &lt;code&gt;@license&lt;/code&gt; в стиле JSDoc . См. &amp;laquo; &lt;a href=&quot;https://developers.google.com/closure/compiler/docs/js-for-compiler#tag-license&quot;&gt;Аннотирование JavaScript для компилятора закрытия&lt;/a&gt; &amp;raquo; для получения дополнительной информации. Тот же формат работает для UglifyJS2.</target>
        </trans-unit>
        <trans-unit id="ed208f1f847352477d5ff2c440d221d28e46603f" translate="yes" xml:space="preserve">
          <source>The default for the optimizer is to do the safest, most robust set of actions that avoid surprises after a build. However, depending on your project setup, you may want to turn off some of these features to get faster builds:</source>
          <target state="translated">По умолчанию оптимизатор выполняет самый безопасный и надежный набор действий,который позволяет избежать сюрпризов после сборки.Однако,в зависимости от настройки проекта,вы можете отключить некоторые из этих функций,чтобы получить более быструю сборку:</target>
        </trans-unit>
        <trans-unit id="7240c5ed21fca9b8654b10aeae53d76526350c3d" translate="yes" xml:space="preserve">
          <source>The dependencies are very weakly stated: the developer needs to know the right dependency order. For instance, The file containing Backbone cannot come before the jQuery tag.</source>
          <target state="translated">Зависимости сформулированы очень слабо:разработчику необходимо знать правильный порядок зависимостей.Например,файл,содержащий Backbone,не может прийти до тега jQuery.</target>
        </trans-unit>
        <trans-unit id="61bd565a453f9fd7f3247103a42eaddea165cea4" translate="yes" xml:space="preserve">
          <source>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</source>
          <target state="translated">Объект ошибки,переданный в errbacks и глобальная функция requirejs.onError обычно содержат два пользовательских свойства:</target>
        </trans-unit>
        <trans-unit id="316bf166ecc014ef8bc6882e464ddfb3c066d80a" translate="yes" xml:space="preserve">
          <source>The example above in the &lt;strong&gt;Multiversion Support&lt;/strong&gt; section shows how code can later be loaded by nested require() calls.</source>
          <target state="translated">В приведенном выше примере в разделе &amp;laquo; &lt;strong&gt;Поддержка нескольких версий&lt;/strong&gt; &amp;raquo; показано, как впоследствии можно загрузить код с помощью вложенных вызовов require ().</target>
        </trans-unit>
        <trans-unit id="2f906ca6df78eb04d4f2471e8af7277fa535310f" translate="yes" xml:space="preserve">
          <source>The examples in this page will assume you downloaded and saved r.js in a directory that is a sibling to your project directory. The optimizer that is part of r.js can live anywhere you want, but you will likely need to adjust the paths accordingly in these examples.</source>
          <target state="translated">Примеры на этой странице будут предполагать,что вы скачали и сохранили r.js в каталоге,который является братом или сестрой в каталоге вашего проекта.Оптимизатор,входящий в состав r.js,может жить где угодно,но в этих примерах вам,скорее всего,придется соответствующим образом настроить пути.</target>
        </trans-unit>
        <trans-unit id="63f1352f2a22f29f7eba80a7f07fe3640f7c41b3" translate="yes" xml:space="preserve">
          <source>The function call above specifies two arguments, &quot;cart&quot; and &quot;inventory&quot;. These are the modules represented by the &quot;./cart&quot; and &quot;./inventory&quot; module names.</source>
          <target state="translated">Вызов функции,описанный выше,задает два аргумента:&quot;тележка&quot; и &quot;инвентаризация&quot;.Это модули,представленные названиями модулей &quot;./тележка&quot; и &quot;./инвентарь&quot;.</target>
        </trans-unit>
        <trans-unit id="ba297d0cdf6db0dcddbde4f96f4e5f762f3c8d6b" translate="yes" xml:space="preserve">
          <source>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the &quot;cart&quot; and &quot;inventory&quot; arguments.</source>
          <target state="translated">Функция не вызывается до тех пор,пока не будут загружены модули my/cart и my/inventory,а функция получает модули в качестве аргументов &quot;корзина&quot; и &quot;инвентарь&quot;.</target>
        </trans-unit>
        <trans-unit id="646d4a9744ff05859b5314213bf0fc732c97dc58" translate="yes" xml:space="preserve">
          <source>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a &quot;paths&quot; array config, and a global requirejs.onError.</source>
          <target state="translated">Общий класс ошибок-404s для скриптов (не найденных),таймауты сети или ошибки в загруженных скриптах.В RequireJS есть несколько инструментов для работы с ними:require-specific errbacks,a &quot;path&quot; array config и global requirejs.onError.</target>
        </trans-unit>
        <trans-unit id="e63c31bbc3167bcd297e7f2c00dc5d691b57b43a" translate="yes" xml:space="preserve">
          <source>The init function will &lt;strong&gt;not&lt;/strong&gt; be called for AMD modules. For example, you cannot use a shim init function to call jQuery's noConflict. See &lt;a href=&quot;jquery#noconflictmap&quot;&gt;Mapping Modules to use noConflict&lt;/a&gt; for an alternate approach to jQuery.</source>
          <target state="translated">Функция init &lt;strong&gt;не&lt;/strong&gt; будет вызываться для модулей AMD. Например, вы не можете использовать функцию инициализации оболочки для вызова jQuery noConflict. См. Раздел &lt;a href=&quot;jquery#noconflictmap&quot;&gt;Сопоставление модулей для использования noConflict, чтобы узнать&lt;/a&gt; об альтернативном подходе к jQuery.</target>
        </trans-unit>
        <trans-unit id="79cd9e532bfc3f909ce1a7cd0b33b3a46f14bfc7" translate="yes" xml:space="preserve">
          <source>The modules that break are ones that do a dynamic calculation of a dependency, anything that does not use a string literal for the require() call, and anything that does not look like a declarative require() call. So things like this fail:</source>
          <target state="translated">Модули,которые ломаются-это те,которые делают динамическое вычисление зависимости,все,что не использует строковый литерал для вызова require(),и все,что не выглядит как декларативный вызов require().Таким образом,такие вещи терпят неудачу:</target>
        </trans-unit>
        <trans-unit id="3015edf1d8929053306c224b7504d1c821a6e9f9" translate="yes" xml:space="preserve">
          <source>The my/lamps module has one property called &quot;testMessage&quot; that uses colors.red to show the localized value for the color red.</source>
          <target state="translated">Модуль my/lamps имеет одно свойство,называемое &quot;testMessage&quot;,которое использует color.red,чтобы показать локализованное значение для цвета красного.</target>
        </trans-unit>
        <trans-unit id="f2c2c7d55feef0ee5662cbb414805068c6cae379" translate="yes" xml:space="preserve">
          <source>The node module also exposes the RequireJS Optimizer as an &lt;strong&gt;optimize&lt;/strong&gt; method for using the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; via a function call instead of a command line tool:</source>
          <target state="translated">Модуль узла также предоставляет оптимизатор RequireJS в качестве метода &lt;strong&gt;оптимизации&lt;/strong&gt; для использования &lt;a href=&quot;optimization&quot;&gt;оптимизатора RequireJS&lt;/a&gt; через вызов функции вместо инструмента командной строки:</target>
        </trans-unit>
        <trans-unit id="6350be35e53443e7abedf9e1bacdc3773be517cd" translate="yes" xml:space="preserve">
          <source>The optimizer can be run using Node, Java with Rhino or Nashorn, or in the browser. The requirements for each option:</source>
          <target state="translated">Оптимизатор может быть запущен с помощью Node,Java с Rhino или Nashorn,или в браузере.Требования к каждому варианту:</target>
        </trans-unit>
        <trans-unit id="4d2c07d263378d0346f09b22f277d0d3e406cae7" translate="yes" xml:space="preserve">
          <source>The optimizer can take care of optimizing all the CSS and JS files in your project by using a build profile.</source>
          <target state="translated">Оптимизатор может позаботиться об оптимизации всех CSS и JS файлов в вашем проекте,используя профиль сборки.</target>
        </trans-unit>
        <trans-unit id="e9597937557a9085898a43c6059a1eebe7339fa9" translate="yes" xml:space="preserve">
          <source>The optimizer cannot load network resources, so if you want it included in the build, be sure to create a &lt;a href=&quot;api#config-paths&quot;&gt;paths config&lt;/a&gt; to map the file to a module name. Then, for running the optimizer, download the CDN script and pass a paths config to the optimizer that maps the module name to the local file path.</source>
          <target state="translated">Оптимизатор не может загружать сетевые ресурсы, поэтому, если вы хотите, чтобы он был включен в сборку, обязательно создайте &lt;a href=&quot;api#config-paths&quot;&gt;конфигурацию путей&lt;/a&gt; для сопоставления файла с именем модуля. Затем для запуска оптимизатора загрузите сценарий CDN и передайте оптимизатору конфигурацию путей, которая сопоставляет имя модуля с путем к локальному файлу.</target>
        </trans-unit>
        <trans-unit id="24dc87afb98a25d8ecbaf32f04ae2ac2d6d3a749" translate="yes" xml:space="preserve">
          <source>The optimizer has supported &lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt; (by setting &lt;strong&gt;useSourceUrl&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;), for debugging combined modules as individual files. However, that only works with non-minified code. Source maps translate a minified file to a non-minified version. It does not make sense to use useSourceUrl with generateSourceMaps since useSourceUrl needs the source values as strings, which prohibits the useful minification done in combination with generateSourceMaps.</source>
          <target state="translated">Оптимизатор поддерживает &lt;a href=&quot;https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/&quot;&gt;sourceURL&lt;/a&gt; (установив для &lt;strong&gt;useSourceUrl&lt;/strong&gt; значение &lt;code&gt;true&lt;/code&gt; ) для отладки комбинированных модулей как отдельных файлов. Однако это работает только с неминифицированным кодом. Исходные карты переводят минифицированный файл в неминифицированную версию. Не имеет смысла использовать useSourceUrl с generateSourceMaps, поскольку useSourceUrl требует исходных значений в виде строк, что запрещает полезную минификацию, выполняемую в сочетании с generateSourceMaps.</target>
        </trans-unit>
        <trans-unit id="97adcb3e43739938bb0b24c540239f8776fdf70e" translate="yes" xml:space="preserve">
          <source>The optimizer is part of the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js adapter for Node and Nashorn&lt;/a&gt;, and it is designed to be run as part of a build or packaging step after you are done with development and are ready to deploy the code for your users.</source>
          <target state="translated">Оптимизатор является частью &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;адаптера r.js для Node и Nashorn&lt;/a&gt; , и он предназначен для запуска как часть этапа сборки или упаковки после того, как вы закончите разработку и будете готовы развернуть код для ваших пользователей.</target>
        </trans-unit>
        <trans-unit id="4dd7b81667d35089632d3cb2dbefac91d4924a99" translate="yes" xml:space="preserve">
          <source>The optimizer will only combine modules that are specified in arrays of string literals that are passed to top-level require and define calls, or the require('name') string literal calls in a &lt;a href=&quot;whyamd#sugar&quot;&gt;simplified CommonJS wrapping&lt;/a&gt;. So, it will not find modules that are loaded via a variable name:</source>
          <target state="translated">Оптимизатор будет объединять только те модули, которые указаны в массивах строковых литералов, которые передаются в вызовы верхнего уровня require и define, или вызовы строковых литералов require ('name') в &lt;a href=&quot;whyamd#sugar&quot;&gt;упрощенной оболочке CommonJS&lt;/a&gt; . Таким образом, он не найдет модули, загружаемые через имя переменной:</target>
        </trans-unit>
        <trans-unit id="e736ee2d0486212242109d874b9057adc10b369e" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) list&lt;/a&gt; participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</source>
          <target state="translated">Участники первоначального &lt;a href=&quot;http://groups.google.com/group/commonjs&quot;&gt;списка CommonJS (CJS)&lt;/a&gt; решили разработать формат модуля, который работал бы с сегодняшним языком JavaScript, но не обязательно был привязан к ограничениям среды JS браузера. Надежда заключалась в том, чтобы использовать какие-то временные меры в браузере и, как мы надеемся, повлиять на производителей браузеров, чтобы они создали решения, которые позволят их формату модулей работать лучше изначально. Временные меры:</target>
        </trans-unit>
        <trans-unit id="49726bf75802c1e0d2ae363b06e8ab652be497a7" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;https://groups.google.com/group/commonjs&quot;&gt;CommonJS (CJS) list&lt;/a&gt; participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ffd664aad13e13f0e39499785339e02cc90784" translate="yes" xml:space="preserve">
          <source>The other (recommended) solution is to just name the file 'jquery.js' and place it in the baseUrl directory. Then the above paths entry is not needed.</source>
          <target state="translated">Другое (рекомендуемое)решение-просто назвать файл 'jquery.js' и поместить его в каталог baseUrl.Тогда запись о вышеперечисленных путях не понадобится.</target>
        </trans-unit>
        <trans-unit id="e8db7c7e84d06e02e54baf98a25cf84663fe34ff" translate="yes" xml:space="preserve">
          <source>The package config can specify the following properties for a specific package:</source>
          <target state="translated">Конфигурация пакета может указать следующие свойства для конкретного пакета:</target>
        </trans-unit>
        <trans-unit id="f7d157456a6adc4bf429c0462916d2f169f00d2d" translate="yes" xml:space="preserve">
          <source>The path configuration for a module is incorrect. Check the &quot;Net&quot; or &quot;Network&quot; tab in the browser's developer tools to see if there was a 404 for an URL that would map to the module name. Make sure the script file is in the right place. In some cases you may need to use the &lt;a href=&quot;api#config&quot;&gt;paths configuration&lt;/a&gt; to fix the URL resolution for the script.</source>
          <target state="translated">Конфигурация пути для модуля неверна. Проверьте вкладку &amp;laquo;Сеть&amp;raquo; или &amp;laquo;Сеть&amp;raquo; в инструментах разработчика браузера, чтобы узнать, существует ли 404 для URL-адреса, который соответствовал бы имени модуля. Убедитесь, что файл сценария находится в нужном месте. В некоторых случаях вам может потребоваться использовать &lt;a href=&quot;api#config&quot;&gt;конфигурацию путей,&lt;/a&gt; чтобы исправить разрешение URL-адреса для скрипта.</target>
        </trans-unit>
        <trans-unit id="d86259d6a0a722e27d583979961ce1e8aa9945a9" translate="yes" xml:space="preserve">
          <source>The path that is used for a module name should &lt;strong&gt;not&lt;/strong&gt; include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If &lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl()&lt;/a&gt; is used, it will add the appropriate extension, if it is for something like a text template.</source>
          <target state="translated">Путь, который используется для имени модуля, &lt;strong&gt;не&lt;/strong&gt; должен включать расширение, поскольку отображение пути может быть для каталога. Код сопоставления пути автоматически добавит расширение .js при сопоставлении имени модуля пути. Если используется &lt;a href=&quot;#modulenotes-urls&quot;&gt;require.toUrl ()&lt;/a&gt; , он добавит соответствующее расширение, если оно предназначено для чего-то вроде текстового шаблона.</target>
        </trans-unit>
        <trans-unit id="4e91b10b7f7d53ba941c2c7e0e1bb6a153f797cb" translate="yes" xml:space="preserve">
          <source>The paths config was used to set two module IDs to the same file, and that file only has one anonymous module in it. If module IDs &quot;something&quot; and &quot;lib/something&quot; are both configured to point to the same &quot;scripts/libs/something.js&quot; file, and something.js only has one anonymous module in it, this kind of timeout error can occur. The fix is to make sure all module ID references use the same ID (either choose &quot;something&quot; or &quot;lib/something&quot; for all references), or use &lt;a href=&quot;api#config-map&quot;&gt;map config&lt;/a&gt;.</source>
          <target state="translated">Конфигурация путей использовалась для установки двух идентификаторов модулей в один и тот же файл, и в этом файле есть только один анонимный модуль. Если идентификаторы модулей &amp;laquo;something&amp;raquo; и &amp;laquo;lib / something&amp;raquo; настроены так, чтобы указывать на один и тот же файл &amp;laquo;scripts / libs / something.js&amp;raquo;, а в something.js есть только один анонимный модуль, может возникнуть такая ошибка тайм-аута. . Исправление состоит в том, чтобы убедиться, что все ссылки на идентификаторы модулей используют один и тот же идентификатор (либо выберите &amp;laquo;something&amp;raquo; или &amp;laquo;lib / something&amp;raquo; для всех ссылок), либо используйте &lt;a href=&quot;api#config-map&quot;&gt;конфигурацию карты&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c55e2f25518ff91b12e2171a0f0a388d17bb4d" translate="yes" xml:space="preserve">
          <source>The precedence for config: command line, build profile, mainConfigFile. In other words, the mainConfigFile configuration has the lowest priority.</source>
          <target state="translated">Приоритет для config:командной строки,профиля сборки,mainConfigFile.Другими словами,конфигурация mainConfigFile имеет наименьший приоритет.</target>
        </trans-unit>
        <trans-unit id="1242359748292937312acf98b1a6eb87d8a3b11f" translate="yes" xml:space="preserve">
          <source>The previous example with a concatenated require-jquery file</source>
          <target state="translated">Предыдущий пример с конкатенированным требуемым файлом запроса</target>
        </trans-unit>
        <trans-unit id="192ab3acce5094758f21a50e14a8da17d6acde2e" translate="yes" xml:space="preserve">
          <source>The r.js optimizer is designed to offer some primitives that can be used for different deployment scenarios by adding other code on top of it. See the &lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;deployment techniques wiki page&lt;/a&gt; for ideas on how to use the optimizer in that fashion.</source>
          <target state="translated">Оптимизатор r.js разработан, чтобы предлагать некоторые примитивы, которые можно использовать для различных сценариев развертывания путем добавления другого кода поверх него. См. &lt;a href=&quot;https://github.com/requirejs/r.js/wiki/Deployment-Techniques&quot;&gt;Вики-страницу&lt;/a&gt; о методах развертывания, чтобы узнать, как использовать оптимизатор таким образом.</target>
        </trans-unit>
        <trans-unit id="e2ee0d524bcd6704760b685962eeb8cfaff57213" translate="yes" xml:space="preserve">
          <source>The rest of this page assumes that r.js is just downloaded manually from the download page. It is normally the clearest, most portable way to use the optimizer.</source>
          <target state="translated">Остальная часть этой страницы предполагает,что r.js просто загружается вручную со страницы загрузки.Обычно это наиболее понятный и портативный способ использования оптимизатора.</target>
        </trans-unit>
        <trans-unit id="ecf160a12aa61fb012a8b2424316d88aa0e4fd22" translate="yes" xml:space="preserve">
          <source>The return object from the function call defines the &quot;my/shirt&quot; module. By defining modules in this way, &quot;my/shirt&quot; does not exist as a global object.</source>
          <target state="translated">Возвращаемый из вызова функции объект определяет &quot;мой/рубашечный&quot; модуль.Определяя таким образом модули,&quot;мой/рубашка&quot; не существует как глобальный объект.</target>
        </trans-unit>
        <trans-unit id="0c88e63a484581ec383ad067c9875d460057af30" translate="yes" xml:space="preserve">
          <source>The shim config only sets up code relationships. To load modules that are part of or use shim config, a normal require/define call is needed. Setting shim by itself does not trigger code to load.</source>
          <target state="translated">Конфигурация shim настраивает только кодовые отношения.Для загрузки модулей,входящих в состав или использующих конфигурацию shim,необходим обычный запрос/определение вызова.Установка shim'а сама по себе не приводит к загрузке кода.</target>
        </trans-unit>
        <trans-unit id="5be64048efe7324abe49142f72faeeaaa7e1ca4a" translate="yes" xml:space="preserve">
          <source>The simplified CommonJS wrapper can be used in &lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack/Add-on SDK&lt;/a&gt; for Firefox</source>
          <target state="translated">Упрощенную оболочку CommonJS можно использовать в &lt;a href=&quot;https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/&quot;&gt;Jetpack / Add-on SDK&lt;/a&gt; для Firefox.</target>
        </trans-unit>
        <trans-unit id="286eeb9d4dd615a5ee96545dccd9adba277a55b2" translate="yes" xml:space="preserve">
          <source>The text! plugin implements write, to write out a string value for the text file that it loaded. A snippet from that file:</source>
          <target state="translated">Плагин text! реализует запись,чтобы выписать строковое значение для загруженного им текстового файла.Отрывок из этого файла:</target>
        </trans-unit>
        <trans-unit id="c439d72b6a34f9f0ba042a5650c9c5ee79e4df55" translate="yes" xml:space="preserve">
          <source>The workaround is to just remove the space. This is fixed in the 2.0 code, and may be backported to the 1.0.x series if a 1.0.9 release is done.</source>
          <target state="translated">Обходной путь состоит в том,чтобы просто убрать пространство.Это исправлено в коде 2.0,и может быть возвращено в серию 1.0.x,если будет выпущен релиз 1.0.9.</target>
        </trans-unit>
        <trans-unit id="9ec19343751911c72325582b0361861caae8236f" translate="yes" xml:space="preserve">
          <source>Then configure the HTML page to load the main-built.js file instead of main.js by configuring the path used for &quot;main&quot; to be &quot;main-built&quot;:</source>
          <target state="translated">Затем сконфигурируйте HTML-страницу для загрузки файла main-built.js вместо main.js,настроив путь,по которому &quot;main&quot; будет &quot;main-built&quot;:</target>
        </trans-unit>
        <trans-unit id="259d26828f417e2f8c13bd0c6028af122d81b719" translate="yes" xml:space="preserve">
          <source>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</source>
          <target state="translated">Затем определите файл на my/nls/fr-fr/colors.js,который имеет следующее содержимое:</target>
        </trans-unit>
        <trans-unit id="be36ae0eb8667335a927273da0e6ab92b4edcb64" translate="yes" xml:space="preserve">
          <source>Then the RequireJS configuration would look like so:</source>
          <target state="translated">Тогда конфигурация RequireJS будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="a910327d077ce4eca13382ba87c8e201b1acd698" translate="yes" xml:space="preserve">
          <source>Then the optimizer will transform the above code sample to:</source>
          <target state="translated">Затем оптимизатор преобразует приведенный выше пример кода:</target>
        </trans-unit>
        <trans-unit id="62170f7da0384f803f3a8eb7d89b68cf954fd553" translate="yes" xml:space="preserve">
          <source>Then the value for red in &quot;root&quot; will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</source>
          <target state="translated">Затем будет использовано значение красного цвета в слове &quot;root&quot;.Это работает для всех частей локали.Если все связки,перечисленные ниже,были определены,то RequireJS будет использовать значения в следующем порядке приоритета (тот,который находится вверху,имеет наибольший приоритет):</target>
        </trans-unit>
        <trans-unit id="f6cde8d9e24c8b9374a3bdc6f65bb6e76f868f68" translate="yes" xml:space="preserve">
          <source>Then, if you use the default optimize setting of &quot;uglify&quot; in r.js 0.26.0 or later, or if the &lt;b&gt;optimize&lt;/b&gt; setting is set to &quot;closure&quot; (when &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;run under Java&lt;/a&gt;), the minifier will optimize out the dead code branch! So you can do custom builds of your code that are optimized for a set of has() tests.</source>
          <target state="translated">Затем, если вы используете настройку оптимизации по умолчанию &amp;laquo;uglify&amp;raquo; в r.js 0.26.0 или новее, или если настройка &lt;b&gt;оптимизации&lt;/b&gt; установлена ​​на &amp;laquo;закрытие&amp;raquo; (при &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;запуске под Java&lt;/a&gt; ), минификатор оптимизирует ветвь мертвого кода. ! Таким образом, вы можете создавать собственные сборки вашего кода, оптимизированные для набора тестов has ().</target>
        </trans-unit>
        <trans-unit id="1f0e546fbe705942eca29d67bf81ee3c8a7db75d" translate="yes" xml:space="preserve">
          <source>Then, when running the optimizer, use 'empty:' for the paths config:</source>
          <target state="translated">Затем,при запуске оптимизатора,используйте 'empty:' для настройки путей:</target>
        </trans-unit>
        <trans-unit id="00b6895c862979cc2eba13bb2a4e9203df3d2928" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;some patterns for separating the config from main module loading&lt;/a&gt;.</source>
          <target state="translated">Есть &lt;a href=&quot;https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module&quot;&gt;несколько шаблонов для отделения конфига от загрузки основного модуля&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c914c8913f0c704632585755ad2fd92421214c70" translate="yes" xml:space="preserve">
          <source>There are a small number of CommonJS modules do not work well as define()-wrapped modules. See the &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;r.js README&lt;/a&gt;</source>
          <target state="translated">Есть небольшое количество модулей CommonJS, которые не работают так хорошо, как модули, обернутые в define (). См. &lt;a href=&quot;https://github.com/requirejs/r.js&quot;&gt;README для r.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d96503df59aae56b5b8ba278910ed073296911" translate="yes" xml:space="preserve">
          <source>There are also hidden costs with the CommonJS format:</source>
          <target state="translated">Существуют также скрытые расходы с форматом CommonJS:</target>
        </trans-unit>
        <trans-unit id="b8e5d4466510ba561a8c62882157f7d3f3f8d4f6" translate="yes" xml:space="preserve">
          <source>There are some CommonJS systems, mainly Node, that allow setting the exported value by assigning the exported value as module.exports. That idiom is supported by RequireJS, but there is another, easier way -- just return the value from the function passed to &lt;strong&gt;define&lt;/strong&gt;:</source>
          <target state="translated">Есть несколько систем CommonJS, в основном Node, которые позволяют установить экспортируемое значение, назначив экспортируемое значение как module.exports. Эта идиома поддерживается RequireJS, но есть другой, более простой способ - просто вернуть значение из функции, переданной для &lt;strong&gt;определения&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="db7bc183023059aacc1b28ac85497f6757932ed2" translate="yes" xml:space="preserve">
          <source>There are two ways to get the Node adapter:</source>
          <target state="translated">Есть два способа получить адаптер Node:</target>
        </trans-unit>
        <trans-unit id="f82b7a30d627e088df9f0dc5d7ebd9889f9e8c88" translate="yes" xml:space="preserve">
          <source>There is a &lt;strong&gt;limitation&lt;/strong&gt; on the command line argument syntax. Dots are viewed as object property separators, to allow something like &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; to be transformed to the following in the optimizer:</source>
          <target state="translated">Есть &lt;strong&gt;ограничение&lt;/strong&gt; на синтаксис аргументов командной строки. Точки рассматриваются как разделители свойств объекта, чтобы позволить &lt;code&gt;paths.jquery=lib/jquery&lt;/code&gt; преобразовать что-то вроде paths.jquery = lib / jquery в следующее:</target>
        </trans-unit>
        <trans-unit id="49ed2d13d62753769d4a3e4b16bbff6caf763443" translate="yes" xml:space="preserve">
          <source>There is a bit more involved than just the above snippet, but that is the basic idea. This approach has the advantage over document.write in that it will not block page rendering and it works after page load.</source>
          <target state="translated">Это немного больше,чем просто вышеупомянутый фрагмент,но это основная идея.Этот подход имеет преимущество перед Document.write в том,что он не будет блокировать рендеринг страницы и работает после загрузки страницы.</target>
        </trans-unit>
        <trans-unit id="1195ff6977b15b525b4fb9026d68e10938839170" translate="yes" xml:space="preserve">
          <source>There is a global function, &lt;b&gt;requirejs.undef()&lt;/b&gt;, that allows undefining a module. It will reset the loader's internal state to forget about the previous definition of the module.</source>
          <target state="translated">Существует глобальная функция &lt;b&gt;requirejs.undef ()&lt;/b&gt; , которая позволяет отменить определение модуля. Он сбросит внутреннее состояние загрузчика, чтобы забыть о предыдущем определении модуля.</target>
        </trans-unit>
        <trans-unit id="19b7fe5cd5ae02fb158a358fbe1b88a6534c1ae6" translate="yes" xml:space="preserve">
          <source>There is also support for a &quot;*&quot; map value which means &quot;for all modules loaded, use this map config&quot;. If there is a more specific map config, that one will take precedence over the star config. Example:</source>
          <target state="translated">Также поддерживается значение &quot;*&quot; карты,что означает &quot;для всех загруженных модулей используйте этот map config&quot;.Если существует более специфический конфигурационный файл карты,то он будет иметь приоритет над звездообразным конфигурационным файлом.Пример:</target>
        </trans-unit>
        <trans-unit id="cf8ab1380352baedf713333d3304b748679a3eaa" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js&lt;/a&gt; file in the requirejs/build directory that details all of the allowed optimizer configuration options.</source>
          <target state="translated">В каталоге requirejs / build есть файл &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/example.build.js&quot;&gt;example.build.js,&lt;/a&gt; в котором подробно описаны все разрешенные параметры конфигурации оптимизатора.</target>
        </trans-unit>
        <trans-unit id="13a8e51faef4350fa51a39f9fddc9216e1cdff43" translate="yes" xml:space="preserve">
          <source>There may be times when you do want to reference a script directly and not conform to the &quot;baseUrl + paths&quot; rules for finding it. If a module ID has one of the following characteristics, the ID will not be passed through the &quot;baseUrl + paths&quot; configuration, and just be treated like a regular URL that is relative to the document:</source>
          <target state="translated">Могут быть моменты,когда вы захотите напрямую обратиться к скрипту и не соответствовать правилам &quot;baseUrl+пути&quot; для его нахождения.Если идентификатор модуля имеет одну из следующих характеристик,то он не будет передан через конфигурацию &quot;baseUrl+пути&quot;,а просто будет рассматриваться как обычный URL,относящийся к документу:</target>
        </trans-unit>
        <trans-unit id="15a0d6c1171150ff1ab728d8563c6ef03f5aeb87" translate="yes" xml:space="preserve">
          <source>There should only be &lt;strong&gt;one&lt;/strong&gt; module definition per file on disk. The modules can be grouped into optimized bundles by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;.</source>
          <target state="translated">Для каждого файла на диске должно быть только &lt;strong&gt;одно&lt;/strong&gt; определение модуля. Модули могут быть сгруппированы в оптимизированные пакеты с помощью &lt;a href=&quot;optimization&quot;&gt;инструмента оптимизации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9aafa4f6a11dfb424aaf808dc827232de9516114" translate="yes" xml:space="preserve">
          <source>There should only be at most &lt;strong&gt;one IO action for each module&lt;/strong&gt;, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json &quot;main&quot; property. Just use module names that map easily to one location based on the project's location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</source>
          <target state="translated">Для &lt;strong&gt;каждого модуля&lt;/strong&gt; должно быть не более &lt;strong&gt;одного действия ввода-вывода&lt;/strong&gt; , и оно должно быть простым. Веб-браузеры не терпят множественных запросов ввода-вывода для поиска модуля. Это является аргументом против поиска по множественным путям, который сейчас выполняет Node, и отказа от использования свойства &amp;laquo;main&amp;raquo; package.json. Просто используйте имена модулей, которые легко сопоставляются с одним местоположением в зависимости от местоположения проекта, используя разумное соглашение по умолчанию, которое не требует подробной настройки, но допускает простую настройку при необходимости.</target>
        </trans-unit>
        <trans-unit id="cdfa1e7131c14d32efb9df0bc08c01be59e54bd9" translate="yes" xml:space="preserve">
          <source>There was a script error in one of the listed modules. If there is no script error in the browser's error console, and if you are using Firebug, try loading the page in another browser like Chrome or Safari. Sometimes script errors do not show up in Firebug.</source>
          <target state="translated">В одном из перечисленных модулей произошла ошибка скрипта.Если в консоли ошибок браузера нет ошибки сценария,и вы используете Firebug,попробуйте загрузить страницу в другом браузере,например,Chrome или Safari.Иногда ошибки сценария не проявляются в Firebug.</target>
        </trans-unit>
        <trans-unit id="468caacfedf05ebd845bad705ed5482dfe20bd36" translate="yes" xml:space="preserve">
          <source>These are normally generated by the &lt;a href=&quot;optimization&quot;&gt;optimization tool&lt;/a&gt;. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</source>
          <target state="translated">Обычно они создаются &lt;a href=&quot;optimization&quot;&gt;инструментом оптимизации&lt;/a&gt; . Вы можете сами явно называть модули, но это делает модули менее переносимыми - если вы переместите файл в другой каталог, вам нужно будет изменить имя. Обычно лучше избегать кодирования в имени модуля и просто позволить инструменту оптимизации записать имена модулей. Инструмент оптимизации должен добавить имена, чтобы в файл можно было объединить несколько модулей, чтобы ускорить загрузку в браузере.</target>
        </trans-unit>
        <trans-unit id="98b4938725e5a5341b6305461362cc0477d874b0" translate="yes" xml:space="preserve">
          <source>These cases are handled by the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt;, &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; normally present in AMD loaders.</source>
          <target state="translated">Эти случаи обрабатываются &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/require&quot;&gt;callback-require&lt;/a&gt; , &lt;code&gt;require([moduleName], function (){})&lt;/code&gt; обычно присутствующим в загрузчиках AMD.</target>
        </trans-unit>
        <trans-unit id="a79accd25478216f5822c8a4c6bf603479d9922e" translate="yes" xml:space="preserve">
          <source>These instructions assume an npm installation of 'requirejs'. If you are using the r.js file directly, replace require('requirejs') with require('./path/to/r.js'). Basic usage is:</source>
          <target state="translated">Эти инструкции предполагают установку &quot;requirejs&quot; в npm.Если вы используете r.js файл напрямую,замените require('requirejs')на require('./path/to/r.js').Основное использование:</target>
        </trans-unit>
        <trans-unit id="16b53404d787cd045723983e31d60ff96d23db07" translate="yes" xml:space="preserve">
          <source>Thinking about the problem.</source>
          <target state="translated">Думая о проблеме.</target>
        </trans-unit>
        <trans-unit id="380032a22f9c26e6024b670111955c2798e616e2" translate="yes" xml:space="preserve">
          <source>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</source>
          <target state="translated">Приведенный выше код попробует найти CDN,но если это не удастся,вернитесь к локальному адресу lib/jquery.js.</target>
        </trans-unit>
        <trans-unit id="49752fc8bf27c03316c7e59051f18837913b9909" translate="yes" xml:space="preserve">
          <source>This allows the loader to load dependency1 and dependency2 asynchronously, execute those dependencies, then execute this function.</source>
          <target state="translated">Это позволяет загрузчику загружать зависимости1 и зависимости2 асинхронно,выполнять эти зависимости,а затем выполнять эту функцию.</target>
        </trans-unit>
        <trans-unit id="9ddedef1b43d7b8525f6b0973e7a8d964d29e5e0" translate="yes" xml:space="preserve">
          <source>This allows you to build other optimization workflows, like &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;a web builder&lt;/a&gt; that can be used if you prefer to always develop with the &quot;one script file included before the &amp;lt;/body&amp;gt; tag&quot; approach. The optimizer running in Node is fairly fast, but for larger projects that do not want to regenerate the build for every browser request, but just if you modify a script that is part of the build. You could use Node's fs.watchFile() to watch files and then trigger the build when a file changes.</source>
          <target state="translated">Это позволяет вам создавать другие рабочие процессы оптимизации, такие &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/build/tests/http&quot;&gt;как веб-конструктор,&lt;/a&gt; который можно использовать, если вы предпочитаете всегда разрабатывать с использованием подхода &amp;laquo;один файл сценария, включенный перед тегом &amp;lt;/body&amp;gt;&amp;raquo;. Оптимизатор, работающий в Node, работает довольно быстро, но для более крупных проектов, которые не хотят восстанавливать сборку для каждого запроса браузера, а только если вы изменяете сценарий, являющийся частью сборки. Вы можете использовать Node fs.watchFile () для просмотра файлов, а затем запускать сборку при изменении файла.</target>
        </trans-unit>
        <trans-unit id="3b65d4f771bf52e95454a2cd0ee5bb01541e3c07" translate="yes" xml:space="preserve">
          <source>This behavior allows dynamic loading of modules even after optimization. You can always explicitly add modules that are not found via the optimizer's static analysis by using the &lt;strong&gt;include&lt;/strong&gt; option.</source>
          <target state="translated">Такое поведение позволяет динамически загружать модули даже после оптимизации. Вы всегда можете явно добавить модули, которые не были найдены с помощью статического анализа оптимизатора, используя опцию &lt;strong&gt;include&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7c2186e1d7918e19fbd7e4fbea3be0565cf286b9" translate="yes" xml:space="preserve">
          <source>This build profile tells RequireJS to copy all of &lt;strong&gt;appdirectory&lt;/strong&gt; to a sibling directory called &lt;strong&gt;appdirectory-build&lt;/strong&gt; and apply all the optimizations in the &lt;strong&gt;appdirectory-build&lt;/strong&gt; directory. It is strongly suggested you use a different output directory than the source directory -- otherwise bad things will likely happen as the optimizer overwrites your source.</source>
          <target state="translated">Этот профиль сборки сообщает RequireJS о необходимости скопировать весь &lt;strong&gt;каталог appdirectory&lt;/strong&gt; в родственный каталог &lt;strong&gt;appdirectory-build&lt;/strong&gt; и применить все оптимизации в &lt;strong&gt;каталоге appdirectory-build&lt;/strong&gt; . Настоятельно рекомендуется использовать другой выходной каталог, чем исходный каталог - в противном случае, вероятно, произойдут плохие вещи, когда оптимизатор перезапишет ваш источник.</target>
        </trans-unit>
        <trans-unit id="75e9d0c26ff83452cfff825256989fd861112776" translate="yes" xml:space="preserve">
          <source>This can be difficult to manage on large projects, particularly as scripts start to have many dependencies in a way that may overlap and nest. Hand-writing script tags is not very scalable, and it leaves out the capability to load scripts on demand.</source>
          <target state="translated">С этим может быть трудно справиться на больших проектах,особенно в связи с тем,что сценарии начинают иметь много зависимостей,которые могут пересекаться и гнездиться.Ручное написание тегов сценариев не очень масштабируемо,и это оставляет за собой возможность загружать скрипты по требованию.</target>
        </trans-unit>
        <trans-unit id="2f1d8dae4f31129d18ce4fad1393977e24dba9d8" translate="yes" xml:space="preserve">
          <source>This error may not show up in IE, just other browsers, and instead, in IE you may see the &lt;a href=&quot;#nodefine&quot;&gt;No define call for ...&lt;/a&gt; error when you see &quot;Script error&quot;. This is due to &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">Эта ошибка может не отображаться в IE, а только в других браузерах, и вместо этого в IE вы можете увидеть ошибку &lt;a href=&quot;#nodefine&quot;&gt;Нет определения вызова для ...,&lt;/a&gt; когда вы видите &amp;laquo;Ошибка сценария&amp;raquo;. Это связано с особенностями &lt;a href=&quot;api#ieloadfail&quot;&gt;IE при обнаружении ошибок скрипта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2ee18c32fb715b5f3e2c96e54faac7bfe81e43" translate="yes" xml:space="preserve">
          <source>This error occurs when the optimizer encounters a path to a module or script which is a network path. The optimizer only allows building with local resources. To fix it:</source>
          <target state="translated">Эта ошибка возникает,когда оптимизатор встречает путь к модулю или скрипту,который является сетевым путем.Оптимизатор позволяет производить сборку только с использованием локальных ресурсов.Чтобы исправить это:</target>
        </trans-unit>
        <trans-unit id="108ce34bf7d5c20a79f2d5aa7de03e6a1873c06c" translate="yes" xml:space="preserve">
          <source>This error only shows up in some IE browsers. Most likely caused by loading a script that calls define() but was loaded in a plain script tag or via some other call, like an eval() of a JavaScript string.</source>
          <target state="translated">Эта ошибка проявляется только в некоторых браузерах IE.Скорее всего,это вызвано загрузкой скрипта,который вызывает функцию define(),но был загружен в обычный тег скрипта или через какой-то другой вызов,например eval()строки JavaScript.</target>
        </trans-unit>
        <trans-unit id="de7406078370325ab6a57dde8efdcf94e3a45238" translate="yes" xml:space="preserve">
          <source>This example should illustrate the basic problem for the browser. Suppose we have an Employee object and we want a Manager object to derive from the Employee object. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;Taking this example&lt;/a&gt;, we might code it up like this using our script loading API:</source>
          <target state="translated">Этот пример должен проиллюстрировать основную проблему браузера. Предположим, у нас есть объект Employee, и мы хотим, чтобы объект Manager был производным от объекта Employee. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy&quot;&gt;Взяв этот пример&lt;/a&gt; , мы могли бы закодировать его так, используя наш API загрузки скриптов:</target>
        </trans-unit>
        <trans-unit id="8bfc2a8f38484617acf67685853c4317495387bb" translate="yes" xml:space="preserve">
          <source>This example shows how to use the &lt;a href=&quot;api#config-shim&quot;&gt;shim config&lt;/a&gt; to specify dependencies for jQuery plugins that do not call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt;. This example is useful if you have an existing jQuery project you want to convert and do not want to modify the sources of the jQuery plugins to call define().</source>
          <target state="translated">В этом примере показано, как использовать &lt;a href=&quot;api#config-shim&quot;&gt;конфигурацию оболочки оболочки&lt;/a&gt; для указания зависимостей для подключаемых модулей jQuery, которые не вызывают &lt;a href=&quot;api#define&quot;&gt;define ()&lt;/a&gt; . Этот пример полезен, если у вас есть существующий проект jQuery, который вы хотите преобразовать, и вы не хотите изменять источники подключаемых модулей jQuery для вызова define ().</target>
        </trans-unit>
        <trans-unit id="961683c2e345f519a690d1fef03102383240f8dc" translate="yes" xml:space="preserve">
          <source>This fails because requirejs needs to be sure to load and execute all dependencies before calling the factory function above. If a dependency array is given to define(), then requirejs assumes that all dependencies are listed in that array, and it will not scan the factory function for other dependencies. So, either do not pass in the dependency array, or if using the dependency array, list all the dependencies in it.</source>
          <target state="translated">Это не удается,потому что требует,чтобы требуемые функции были загружены и выполнены все зависимости,прежде чем вызывать заводскую функцию,описанную выше.Если для функции specify()задан массив зависимостей,то requirejs предполагает,что все зависимости перечислены в этом массиве,и он не будет сканировать заводскую функцию на наличие других зависимостей.Таким образом,либо не передавайте в массив зависимостей,либо,если вы используете массив зависимостей,перечислите все зависимости в нем.</target>
        </trans-unit>
        <trans-unit id="023d496162ffcb10b7cee76e6630652af2251947" translate="yes" xml:space="preserve">
          <source>This feature only works well for scripts that are real AMD modules that call define() and register as anonymous modules. Also, &lt;strong&gt;only use absolute module IDs&lt;/strong&gt; for map config. Relative IDs (like &lt;code&gt;'../some/thing'&lt;/code&gt;) do not work.</source>
          <target state="translated">Эта функция хорошо работает только для скриптов, которые являются настоящими модулями AMD, которые вызывают define () и регистрируются как анонимные модули. Кроме того, для конфигурации карты &lt;strong&gt;используйте только абсолютные идентификаторы модулей&lt;/strong&gt; . Относительные идентификаторы (например, &lt;code&gt;'../some/thing'&lt;/code&gt; ) не работают.</target>
        </trans-unit>
        <trans-unit id="59e2e5874b3bfece421a8bffb9d4f0bc76a33cd1" translate="yes" xml:space="preserve">
          <source>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with &quot;require&quot;, so the code will work correctly with relative paths.</source>
          <target state="translated">Эта форма будет использовать Function.prototype.toString()для поиска вызовов require()и добавления их в массив зависимостей вместе с &quot;require&quot;,так что код будет корректно работать с относительными путями.</target>
        </trans-unit>
        <trans-unit id="e8ed70de90f1dd1e9ab06535ec8d2f6b33f8586d" translate="yes" xml:space="preserve">
          <source>This function also contains a property function, &lt;b&gt;write.asModule(moduleName, fileName, text)&lt;/b&gt;. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(&quot;&quot;) dependencies that need to be pulled out for the optimized file.</source>
          <target state="translated">Эта функция также содержит функцию свойства &lt;b&gt;write.asModule (имя модуля, имя файла, текст)&lt;/b&gt; . asModule можно использовать для записи модуля, который может иметь анонимный вызов define, который требует вставки имени или / и содержит неявные зависимости require (&quot;&quot;), которые необходимо извлечь для оптимизированного файла.</target>
        </trans-unit>
        <trans-unit id="07d2cf725c69b1eebada5d75140b90dfb091161d" translate="yes" xml:space="preserve">
          <source>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</source>
          <target state="translated">Эта функциональность не должна использоваться для длиннопроходных JSONP соединений --API,которые работают с потоками в реальном времени.Такие API должны делать больше очистки скриптов после получения каждого ответа,и RequireJS будет получать JSONP URL только один раз --последующее использование того же самого URL,что и зависимость в require()или define()вызове,получит кэшированное значение.</target>
        </trans-unit>
        <trans-unit id="e89c5e06d3af4319ae091f80dd3551a4bc45ff27" translate="yes" xml:space="preserve">
          <source>This is an example on how to load an optimize your code while loading jQuery from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN). This example requires all your jQuery plugins to call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt; to properly express their dependencies. &lt;a href=&quot;api#config-shim&quot;&gt;Shim config&lt;/a&gt; does not work after optimization builds with CDN resources.</source>
          <target state="translated">Это пример того, как загрузить оптимизированный код при загрузке jQuery из &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;сети доставки контента&lt;/a&gt; (CDN). В этом примере требуется, чтобы все ваши плагины jQuery вызывали &lt;a href=&quot;api#define&quot;&gt;define (),&lt;/a&gt; чтобы правильно выразить свои зависимости. &lt;a href=&quot;api#config-shim&quot;&gt;Конфигурация Shim&lt;/a&gt; не работает после оптимизационных сборок с ресурсами CDN.</target>
        </trans-unit>
        <trans-unit id="2c45233a38eed42b024ceb6884edbdad4d0bc54c" translate="yes" xml:space="preserve">
          <source>This is an example on how to load an optimize your code while loading jQuery from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN). This example requires all your jQuery plugins to call &lt;a href=&quot;api#define&quot;&gt;define()&lt;/a&gt; to properly express their dependencies. &lt;a href=&quot;api#config-shim&quot;&gt;Shim config&lt;/a&gt; does not work after optimization builds with CDN resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ccd67f04bf3d8be2fc0d6f03574cd28eb692e8" translate="yes" xml:space="preserve">
          <source>This is because the config settings for a build can be very different, with multiple optimization targets. So a separate set of config options need to be specified for the optimizer.</source>
          <target state="translated">Это связано с тем,что настройки конфигурации для сборки могут быть очень разными,с несколькими целями оптимизации.Поэтому для оптимизатора должен быть указан отдельный набор параметров конфигурации.</target>
        </trans-unit>
        <trans-unit id="c08ad2236b0738d01b1e87a814f05cd47dfb7993" translate="yes" xml:space="preserve">
          <source>This is not possible with the &lt;a href=&quot;#multiversion&quot;&gt;context-backed multiversion support&lt;/a&gt;. In addition, the &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; is only for setting up root paths for module IDs, not for mapping one module ID to another one.</source>
          <target state="translated">Это невозможно с &lt;a href=&quot;#multiversion&quot;&gt;поддержкой многоверсий&lt;/a&gt; с контекстной поддержкой . Кроме того, &lt;a href=&quot;#config-paths&quot;&gt;конфигурация путей&lt;/a&gt; предназначена только для настройки корневых путей для идентификаторов модулей, а не для сопоставления одного идентификатора модуля с другим.</target>
        </trans-unit>
        <trans-unit id="dbd4ac4ce622f942627879025300deca09f57bd3" translate="yes" xml:space="preserve">
          <source>This means that any module which uses jQuery will need to use the AMD return value rather than depending on the global $:</source>
          <target state="translated">Это означает,что любой модуль,использующий jQuery,должен будет использовать возвращаемое значение AMD,а не зависеть от глобальных $:</target>
        </trans-unit>
        <trans-unit id="660aa1bff65fdcc611a8965c59f57a351f6f7cd7" translate="yes" xml:space="preserve">
          <source>This occurs when enforceDefine is set to true, and a script that is loaded either:</source>
          <target state="translated">Это происходит,когда значение параметра enforcementDefine равно true,и сценарий,который также загружается:</target>
        </trans-unit>
        <trans-unit id="f289c4df7b00d5edd870e53e404ebd6b7af70cdb" translate="yes" xml:space="preserve">
          <source>This occurs when the script.onerror function is triggered in a browser. This usually means there is a JavaScript syntax error or other execution problem running the script. To fix it, examine the script that generated the error in a script debugger.</source>
          <target state="translated">Это происходит при срабатывании функции script.onerror в браузере.Обычно это означает наличие синтаксической ошибки JavaScript или другой проблемы при выполнении скрипта.Чтобы это исправить,изучите скрипт,который сгенерировал ошибку в отладчике скрипта.</target>
        </trans-unit>
        <trans-unit id="6aada266dc2b34a31cd1025b898441e43473ae95" translate="yes" xml:space="preserve">
          <source>This occurs when there is a call like:</source>
          <target state="translated">Это происходит,когда поступает такой звонок:</target>
        </trans-unit>
        <trans-unit id="928706501045c1df1973346d9b52dc67e9760f4b" translate="yes" xml:space="preserve">
          <source>This occurs when there is a require('name') call, but the 'name' module has not been loaded yet.</source>
          <target state="translated">Это происходит,когда происходит вызов require('name'),но модуль 'name' еще не загружен.</target>
        </trans-unit>
        <trans-unit id="d5a19ba0ac3512b99642760d7832ca4bbfdbf103" translate="yes" xml:space="preserve">
          <source>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</source>
          <target state="translated">Это только устанавливает,где найти модуль внутри скрипта,который имеет несколько модулей с функцией define()'d.Он не связывает эти модули автоматически с идентификатором модуля пакета.Идентификатор модуля пакета просто используется для определения местонахождения набора модулей.</target>
        </trans-unit>
        <trans-unit id="5ff463f5c13219de083a5b986d24729b282c0b63" translate="yes" xml:space="preserve">
          <source>This option will install the latest release.</source>
          <target state="translated">Эта опция установит последнюю версию.</target>
        </trans-unit>
        <trans-unit id="3080e3b4e7305b7a390be280a008f2efaa8b0dce" translate="yes" xml:space="preserve">
          <source>This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page that talks about &lt;a href=&quot;whyamd&quot;&gt;the design forces&lt;/a&gt; for the particular function wrapped format used by RequireJS.</source>
          <target state="translated">На этой странице обсуждается, почему модули в Интернете полезны, и механизмы, которые можно использовать в Интернете сегодня для их включения. На отдельной странице рассказывается о &lt;a href=&quot;whyamd&quot;&gt;проектных силах&lt;/a&gt; для конкретного формата с оболочкой функций, используемого RequireJS.</target>
        </trans-unit>
        <trans-unit id="5c32b7767b663c9b112dbfb1a72ec9435610f40c" translate="yes" xml:space="preserve">
          <source>This page lists errors that are generated by RequireJS. If the following information does not fix the problem, you can ask on the &lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;RequireJS list&lt;/a&gt; or &lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;open an issue&lt;/a&gt;. In either case it is best to have an example or detailed explanation of the problem, hopefully with steps to reproduce.</source>
          <target state="translated">На этой странице перечислены ошибки, генерируемые RequireJS. Если следующая информация не решает проблему, вы можете задать вопрос в &lt;a href=&quot;https://groups.google.com/group/requirejs&quot;&gt;списке RequireJS&lt;/a&gt; или &lt;a href=&quot;https://github.com/requirejs/requirejs/issues&quot;&gt;открыть проблему&lt;/a&gt; . В любом случае лучше иметь пример или подробное объяснение проблемы, надеюсь, с указанием шагов для воспроизведения.</target>
        </trans-unit>
        <trans-unit id="d329b7fabff8549e3864ca1c943467a2e9c50ff6" translate="yes" xml:space="preserve">
          <source>This page talks about the design forces and use of the &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;Asynchronous Module Definition (AMD) API&lt;/a&gt; for JavaScript modules, the module API supported by RequireJS. There is a different page that talks about &lt;a href=&quot;why&quot;&gt;general approach to modules on the web&lt;/a&gt;.</source>
          <target state="translated">На этой странице рассказывается о силах проектирования и использовании &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;API определения асинхронного модуля (AMD)&lt;/a&gt; для модулей JavaScript, API модуля, поддерживаемого RequireJS. На другой странице рассказывается об &lt;a href=&quot;why&quot;&gt;общем подходе к модулям в сети&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7547edb3cbad1a453ea3d817f5a0c1d8a4736ba" translate="yes" xml:space="preserve">
          <source>This sort of capability is really important for larger projects which may have two sets of modules that need to use two different versions of 'foo', but they still need to cooperate with each other.</source>
          <target state="translated">Такие возможности действительно важны для больших проектов,которые могут иметь два набора модулей,которые должны использовать две разные версии 'foo',но они все равно должны сотрудничать друг с другом.</target>
        </trans-unit>
        <trans-unit id="0667b0a681c9b05158e69aa153c3649764124d9b" translate="yes" xml:space="preserve">
          <source>This type of syntax was chosen because it is terse and allows the loader to use head.appendChild(script) type of loading.</source>
          <target state="translated">Этот тип синтаксиса был выбран потому,что он лаконичен и позволяет загрузчику использовать тип загрузки head.appendChild(script).</target>
        </trans-unit>
        <trans-unit id="7fbbc6fb221c91b49f8258b96647211b9f95e5f7" translate="yes" xml:space="preserve">
          <source>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</source>
          <target state="translated">Это использование JSONP должно быть ограничено услугами JSONP для начальной установки приложения.Если JSONP-служба перестает работать,это означает,что другие модули,которые вы определяете с помощью функции define(),могут не выполняться,поэтому обработка ошибок не является надежной.</target>
        </trans-unit>
        <trans-unit id="3c1fda79acd078a4d1f652fe39b9fd5add1ef63f" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/css/main-build.css&lt;/strong&gt; that will include the contents of main.css, have the url() paths properly adjusted, and have comments removed.</source>
          <target state="translated">Это создаст файл с именем &lt;strong&gt;appdirectory / css / main-build.css,&lt;/strong&gt; который будет включать содержимое main.css, правильно скорректировать пути url () и удалить комментарии.</target>
        </trans-unit>
        <trans-unit id="ef9cf9d96109395280b1d0122aae6bddc9d67c04" translate="yes" xml:space="preserve">
          <source>This will create a file called &lt;strong&gt;appdirectory/scripts/main-built.js&lt;/strong&gt; that will include the contents of main.js, one.js, two.js and three.js.</source>
          <target state="translated">Это создаст файл с именем &lt;strong&gt;appdirectory / scripts / main-built.js,&lt;/strong&gt; который будет включать содержимое main.js, one.js, two.js и three.js.</target>
        </trans-unit>
        <trans-unit id="a1edb6163d3cb5d334a5064291a25cbd6b030b50" translate="yes" xml:space="preserve">
          <source>This will instruct require.js to load scripts/main.js. &lt;strong&gt;main.js&lt;/strong&gt; uses the &quot;packages&quot; config to set up packages that are relative to require.js, which in this case are the source packages &quot;cart&quot; and &quot;store&quot;:</source>
          <target state="translated">Это проинструктирует require.js загрузить скрипты / main.js. &lt;strong&gt;main.js&lt;/strong&gt; использует конфигурацию &quot;packages&quot; для настройки пакетов, относящихся к require.js, которые в данном случае являются исходными пакетами &quot;cart&quot; и &quot;store&quot;:</target>
        </trans-unit>
        <trans-unit id="6c5b1c3af64e803c47342d3ad7896c9f28af8c07" translate="yes" xml:space="preserve">
          <source>This wrapper relies on Function.prototype.toString() to give a useful string value of the function contents. This does not work on some devices like the PS3 and some older Opera mobile browsers. Use the &lt;a href=&quot;optimization&quot;&gt;optimizer&lt;/a&gt; to pull out the dependencies in the array format for use on those devices.</source>
          <target state="translated">Эта оболочка полагается на Function.prototype.toString () для предоставления полезного строкового значения содержимого функции. Это не работает на некоторых устройствах, таких как PS3 и некоторых старых мобильных браузерах Opera. Используйте &lt;a href=&quot;optimization&quot;&gt;оптимизатор,&lt;/a&gt; чтобы извлечь зависимости в формате массива для использования на этих устройствах.</target>
        </trans-unit>
        <trans-unit id="4ea26143e34ae9633403f4fd5a98ac5694f88e74" translate="yes" xml:space="preserve">
          <source>Those IE behaviors result in &lt;a href=&quot;api#ieloadfail&quot;&gt;IE's quirks in detecting script errors&lt;/a&gt;.</source>
          <target state="translated">Такое поведение IE приводит к особенностям &lt;a href=&quot;api#ieloadfail&quot;&gt;IE при обнаружении ошибок скрипта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac488f97d42aa2e61a9ce4a064fafcf5bd478c2a" translate="yes" xml:space="preserve">
          <source>Threw a JavaScript syntax/evaluation error.</source>
          <target state="translated">Ошибка синтаксиса/оценки JavaScript.</target>
        </trans-unit>
        <trans-unit id="96453b3268c65bdfaf0b098f61bbc13d247c2512" translate="yes" xml:space="preserve">
          <source>To avoid the error, be sure to load all scripts that call define via the RequireJS API.</source>
          <target state="translated">Чтобы избежать ошибки,обязательно загрузите все скрипты,которые вызывают определение через API RequireJS.</target>
        </trans-unit>
        <trans-unit id="45ed3d91f7409c8fcc6de93c3d7c8e6c0d28c524" translate="yes" xml:space="preserve">
          <source>To avoid the error:</source>
          <target state="translated">Чтобы избежать ошибки:</target>
        </trans-unit>
        <trans-unit id="b81ae61caebc13a78c16e37ec4312cbb3981bf52" translate="yes" xml:space="preserve">
          <source>To avoid verbosity, it is strongly suggested to always use packages that use &quot;main&quot; convention in their structure.</source>
          <target state="translated">Чтобы избежать многословия,настоятельно рекомендуется всегда использовать пакеты,в структуре которых используется &quot;главная&quot; конвенция.</target>
        </trans-unit>
        <trans-unit id="530150d7bd05dc2c544154697dc2d2ab00652849" translate="yes" xml:space="preserve">
          <source>To define a bundle, put it in a directory called &quot;nls&quot; -- the i18n! plugin assumes a module name with &quot;nls&quot; in it indicates an i18n bundle. The &quot;nls&quot; marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your &quot;my&quot; set of modules, create the directory structure like so:</source>
          <target state="translated">Чтобы определить связку,поместите её в директорию,называемую &quot;nls&quot; --плагин i18n! предполагает имя модуля с &quot;nls&quot; в нём указывает на связку i18n.Маркер &quot;nls&quot; в имени говорит плагину i18n,где ожидать каталоги локали (они должны быть непосредственными дочерними процессами каталога nls).Если вы хотите предоставить набор цветовых имён в вашем наборе модулей &quot;my&quot;,создайте структуру каталога таким образом:</target>
        </trans-unit>
        <trans-unit id="5e288589ea56ef3a80663c84121f07a74a5ac771" translate="yes" xml:space="preserve">
          <source>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</source>
          <target state="translated">Для обнаружения ошибок,которые не перехватываются локальными errbacks,можно переопределить requirejs.onError():</target>
        </trans-unit>
        <trans-unit id="73a7dcc27c7d6f6895600c807abaff1dd3a1a4f4" translate="yes" xml:space="preserve">
          <source>To enable the source map generation, set &lt;strong&gt;generateSourceMaps&lt;/strong&gt; to &lt;code&gt;true&lt;/code&gt;. Since the minifier needs to have full control over the minified file to generate the source map, the &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; should be explicitly set to &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;errors#sourcemapcomments&quot;&gt;There is is a way to get some license comments in the minified source though&lt;/a&gt;.</source>
          <target state="translated">Чтобы включить создание исходной карты, установите для &lt;strong&gt;generateSourceMaps&lt;/strong&gt; значение &lt;code&gt;true&lt;/code&gt; . Поскольку минификатор должен иметь полный контроль над минифицированным файлом для генерации исходной карты, &lt;strong&gt;preserveLicenseComments&lt;/strong&gt; должно быть явно установлено в &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;errors#sourcemapcomments&quot;&gt;Тем не менее, есть способ получить некоторые лицензионные комментарии в уменьшенном исходном коде&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7715057c88fc3ede1f6116ac0416e2c729170f" translate="yes" xml:space="preserve">
          <source>To fix it:</source>
          <target state="translated">Чтобы починить его:</target>
        </trans-unit>
        <trans-unit id="a6b6d7bba93f6e1e868d22c4ce5e8fd401f399ba" translate="yes" xml:space="preserve">
          <source>To make this easier, and to make it easy to do a simple wrapping around CommonJS modules, this form of define is supported, sometimes referred to as &quot;simplified CommonJS wrapping&quot;:</source>
          <target state="translated">Чтобы сделать это проще,а также чтобы упростить обертывание вокруг модулей CommonJS,поддерживается эта форма определения,иногда называемая &quot;упрощенная обертка CommonJS&quot;:</target>
        </trans-unit>
        <trans-unit id="82e845da0003462942d83d91b7eadeddf354717e" translate="yes" xml:space="preserve">
          <source>To run the build, run this command from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">Чтобы запустить сборку, запустите эту команду из &lt;strong&gt;каталога appdirectory / scripts&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="b966b017967eef9b2e7721cf76e9ae536670e6c7" translate="yes" xml:space="preserve">
          <source>To see a more complete example that loads a module via RequireJS but uses Node-native modules for other things, see the &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;embedded test&lt;/a&gt; in the r.js repo.</source>
          <target state="translated">Чтобы увидеть более полный пример, который загружает модуль через RequireJS, но использует собственные модули для других целей, см. &lt;a href=&quot;https://github.com/requirejs/r.js/tree/master/tests/node/embedded&quot;&gt;Встроенный тест&lt;/a&gt; в репозитории r.js.</target>
        </trans-unit>
        <trans-unit id="bd4ac4ae170da9b146e596ddd3711697926708ca" translate="yes" xml:space="preserve">
          <source>To use a JSONP service in RequireJS, specify &quot;define&quot; as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</source>
          <target state="translated">Чтобы использовать JSONP-службу в RequireJS,укажите &quot;define&quot; в качестве значения параметра обратного вызова.Это означает,что вы можете получить значение JSONP URL,как если бы это было определение модуля.</target>
        </trans-unit>
        <trans-unit id="6e6b87677764cd023d6559e51135d23b8537fde7" translate="yes" xml:space="preserve">
          <source>Turbo options</source>
          <target state="translated">Турбо варианты</target>
        </trans-unit>
        <trans-unit id="55dd7970fca07c8a75f9aec4ee294f40a4e2c493" translate="yes" xml:space="preserve">
          <source>Undefining a Module</source>
          <target state="translated">Неопределение модуля</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="4997c3bd4bc74709bc6843fcd14f2bdb1f7ad512" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt; to install it:</source>
          <target state="translated">Используйте &lt;a href=&quot;http://npmjs.org&quot;&gt;npm&lt;/a&gt; для его установки:</target>
        </trans-unit>
        <trans-unit id="bd6b9479e460e2b59235dee4fb939136093ae550" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://npmjs.org&quot;&gt;npm&lt;/a&gt; to install it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30513a9146bbc0ebb732f04c610e5cdcb9629b08" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optimization&quot;&gt;RequireJS optimizer&lt;/a&gt; either in command line mode or as an &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;HTTP service&lt;/a&gt; with the &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;almond AMD shim&lt;/a&gt;.</source>
          <target state="translated">Используйте &lt;a href=&quot;optimization&quot;&gt;оптимизатор RequireJS&lt;/a&gt; либо в режиме командной строки, либо как &lt;a href=&quot;https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js&quot;&gt;службу HTTP&lt;/a&gt; с &lt;a href=&quot;https://github.com/requirejs/almond&quot;&gt;миндальной прокладкой AMD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c904f7d34df4986bde9381d86c2179b0ac9fd6ef" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.css, you could use this command, from inside the &lt;strong&gt;appdirectory/css&lt;/strong&gt; directory:</source>
          <target state="translated">Используйте приведенный выше пример настройки, если вы просто хотите оптимизировать main.css, вы можете использовать эту команду из &lt;strong&gt;каталога appdirectory / css&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="67649effa4ce87323ef0aebd844fbda30158f942" translate="yes" xml:space="preserve">
          <source>Use the above example setup, if you just wanted to optimize main.js, you could use this command, from inside the &lt;strong&gt;appdirectory/scripts&lt;/strong&gt; directory:</source>
          <target state="translated">Используйте приведенный выше пример настройки, если вы просто хотите оптимизировать main.js, вы можете использовать эту команду из &lt;strong&gt;каталога appdirectory / scripts&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c4a7a353170f8234a34024bafeaef356b8a52975" translate="yes" xml:space="preserve">
          <source>Used by &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</source>
          <target state="translated">Используется &lt;a href=&quot;http://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</target>
        </trans-unit>
        <trans-unit id="1ab95f8dd9363667edb7c709a2b8b217619a0bdf" translate="yes" xml:space="preserve">
          <source>Used by &lt;a href=&quot;https://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 1.8+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a847f63dd57eec0beb9d1e9525a841568bcd78" translate="yes" xml:space="preserve">
          <source>Used for parts of sites on &lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;the BBC&lt;/a&gt; (observed by looking at the source, not an official recommendation of AMD/RequireJS)</source>
          <target state="translated">Используется для частей сайтов &lt;a href=&quot;http://www.bbc.co.uk/&quot;&gt;BBC&lt;/a&gt; (наблюдается при просмотре источника, а не официальной рекомендации AMD / RequireJS)</target>
        </trans-unit>
        <trans-unit id="676e70a259493e207e5d446865f8b6a8d77c070f" translate="yes" xml:space="preserve">
          <source>Used for parts of sites on &lt;a href=&quot;https://www.bbc.co.uk/&quot;&gt;the BBC&lt;/a&gt; (observed by looking at the source, not an official recommendation of AMD/RequireJS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d41fd422f48e9ed0d3aae94c29bc124059cf2fe" translate="yes" xml:space="preserve">
          <source>Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.</source>
          <target state="translated">Использует практику CommonJS для идентификаторов строк для зависимостей.Четкое объявление зависимостей и отказ от использования глобусов.</target>
        </trans-unit>
        <trans-unit id="cfa856e44663f218032ac9363f5587a815abdfb8" translate="yes" xml:space="preserve">
          <source>Using JavaScript functions for encapsulation has been documented as the &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;module pattern&lt;/a&gt;:</source>
          <target state="translated">Использование функций JavaScript для инкапсуляции задокументировано как &lt;a href=&quot;http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth&quot;&gt;шаблон модуля&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a13efaa4a436994146b35afa81f0dbfea7e1c8c8" translate="yes" xml:space="preserve">
          <source>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</source>
          <target state="translated">Использование RequireJS в серверной JavaScript-среде с синхронной загрузкой должно быть таким же простым,как и переопределение require.load().Система сборки делает это,метод require.load для этого окружения можно найти в файле build/jslib/requirePatch.js.</target>
        </trans-unit>
        <trans-unit id="289a74aa4c0456df8650ad33e2452d68f57e8d5d" translate="yes" xml:space="preserve">
          <source>Using eval() to evaluate the modules is bad:</source>
          <target state="translated">Использовать eval()для оценки модулей плохо:</target>
        </trans-unit>
        <trans-unit id="c78edb579e3dbb222f2d259b6740f11757398aac" translate="yes" xml:space="preserve">
          <source>Using script tags with body text set to file text is bad:</source>
          <target state="translated">Плохо использовать теги скриптов с заданным текстом в файле:</target>
        </trans-unit>
        <trans-unit id="228d83b80eb38ba23af9f37e0663410934e378f7" translate="yes" xml:space="preserve">
          <source>Using the optimizer as a node module</source>
          <target state="translated">Использование оптимизатора в качестве узлового модуля</target>
        </trans-unit>
        <trans-unit id="c3fd77222b2e71662b263477d33da9477f3ede5c" translate="yes" xml:space="preserve">
          <source>Verbosity vs. Usefulness</source>
          <target state="translated">Вербозность против полезности</target>
        </trans-unit>
        <trans-unit id="508686787ae997d3c41509077c7ba378e743f470" translate="yes" xml:space="preserve">
          <source>Version 2.1.6 and higher have experimental support for &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;. It works for mapping minified, bundled code to unminified, separate modules and only when &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt;. optimize set to &lt;code&gt;&quot;closure&quot;&lt;/code&gt; allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a &quot;.src.js&quot; file extension.</source>
          <target state="translated">Версия 2.1.6 и выше имеют экспериментальную поддержку &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;исходных карт&lt;/a&gt; . Он работает для сопоставления минимизированного связанного кода с неминифицированными отдельными модулями и только тогда, когда для параметра &lt;strong&gt;optimize&lt;/strong&gt; установлено значение &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt; . Параметр optimize, установленный на &lt;code&gt;&quot;closure&quot;&lt;/code&gt; позволяет отображать только минимизированный связанный код в неминифицированный связанный код (закрытие доступно только при работе под Java с Rhino). Неминифицированные файлы появятся в инструментах разработчика с расширением файла &quot;.src.js&quot;.</target>
        </trans-unit>
        <trans-unit id="5f620e812b7700803d72b13ad0b2acfd35653cef" translate="yes" xml:space="preserve">
          <source>Version 2.1.6 and higher have experimental support for &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;. It works for mapping minified, bundled code to unminified, separate modules and only when &lt;strong&gt;optimize&lt;/strong&gt; is set to &lt;code&gt;&quot;uglify2&quot;&lt;/code&gt;. optimize set to &lt;code&gt;&quot;closure&quot;&lt;/code&gt; allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a &quot;.src.js&quot; file extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca0f4365b0300cd8d135ed858b5f4630b5f824" translate="yes" xml:space="preserve">
          <source>We also want some sort of syntax that will allow loading plain JavaScript files that exist today -- a developer should not have to rewrite all of their JavaScript to get the benefits of script loading.</source>
          <target state="translated">Нам также нужен какой-то синтаксис,который позволит загружать простые JavaScript-файлы,которые существуют сегодня-разработчику не нужно переписывать весь JavaScript,чтобы получить преимущества от загрузки скриптов.</target>
        </trans-unit>
        <trans-unit id="289b86ce1649fa4f7108b9c4b6021d64ea08c079" translate="yes" xml:space="preserve">
          <source>We can create scripts on demand and add them to the head:</source>
          <target state="translated">Мы можем создавать скрипты по запросу и добавлять их в голову:</target>
        </trans-unit>
        <trans-unit id="a1ec9bf7282d39f1ec2d480df5541aa3df59aee1" translate="yes" xml:space="preserve">
          <source>Web Worker Support</source>
          <target state="translated">Поддержка веб-работников</target>
        </trans-unit>
        <trans-unit id="2e99e1a486438cbb3065bc99ce45e9c7f8d976a6" translate="yes" xml:space="preserve">
          <source>Web Workers might be another way to load scripts, but:</source>
          <target state="translated">Веб-работники могут быть другим способом загрузки скриптов,но..:</target>
        </trans-unit>
        <trans-unit id="7dc2b7a514c40d738fcb40c24966fdd35b7ab44e" translate="yes" xml:space="preserve">
          <source>Web sites are turning into Web apps</source>
          <target state="translated">Веб-сайты превращаются в веб-приложения</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">Что ты можешь сделать</target>
        </trans-unit>
        <trans-unit id="d2b9d5645e3e29755ed6d5e5bd23b5476467de76" translate="yes" xml:space="preserve">
          <source>What are JavaScript modules? What is their purpose?</source>
          <target state="translated">Что такое модули JavaScript? Каково их назначение?</target>
        </trans-unit>
        <trans-unit id="9ba322e4d451d61aa1aa925a8fc046c545b21e05" translate="yes" xml:space="preserve">
          <source>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</source>
          <target state="translated">Что важно:умение на самом деле делиться кодом с другими.AMD-это самый низкий энергетический путь к этой цели.</target>
        </trans-unit>
        <trans-unit id="3069c65b9df09bdc25a6487669983185f31b7699" translate="yes" xml:space="preserve">
          <source>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</source>
          <target state="translated">Когда 'some/newmodule' делает `требуется('foo')` он получит файл foo1.2.js,а когда 'some/oldmodule' делает `требуется('foo')` он получит файл foo1.0.js.</target>
        </trans-unit>
        <trans-unit id="13a587a5f71c45fb2a2ee5c7ebede909a0a90ccd" translate="yes" xml:space="preserve">
          <source>When RequireJS is used in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;Web Worker&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;importScripts&lt;/a&gt; is used to load modules. If that call failed for some reason, this error is generated.</source>
          <target state="translated">Когда RequireJS используется в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers&quot;&gt;веб- &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers#Importing_scripts_and_libraries&quot;&gt;воркере&lt;/a&gt; , importScripts используется для загрузки модулей. Если этот вызов по какой-либо причине завершился неудачно, генерируется эта ошибка.</target>
        </trans-unit>
        <trans-unit id="7fa66298280c020819d91748b0ae9d2ec88742bb" translate="yes" xml:space="preserve">
          <source>When run in a browser, &lt;a href=&quot;#pathsfallbacks&quot;&gt;paths fallbacks&lt;/a&gt; can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</source>
          <target state="translated">При запуске в браузере можно указать &lt;a href=&quot;#pathsfallbacks&quot;&gt;резервные пути&lt;/a&gt; , чтобы разрешить попытку загрузки из местоположения CDN, но вернуться к локальному местоположению, если местоположение CDN не загружается.</target>
        </trans-unit>
        <trans-unit id="d45a6bc83259e410831e5ab4ac9eae06192f6fba" translate="yes" xml:space="preserve">
          <source>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</source>
          <target state="translated">При использовании функции require()в HTML-странице верхнего уровня (или в файле скрипта верхнего уровня,который не определяет модуль)в качестве первого варианта может быть передан объект конфигурации:</target>
        </trans-unit>
        <trans-unit id="7d8a8cb4134eda8c65a86351c434df5553a6ead3" translate="yes" xml:space="preserve">
          <source>While RequireJS loads jQuery just like any other dependency, jQuery's wide use and extensive plugin ecosystem mean you'll likely have other scripts in your project that also depend on jQuery. You might approach your jQuery RequireJS configuration differently depending on whether you are starting a new project or whether you are adapting existing code.</source>
          <target state="translated">В то время как приложение RequireJS загружает jQuery так же,как и любую другую зависимость,широкое использование jQuery и обширная экосистема плагинов означают,что в вашем проекте,скорее всего,будут и другие скрипты,также зависящие от jQuery.Вы можете подойти к настройке jQuery RequireJS по-разному в зависимости от того,запускаете ли вы новый проект или адаптируете существующий код.</target>
        </trans-unit>
        <trans-unit id="8a365eae40482509c1f0aa1f29bc4a4bfcd1a236" translate="yes" xml:space="preserve">
          <source>While debugging, the line number you get for an error does not map to the original source file.</source>
          <target state="translated">Во время отладки номер строки,которую вы получаете за ошибку,не привязывается к исходному файлу.</target>
        </trans-unit>
        <trans-unit id="60d30561ad47c3e2e8a86b25641c43eb2c815a72" translate="yes" xml:space="preserve">
          <source>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the &lt;a href=&quot;commonjs#autoconversion&quot;&gt;CommonJS converter tool&lt;/a&gt; if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</source>
          <target state="translated">Хотя пакеты могут иметь структуру каталогов CommonJS, сами модули должны быть в формате, понятном RequireJS. Исключение из правила: если вы используете адаптер r.js Node, модули могут быть в традиционном формате модулей CommonJS. Вы можете использовать &lt;a href=&quot;commonjs#autoconversion&quot;&gt;инструмент конвертера CommonJS,&lt;/a&gt; если вам нужно преобразовать традиционные модули CommonJS в формат модуля async, который использует RequireJS.</target>
        </trans-unit>
        <trans-unit id="8c7f642c080d5fc3b4f51344f0cf442a310298a7" translate="yes" xml:space="preserve">
          <source>Why AMD?</source>
          <target state="translated">Почему драм?</target>
        </trans-unit>
        <trans-unit id="71369dce19ad499c48f1624383e9218e3dd40601" translate="yes" xml:space="preserve">
          <source>Why Web Modules?</source>
          <target state="translated">Почему именно веб-модули?</target>
        </trans-unit>
        <trans-unit id="c5f8918743f6d7a09acef8b6e47dcd1fabab011d" translate="yes" xml:space="preserve">
          <source>With `requirejs.undef()`, if you later set up a different config and try to load the same module, the loader will still remember which modules needed that dependency and finish loading them when the newly configured module loads.</source>
          <target state="translated">С помощью `requirejs.undef()`,если вы позже установите другую конфигурацию и попытаетесь загрузить тот же модуль,загрузчик всё равно вспомнит,какие модули нуждались в этой зависимости,и завершит загрузку при загрузке только что настроенного модуля.</target>
        </trans-unit>
        <trans-unit id="cd9fb2c8cfbcd1191658318a7ea78f5b12fe941e" translate="yes" xml:space="preserve">
          <source>With the local install, you can also &lt;a href=&quot;node#optimizer&quot;&gt;use the optimizer via a function call&lt;/a&gt; inside a node program.</source>
          <target state="translated">При локальной установке вы также можете &lt;a href=&quot;node#optimizer&quot;&gt;использовать оптимизатор через вызов функции&lt;/a&gt; внутри программы узла.</target>
        </trans-unit>
        <trans-unit id="f8debcd1d8b575c073e319ccbee375c82809a4e3" translate="yes" xml:space="preserve">
          <source>With this approach, the CommonJS group was able to work out dependency references and how to deal with circular dependencies, and how to get some properties about the current module. However, they did not fully embrace some things in the browser environment that cannot change but still affect module design:</source>
          <target state="translated">Благодаря такому подходу,группа CommonJS смогла выработать ссылки на зависимости и как работать с круговыми зависимостями,а также как получить некоторые свойства текущего модуля.Тем не менее,они не полностью охватили некоторые вещи в среде браузера,которые не могут измениться,но все еще влияют на дизайн модуля:</target>
        </trans-unit>
        <trans-unit id="6a22952292ff7c2d65a8ad8ea0b53628bf602df7" translate="yes" xml:space="preserve">
          <source>With this approach, then you normally do not need the exports and module function arguments, so you can leave them off the module definition.</source>
          <target state="translated">При таком подходе вам обычно не нужны экспорты и аргументы модульных функций,поэтому вы можете оставить их вне определения модуля.</target>
        </trans-unit>
        <trans-unit id="6d2f2f7f294f064bba8074a81bae1e972660489d" translate="yes" xml:space="preserve">
          <source>With this local install, you can run the optimizer by running the &lt;code&gt;r.js&lt;/code&gt; or &lt;code&gt;r.js.cmd&lt;/code&gt; file found in the project's &lt;code&gt;node_modules/.bin&lt;/code&gt; directory.</source>
          <target state="translated">При такой локальной установке вы можете запустить оптимизатор, запустив файл &lt;code&gt;r.js&lt;/code&gt; или &lt;code&gt;r.js.cmd&lt;/code&gt; , находящийся в &lt;code&gt;node_modules/.bin&lt;/code&gt; проекта .</target>
        </trans-unit>
        <trans-unit id="cfe5ad7fe6d1924fe8f5873b574afb12bdfa0c42" translate="yes" xml:space="preserve">
          <source>XHR also has issues with cross-domain requests. Some browsers now have cross-domain XHR support, but it is not universal, and IE decided to create a different API object for cross-domain calls, XDomainRequest. More moving parts and more things to get wrong. In particular, you need to be sure to not send any non-standard HTTP headers or there may be another &quot;preflight&quot; request done to make sure the cross-domain access is allowed.</source>
          <target state="translated">XHR также имеет проблемы с междоменными запросами.Некоторые браузеры теперь имеют поддержку XHR для междоменных запросов,но она не является универсальной,и IE решила создать другой объект API для междоменных запросов,XDomainRequest.Больше движущихся частей и больше вещей,чтобы ошибиться.В частности,нужно убедиться,что не посылаются нестандартные HTTP-заголовки или может быть сделан другой &quot;префлайтовый&quot; запрос,чтобы убедиться,что междоменный доступ разрешён.</target>
        </trans-unit>
        <trans-unit id="31c2c59b547d0a7ab95d805593077bc3374fcdb4" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; does. That loader uses the CommonJS module format. The CommonJS module format is &lt;a href=&quot;why&quot;&gt;non-optimal for the browser&lt;/a&gt;, and I do not agree with &lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;some of the trade-offs made in the CommonJS module format&lt;/a&gt;. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</source>
          <target state="translated">Да, &lt;a href=&quot;http://nodejs.org&quot;&gt;Node&lt;/a&gt; делает. Этот загрузчик использует формат модуля CommonJS. Формат модуля CommonJS &lt;a href=&quot;why&quot;&gt;не оптимален для браузера&lt;/a&gt; , и я не согласен с &lt;a href=&quot;http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;некоторыми компромиссами, сделанными в формате модуля CommonJS&lt;/a&gt; . Используя RequireJS на сервере, вы можете использовать один формат для всех своих модулей, независимо от того, работают ли они на стороне сервера или в браузере. Таким образом, вы можете сохранить преимущества скорости и простую отладку, которую вы получаете с помощью RequireJS в браузере, и не беспокоиться о дополнительных расходах на перевод при переходе между двумя форматами.</target>
        </trans-unit>
        <trans-unit id="68f725711a636de1365501f3d51b375b44fb0e6f" translate="yes" xml:space="preserve">
          <source>Yes &lt;a href=&quot;https://nodejs.org&quot;&gt;Node&lt;/a&gt; does. That loader uses the CommonJS module format. The CommonJS module format is &lt;a href=&quot;why&quot;&gt;non-optimal for the browser&lt;/a&gt;, and I do not agree with &lt;a href=&quot;https://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html&quot;&gt;some of the trade-offs made in the CommonJS module format&lt;/a&gt;. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8663ce779c85954c38a5af8306faf37b7880023" translate="yes" xml:space="preserve">
          <source>Yes! The Node adapter for RequireJS, called r.js, will use Node's implementation of require and Node's search paths if the module is not found with the configuration used by RequireJS, so you can continue to use your existing Node-based modules without having to do changes to them.</source>
          <target state="translated">Да! Адаптер Node для RequireJS,называемый r.js,будет использовать реализацию Node's require и пути поиска Node's search path,если модуль не найден с конфигурацией,используемой в RequireJS,так что вы можете продолжать использовать существующие Node-based модули без необходимости вносить в них изменения.</target>
        </trans-unit>
        <trans-unit id="ee8947dc57d182a3011ce395532368374e65caa2" translate="yes" xml:space="preserve">
          <source>You can avoid lots of configuration lines by placing the files according to the default ID-to-path convention of &lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt;. The examples below show how to set baseUrl to be the directory for third-party, library code, and use one extra paths config for your app code.</source>
          <target state="translated">Вы можете избежать большого количества строк конфигурации, разместив файлы в соответствии с соглашением по умолчанию между идентификаторами и путями &lt;code&gt;baseUrl + moduleID + '.js'&lt;/code&gt; . В приведенных ниже примерах показано, как установить baseUrl в качестве каталога для стороннего кода библиотеки и использовать одну конфигурацию дополнительных путей для кода вашего приложения.</target>
        </trans-unit>
        <trans-unit id="934837e40083f6a48dd3d019d739d3bb3bd6f17f" translate="yes" xml:space="preserve">
          <source>You can define a &lt;b&gt;has&lt;/b&gt; object in the build config with true or false values for some has() tests, and the optimizer will replace the has() test with the true or false value.</source>
          <target state="translated">Вы можете определить объект &lt;b&gt;has&lt;/b&gt; в конфигурации сборки со значениями true или false для некоторых тестов has (), и оптимизатор заменит тест has () на истинное или ложное значение.</target>
        </trans-unit>
        <trans-unit id="0d9092704d3269e06cf75c7384f32aa09d5f3586" translate="yes" xml:space="preserve">
          <source>You can do this by using the &lt;strong&gt;excludeShallow&lt;/strong&gt; option. Using the &lt;a href=&quot;#example&quot;&gt;example setup&lt;/a&gt; above, assume you are currently building out or debugging two.js. You could use this optimization command:</source>
          <target state="translated">Вы можете сделать это с помощью опции &lt;strong&gt;excludeShallow&lt;/strong&gt; . Используя приведенный выше &lt;a href=&quot;#example&quot;&gt;пример настройки&lt;/a&gt; , предположим, что вы в настоящее время создаете или отлаживаете two.js. Вы можете использовать эту команду оптимизации:</target>
        </trans-unit>
        <trans-unit id="ca244dd9b6be738c5452010e67be2b0c37758fa8" translate="yes" xml:space="preserve">
          <source>You can either specify options on the command line:</source>
          <target state="translated">Вы можете либо указать опции в командной строке:</target>
        </trans-unit>
        <trans-unit id="e52217d43c25ef584de1ffe0ee00d4d33eea6385" translate="yes" xml:space="preserve">
          <source>You can reference your plugin by putting its module name before a ! in the dependency. For instance, if you create a plugin with the name &quot;foo.js&quot;, you would use it like so:</source>
          <target state="translated">Вы можете ссылаться на свой плагин,поместив его имя модуля перед a ! в зависимости.Например,если Вы создадите плагин с именем &quot;foo.js&quot;,Вы будете использовать его в таком виде:</target>
        </trans-unit>
        <trans-unit id="94af4f0eaff062d0b3e49c77a862fe434306c96d" translate="yes" xml:space="preserve">
          <source>You can see an example of its use by looking at one of the files used in &lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;the unit test&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть пример его использования, посмотрев на один из файлов, используемых в &lt;a href=&quot;http://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;модульном тесте&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5ccb7204771be86c6e5d3656d2629fae574f27d" translate="yes" xml:space="preserve">
          <source>You can see an example of its use by looking at one of the files used in &lt;a href=&quot;https://github.com/requirejs/requirejs/blob/master/tests/workers.js&quot;&gt;the unit test&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f18da7863e56fdfa33c97e023770bcb1c79817" translate="yes" xml:space="preserve">
          <source>You can then use the above module in another module, say, in a my/lamps.js file:</source>
          <target state="translated">Затем вы можете использовать вышеуказанный модуль в другом модуле,например,в файле my/lamps.js:</target>
        </trans-unit>
        <trans-unit id="6d408cedf635435c4559ea8c022ad45cd120dee1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#onejs&quot;&gt;one JavaScript file optimization&lt;/a&gt; approach to make your development experience faster. By optimizing all the modules in your project into one file, except the one you are currently developing, you can reload your project quickly in the browser, but still give you the option of fine grained debugging in a module.</source>
          <target state="translated">Вы можете использовать подход к &lt;a href=&quot;#onejs&quot;&gt;оптимизации одного файла JavaScript,&lt;/a&gt; чтобы ускорить разработку. Оптимизируя все модули в вашем проекте в один файл, за исключением того, который вы сейчас разрабатываете, вы можете быстро перезагрузить свой проект в браузере, но при этом предоставить вам возможность детальной отладки в модуле.</target>
        </trans-unit>
        <trans-unit id="e85f93e17713bad14a95d8cd370414470f034be1" translate="yes" xml:space="preserve">
          <source>You can use this example with the CDN example above -- the shim example will not work since shimmed libraries need a global jQuery.</source>
          <target state="translated">Вы можете использовать этот пример с CDN примером выше --пример shim не будет работать,так как shimmed библиотекам нужен глобальный jQuery.</target>
        </trans-unit>
        <trans-unit id="35637298babea9951136fe42e40ee8a2641302e6" translate="yes" xml:space="preserve">
          <source>You do not need to implement normalize if the resource name is just a regular module name. For instance, the text! plugin does not implement normalize because the dependency names look like 'text!./some/path.html'.</source>
          <target state="translated">Вам не нужно реализовывать нормализацию,если имя ресурса является обычным именем модуля.Например,плагин text! не реализует нормализацию,потому что имена зависимостей выглядят как 'text!./some/path.html'.</target>
        </trans-unit>
        <trans-unit id="268347d9cc7d9cf7908d577ac75d750a3ec06657" translate="yes" xml:space="preserve">
          <source>You may also call require.config from your &lt;a href=&quot;api#data-main&quot;&gt;data-main Entry Point&lt;/a&gt;, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.</source>
          <target state="translated">Вы также можете вызвать require.config из &lt;a href=&quot;api#data-main&quot;&gt;точки входа в главные данные&lt;/a&gt; , но имейте в виду, что скрипт основных данных загружается асинхронно. Избегайте других сценариев точки входа, которые ошибочно предполагают, что data-main и его require.config всегда будут выполняться до загрузки их сценария.</target>
        </trans-unit>
        <trans-unit id="c90399d9bc6d39e4e0323a4f654f5ad35f0761ea" translate="yes" xml:space="preserve">
          <source>You may encounter some define() calls that include a name for the module as the first argument to define():</source>
          <target state="translated">Вы можете столкнуться с некоторыми вызовами функции define(),которые включают имя модуля в качестве первого аргумента для функции define():</target>
        </trans-unit>
        <trans-unit id="85ff5b58fd6ef6fa6b20479d3b624ce5c45a8836" translate="yes" xml:space="preserve">
          <source>You may have a script you want to load from a &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; or any other server on a different domain.</source>
          <target state="translated">У вас может быть сценарий, который вы хотите загрузить из &lt;a href=&quot;http://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;сети доставки контента (CDN)&lt;/a&gt; или любого другого сервера в другом домене.</target>
        </trans-unit>
        <trans-unit id="6857ed319a34a42444b0124457cbd761b051ca92" translate="yes" xml:space="preserve">
          <source>You may have a script you want to load from a &lt;a href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network (CDN)&lt;/a&gt; or any other server on a different domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cb0c91120fb108d906ccb84178ac86146de663" translate="yes" xml:space="preserve">
          <source>You should avoid naming modules yourself, and only place one module in a file while developing. However, for tooling and performance, a module solution needs a way to identify modules in built resources.</source>
          <target state="translated">Следует избегать самостоятельного именования модулей,а при разработке помещать в файл только один модуль.Однако,для обеспечения инструментария и производительности,модульное решение нуждается в способе идентификации модулей во встроенных ресурсах.</target>
        </trans-unit>
        <trans-unit id="020d90c4a950b7c671e463b43e9d47537f9c25b6" translate="yes" xml:space="preserve">
          <source>You should use the &lt;a href=&quot;optimization#mainConfigFile&quot;&gt;mainConfigFile build option&lt;/a&gt; to specify the file where to find the shim config. Otherwise the optimizer will not know of the shim config. The other option is to duplicate the shim config in the build profile.</source>
          <target state="translated">Вы должны использовать &lt;a href=&quot;optimization#mainConfigFile&quot;&gt;опцию сборки mainConfigFile,&lt;/a&gt; чтобы указать файл, в котором находится конфигурация прокладки. В противном случае оптимизатор не узнает о конфигурации прокладки. Другой вариант - продублировать конфигурацию прокладки в профиле сборки.</target>
        </trans-unit>
        <trans-unit id="97681be93dfef60f3fb4d09b005e73fd388aec7f" translate="yes" xml:space="preserve">
          <source>You will likely need to set the &lt;strong&gt;baseUrl&lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;configuration option&lt;/a&gt; to make sure require() can find the scripts to load.</source>
          <target state="translated">Вероятно, вам потребуется установить &lt;strong&gt;параметр &lt;/strong&gt;&lt;a href=&quot;#config&quot;&gt;конфигурации &lt;/a&gt;&lt;strong&gt;baseUrl,&lt;/strong&gt; чтобы убедиться, что require () может найти скрипты для загрузки.</target>
        </trans-unit>
        <trans-unit id="6dba9d538cc7725fb3a6aa1bf1b4ce6a48e9f9b4" translate="yes" xml:space="preserve">
          <source>You will typically use a data-main script to &lt;a href=&quot;#config&quot;&gt;set configuration options&lt;/a&gt; and then load the first application module. Note: the script tag require.js generates for your data-main module includes the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;async attribute&lt;/a&gt;. This means that &lt;strong&gt;you cannot assume that the load and execution of your data-main script will finish prior to other scripts referenced later in the same page.&lt;/strong&gt;</source>
          <target state="translated">Обычно вы используете сценарий основных данных для &lt;a href=&quot;#config&quot;&gt;установки параметров конфигурации,&lt;/a&gt; а затем загружаете первый модуль приложения. Примечание: тег скрипта, который require.js генерирует для вашего модуля data-main, включает &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async&quot;&gt;атрибут async&lt;/a&gt; . Это означает, что &lt;strong&gt;вы не можете предполагать, что загрузка и выполнение вашего скрипта data-main завершится раньше, чем другие скрипты, упомянутые позже на той же странице.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="369dac7c679f0128f82fcbd8ee8a70df45995f85" translate="yes" xml:space="preserve">
          <source>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</source>
          <target state="translated">Твоё время на кодирование в основном тратится на размышления,а не на набор текста.Хотя,как правило,предпочтительнее использовать меньше слов,есть предел для того,чтобы такой подход окупился,и лишний набор в драмовом эквиваленте не так уж и велик.</target>
        </trans-unit>
        <trans-unit id="fa5e2f93089b6ba91d69ad2df5ffb1b8e3b30434" translate="yes" xml:space="preserve">
          <source>and in app.js:</source>
          <target state="translated">и в App.Js:</target>
        </trans-unit>
        <trans-unit id="30d099754f286078db100db738bf8973842acc61" translate="yes" xml:space="preserve">
          <source>and the root bundle would look like:</source>
          <target state="translated">и корневой пучок будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="4a68969ef8e858229267b842dedf42ab5dde4d50" translate="yes" xml:space="preserve">
          <source>app.js</source>
          <target state="translated">app.js</target>
        </trans-unit>
        <trans-unit id="68620029c15ee91081f25087c97731ddec131ed1" translate="yes" xml:space="preserve">
          <source>app/</source>
          <target state="translated">app/</target>
        </trans-unit>
        <trans-unit id="182b400a51ca1ed7d5e68cd0c9e35beb52b7043d" translate="yes" xml:space="preserve">
          <source>appdirectory</source>
          <target state="translated">appdirectory</target>
        </trans-unit>
        <trans-unit id="a6e2217113e1101cebbd54678d99479155ebe930" translate="yes" xml:space="preserve">
          <source>avoid dumping global variables in the page</source>
          <target state="translated">избегать дампинга глобальных переменных на странице</target>
        </trans-unit>
        <trans-unit id="d8b586bf1b6b8514e418f30ddc1550845968e12d" translate="yes" xml:space="preserve">
          <source>baseUrl</source>
          <target state="translated">baseUrl</target>
        </trans-unit>
        <trans-unit id="35e8277cc95cf8aaf1e8e9ffcb5ea39e6502bbd0" translate="yes" xml:space="preserve">
          <source>bundles</source>
          <target state="translated">bundles</target>
        </trans-unit>
        <trans-unit id="1d87cf050f073de171743e1289b27e42077e9332" translate="yes" xml:space="preserve">
          <source>bundles config is useful if doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin. &lt;strong&gt;Note that the keys and values are module IDs&lt;/strong&gt;, not path segments. They are absolute module IDs, not a module ID prefix like &lt;a href=&quot;#config-paths&quot;&gt;paths config&lt;/a&gt; or &lt;a href=&quot;#config-map&quot;&gt;map config&lt;/a&gt;. Also, bundle config is different from map config in that map config is a one-to-one module ID relationship, where bundle config is for pointing multiple module IDs to a bundle's module ID.</source>
          <target state="translated">Конфигурация пакетов полезна, если выполняется сборка, и эта цель сборки не является существующим идентификатором модуля, или если у вас есть ресурсы плагина загрузчика во встроенных файлах JS, которые не должны загружаться плагином загрузчика. &lt;strong&gt;Обратите внимание, что ключи и значения являются идентификаторами модулей&lt;/strong&gt; , а не сегментами пути. Это абсолютные идентификаторы модуля, а не префикс идентификатора модуля, например &lt;a href=&quot;#config-paths&quot;&gt;конфигурация путей&lt;/a&gt; или &lt;a href=&quot;#config-map&quot;&gt;конфигурация карты&lt;/a&gt; . Кроме того, конфигурация пакета отличается от конфигурации карты тем, что конфигурация карты является взаимно однозначным отношением идентификатора модуля, где конфигурация пакета предназначена для указания нескольких идентификаторов модуля на идентификатор модуля пакета.</target>
        </trans-unit>
        <trans-unit id="579c9417979d7785e6b71b4f343a3a25028e0208" translate="yes" xml:space="preserve">
          <source>but 'a' and 'b' will be included if specified like so:</source>
          <target state="translated">но &quot;a&quot; и &quot;b&quot; будут включены,если они будут так указаны:</target>
        </trans-unit>
        <trans-unit id="5651c3e30152897bed64070f9ea7509fbb7eaf58" translate="yes" xml:space="preserve">
          <source>but this means you cannot set the value for a paths property of &quot;core/jquery.tabs&quot; to a value. This would not work: &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt;, since it would result in this incorrect structure:</source>
          <target state="translated">но это означает, что вы не можете установить для свойства paths &quot;core / jquery.tabs&quot; значение. Это не сработает: &lt;code&gt;paths.core/jquery.tabs=empty:&lt;/code&gt; , так как это приведет к неправильной структуре:</target>
        </trans-unit>
        <trans-unit id="b4d5b37bf7a986c138ede89e0806f366b5cb1830" translate="yes" xml:space="preserve">
          <source>callback</source>
          <target state="translated">callback</target>
        </trans-unit>
        <trans-unit id="9031234d18c313213c6fa8578b1a6efffa132f47" translate="yes" xml:space="preserve">
          <source>canvas.js</source>
          <target state="translated">canvas.js</target>
        </trans-unit>
        <trans-unit id="0ba1b6d81cde508d26591e899916a6b092ccc039" translate="yes" xml:space="preserve">
          <source>cart/</source>
          <target state="translated">cart/</target>
        </trans-unit>
        <trans-unit id="5db796b338afba355ef805d024ec3e62501d72e9" translate="yes" xml:space="preserve">
          <source>common.css</source>
          <target state="translated">common.css</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="2f84417a9e73cead4d5c99e05daff2a534b30132" translate="yes" xml:space="preserve">
          <source>css</source>
          <target state="translated">css</target>
        </trans-unit>
        <trans-unit id="5300d17a1d695bd411e4cdf96f9548c23ced6175" translate="yes" xml:space="preserve">
          <source>curl</source>
          <target state="translated">curl</target>
        </trans-unit>
        <trans-unit id="b549cb140e511f5ac2733025ff6d8eda8a8b7fc8" translate="yes" xml:space="preserve">
          <source>data-main Entry Point</source>
          <target state="translated">основная точка входа</target>
        </trans-unit>
        <trans-unit id="9f2696583122964a7d696a2d47ac4a3db6ad1bcb" translate="yes" xml:space="preserve">
          <source>deps</source>
          <target state="translated">deps</target>
        </trans-unit>
        <trans-unit id="4bad62c293c46433ccc5a55eff2c143661293c1a" translate="yes" xml:space="preserve">
          <source>document.write() can be used to load scripts -- it can load scripts from other domains and it maps to how browsers normally consume scripts, so it allows for easy debugging.</source>
          <target state="translated">document.write()может использоваться для загрузки скриптов --он может загружать скрипты из других доменов и отображает то,как браузеры обычно потребляют скрипты,так что он позволяет легко отлаживать.</target>
        </trans-unit>
        <trans-unit id="5958b76387ccd458d5f527ca464f090598df6741" translate="yes" xml:space="preserve">
          <source>edge cases that break in browsers, like cross-domain access</source>
          <target state="translated">крайние случаи,которые взламывают браузеры,такие как междоменный доступ</target>
        </trans-unit>
        <trans-unit id="ff8af39bb078e2360da7fdc28417e6c1c52d5174" translate="yes" xml:space="preserve">
          <source>empty: paths for network/CDN resources</source>
          <target state="translated">пустые:пути для сетевых/CDN ресурсов</target>
        </trans-unit>
        <trans-unit id="4b572a52b55bf1889556c6ce1e404be0d7ce946c" translate="yes" xml:space="preserve">
          <source>enforceDefine</source>
          <target state="translated">enforceDefine</target>
        </trans-unit>
        <trans-unit id="d90d8771241a7a05d34eed9205b8b446fb5b5f3a" translate="yes" xml:space="preserve">
          <source>eval context is different across browsers. You might be able to use execScript in IE to help this, but it means more moving parts.</source>
          <target state="translated">контекст eval отличается в разных браузерах.Вы можете использовать execScript в IE,чтобы помочь в этом,но это означает больше подвижных частей.</target>
        </trans-unit>
        <trans-unit id="43cca01843358114d77138bdf4c270875286cec3" translate="yes" xml:space="preserve">
          <source>foo1.0.js</source>
          <target state="translated">foo1.0.js</target>
        </trans-unit>
        <trans-unit id="42bf6d0b49db5b2166474ae85e2cf958a05393cb" translate="yes" xml:space="preserve">
          <source>foo1.2.js</source>
          <target state="translated">foo1.2.js</target>
        </trans-unit>
        <trans-unit id="b0cf8d3b30f6f61f1cfb2f257448bf0165378abc" translate="yes" xml:space="preserve">
          <source>for more information.</source>
          <target state="translated">для дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0032176e806dc0ce8286589b0e98559a66027030" translate="yes" xml:space="preserve">
          <source>for the optimization target.</source>
          <target state="translated">для цели оптимизации.</target>
        </trans-unit>
        <trans-unit id="ead9f7e89bbc436a96977295af1dc1bc42e42683" translate="yes" xml:space="preserve">
          <source>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). &lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;Download the plugin&lt;/a&gt; and put it in the same directory as your app's main JS file.</source>
          <target state="translated">Поддержка пакетов i18n обеспечивается плагином i18n.js. Он загружается автоматически, когда модуль или зависимость указывает i18n! префикс (подробнее ниже). &lt;a href=&quot;http://requirejs.org/docs/download.html#i18n&quot;&gt;Загрузите плагин&lt;/a&gt; и поместите его в тот же каталог, что и основной JS-файл вашего приложения.</target>
        </trans-unit>
        <trans-unit id="dc5f7718fd7e5c233be9044ede6ef58c83b5d6d2" translate="yes" xml:space="preserve">
          <source>importScripts failed for ...</source>
          <target state="translated">importScripts провалился для ...</target>
        </trans-unit>
        <trans-unit id="2c1a36cd8bde417114cd4f15a9d7802a1c5bf634" translate="yes" xml:space="preserve">
          <source>in index.html:</source>
          <target state="translated">в индексе.html:</target>
        </trans-unit>
        <trans-unit id="f6013a00b362253c64368d6eebc50ea2131754e2" translate="yes" xml:space="preserve">
          <source>index.html</source>
          <target state="translated">index.html</target>
        </trans-unit>
        <trans-unit id="33249b1929c8b83eb4a72adebb385c134300aa14" translate="yes" xml:space="preserve">
          <source>inherent asynchronicity</source>
          <target state="translated">присущая асинхроничность</target>
        </trans-unit>
        <trans-unit id="3f33a365d57118fb6c072149b026bf3898687f01" translate="yes" xml:space="preserve">
          <source>jQuery defines &lt;a href=&quot;api#modulename&quot;&gt;named AMD module&lt;/a&gt; 'jquery' (all lower case) when it detects AMD/RequireJS. To reduce confusion, we recommend using 'jquery' as the module name in your requirejs.config.</source>
          <target state="translated">jQuery определяет &lt;a href=&quot;api#modulename&quot;&gt;названный модуль AMD&lt;/a&gt; 'jquery' (все в нижнем регистре) при обнаружении AMD / RequireJS. Чтобы избежать путаницы, мы рекомендуем использовать jquery в качестве имени модуля в файле requirejs.config.</target>
        </trans-unit>
        <trans-unit id="9138a4fadeb7b3d7df1c442e211cb8d36112cba1" translate="yes" xml:space="preserve">
          <source>jQuery registers itself as the global variables &quot;$&quot; and &quot;jQuery&quot;, even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a &lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict function&lt;/a&gt; that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see &lt;a href=&quot;#noconflictmap&quot;&gt;later&lt;/a&gt;.</source>
          <target state="translated">jQuery регистрирует себя как глобальные переменные &amp;laquo;$&amp;raquo; и &amp;laquo;jQuery&amp;raquo;, даже если обнаруживает AMD / RequireJS. Подход AMD не рекомендует использовать глобальные функции, но решение отключить эти глобальные объекты jQuery зависит от того, есть ли у вас не-AMD код, который зависит от них. В jQuery есть &lt;a href=&quot;http://api.jquery.com/jQuery.noConflict/&quot;&gt;функция noConflict,&lt;/a&gt; которая поддерживает освобождение управления глобальными переменными, и это можно автоматизировать в файле requirejs.config, как мы увидим &lt;a href=&quot;#noconflictmap&quot;&gt;позже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63ee06036c004043a1670e9dc620e1643bb8fd2c" translate="yes" xml:space="preserve">
          <source>jQuery registers itself as the global variables &quot;$&quot; and &quot;jQuery&quot;, even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a &lt;a href=&quot;https://api.jquery.com/jQuery.noConflict/&quot;&gt;noConflict function&lt;/a&gt; that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see &lt;a href=&quot;#noconflictmap&quot;&gt;later&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d2a18212b79b67dee0e91e19cf1b654062c92" translate="yes" xml:space="preserve">
          <source>jquery.js</source>
          <target state="translated">jquery.js</target>
        </trans-unit>
        <trans-unit id="9ed0b2469c22926565156df53ef6562350753750" translate="yes" xml:space="preserve">
          <source>js/</source>
          <target state="translated">js/</target>
        </trans-unit>
        <trans-unit id="70070d20d4c6e863f10cb8b6749cc4b4efaf6027" translate="yes" xml:space="preserve">
          <source>lib/</source>
          <target state="translated">lib/</target>
        </trans-unit>
        <trans-unit id="5dbc716c4600097b85b9e51d6aeb77a4363b03ed" translate="yes" xml:space="preserve">
          <source>load</source>
          <target state="translated">load</target>
        </trans-unit>
        <trans-unit id="ec030ee0a72bb1bad48e285b9d1e42ab5b8170ee" translate="yes" xml:space="preserve">
          <source>load is a function, and it will be called with the following arguments:</source>
          <target state="translated">Загрузка является функцией,и она будет вызвана со следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="6dff233c807097ef10ae79c568dc973d30c3cf68" translate="yes" xml:space="preserve">
          <source>load: function (name, parentRequire, onload, config)</source>
          <target state="translated">загрузка:функция (имя,parentRequire,onload,config)</target>
        </trans-unit>
        <trans-unit id="0b6d8e9672e5ffa1f585413a4ff5521b40332f97" translate="yes" xml:space="preserve">
          <source>lsjs</source>
          <target state="translated">lsjs</target>
        </trans-unit>
        <trans-unit id="33e0a7d96f2f283eb6f94bbfd4ce882c6816f77d" translate="yes" xml:space="preserve">
          <source>main.css</source>
          <target state="translated">main.css</target>
        </trans-unit>
        <trans-unit id="7b6b9d0efba95dec0a83ec36edc8acd84043be9d" translate="yes" xml:space="preserve">
          <source>main.css has content like the following:</source>
          <target state="translated">main.css имеет следующее содержание:</target>
        </trans-unit>
        <trans-unit id="2d6427cfcffb5ef37b2d32bd7aac8a9b7450a987" translate="yes" xml:space="preserve">
          <source>main.html</source>
          <target state="translated">main.html</target>
        </trans-unit>
        <trans-unit id="f1df1c5603aa500b9411213f4ea48cf4e5d422e0" translate="yes" xml:space="preserve">
          <source>main.html has script tags for require.js and loads main.js via a require call, like so:</source>
          <target state="translated">main.html имеет теги скриптов для require.js и загружает main.js через вызов требуемого типа:</target>
        </trans-unit>
        <trans-unit id="c4a4248f7568c9e41265502c39b0daeb8b635431" translate="yes" xml:space="preserve">
          <source>main.js</source>
          <target state="translated">main.js</target>
        </trans-unit>
        <trans-unit id="5bde0c1eb87162d48261ef607a5f7367edd8af16" translate="yes" xml:space="preserve">
          <source>main.js loads one.js, two.js and three.js via a require call:</source>
          <target state="translated">Сеть подключает 1.js,2.js и 3.js с помощью требуемого вызова:</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="839a384082f672d5b0e4ed1c48403f66bc62c7e5" translate="yes" xml:space="preserve">
          <source>map example:</source>
          <target state="translated">Пример карты:</target>
        </trans-unit>
        <trans-unit id="3c439d3b6842ae589d848604d613de606883e341" translate="yes" xml:space="preserve">
          <source>my/cart.js</source>
          <target state="translated">my/cart.js</target>
        </trans-unit>
        <trans-unit id="6ff94085a8329ba4ee05cefa0a0b5b1b179b3db7" translate="yes" xml:space="preserve">
          <source>my/inventory.js</source>
          <target state="translated">my/inventory.js</target>
        </trans-unit>
        <trans-unit id="23b2f9933585fb1b37de87310c51e3eb51c83b97" translate="yes" xml:space="preserve">
          <source>my/nls/colors.js</source>
          <target state="translated">my/nls/colors.js</target>
        </trans-unit>
        <trans-unit id="c3e4ffdb238e5c58edbed616f0dfed31ef1359ff" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr-paris/colors.js</source>
          <target state="translated">my/nls/fr-fr-paris/colors.js</target>
        </trans-unit>
        <trans-unit id="6d560f42236d5cf1594fcea61de2e335709a6b4e" translate="yes" xml:space="preserve">
          <source>my/nls/fr-fr/colors.js</source>
          <target state="translated">my/nls/fr-fr/colors.js</target>
        </trans-unit>
        <trans-unit id="5a03cbc43369adc59a77432f3dbe892648c90d2f" translate="yes" xml:space="preserve">
          <source>my/nls/fr/colors.js</source>
          <target state="translated">my/nls/fr/colors.js</target>
        </trans-unit>
        <trans-unit id="68644578c0e8f200b5d33adf2401413115a74114" translate="yes" xml:space="preserve">
          <source>my/shirt.js</source>
          <target state="translated">my/shirt.js</target>
        </trans-unit>
        <trans-unit id="a412083cb1fc91a30f7e8b0861829a50827f0b6c" translate="yes" xml:space="preserve">
          <source>network loading</source>
          <target state="translated">загрузка сети</target>
        </trans-unit>
        <trans-unit id="2fad3300f3300cc8d668154fa62ddaae9e5376d5" translate="yes" xml:space="preserve">
          <source>newmodule.js</source>
          <target state="translated">newmodule.js</target>
        </trans-unit>
        <trans-unit id="71878dcf848606242ed856e0c6a0c24d1d32a939" translate="yes" xml:space="preserve">
          <source>nodeIdCompat</source>
          <target state="translated">nodeIdCompat</target>
        </trans-unit>
        <trans-unit id="514d9f2e0acc04d77fc45ca16b43c69b19977218" translate="yes" xml:space="preserve">
          <source>normalize</source>
          <target state="translated">normalize</target>
        </trans-unit>
        <trans-unit id="2a281ad421bb92791152f62669135fa7021cb816" translate="yes" xml:space="preserve">
          <source>normalize: function (name, normalize)</source>
          <target state="translated">нормализовать:функция (имя,нормализовать)</target>
        </trans-unit>
        <trans-unit id="660051d15ac64cec704cfacca2c2eab008f657e8" translate="yes" xml:space="preserve">
          <source>npm</source>
          <target state="translated">npm</target>
        </trans-unit>
        <trans-unit id="d8631383a6178b11a2917aa845f41707e9185dc0" translate="yes" xml:space="preserve">
          <source>oldmodule.js</source>
          <target state="translated">oldmodule.js</target>
        </trans-unit>
        <trans-unit id="7a39e1d29475a2a77167507df7366126892c9900" translate="yes" xml:space="preserve">
          <source>onLayerEnd</source>
          <target state="translated">onLayerEnd</target>
        </trans-unit>
        <trans-unit id="6010d31025036ae4e749a8b5c4d5bc7058a8c6f4" translate="yes" xml:space="preserve">
          <source>onLayerEnd is called with the following arguments:</source>
          <target state="translated">onLayerEnd вызывается со следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="b01854b4ccf9ea6577756f43de48539c45cd34d9" translate="yes" xml:space="preserve">
          <source>onLayerEnd: function (write, data)</source>
          <target state="translated">onLayerEnd:функция (запись,данные)</target>
        </trans-unit>
        <trans-unit id="4ec3dc925c02508cf421d1fa6fa05251616d92d3" translate="yes" xml:space="preserve">
          <source>one.js</source>
          <target state="translated">one.js</target>
        </trans-unit>
        <trans-unit id="da3a307e7a7ab71834fdcca6a6af66dcf9eeebce" translate="yes" xml:space="preserve">
          <source>or in a build profile. In a &lt;strong&gt;build.js&lt;/strong&gt;, the same command line arguments can be specified like so:</source>
          <target state="translated">или в профиле сборки. В &lt;strong&gt;build.js&lt;/strong&gt; те же аргументы командной строки можно указать так:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7030d0b2f71b999ff89a343de08c414af32fc93a" translate="yes" xml:space="preserve">
          <source>package.json</source>
          <target state="translated">package.json</target>
        </trans-unit>
        <trans-unit id="d8ae088aee969371bf4ed994e9106b5d3e799c35" translate="yes" xml:space="preserve">
          <source>packages</source>
          <target state="translated">packages</target>
        </trans-unit>
        <trans-unit id="1910200239e6caafdd7288bf98705c63894fa1e7" translate="yes" xml:space="preserve">
          <source>participate in a workable module system for JS in the browser today.</source>
          <target state="translated">участвуйте в работающей модульной системе для JS в браузере уже сегодня.</target>
        </trans-unit>
        <trans-unit id="0c6eeceb6e5744cc0a0a7d55d06e7292f43c9f8c" translate="yes" xml:space="preserve">
          <source>paths</source>
          <target state="translated">paths</target>
        </trans-unit>
        <trans-unit id="55431d04ee22f086c0e4730ad2d0ad6ba1df9215" translate="yes" xml:space="preserve">
          <source>paths config fallbacks</source>
          <target state="translated">ошибки конфигурации путей</target>
        </trans-unit>
        <trans-unit id="3247077e9f813f61c28294ebf0b04fa7b7e763f6" translate="yes" xml:space="preserve">
          <source>pluginBuilder</source>
          <target state="translated">pluginBuilder</target>
        </trans-unit>
        <trans-unit id="d37b10be4b23b3a5407225d5efaed1c9d5e4e805" translate="yes" xml:space="preserve">
          <source>project-directory/</source>
          <target state="translated">project-directory/</target>
        </trans-unit>
        <trans-unit id="055c5bd0721336c320466362c116cc9e22059fd0" translate="yes" xml:space="preserve">
          <source>project.html</source>
          <target state="translated">project.html</target>
        </trans-unit>
        <trans-unit id="e6c30fb20717a4f9320c2216f6eb104985e6e25d" translate="yes" xml:space="preserve">
          <source>r.js (The r.js optimizer from &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;download page&lt;/a&gt;)</source>
          <target state="translated">r.js (Оптимизатор r.js со &lt;a href=&quot;http://requirejs.org/docs/download.html#rjs&quot;&gt;страницы загрузки&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d167818bd51e72c059598e330a28144029cd8fc5" translate="yes" xml:space="preserve">
          <source>require('requirejs')</source>
          <target state="translated">require('requirejs')</target>
        </trans-unit>
        <trans-unit id="3558129c06c8b15607f833dd7dfd9f07eeda7dfe" translate="yes" xml:space="preserve">
          <source>require([]) errbacks</source>
          <target state="translated">require([])errbacks</target>
        </trans-unit>
        <trans-unit id="3eddd1f1e5f1762adabfa0582463ae368a1590f8" translate="yes" xml:space="preserve">
          <source>require.js</source>
          <target state="translated">require.js</target>
        </trans-unit>
        <trans-unit id="52b4004b2a5f9427f8ae9be275de601264335e33" translate="yes" xml:space="preserve">
          <source>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</source>
          <target state="translated">скрипт.онеррор не работает в IE 6-8.Нет способа узнать,генерирует ли загрузка скрипта 404,хуже то,что он запускает onreadystatechange с полным состоянием даже в случае 404.</target>
        </trans-unit>
        <trans-unit id="1da4f66f62a84398d6a63d2bdcbb0c6bbfb2ae9f" translate="yes" xml:space="preserve">
          <source>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</source>
          <target state="translated">script.onerror работает в IE 9+,но в нем есть ошибка,при которой он не запускает обработчики событий script.onload сразу после выполнения скрипта,поэтому он не может поддерживать стандартный метод разрешения анонимных модулей AMD.Поэтому скрипт.onreadystatechange до сих пор используется.Тем не менее,onreadystatechange работает с полным состоянием до запуска функции script.onerror.</target>
        </trans-unit>
        <trans-unit id="7818b054440ca239beb44d0b0991165ee0ad46f4" translate="yes" xml:space="preserve">
          <source>scriptType</source>
          <target state="translated">scriptType</target>
        </trans-unit>
        <trans-unit id="16728d18790deb58b3b8c1df74f06e536b532695" translate="yes" xml:space="preserve">
          <source>scripts</source>
          <target state="translated">scripts</target>
        </trans-unit>
        <trans-unit id="0cec61d8fab53349479d2fc0899c8c9fdc57a2c5" translate="yes" xml:space="preserve">
          <source>scripts/</source>
          <target state="translated">scripts/</target>
        </trans-unit>
        <trans-unit id="089017cedf29ba7955e32e88c25d3948b4f3fdea" translate="yes" xml:space="preserve">
          <source>shim</source>
          <target state="translated">shim</target>
        </trans-unit>
        <trans-unit id="357d6240a2159a33c8d69670dbeaf60f751f6066" translate="yes" xml:space="preserve">
          <source>skipDataMain</source>
          <target state="translated">skipDataMain</target>
        </trans-unit>
        <trans-unit id="94a86d6fcf88d9b98c51727a4b90aa8812e2c49e" translate="yes" xml:space="preserve">
          <source>some/</source>
          <target state="translated">some/</target>
        </trans-unit>
        <trans-unit id="94af276c25727779efc4cfa45d83a3c73f4be23c" translate="yes" xml:space="preserve">
          <source>store.js</source>
          <target state="translated">store.js</target>
        </trans-unit>
        <trans-unit id="8ca15b529f630f7ce97e77cae45b2785290b1404" translate="yes" xml:space="preserve">
          <source>store/</source>
          <target state="translated">store/</target>
        </trans-unit>
        <trans-unit id="a41e737bdcb57316f3b931ebc708a240ae2684de" translate="yes" xml:space="preserve">
          <source>sub.js</source>
          <target state="translated">sub.js</target>
        </trans-unit>
        <trans-unit id="a18864cfdb7cf1305a2ae73d6709348bf2a1be5a" translate="yes" xml:space="preserve">
          <source>the optimization could overwrite or place files outside the output directory. For those cases, create a &lt;strong&gt;paths&lt;/strong&gt; config to map that file to a local name, like:</source>
          <target state="translated">оптимизация может перезаписать или разместить файлы вне выходного каталога. В этих случаях создайте конфигурацию &lt;strong&gt;путей&lt;/strong&gt; для сопоставления этого файла с локальным именем, например:</target>
        </trans-unit>
        <trans-unit id="e76fa894c07e30c55a48e7c792952c4491d0cd8d" translate="yes" xml:space="preserve">
          <source>the tooling dependency cost</source>
          <target state="translated">стоимость инструментальной зависимости</target>
        </trans-unit>
        <trans-unit id="2750d4c188b4b1a71febebc268725da0cb849812" translate="yes" xml:space="preserve">
          <source>then just pass the build profile's file name to the optimizer:</source>
          <target state="translated">затем просто передайте оптимизатору имя файла профиля сборки:</target>
        </trans-unit>
        <trans-unit id="bf8b5529b79e43921112789bda96246277ea7d0f" translate="yes" xml:space="preserve">
          <source>then use name:</source>
          <target state="translated">тогда используй имя:</target>
        </trans-unit>
        <trans-unit id="c441435c0602c49b97cc1e421949a1f5095cd1fb" translate="yes" xml:space="preserve">
          <source>three.js</source>
          <target state="translated">three.js</target>
        </trans-unit>
        <trans-unit id="4ddfb1710fe5f5980cb00ef5dd17923d67356df7" translate="yes" xml:space="preserve">
          <source>two.js</source>
          <target state="translated">two.js</target>
        </trans-unit>
        <trans-unit id="cf67f0d1ebbbec2dd994c75b048536c4cd0b757e" translate="yes" xml:space="preserve">
          <source>urlArgs</source>
          <target state="translated">urlArgs</target>
        </trans-unit>
        <trans-unit id="e0971e2c6fc32a880b2a4273d8cd19d12b256a30" translate="yes" xml:space="preserve">
          <source>use existing AMD tooling to optimize their project</source>
          <target state="translated">использовать существующий инструментарий AMD для оптимизации своего проекта</target>
        </trans-unit>
        <trans-unit id="44317b82ece1d6cd2d98c56b0e42b6ace033067f" translate="yes" xml:space="preserve">
          <source>use more options for code loading, delayed loading</source>
          <target state="translated">использовать больше опций для загрузки кода,отложенной загрузки</target>
        </trans-unit>
        <trans-unit id="d3b2ef2f2fe3412d2bdf5d97d5d41fe37cf0e715" translate="yes" xml:space="preserve">
          <source>util.js</source>
          <target state="translated">util.js</target>
        </trans-unit>
        <trans-unit id="8f91e15d036639328135c4f04e40da6bdfdf31aa" translate="yes" xml:space="preserve">
          <source>waitSeconds</source>
          <target state="translated">waitSeconds</target>
        </trans-unit>
        <trans-unit id="bdb53d29bbbbaa4071ae3637cca5a02d7bba4c4e" translate="yes" xml:space="preserve">
          <source>where the main.js module looks like this:</source>
          <target state="translated">где модуль main.js выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="535e4e9b361a4e62b7649966552382e07ec58337" translate="yes" xml:space="preserve">
          <source>will return the current document when used as a loader plugin:</source>
          <target state="translated">вернет текущий документ при использовании в качестве плагина загрузчика:</target>
        </trans-unit>
        <trans-unit id="0adb626f023cbc31f0be36d86bd7e915c1af3143" translate="yes" xml:space="preserve">
          <source>worse debugging, a cost that continues to add up over time</source>
          <target state="translated">худшая отладка,цена,которая продолжает накапливаться с течением времени.</target>
        </trans-unit>
        <trans-unit id="e1d0c6c1c29e6ad5164072a5b21340dca7fcb052" translate="yes" xml:space="preserve">
          <source>write</source>
          <target state="translated">write</target>
        </trans-unit>
        <trans-unit id="5ae459e45b554a20a34db9cf6e8545cfa6f52ddd" translate="yes" xml:space="preserve">
          <source>write: function (pluginName, moduleName, write)</source>
          <target state="translated">запись:функция (pluginName,moduleName,write)</target>
        </trans-unit>
        <trans-unit id="6b8257fc78666892f1dfe434d6373f1c5b7bdfaf" translate="yes" xml:space="preserve">
          <source>writeFile</source>
          <target state="translated">writeFile</target>
        </trans-unit>
        <trans-unit id="ee09b7c80317309eef991c850400f0f5da599fcd" translate="yes" xml:space="preserve">
          <source>writeFile: function (pluginName, name, parentRequire, write)</source>
          <target state="translated">writeFile:функция (pluginName,name,parentRequire,write)</target>
        </trans-unit>
        <trans-unit id="0e547e2244cf8baca179b01e93513122cc2fdef1" translate="yes" xml:space="preserve">
          <source>www/</source>
          <target state="translated">www/</target>
        </trans-unit>
        <trans-unit id="152de8eee480369bd7bffe90947136dd08b6baa2" translate="yes" xml:space="preserve">
          <source>xhtml</source>
          <target state="translated">xhtml</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
