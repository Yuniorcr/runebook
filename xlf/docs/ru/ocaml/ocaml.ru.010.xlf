<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="dfd76a7086e3cc42170f403e6e55cc09afe26cb2" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;. Note that &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; is negative only if &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b01a6a7b79fbcb183062af64aaaa63eeb3f2718" translate="yes" xml:space="preserve">
          <source>Integer subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d24914c47006eb02f4dff06d0cd904dc2d2c7e" translate="yes" xml:space="preserve">
          <source>Integer subtraction. Left-associative operator, , see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee1ee4b4f11b2969952d343f112afa9881a1bab" translate="yes" xml:space="preserve">
          <source>Integer values are integer numbers from &amp;minus;2&lt;sup&gt;30&lt;/sup&gt; to 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1, that is &amp;minus;1073741824 to 1073741823. The implementation may support a wider range of integer values: on 64-bit platforms, the current implementation supports integers ranging from &amp;minus;2&lt;sup&gt;62&lt;/sup&gt; to 2&lt;sup&gt;62&lt;/sup&gt;&amp;minus;1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712ee29f7fc5c28dea5cc603b21eca7741d78fbd" translate="yes" xml:space="preserve">
          <source>Integer values encode 63-bit signed integers (31-bit on 32-bit architectures). They are unboxed (unallocated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83aa7411530d0444302d56a388b902fdce29d91" translate="yes" xml:space="preserve">
          <source>Integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="bc497571cb33f7c1a8b4b38e571f47e9c94eb5e7" translate="yes" xml:space="preserve">
          <source>Integers are &lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt; bits wide and use two's complement representation. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4241877025d1966580ad7c3f3b0ff442755310e" translate="yes" xml:space="preserve">
          <source>Integers are &lt;code&gt;Sys.int_size&lt;/code&gt; bits wide. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a102c4a574ecfadd9a7c5f1722bd0399b5d2cd" translate="yes" xml:space="preserve">
          <source>Integers are not allocated and cannot be stored in weak arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935ae25e71bde4c78ba85d5dac1b5c31c4661273" translate="yes" xml:space="preserve">
          <source>Interactive interrupt (ctrl-C)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04543475f0af93a9b1f70f2a38be6ff47c43ef12" translate="yes" xml:space="preserve">
          <source>Interactive stop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc0bc31a21623037df91a449af1758c1ea53779" translate="yes" xml:space="preserve">
          <source>Interactive termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152a2569e2c91ee227ddb8f5534f2eae5eb0d12f" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f4c23d2b8212406b51e7046c93c96a1a7f1146" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system. To use as replacement to default &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module, add &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; in your implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467f8304012cd505625c260277e4cae411499ca2" translate="yes" xml:space="preserve">
          <source>Interfacing with the standard input/output library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7c946b4a793edf3af449c46e4c2c299d575469" translate="yes" xml:space="preserve">
          <source>Internet addresses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ecff40bc2b8c11c2e5679d0ffe558077996225" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv4)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857d078139ed411f7ba1150677d3393807432577" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv6)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b995e53883804fd20a387b321cb4b4c4302563e5" translate="yes" xml:space="preserve">
          <source>Interrupt character (usually ctrl-C).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="279042ba487b938485f08f0399290c5d0cf49331" translate="yes" xml:space="preserve">
          <source>Intuition: a &amp;ldquo;blocking section&amp;rdquo; is a piece of C code that does not use the OCaml run-time system, typically a blocking input/output operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d8afba7764b4a5e45be2c963d38829c02898a1" translate="yes" xml:space="preserve">
          <source>Intuitively, a value of type 'a nested is a list of list &amp;hellip;of list of elements a with k nested list. We can then adapt the maximal_depth function defined on regular_depth into a depth function that computes this k. As a first try, we may define</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb51873a166a0ca612be5e39e25b496f16f0edd3" translate="yes" xml:space="preserve">
          <source>Invalid hardware instruction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaeaeb6ec3f8154506ce18b333531c275dcb035" translate="yes" xml:space="preserve">
          <source>Invalid link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1835382968f46a5f88dff8462ccb2b244e21516d" translate="yes" xml:space="preserve">
          <source>Invalid memory reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9851d3714a00331607464ec1db51c684493f3fde" translate="yes" xml:space="preserve">
          <source>Invalid seek e.g. on a pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d246b366cbb2a7b87d693c8eb7b14afb327f18c3" translate="yes" xml:space="preserve">
          <source>Is_block(v) is true if value v is a pointer to a block, and false if it is an immediate integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162a91bb1ae1511c1a14b48fc9b99ad1c1b64c87" translate="yes" xml:space="preserve">
          <source>Is_long(v) is true if value v is an immediate integer, false otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aad919330ed2554ad6efa2615b1d05980c4a1fa" translate="yes" xml:space="preserve">
          <source>Is_none(v) is true if value v is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805c7256b88b9f3f6f1e903639b0f13116fe3e22" translate="yes" xml:space="preserve">
          <source>Is_some(v) is true if value v (assumed to be of option type) corresponds to the Some constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90960e35ff8d0e1edddd78784b82e7ac0c892d5d" translate="yes" xml:space="preserve">
          <source>It becomes more straightforward to optimise closure allocations since the layout of closures does not have to be estimated in any way: it is known. Similarly, it becomes more straightforward to control which variables end up in which closures, helping to avoid closure bloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c1a2b53a967f6be04a8b2e559ade5c3657e377" translate="yes" xml:space="preserve">
          <source>It can be given the following specification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b604d7f25795726169718eb6d7ffbabff67881" translate="yes" xml:space="preserve">
          <source>It generates the following outputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9fb0522efe7d2a9a2092136c5f0cb0eceb5547" translate="yes" xml:space="preserve">
          <source>It is a natural choice in the API of generic functions where values could fall in two different cases, possibly at different types, without assigning a specific meaning to what each case should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8b480dde6b5f3c81553f985c24b6d8054d15cf" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &amp;zwj;&lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &amp;zwj;&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044d9b1336b13c24f31c6087a0884aa833908413" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea3ffa0da3a6a64e26d92217f56bc5dc0ee88ad" translate="yes" xml:space="preserve">
          <source>It is also possible to copy the components of a module inside another module by using an include statement. This can be particularly useful to extend existing modules. As an illustration, we could add functions that returns an optional value rather than an exception when the priority queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b378569adc4da470dbea88424425ba33922ddf5" translate="yes" xml:space="preserve">
          <source>It is also possible to specify attributes using an infix syntax. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fcca3d515f217455ee5cbe30c0a352c5140f35" translate="yes" xml:space="preserve">
          <source>It is also possible to use a virtual class. Inheriting from this class simultaneously forces all methods of c to have the same type as the methods of c'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd58beaddeffd7ca4bb4171ee18d2d1d171993da" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that expressions with no effects, whose results are not used, may be eliminated. (This typically happens where the expression in question is the defining expression of a let; in such cases the let-expression will be eliminated.) It is further assumed that such expressions with no effects may be duplicated (and thus possibly executed more than once).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d2ff83781a8a7489c112130f8ee70344794950" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that, subject to data dependencies, expressions with neither effects nor coeffects may be reordered with respect to other expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5a661dd59eecff9dd10ceec465f901059e4cc2" translate="yes" xml:space="preserve">
          <source>It is automatically &amp;ldquo;opened&amp;rdquo; when a compilation starts, or when the toplevel system is launched. Hence, it is possible to use unqualified identifiers to refer to the functions provided by the Stdlib module, without adding a open Stdlib directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd50e36d45c2c70d3b44b44f6b93ceca5aaed4e3" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd4849d026298aa7f6ab63f07e5240537d04447" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83064bce61d18a3c463038ddbd763bdd7b618f8" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9bd2e9555690ad21a6a0c4218827b24b71e84a" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b06674c64e7087d6cd54c0e34bb489d7d00dd20" translate="yes" xml:space="preserve">
          <source>It is easier to integrate with cross-module optimisation, since imported information about other modules is already in the correct intermediate language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e38f3c9e1798fbab9e90c5865cda5877abcfa" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1f54bf27ff0a3758919f394790ff7b25c9d1f8" translate="yes" xml:space="preserve">
          <source>It is however possible to define functions that manipulate objects of type either money or money2: the function min will return the minimum of any two objects whose type unifies with #comparable. The type of min is not the same as #comparable -&amp;gt; #comparable -&amp;gt; #comparable, as the abbreviation #comparable hides a type variable (an ellipsis). Each occurrence of this abbreviation generates a new variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06505630dc097368cdf81588999cb42bce21605e" translate="yes" xml:space="preserve">
          <source>It is important to note that the exported front-end interface follows the evolution of the OCaml language and implementation, and thus does not provide any backwards compatibility guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df425a65ea13fa3de15879ad0ff948e700f992b5" translate="yes" xml:space="preserve">
          <source>It is important to provide the client&amp;rsquo;s view as a functor Client so that client accounts can still be built after a possible specialization of the bank. The functor Client may remain unchanged and be passed the new definition to initialize a client&amp;rsquo;s view of the extended account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a013a33299e01ccd1972c4a799393bbe9b322fa8" translate="yes" xml:space="preserve">
          <source>It is important to remark that the function eval is using the polymorphic syntax for locally abstract types. When defining a recursive function that manipulates a GADT, explicit polymorphic recursion should generally be used. For instance, the following definition fails with a type error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f0de9451006df17669b54818c85d11fb78b04d" translate="yes" xml:space="preserve">
          <source>It is not possible to mix native-code object files produced by ocamlopt with bytecode object files produced by ocamlc: a program must be compiled entirely with ocamlopt or entirely with ocamlc. Native-code object files produced by ocamlopt cannot be loaded in the toplevel system ocaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6d73db6c27ba0773eb0db381d42efb65e8e409" translate="yes" xml:space="preserve">
          <source>It is often a security hole to leak file descriptors opened on, say, a private file to an external program: the program, then, gets access to the private file and can do bad things with it. Hence, it is highly recommended to set all file descriptors ``close-on-exec'', except in the very few cases where a file descriptor actually needs to be transmitted to another program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79cb04a19a396d38be69e08c2821e7ce44154b03" translate="yes" xml:space="preserve">
          <source>It is only possible to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, if the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (like for a type annotation), and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The type of the coerced expression is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. If the types contain variables, they may be instantiated by the subtyping algorithm, but this is only done after determining whether &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a potential subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This means that typing may fail during this latter unification step, even if some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. In the following paragraphs we describe the subtyping relation used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc436df5f472c76f9b857cad66e30b424d794e2" translate="yes" xml:space="preserve">
          <source>It is possible to declare a method without actually defining it, using the keyword virtual. This method will be provided later in subclasses. A class containing virtual methods must be flagged virtual, and cannot be instantiated (that is, no object of this class can be created). It still defines type abbreviations (treating virtual methods as other methods.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e850727b9f6478bee4607ccc53d1de385121ba" translate="yes" xml:space="preserve">
          <source>It is possible to define a generator class in several modules, which are defined in several files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], file&lt;sub&gt;2&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i]. A .cma library file must be created, including all these files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faea6818157cac9f0988b494ec9a1fb10a63786" translate="yes" xml:space="preserve">
          <source>It is possible to define local exceptions in expressions: letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; . The syntactic scope of the exception constructor is the inner expression, but nothing prevents exception values created with this constructor from escaping this scope. Two executions of the definition above result in two incompatible exception constructors (as for any exception definition). For instance, the following assertion is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c1a7eb6e17934cbe039ce2d9565c2d1a043e49" translate="yes" xml:space="preserve">
          <source>It is possible to write a version of class point without assignments on the instance variables. The override construct {&amp;lt; ... &amp;gt;} returns a copy of &amp;ldquo;self&amp;rdquo; (that is, the current object), possibly changing the value of some instance variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b8c74a40907020aea23679f7d3a1e47e89c876" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0223e5551045af3ae0aff910678f36144e4dbc" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79eca76d0232a8de08f10b0fc7e60c155d206d" translate="yes" xml:space="preserve">
          <source>It is recommended to inherit from the current generator of the same kind as the one you want to define. Doing so, it is possible to load various custom generators to combine improvements brought by each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfaad68f50ca8cd128072213cb8026032d1a1ddb" translate="yes" xml:space="preserve">
          <source>It is sometimes inconvenient to build a custom runtime system each time OCaml code is linked with C libraries, like ocamlc -custom does. For one thing, the building of the runtime system is slow on some systems (that have bad linkers or slow remote file systems); for another thing, the platform-independence of bytecode files is lost, forcing to perform one ocamlc -custom link per platform of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccaf02d4a67360ff683564b219f17b5312faf2d" translate="yes" xml:space="preserve">
          <source>It may also be useful to relay an optional argument from a function call to another. This can be done by prefixing the applied argument with ?. This question mark disables the wrapping of optional argument in an option type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2ae4f4dfef6ee049420fc585397e822cd1841d" translate="yes" xml:space="preserve">
          <source>It may become the case during compilation that one or more invariant arguments to a function become specialised to a particular value. When such values are themselves boxed the corresponding specialised arguments may be split into more specialised arguments corresponding to the projections out of the boxed value that occur within the function body. This transformation is called &lt;em&gt;unboxing of specialised arguments&lt;/em&gt;. It is only applied when there is reasonable certainty that the boxed argument itself is unused within the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2113b64361ed06b2fb660d291ef792f576530d08" translate="yes" xml:space="preserve">
          <source>It particular, it provides the basic operations over the built-in types (numbers, booleans, byte sequences, strings, exceptions, references, lists, arrays, input-output channels, ...) and the &lt;a href=&quot;stdlib#modules&quot;&gt;standard library modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e1bb8314f0b54fe82043439ead06c77dd005bd" translate="yes" xml:space="preserve">
          <source>It permits higher-order inlining, for example when a non-inlinable function always returns the same function yet with different environments of definition. Not all such cases are supported yet, but it is intended that such support will be improved in future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62dc081b8f1528625d07f7e633e0a268ec1a67b" translate="yes" xml:space="preserve">
          <source>It raises &lt;code&gt;End_of_file&lt;/code&gt; if the function has already reached the end of file when starting to read from the channel, and raises &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; if it reaches the end of file later during the unmarshalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eeb9110a841ac9d46371abdaeea4230b064629" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;em&gt;unboxing of closures&lt;/em&gt; pass (see below) can introduce specialised arguments on non-recursive functions. (No other place in the compiler currently does this.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1b6ac17c7b6c87ec71a416499d7641064d1ab8" translate="yes" xml:space="preserve">
          <source>It should be noted that the blocks corresponding to initialise-symbol bindings are kept alive forever, by virtue of them occurring in a static table of GC roots within the object file. This extended lifetime of expressions may on occasion be surprising. If it is desired to create some non-constant value (for example when writing GC tests) that does not have this extended lifetime, then it may be created and used inside a function, with the application point of that function (perhaps at toplevel)&amp;mdash;or indeed the function declaration itself&amp;mdash;marked as to never be inlined. This technique prevents lifting of the definition of the value in question (assuming of course that it is not constant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c39d8ce8aefbd00cfb85541a53fdf588caae0" translate="yes" xml:space="preserve">
          <source>It will be accepted if each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, is not immediately linked to any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and is not an array constructor whose arguments have abstract type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1efde60809be61ee856277b8eeaecd2343156c0" translate="yes" xml:space="preserve">
          <source>It would be incorrect to perform Field(r, 1) = tail directly, because the allocation of tail has taken place since r was allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e56ebc8d92919227f4b41f4b34fc2bd72f5bbb0" translate="yes" xml:space="preserve">
          <source>It would be natural to factorize these two definitions as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033f25fa120ee864f9ba41bac8624f68584547d1" translate="yes" xml:space="preserve">
          <source>It would be unsound to apply this fake_id function to values with different types. The function fake_id is therefore rightfully assigned the type '_weak3 -&amp;gt; '_weak3 rather than 'a -&amp;gt; 'a. At the same time, it ought to be possible to use a local mutable state without impacting the type of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9a22f0bb03dc04334b781283f4d9b2b79cd9d" translate="yes" xml:space="preserve">
          <source>Items produced by symbolic pretty-printers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c475641298983202fb5bb4c85bf773502af819b" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e251fe0eee2437464dec9a234fc1b325f32052" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d6cc59b755b47fc8e1cdb410adb3abe777160d" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa1984f98f87ade05a77d2d30ccf29617c61c6" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc753a1a200932eacd72d4b7ac2810d8ee977b0f" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72365e84c44abbdabda346bfd2a72b67f6a2f040" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d6da7fff2897e2fdb9323a2fa6acc42d8e4f3c" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59b1457067d268a42e29eef63f4228e79bc1f79" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53111c31562ee5692d94ba95750e9d8128aa9335" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52718e109f8ea9e93b899d8a8c03df0ab8a5e288" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7e2d0218e27b69ec7b7e2712b13e76087fea47" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c13a9362e94273776029d2c08f652f705e4760a" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b731e40512294d27a66934701878da5e53e3950" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a301a25721beaf25e58fa63b6a4fc32321de99" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08358549ccfddcf0b104c824624f18dbe99ff7fa" translate="yes" xml:space="preserve">
          <source>Iterate on the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0a0ebdb168df270cb3d5064d01e17c0b56bb4a" translate="yes" xml:space="preserve">
          <source>Iterate on the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0797886b2f424b48d1cd58859fb9af00b7784b" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25db6012c3533afa619b7a8a7742b0a42cb7afd" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order. The behavior is not defined if the queue is modified during the iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0bd8ad0f81cad6d96bacf14d0331f3a6e12dbd" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff7477ff445e072b84d4239e6c7d7c3aa347e47" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c886336160d913779eb591bdee0d4b0e15e45e" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94cac5480ab8007065d1c6001b6f46bf9c31673" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom. It is safe to modify the stack during iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f621778fd05a26d4f34ddb7acf9a152913cceff" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcd995c03b85f6200cad5b28912c76d3ebd838a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83efc6c1259a0086cd4741e82ac58d922ad5c76a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing order, yielding indices along chars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b702d271270fdfb0f8e97fdc65aa27aa84c7e5" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in ascending order of keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1597c7ed9610370a35252cf68c470142228c66" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in descending order of keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fbfcbff3c4717a90de3169e97500f554fe0e8f" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in ascending order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73226e9d1bfa69238bca027c8fc049d38fc1ddb2" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in descending order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d061daf3db9ad7ba0961da1a7a84cd239402bf" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d8c94aa5374233499af2d9864d692b5eaf8400" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table. The order in which the bindings appear in the sequence is unspecified. However, if the table contains several bindings for the same key, they appear in reversed order of introduction, that is, the most recent binding appears first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="92a60e08e4214743467aeef16832efbb28d68b7b" translate="yes" xml:space="preserve">
          <source>Iterators on two arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf924725c2b8039b9d275152dc025994654f8e3d" translate="yes" xml:space="preserve">
          <source>Iterators on two lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="91ad1acf9ee2be52d2d52e1b2736deba62d38e52" translate="yes" xml:space="preserve">
          <source>January &amp;zwj;27, 2021</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb8b7268bc0ef366e246e15fb194af699da0d9a" translate="yes" xml:space="preserve">
          <source>Jump to the given time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7561e05c5b18318690fb04c12d71c9e371b509" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &amp;zwj;&lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624a232e29c6285e85daf176c56dfb635d3dd7fd" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="a940001b3198e7ae1e643d753be086d8c3542efb" translate="yes" xml:space="preserve">
          <source>Keep connection active</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136012b6c6d58edff8f132cf6ce26d59cc8f9982" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274136e14622e37b8b6331a086d3f3366e3831f5" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d62255be0ec9f781a5f40b46da0c3024c36bab8" translate="yes" xml:space="preserve">
          <source>Keep the assembly code produced during the compilation. The assembly code for the source file x.ml is saved in the file x.s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14983f1a3e8d2301fc0a539f434e69ec9ea45c93" translate="yes" xml:space="preserve">
          <source>Kill line character (usually ctrl-U).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60b8fa8d42c209a51f605ad6c17c5d3484a13de" translate="yes" xml:space="preserve">
          <source>Kill the program being executed. This command is mainly useful if you wish to recompile the program without leaving the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67374519f2f22eab63c039c77b42da37349cc81" translate="yes" xml:space="preserve">
          <source>Kind of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="ce4744e6d2befcbbcee49b587ff32fe4d8b6dfef" translate="yes" xml:space="preserve">
          <source>Label names, tag names, method names and instance variable names need not be qualified: the former three are global labels, while the latter are local to a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7566409fe33db7c1382047b4b33d525174722c1" translate="yes" xml:space="preserve">
          <source>Label omitted in function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="09193ca3e31ac574fb94c2e9ba86583737f30c6d" translate="yes" xml:space="preserve">
          <source>Labels are not ignored in types, labels may be used in applications, and labelled parameters can be given in any order. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d07567828d6157c7a0bbfacdccc17fbf690bde4" translate="yes" xml:space="preserve">
          <source>Labels obey the same rules as other identifiers in OCaml, that is you cannot use a reserved keyword (like in or to) as label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac290ed377f5383ec5a1609fac7d51da07b74769" translate="yes" xml:space="preserve">
          <source>Large, multi-dimensional, numerical arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27ea870e756a4996b6e5548e72dad903dff893f" translate="yes" xml:space="preserve">
          <source>Last access time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ae7c6bdca85d087ad5892abd46d332ae4415d4" translate="yes" xml:space="preserve">
          <source>Last modification time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd551a9da615e1f482b38b0b5800894d52c749c" translate="yes" xml:space="preserve">
          <source>Last status change time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a1892b560a2dae03d58c477f42a35e2fc92bf8" translate="yes" xml:space="preserve">
          <source>Last-in first-out stacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="7f09861439451aa36330c7bf95178c6ddcb46e50" translate="yes" xml:space="preserve">
          <source>Lazy patterns provide another way to force a lazy expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634afef2094c369bdd48d1f752631ea2a14a676c" translate="yes" xml:space="preserve">
          <source>Leave out-of-band data in line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f5ed01117b556dfcfb05f94fe84491fe8dcbb5" translate="yes" xml:space="preserve">
          <source>Less commonly-used options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1097315573ec76e509abe7102d689a6563ecc3" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e205d5e74a87e2d51ce5ba5fc4154c84a89a9f" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90f57fc3563e16d5d28640fa27a45b5626288d1" translate="yes" xml:space="preserve">
          <source>Let us consider a more complex example: define a circle, whose center may be any kind of point. We put an additional type constraint in method move, since no free variables must remain unaccounted for by the class type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ad92c4c358eba8bbc5b8a0969daf464a03c61f" translate="yes" xml:space="preserve">
          <source>Let-bindings within class definitions are evaluated before the object is constructed. It is also possible to evaluate an expression immediately after the object has been built. Such code is written as an anonymous hidden method called an initializer. Therefore, it can access self and the instance variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78e74717b8e8ca45266657c33dd0aa134152b63" translate="yes" xml:space="preserve">
          <source>Lexer buffers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9b887a7274d537cc019ca8a98c797f62c81ee3" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &amp;zwj;&lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;23&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba638f354cbd4eea4869aa7af64033d01e9baca" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92672530b6de1c7c2b6aa008abe880f35c25185c" translate="yes" xml:space="preserve">
          <source>Lexers can optionally maintain the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; position fields. This &quot;position tracking&quot; mode is the default, and it corresponds to passing &lt;code&gt;~with_position:true&lt;/code&gt; to functions that create lexer buffers. In this mode, the lexing engine and lexer actions are co-responsible for properly updating the position fields, as described in the next paragraph. When the mode is explicitly disabled (with &lt;code&gt;~with_position:false&lt;/code&gt;), the lexing engine will not touch the position fields and the lexer actions should be careful not to do it either; the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; field will then always hold the &lt;code&gt;dummy_pos&lt;/code&gt; invalid position. Not tracking positions avoids allocations and memory writes and can significantly improve the performance of the lexer in contexts where &lt;code&gt;lex_start_p&lt;/code&gt; and &lt;code&gt;lex_curr_p&lt;/code&gt; are not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3917223ea7504c595a7ef33cb226700969d3360" translate="yes" xml:space="preserve">
          <source>Lexical ambiguities are resolved according to the &amp;ldquo;longest match&amp;rdquo; rule: when a character sequence can be decomposed into two tokens in several different ways, the decomposition retained is the one with the longest first token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a202cc33085b7bb25725a4f379636b34841789" translate="yes" xml:space="preserve">
          <source>Lexing</source>
          <target state="translated">Lexing</target>
        </trans-unit>
        <trans-unit id="a70e713317076c077fd1641566d360708f118d2a" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bbfe7d8b55633595dd6244e6f0439507cf30e5" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_char lexbuf n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74ea0f938e819ae2026560af60f9bf7b4293e6d" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_end lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd5d51aa0344b0018430731ae4cef689fd5ac6c" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_start lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="29af859893fdcdadf9189b04f68a9abe34f1c20e" translate="yes" xml:space="preserve">
          <source>Lifting of constants to toplevel reduces allocation at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb0377305aff6b2536761bb8210a8352e72ce63" translate="yes" xml:space="preserve">
          <source>Lightweight threads for Posix &lt;code&gt;1003.1c&lt;/code&gt; and Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850af4b7ba532914fbbab5d04f50f07c734c1799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e8e123fe0b1dc99bead7adea2aec6a3d1ac2c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cf409f10899743c833d44d422e8ce9982b9a92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6c54b020c7c7d74936820b2eb4bd3d379258c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfadb351771bde10f24fe7abed8ab6142dcbd0a1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALget&quot;&gt;&lt;code&gt;Bigarray.Array2.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221178edad17fc6894a4c266434a7aa9bc5afe69" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALset&quot;&gt;&lt;code&gt;Bigarray.Array2.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbb6f02cca19cfee80223b75c549f0acb3031ee" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALget&quot;&gt;&lt;code&gt;Bigarray.Array3.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ea99c63be240916526a60717058a5a7e0e8f87" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALset&quot;&gt;&lt;code&gt;Bigarray.Array3.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9e4e4e60b86cce032b0d708e5c35fefc9ea9ae" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbbb7a679272947e8eb9d35cbee8a2de10a3c47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file. This function is a no-op if OCAML_SPACETIME_INTERVAL was not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f14140f3588801dee3a1d5fb94c57e5e969c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e8a3b2000bfdbec151fc2e1f14f86877e2c204" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05df27d0e208419cdd29b6ff60273cb7cdd7768" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e5ff07d8ec0b1c6d8bcaabede4dea51cec8d1b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1c55d58c17c31347619f0f98121afaee022313" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;raw_backtrace_entry&lt;/code&gt;, values of this type are process-specific and must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc734516e0de9e6a8e3e99a4330cf58d7f961f5" translate="yes" xml:space="preserve">
          <source>Like constructed terms, polymorphic variant values are represented either as integers (for polymorphic variants without argument), or as blocks (for polymorphic variants with an argument). Unlike constructed terms, variant constructors are not numbered starting from 0, but identified by a hash value (an OCaml integer), as computed by the C function hash_variant (declared in &amp;lt;caml/mlvalues.h&amp;gt;): the hash value for a variant constructor named, say, VConstr is hash_variant(&quot;VConstr&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84db1f1935fb847355e19d1183905165a54092aa" translate="yes" xml:space="preserve">
          <source>Like for modules, it is possible to include a signature to copy its components inside the current signature. For instance, we can extend the PRIOQUEUE signature with the extract_opt function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bed73780596b7f834ced053725e46c0df1f9817" translate="yes" xml:space="preserve">
          <source>Like for names, choosing labels for functions is not an easy task. A good labeling is a labeling which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e1d0d1bfc15d7766298ee68fb31b046e1b23e5" translate="yes" xml:space="preserve">
          <source>Like in function definitions, the definition above can be abbreviated as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd97eca67dfa1c7ecded513f14bd0f5af7f65f" translate="yes" xml:space="preserve">
          <source>Likewise.</source>
          <target state="translated">Likewise.</target>
        </trans-unit>
        <trans-unit id="d6a89f5f5aab1dc9ec97d86beabe3da25c8f6ddd" translate="yes" xml:space="preserve">
          <source>Limit the number of value nodes printed to at most n. Remaining parts of values are printed as ... (ellipsis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad9b678b8122b484b49d4fd677c60e7b110f651" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe294dbc375ee535fc34452b44543c9389175384" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of n. The parts of values whose depth exceeds n are printed as ... (ellipsis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c82d004dcdb36148874aaf0cae92f27ef7fbfb" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to at most l nodes printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922b9004440d60d364efc1c8981f83c8e0a5a20" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07f2e960f4ea462077ce5669747d94a6df33827" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e5da713196db5ef014749220895ab23bcef20fe" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e15b2364cc575d6dbc34984468f8d6d885901b" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="dc3d988645b4957d3dd83740735d0cb6d66953cf" translate="yes" xml:space="preserve">
          <source>List concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd013775c64eff58dc6132a245c0ce270a850c6" translate="yes" xml:space="preserve">
          <source>List concatenation. Not tail-recursive (length of the first argument). Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0365ae410f8457307452f898da684eba14b29c5f" translate="yes" xml:space="preserve">
          <source>List of directories searched to find the bytecode executable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eaa95db5646e28fe7153c07d0f70fa876dd1b94" translate="yes" xml:space="preserve">
          <source>List of format elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2136f9decb402dc033169190742a9590a2e8171a" translate="yes" xml:space="preserve">
          <source>List operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b37d6672e7f341dcb945c17aabc1b419dec4f50" translate="yes" xml:space="preserve">
          <source>List reversal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637c60434c34ad7a7432343dd717e34e34be9418" translate="yes" xml:space="preserve">
          <source>List scanning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ca755f57f387a8fa5a689d0657d056de2dbb3e" translate="yes" xml:space="preserve">
          <source>List searching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e130b5fdd6ede5933f5e364b277835f131b8204" translate="yes" xml:space="preserve">
          <source>List the source of module module, from line number beginning to line number end. By default, 20 lines of the current module are displayed, starting 10 lines before the current position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca5f98ec9772c0239bb1a06bbafbaa7dccb5d4c" translate="yes" xml:space="preserve">
          <source>ListLabels</source>
          <target state="translated">ListLabels</target>
        </trans-unit>
        <trans-unit id="caa56fb279e78a5e60984ad896e4f99d33cd9ba0" translate="yes" xml:space="preserve">
          <source>Lists of pairs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9984cdc3b0e43d1b8e01a6016b6b16f60122a8" translate="yes" xml:space="preserve">
          <source>Literals for 32-bit integers are suffixed by l:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f376ff18d781ef4e7ce630da2eb8cc5e0867f63" translate="yes" xml:space="preserve">
          <source>Literals for 64-bit integers are suffixed by L:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6259c5bb5a0b49cb897bdeab6a0b94ebf736355f" translate="yes" xml:space="preserve">
          <source>Literals for native integers are suffixed by n:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b1043a802b867b1154a51397b46d475fcc1b1c" translate="yes" xml:space="preserve">
          <source>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on &lt;a href=&quot;sys#VALbig_endian&quot;&gt;&lt;code&gt;Sys.big_endian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf6da19f9240117d92be77adf519c48a64293ee" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cbe4ea6dac6abfc435470246f61cb80c7ae677" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc. When loading an object file that depends on other modules which have not been loaded yet, the .cmo files for these modules are searched and loaded as well, recursively. The loading order is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5246ec3fd3ea63c509be27737c36d3be01173e" translate="yes" xml:space="preserve">
          <source>Load in the debugger the indicated .cmo or .cma object file. The file is loaded in an environment consisting only of the OCaml standard library plus the definitions provided by object files previously loaded using load_printer. If this file depends on other object files not yet loaded, the debugger automatically loads them if it is able to find them in the search path. The loaded file does not have direct access to the modules of the program being debugged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9554426e849ebccce273355d09330acd0af5f810" translate="yes" xml:space="preserve">
          <source>Load information from file, which has been produced by ocamldoc -dump. Several -load options can be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1468bdc0578724ddc204f4a8076fd367c4f00ada" translate="yes" xml:space="preserve">
          <source>Load the given file instead of the default initialization file. The default file is .ocamlinit in the current directory if it exists, otherwise XDG_CONFIG_HOME/ocaml/init.ml or .ocamlinit in the user&amp;rsquo;s home directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a34ca10bffd479d41682ae72278c33fd620c73" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &amp;zwj;&lt;a href=&quot;#s%3Abreakpoints&quot;&gt;16.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c136cf2e9c1518388c865d582646bebe003932" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e63214a47f4377c1d66c127f747b02a52318db2" translate="yes" xml:space="preserve">
          <source>Load the program and stop on the first event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d5cb576439af064f31b513f860fdcf129f485b" translate="yes" xml:space="preserve">
          <source>Loading codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75d20b246e4621320b31b1c098e452853a4ac67" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class expressions since OCaml 4.06.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570b10f925c51b325fdc93e2d97c8848252648e2" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class types since OCaml 4.06.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a006a52c95463d27833642d291aafafbbe657d6" translate="yes" xml:space="preserve">
          <source>Local substitutions behave like destructive substitutions (with ... := ...) but instead of being applied to a whole signature after the fact, they are introduced during the specification of the signature, and will apply to all the items that follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b9f4a56a716ca3242cf294551816b0edc61b5d" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, and block if already locked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f366a2b18c94da3f95550dd69540c8a030c1d1" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, or fail if already locked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b934b756e8fc53911807eb32d2b56437692262d" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, and block if already locked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93a16a3ed8e2fb19e43651da0d9564d29f64855" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, or fail if already locked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7af655541e99448e1ec9e27d57b823c87c4cdc" translate="yes" xml:space="preserve">
          <source>Lock the given mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef84af5a92860b1f205389a08e46e19c1d0376bf" translate="yes" xml:space="preserve">
          <source>Lock the given mutex. Only one thread can have the mutex locked at any time. A thread that attempts to lock a mutex already locked by another thread will suspend until the other thread unlocks the mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="d744573647f56d06b5b86078a49e94460efb4548" translate="yes" xml:space="preserve">
          <source>Locks for mutual exclusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2911f8b42aa989ed16139a00c9d592e0e4e835c2" translate="yes" xml:space="preserve">
          <source>Long_val(v) returns the long int encoded in value v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911e3c5ea58f72e14fe5b81b5acd435c6c333d4f" translate="yes" xml:space="preserve">
          <source>Low-level functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="c934410bd452bcb5e709691c6c967b3dbcd37b50" translate="yes" xml:space="preserve">
          <source>MD5 message digest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6426140160e26a1863b2e621495d7c29a1605e0" translate="yes" xml:space="preserve">
          <source>Make inlining decisions at the point of definition of a function rather than at the call site(s). This mirrors the behaviour of OCaml compilers not using Flambda. Compared to compilation using the new Flambda inlining heuristics (for example at -O2) it produces smaller .cmx files, shorter compilation times and code that probably runs rather slower. When using -Oclassic, only the following options described in this section are relevant: -inlining-report and -inline. If any other of the options described in this section are used, the behaviour is undefined and may cause an error in future versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f29834334520e37b98f6237ca25333d059bd2e" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;15.2.5&lt;/a&gt;) is very simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8c42ef87bb8b55a6444a52383572cda55e1591" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt;) is very simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee138b412931aab18dbc01608d4cef40bddbdba" translate="yes" xml:space="preserve">
          <source>Management of signals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8766772088c50c0ea69ddcc9e68cc232fadded3" translate="yes" xml:space="preserve">
          <source>Manipulation of backtrace information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c43329032df3d96e24d72c385d12a422e571b619" translate="yes" xml:space="preserve">
          <source>Map CR to NL on input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b1ed02cf5951695363e86b8efaae11f6285d79" translate="yes" xml:space="preserve">
          <source>Map NL to CR on input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="face92f1c006ac531f226f881711266fcb0854d2" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1e9a2774804659a435bcd137155a2fc9950a33" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874e0cf467c242a8715d382d0113f4ffe8e8b9dc" translate="yes" xml:space="preserve">
          <source>Mapping files into memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792fe4aaafb220da5ab17388e5844c93f1d95290" translate="yes" xml:space="preserve">
          <source>Margin</source>
          <target state="translated">Margin</target>
        </trans-unit>
        <trans-unit id="4e68d70db4cb0c9f7b47b7e8261347a139a40f40" translate="yes" xml:space="preserve">
          <source>Mark as fatal the warnings specified in the argument warning-list. The compiler will stop with an error when one of these warnings is emitted. The warning-list has the same meaning as for the -w option: a + sign (or an uppercase letter) marks the corresponding warnings as fatal, a - sign (or a lowercase letter) turns them back into non-fatal warnings, and a @ sign both enables and marks as fatal the corresponding warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9651ed6afe7f40f844d844247a351f306f618725" translate="yes" xml:space="preserve">
          <source>Mark parity errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="facd64ea9fa3010a0e9705a9b4261b78f3ecb660" translate="yes" xml:space="preserve">
          <source>Marshaling of data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad9eec833cc64e444f260559ec864ea918d9fe7" translate="yes" xml:space="preserve">
          <source>Match any single character belonging to the given character set. Valid character sets are: single character constants 'c'; ranges of characters 'c&lt;sub&gt;1&lt;/sub&gt;'-'c&lt;sub&gt;2&lt;/sub&gt;' (all characters between c&lt;sub&gt;1&lt;/sub&gt; and c&lt;sub&gt;2&lt;/sub&gt;, inclusive); and the union of two or more character sets, denoted by concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff233319bdf1bc966fa073a62017cfcf28311ec" translate="yes" xml:space="preserve">
          <source>Match any single character not belonging to the given character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ad8e08bddf311e1561c76915c116ddac2c9064" translate="yes" xml:space="preserve">
          <source>Match the end of the lexer input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624939b9202c5d64193aa77b5ed57d3e219078ff" translate="yes" xml:space="preserve">
          <source>Match the same strings as &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d643dda70d07a9bff87dc40b34a36dca7c58f10" translate="yes" xml:space="preserve">
          <source>Matching &lt;em&gt;any&lt;/em&gt; amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; succeeds and returns &lt;code&gt;1&lt;/code&gt; when reading an input with various whitespace in it, such as &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt;, &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt;, or even &lt;code&gt;Price=1$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ba4e48291cd2cf0b811e179ed03624617f0f18" translate="yes" xml:space="preserve">
          <source>Matching proceeds as described before, except that if the value matches some pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; which has a guard cond&lt;sub&gt;i&lt;/sub&gt;, then the expression cond&lt;sub&gt;i&lt;/sub&gt; is evaluated (in an environment enriched by the bindings performed during matching). If cond&lt;sub&gt;i&lt;/sub&gt; evaluates to true, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated and its value returned as the result of the matching, as usual. But if cond&lt;sub&gt;i&lt;/sub&gt; evaluates to false, the matching is resumed against the patterns following &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fe7526fed514734906dd56f0808fdf64d5c5e7" translate="yes" xml:space="preserve">
          <source>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by &lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt;&lt;code&gt;Format.get_ellipsis_text&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c775e0b631e27aa872cba9538a7ad38db0e8382" translate="yes" xml:space="preserve">
          <source>Maximal number of bindings per bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4aecc225c29a9b00684b7a91e8d4a7c0c4fcf7" translate="yes" xml:space="preserve">
          <source>Maximum amount of out-of-heap memory for each custom value allocated in the minor heap. When a custom value is allocated on the minor heap and holds more than this many bytes, only this value is counted against &lt;code&gt;custom_minor_ratio&lt;/code&gt; and the rest is directly counted against &lt;code&gt;custom_major_ratio&lt;/code&gt;. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 8192 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4b693ac7f8f148df9e57169d08a10429066cdc" translate="yes" xml:space="preserve">
          <source>Maximum formatting depth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e8208d3223642a44e274b068fe9167dea74624" translate="yes" xml:space="preserve">
          <source>Maximum indentation limit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d9251c94f60be5c0a454afa29832266764bb87" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a82d8640ca6e8be934710976326d9e3d41c21e3" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray. This is also the maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; when OCaml is configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f830d8170e15a87cf9b64f314629724f342359" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e07a269e552f76233aa4f04ad4c80b7015574f5" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e. any array whose elements are not of type &lt;code&gt;float&lt;/code&gt;). The maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; is &lt;code&gt;max_floatarray_length&lt;/code&gt; if OCaml was configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt; and &lt;code&gt;max_array_length&lt;/code&gt; if configured with &lt;code&gt;--disable-flat-float-array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4de1705370b8992fe2eac57ca9e570d5b6fdbf4" translate="yes" xml:space="preserve">
          <source>Maximum length of an ephemeron, ie the maximum number of keys an ephemeron could contain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d2ea9cbf5aa25afab320da73d2cb8746b9c6ea" translate="yes" xml:space="preserve">
          <source>Maximum length of strings and byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111798f4ee1440503f39a9ca5e215b57ed0edd0d" translate="yes" xml:space="preserve">
          <source>Maximum read wait (in 0.1s units).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421dda9f026ffda8002440f413ce7dac542281cc" translate="yes" xml:space="preserve">
          <source>Maximum size reached by the major heap, in words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0867fadb65552799103f1e2c59b6996e3bca055e" translate="yes" xml:space="preserve">
          <source>Maybe the most frequent examples of non-genericity derive from the interactions between polymorphic types and mutation. A simple example appears when typing the following expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="58b588830d79aaa6edd4ede9d25c9ec5e38ae494" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to control event collection at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5747d498a7435bd2232d8a279011040168fdf61" translate="yes" xml:space="preserve">
          <source>Memory management control and statistics; finalised values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d5fee5c92276c92276efd0e44640e46a30110a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac1a6209785502b12f1048680ede77f0350462f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d453e5fd051d62abb4952e6dce9f9a70c5c2e73f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;code&gt;Unix.openfile&lt;/code&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687a2f280f91251cb46ba017b7b6d351d9f7b57a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;~kind&amp;nbsp;~layout&amp;nbsp;~shared&amp;nbsp;~dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880d9fe17162cdc8dbe19eec2a7dab314180b634" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82c912801fa2f38788ef8f80f6481aca333a281" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3146b01bddaff3613fcbac8db0c98762beac5c7b" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7521d4a01b5a820f9494840a903097972d0cd3be" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;~cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf991e7854ed942e57f7a8ae958526d710e4851" translate="yes" xml:space="preserve">
          <source>Message too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe901f98d707d8893028273fbe15a247b6dc752f" translate="yes" xml:space="preserve">
          <source>Method calls to objects are not at present inlined by Flambda.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725d48f23a2318240368857da2dd4a836394a9b1" translate="yes" xml:space="preserve">
          <source>Method overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="73d77f95747bb6c235ba5d9d8dd5594481b601b7" translate="yes" xml:space="preserve">
          <source>Methods may have an explicitly polymorphic type, allowing them to be used polymorphically in programs (even for the same object). The explicit declaration may be done in one of three ways: (1) by giving an explicit polymorphic type in the method definition, immediately after the method name, &lt;em&gt;i.e.&lt;/em&gt;method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;: {'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;; (2) by a forward declaration of the explicit polymorphic type through a virtual method definition; (3) by importing such a declaration through inheritance and/or constraining the type of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977a75b1b527cafb43a310b768323025de5a89bf" translate="yes" xml:space="preserve">
          <source>Methods need not be declared previously, as shown by the example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a374e74161047aa235fbb3100763be5b812693" translate="yes" xml:space="preserve">
          <source>Middle mouse button</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d193e7dfe2ad2529b4896dcc5d46972be46e952" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for input operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d481070b2cfb403e278c0dca62449244848cbded" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for output operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5be9f6d96fb9719bc05c3c57eba753a99104553" translate="yes" xml:space="preserve">
          <source>Minimum number of characters to read before the read request is satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1858c250815195a7d6f8064ba7ae2ae308e2c946" translate="yes" xml:space="preserve">
          <source>Minor collection and major GC slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7f64b06da5b1e4fcb3453af263375fd663c205" translate="yes" xml:space="preserve">
          <source>Minutes 0..59</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b08ec421dc1322ebeee3c79275c01cc8b3d8fe" translate="yes" xml:space="preserve">
          <source>Missing cmx file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d081333d4e9bb27d1f44459f14c2d45dd9f81b1c" translate="yes" xml:space="preserve">
          <source>Missing fields in a record pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f242d312b71edb3517a2032fd66710ec76680c" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Format&lt;/code&gt; provides a complete set of &lt;code&gt;printf&lt;/code&gt; like functions for pretty-printing using format string specifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad989c3e6325882d6507e66e3602a4dd7dd1950" translate="yes" xml:space="preserve">
          <source>Module Arg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abf3bb1d160573e61d46e6b5f81e5508ae82e88" translate="yes" xml:space="preserve">
          <source>Module Arg: parsing of command line arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56fcb800d5771af9f080dd53abe44c449867565" translate="yes" xml:space="preserve">
          <source>Module Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2ddb4a440e52c266e257d745c23b9dadfa5b3d" translate="yes" xml:space="preserve">
          <source>Module Array: array operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d18ab309cc5cd2e46cd375092084b640f8135f4" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6ff72196a05305dab9e2db994ea05cd60e104b" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels: array operations (with labels)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93c03acf357c6454b6e5285450c3f3f3f30bb2c" translate="yes" xml:space="preserve">
          <source>Module Ast_helper: helper functions for AST construction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f633b64e1901b821e83c2d2917c9c7dfe7b2811" translate="yes" xml:space="preserve">
          <source>Module Ast_mapper: -ppx rewriter interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d5c8f5c6bb7605890429c1f11b8c345bdf0a9" translate="yes" xml:space="preserve">
          <source>Module Asttypes: auxiliary types used by Parsetree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466cc01746b0ce14da9c3101dbcb89de8c254f25" translate="yes" xml:space="preserve">
          <source>Module Atomic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14944e195276656a6b2e991b8c449794b3b7e562" translate="yes" xml:space="preserve">
          <source>Module Atomic: atomic references</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc643dfec1e07f16e63a2f5d40439c635b5a0da0" translate="yes" xml:space="preserve">
          <source>Module Bigarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b457fad35d3c5733311bed4d1abc1928bb9ab28" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0606447c86667b05a149e8ca96cc9d366dcdc45f" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9d1f71e428cb53a57134b56fbd980b03c94e2c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d48e9da9c33900ca44d6ecad351863f7bdaf5c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d26b36f6d58ffaea1f504565e46f4f60567d67" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Genarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3762282f9caa555d54286fbb90a1e96b4c7c432" translate="yes" xml:space="preserve">
          <source>Module Bigarray: large, multi-dimensional, numerical arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecd3446e16a821dd5e1adff2cc82cb3a5130a89" translate="yes" xml:space="preserve">
          <source>Module Bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3e715d33fc29b958efa37ae69668a59a1706ff" translate="yes" xml:space="preserve">
          <source>Module Bool: boolean values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddc2144c4c529dd8430235937580a143554e16c" translate="yes" xml:space="preserve">
          <source>Module Buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c2c38aaa41d7ed5d989a9cc184b3794181c9f7" translate="yes" xml:space="preserve">
          <source>Module Buffer: extensible buffers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72216591b14162977cfdb1c07def7995da644395" translate="yes" xml:space="preserve">
          <source>Module Bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c11fb2e91c5b00fbb9701a94d4424a17d04a49c" translate="yes" xml:space="preserve">
          <source>Module Bytes: byte sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85f0c0beeed2c6b8ad5ef29ccdfab63a21b9d52" translate="yes" xml:space="preserve">
          <source>Module BytesLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cf68f0aad404a1f34cfeef9f8dc2bc6273085e" translate="yes" xml:space="preserve">
          <source>Module BytesLabels: byte sequences (with labels)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99b095fc3c2466d64fae5588a546e997e1e5f16" translate="yes" xml:space="preserve">
          <source>Module Callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559eafeaa053a08996c324cd386ae9221fc17b97" translate="yes" xml:space="preserve">
          <source>Module Callback: registering OCaml values with the C runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbdcb25b8c3385ccca990f6993d3f200b6c8d9d" translate="yes" xml:space="preserve">
          <source>Module CamlinternalAtomic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1355614e6d5e948afbb68e8c6119679a9a45955" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d1db84ed7881aa6f76ae9db16693820f6725ae" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormatBasics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e7f0366b4e8dbdb121c6899472d74fc9e300ed" translate="yes" xml:space="preserve">
          <source>Module CamlinternalLazy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030e686bde89aa913f3dbe8fe375396e5953e5e6" translate="yes" xml:space="preserve">
          <source>Module CamlinternalMod</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6ad5c3473f26f582d139567a98ea0e9d3d3b4e" translate="yes" xml:space="preserve">
          <source>Module CamlinternalOO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e77ccf8fe8cad52d93078cb896ef207ae08837" translate="yes" xml:space="preserve">
          <source>Module Char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb75d51c88cc6b02cf6aca6015384b8720d875a9" translate="yes" xml:space="preserve">
          <source>Module Char: character operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5548e02ff9068a8bd2671e455dd9adf27f571d77" translate="yes" xml:space="preserve">
          <source>Module Complex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142a8ecd6426e808bdec26ab206584b15b18b324" translate="yes" xml:space="preserve">
          <source>Module Complex: Complex numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6616c10e3d84b4d6c6f90344d150f834e185fcae" translate="yes" xml:space="preserve">
          <source>Module Complex: complex numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0d5f1ae3231eea0973a205c212df89a0b65712" translate="yes" xml:space="preserve">
          <source>Module Condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a62a2154dc372d92c88ec0dfbedc61b73cd367" translate="yes" xml:space="preserve">
          <source>Module Condition: condition variables to synchronize between threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c923312ef4200761b1302981bacdcb52bccc44f9" translate="yes" xml:space="preserve">
          <source>Module Digest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbfa8ae15ecab1209610ac5a66a651f78875a78" translate="yes" xml:space="preserve">
          <source>Module Digest: MD5 message digest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c49caa12242dda259d7307d31dd98fda25b90d" translate="yes" xml:space="preserve">
          <source>Module Dynlink</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17df668e4cee0361dd61ce759ea047d4ccf6ce2f" translate="yes" xml:space="preserve">
          <source>Module Dynlink: dynamic loading of bytecode object files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b077e55507ea365c5713901e6a0e01092935292a" translate="yes" xml:space="preserve">
          <source>Module Either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a3d2172baa76706a9eb32021eb67f6a8824d3b" translate="yes" xml:space="preserve">
          <source>Module Either: either values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c62be44cefe5016fcac970fcb981646c02e96b6" translate="yes" xml:space="preserve">
          <source>Module Ephemeron</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306ceb414fe45593e76183fffc1c6e8063a97af7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.GenHashTable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0d413a4c6a68f4547228b7fbcd4303cea78dd7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc37a3b6fff03344d782218dfc93f84de56f0454" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbed2786938f2a0e76b0e83d9e7aee1f6ba1c21" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.Kn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc16c26307d248abe81e5774136cc291bdc2f67" translate="yes" xml:space="preserve">
          <source>Module Ephemeron: Ephemerons and weak hash table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965c3d92c5cef899a73c03e9b00b354453a07c58" translate="yes" xml:space="preserve">
          <source>Module Event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6dd977ad9cdd9e33bfa766d7ff4615d50d92bac" translate="yes" xml:space="preserve">
          <source>Module Event: first-class synchronous communication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95908861b116393327d9f6360c9aa8ce9f3fc3d9" translate="yes" xml:space="preserve">
          <source>Module Filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2de638ce58f0d0a702b4d4f313c4f37216533f" translate="yes" xml:space="preserve">
          <source>Module Filename: operations on file names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf4558ebef769a096f39fa6c0312334a381fec2" translate="yes" xml:space="preserve">
          <source>Module Float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ebb1cca64e0c8f91ce7a3e1f3ba4030ed3b8f4" translate="yes" xml:space="preserve">
          <source>Module Float.Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445a0b0a1771a9581127d17829402c08430bebed" translate="yes" xml:space="preserve">
          <source>Module Float.ArrayLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3600f92b6696937343502269bc8090397c0e51e" translate="yes" xml:space="preserve">
          <source>Module Float: Floating-point numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313822257f2621ba0ec98af8aadf8d2638a5326a" translate="yes" xml:space="preserve">
          <source>Module Float: floating-point numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cecfe8e0ae9b3a901adc050a10fa4ea0c7797d" translate="yes" xml:space="preserve">
          <source>Module Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bb5435b16c5c8b6ab86cf0323be7dcc9f30566" translate="yes" xml:space="preserve">
          <source>Module Format: pretty printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb444a56b618a584c9cdb2f01ce73257415d59a" translate="yes" xml:space="preserve">
          <source>Module Fun</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b410ee83d227d662e6b02df5f6cd601cb1762f" translate="yes" xml:space="preserve">
          <source>Module Fun: function values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07aebf1d4ebd5c2e42b08423a93172511323b0f" translate="yes" xml:space="preserve">
          <source>Module Gc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac86c6af7ac7bc4fc4841fea39b50ce532e9eae3" translate="yes" xml:space="preserve">
          <source>Module Gc.Memprof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017db642bb8f1e27af62b289d7afc0311dfb9b9d" translate="yes" xml:space="preserve">
          <source>Module Gc: memory management control and statistics; finalized values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13184731a834066fef8c861de2b8b904d78a2c40" translate="yes" xml:space="preserve">
          <source>Module Genlex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee3df3538f22bd946cb81aed2d740d6af4e43d7" translate="yes" xml:space="preserve">
          <source>Module Genlex: a generic lexical analyzer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8fffbaf37dc886f091f1fcec194d70a8a56139" translate="yes" xml:space="preserve">
          <source>Module Hashtbl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ea31d5ad955fa4490b30ef1a1270d2c6392bda" translate="yes" xml:space="preserve">
          <source>Module Hashtbl: hash tables and hash functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f5fed72bf1186b3606fcd64d3620ad4b5e6d3f" translate="yes" xml:space="preserve">
          <source>Module Int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acab9c65663172b6b3cf63cdb91db7c853666939" translate="yes" xml:space="preserve">
          <source>Module Int32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59af84ad710fb152c38038123bed434bcda5ee5d" translate="yes" xml:space="preserve">
          <source>Module Int32: 32-bit integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb57e65a2c5001e2ebbf893ab00402f586e67a7" translate="yes" xml:space="preserve">
          <source>Module Int64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5dcbf9b29416b9da9d5777bc0cbfff746fd3bff" translate="yes" xml:space="preserve">
          <source>Module Int64: 64-bit integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67951c6b0d56d43a8d0b9f4a75238e26b84e176" translate="yes" xml:space="preserve">
          <source>Module Int: integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbdc748b0a834da10d99ca83f0f783ca0b5c0b5" translate="yes" xml:space="preserve">
          <source>Module Lazy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed3c69956723eb0ea9cccf3b3f808a1e740d7bd" translate="yes" xml:space="preserve">
          <source>Module Lazy: deferred computations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9af75cdf4a76dd0ace806f7dd01595ce9a4e7f" translate="yes" xml:space="preserve">
          <source>Module Lexing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda606f5e00de0f84675796ae085f4bffba696d6" translate="yes" xml:space="preserve">
          <source>Module Lexing: the run-time library for lexers generated by ocamllex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba47168d0ea302d6485e2bceea2a3d5ea07497a" translate="yes" xml:space="preserve">
          <source>Module List</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95ac15be64ca43f1623a9f9232b997c5bf2c1d4" translate="yes" xml:space="preserve">
          <source>Module List: list operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daeda2f1f3fc9215afe3219e87ce40a8a991bc71" translate="yes" xml:space="preserve">
          <source>Module ListLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abd62669e68c48ade8c878e63da864a392f2017" translate="yes" xml:space="preserve">
          <source>Module ListLabels: list operations (with labels)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41eb27b154c8a0a9fe8b6fcd4251fc8ecd2542f7" translate="yes" xml:space="preserve">
          <source>Module Location: source code locations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ea5f0fd44fa46552a5f30cbf18b1bf609af0ea" translate="yes" xml:space="preserve">
          <source>Module Longident: long identifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b6935577db632331cb02bf7fee39599c44a34e" translate="yes" xml:space="preserve">
          <source>Module Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723c875a6e9814d580d5129ea7f70d98fe17170f" translate="yes" xml:space="preserve">
          <source>Module Map: association tables over ordered types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996a073e0bd0499fc31006fad291c31374a4ad0a" translate="yes" xml:space="preserve">
          <source>Module Marshal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937c5df760edcb5aeb3c943766622a05d26ea688" translate="yes" xml:space="preserve">
          <source>Module Marshal: marshaling of data structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7a3c934043e76f7e6aa5bab83a410c8b18ba72" translate="yes" xml:space="preserve">
          <source>Module MoreLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b77f1b995f3d850723fe2d5f0d94f538cb8bc90" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Hashtbl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760a84c4680b6780dd84d385973bbf20f33f4210" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Map</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25069e19c5b1b2db1e702799063dde780224c560" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b19605374bddf60dcda0218ce57f2d6c6393746" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: Include modules Hashtbl, Map and Set with labels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98637b2b2a158224bf07282ac080de51fa6cf0bc" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: include modules Hashtbl, Map and Set with labels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699fda78007ab6ee795d1ec46cb5ba0fadbcd152" translate="yes" xml:space="preserve">
          <source>Module Mutex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9441c63e9620994d64788047f899a67dff634072" translate="yes" xml:space="preserve">
          <source>Module Mutex: locks for mutual exclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1838869d8ec86c1a2d37dff5dc780f83b0fec1d6" translate="yes" xml:space="preserve">
          <source>Module Nativeint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1d1c0c97415413ce2342a3f6f55d45834011c5" translate="yes" xml:space="preserve">
          <source>Module Nativeint: processor-native integers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4ea02830398a7975c1360e1989452b5c984a6e" translate="yes" xml:space="preserve">
          <source>Module Obj</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859ef67380ce711f1e2680e67b72fd41777bfb0f" translate="yes" xml:space="preserve">
          <source>Module Obj.Closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272ea9eeccbd009ebb96e6b41a649184070812a9" translate="yes" xml:space="preserve">
          <source>Module Obj.Ephemeron</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d7d19a5339d91797722162ab420ee924fd4061" translate="yes" xml:space="preserve">
          <source>Module Obj.Extension_constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe9ce284b5e4679d29a8e61897d87de3d56edfa" translate="yes" xml:space="preserve">
          <source>Module Oo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab66589e35c123c9f9433f57b4d129d3e642f10" translate="yes" xml:space="preserve">
          <source>Module Oo: object-oriented extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552e8a4259199d9b2043147a832aca29c2875d9a" translate="yes" xml:space="preserve">
          <source>Module Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8d3db6fe714bb3b01fd318b7f50f3a7d37c609" translate="yes" xml:space="preserve">
          <source>Module Option: option values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee462040d70476901068cb4b27d7246c72808b85" translate="yes" xml:space="preserve">
          <source>Module Parse: OCaml syntax parsing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf367dbe7aff2e9ccc52d81e33ebb4ebae22ff7" translate="yes" xml:space="preserve">
          <source>Module Parsetree: OCaml syntax tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7614cdd9f0ec33aa4685f6bd34afeb038456c5ae" translate="yes" xml:space="preserve">
          <source>Module Parsing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674971f0c437aab44e4076ee335788a7f95f2d06" translate="yes" xml:space="preserve">
          <source>Module Parsing: the run-time library for parsers generated by ocamlyacc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5588d487861f64669575fcb69cb5b074b4f41fb" translate="yes" xml:space="preserve">
          <source>Module Pervasives: deprecated alias for Stdlib</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1dc73aec1ccbac02b8e8f43ee58892b59b0745" translate="yes" xml:space="preserve">
          <source>Module Pprintast: OCaml syntax printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e430425b7a707621c40fc5db568b1422825347" translate="yes" xml:space="preserve">
          <source>Module Printexc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c879b5b58ad9c94051bbfc78df7ae8670b40859d" translate="yes" xml:space="preserve">
          <source>Module Printexc.Slot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f9916225d741d402336a087d22708a6a08547d" translate="yes" xml:space="preserve">
          <source>Module Printexc: facilities for printing exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef8e2302f5298816f3c9a62eb7ff84ee4558dc9" translate="yes" xml:space="preserve">
          <source>Module Printf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2f2beac76b39281ec8d02c364037eaeb98cbcb" translate="yes" xml:space="preserve">
          <source>Module Printf: formatting printing functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12960179cefb13cef1a39ceeab8802831a8d8f8" translate="yes" xml:space="preserve">
          <source>Module Queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053310d8755ceed37f1727f1d1a1abcfeefaea2f" translate="yes" xml:space="preserve">
          <source>Module Queue: first-in first-out queues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef161e448a0a073f4c747dde06ec44412c5ae309" translate="yes" xml:space="preserve">
          <source>Module Random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8723087c253ef44125a63809350dd54cc9e5e8" translate="yes" xml:space="preserve">
          <source>Module Random.State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfee50267f747d0f1636dd29878bc9fbb3994b9" translate="yes" xml:space="preserve">
          <source>Module Random: pseudo-random number generator (PRNG)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e0c591450e8a2f60ddb8562b4eb14af09e5b51" translate="yes" xml:space="preserve">
          <source>Module Result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eafde20b375d72096c25a3285f206655630e2ae" translate="yes" xml:space="preserve">
          <source>Module Result: result values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dde4ae279ace1dea00b588ae3d4054f614e24e" translate="yes" xml:space="preserve">
          <source>Module Scanf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa3fa82fa6bc6d8e6dabdd6356bda9b0137aefa" translate="yes" xml:space="preserve">
          <source>Module Scanf.Scanning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93459bcb89eeedf8df411de000f7c2b7c9780503" translate="yes" xml:space="preserve">
          <source>Module Scanf: formatted input functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e539c5a64e74abf12fbc1f4b60209168d4716984" translate="yes" xml:space="preserve">
          <source>Module Semaphore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7688008138dadcacc66b763e30777b6d0d699616" translate="yes" xml:space="preserve">
          <source>Module Semaphore.Binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd5cecccc783dc01eb0a29e9c5b25b59e399bba" translate="yes" xml:space="preserve">
          <source>Module Semaphore.Counting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1eab6a93a86c214bcaac7b7a7a9fa747c2741e" translate="yes" xml:space="preserve">
          <source>Module Semaphore: semaphores, another thread synchronization mechanism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5360c938c49ae1cd63d56a4fc35fd3890f06a01" translate="yes" xml:space="preserve">
          <source>Module Seq</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745c27dde866b15642e25a8b7002225f218d5efe" translate="yes" xml:space="preserve">
          <source>Module Seq: functional iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0b5bb25d996e8a2a59e644edb186eb56df4a38" translate="yes" xml:space="preserve">
          <source>Module Set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67541933874b03516f40829e2167ebbae9f49f77" translate="yes" xml:space="preserve">
          <source>Module Set: sets over ordered types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15bed9d67a6d8605a1857d27cc2f85878fa8b5" translate="yes" xml:space="preserve">
          <source>Module Spacetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b13666199abdbce5a1c2329aac36b498b7e871" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Series</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed586d95f752bc00d8837393fbda372cb0681cb" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Snapshot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ff8e88da485589309cef464360394198823612" translate="yes" xml:space="preserve">
          <source>Module Spacetime: memory profiler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d4f336aa17896a5ff3ff9448ea7a4608c970ea" translate="yes" xml:space="preserve">
          <source>Module Stack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecef102202227813e5a4bf6e1e72dfe223f093c2" translate="yes" xml:space="preserve">
          <source>Module Stack: last-in first-out stacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958de5433af391dd3de782eaa1308532356d8dda" translate="yes" xml:space="preserve">
          <source>Module StdLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6cfb9453daaec927ca632937f9ea620e55191b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fabd24c30510aa2b8a03d1edb5b5d1ecd2653b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d01f040c78ef0b845f05e2b484d4280c974e590" translate="yes" xml:space="preserve">
          <source>Module StdLabels.List</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd5288d0fdc22e9eb53ef8ba091154cc4f412a2" translate="yes" xml:space="preserve">
          <source>Module StdLabels.String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6319cdcea700dd1fcd120036bbd03d1e43944c48" translate="yes" xml:space="preserve">
          <source>Module StdLabels: Include modules Array, List and String with labels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39a9c6c78d95bf885f759f67a81d80cda893b5f" translate="yes" xml:space="preserve">
          <source>Module StdLabels: include modules Array, List and String with labels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7ff76184d2e7ae3e758550a03699c6d8049bc7" translate="yes" xml:space="preserve">
          <source>Module Stdlib</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4a0131cb2ed42ae1c9005e8a590e1a54091746" translate="yes" xml:space="preserve">
          <source>Module Stdlib: the initially opened module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e94b392b5c848b46e6e013f4fd8019d3c00a4e" translate="yes" xml:space="preserve">
          <source>Module Str</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5614285483e72abcf9faabc441c693739ffb77" translate="yes" xml:space="preserve">
          <source>Module Str: regular expressions and string processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7138e5bba47e7b41c63652637ee7a8b037bea0" translate="yes" xml:space="preserve">
          <source>Module Stream</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10278f414b080e077e13858c56aa56fde51bd41" translate="yes" xml:space="preserve">
          <source>Module Stream: streams and parsers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ab9c78a29a26ab6d1cdf26aea5144a4e15f83e" translate="yes" xml:space="preserve">
          <source>Module String</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d219088316f00d44e6354f32e38b06be5fe6f8" translate="yes" xml:space="preserve">
          <source>Module String: string operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3e85713ed5e07464558eda70637c5642cbf379" translate="yes" xml:space="preserve">
          <source>Module StringLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95abe374ec440091969c5ee120b8542ebb8f77" translate="yes" xml:space="preserve">
          <source>Module StringLabels: string operations (with labels)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5b8544f315aab96f8817d79bb089eae9451184" translate="yes" xml:space="preserve">
          <source>Module Sys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958984972bc48fce8fefbe326a85479ad724c6a0" translate="yes" xml:space="preserve">
          <source>Module Sys.Immediate64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629ea4ee2faa04c5bb6a3adf93e15571e0d8394e" translate="yes" xml:space="preserve">
          <source>Module Sys: system interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48051dde4d899f8ff82f4d3479ec93c3c7647b0f" translate="yes" xml:space="preserve">
          <source>Module Thread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a862836a470588219a4249125bd8f10755fd16b0" translate="yes" xml:space="preserve">
          <source>Module Thread: lightweight threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9156d38a7fa11dbaedc16f3d0706294aac2ebee0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6798276f98df7d87c62baea2b0202dd5654a1c0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix: thread-compatible system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9e553dcec01d6ecdaeef8c6bce2f1ed535807c" translate="yes" xml:space="preserve">
          <source>Module Uchar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e8da370a37852b69424f5d308f6e8b6a190cbb" translate="yes" xml:space="preserve">
          <source>Module Uchar: Unicode characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ecb69a288aecc5495371b2c1779751b68e31b4" translate="yes" xml:space="preserve">
          <source>Module Unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba1b1b3ef272d41eba2286920064169778f337d" translate="yes" xml:space="preserve">
          <source>Module Unit: unit values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1792b1adb6606ac02ca5a4965131d6116d82599a" translate="yes" xml:space="preserve">
          <source>Module Unix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68685cf371d09d0be037c8891fdbb041a6955bb4" translate="yes" xml:space="preserve">
          <source>Module Unix.LargeFile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09a1e52642105e9e7b0b8457efac3458d40b0f0" translate="yes" xml:space="preserve">
          <source>Module Unix: Unix system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e446500e934433078817abf2e14140a9f2567531" translate="yes" xml:space="preserve">
          <source>Module UnixLabels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d97bc7771ac286b2f7fa8d869eb8a2a0f2e806" translate="yes" xml:space="preserve">
          <source>Module UnixLabels.LargeFile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc3a336379a1ab64349969278912adaf93249f4" translate="yes" xml:space="preserve">
          <source>Module UnixLabels: Labeled Unix system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87aa68b013503ed8844fab06b1f94a6cf80b676" translate="yes" xml:space="preserve">
          <source>Module Weak</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fbea6de11552e58adf74acc30f65573ee8b35b" translate="yes" xml:space="preserve">
          <source>Module Weak: arrays of weak pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331d2760734f7e482dfad8fe98cac289cb021696" translate="yes" xml:space="preserve">
          <source>Module expressions are the module-level equivalent of value expressions: they evaluate to modules, thus providing implementations for the specifications expressed in module types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd0d4a8e429ad9704ed8561d8b8ccf363cf691b" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba5bbb64dc581113ae02747f71e2e95524ad670" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.SeededS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fc3d9e09cfcef4e28717f43e53f614492c4a07" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.HashedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553e3c5393f8ee87abd320792f53df0480a89437" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f4885e8e252ac679a71b98e38ae6b36bec3794" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededHashedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a7fd61f14defb9b6e4cfd12105dcf424fb68dc" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a914203d81a68cd8f34d38dd3525c65fb9c5ba" translate="yes" xml:space="preserve">
          <source>Module type Map.OrderedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d326bc02f7f0598bde27deba9a371a4e51379f13" translate="yes" xml:space="preserve">
          <source>Module type Map.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f4fc879c6159477aa40865bb89618115962c18" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.HashedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac1d1343fd73a7f1801158d9ea0bc13f5f2438e" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227008c4795726cb8535f817b67718075184d4b4" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededHashedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378116ae1fbf467ddaea54a32b51349c6761a1c1" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae291b8f1ed6643e66aaa62f2bc341a327d4675" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.OrderedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7154f17264fbac973b9fa0370b2c6d6369cde11d" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a999b8bf8010daee6d4715724a5de3c63e349192" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.OrderedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f02d0b490b6bd1c3b28accd09985393baabab9" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05df05949b4417b3b5d633c96eec842e5cc5a73c" translate="yes" xml:space="preserve">
          <source>Module type Set.OrderedType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0540217cacc40a66bb6b0dcbe128de08a49bb684" translate="yes" xml:space="preserve">
          <source>Module type Set.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6682efa59e414919e3f347ffa12dbd5a9ef7d4b0" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Immediate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a12e0efd39177b624b9104a3d6be80c5fdf8d7" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Non_immediate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4946361a74879d2b9ef81babbb5a11b0fd75747a" translate="yes" xml:space="preserve">
          <source>Module type Weak.S</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e18ca9fec937a1c5383f1670e1007cb899397310" translate="yes" xml:space="preserve">
          <source>Module types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5882558195a629df9610d22ab7a2bb696dfa08e" translate="yes" xml:space="preserve">
          <source>Module types are the module-level equivalent of type expressions: they specify the general shape and type properties of modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="1bdeaa58662002456132d5e4df075bf678e694ae" translate="yes" xml:space="preserve">
          <source>Modules are typically thought of as static components. This extension makes it possible to pack a module as a first-class value, which can later be dynamically unpacked into a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3f2d6730fda28eebf828a1b5d994ee25cda13c" translate="yes" xml:space="preserve">
          <source>Month of year 0..11</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7368e316821f8931f19a457402e063b7f5ee9a7c" translate="yes" xml:space="preserve">
          <source>More character operations are provided in module &lt;a href=&quot;char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bfe303800e6bfff75b4a2a864eabaac9c1ba04" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as &lt;a href=&quot;https://github.com/ocaml/dune&quot;&gt;dune&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c4048d66ba3c4b91263b34fa74fb272d60a783" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as the &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; compilation manager.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78f1fdb280b815afafea05758a2cf808b129b60" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &amp;zwj;&lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561b0023eb18eba22354cdb393742a8b59c73c03" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d19b2b2f97ccba7609ee2b5ad377c0b117b048" translate="yes" xml:space="preserve">
          <source>More formatters can be created with &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt;&lt;/a&gt; or using &lt;a href=&quot;format#formatter&quot;&gt;custom formatters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6948d057e07078f31d8b94099955db506d318be0" translate="yes" xml:space="preserve">
          <source>More generally, as soon as a type variable appears in a position describing mutable state it becomes invariant. As a corollary, covariant variables will never denote mutable locations and can be safely generalized. For a better description, interested readers can consult the original article by Jacques Garrigue on &lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c805dcb67ff19c680fa8d577587f09aa3b1df1b0" translate="yes" xml:space="preserve">
          <source>More important is the fact that polymorphic variants, while being type-safe, result in a weaker type discipline. That is, core language variants do actually much more than ensuring type-safety, they also check that you use only declared constructors, that all constructors present in a data-structure are compatible, and they enforce typing constraints to their parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e832f6beb4577f420972cdf48bcfee3bb6d20aec" translate="yes" xml:space="preserve">
          <source>More list operations are provided in module &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c233b3a7dba4306b68b837cdcd9f763220099a" translate="yes" xml:space="preserve">
          <source>More precisely, consider the expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2403a8574f06c5e570469506e110ecacf6fc95f8" translate="yes" xml:space="preserve">
          <source>More precisely: when a semantic tag is opened or closed then both and successive 'tag-printing' and 'tag-marking' operations occur:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9eabc59e9a2d75ca1154fdc14a5cb14b6f18138" translate="yes" xml:space="preserve">
          <source>More string operations are provided in module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20302dcfb13e0aacdfb918a9998d06e11ec681a9" translate="yes" xml:space="preserve">
          <source>MoreLabels</source>
          <target state="translated">MoreLabels</target>
        </trans-unit>
        <trans-unit id="f2d9c7352bab5b013f1b4948abc890b999a592c8" translate="yes" xml:space="preserve">
          <source>Moreover, being the last defined type is a quite unstable position that may change surreptitiously after adding or moving around a type definition, or after opening a module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;). Consequently, adding explicit type annotations to guide disambiguation is more robust than relying on the last defined type disambiguation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575cbbaf8906b9c5a5ee4c9f1a89643a318a7a5" translate="yes" xml:space="preserve">
          <source>Moreover, opening a box after the &lt;a href=&quot;format#maxindent&quot;&gt;maximum indentation limit&lt;/a&gt; splits the line whether or not the box would end up fitting on the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bacee78a2fc3a758d3d73b2a613831022d03403" translate="yes" xml:space="preserve">
          <source>Moreover, the table shouldn't be modified during a call to &lt;code&gt;iter&lt;/code&gt;. Use &lt;code&gt;filter_map_inplace&lt;/code&gt; in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938a8c4d2e6fe32d5784eafdd62df55fa7c40576" translate="yes" xml:space="preserve">
          <source>Moreover, weak types cannot appear in the signature of toplevel modules: types must be known at compilation time. Otherwise, different compilation units could replace the weak type with different and incompatible types. For this reason, compiling the following small piece of code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3770beeb0150f7b961905b2a3287d7d10a959428" translate="yes" xml:space="preserve">
          <source>Moreover, when the type definitions are exposed, the type checker is able to infer variance information on its own and one can benefit from the relaxed value restriction even unknowingly. However, this is not the case anymore when defining new abstract types. As an illustration, we can define a module type collection as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce25d2287fa6866cf43b250692213d18a00fc939" translate="yes" xml:space="preserve">
          <source>Most functions in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module come in two variants: a short version that operates on &lt;a href=&quot;format#VALstd_formatter&quot;&gt;&lt;code&gt;Format.std_formatter&lt;/code&gt;&lt;/a&gt; and the generic version prefixed by &lt;code&gt;pp_&lt;/code&gt; that takes a formatter as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ca906dcdb56968f58923bddaabb17961cb58f1" translate="yes" xml:space="preserve">
          <source>Multi-index are also supported through a second variant of indexing operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac17c3be367cdf7b78ca9f7d7c50f262d3737c1d" translate="yes" xml:space="preserve">
          <source>Multiple inheritance is allowed. Only the last definition of a method is kept: the redefinition in a subclass of a method that was visible in the parent class overrides the definition in the parent class. Previous definitions of a method can be reused by binding the related ancestor. Below, super is bound to the ancestor printable_point. The name super is a pseudo value identifier that can only be used to invoke a super-class method, as in super#print.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3d99d65d2f00ba5445685c943974a51e9484a3" translate="yes" xml:space="preserve">
          <source>Multiple levels of packing can be achieved by combining -pack with -for-pack. Consider the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="549313c817d85e3b3f930b86928b72bbc44715d8" translate="yes" xml:space="preserve">
          <source>Multiplication.</source>
          <target state="translated">Multiplication.</target>
        </trans-unit>
        <trans-unit id="0d9a3f742b2bc9ffe56449aed4b901aa2ce9a0f4" translate="yes" xml:space="preserve">
          <source>Multiplicative inverse (&lt;code&gt;1/z&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="ff8d388bea0cae09717df1b41a4b4c493e6970fa" translate="yes" xml:space="preserve">
          <source>Mutexes (mutual-exclusion locks) are used to implement critical sections and protect shared mutable data structures against concurrent accesses. The typical use is (if &lt;code&gt;m&lt;/code&gt; is the mutex associated with the data structure &lt;code&gt;D&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="e353e4d6aad1380c87ec233564134a4a344dffe7" translate="yes" xml:space="preserve">
          <source>Name of service or port number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae264d14a11c34ace5fbb1bb8a6dd75bfdb17d89" translate="yes" xml:space="preserve">
          <source>Name or IP address of host</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549333ca0fbff4a493ab5e0bc0f95428f0fc7de0" translate="yes" xml:space="preserve">
          <source>Name space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b76addd8adeb70cb127b2a93c3fa37d752c2d" translate="yes" xml:space="preserve">
          <source>Name the output files prefix.ml, prefix.mli, prefix.output, instead of the default naming convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c095b2219367daec6dcc1e5087ff4061bfc41c9" translate="yes" xml:space="preserve">
          <source>Named pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296294d67daa5c2f7bd477f7158b245e13beb631" translate="yes" xml:space="preserve">
          <source>Namely, the inferred remaining case is Some _, which is split into Some (Int, _) and Some (Bool, _), which are both untypable because deep expects a non-existing char t as the first element of the tuple. Note that the refutation case could be omitted here, because it is automatically added when there is only one case in the pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e162aabfb0fa43d82b67a374234c4cb74d9be965" translate="yes" xml:space="preserve">
          <source>Names that are defined as abstract types in a signature can be implemented in a matching structure by any kind of type definition (provided it has the same number of type parameters). The exact implementation of the type will be hidden to the users of the structure. In particular, if the type is implemented as a variant type or record type, the associated constructors and fields will not be accessible to the users; if the type is implemented as an abbreviation, the type equality between the type name and the right-hand side of the abbreviation will be hidden from the users of the structure. Users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e848993d9abd7bcd0da1a886c50f6a34ca40770" translate="yes" xml:space="preserve">
          <source>Naming labels come in two flavours: &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; for normal arguments and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; for optional ones. They are simply distinguished by their first character, either ~ or ?.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be64c74e17dde72651549865ed8544a38961913d" translate="yes" xml:space="preserve">
          <source>Nativeint</source>
          <target state="translated">Nativeint</target>
        </trans-unit>
        <trans-unit id="6121887e44c8bb72f2cd96f891df9010238c7905" translate="yes" xml:space="preserve">
          <source>Nativeint_val(v) returns the long integer contained in the nativeintv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe99dc11adcd3f4c5eeceb4413e82bcd56b5ef61" translate="yes" xml:space="preserve">
          <source>Natural logarithm (in base &lt;code&gt;e&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f187f5dc4cb75173c53a77254bdd4b7078911c3" translate="yes" xml:space="preserve">
          <source>Natural logarithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b710ee6a1b2df5b06e260b4de6bc7921f957917e" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8919121a4837a7384f394582f637a0af70744796" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9befaab36628d9f7863760f1639c08f6661eaa9f" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f78c719756b0216b5efd59f9661b9e8b62f6c6" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f939047f0ba0a97a64071a5a435763eb58f7bd" translate="yes" xml:space="preserve">
          <source>Negative infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba9abe745a8f0e4e877cc69abc52cdee83e48b7" translate="yes" xml:space="preserve">
          <source>Network dropped connection on reset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34a1412dd6535ceabe7960d72728113a96b875c" translate="yes" xml:space="preserve">
          <source>Network is unreachable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c006cf01dc92514d04743559daf156d417fe5f82" translate="yes" xml:space="preserve">
          <source>New applications that need arbitrary-precision arithmetic should use the Zarith library (&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;) instead of the Num library, and older applications that already use Num are encouraged to switch to Zarith. Zarith delivers much better performance than Num and has a nicer API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280be44a9152ebadb2bdb39840c63ece14ec70f7" translate="yes" xml:space="preserve">
          <source>New variant type or record type: no equation, a representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1039fc69f9291b60d0860a59005e4bab261192" translate="yes" xml:space="preserve">
          <source>Next, we run the program under afl-fuzz:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2981f6fc6fe648e38aa58e8e417c3c2d93457ab6" translate="yes" xml:space="preserve">
          <source>No attempt has been made at mathematical rigor: words are employed with their intuitive meaning, without further definition. As a consequence, the typing rules have been left out, by lack of the mathematical framework required to express them, while they are definitely part of a full formal definition of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa02cb7a520e805604b436b26d2e3b0230ac3573" translate="yes" xml:space="preserve">
          <source>No child process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b716f8eaa691d689900e51bfb7cf3470f97f3d4" translate="yes" xml:space="preserve">
          <source>No coeffects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0b86ee8d4ae90b6347fb23a23aee01ef7d1ad2" translate="yes" xml:space="preserve">
          <source>No effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac84bf2f78b29d7fcdb0dbd9e9503065301a53a2" translate="yes" xml:space="preserve">
          <source>No locks available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7d314f83d9dd80d3f3a1d2cf49d2c2861bf468" translate="yes" xml:space="preserve">
          <source>No string in the result contains the &lt;code&gt;sep&lt;/code&gt; character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db516bd236f8b19cb9f7f134b81fc52a48b48cab" translate="yes" xml:space="preserve">
          <source>Non-Flambda versions of the compiler cannot inline functions that contain a definition of another function. However -Oclassic does permit this. Further, non-Flambda versions also cannot inline functions that are only themselves exposed as a result of a previous pass of inlining, but again this is permitted by -Oclassic. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7fec4c0093183b651e94da8602d12888a9798d" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c495fe7e42478c735910f07114d91295ddc81f" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication. Otherwise, return &lt;code&gt;None&lt;/code&gt; without blocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7955c5f7147285808f393b0a2f015ae8bfdf418" translate="yes" xml:space="preserve">
          <source>Non-generalized type variables in a type cause no difficulties inside a given structure or compilation unit (the contents of a .ml file, or an interactive session), but they cannot be allowed inside signatures nor in compiled interfaces (.cmi file), because they could be used inconsistently later. Therefore, the compiler flags an error when a structure or compilation unit defines a value name whose type contains non-generalized type variables. There are two ways to fix this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b76795e362f5a2898817253827ed1f46066a45" translate="yes" xml:space="preserve">
          <source>Non-principal type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552623d2d3482ef2ceb23ffcc0f0d612c140eb4c" translate="yes" xml:space="preserve">
          <source>Non-regular recursive algebraic data types correspond to polymorphic algebraic data types whose parameter types vary between the left and right side of the type definition. For instance, it might be interesting to define a datatype that ensures that all lists are nested at the same depth:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4722a32b4738403c181ac5e3a12ee6eb896bca7c" translate="yes" xml:space="preserve">
          <source>Non-returning statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187ac81e9effe553285ccadbb88b811d43fd0c04" translate="yes" xml:space="preserve">
          <source>Nonoptional label applied as optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7065271027eca5c68630d7333cfc9de2dd8678" translate="yes" xml:space="preserve">
          <source>Nonterminal symbols are like regular OCaml symbols, except that they cannot end with ' (single quote).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c779683d49742e5580a38345a8dbcc07ab2e152" translate="yes" xml:space="preserve">
          <source>Norm squared: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc420b7c8d61b9e4310ab8493f4d729522accc5" translate="yes" xml:space="preserve">
          <source>Norm: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d7530daae5b9c5977ddf4fbfb276d8be8264d" translate="yes" xml:space="preserve">
          <source>Normal number, none of the below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fb1748b422ce3ad94d8a06d8205b349c379068" translate="yes" xml:space="preserve">
          <source>Normally the compiler generates a type error if you attempt to pass to a function a parameter whose type is different from the expected one. However, in the specific case where the expected type is a non-labeled function type, and the argument is a function expecting optional parameters, the compiler will attempt to transform the argument to have it match the expected type, by passing None for all optional parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c792fa3c18a06a015ea04948e5b4604135e35115" translate="yes" xml:space="preserve">
          <source>Normally, the allocation rate is measured by counting the in-heap size of allocated blocks. However, it often happens that finalized objects contain pointers to out-of-heap memory blocks and other resources (such as file descriptors, X Windows bitmaps, etc.). For those blocks, the in-heap size of blocks is not a good measure of the quantity of resources allocated by the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff9300a83f8a35da371237256262716296f049b" translate="yes" xml:space="preserve">
          <source>Normally, the debugger takes checkpoints of the program state from time to time. That is, it makes a copy of the current state of the program (using the Unix system call fork). If the variable checkpoints is set to off, the debugger will not take any checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9faeba3fc7b5c9d7e01764096168b9e8e374411d" translate="yes" xml:space="preserve">
          <source>Not a number: result of an undefined operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ae112a2e8df4e520ecf91813337acb821264b" translate="yes" xml:space="preserve">
          <source>Not all functions are provided by all Unix variants. If some functions are not available, they will raise Invalid_arg when called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a251fde2cab1783fbc45a17d3491954f07532d2e" translate="yes" xml:space="preserve">
          <source>Not all header available in the caml/ directory were described in previous sections. All those unmentioned headers are part of the internal runtime API, for which there is &lt;em&gt;no&lt;/em&gt; stability guarantee. If you really need access to this internal runtime API, this section provides some guidelines that may help you to write code that might not break on every new version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9199f21841e17aae508bebd4889b3a7dc1d36c6" translate="yes" xml:space="preserve">
          <source>Not an executable file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facd4c2d5bdce52a545593e87469a809ac0e1231" translate="yes" xml:space="preserve">
          <source>Not enough memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf34be1f750ab01dd0f009456dd21934f44155fb" translate="yes" xml:space="preserve">
          <source>Not for the casual user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4152727c8d99325fa09c8beae5e73e4b8bd46f0c" translate="yes" xml:space="preserve">
          <source>Not the normal way of pretty-printing, since imperative line splitting may interfere with current line counters and box size calculation. Using break hints within an enclosing vertical box is a better alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a819c9b54780bf0db302a106d8d765a494007de9" translate="yes" xml:space="preserve">
          <source>Note as well that parent directories in the given path will not be created when opening the trace. The runtime assumes the path is accessible for creating and writing the trace. The program will fail to start if this requirement isn&amp;rsquo;t met.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037c57d3261561d20c1db3424456e04def230f71" translate="yes" xml:space="preserve">
          <source>Note here the (self : int #iterator) idiom, which ensures that this object implements the interface iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ce8074b0d7cbaefabb1e3d3e4d3c74808df3a8" translate="yes" xml:space="preserve">
          <source>Note here the special syntax (#point0 as 'a) we have to use to quantify the extensible part of #point0. As for the variable binder, it can be omitted in class specifications. If you want polymorphism inside object field it must be quantified independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab69a65854dd6fec6962d0e2d5e4784cf692204e" translate="yes" xml:space="preserve">
          <source>Note in particular that -inline does not have the meaning that it has in the previous compiler or in -Oclassic mode. In both of those situations -inline was effectively some kind of basic assessment of inlining benefit. However in Flambda inlining mode it corresponds to a constraint on the search; the assessment of benefit is independent, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e7c8c1273c2167af15e26d1e579c38f8f99528" translate="yes" xml:space="preserve">
          <source>Note on polymorphic variant tags: the current implementation accepts lowercase variant tags in addition to capitalized variant tags, but we suggest you avoid lowercase variant tags for portability and compatibility with future OCaml versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abc6d55c7e6502cb76253097a56d727be818505" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynlink#VALloadfile&quot;&gt;&lt;code&gt;Dynlink.loadfile&lt;/code&gt;&lt;/a&gt; changes the allowed-units list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d26a6dbdf7cb76c9e11d80524e91dc7d0ef610" translate="yes" xml:space="preserve">
          <source>Note that entering open Mod merely accesses the compiled interface (.cmi file) for Mod, but does not load the implementation of Mod, and does not cause any error if no implementation of Mod has been loaded. The error &amp;ldquo;reference to undefined global Mod&amp;rdquo; will occur only when executing a value or module definition that refers to Mod.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2165fbecefe21675865f5a8f169aa75121b7dd25" translate="yes" xml:space="preserve">
          <source>Note that for clarity&amp;rsquo;s sake, the method print is explicitly marked as overriding another definition by annotating the method keyword with an exclamation mark !. If the method print were not overriding the print method of printable_point, the compiler would raise an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f7f9990a4c81187469986363cda35568351830" translate="yes" xml:space="preserve">
          <source>Note that if no arguments follow a &lt;code&gt;Rest&lt;/code&gt; keyword then the function is not called at all whereas the function for a &lt;code&gt;Rest_all&lt;/code&gt; keyword is called with an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8b0cd07d8b3eb1cb5c73f85a9b93dce5e210f3" translate="yes" xml:space="preserve">
          <source>Note that in this case you should not compute dependencies for mylib.mli together with the other files, hence the need to pass explicitly the list of files to process. If mylib.mli itself has dependencies, you should compute them using -as-map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63274ceec059ea43f06cf7d5143c9d0f279449fe" translate="yes" xml:space="preserve">
          <source>Note that it would be unsafe if &lt;code&gt;s&lt;/code&gt; was passed as an additional parameter to the function &lt;code&gt;f&lt;/code&gt; as it could escape this way and be mutated in the future -- &lt;code&gt;string_init&lt;/code&gt; would give up ownership of &lt;code&gt;s&lt;/code&gt; to pass it to &lt;code&gt;f&lt;/code&gt;, and could not call &lt;code&gt;unsafe_to_string&lt;/code&gt; safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4753a1c807609006c1cb1222f68e354a9ec0d33" translate="yes" xml:space="preserve">
          <source>Note that label comments take precedence over item comments, so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919535701ff97d2e364548f37fa537e17d9cc03" translate="yes" xml:space="preserve">
          <source>Note that lazy_two has type int lazy_t. However, the type 'a lazy_t is an internal type name, so the type 'a Lazy.t should be preferred when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbd6ed5e065f79a1664cc5e3d9e396319783be3" translate="yes" xml:space="preserve">
          <source>Note that line splitting policy is box specific: the policy of a box does not rule the policy of inner boxes. For instance, if a vertical box is nested in an horizontal box, all break hints within the vertical box will split the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce52db53f4883581f49385acd3aa04301c1b07b" translate="yes" xml:space="preserve">
          <source>Note that no information is propagated about the contents of strings, even in safe-string mode, because it cannot yet be guaranteed that they are immutable throughout a given program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecfaba3e31b928fe62c543cf4b58b08adf9f38d" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078cdfb36f419462d48005d3185623168e74775b" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;morelabels.hashtbl#VALcreate&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3eb4400a3041e1bc0872d4c6fadfee7b45a0533" translate="yes" xml:space="preserve">
          <source>Note that only top-level structures can be mapped to separately-compiled files, but neither functors nor module types. However, all module-class objects can appear as components of a structure, so the solution is to put the functor or module type inside a structure, which can then be mapped to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d50cbdd93bc0057831e01783483dc11563f7c4" translate="yes" xml:space="preserve">
          <source>Note that since immediate objects do not define a class type, they have no such restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd433ffb5b0bba6a711c0ea5bb3b1c7a88c90b0" translate="yes" xml:space="preserve">
          <source>Note that the callback can be postponed slightly after the actual event. The callstack passed to the callback is always accurate, but the program state may have evolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ef9b9d1aff860780f332e0b33c8e88450455d7" translate="yes" xml:space="preserve">
          <source>Note that the coercion (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) is actually an abbreviated form, and will only work in presence of private abbreviations if neither the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; nor &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; contain any type variables. If they do, you must use the full form (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) where &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is the expected type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Concretely, this would be (x : N.t :&amp;gt; int) and (l : N.t list :&amp;gt; int list) for the above examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50817e39131d67a96275cac53949dd6c7173b3db" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the Camlp4 extensions and should be avoided for compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a3babe539fe240e495a53999452fd839e7e6f6" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the now unmaintained Camlp4 system and should be avoided for backwards compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6f602690ce2c063c471eee010ebbe59f6bbddc" translate="yes" xml:space="preserve">
          <source>Note that the instrumented runtime is an alternative runtime for OCaml programs. It is only referenced during the linking stage of the final executable. This means that the compilation stage does not need to be altered to enable instrumentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5971f9da22f0faace6bfec873b81d408ac540d78" translate="yes" xml:space="preserve">
          <source>Note that the new type &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; is not compatible with the type &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; of the generic interface. For example, &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; would not type-check, you must use &lt;code&gt;IntHashtbl.length&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01438030239e56aa11911507a85c74b4e412af5" translate="yes" xml:space="preserve">
          <source>Note that the relationship between object, class and type in OCaml is different than in mainstream object-oriented languages such as Java and C++, so you shouldn&amp;rsquo;t assume that similar keywords mean the same thing. Object-oriented features are used much less frequently in OCaml than in those languages. OCaml has alternatives that are often more appropriate, such as modules and functors. Indeed, many OCaml programs do not use objects at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7b8526d94d8c27ed35f7c7cec40a0edae7df3f" translate="yes" xml:space="preserve">
          <source>Note that the two types AbstractStringSet.set and NoCaseStringSet.set are not compatible, and values of these two types do not match. This is the correct behavior: even though both set types contain elements of the same type (strings), they are built upon different orderings of that type, and different invariants need to be maintained by the operations (being strictly increasing for the standard ordering and for the case-insensitive ordering). Applying operations from AbstractStringSet to values of type NoCaseStringSet.set could give incorrect results, or build lists that violate the invariants of NoCaseStringSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e9f41fd86b1c950c9ef81d22b068692eccf75f" translate="yes" xml:space="preserve">
          <source>Note that the type constructor regular_nested always appears as 'a regular_nested in the definition above, with the same parameter 'a. Equipped with this type, one can compute a maximal depth with a classic recursive function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f894cfb3f87405bfa359dfc278dfe88f62a0e6bb" translate="yes" xml:space="preserve">
          <source>Note that the type money is not a subtype of type comparable, as the self type appears in contravariant position in the type of method leq. Indeed, an object m of class money has a method leq that expects an argument of type money since it accesses its value method. Considering m of type comparable would allow a call to method leq on m with an argument that does not have a method value, which would be an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b3888a7e3a6dd69b6635ff1d23f6223d9986c2" translate="yes" xml:space="preserve">
          <source>Note that the type of p is point. This is an abbreviation automatically defined by the class definition above. It stands for the object type &amp;lt;get_x : int; move : int -&amp;gt; unit&amp;gt;, listing the methods of class point along with their types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b9f6fff51ab2e45034f690441bdecd68df53d9" translate="yes" xml:space="preserve">
          <source>Note that the word-delimited form, for example {sql|...|sql}, should not be used for signaling that an extension is in use. Indeed, the user cannot see from the code whether this string literal has different semantics than they expect. Moreover, giving semantics to a specific delimiter limits the freedom to change the delimiter to avoid escaping issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5daea91835e86ffb05aea9cef4296c3068906517" translate="yes" xml:space="preserve">
          <source>Note that this construction is only useful if the exception is raised between match&amp;hellip;with. Exception patterns can be combined with ordinary patterns at the toplevel,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ffac9391573364c371a7957c46dea2fc876529" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &amp;zwj;&lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c35684e12f57c72020fa856c51c0081aec8613e" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5301e9ce9eaee70b52bc0e30c461f8dc4f50979b" translate="yes" xml:space="preserve">
          <source>Note that this syntax is not valid within OCaml: average has an universally quantified type 'a inside the type of one of its argument whereas for polymorphic recursion the universally quantified type was introduced before the rest of the type. This position of the universally quantified type means that average is a second-rank polymorphic function. This kind of higher-rank functions is not directly supported by OCaml: type inference for second-rank polymorphic function and beyond is undecidable; therefore using this kind of higher-rank functions requires to handle manually these universally quantified types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0537a61ab3006dae26fac6b5f19a889d7c194bae" translate="yes" xml:space="preserve">
          <source>Note that this will only affect the prefix of the trace file, there is no option to specify the full effective file name. This restriction is in place to make room for future improvements to the instrumented runtime, where the single trace file per session design may be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53f78797414436c28938372fd25e7a220604184" translate="yes" xml:space="preserve">
          <source>Note that we can rewrite the type of f and f' as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9855ac639cc02bb505afbab05f1ffccd97cf7fa0" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fn&lt;/code&gt; is called all the functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; have already been called. Because of this you must make sure any output channel &lt;code&gt;fn&lt;/code&gt; writes on is flushed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5902b468c9420c576a1090e7ba4580b19535ba05" translate="yes" xml:space="preserve">
          <source>Note that when you don&amp;rsquo;t need an argument, you can still use a wildcard pattern, but you must prefix it with the label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42951dc6e5e061dd8581c9cd3e18ab7ff1122703" translate="yes" xml:space="preserve">
          <source>Note that you can also remove manifest types, by substituting with the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d24bd50ee40c13de42decb018fafac2cc30412b" translate="yes" xml:space="preserve">
          <source>Note that, if a comment appears immediately next to multiple items, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579e1ef453daed542dee9b6448ed260939315131" translate="yes" xml:space="preserve">
          <source>Note that, in the &lt;a href=&quot;modtypes#specification&quot;&gt;specification&lt;/a&gt; case, the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;s must be parenthesized if they use the with&lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecccd058b8859c03de2fd449f57787fc6750b3c" translate="yes" xml:space="preserve">
          <source>Note that, unlike type declarations, type substitution declarations are not recursive, so substitutions like the following are rejected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d71401130598be60ae748ad0081c1eff34da4af" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &amp;zwj;&lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d522de17989d9555a8bbce2b8df8ef04eb9f91" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c5273bc385a2bc73dec61088cee3a19dd057d4" translate="yes" xml:space="preserve">
          <source>Note the use of double underscores in Mylib__A and Mylib__B. These were chosen on purpose; the compiler uses the following heuristic when printing paths: given a path Lib__fooBar, if Lib.FooBar exists and is an alias for Lib__fooBar, then the compiler will always display Lib.FooBar instead of Lib__fooBar. This way the long Mylib__ names stay hidden and all the user sees is the nicer dot names. This is how the OCaml standard library is compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1d07e0d8f7923bb8cef98de8decf201a2336ee" translate="yes" xml:space="preserve">
          <source>Note the use of override for method times. Writing new money2 (k *. repr) instead of {&amp;lt; repr = k *. repr &amp;gt;} would not behave well with inheritance: in a subclass money3 of money2 the times method would return an object of class money2 but not of class money3 as would be expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="a7c6195c71846fafbab4e4cc00dfd41c54465d1b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Lazy.force&lt;/code&gt; is not thread-safe. If you use this module in a multi-threaded program, you will need to add some locks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee1f0993f734f3d32255902fa4253dbe8464720" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;lazy_t&lt;/code&gt; is the built-in type constructor used by the compiler for the &lt;code&gt;lazy&lt;/code&gt; keyword. You should not use it directly. Always use &lt;code&gt;Lazy.t&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65beeb77bdc7dc7ee42cc9da173d89eac9e501e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;open_in&lt;/code&gt; returns a formatted input channel that efficiently reads characters in large chunks; in contrast, &lt;code&gt;from_channel&lt;/code&gt; below returns formatted input channels that must read one character at a time, leading to a much slower scanning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb80132052a566980a3f39541caf9bc002b1c90" translate="yes" xml:space="preserve">
          <source>Note: Existing command line options can be redefined using this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f6141fe67a802e7e2bf4927ccb64d0289512ae" translate="yes" xml:space="preserve">
          <source>Note: For maximum backwards compatibility in Unicode mode, if the argument is not a valid UTF-8 string, this function will fall back to assuming that it is encoded in the current code page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae74bcb6937d84acfff2f5cc371f0df0a9df245" translate="yes" xml:space="preserve">
          <source>Note: If lazy patterns appear in multiple cases in a pattern-matching, lazy expressions may be forced even outside of the case ultimately selected by the pattern matching. In the example above, the suspension &lt;code&gt;x&lt;/code&gt; is always computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7d69b5a35fb8fdd2ec3a14decb5554cdfa109f" translate="yes" xml:space="preserve">
          <source>Note: Including the header files without first defining CAML_NAME_SPACE introduces in scope short names for most functions. Those short names are deprecated, and may be removed in the future because they usually produce clashes with names defined by other C libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51519ebae7f9975b891bddfc046ca788658aed4d" translate="yes" xml:space="preserve">
          <source>Note: It is a &lt;em&gt;programming error&lt;/em&gt; if other kinds of exceptions are raised by &lt;code&gt;finally&lt;/code&gt;, as any exception raised in &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; will be lost in the event of a &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt;&lt;code&gt;Fun.Finally_raised&lt;/code&gt;&lt;/a&gt; exception. Therefore, one should make sure to handle those inside the finally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bedbf1279049e8ebd79ce828d1966e381406da84" translate="yes" xml:space="preserve">
          <source>Note: OCaml strings used to be modifiable in place, for instance via the &lt;a href=&quot;string#VALset&quot;&gt;&lt;code&gt;String.set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALblit&quot;&gt;&lt;code&gt;String.blit&lt;/code&gt;&lt;/a&gt; functions described below. This usage is only possible when the compiler is put in &quot;unsafe-string&quot; mode by giving the &lt;code&gt;-unsafe-string&lt;/code&gt; command-line option. This compatibility mode makes the types &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; (see module &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;) interchangeable so that functions expecting byte sequences can also accept strings as arguments and modify them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72b40ee4e5477e5f7d6e7553ca34de54319049d" translate="yes" xml:space="preserve">
          <source>Note: On some systems, with interactive input, an end-of-file may be followed by more characters. However, ocamllex will not correctly handle regular expressions that contain eof followed by something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01558340b88b057d42608e1a6ec3ca0cfdf079a7" translate="yes" xml:space="preserve">
          <source>Note: The strings returned by caml_stat_strdup_to_os and caml_stat_strdup_of_os are allocated using caml_stat_alloc, so they need to be deallocated using caml_stat_free when they are no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7848f4c2eb8f564919b210b8bbfed2cdf5ec566d" translate="yes" xml:space="preserve">
          <source>Note: This example is on a Unix system. The exact command lines may be different on other systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84be470836b2d22c5aa15438ce95fd6f0d863631" translate="yes" xml:space="preserve">
          <source>Note: This is an experimental feature of OCaml: the set of APIs below, as well as their exact semantics are not final and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823ecd73e96dee992922fa24d09d174fea0a6e57" translate="yes" xml:space="preserve">
          <source>Note: To prevent the interpretation of a &lt;code&gt;@&lt;/code&gt; character as a pretty-printing indication, escape it with a &lt;code&gt;%&lt;/code&gt; character. Old quotation mode &lt;code&gt;@@&lt;/code&gt; is deprecated since it is not compatible with formatted input interpretation of character &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9bd6a881cbdf7f9df1e298990c77110c41a774" translate="yes" xml:space="preserve">
          <source>Note: When changing to a low-fragmentation policy, you may need to augment the &lt;code&gt;space_overhead&lt;/code&gt; setting, for example using &lt;code&gt;100&lt;/code&gt; instead of the default &lt;code&gt;80&lt;/code&gt; which is tuned for next-fit. Indeed, the difference in fragmentation behavior means that different policies will have different proportion of &quot;wasted space&quot; for a given program. Less fragmentation means a smaller heap so, for the same amount of wasted space, a higher proportion of wasted space. This makes the GC work harder, unless you relax it by increasing &lt;code&gt;space_overhead&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c53f545ae2f49916857c5dbc74afbbb3f17b01" translate="yes" xml:space="preserve">
          <source>Note: a scanning action may often require to examine one character in advance; when this 'lookahead' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character yet to be read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1704bf03b020589de313c230890a2e46b48b94e8" translate="yes" xml:space="preserve">
          <source>Note: all directives start with a # (sharp) symbol. This # must be typed before the directive, and must not be confused with the # prompt displayed by the interactive loop. For instance, typing #quit;; will exit the toplevel loop, but typing quit;; will result in an &amp;ldquo;unbound value quit&amp;rdquo; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661bb9a4a4fadd61ccae3d7f4cea4d69fb6a3c2a" translate="yes" xml:space="preserve">
          <source>Note: all input/output functions can raise &lt;code&gt;Sys_error&lt;/code&gt; when the system calls they invoke fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f409c4273c4016899888e40b1686a702c39d6ff" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unix#VALerror_message&quot;&gt;&lt;code&gt;Unix.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt;&lt;code&gt;Unix.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;Unix.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79908ccb7a82d0caccd2893700ccad147b944a43" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unixlabels#VALerror_message&quot;&gt;&lt;code&gt;UnixLabels.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALhandle_unix_error&quot;&gt;&lt;code&gt;UnixLabels.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unixlabels#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;UnixLabels.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9881244812e43ce519dbdb2a33d7a86a78dc2b73" translate="yes" xml:space="preserve">
          <source>Note: changing the allocation policy at run-time forces a heap compaction, which is a lengthy operation unless the heap is small (e.g. at the start of the program).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e740cc9128b3de503776a812fd3bb3f85d80f59" translate="yes" xml:space="preserve">
          <source>Note: do not use the C int type in correspondence with (int [@untagged]). This is because they often differ in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f28c1f397eec585fd0b2e1caaaf11772a9b784" translate="yes" xml:space="preserve">
          <source>Note: if the program is compiled with the &lt;code&gt;-rectypes&lt;/code&gt; option, ill-founded recursive definitions of the form &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; or &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the &lt;code&gt;-rectypes&lt;/code&gt; option, such ill-founded recursive definitions are rejected by the type-checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebef76f46f02ed8c6dbb4a7a51649415bd9b78c4" translate="yes" xml:space="preserve">
          <source>Note: in order to insure that the dynamically-loaded modules have access to all the libraries that are visible to the main program (and not just to the parts of those libraries that are actually used in the main program), programs using the dynlink library should be linked with -linkall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ff267a2f14d6dd07cded0766c39d2aeb6bc63e" translate="yes" xml:space="preserve">
          <source>Note: in the case of &lt;code&gt;global_substitute&lt;/code&gt; and &lt;code&gt;substitute_first&lt;/code&gt;, a call to &lt;code&gt;matched_string&lt;/code&gt; is only valid within the &lt;code&gt;subst&lt;/code&gt; argument, not after &lt;code&gt;global_substitute&lt;/code&gt; or &lt;code&gt;substitute_first&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922b543ff896ef77cd9d8044969360c9a53c3cbf" translate="yes" xml:space="preserve">
          <source>Note: in the interactive system, when input is read from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, the newline character that triggers evaluation is part of the input; thus, the scanning specifications must properly skip this additional newline character (for instance, simply add a &lt;code&gt;'\n'&lt;/code&gt; as the last character of the format string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145e7cd4d750ab522e65fe8e15a2f8018a1e2e0d" translate="yes" xml:space="preserve">
          <source>Note: installation of signal handlers is performed via the functions &lt;a href=&quot;sys#VALsignal&quot;&gt;&lt;code&gt;Sys.signal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#VALset_signal&quot;&gt;&lt;code&gt;Sys.set_signal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629c5048579fb0ed4f8a77f6a5cbc67a5d0b3404" translate="yes" xml:space="preserve">
          <source>Note: it is not recommended to use warning sets (i.e. letters) as arguments to -warn-error in production code, because this can break your build when future versions of OCaml add some new warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443e1ada797e5067adc60f24f10b243b6714e1e3" translate="yes" xml:space="preserve">
          <source>Note: never use &lt;code&gt;print_flush&lt;/code&gt; in the normal course of a pretty-printing routine, since the pretty-printer uses a complex buffering machinery to properly indent the output; manually flushing those buffers at random would conflict with the pretty-printer strategy and result to poor rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9341c4536efd6e856d0cfcbf40db0f74c45c131a" translate="yes" xml:space="preserve">
          <source>Note: printing within tabulation box is line directed, so arbitrary line splitting inside a tabulation box leads to poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns within module &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aac78a82348d2aa75442bb5d55e79ba31ac133" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;cmp&lt;/code&gt; function will be called even if the lists have different lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebffc51f9fb16239843be4e6722cccd39a9129f" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;eq&lt;/code&gt; function may be called even if the lists have different length. If you know your equality function is costly, you may want to check &lt;a href=&quot;list#VALcompare_lengths&quot;&gt;&lt;code&gt;List.compare_lengths&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517276021ef1d214b7e49458c6978d5ac4a8067f" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;eq&lt;/code&gt; function may be called even if the lists have different length. If you know your equality function is costly, you may want to check &lt;a href=&quot;listlabels#VALcompare_lengths&quot;&gt;&lt;code&gt;ListLabels.compare_lengths&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9834335cf6fe5fc53b95c18382af756506e19d5" translate="yes" xml:space="preserve">
          <source>Note: the acquire and release functions described above were introduced in OCaml 3.12. Older code uses the following historical names, declared in &amp;lt;caml/signals.h&amp;gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2177e9bf34eb19b28eb32c96470882b643de2040" translate="yes" xml:space="preserve">
          <source>Note: the argument to &lt;code&gt;regexp&lt;/code&gt; is usually a string literal. In this case, any backslash character in the regular expression must be doubled to make it past the OCaml string parser. For example, the following expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd47f5e6d4b6f57e31724916a1771922f810447" translate="yes" xml:space="preserve">
          <source>Note: the finalize, compare, hash, serialize and deserialize functions attached to custom block descriptors must never trigger a garbage collection. Within these functions, do not call any of the OCaml allocation functions, and do not perform a callback into OCaml code. Do not use CAMLparam to register the parameters to these functions, and do not use CAMLreturn to return the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa124181f0ab52f95d5aba93b0fc5a2ffbf20f4" translate="yes" xml:space="preserve">
          <source>Note: the notions of space and line splitting are abstract for the pretty-printing engine, since those notions can be completely redefined by the programmer. However, in the pretty-printer default setting, ``output a space'' simply means printing a space character (ASCII code 32) and ``split the line'' means printing a newline character (ASCII code 10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8057d5d098672ea84c975196f3af91fed42a2aa5" translate="yes" xml:space="preserve">
          <source>Note: the operators &amp;amp;&amp;amp;, ||, and ~- are handled specially and it is not advisable to change their meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efcff7406c86de78d66a3b54bdcef50f38f8039" translate="yes" xml:space="preserve">
          <source>Note: this API is EXPERIMENTAL. It may change without prior notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6965dbae3f43f8571341ee41d021ab34917b0487" translate="yes" xml:space="preserve">
          <source>Note: this is not the normal way to output a new line; the preferred method is using break hints within a vertical pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ebc2b8878898c4c60d71b3c20e680a573cda23" translate="yes" xml:space="preserve">
          <source>Note: this only applies to the native compiler. So whenever you use any of these methods, you have to provide an alternative byte-code stub that ignores all the special annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c9f2b925633b8f6e73b9bf63c5cdc7777edeca" translate="yes" xml:space="preserve">
          <source>Note: this possibility is offered only for backward compatibility with older versions of OCaml and will be removed in a future version. New code should use byte sequences and the Bytes.set function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8d829c25ab6089d7e4980f899718094fb71afc" translate="yes" xml:space="preserve">
          <source>Note: when a label declaration is followed by a semi-colon, attributes can also be put after the semi-colon (in which case they are merged to those specified before).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="d5e45a48a978d6899712bd076f72479aeea810fa" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;d&lt;/code&gt; is smaller than 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fb7c03e6cb136de7fbdb71a619368064c85b64" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;max&lt;/code&gt; is smaller than 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa95920bb8194bd4a2ebe309a76e0b3b76edccd" translate="yes" xml:space="preserve">
          <source>Notice that in the vec case, we are calling the single index operator, (.%{}), and not the multi-index variant, (.{;..}). For this reason, it is expected that most users of multi-index operators will need to define conjointly a single index variant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc088a60c877ce62f962886fe65bf44f1be80800" translate="yes" xml:space="preserve">
          <source>Notice that it is not possible to pass options to ocamlrun when invoking a.out directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74aaf1392791cdacd5b251b350a4fa759d0daf50" translate="yes" xml:space="preserve">
          <source>Notice that our function call above prints &amp;ldquo;lazy_two evaluation&amp;rdquo; and then returns the plain value of the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c42130e4cbfad9b1ab31f04d64c0912792bf5e1" translate="yes" xml:space="preserve">
          <source>Notice that the bytecode libraries unix.cma and threads.cma must be given twice: when building the runtime system (so that ocamlc knows which C primitives are required) and also when building the bytecode executable (so that the bytecode from unix.cma and threads.cma is actually linked in).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0646640caf022897bba768e601eae5583de16c" translate="yes" xml:space="preserve">
          <source>Now for a real symbolic processing, we define the derivative of an expression with respect to a variable dv:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31c772d9b3d93fe10a1d16923ec1381b4e0e40a" translate="yes" xml:space="preserve">
          <source>Now if we annotate the arguments and result with [@unboxed], the native-code compiler will be able to avoid all these allocations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9da36ea65d19919b99ea34d11ca3b1c7c4a4a7" translate="yes" xml:space="preserve">
          <source>Now if we look at the value of lazy_two, we see that it is not displayed as &amp;lt;lazy&amp;gt; anymore but as lazy 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70cad05eff4f060c1122a9df879ce632eabd808" translate="yes" xml:space="preserve">
          <source>Now, here is a sample OCaml program prog.ml that uses the curses module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1a9455d741ea437460b8735fa1fd8568d51cbd" translate="yes" xml:space="preserve">
          <source>Now, we can use the two functions fib and format_result in any C program, just like regular C functions. Just remember to call caml_startup (or caml_startup_exn) once before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3138d7df51fb63c0581ea81498fd68c3e05c37c6" translate="yes" xml:space="preserve">
          <source>Number is 0.0 or -0.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599fcc81bb79a4df28a99bc27dc454bdb406e359" translate="yes" xml:space="preserve">
          <source>Number is positive or negative infinity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6a12894e1886f16551dce8aa6a476046e0e378" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;hashtbl#VALlength&quot;&gt;&lt;code&gt;Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3019c43254ba4df6dd4a5febe0a3c1e3603da20" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;morelabels.hashtbl#VALlength&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c993eaebae88d7a870c6aedb7b2959b80e3c4ac" translate="yes" xml:space="preserve">
          <source>Number of bits per character (5-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556c7d37711ec6f2f70fe3dcea838b8ca1371010" translate="yes" xml:space="preserve">
          <source>Number of blocks in the free list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30e61fc6036da5db3f139d2340ea9277079b7a3" translate="yes" xml:space="preserve">
          <source>Number of buckets in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd43d1f40b17a39ffbd688d74199162e00feb899" translate="yes" xml:space="preserve">
          <source>Number of contiguous pieces of memory that make up the major heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ee259bd3c41fa404a37a53bd7edb78724bd92e" translate="yes" xml:space="preserve">
          <source>Number of forced full major collections completed since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bfd01520799f6fb0b893646db43e4eff4024a4" translate="yes" xml:space="preserve">
          <source>Number of heap compactions since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3275a16ef5f550e3a9777e377a1e501bfdab390" translate="yes" xml:space="preserve">
          <source>Number of links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1a2280ac441cab2cdb5c0495373425c8df6602" translate="yes" xml:space="preserve">
          <source>Number of live blocks in the major heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f456114fcb5877ccbceb91eb404b219b9ce44ade" translate="yes" xml:space="preserve">
          <source>Number of major collection cycles completed since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9386df61202e08b36cb678baacc9b23f2a02d67b" translate="yes" xml:space="preserve">
          <source>Number of minor collections since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809a46ad96dee431d9a0e29595d29eae99894471" translate="yes" xml:space="preserve">
          <source>Number of stop bits (1-2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d3ddb5d0c96281ae43ec9c22a0b4e3422e79bf" translate="yes" xml:space="preserve">
          <source>Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce81b5c3bd146557576eb8ed07acd1dffea0dab3" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the major heap, including the promoted words, since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ca08671f1b43ba25ac654a59ea877d2a2b67a5" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2252886aac21fa9ff4a9c573d75468a53aea2f8b" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7984519fd15afeac8c64ab5080cc953cb9c00a2" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f31dc5c12c1a7f06ec7bd177c5b77d43639c8d" translate="yes" xml:space="preserve">
          <source>Number of words in the free list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89158a98cc97e9ec991a351e0adf4b876875a73a" translate="yes" xml:space="preserve">
          <source>Number of words of live data in the major heap, including the header words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4497ca18a980559e81799d511efa2fbf2cfc2a06" translate="yes" xml:space="preserve">
          <source>Number very close to 0.0, has reduced precision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="7a33aed24260554ed4044e957096dba2b5814942" translate="yes" xml:space="preserve">
          <source>OCAMLLIB</source>
          <target state="translated">OCAMLLIB</target>
        </trans-unit>
        <trans-unit id="18f162a99ff8d53ff64a6b4e151cb31d5e551861" translate="yes" xml:space="preserve">
          <source>OCAMLPARAM (environment variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63bde53850374ed2ceaca560296ca5ae4288cfc9" translate="yes" xml:space="preserve">
          <source>OCAMLRUNPARAM</source>
          <target state="translated">OCAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="5a645a796dc3a615a92ec7a9d69a83018587cfd3" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_INCLUDE_PATH</source>
          <target state="translated">OCAMLTOP_INCLUDE_PATH</target>
        </trans-unit>
        <trans-unit id="8d2f44eaaa8da1e94f7c788d8bdd29ded4da06e4" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_UTF_8</source>
          <target state="translated">OCAMLTOP_UTF_8</target>
        </trans-unit>
        <trans-unit id="ad1263844890ea6d4fa757c36f64dd4aa02ae452" translate="yes" xml:space="preserve">
          <source>OCAML_EVENTLOG_ENABLED can be set to the p flag in order to start the program with event collection paused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5452f25317c588b2d021a1ead667fb17370d1d55" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK</source>
          <target state="translated">OCAML_FLEXLINK</target>
        </trans-unit>
        <trans-unit id="180089a275079837ea5e6f4afd0b87d27e4469c6" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK (environment variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdddb7074ce2b9a9f470e52afd10a9b95816171" translate="yes" xml:space="preserve">
          <source>OCaml allows us to defer some computation until later when we need the result of that computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40aa7560087d20b8f8199f53d34735d850d308b1" translate="yes" xml:space="preserve">
          <source>OCaml code executing in the traditional toplevel system uses the bytecode interpreter. When increased performance is required, or for testing programs that will only execute correctly when compiled to native code, the &lt;em&gt;native toplevel&lt;/em&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267c01d6c4260bac5e8f28a01de2593eca32db2c" translate="yes" xml:space="preserve">
          <source>OCaml has no built-in notion of variable &amp;ndash; identifiers whose current value can be changed by assignment. (The let binding is not an assignment, it introduces a new identifier with a new scope.) However, the standard library provides references, which are mutable indirection cells, with operators ! to fetch the current contents of the reference and := to assign the contents. Variables can then be emulated by let-binding a reference. For instance, here is an in-place insertion sort over arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb3adc8841417401cbe5cbf1dccabafc62d9c42" translate="yes" xml:space="preserve">
          <source>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt;&lt;code&gt;Bigarray.int_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a9ccb34887b4bee6ea9726429d33718de72371" translate="yes" xml:space="preserve">
          <source>OCaml is a functional language: functions in the full mathematical sense are supported and can be passed around freely just as any other piece of data. For instance, here is a deriv function that takes any float function as argument and returns an approximation of its derivative function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef8c1d2377beafebd9185056587e4432d10a17d" translate="yes" xml:space="preserve">
          <source>OCaml provides exceptions for signalling and handling exceptional conditions. Exceptions can also be used as a general-purpose non-local control structure, although this should not be overused since it can make the code harder to understand. Exceptions are declared with the exception construct, and signalled with the raise operator. For instance, the function below for taking the head of a list uses an exception to signal the case where an empty list is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb9dff10bdb65bfb239e824ad6d8af0b7cc9004" translate="yes" xml:space="preserve">
          <source>OCaml runs on several operating systems. The parts of this manual that are specific to one operating system are presented as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1726ed3129ec43182a952dcd0e32f27c1495a2bf" translate="yes" xml:space="preserve">
          <source>OCaml source files and object files (.cmo, .cmx, .ml) comprising the OCaml part of the library;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b33a87ea85672b2f3dc3cc175ebdefe40c9d34" translate="yes" xml:space="preserve">
          <source>OCaml supports the assert construct to check debugging assertions. The expression assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns () if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to true. If it evaluates to false the exception Assert_failure is raised with the source file name and the location of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as arguments. Assertion checking can be turned off with the -noassert compiler option. In this case, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c85e2232603a9909d0b7ff1b3926fe7e6d893e4" translate="yes" xml:space="preserve">
          <source>OCaml type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d72b1edf8e07e587e3d50ac25c27ae51c1a8cd" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, and any arithmetic operation with &lt;code&gt;nan&lt;/code&gt; as argument returns &lt;code&gt;nan&lt;/code&gt; as result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5200ab6029faacafa8905f9af598bec7c22a9ce3" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, basic arithmetic operations (&lt;code&gt;+.&lt;/code&gt;, &lt;code&gt;-.&lt;/code&gt;, &lt;code&gt;*.&lt;/code&gt;, &lt;code&gt;/.&lt;/code&gt;) with &lt;code&gt;nan&lt;/code&gt; as an argument return &lt;code&gt;nan&lt;/code&gt;, ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9ec7fcee833e36e4b14ae69e1e560823d2194a" translate="yes" xml:space="preserve">
          <source>OCamldoc calls the OCaml type-checker to obtain type information. The following options impact the type-checking phase. They have the same meaning as for the ocamlc and ocamlopt commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fd7b104be92b2bbccb12043665773616dd39a8" translate="yes" xml:space="preserve">
          <source>OCamldoc can associate comments to some elements of the language encountered in the source files. The association is made according to the locations of comments with respect to the language elements. The locations of comments in .mli and .ml files are different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b300cd09621c9734759f5eb8f185eb95b76cf98e" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;15.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faec01ad8468873527336baad11c51145d082115" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97a33abb490cfa006083e0758a66c65ccefd2d" translate="yes" xml:space="preserve">
          <source>OCamldoc is invoked via the command ocamldoc, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9e742b8c79265cdf1d7a881feb63c658daf697" translate="yes" xml:space="preserve">
          <source>OCamldoc operates in two steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d31081ef8855113f2a0517703c8269e167e955" translate="yes" xml:space="preserve">
          <source>OPAM switches will be provided for Spacetime-configured compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb8f90af03d5b6035972034e7db2381c61fb84c" translate="yes" xml:space="preserve">
          <source>Obj</source>
          <target state="translated">Obj</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="7a7417369b52b8eb7878a369c0569d594dbf4af1" translate="yes" xml:space="preserve">
          <source>Objects are composed of a hidden internal state which is a record of instance variables, and a set of methods for accessing and modifying these variables. The structure of an object is described by the toplevel class that created it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d201edcc8c7a34735ba42eb0dde4de7ae96dbd1" translate="yes" xml:space="preserve">
          <source>Objects are represented as blocks with tag Object_tag. The first field of the block refers to the object&amp;rsquo;s class and associated method suite, in a format that cannot easily be exploited from C. The second field contains a unique object ID, used for comparisons. The remaining fields of the object contain the values of the instance variables of the object. It is unsafe to access directly instance variables, as the type system provides no guarantee about the instance variables contained by an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4792dc04542c4957b7299aef2bdc36a1978fd6e" translate="yes" xml:space="preserve">
          <source>Objects can also be cloned, whether they are functional or imperative. The library function Oo.copy makes a shallow copy of an object. That is, it returns a new object that has the same methods and instance variables as its argument. The instance variables are copied but their contents are shared. Assigning a new value to an instance variable of the copy (using a method call) will not affect instance variables of the original, and conversely. A deeper assignment (for example if the instance variable is a reference cell) will of course affect both the original and the copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6212b229fd84e14b8e1bd78d95275e70aab5b8c" translate="yes" xml:space="preserve">
          <source>Objects can be compared using the generic comparison functions = and &amp;lt;&amp;gt;. Two objects are equal if and only if they are physically equal. In particular, an object and its copy are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e562beb45bc84c915a01804d2101ba51908f44" translate="yes" xml:space="preserve">
          <source>Ocaml_operators</source>
          <target state="translated">Ocaml_operators</target>
        </trans-unit>
        <trans-unit id="ee3ae917b76500c4d6f5198aee13dfba5343c14b" translate="yes" xml:space="preserve">
          <source>Of course the constraint may also be an explicit method type. Only occurrences of quantified variables are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390a64456209ce68498258cb6922119e7dbf8e07" translate="yes" xml:space="preserve">
          <source>Of course, not all abstract types can be refined, as this would contradict the exhaustiveness check. Namely, builtin types (those defined by the compiler itself, such as int or array), and abstract types defined by the local module, are non-instantiable, and as such cause a type error rather than introduce an equation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd38f73712f3f921494c6d0ba6b9d46d4b7cbdf" translate="yes" xml:space="preserve">
          <source>Of course, private methods can also be virtual. Then, the keywords must appear in this order method private virtual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f10114972b3e32658bfd9f3e9aeeb732ce426d" translate="yes" xml:space="preserve">
          <source>Of course, this applies to all sorts of accounts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce8d8c0b88abbfc440d3dc4b57a2cf0a75a3a5f" translate="yes" xml:space="preserve">
          <source>Of course, you will always encounter this error if you have mutually recursive functions across modules. That is, function Mod1.f calls function Mod2.g, and function Mod2.g calls function Mod1.f. In this case, no matter what permutations you perform on the command line, the program will be rejected at link-time. Fixes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abc8fb824d1ca26c79cf75a199925a3994ef82b" translate="yes" xml:space="preserve">
          <source>On ARM and PowerPC processors (32 and 64 bits), fused multiply-add (FMA) instructions can be generated for a floating-point multiplication followed by a floating-point addition or subtraction, as in x *. y +. z. The FMA instruction avoids rounding the intermediate result x *. y, which is generally beneficial, but produces floating-point results that differ slightly from those produced by the bytecode interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4743b988a9d2c98b0f15c07522d89801266295" translate="yes" xml:space="preserve">
          <source>On IA32 processors only (Intel and AMD x86 processors in 32-bit mode), some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f508fe5288f2a0aa709949918760a561ec1bb382" translate="yes" xml:space="preserve">
          <source>On Intel/AMD x86 processors in 32-bit mode, some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbf10944f284d7a264460f6a902cd99abf3e37d" translate="yes" xml:space="preserve">
          <source>On Windows, it is not implemented. Use threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dade53b6a22945b59c406518b5b7ced4711e03de" translate="yes" xml:space="preserve">
          <source>On Windows, not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8906e1dc157f50b42f72e0cd4030336afb142f2b" translate="yes" xml:space="preserve">
          <source>On Windows, this function can only wait for a given PID, not any child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac6ad13ca209e474dd5d7f27daf61cf7c33de3b" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;PF_UNIX&lt;/code&gt; not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ea9a621768303ff6efcb50e8aaf24bb46111f6" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;set_binary_mode_in&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc95dfa2349250ffde726f36b97030136e7f6c2" translate="yes" xml:space="preserve">
          <source>On Windows: &lt;code&gt;set_binary_mode_out&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acef991e8908183d9940b463de2698612bbf4fe" translate="yes" xml:space="preserve">
          <source>On Windows: Not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da523720ddd934f446918d027605931e5c5127b8" translate="yes" xml:space="preserve">
          <source>On Windows: always returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57ce5674b64a4e3616d137976975a2bc57a74ff" translate="yes" xml:space="preserve">
          <source>On Windows: always returns &lt;code&gt;[|1|]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb08db5b0219df69daea475e5cecf6bc85db53e" translate="yes" xml:space="preserve">
          <source>On Windows: can only wait for a given PID, not any child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef01eb224510c2a665dca3b58ffa03a7e7fb688" translate="yes" xml:space="preserve">
          <source>On Windows: execute permission &lt;code&gt;X_OK&lt;/code&gt; cannot be tested, just tests for read permission instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f81ce21e2dfe02264da50945ccef7a68e9401c" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (because it is meaningless).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b247888acfd86ad89effa228bc273bc912c169cc" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (no inter-process signals on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f29aabd74d2a481962357f52a86cac6b3a1664c" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (use threads).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7ecaf2e67d2e221d004d06c969e40c1f3fa6b9" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALcreate_process&quot;&gt;&lt;code&gt;Unix.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9a785f9bfc7be0ac004adbbac251dd0fd7a11d" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cc38279706572b8aec00ed072b6a09f30ba31d" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unixlabels#VALcreate_process&quot;&gt;&lt;code&gt;UnixLabels.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6184afb14529e272fde289ddcc0c79bc44e53b1" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt;&lt;code&gt;UnixLabels.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275242bb70c12d899890264c377bf0698c3fd50b" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80d45ffbea9730a03ea9d292e86a7f33ca75082" translate="yes" xml:space="preserve">
          <source>On Windows: only the &lt;a href=&quot;sys#VALsigkill&quot;&gt;&lt;code&gt;Sys.sigkill&lt;/code&gt;&lt;/a&gt; signal is emulated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f346325fc833b7dd2d5cbc6251af254465b155" translate="yes" xml:space="preserve">
          <source>On Windows: partially implemented, will not report timings for child processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d73771d5997e1e56b96cce84c556b6aa2f143d" translate="yes" xml:space="preserve">
          <source>On each case of a pattern-matching definition (function, match&amp;hellip;with construct, try&amp;hellip;with construct):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e88170bb615e04bffb73dc9ab941d16c68ec80f" translate="yes" xml:space="preserve">
          <source>On entrance to a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06905e7e7cd277c45d37ec140ed32c4c8da539c" translate="yes" xml:space="preserve">
          <source>On most systems, the file produced by the linking phase can be run directly, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81f9f71a735722a72705b16087220b85ed634fb" translate="yes" xml:space="preserve">
          <source>On native Windows, the following environment variable is also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8007c691da700e3ae4175b6d76c73c8fb4dfce47" translate="yes" xml:space="preserve">
          <source>On one example that was known to be bad for next-fit and first-fit, next-fit takes 28s using 855Mio of memory, first-fit takes 47s using 566Mio of memory, best-fit takes 27s using 545Mio of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5948507ff40bc2323b67783b3e4e95bc1723dae" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &amp;zwj;&lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;18.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6baf20c0bc95c4d024106e11bc89c9ce694fe9" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f23214a8cc0b25426327d7520ebefaf7e3dc98b" translate="yes" xml:space="preserve">
          <source>On some ports, special options are required on the final linking phase that links together the object file produced by the -output-obj option and the remainder of the program. Those options are shown in the configuration file Makefile.config generated during compilation of OCaml, as the variable OC_LDFLAGS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d9b385e6328adefa96c7b5d8b00ab42f09a2ff" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1d4e4f1b5f80e398835cf87ca32c2f6861e659" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b84befbd60a3041accf5742277784b546af6a5" translate="yes" xml:space="preserve">
          <source>On start-up, the debugger will read commands from an initialization file before giving control to the user. The default file is .ocamldebug in the current directory if it exists, otherwise .ocamldebug in the user&amp;rsquo;s home directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd11bf07751e14f362666e5c1bd69ee93954cd1" translate="yes" xml:space="preserve">
          <source>On the C side, a pointer to the value registered under name n is obtained by calling caml_named_value(n). The returned pointer must then be dereferenced to recover the actual OCaml value. If no value is registered under the name n, the null pointer is returned. For example, here is a C wrapper that calls the OCaml function f above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064af06a1d91392c727df0b16b39810d1213c9db" translate="yes" xml:space="preserve">
          <source>On the OCaml side, registration is performed by evaluating Callback.registern v. Here, n is the global name (an arbitrary string) and v the OCaml value. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de3701f349d27c7db926bd7951f46017d144e8d" translate="yes" xml:space="preserve">
          <source>On the debugged program side, the socket name is passed through the CAML_DEBUG_SOCKET environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3a47d696ce0714f9f1c41b24081abcae43afd6" translate="yes" xml:space="preserve">
          <source>On the other hand, a class for polymorphic references must explicitly list the type parameters in its declaration. Class type parameters are listed between [ and ]. The type parameters must also be bound somewhere in the class body by a type constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde94d852235534ebe9a07117621ba74b29f99ae" translate="yes" xml:space="preserve">
          <source>Once a runtime is unloaded, it cannot be started up again without reloading the shared library and reinitializing its static data. Therefore, at the moment, the facility is only useful for building reloadable shared libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fcb0d46bf0fa0b289db31330eb16f274c3b00f" translate="yes" xml:space="preserve">
          <source>Once compiled and linked with the instrumented runtime, any OCaml program can generate &lt;em&gt;trace files&lt;/em&gt; that can then be read and analyzed by users in order to understand specific runtime behaviors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d1a0a00f7b028b377134ebb6383b1db4d55c3d" translate="yes" xml:space="preserve">
          <source>Once the appropriate compiler has been selected the program should be built as normal (ensuring that all files are built with the Spacetime compiler&amp;mdash;there is currently no protection to ensure this is the case, but it is essential). For many uses it will not be necessary to change the code of the program to use the profiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c6b2bb41ee454dbfaccf9b93d05b18a714000d" translate="yes" xml:space="preserve">
          <source>One can also use this to completely remove a field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de9b9cc70a42dc4f700bcc1de9462f06fdcb0c2" translate="yes" xml:space="preserve">
          <source>One can write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15e35f605f634d4dc006143de05c9a72bf8ebe2" translate="yes" xml:space="preserve">
          <source>One could think of defining the type abbreviation directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c4aedb3397880f828378b13f6f7ae32fd18ccd" translate="yes" xml:space="preserve">
          <source>One could think that a private method should remain private in a subclass. However, since the method is visible in a subclass, it is always possible to pick its code and define a method of the same name that runs that code, so yet another (heavier) solution would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f1bbfebca36b804f1d02940b9fe648bbeb9dc0" translate="yes" xml:space="preserve">
          <source>One important restriction is that types introduced by openstruct ... end cannot appear in the signature of the enclosing structure, unless they are defined equal to some non-local type. So:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae76e80271c4a94dd62fcba165e22dd596cb51b" translate="yes" xml:space="preserve">
          <source>One may extract a public method from an object using the C function caml_get_public_method (declared in &amp;lt;caml/mlvalues.h&amp;gt;.) Since public method tags are hashed in the same way as variant tags, and methods are functions taking self as first argument, if you want to do the method call foo#bar from the C side, you should call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c0b5251da945468988a280889faaa02e2f8010" translate="yes" xml:space="preserve">
          <source>One may wish to open an account and simultaneously deposit some initial amount. Although the initial implementation did not address this requirement, it can be achieved by using an initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac45b2b8f5570a34d56bdec8e442987bb58c7b07" translate="yes" xml:space="preserve">
          <source>One may wonder whether it is possible to treat primitive types such as integers and strings as objects. Although this is usually uninteresting for integers or strings, there may be some situations where this is desirable. The class money above is such an example. We show here how to do it for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a6da4a2194d9a62f8ff334748a426441e352b3" translate="yes" xml:space="preserve">
          <source>One should notice that the use of the &lt;code&gt;parser&lt;/code&gt; keyword and associated notation for streams are only available through camlp4 extensions. This means that one has to preprocess its sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4137e328694d44e01b837a396be545fdedd151" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19597e0daea38469940aa2541294449599b19f03" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays. The &lt;code&gt;Array1&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of one-dimensional arrays. (The &lt;a href=&quot;bigarray.array2&quot;&gt;&lt;code&gt;Bigarray.Array2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.array3&quot;&gt;&lt;code&gt;Bigarray.Array3&lt;/code&gt;&lt;/a&gt; structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e57737797ac7cce48fd7410f424583fc8513250" translate="yes" xml:space="preserve">
          <source>Only consider using &lt;code&gt;print_flush&lt;/code&gt; when displaying all pending material is mandatory (for instance in case of interactive use when you want the user to read some text) and when resetting the pretty-printer state will not disturb further pretty-printing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c1f2f7c1cbc3df8fd97de870c8cc67eed2b309" translate="yes" xml:space="preserve">
          <source>Only elements (values, types, classes, ...) declared in the .mli file are kept. In other terms, definitions from the .ml file that are not exported in the .mli file are not documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b33e1f6fc9c9ddf7561ddbbf58ce1315c78aa84" translate="yes" xml:space="preserve">
          <source>Only generative effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd27083a589b2ea8c548b530eaf11c8f07666db" translate="yes" xml:space="preserve">
          <source>Only the override can be used to actually override fields, and only the Oo.copy primitive can be used externally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d7997d1c51094c34071c019aa4016ceac60919" translate="yes" xml:space="preserve">
          <source>Oo</source>
          <target state="translated">Oo</target>
        </trans-unit>
        <trans-unit id="879894b2b7b07e597e8cd61a26bfd25635e3e7b3" translate="yes" xml:space="preserve">
          <source>Open a descriptor on a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42cdbc4aac5165559359ac8e455a8abf3fb22ee2" translate="yes" xml:space="preserve">
          <source>Open for append</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22f60235dedec7386d0bead1c3c094a8425cdd5" translate="yes" xml:space="preserve">
          <source>Open for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe9ee1f7787491ffb2ce2a09f2e3a1c47b49760" translate="yes" xml:space="preserve">
          <source>Open for reading and writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02c2958f8bca2d69a22cec109cddef10f1b7f6a" translate="yes" xml:space="preserve">
          <source>Open for writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c50ee9bdb83bc2966178eb9517aa2ed3bb705c2" translate="yes" xml:space="preserve">
          <source>Open in non-blocking mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be813666b3c7520ae92cd0a1c6783279f682b877" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ebdf1219ecd6520cbac717e097eb9be6c3aaca" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined label or constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f7d6bffbe087ced7c1077d53f97324fb2738f7" translate="yes" xml:space="preserve">
          <source>Open the named file for reading, and return a new input channel on that file, positioned at the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca06bc653ed2aa9b9ca617abff820d8ae7223d" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff1c4e694cef020d3159f32a866f2a047386814" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855fccd9cd030742446f7fcafaafb5b0c12184d8" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df722ec03c209e9326d618d229491b24151a9084" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0b0770f8c14a1fd210c4ac33013fabb355dc35" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unixlabels#VALumask&quot;&gt;&lt;code&gt;UnixLabels.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49f1f535c925238e318a33c608a939bf58bc5fe" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created. Return a file descriptor on the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c183b6c4d6c2979639b113137c57ec0de409f0" translate="yes" xml:space="preserve">
          <source>Opening a module enables lighter access to its components, at the cost of making it harder to identify in which module a identifier has been defined. In particular, opened modules can shadow identifiers present in the current scope, potentially leading to confusing errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5209b9452f8161599a2a771725ad2ccd16a6bec" translate="yes" xml:space="preserve">
          <source>Opening modes for &lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt;&lt;code&gt;open_out_gen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt;&lt;code&gt;open_in_gen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f27f60f5932e4abb4b4ed37257f5c7c5328157" translate="yes" xml:space="preserve">
          <source>Opens the given module before processing the interface or implementation files. If several -open options are given, they are processed in order, just as if the statements open!Module1;;...open!ModuleN;; were added at the top of each file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785a4531dce5036578aea8e49ed353d58a926529" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21abc6dbd0063cb952c1cc150a7203c29ccc476d" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program. One of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49e2a256113761881fb1a1fa41d066e27d70d15" translate="yes" xml:space="preserve">
          <source>Operation not supported on socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d4b9b2ab0289179c7507e1de79db969d3d4674" translate="yes" xml:space="preserve">
          <source>Operations on binary trees are naturally expressed as recursive functions following the same structure as the type definition itself. For instance, here are functions performing lookup and insertion in ordered binary trees (elements increase from left to right):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ba0f6e1bd0b179a386572eb306814fd822f312" translate="yes" xml:space="preserve">
          <source>Operations on file descriptors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dd6735ea7932a85dd5996051b8e28bae8e00af" translate="yes" xml:space="preserve">
          <source>Operations on file names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3fabd6bce5c3e474e507106204018aa930b99e" translate="yes" xml:space="preserve">
          <source>Operations on file names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e7fd3b17cf5a9396bca0fcd458a4b1c3357462" translate="yes" xml:space="preserve">
          <source>Operations on format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d745537237adfa18d0a04a59f915fbeb6922d1" translate="yes" xml:space="preserve">
          <source>Operations on internal representations of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef05a420fdb91696847263f07548f0822231b601" translate="yes" xml:space="preserve">
          <source>Operations on large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884b46ea59004fc7b9feee6503d70fe0de517a3c" translate="yes" xml:space="preserve">
          <source>Operations on large files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392a9d3b032591e4ff18dd78bdf784b52dd45f89" translate="yes" xml:space="preserve">
          <source>Operations on objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="c4083b8c5eac166a2a2acd9a240e21f33de8bf2b" translate="yes" xml:space="preserve">
          <source>Operator class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2866cf078fa7e1a2f2d0a2ea0ea2b67ee507cc6b" translate="yes" xml:space="preserve">
          <source>Operator names starting with a # character and containing more than one # character are reserved for extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45483f2ad274c0501b5ffbf4bf59ee7cd50884a0" translate="yes" xml:space="preserve">
          <source>Optimisation with Flambda is not currently supported when generating bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="9d029eff2b929a5ac0d4af743cee64e78c8571a4" translate="yes" xml:space="preserve">
          <source>Optimize the produced code for space rather than for time. This results in slightly smaller but slightly slower programs. The default is to optimize for speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b4461387353942c5c9a36536dba32b4583899a32" translate="yes" xml:space="preserve">
          <source>Option values explicitly indicate the presence or absence of a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed9d5149119da92f8108cc447b5c8a63bc1983d" translate="yes" xml:space="preserve">
          <source>Option values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72c0a2e7190e2eb7aaa162394774f42f8444781" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually implemented as option types. If you do not give a default value, you have access to their internal representation, type 'a option = None | Some of 'a. You can then provide different behaviors when an argument is present or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57beea4dfffda43497b4bb0d9bd857b0df0104e1" translate="yes" xml:space="preserve">
          <source>Optional parameters may also commute with non-optional or unlabeled ones, as long as they are applied simultaneously. By nature, optional arguments do not commute with unlabeled arguments applied independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659fd3897d334a8024280ea2db630f05a96e06e0" translate="yes" xml:space="preserve">
          <source>Optionally, missing fields can be made explicit by ending the list of fields with a trailing wildcard _::</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="de973f948db8258d8d749bfe279d72496cf0c025" translate="yes" xml:space="preserve">
          <source>Options selecting a built-in generator to ocamldoc, such as -html, have no effect if a custom generator of the same kind is provided using -g. If the kinds do not match, the selected built-in generator is used and the custom one is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfdbe107bba41b0abba570531e3c3d244ee7166" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbc13cd4094c5e7aa7a8e52fa68629dbf0813f9" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a94dd4d94b5377208a7fb921f37e8e691cbccf" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unixlabels#VALgetaddrinfo&quot;&gt;&lt;code&gt;UnixLabels.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d70fdc1d8443e456faa3f18ac9f4cce1786955" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unixlabels#VALgetnameinfo&quot;&gt;&lt;code&gt;UnixLabels.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabf18c33657daede436c9425e69c4a2df9c4ba4" translate="yes" xml:space="preserve">
          <source>Or, equivalently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2251dba4688a589e898c162858a821fdb5b816" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;hashtbl#VALiter&quot;&gt;&lt;code&gt;Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad21b6c76995f078551fec35633e00c1a8b9aa0" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;morelabels.hashtbl#VALiter&quot;&gt;&lt;code&gt;MoreLabels.Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72667213aa60e61b77943168bfb7d9b47ab1a35" translate="yes" xml:space="preserve">
          <source>Other generic comparisons such as (&amp;lt;, &amp;lt;=, ...) can also be used on objects. The relation &amp;lt; defines an unspecified but strict ordering on objects. The ordering relationship between two objects is fixed once for all after the two objects have been created and it is not affected by mutation of fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8efe1d345866aae01ed21ce80800454a7ab6f8" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; &amp;zwj;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3a931554b88e85d13e345dd0998e69549806d3" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cb471cac1651f6cd901864ed749958654b7d77" translate="yes" xml:space="preserve">
          <source>Otherwise the function being called is substituted at the call site with its body having been rewritten such that any recursive calls to that function &lt;em&gt;or any others in the same mutually-recursive group&lt;/em&gt; are annotated with the attribute unrolled(n &amp;minus; 1). Inlining may continue on that body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf7d27ce868f52e567b02e4ec391690c62f134e" translate="yes" xml:space="preserve">
          <source>Otherwise, nothing happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c86b00df30e667ed3c1e54e980a320c6bfb8e87" translate="yes" xml:space="preserve">
          <source>Otherwise, the initialising array is lifted out and subject to the normal constant sharing procedure; creation of the array consists of bulk copying the initialising array into a fresh value on the OCaml heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafa7eee672f6b85c088cd2cb345b72adf66f904" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol is bound to a (statically-allocated) &lt;em&gt;preallocated block&lt;/em&gt; containing one field. At runtime, the defining expression will be evaluated and the first field of the block filled with the resulting value. This &lt;em&gt;initialise-symbol&lt;/em&gt; binding causes one extra indirection but ensures, by virtue of the symbol&amp;rsquo;s address being known at compile time, that uses of the value are not captured by closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e89ee3a810516da1f61deb1e918aa6f94233ccf" translate="yes" xml:space="preserve">
          <source>Our iterator works, as shows its first use for summation. However, since objects themselves are not polymorphic (only their constructors are), using the fold method fixes its type for this individual object. Our next attempt to use it as a string iterator fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be297b561141a6a2d82a7108dddc36e1cc22dba" translate="yes" xml:space="preserve">
          <source>Out of memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e02b9b7b5116b9cf2721c4e3f0f7bdbc58079e4" translate="yes" xml:space="preserve">
          <source>Output GC statistics at program exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7671f0341e3d098b8c9393d0300f5e4d7f5c6621" translate="yes" xml:space="preserve">
          <source>Output baud rate (0 means close connection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c09cf6b42600a87ca03143becccdcb8b33419e1" translate="yes" xml:space="preserve">
          <source>Output code that does not use OCaml&amp;rsquo;s built-in automata interpreter. Instead, the automaton is encoded by OCaml functions. This option improves performance when using the native compiler, but decreases it when using the bytecode compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743a4b6a0ace04e22a3f7d73badb17283ccbd3bc" translate="yes" xml:space="preserve">
          <source>Output dot code describing the type dependency graph instead of the module dependency graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da5f56773c68337139a5eca245caeacb63ae861" translate="yes" xml:space="preserve">
          <source>Output functions on standard error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ab5418296d95f226bfcd5834dc0e99eb65877d" translate="yes" xml:space="preserve">
          <source>Output functions on standard output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2900df23d8753bef8ba40bb95924b811a8a31a30" translate="yes" xml:space="preserve">
          <source>Output one line per file, regardless of the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052a1c1bf420fd7d12e0f3d0ea009ebee9739c3a" translate="yes" xml:space="preserve">
          <source>Output raw dependencies of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bd2e99d5d5374f1bd9969053ecf288c36f827f" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce15cc8d58fabc956c6b1932886db9d314a2ae5" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;morelabels.map.make&quot;&gt;&lt;code&gt;MoreLabels.Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4100ed2d22cb3ae26b1477b3891fbe93d1b79c17" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;morelabels.set.make&quot;&gt;&lt;code&gt;MoreLabels.Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5145c8c79a32654b4778e9f93670595bbd8d1719" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31f223f57817b5e1d76b337263e2c889f885c49" translate="yes" xml:space="preserve">
          <source>Output the generated documentation to file instead of ocamldoc.out. This option is meaningful only in conjunction with the -latex, -texi, or -dot options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95791b995af7b93d84b0104e38a8bf231ca37bde" translate="yes" xml:space="preserve">
          <source>Outside of this domain, &lt;code&gt;pp_set_geometry&lt;/code&gt; raises an invalid argument exception whereas &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d1264bc905918faeda24a1a224e8b90ab0b9d7" translate="yes" xml:space="preserve">
          <source>Outside the structure, its components can be referred to using the &amp;ldquo;dot notation&amp;rdquo;, that is, identifiers qualified by a structure name. For instance, PrioQueue.insert is the function insert defined inside the structure PrioQueue and PrioQueue.queue is the type queue defined in PrioQueue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="da18ad2a8cc0702f3ea2d5253be6cbd4ca251be5" translate="yes" xml:space="preserve">
          <source>PF_INET is fully supported; PF_INET6 is fully supported (since 4.01.0); PF_UNIX is not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc6925c70ec89b041de02dd5e2ee478c8a2fff1" translate="yes" xml:space="preserve">
          <source>Pair operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="06f18dad25a25477df3046f706b5e47ba6a1cff9" translate="yes" xml:space="preserve">
          <source>Parameterize one function by the other. That is, instead of having</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="917b2a251560fc0829ba549ae43c67440509e02d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &amp;zwj;&lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3863839aefaac9ffd796e91309941e5a0aabf4" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e82529fec7a054cadaa05482779b54cccd0e7d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can contain a type constraint, as in (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="b2eda9d52f18e0568a63bc181bcaa6ee3a98404e" translate="yes" xml:space="preserve">
          <source>Parsing of command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5f54d8070d9bc8013738e6b516352edaed2ca3" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19238d57dd0b585bfed6e7ad8133742326ec59ac" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acfeea4b9543fefe3bae0d4e85f92629ac3ad50" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fb4bbb0a4f774cd23019ab4a347d036de5427b" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;&lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38a98ee2d74d13c07933d22667a73fadfb813b1" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;I An introduction to OCaml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a0af2c91d9271afdf61c522b100141d883d23e" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;II The OCaml language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d9ac25931ce230c248c31708f02b35b21928fb" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;III The OCaml tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f44b93036e9ab25420868aabe5d6e167b279f5" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;IV The OCaml library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d808f75d0801383a43b1615503577d5f6b97062" translate="yes" xml:space="preserve">
          <source>Part &amp;zwj;V Indexes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9e17bd7715006188f45f1708aaf0fea52ec4f8" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c889dcbcc02d29f2665be2a7454d8a1987503b" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0668847ca907120f5188c16ff537453a2eafe0" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903f9019ed78ac57cfad4f904e7657f4fe68eff9" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a2c5985aa86cde57c2ecbbc6cbc8380d79481d" translate="yes" xml:space="preserve">
          <source>Part I An introduction to OCaml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62eaed854d7e70fe37691fb3a427228618bcb89" translate="yes" xml:space="preserve">
          <source>Part II The OCaml language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5891d0deb20c4e4a3137af20b7932727b436b5" translate="yes" xml:space="preserve">
          <source>Part III The OCaml tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29da75cd43003faab118a1eb6915f585144a3e6" translate="yes" xml:space="preserve">
          <source>Part IV The OCaml library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952bed16abbd7542df79c253d7d2a383bf3f6501" translate="yes" xml:space="preserve">
          <source>Part V Appendix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259899217f837489155c6afc61bda7baa0892067" translate="yes" xml:space="preserve">
          <source>Partial match: missing cases in pattern-matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3a92949ce10ed0b574a754bc455be19981923a" translate="yes" xml:space="preserve">
          <source>Partially applied function: expression whose result has function type and is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8f0a0917978c15b665028676a364a22bd18fe0" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;19.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122dc2b1a442a4492301d7cfaae94e0455545b63" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139f1329d56ecac27be1fc05605291efd738915" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option). This causes the given C library to be linked with the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ec306fd1c4422e97cfa2ee48b0b9b8261921e1" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df106032363559c3f40628cbdd6ff4a26fa7fd35" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceed386065448933a097ec35067876966e85d14f" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the linker . This causes the given C library to be linked with the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a98fab69c5b411c299526b9c9f34cd1b6787ac" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59af1bc11afda37b34f10079d3a9dec8ef0d8df" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35478fccd7fbafbf25aff91256c23a1c032cf84" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. For instance,-ccopt -Ldir causes the C linker to search for C libraries in directory dir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273a7a00d3bf42c46d56c858df14b11822928560" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. When linking in &amp;ldquo;custom runtime&amp;rdquo; mode, for instance-ccopt -Ldir causes the C linker to search for C libraries in directory dir.(See the -custom option.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72dfe02cbb8cc21321b311387b88011ec8835c71" translate="yes" xml:space="preserve">
          <source>Pattern matching on an extensible variant type requires a default case to handle unknown variant constructors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7196102a3d9bcbd2b6117c4975e2514a2f279f02" translate="yes" xml:space="preserve">
          <source>Pattern-matching depending on mutable state prevents the remaining arguments from being uncurried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c3d48bb09ccd90e9aae3bcf8d34d9478c3b2ab" translate="yes" xml:space="preserve">
          <source>Patterns are &lt;em&gt;linear&lt;/em&gt;: a variable cannot be bound several times by a given pattern. In particular, there is no way to test for equality between two parts of a data structure using only a pattern (but when guards can be used for this purpose).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3abd39dc618aa8814823785a44aa53f573df633" translate="yes" xml:space="preserve">
          <source>Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure. This selection operation is called pattern matching; its outcome is either &amp;ldquo;this value does not match this pattern&amp;rdquo;, or &amp;ldquo;this value matches this pattern, resulting in the following bindings of names to values&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c689af30d05364792d515c0faaa88a9ab2da162" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d568817e2f7ecd125459c14fd92de23c2c2e40" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055dbe4520a583e58ae39a293f647d64d4770ec6" translate="yes" xml:space="preserve">
          <source>Perform a transitive reduction of the dependency graph before outputting the dot code. This can be useful if there are a lot of transitive dependencies that clutter the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a67fe1a67339dfb0ee43e9f1cd0038c969bd66" translate="yes" xml:space="preserve">
          <source>Perform even more optimisation than usual, possibly including unrolling of recursive functions. Compilation times may be significantly lengthened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ae6f3e3a5dfa3cf5ca340a83e5ff43e4d7561e" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;19.5&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87d065999353ac9c7a4517b1177b42e5b1d7054" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22610c9aaccb16a1bee9b7cee9dfb32918779ba0" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int32&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int32&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int32&lt;/code&gt; only when the application requires exact 32-bit arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662740b47a420ed740a0039a0fb0aa90dd4e339b" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int64&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int64&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int64&lt;/code&gt; only when the application requires exact 64-bit arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9583bec530f000172f8c0f05a57970fabee45e7c" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;nativeint&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;nativeint&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;nativeint&lt;/code&gt; only when the application requires the extra bit of precision over the &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca053ed9d5deaad2a727eb5b9ce7480cd5b49c87" translate="yes" xml:space="preserve">
          <source>Permit sending of broadcast messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e98f8d6c9356b9f9b3cb0dd0fac5d3d678c8e6" translate="yes" xml:space="preserve">
          <source>Physical equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764dcc2a562c9da7446795d50aa77b7dbdc6bc96" translate="yes" xml:space="preserve">
          <source>Physical inequality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9077104dc61ea39ed76dd5e6b7f00ad4f53b057c" translate="yes" xml:space="preserve">
          <source>Pipe abstract syntax trees through preprocessor command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258a386ac1d80ecc73cf9133d40fece735aa3f44" translate="yes" xml:space="preserve">
          <source>Pipe sources through preprocessor command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0094bdf1788f2095a6baf0ac9fd3dc283b5db4" translate="yes" xml:space="preserve">
          <source>Pipes and redirections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48afc6d396ff51a5ed35b5868fabdc57f1c9fb87" translate="yes" xml:space="preserve">
          <source>Pollable event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4044893229fcfc93927dd395fda2603f25cbf9b0" translate="yes" xml:space="preserve">
          <source>Polling</source>
          <target state="translated">Polling</target>
        </trans-unit>
        <trans-unit id="b87c82743d31a59fa081b4b5917f7e5fb9a91553" translate="yes" xml:space="preserve">
          <source>Polymorphic methods are called in exactly the same way as normal methods, but you should be aware of some limitations of type inference. Namely, a polymorphic method can only be called if its type is known at the call site. Otherwise, the method will be assumed to be monomorphic, and given an incompatible type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9825069b45f85b17a181b73e838bf2e21e0bf759" translate="yes" xml:space="preserve">
          <source>Polymorphic type annotations in let-definitions behave in a way similar to polymorphic methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213691ff9b4dc02fdb3bf4a27f4eb612ef11f926" translate="yes" xml:space="preserve">
          <source>Polymorphic variant tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22aa46a8a43e1108e30e6c20c787a6de9123751d" translate="yes" xml:space="preserve">
          <source>Polymorphic variant types describe the values a polymorphic variant may take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2029098a5b14173ba88c69574469d4e0ce8f59cd" translate="yes" xml:space="preserve">
          <source>Polymorphic variants are an alternate form of variant values, not belonging explicitly to a predefined variant type, and following specific typing rules. They can be either constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, or non-constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(v).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2610209437f25d35cbd42b41c775ccdcaf3af336" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f6ef1f36c845706de35765267136890ed1fd7c" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed. You can change this value, e.g. to force &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; to skip some arguments. &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; uses the initial value of &lt;a href=&quot;arg#VALcurrent&quot;&gt;&lt;code&gt;Arg.current&lt;/code&gt;&lt;/a&gt; as the index of argument 0 (the program name) and starts parsing arguments at the next element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fd514253c1577755278adb384c498032582797" translate="yes" xml:space="preserve">
          <source>Position tracking mode works as follows. At each token, the lexing engine will copy &lt;code&gt;lex_curr_p&lt;/code&gt; to &lt;code&gt;lex_start_p&lt;/code&gt;, then change the &lt;code&gt;pos_cnum&lt;/code&gt; field of &lt;code&gt;lex_curr_p&lt;/code&gt; by updating it with the number of characters read since the start of the &lt;code&gt;lexbuf&lt;/code&gt;. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also &lt;code&gt;new_line&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2013d98249e5e8bcfd7d895cc29b28e763b3a92" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c07ff7a6172b892fe2ca9c53ec2061c8855ce1" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="653a3645251575bf9279abc23fa56dfc34058739" translate="yes" xml:space="preserve">
          <source>Positive infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86a729c53a1915ca3654adc8aae51c101d917df" translate="yes" xml:space="preserve">
          <source>Power function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fbbe41e74c44588da3a875aa227d393b9e7e864" translate="yes" xml:space="preserve">
          <source>Power function. &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; returns &lt;code&gt;z1&lt;/code&gt; to the &lt;code&gt;z2&lt;/code&gt; power.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5789da79b475d584d15053c8dde659f5c24e3de1" translate="yes" xml:space="preserve">
          <source>Precedence level and associativity of operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8a0e66b4c1574357482510c167de122caee2aa" translate="yes" xml:space="preserve">
          <source>Predecessor.</source>
          <target state="translated">Predecessor.</target>
        </trans-unit>
        <trans-unit id="b3d4df1b4fc8bba29600c89de44c71635c187145" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a365fc68958b3868521e16be1f99a37de6553c7a" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3760cb7859c8cbaa586b1b23829a81faa04f5005" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72b78329d76d9323072a7e5e631c531e356e518" translate="yes" xml:space="preserve">
          <source>Predefined data structures include tuples, arrays, and lists. There are also general mechanisms for defining your own data structures, such as records and variants, which will be covered in more detail later; for now, we concentrate on lists. Lists are either given in extension as a bracketed list of semicolon-separated elements, or built from the empty list [] (pronounce &amp;ldquo;nil&amp;rdquo;) by adding elements in front using the :: (&amp;ldquo;cons&amp;rdquo;) operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1410f8fbd254f890a3355e9bcb2305c86175f5" translate="yes" xml:space="preserve">
          <source>Predefined parsers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3e08e9e6eb753141109ff66d4be4a3ea38babd" translate="yes" xml:space="preserve">
          <source>Predicates and comparisons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="a46adfa85b9e12a0f2b4120e9bc73717dcfc0bd1" translate="yes" xml:space="preserve">
          <source>Preprocessor warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8c2216bf58d48c75b9b44385be2473949e9115" translate="yes" xml:space="preserve">
          <source>Preprocessors that generate OCaml source code can insert line number directives in their output so that error messages produced by the compiler contain line numbers and file names referring to the source file before preprocessing, instead of after preprocessing. A line number directive is composed of a # (sharp sign), followed by a positive integer (the source line number), optionally followed by a character string (the source file name). Line number directives are treated as blanks during lexical analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bace76147e38ae19d3a0c11609fc9d38e774f7e8" translate="yes" xml:space="preserve">
          <source>Pretty-printing</source>
          <target state="translated">Pretty-printing</target>
        </trans-unit>
        <trans-unit id="1cccabcdd6a358d979939998cc033a04308c5cf5" translate="yes" xml:space="preserve">
          <source>Pretty-printing boxes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a4462f39466982126a74de486bca0779a059f3" translate="yes" xml:space="preserve">
          <source>Pretty-printing termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3bd5a8a477c68713e4b63b07bf86de7633d445" translate="yes" xml:space="preserve">
          <source>Pretty-printing.</source>
          <target state="translated">Pretty-printing.</target>
        </trans-unit>
        <trans-unit id="8dc354dacf2179400fda256bb8b5273768f4fa0d" translate="yes" xml:space="preserve">
          <source>Primitives with several arguments are always curried. The C function does not necessarily have the same name as the ML function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4927a230a7393e58f700f3b895b9a8e2141e1502" translate="yes" xml:space="preserve">
          <source>Print a boolean in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429be0de1bf187c6aed029fd0f262066cde03fe6" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b40235213e3b9b233db12ee353ee4db3cf9b5e" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c581c84ffe95bc9ceacf3ea66bdfc3a0500bac" translate="yes" xml:space="preserve">
          <source>Print a character in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af319c36a4f3c8916104f4d0b89b33a561567553" translate="yes" xml:space="preserve">
          <source>Print a character on standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d52b245107b56716114cb4df780a3991c94880" translate="yes" xml:space="preserve">
          <source>Print a character on standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3800dc392ff64d7282401e28ec9718d894a98136" translate="yes" xml:space="preserve">
          <source>Print a floating point number in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d3361cbb609b643a25135cfa13aaa39fdd8216" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f593ed3a39b6bcdd833537c6e2868f7d6bbca3c" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6af9922bfeade8a893e020a9b67b642c05b2584" translate="yes" xml:space="preserve">
          <source>Print a list of checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b79eb900647a5ec2eb44f25634fcf150fb96e4" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard error, and flush standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02b6c71fe25d1c006f404421e4a18e508b909cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51802e08b4337c0255ed47927f1d410b8ef886cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b23be15f00e2b2a766ad074fcad3032022f804" translate="yes" xml:space="preserve">
          <source>Print a raw backtrace in the same format &lt;code&gt;Printexc.print_backtrace&lt;/code&gt; uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59315f70ac13c50e613039426e9b1da6c2b46f5" translate="yes" xml:space="preserve">
          <source>Print a string on standard error.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
