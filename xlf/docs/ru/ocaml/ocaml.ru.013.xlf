<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="8198b57a18523f699b5f95a3eca2418108615522" translate="yes" xml:space="preserve">
          <source>The transformation replaces closure variables by specialised arguments. The aim is to cause more closures to become closed. It is particularly applicable, as a means of reducing allocation, where the function concerned cannot be inlined or specialised. For example, some non-recursive function might be too large to inline; or some recursive function might offer no opportunities for specialisation perhaps because its only argument is one of type unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec534b61d911e890ad6935004cee0e7049d17f2" translate="yes" xml:space="preserve">
          <source>The transformation to unbox specialised arguments never introduces extra allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e701b3559c3cd620429a438a8bb4dcb9c99e51c" translate="yes" xml:space="preserve">
          <source>The transformation will not unbox arguments if it would result in the original function having sufficiently many arguments so as to inhibit tail-call optimisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3231a8b466d35dcee0deec7b0a92803db2aeb3cd" translate="yes" xml:space="preserve">
          <source>The transformations in this section relate to the splitting apart of &lt;em&gt;boxed&lt;/em&gt; (that is to say, non-immediate) values. They are largely intended to reduce allocation, which tends to result in a runtime performance profile with lower variance and smaller tails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb73189e94327227c50de51480db7a0a57ff2cd" translate="yes" xml:space="preserve">
          <source>The two arguments used and max give the GC an idea of how much out-of-heap resources are consumed by the finalized block being allocated: you give the amount of resources allocated to this object as parameter used, and the maximum amount that you want to see in floating garbage as parameter max. The units are arbitrary: the GC cares only about the ratio used / max.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed7190edee3a6e075a677294a42446cfd7fe2e5" translate="yes" xml:space="preserve">
          <source>The two basic operations on semaphores are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de645ad92a5669480afb7be4dd3aef35389b655e" translate="yes" xml:space="preserve">
          <source>The two components of a type definition, the optional equation and the optional representation, can be combined independently, giving rise to four typical situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0d501a57672abb475f57d2ac37627ee51ce36b" translate="yes" xml:space="preserve">
          <source>The two parameters used and max are used to control the speed of garbage collection when the finalized object contains pointers to out-of-heap resources. Generally speaking, the OCaml incremental major collector adjusts its speed relative to the allocation rate of the program. The faster the program allocates, the harder the GC works in order to reclaim quickly unreachable blocks and avoid having large amount of &amp;ldquo;floating garbage&amp;rdquo; (unreferenced objects that the GC has not yet collected).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4b8bfbffcea6080868e73fa6fa91ada3a5aee9" translate="yes" xml:space="preserve">
          <source>The type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is a special kind of abbreviation. This abbreviation unifies with the type of any object belonging to a subclass of the class type &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. It is handled in a special way as it usually hides a type variable (an ellipsis, representing the methods that may be added in a subclass). In particular, it vanishes when the ellipsis gets instantiated. Each type expression #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; defines a new type variable, so type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;-&amp;gt;#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is usually not the same as type (#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;) -&amp;gt;'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2098df733b38a624b57b6a1ed22bd572f1e7f4fb" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; m : int &amp;gt; we see here is just the expansion of c, due to the use of a reference; we have succeeded in getting back an object of type c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5a55287de7cc9d410124fb3cd96a5d5e22f24" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; {&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;;} ..&amp;gt; is the type of an object whose method names and types are described by &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and possibly some other methods represented by the ellipsis. This ellipsis actually is a special kind of type variable (called &lt;em&gt;row variable&lt;/em&gt; in the literature) that stands for any number of extra method types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a639916ee7c30a10391d14e898dca5f2454415e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;'a&amp;nbsp;Seq.t&lt;/code&gt; is a &lt;b&gt;delayed list&lt;/b&gt;, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78845a66a3de51237a6160ba5250e692cfe066" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; is a &lt;b&gt;delayed list&lt;/b&gt;, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e093dd6adec72b6cbeb6815ff6a81bdec059a25" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17aafa409f735e2a7fb7b2d3ed8979e96c9a297" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions. Any number of dimensions between 0 and 16 is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da35f3f0e7a30126f1d89917b5a31fc578b5ea5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;raw_backtrace&lt;/code&gt; stores a backtrace in a low-level format, which can be converted to usable form using &lt;code&gt;raw_backtrace_entries&lt;/code&gt; and &lt;code&gt;backtrace_slots_of_raw_entry&lt;/code&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bb838dc88582dbd178720dcfda52e51470b21" translate="yes" xml:space="preserve">
          <source>The type N.t is incompatible with int, ensuring that nonnegative integers and regular integers are not confused. However, if x has type N.t, the coercion (x :&amp;gt; int) is legal and returns the underlying integer, just like N.to_int x. Deep coercions are also supported: if l has type N.t list, the coercion (l :&amp;gt; int list) returns the list of underlying integers, like List.map N.to_int l but without copying the list l.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa132651b99c1854c25fdf68be9f2ebc9e6e4a11" translate="yes" xml:space="preserve">
          <source>The type describing the status of an interval timer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25486382c0973b8dd5baf2bfa2b12dda90d4ed79" translate="yes" xml:space="preserve">
          <source>The type error here comes from the fact that during the definition of depth, the type checker first assigns to depth the type 'a -&amp;gt; 'b . When typing the pattern matching, 'a -&amp;gt; 'b becomes 'a nested -&amp;gt; 'b, then 'a nested -&amp;gt; int once the List branch is typed. However, when typing the application depth n in the Nested branch, the type checker encounters a problem: depth n is applied to 'a list nested, it must therefore have the type 'a list nested -&amp;gt; 'b. Unifying this constraint with the previous one leads to the impossible constraint 'a list nested = 'a nested. In other words, within its definition, the recursive function depth is applied to values of type 'a t with different types 'a due to the non-regularity of the type constructor nested. This creates a problem because the type checker had introduced a new type variable 'a only at the &lt;em&gt;definition&lt;/em&gt; of the function depth whereas, here, we need a different type variable for every &lt;em&gt;application&lt;/em&gt; of the function depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266509740eced7302211061ddb0023fc743e4493" translate="yes" xml:space="preserve">
          <source>The type expression '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; stands for the type variable named &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;. The type expression _ stands for either an anonymous type variable or anonymous type parameters. In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction. In the following cases, the scope of named type variables is restricted to the type expression where they appear: 1) for universal (explicitly polymorphic) type variables; 2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section &amp;zwj;&lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1&lt;/a&gt;); 3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it contains free universal type variables, or locally defined types.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9c8aa5ef431c67c6adbd4b206fd03f62c7ba9" translate="yes" xml:space="preserve">
          <source>The type expression '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; stands for the type variable named &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;. The type expression _ stands for either an anonymous type variable or anonymous type parameters. In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction. In the following cases, the scope of named type variables is restricted to the type expression where they appear: 1) for universal (explicitly polymorphic) type variables; 2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section &lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1&lt;/a&gt;); 3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it contains free universal type variables, or locally defined types.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361863db6506eaaf72bc73833dd7a710012beed" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf716551ec1bcc30d2653d9a50db98a601e3996" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;, &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with n parameters, denotes the application of the n-ary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1267fea7ae64838d1130ee8c9de538451b3845" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with one parameter, denotes the application of the unary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134280a727f04e70e93aab40360430e6a4a2edfe" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; denotes the type of tuples whose elements belong to types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd49bc22f7c62d9c4ae3e943e6b56abafe95d35b" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; denotes the type of functions mapping arguments of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to results of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f68ff9fb1de19b9947374a080e92592e2bffa5" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, and also binds the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; to type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; both in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; and in other types. In general the scope of an alias is the same as for a named type variable, and covers the whole enclosing definition. If the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; actually occurs in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, a recursive type is created. Recursive types for which there exists a recursive path that does not contain an object or polymorphic variant type constructor are rejected, except when the -rectypes mode is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6801841411231abefa49731a3af05dc93c2d6bf" translate="yes" xml:space="preserve">
          <source>The type for Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7710723d784526bfd14ff8684cd4f3768c3a88c0" translate="yes" xml:space="preserve">
          <source>The type for integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9382d7daf14dbc0dd9ad2ac68253c35ad1396cc7" translate="yes" xml:space="preserve">
          <source>The type for option values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d8396849b8d6781e4d124b104e7abf0c738fb9" translate="yes" xml:space="preserve">
          <source>The type for option values. Either &lt;code&gt;None&lt;/code&gt; or a value &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6a4f1c52488e6ba5ba76a0aea28a22e82a6300" translate="yes" xml:space="preserve">
          <source>The type for result values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ce0c547a2cc6ec0a54327ae4897e498aad029d" translate="yes" xml:space="preserve">
          <source>The type for result values. Either a value &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; or an error &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3acb8ad7e65f29f1c95c2b5b704647da2118b69e" translate="yes" xml:space="preserve">
          <source>The type for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0b6a8e9537b83d5facebd9c46c52d219d5b39a" translate="yes" xml:space="preserve">
          <source>The type inferred for sort, 'a list -&amp;gt; 'a list, means that sort can actually apply to lists of any type, and returns a list of the same type. The type 'a is a &lt;em&gt;type variable&lt;/em&gt;, and stands for any given type. The reason why sort can apply to lists of any type is that the comparisons (=, &amp;lt;=, etc.) are &lt;em&gt;polymorphic&lt;/em&gt; in OCaml: they operate between any two values of the same type. This makes sort itself polymorphic over all list types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c08084fecb7e84be89d27f0d722611fa9cc32c8" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a type compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. All users of the structure know that the type name is compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebe16a502ab193556c30fa1d8f9ab51fb2a92a2" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a variant type or record type with exactly the constructors or fields specified. All users of the structure have access to the constructors or fields, and can use them to create or inspect values of that type. However, users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95162088ecc49c178a74b8a108f2f06d181cf540" translate="yes" xml:space="preserve">
          <source>The type of (read-only) character strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb54904d6ce772d0ceeac1ee805267485217e2e" translate="yes" xml:space="preserve">
          <source>The type of (writable) byte sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175f1511e76274de17f3f982e04261ad9ff87edf" translate="yes" xml:space="preserve">
          <source>The type of Oo.copy is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9cbb3bbfa2f749813e7746851407d1f9f2830e" translate="yes" xml:space="preserve">
          <source>The type of PRNG states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f20f1f9fb27d1be581c722308fe57e5261bca48" translate="yes" xml:space="preserve">
          <source>The type of a generator module depends on the kind of generated documentation. Here is the list of generator module types, with the name of the generator class in the module &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f3bef48e012323310e56008b546bd70a23ee79" translate="yes" xml:space="preserve">
          <source>The type of a generator module depends on the kind of generated documentation. Here is the list of generator module types, with the name of the generator class in the module :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474468ccde94e04dc6d84d6aa522d6290591ae8e" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49335a2fa0da36592772610d625d9e7862131665" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays). A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program. Note that finalisation functions are run before the weak pointers are erased, because the finalisation functions can make values alive again (before 4.03 the finalisation functions were run after).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b210af5769dfe8a33b57a953fcf512009f49e6" translate="yes" xml:space="preserve">
          <source>The type of arrays whose elements have type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa11f3c01ba5678ddec397106bd88a162c4f603" translate="yes" xml:space="preserve">
          <source>The type of binary semaphores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0595a4cfa984f250f4abe368aae01bbd26bbe40a" translate="yes" xml:space="preserve">
          <source>The type of booleans (truth values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f43364adb027e8e1ba3b2312688a97e5a4bfee" translate="yes" xml:space="preserve">
          <source>The type of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa31d4f6bd583eef19e62cfd7cf4d795b85cb0" translate="yes" xml:space="preserve">
          <source>The type of commands for &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3f99b8924ec20003595b05b507f3dd92f84242" translate="yes" xml:space="preserve">
          <source>The type of communication channels carrying values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bee64553824e660fa6229cc5c7107b80d346c9" translate="yes" xml:space="preserve">
          <source>The type of communication events returning a result of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4694bbb21fec365f7f23def5ef3c32491f195566" translate="yes" xml:space="preserve">
          <source>The type of compiled regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf94d66ebaa6a6bac9b3992799eba28dae304024" translate="yes" xml:space="preserve">
          <source>The type of complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9493cdeccb2ee09d3bbc2192a85ea88bdc22d219" translate="yes" xml:space="preserve">
          <source>The type of complex numbers. &lt;code&gt;re&lt;/code&gt; is the real part and &lt;code&gt;im&lt;/code&gt; the imaginary part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919227d85c7433279106182e9342eaf933551d4" translate="yes" xml:space="preserve">
          <source>The type of condition variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ad31aa390bde5b9b9c5ae8b258ccd255d3a30c" translate="yes" xml:space="preserve">
          <source>The type of counting semaphores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2948f756f59cbab66ed838f1fd09d9a51206608c" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b1cace17bd70c1c864fc3ccf8d84d6aeafa3b9" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;. Note that the concrete list node &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; is delayed under a closure, not a &lt;code&gt;lazy&lt;/code&gt; block, which means it might be recomputed every time we access it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528bf9052fce3ac6805ffa892e89bbfb27784ec6" translate="yes" xml:space="preserve">
          <source>The type of descriptors over opened directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a1434458aaedb356cff26edc4284a6edf9ec7" translate="yes" xml:space="preserve">
          <source>The type of digests: 16-character strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7f6fa3fdb11f6e5f157b97ab1334e5206abde6" translate="yes" xml:space="preserve">
          <source>The type of error codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374429438a468e5405acbf7c3ebd3a8090be7716" translate="yes" xml:space="preserve">
          <source>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aa20107e0953510225d3286a9c720778df2ae3" translate="yes" xml:space="preserve">
          <source>The type of exception values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9a06fd1a883a7ff59af6a47cff3a54b165e238" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a1b61ab121d17826ae99852665f41b9088bb6f" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g. &lt;code&gt;0o640&lt;/code&gt; is read and write for user, read for group, none for others</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd46f8d4353ac7fec53695a7079f8ba6a127a094" translate="yes" xml:space="preserve">
          <source>The type of float arrays with packed representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae512fb6e68d577ece237ab0b35021285c8a32b" translate="yes" xml:space="preserve">
          <source>The type of floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882f6167872619af22e623d191dbe06d50c3e5c8" translate="yes" xml:space="preserve">
          <source>The type of format strings. 'a is the type of the parameters of the format, 'f is the result type for the printf-style functions, 'b is the type of the first argument given to %a and %t printing functions (see module &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt;), 'c is the result type of these functions, and also the type of the argument transmitted to the first argument of kprintf-style functions, 'd is the result type for the scanf-style functions (see module &lt;a href=&quot;libref/scanf&quot;&gt;Scanf&lt;/a&gt;), and 'e is the type of the receiver function for the scanf-style functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c398a9ad6d40134bc9da4aab8cb49e3ed44b56" translate="yes" xml:space="preserve">
          <source>The type of formatted input scanners: &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if &lt;code&gt;scan&lt;/code&gt; is some formatted input function, then &lt;code&gt;scan&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all the arguments specified by format string &lt;code&gt;fmt&lt;/code&gt;, when &lt;code&gt;scan&lt;/code&gt; has read those arguments from the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel &lt;code&gt;ic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea5a1b18ac88613e37414b6827c2703455101bb" translate="yes" xml:space="preserve">
          <source>The type of hash tables from type &lt;code&gt;'a&lt;/code&gt; to type &lt;code&gt;'b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696255785a919ef1978b95f3b810845f1d5f24f3" translate="yes" xml:space="preserve">
          <source>The type of input channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733bfc9210840c12ac529e5664090014cfaed19" translate="yes" xml:space="preserve">
          <source>The type of integer numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a16543916e281f6e705178f7068ae7b81eabd0" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6ff741c03d54a16b116276f6d1b7c29c419556" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b78930ebe1ff9598f2ce1e960c8d2f960ca9edd" translate="yes" xml:space="preserve">
          <source>The type of lists whose elements have type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4c8fdad1b3bd84e4c3cca78b35e83c55b502de" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498bd9a851a6cfafcb8f5766233f38fdc36ca792" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces. &lt;code&gt;start_char&lt;/code&gt; and &lt;code&gt;end_char&lt;/code&gt; are positions relative to the beginning of the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed706b6a75175b21f33900096f47f5ce25dcd56f" translate="yes" xml:space="preserve">
          <source>The type of maps from type &lt;code&gt;key&lt;/code&gt; to type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5234180ce852e2c9add54e2a43fe30af56ce71bf" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7ce6248520399ff389ae062f84b764cade9171" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations. This is the type of records passed to the callback triggered by the sampling of an allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e287e9bbc376eb420f29d58e9d26ead8ee6aa7" translate="yes" xml:space="preserve">
          <source>The type of mutexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a3a571763275675b862ae9f296a04facfd9dc7" translate="yes" xml:space="preserve">
          <source>The type of one-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427b82aee3c183b2b5534df6717057b224234245" translate="yes" xml:space="preserve">
          <source>The type of optional values of type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a247986af85700af0514a9a8547e14b281ce0624" translate="yes" xml:space="preserve">
          <source>The type of output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4593e8016738b30531d3a2d698c5003680100a" translate="yes" xml:space="preserve">
          <source>The type of queues containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed3d947a75f974c4a636eeee9cca0bdcea8439d" translate="yes" xml:space="preserve">
          <source>The type of references (mutable indirection cells) containing a value of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c47f9a8e4ac2d5a708feb705e0eb216916eb90e" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641cb810f5f62717bfd7cda0a11b14f8777c6464" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9a74d002d27ad159cff07bde988e8e266d179" translate="yes" xml:space="preserve">
          <source>The type of sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e670e3a2a21e4cdf70bf2240d4a5a94082c733" translate="yes" xml:space="preserve">
          <source>The type of signed 32-bit integers. Literals for 32-bit integers are suffixed by l. See the &lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049aa2f5e1bceacd2dc3e7900753d299e293a211" translate="yes" xml:space="preserve">
          <source>The type of signed 64-bit integers. Literals for 64-bit integers are suffixed by L. See the &lt;a href=&quot;libref/int64&quot;&gt;Int64&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14572b24035765d23bfc1ab5989635cd85be76c9" translate="yes" xml:space="preserve">
          <source>The type of signed, platform-native integers (32 bits on 32-bit processors, 64 bits on 64-bit processors). Literals for native integers are suffixed by n. See the &lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5b2958f6bf6b0150e2e607a78d659c4f79eb05" translate="yes" xml:space="preserve">
          <source>The type of socket addresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db586c580808d7d4b0a9c2a68894ac1deac9713a" translate="yes" xml:space="preserve">
          <source>The type of socket addresses. &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; is a socket address in the Unix domain; &lt;code&gt;name&lt;/code&gt; is a file name in the file system. &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; is a socket address in the Internet domain; &lt;code&gt;addr&lt;/code&gt; is the Internet address of the machine, and &lt;code&gt;port&lt;/code&gt; is the port number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608407eaec3033fe97cbe414b0ad430f843c8db2" translate="yes" xml:space="preserve">
          <source>The type of socket domains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d14d79c33e13c0f239ad5001df98545855ce4a" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b519e0b22d95beab7899e8dfff601ea38a0a80e" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;). Windows does not support &lt;code&gt;PF_UNIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2727d81576dab1fb5a38c8713ea564ef66856040" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3007fcdc44e3284ad3118e0dffc7d71aaf743c" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications. &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; is included for completeness, but is rarely supported by the OS, and needs system calls that are not available in this library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e03b4fa592223c0c98868c0491cee08f03432" translate="yes" xml:space="preserve">
          <source>The type of stacks containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f65d04f78e3ceb4ae3eccd621111d1fffe7fea7" translate="yes" xml:space="preserve">
          <source>The type of streams holding values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6765ffbd6cdd35348726a7b361a85542a02c62ba" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f05d8ed34a2aeecd6a307e47d3388f2f3349d" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;. Note that weak hash sets cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee1409d00d5fb4980f4ba74e5a57012a5c95891" translate="yes" xml:space="preserve">
          <source>The type of the allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376291c83380bfe855667ba5075e67da3fc440d1" translate="yes" xml:space="preserve">
          <source>The type of the elements stored in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a01f06c2807810d54d563bff488d148e91f692" translate="yes" xml:space="preserve">
          <source>The type of the hashtable keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419849ba8c429fc85eb7b7159392b7645493c383" translate="yes" xml:space="preserve">
          <source>The type of the map keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c0446d50346f3a3a5ced32244b2b1d6aa72fb4" translate="yes" xml:space="preserve">
          <source>The type of the set elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9b34617afb59cca236cf1ed744d053aeba331d" translate="yes" xml:space="preserve">
          <source>The type of the unit value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558f0da7756d6b8a5e6fa053bc9e88665bde8e00" translate="yes" xml:space="preserve">
          <source>The type of this expression, t, contains type variables that cannot be generalized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38374ae48a76fc267fc266e7d1fb3adac8f8923" translate="yes" xml:space="preserve">
          <source>The type of thread handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911e648755e2ce01883554d3b0a3d8fbef08dfa3" translate="yes" xml:space="preserve">
          <source>The type of three-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93d7af7669a780db37d7a6a35b93628bedc91cc" translate="yes" xml:space="preserve">
          <source>The type of tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fe884e37cec8d7d8dffba0f78cacab0927a183" translate="yes" xml:space="preserve">
          <source>The type of tokens. The lexical classes are: &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; for integer and floating-point numbers; &lt;code&gt;String&lt;/code&gt; for string literals, enclosed in double quotes; &lt;code&gt;Char&lt;/code&gt; for character literals, enclosed in single quotes; &lt;code&gt;Ident&lt;/code&gt; for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc); and &lt;code&gt;Kwd&lt;/code&gt; for keywords (either identifiers or single 'special characters' such as &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a131ee154ce5805d4743ddd4e7ac6f8f0a846600" translate="yes" xml:space="preserve">
          <source>The type of two-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1acfc22850de31c2fb5225a9fc570f7727191c" translate="yes" xml:space="preserve">
          <source>The type of zero-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3babab89ffd173e9518cc78562c29d921585ef" translate="yes" xml:space="preserve">
          <source>The type parameter in the declaration may actually be constrained in the body of the class definition. In the class type, the actual value of the type parameter is displayed in the constraint clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5037564652e82350a92a754ff0cf691d4922b52e" translate="yes" xml:space="preserve">
          <source>The type representation = [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; } describes a variant type. The constructor declarations &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the constructors associated to this variant type. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a non-constant constructor, whose arguments have types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a constant constructor. Constructor names must be capitalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb673b534c3fd2e98456972d5696bd025fa4d55" translate="yes" xml:space="preserve">
          <source>The type representation ={&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; { ;&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;] } describes a record type. The field declarations &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the fields associated to this record type. The field declaration &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; declares &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; as a field whose argument has type &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;. The field declaration mutable&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;  behaves similarly; in addition, it allows physical modification of this field. Immutable fields are covariant, mutable fields are non-variant. Both mutable and immutable fields may have explicitly polymorphic types. The polymorphism of the contents is statically checked whenever a record value is created or modified. Extracted values may have their types instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc55907fc102b663d0673eb99112e552f4a435a" translate="yes" xml:space="preserve">
          <source>The type representing wallclock time and calendar date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719afb56f810f882e663e05949b4c0135dc8e565" translate="yes" xml:space="preserve">
          <source>The type variables appearing as type parameters can optionally be prefixed by + or - to indicate that the type constructor is covariant or contravariant with respect to this parameter. This variance information is used to decide subtyping relations when checking the validity of :&amp;gt; coercions (see section &lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4bb1f94026133ed9e6ee3397f9022a4a5493c7" translate="yes" xml:space="preserve">
          <source>The types and their meanings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf539767254769cb84eb0b1abbb2be61f0f57486" translate="yes" xml:space="preserve">
          <source>The typical usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae726f6193a47e436bd7b538894c5c73fa741bdc" translate="yes" xml:space="preserve">
          <source>The typical use of &lt;a href=&quot;unix#VAL_exit&quot;&gt;&lt;code&gt;Unix._exit&lt;/code&gt;&lt;/a&gt; is after a &lt;a href=&quot;unix#VALfork&quot;&gt;&lt;code&gt;Unix.fork&lt;/code&gt;&lt;/a&gt; operation, when the child process runs into a fatal error and must exit. In this case, it is preferable to not perform any finalization action in the child process, as these actions could interfere with similar actions performed by the parent process. For example, output channels should not be flushed by the child process, as the parent process may flush them again later, resulting in duplicate output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2cdbd104780129e6eb6af11e6842e3411789d0" translate="yes" xml:space="preserve">
          <source>The typical use of private types is in the export signature of a module, to ensure that construction of values of the private type always go through the functions provided by the module, while still allowing pattern-matching outside the defining module. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76fc86bc826ecd117df214c518ef9dca7c54b653" translate="yes" xml:space="preserve">
          <source>The typing of immediate objects is slightly different from explicitly defining a class in two respects. First, the inferred object type may contain free type variables. Second, since the class body of an immediate object will never be extended, its self type can be unified with a closed object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379766838ae430347d582312c2b9bd97e93485b9" translate="yes" xml:space="preserve">
          <source>The typing of pattern matching in presence of GADT can generate many existential types. When necessary, error messages refer to these existential types using compiler-generated names. Currently, the compiler generates these names according to the following nomenclature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b139709c938696abfe6558bd71c73b15692ae467" translate="yes" xml:space="preserve">
          <source>The unit type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f157a3529b6639761d0fe3370101d0cd58a51217" translate="yes" xml:space="preserve">
          <source>The unit type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f35cce1a1526a7e3fbd7d34502e07f914d39ed" translate="yes" xml:space="preserve">
          <source>The unix library makes many Unix system calls and system-related library functions available to OCaml programs. This chapter describes briefly the functions provided. Refer to sections 2 &amp;zwj;and &amp;zwj;3 of the Unix manual for more details on the behavior of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7a079da5bd24c487f37916205b8998acfd3262" translate="yes" xml:space="preserve">
          <source>The unix library makes many Unix system calls and system-related library functions available to OCaml programs. This chapter describes briefly the functions provided. Refer to sections 2 and 3 of the Unix manual for more details on the behavior of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f8335838db8a8ae9ab9030edc50991b021708a" translate="yes" xml:space="preserve">
          <source>The unrolling depth applies to calls within the same mutually-recursive group of functions. Each time an inlining of such a call is performed the depth is incremented by one when examining the resulting body. If the depth reaches the limit set by -inline-max-unroll then speculation stops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef46466283aedcffa1e3418737dde034112c7cb9" translate="yes" xml:space="preserve">
          <source>The unused specialised argument f may now be removed, leaving:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25fc5451b4b7e9e596e2f95c2648b7f2f987a8b" translate="yes" xml:space="preserve">
          <source>The usage for ocamlrun is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf174ec233170184c634afe9d8c6e98683f2f9c" translate="yes" xml:space="preserve">
          <source>The user must make sure that the parameter &lt;code&gt;s&lt;/code&gt; is the same string that was passed to the matching or searching function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03d2d6cd25c13447899f1193d309cb6b8e6e6bf" translate="yes" xml:space="preserve">
          <source>The user starts manually the program, when asked by the debugger. Allows remote debugging (see section &amp;zwj;&lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;16.8.8&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc30db23fbb2629fd5d6a40fb9f9a4aa615d10c" translate="yes" xml:space="preserve">
          <source>The user starts manually the program, when asked by the debugger. Allows remote debugging (see section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642aefa1c3276d4815d6372b5c2ba0e28849644d" translate="yes" xml:space="preserve">
          <source>The value of lazy_two is displayed as &amp;lt;lazy&amp;gt;, which means the expression has not been evaluated yet, and its final value is unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44eeca632e1ee708a87c7d08ac7f919078da583" translate="yes" xml:space="preserve">
          <source>The value path printer-name must refer to one of the functions defined by the object files loaded using load_printer. It cannot reference the functions of the program being debugged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213346982c2b5edd8a2868f6648a75de11f3a7a1" translate="yes" xml:space="preserve">
          <source>The value restriction combined with this generalization for covariant type parameters is called the relaxed value restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e457e086f638356c025d7f98eea16073334d087" translate="yes" xml:space="preserve">
          <source>The variance indicated by the + and - annotations on parameters is enforced only for abstract and private types, or when there are type constraints. Otherwise, for abbreviations, variant and record types without type constraints, the variance properties of the type constructor are inferred from its definition, and the variance annotations are only checked for conformance with the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c84e520b4d58847b9a0936e0ff6718cecdfce8" translate="yes" xml:space="preserve">
          <source>The variant &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; is provided, that returns the exception instead of raising it directly into OCaml code. Its result must be tested using Is_exception_result, and followed by Extract_exception if appropriate. It is typically used for clean up before re-raising:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3e8b9825c91e7d1c1de2e5964ef9a6faa3a9d6" translate="yes" xml:space="preserve">
          <source>The variant value `VConstr is represented by hash_variant(&quot;VConstr&quot;). The variant value `VConstr(v) is represented by a block of size 2 and tag 0, with field number 0 containing hash_variant(&quot;VConstr&quot;) and field number 1 containing v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7a7371cf1264e74123560fc9eaab0ccf8deadd" translate="yes" xml:space="preserve">
          <source>The version number for the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12195f2bfc0b341eebc2706c0f898b85f60cd39" translate="yes" xml:space="preserve">
          <source>The warning-list argument is a sequence of warning specifiers, with no separators between them. A warning specifier is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3155774bd8f5952cba7da2b05dd2d603a1c4e3ad" translate="yes" xml:space="preserve">
          <source>The with part does pattern matching on the exception value with the same syntax and behavior as match. Thus, several exceptions can be caught by one try&amp;hellip;with construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bee62c92457d9c1edd0b95b70b38529cd1e173d" translate="yes" xml:space="preserve">
          <source>The workaround is easy: you should put a type constraint on the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5abc2079ccb81595a85c637140e96ed3e00651" translate="yes" xml:space="preserve">
          <source>Then, the following command uses custom.cma as custom generator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ff4a021d393fa87cf695d354fe2d1e4838a3f6" translate="yes" xml:space="preserve">
          <source>There are no type expressions describing (defined) variant types nor record types, since those are always named, i.e. defined before use and referred to by name. Type definitions are described in section &amp;zwj;&lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da202378d7326ed462fca4e0c21921b3c299f46" translate="yes" xml:space="preserve">
          <source>There are no type expressions describing (defined) variant types nor record types, since those are always named, i.e. defined before use and referred to by name. Type definitions are described in section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed327f049e48284a0a623ce9851b6b43632572d" translate="yes" xml:space="preserve">
          <source>There are several restrictions on &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5816a972e7e95d82645db243fd7e0a0acf5b5d4" translate="yes" xml:space="preserve">
          <source>There are six CAMLparam macros: CAMLparam0 to CAMLparam5, which take zero to five arguments respectively. If your function has no more than 5 parameters of type value, use the corresponding macros with these parameters as arguments. If your function has more than 5 parameters of type value, use CAMLparam5 with five of these parameters, and use one or more calls to the CAMLxparam macros for the remaining parameters (CAMLxparam1 to CAMLxparam5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a70237d0ffb18913597dc8bc48a2788fdf2980" translate="yes" xml:space="preserve">
          <source>There are two drawbacks to dynamic linking. The first is that the resulting executable is not stand-alone: it requires the shared libraries, as well as ocamlrun, to be installed on the machine executing the code. If you wish to distribute a stand-alone executable, it is better to link it statically, using ocamlc -custom -ccopt -static or ocamlopt -ccopt -static. Dynamic linking also raises the &amp;ldquo;DLL hell&amp;rdquo; problem: some care must be taken to ensure that the right versions of the shared libraries are found at start-up time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66d252bf6e5adb16a8a81b0a31bcc98e8083e8f" translate="yes" xml:space="preserve">
          <source>There are two exceptions: for constructors and record fields in type definitions, the associated comment can only be placed after the constructor or field definition, without blank lines or other comments between them. The special comment for a constructor with another constructor following must be placed before the &amp;rsquo;|&amp;rsquo; character separating the two constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eea4041f7bae7ed250a35d69c8993bc99a56a95" translate="yes" xml:space="preserve">
          <source>There are two valid use-cases that respect this ownership discipline:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4c01af210fd3e27d304b7f41d713af6236e4a1" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain OCaml function values (closures) to be passed to the callback functions described above. One way is to pass the OCaml function as an argument to a primitive function. For example, if the OCaml code contains the declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1be669f2eb3042b085336308606e766c589b14c" translate="yes" xml:space="preserve">
          <source>There is a printf function in the &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; module (see chapter &amp;zwj;&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;) that allows you to make formatted output more concisely. It follows the behavior of the printf function from the C standard library. The printf function takes a format string that describes the desired output as a text interspersed with specifiers (for instance %d, %f). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f796d8197ff409294fcb0b2b9480a2ce5fecdc08" translate="yes" xml:space="preserve">
          <source>There is a printf function in the &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;) that allows you to make formatted output more concisely. It follows the behavior of the printf function from the C standard library. The printf function takes a format string that describes the desired output as a text interspered with specifiers (for instance %d, %f). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0926f9a5aad069ce9f290befa2171e8e69385aeb" translate="yes" xml:space="preserve">
          <source>There is a single classification for coeffects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86860c4a3904e32a0066d40f9221fe10cbd4529f" translate="yes" xml:space="preserve">
          <source>There is a single input (the string &amp;ldquo;secret code&amp;rdquo;) which causes this program to crash, but finding it by blind random search is infeasible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f530a5d8b189e6bec332a6ff74e1e85c4100c796" translate="yes" xml:space="preserve">
          <source>There is an additional lexical rule to escape the special characters &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;'@'&lt;/code&gt; in format strings: if a special character follows a &lt;code&gt;'%'&lt;/code&gt; character, it is treated as a plain character. In other words, &lt;code&gt;&quot;%%&quot;&lt;/code&gt; is considered as a plain &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;&quot;%@&quot;&lt;/code&gt; as a plain &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89300e6e8eb5caa8716a6d136ca3ce59e33af664" translate="yes" xml:space="preserve">
          <source>There is another partial solution to the problem of unnecessary weak type, which is implemented directly within the type checker. Briefly, it is possible to prove that weak types that only appear as type parameters in covariant positions &amp;ndash;also called positive positions&amp;ndash; can be safely generalized to polymorphic types. For instance, the type 'a list is covariant in 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4839904c7c8092d09c24e4a4ca03c2ca6d8ace01" translate="yes" xml:space="preserve">
          <source>There is another, more direct way to create an object: create it without going through a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6713ccaa14a77e18cc0d165c630249a7f39edf84" translate="yes" xml:space="preserve">
          <source>There is no blank line or another special comment between the special comment and the element. However, a regular comment can occur between the special comment and the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420c7eecf9b88f0fd685ede8cd7d5594dccc6b10" translate="yes" xml:space="preserve">
          <source>There is no linearity restriction over as bound variables. When a variable is bound more than once, the previous rules are to be extended as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2df4086644aefdc6d4fa1daff752de72504dccd" translate="yes" xml:space="preserve">
          <source>There is nothing particular about functors that inhibits inlining compared to normal functions. To the inliner, these both look the same, except that functors are marked as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7526b0137b40ba5befc330c948531d764b9b23" translate="yes" xml:space="preserve">
          <source>There is sometimes an alternative between using modules or classes for parametric data types. Indeed, there are situations when the two approaches are quite similar. For instance, a stack can be straightforwardly implemented as a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6f12e3992f209be063993c601fdba9acbc537c" translate="yes" xml:space="preserve">
          <source>Therefore, after placing an int in store, we cannot use it to store any value other than an int. More generally, weak types protect the program from undue mutation of values with a polymorphic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c813ad0d9ef31d493524a8ea85262d92050cce" translate="yes" xml:space="preserve">
          <source>These .cmt and .cmti files are typically useful for code inspection tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69311f08c70520540fee4cbe4bda7e98116c0238" translate="yes" xml:space="preserve">
          <source>These annotations explicitly require the defined value to be polymorphic, and allow one to use this polymorphism in recursive occurrences (when using letrec). Note however that this is a normal polymorphic type, unifiable with any instance of itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e7d9c598d98633999ba13a3dcc444ba12214ad" translate="yes" xml:space="preserve">
          <source>These eleven name spaces are distinguished both by the context and by the capitalization of the identifier: whether the first letter of the identifier is in lowercase (written &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; below) or in uppercase (written &lt;a href=&quot;lex#capitalized-ident&quot;&gt;capitalized-ident&lt;/a&gt;). Underscore is considered a lowercase letter for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870297f2b83ed8726b893d830c917d6f224b681b" translate="yes" xml:space="preserve">
          <source>These files reside in the caml/ subdirectory of the OCaml standard library directory, which is returned by the command ocamlc -where (usually /usr/local/lib/ocaml or /usr/lib/ocaml).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be7b63190a743842c43dfb1591048d46124470c" translate="yes" xml:space="preserve">
          <source>These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239ea6a3f14d9dc171a9d56f5158d10f257a786d" translate="yes" xml:space="preserve">
          <source>These functions are used to traverse the slots of a raw backtrace and extract information from them in a programmer-friendly format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f25166bb6e1a3aa7c0d7c601a90c21f11c48cf" translate="yes" xml:space="preserve">
          <source>These functions poll for pending signals by calling asynchronous callbacks (section &amp;zwj;&lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;18.5.3&lt;/a&gt;) before releasing and after acquiring the lock. They can therefore execute arbitrary OCaml code including raising an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf57b7b10c266fa7ea278e39e177192d8ca0786" translate="yes" xml:space="preserve">
          <source>These functions poll for pending signals by calling asynchronous callbacks (section &lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt;) before releasing and after acquiring the lock. They can therefore execute arbitrary OCaml code including raising an asynchronous exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1ff51841b268ac0bc83ac53b16b105790d419d" translate="yes" xml:space="preserve">
          <source>These functions return immediately &lt;code&gt;true&lt;/code&gt; in the Win32 implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce3216765c88e5c48af00b3c110ef4d63384284" translate="yes" xml:space="preserve">
          <source>These goals are often reached not just by inlining itself but also by other optimisations that the compiler is able to perform as a result of inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4386b22d00bf9e30129abfc3148f83106ab4fda2" translate="yes" xml:space="preserve">
          <source>These options are passed as is to ocamlc or ocamlopt. See the documentation of these commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484df2de1a8035aff891a6ad2ca2a206e2085ae8" translate="yes" xml:space="preserve">
          <source>These options are passed as is to the C compiler. Refer to the documentation of the C compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeaa8b4b44d8ce0bdc7032fda14b43069cb254a" translate="yes" xml:space="preserve">
          <source>These options are useful when you have, for example, a type and a value with the same name. If you do not specify prefixes, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X will complain about multiply defined labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd109aa38e89265e3d535e5b8837cacc7cebe8b5" translate="yes" xml:space="preserve">
          <source>These parameters are ultimately bounded by the arguments provided to the corresponding command-line flags (or their default values):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201eef9e30770a6e41dd8bf1c6f8c6e7106ea2b8" translate="yes" xml:space="preserve">
          <source>These program generators are very close to the well-known lex and yacc commands that can be found in most C programming environments. This chapter assumes a working knowledge of lex and yacc: while it describes the input syntax for ocamllex and ocamlyacc and the main differences with lex and yacc, it does not explain the basics of writing a lexer or parser description in lex and yacc. Readers unfamiliar with lex and yacc are referred to &amp;ldquo;Compilers: principles, techniques, and tools&amp;rdquo; by Aho, Sethi and Ullman (Addison-Wesley, 1986), or &amp;ldquo;Lex &amp;amp; Yacc&amp;rdquo;, by Levine, Mason and Brown (O&amp;rsquo;Reilly, 1992).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01d3add6122970dc3dbf24500aab00b1c8c4545" translate="yes" xml:space="preserve">
          <source>These text messages are usually not stable over time: call sites building these constructors may refine the message in a future version to make it more explicit, etc. Therefore, it is dangerous to match over the precise value of the message. For example, until OCaml 4.02, Array.iter2 would raise the exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056363d88c08f1781faea018bb808d8587eb9a45" translate="yes" xml:space="preserve">
          <source>These two files together define a structure named A as if the following definition was entered at top-level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3373b0a618202574e74bfc05210cbd553b7e77" translate="yes" xml:space="preserve">
          <source>These weakened dependencies make possible to use module aliases in place of the -pack mechanism. Suppose that you have a library Mylib composed of modules A and B. Using -pack, one would issue the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e847d2a87ac8165d8955c02fcafa07afd4fca2" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. Detailed interfaces can be found in &lt;code&gt;arrayLabels.mli&lt;/code&gt;, &lt;code&gt;bytesLabels.mli&lt;/code&gt;, &lt;code&gt;listLabels.mli&lt;/code&gt; and &lt;code&gt;stringLabels.mli&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b235c592e19c9ae8ea4fa2dac4a8048ec27fa43" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. They are provided to help porting from previous versions of OCaml. The contents of this module are subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9349ea824b32cbc75b5ac69fdc3a31eb2e505a" translate="yes" xml:space="preserve">
          <source>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section &amp;zwj;&lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e865936f70f95a35530da646f08d349c8618ab8" translate="yes" xml:space="preserve">
          <source>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section &lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4da690687d8f30331d0881e81b870c14418b6d" translate="yes" xml:space="preserve">
          <source>This allows delaying the formatting of backtraces to when they are actually printed, which may be useful if you record more backtraces than you print.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf2b05351c309723aa496873af8b5e1e89659d8" translate="yes" xml:space="preserve">
          <source>This allows the following idiom, keeping a list of all objects belonging to a class or its subclasses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f29de16e9f8798d1932dbc922db0d447425dac" translate="yes" xml:space="preserve">
          <source>This approach lets you access A and B directly inside the library, and as Mylib.A and Mylib.B from outside. It also has the advantage that Mylib is no longer monolithic: if you use Mylib.A, only Mylib__A will be linked in, not Mylib__B.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1372a67563bf716e071b3b183d02ea2f598a4156" translate="yes" xml:space="preserve">
          <source>This attribute is attached to a function application and always takes an integer argument. Each time the inliner sees the attribute it behaves as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b4b8d9fa337a2eb876a44b79cb348c9e5f0855" translate="yes" xml:space="preserve">
          <source>This box behaves as an horizontal box if it fits on a single line, otherwise it behaves as a vertical box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7625b4398585ec56f1ee579a0692c7819ab1dcb" translate="yes" xml:space="preserve">
          <source>This box features command &lt;code&gt;set_tab&lt;/code&gt; to define cell boundaries, and command &lt;code&gt;print_tab&lt;/code&gt; to move from cell to cell and split the line when there is no more cells to print on the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d886ace2f3bb025615806e435389e25f058b58" translate="yes" xml:space="preserve">
          <source>This box is the general purpose pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4790a08c0b8ba22758a78bbaf58c7ad274884241" translate="yes" xml:space="preserve">
          <source>This box prints lines separated into cells of fixed width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9521c4e75869b633ff289e3509ef90a59f7e6d5f" translate="yes" xml:space="preserve">
          <source>This box prints material as much as possible on every line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4388d065629c7972988d67b92adade884cfc189" translate="yes" xml:space="preserve">
          <source>This box prints material on a single line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed97b2eb7c12b24bf9da6774de6d18d44c03f8a" translate="yes" xml:space="preserve">
          <source>This box prints material on as many lines as break hints in the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac037b45f5205c0421d44bb0a7e2d59de5d5640" translate="yes" xml:space="preserve">
          <source>This builds a runtime system with the required primitives. The OCaml linker generates bytecode for this custom runtime system. The bytecode is appended to the end of the custom runtime system, so that it will be automatically executed when the output file (custom runtime + bytecode) is launched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b017452d5ed8ae35ceea59902e09d1ad45c8bde1" translate="yes" xml:space="preserve">
          <source>This can be used as a replacement for &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; to delay formatting decisions. Using the string returned by &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; in a formatting context forces formatting decisions to be taken in isolation, and the final string may be created prematurely. &lt;a href=&quot;format#VALdprintf&quot;&gt;&lt;code&gt;Format.dprintf&lt;/code&gt;&lt;/a&gt; allows delay of formatting decisions until the final formatting context is known. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736b6a8d2382f934d9e36c672b75eae9562bc868" translate="yes" xml:space="preserve">
          <source>This case combines the previous two: the representation of the type is made visible to all users, and no fresh type is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0b9d32c2c99f0a8a9065915f71e59738d0f44f" translate="yes" xml:space="preserve">
          <source>This chapter covers more advanced questions related to the limitations of polymorphic functions and types. There are some situations in OCaml where the type inferred by the type checker may be less generic than expected. Such non-genericity can stem either from interactions between side-effect and typing or the difficulties of implicit polymorphic recursion and higher-rank polymorphism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522dedf7b87d3fe7e1de4f1b9ea15db17ac665a1" translate="yes" xml:space="preserve">
          <source>This chapter describes OCamldoc, a tool that generates documentation from special comments embedded in source files. The comments used by OCamldoc are of the form (**&amp;hellip;*) and follow the format described in section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;15.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99967e6f113e515abf96820acbd0c907f9ea256" translate="yes" xml:space="preserve">
          <source>This chapter describes OCamldoc, a tool that generates documentation from special comments embedded in source files. The comments used by OCamldoc are of the form (**&amp;hellip;*) and follow the format described in section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22979b22da128bdede671815a07fda413464a01f" translate="yes" xml:space="preserve">
          <source>This chapter describes how the execution of OCaml programs can be profiled, by recording how many times functions are called, branches of conditionals are taken, &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc58c64bbca12c120e6be347ae738db5e914ab57" translate="yes" xml:space="preserve">
          <source>This chapter describes how user-defined primitives, written in C, can be linked with OCaml code and called from OCaml functions, and how these C functions can call back to OCaml code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d06c319871b2fca85b3fcbf3d8380ae5ce1f88" translate="yes" xml:space="preserve">
          <source>This chapter describes language extensions and convenience features that are implemented in OCaml, but not described in chapter &lt;a href=&quot;language#c%3Arefman&quot;&gt;7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084829076e627e4169c9229a38a24e09ad828c7b" translate="yes" xml:space="preserve">
          <source>This chapter describes language extensions and convenience features that are implemented in OCaml, but not described in the OCaml reference manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995a07b1158b72f353eb1ac428ac4123f6853088" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml batch compiler ocamlc, which compiles OCaml source files to bytecode object files and links these object files to produce standalone bytecode executable files. These executable files are then run by the bytecode interpreter ocamlrun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b065bf42750f41d77bac34c5d6dddd1489b34a0" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml core library, which is composed of declarations for built-in types and exceptions, plus the module Stdlib that provides basic operations on these built-in types. The Stdlib module is special in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd90dbae49e1f320d3af306460277830649c6309" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml front-end, which declares the abstract syntax tree used by the compiler, provides a way to parse, print and pretty-print OCaml code, and ultimately allows one to write abstract syntax tree preprocessors invoked via the -ppx flag (see chapters &amp;zwj;&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &amp;zwj;&lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36bc4b25a8de2e3c8b0cfa69654d56ac54e08f29" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml front-end, which declares the abstract syntax tree used by the compiler, provides a way to parse, print and pretty-print OCaml code, and ultimately allows one to write abstract syntax tree preprocessors invoked via the -ppx flag (see chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5ce841e2ff9db70cbc0f9643176a189658c748" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml high-performance native-code compiler ocamlopt, which compiles OCaml source files to native code object files and links these object files to produce standalone executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07729068091da08d36b2e49ba6d4e4d523bd49f5" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ddd94c98a17da2cbc644dd1e169145a2b86378" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml source-level replay debugger ocamldebug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3bef73d988061d29d6941712ad9747d92ad9a4" translate="yes" xml:space="preserve">
          <source>This chapter describes the functions provided by the OCaml standard library. The modules from the standard library are automatically linked with the user&amp;rsquo;s object code files by the ocamlc command. Hence, these modules can be used in standalone programs without having to add any .cmo file on the command line for the linking phase. Similarly, in interactive use, these globals can be used in toplevel phrases without having to load any .cmo file in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ad0f253c7b2080f9dd53e8aa8d98648421148a" translate="yes" xml:space="preserve">
          <source>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system through a read-eval-print loop (REPL). In this mode, the system repeatedly reads OCaml phrases from the input, then typechecks, compile and evaluate them, then prints the inferred type and result value, if any. The system prints a # (sharp) prompt before reading each phrase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eaa3d075690cc435be03284e22882527590fd09" translate="yes" xml:space="preserve">
          <source>This chapter describes three libraries which were formerly part of the OCaml distribution (Graphics, Num, and LablTk), and a library which has now become part of OCaml&amp;rsquo;s standard library, and is documented there (Bigarray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c3d7e39acb1d5e622db5124a13613835b7634c" translate="yes" xml:space="preserve">
          <source>This chapter describes two program generators: ocamllex, that produces a lexical analyzer from a set of regular expressions with associated semantic actions, and ocamlyacc, that produces a parser from a grammar with associated semantic actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210573b7ce8135e7e064f066b6ebcd12cb7b792a" translate="yes" xml:space="preserve">
          <source>This chapter details each of these situations and, if it is possible, how to recover genericity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2681602b9187f866a2387ff78cec658492716" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the new features in OCaml 3: labels, and polymorphic variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3588c35304425734153b099a7cdbb31b7ab306d6" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the object-oriented features of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f743cd4aa8589a6f7ccb3236942f7a143fef8068" translate="yes" xml:space="preserve">
          <source>This chapter introduces the module system of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641fe4386aeca969ab9cc8d868ad085c0c8ea3bb" translate="yes" xml:space="preserve">
          <source>This construction is useful because the type constructors it introduces can be used in places where a type variable is not allowed. For instance, one can use it to define an exception in a local module within a polymorphic function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d44fb398c8f2ad20178f128be9005c0c3a7520" translate="yes" xml:space="preserve">
          <source>This correspond to the commuting label mode of Objective Caml 3.00 through 3.02, with some additional flexibility on total applications. The so-called classic mode (-nolabels options) is now deprecated for normal use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f3f784e1b28dce9462db7a4f03b9575085de6b" translate="yes" xml:space="preserve">
          <source>This corresponds to the commuting label mode of Objective Caml 3.00 through 3.02, with some additional flexibility on total applications. The so-called classic mode (-nolabels options) is now deprecated for normal use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5634341302134670e8fa24213d20b7b796e20a4" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;IntHashtbl&lt;/code&gt;, with a new type &lt;code&gt;'a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; of tables from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;h&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0703f0be9e37d286e36c6f06a582f656747a10b9" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;IntHashtbl&lt;/code&gt;, with a new type &lt;code&gt;'a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; of tables from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;h&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d68deb1edda584ae4e6e7569ccd1f525a47a80" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsMap&lt;/code&gt;, with a new type &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; of maps from &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;m&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390961a477909cf3be486ca4a271404c23f7a126" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsSet&lt;/code&gt;, with a new type &lt;code&gt;PairsSet.t&lt;/code&gt; of sets of &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cd13267b497efe97847c8300244e98191e876f" translate="yes" xml:space="preserve">
          <source>This creates the bytecode file mytoplevel, containing the OCaml toplevel system, plus the code from the three .cmo files. This toplevel is directly executable and is started by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b1409a54230dba201ee4c701c307570dc6eae6" translate="yes" xml:space="preserve">
          <source>This declaration does more than hiding the y method, it also makes the type c incompatible with any other closed object type, meaning that only o will be of type c. In that respect it behaves similarly to private record types. But private row types are more flexible with respect to incremental refinement. This feature can be used in combination with functors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b4223715d06df11caf2304744d5adfa549ab4f" translate="yes" xml:space="preserve">
          <source>This declaration expresses that a value of type number is either an integer, a floating-point number, or the constant Error representing the result of an invalid operation (e.g. a division by zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650dca8821c23c4d144204d01cac7fd4b83e068e" translate="yes" xml:space="preserve">
          <source>This defines name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; as mutually recursive functions local to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9d147194e992eb8205321a938f103ca896c88b" translate="yes" xml:space="preserve">
          <source>This defines the type constructor as an abbreviation for the type expression on the right of the = sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749cd341985f67a650d96523cab212ab33c78584" translate="yes" xml:space="preserve">
          <source>This defines the value name name as a function with type type that executes by calling the given C function. For instance, here is how the int_of_string primitive is declared in the standard library module Stdlib:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6a7668ca6796a5f9aedc245a7fcfd4cb8617a2" translate="yes" xml:space="preserve">
          <source>This defines the value name name as a function with type type that executes by calling the given C function. For instance, here is how the seek_in primitive is declared in the standard library module Stdlib:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ba8edf36d0fb0da29929bdb415469de948dad5" translate="yes" xml:space="preserve">
          <source>This definition reads as follows: a binary tree containing values of type 'a (an arbitrary type) is either empty, or is a node containing one value of type 'a and two subtrees also containing values of type 'a, that is, two 'a btree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8e09fb17ca3bdcd19c8523134e3e779a73a386" translate="yes" xml:space="preserve">
          <source>This directive registers the function named printer-name (a value path) as a printer for values whose types match the argument type of the function. That is, the toplevel loop will call printer-name when it has such a value to print.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e68ea2c0517c1d20b6ed32dd8f6c253ddb6f201" translate="yes" xml:space="preserve">
          <source>This document is intended as a reference manual for the OCaml language. It lists the language constructs, and gives their precise syntax and informal semantics. It is by no means a tutorial introduction to the language: there is not a single example. A good working knowledge of OCaml is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74df0e696ad77b21b87792ac16ae61fcae218478" translate="yes" xml:space="preserve">
          <source>This engine makes it possible to implement a low-overhead memory profiler as an OCaml library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fa2a6f69f904187160e52f45b06e671158e7a1" translate="yes" xml:space="preserve">
          <source>This enters a regular toplevel loop, except that the code from foo.cmo, bar.cmo and gee.cmo is already loaded in memory, just as if you had typed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5c02e5a2be940db6035f15a82bb532610ff549" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link an incomplete or incorrectly ordered set of files. Either you have forgotten to provide an implementation for the compilation unit named mod on the command line (typically, the file named mod.cmo, or a library containing that file). Fix: add the missing .ml or .cmo file to the command line. Or, you have provided an implementation for the module named mod, but it comes too late on the command line: the implementation of mod must come before all bytecode object files that reference mod. Fix: change the order of .ml and .cmo files on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971e165e7f4a2dd830b3b93e7eea49f1ba8a83fb" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link code that calls external functions written in C. As explained in chapter &amp;zwj;&lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;18&lt;/a&gt;, such code must be linked with C libraries that implement the required f C function. If the C libraries in question are not shared libraries (DLLs), the code must be linked in &amp;ldquo;custom runtime&amp;rdquo; mode. Fix: add the required C libraries to the command line, and possibly the -custom option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01feea14de8e0c629d6af124eee3f63c75a3e58e" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link code that calls external functions written in C. As explained in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, such code must be linked with C libraries that implement the required f C function. If the C libraries in question are not shared libraries (DLLs), the code must be linked in &amp;ldquo;custom runtime&amp;rdquo; mode. Fix: add the required C libraries to the command line, and possibly the -custom option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3322e1b78b0d097c04a82c8abad2b9e17591c8f" translate="yes" xml:space="preserve">
          <source>This explicit overriding annotation also works for val and inherit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c31e1e38cacd668c448b1b245b9768d081710af" translate="yes" xml:space="preserve">
          <source>This expression evaluates to a functional value with one argument. When this function is applied to a value v, this value is matched against each pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If one of these matchings succeeds, that is, if the value v matches the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for some i, then the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; associated to the selected pattern is evaluated, and its value becomes the value of the function application. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during the matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e34d384bc13e41a20958589d5dd84188cb9c53" translate="yes" xml:space="preserve">
          <source>This expression has type t&lt;sub&gt;1&lt;/sub&gt;, but is used with type t&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c752faae770745f4efadec9ad9e3c86712116bf8" translate="yes" xml:space="preserve">
          <source>This expression is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f6d05e23df51dd5500167d330c8fab6501e536" translate="yes" xml:space="preserve">
          <source>This extension allows user to define empty variants. Empty variant type can be eliminated by refutation case of pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21aac0cfc0a526fe8feeb656d5151ae30a38c66" translate="yes" xml:space="preserve">
          <source>This extension is intended to provide a convenient syntax for working with monads and applicatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4fa874a00f72ae6a3e4ed02825e2050e5a7719" translate="yes" xml:space="preserve">
          <source>This extension makes it possible to open any module expression in module structures and expressions. A similar mechanism is also available inside module types, but only for extended module paths (e.g. F(X).G(Y)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bded797c2b65154bcb84bdfa2fb5ae024b3d73a" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements for user-defined indexed types. For instance, we can define python-like dictionaries with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ced06d009b619786712d80c35d7e9694c054e2d" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements in the arrays provided by the &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1d07b08e65aec904b4829d528dfb8d3dbc575e" translate="yes" xml:space="preserve">
          <source>This facility is currently available on all platforms supported by OCaml except Cygwin 64 bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aaa2dee7862002847ec215725a07465e9cee221" translate="yes" xml:space="preserve">
          <source>This filename can also be specified using the OCAML_EVENTLOG_PREFIX environment variable. The given path will be suffixed with {.PID}.eventlog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d118477856b3c7c25f93002b3254e61bdd8c9a57" translate="yes" xml:space="preserve">
          <source>This form of attributes can also be inserted after the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; in polymorphic variant type expressions (&lt;a href=&quot;types#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt;, &lt;a href=&quot;types#tag-spec&quot;&gt;tag-spec&lt;/a&gt;, &lt;a href=&quot;types#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt;) or after the &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; in &lt;a href=&quot;types#method-type&quot;&gt;method-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb9471d9b8d494e18c82c68d8f753fc5a0fc194" translate="yes" xml:space="preserve">
          <source>This function can be applied to objects of type money or money2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f742d762c2f337f9316533c0c01063fbc47ef8" translate="yes" xml:space="preserve">
          <source>This function conforms to the specification of POSIX.1-2008 for the &lt;code&gt;basename&lt;/code&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6687a7963ca256cf05cde1098887f34f0c554208" translate="yes" xml:space="preserve">
          <source>This function does not allocate memory, but tries to run the postponed callbacks for already allocated memory blocks (of course, these callbacks may allocate).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd19a19cf61917fbfecec75f4866f2fb324df47" translate="yes" xml:space="preserve">
          <source>This function does not allocate memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8062cf32d5ed3672f8ed376acc1d476ed6d78c9" translate="yes" xml:space="preserve">
          <source>This function does not terminate on infinite sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2614000c6deae7727744ae05aa634fae4fdf65" translate="yes" xml:space="preserve">
          <source>This function does nothing in the current implementation of the threading library and can be removed from all user programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68449acffb76876acb29d71c9df112633cbec2b0" translate="yes" xml:space="preserve">
          <source>This function does nothing in this implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b93512b013a1d7422171a6bb6941e6102fbeb0a" translate="yes" xml:space="preserve">
          <source>This function is safe because the byte sequence &lt;code&gt;s&lt;/code&gt; will never be accessed or mutated after &lt;code&gt;unsafe_to_string&lt;/code&gt; is called. The &lt;code&gt;string_init&lt;/code&gt; code gives up ownership of &lt;code&gt;s&lt;/code&gt;, and returns the ownership of the resulting string to its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9678c9920e8bd6fa3351bc87366633dae969b5" translate="yes" xml:space="preserve">
          <source>This function might be written like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34819fee235c861f78a56b8c861946bab42ab07" translate="yes" xml:space="preserve">
          <source>This function was supposed to terminate prematurely the thread whose handle is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200e72f67f453ed192894d2651726e4155abe8a8" translate="yes" xml:space="preserve">
          <source>This function was supposed to terminate prematurely the thread whose handle is given. It is not currently implemented due to problems with cleanup handlers on many POSIX 1003.1c implementations. It always raises the &lt;code&gt;Invalid_argument&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cc7e820a82b580a34f0b2bb19198a32fb2d1dc" translate="yes" xml:space="preserve">
          <source>This function will erase non-string tag formatting functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8a6a2bcdafd5f49ba5cdcd976330cb7e69f76f" translate="yes" xml:space="preserve">
          <source>This functional, along with a number of other list and array functionals, is predefined because it is often useful, but there is nothing magic with it: it can easily be defined as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98ed33477f247dffac90e7d27b65afcdf57df27" translate="yes" xml:space="preserve">
          <source>This generates a new type constructor and defines associated constructors or fields, through which values of that type can be directly built or inspected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ad557334e8e1d878c785f430b3e375436f8b96" translate="yes" xml:space="preserve">
          <source>This idiom can in turn be used to retrieve an object whose type has been weakened:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70991f0b7fe10b4796387e57d8f588f1325f5ec1" translate="yes" xml:space="preserve">
          <source>This idiom guarantees that Myset is compatible with Set, but allows it to represent sets internally in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751a6509444b430d2b4388b31e1c9693d69713df" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; the semantics adopted by OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58da15a38848eb6e8733fd04e3d04f1485f3fce9" translate="yes" xml:space="preserve">
          <source>This is also available (since OCaml 4.06) for local opens in class expressions and class type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9768346232217703b79f946958f318884f387d78" translate="yes" xml:space="preserve">
          <source>This is an experimental extension of OCaml: the class of recursive definitions accepted, as well as its dynamic semantics are not final and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffa316d512275ca1ce7e6b896527839df501a74" translate="yes" xml:space="preserve">
          <source>This is another instance of friend functions as seen in section &amp;zwj;&lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;. Indeed, this is the same mechanism used in the module Set in the absence of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf0eb306419907e3403ce9f96c3ef7450a9208f" translate="yes" xml:space="preserve">
          <source>This is another instance of friend functions as seen in section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;. Indeed, this is the same mechanism used in the module Set in the absence of objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c683f5551fbf795dd6f0010c7e2c94e3d36bfd7" translate="yes" xml:space="preserve">
          <source>This is because Lazy.force memoizes the result of the forced expression. In other words, every subsequent call of Lazy.force on that expression returns the result of the first computation without recomputing the lazy expression. Let us force lazy_two once again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad067981738b53b159d177a530e65b07049d0d76" translate="yes" xml:space="preserve">
          <source>This is by far the most common type error in programs. Type t&lt;sub&gt;1&lt;/sub&gt; is the type inferred for the expression (the part of the program that is displayed in the error message), by looking at the expression itself. Type t&lt;sub&gt;2&lt;/sub&gt; is the type expected by the context of the expression; it is deduced by looking at how the value of this expression is used in the rest of the program. If the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are not compatible, then the error above is produced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82fc074dee53936731175b8537edb3c787511a9" translate="yes" xml:space="preserve">
          <source>This is done by forming judgements on the &lt;em&gt;effects&lt;/em&gt; and the &lt;em&gt;coeffects&lt;/em&gt; that might be performed were the expression to be executed. Effects talk about how the expression might affect the world; coeffects talk about how the world might affect the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b690baac19cb0582baf96deb9492b21952c740" translate="yes" xml:space="preserve">
          <source>This is done using first class modules (see chapter &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b965549f63ae8efc2b10799321a123949f32e2" translate="yes" xml:space="preserve">
          <source>This is in any case a good practice for such global mutable variables. Otherwise, they will pick out the type of first use. If there is a mistake at this point, this can result in confusing type errors when later, correct uses are flagged as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8a97ff5473940dbd5590e2ac55f520f156f175" translate="yes" xml:space="preserve">
          <source>This is the counterpart in signatures of class definitions. A class specification matches a class definition if they have the same type parameters and their types match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2f273ae05987b14e1f15ae11bcc910f3cc8e34" translate="yes" xml:space="preserve">
          <source>This manual documents the release 4.11 of the OCaml system. It is organized as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bd583dc9aee85e830c217610e34c8386ad4c5b" translate="yes" xml:space="preserve">
          <source>This manual documents the release 4.12 of the OCaml system. It is organized as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949db82cf2165881bb890405414754937b92c7a0" translate="yes" xml:space="preserve">
          <source>This manual is also available in &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt;. &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;plain text&lt;/a&gt;, as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;bundle of HTML files&lt;/a&gt;, and as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;bundle of Emacs Info files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e19757f9e628b9155f1d9baf54d8ba288ea7582" translate="yes" xml:space="preserve">
          <source>This manual is also available in &lt;a href=&quot;https://ocaml.org/releases/4.12/ocaml-4.12-refman.pdf&quot;&gt;PDF&lt;/a&gt;, &lt;a href=&quot;https://ocaml.org/releases/4.12/ocaml-4.12-refman.txt&quot;&gt;plain text&lt;/a&gt;, as a &lt;a href=&quot;https://ocaml.org/releases/4.12/ocaml-4.12-refman-html.tar.gz&quot;&gt;bundle of HTML files&lt;/a&gt;, and as a &lt;a href=&quot;https://ocaml.org/releases/4.12/ocaml-4.12-refman.info.tar.gz&quot;&gt;bundle of Emacs Info files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a463aa2621012fa84bb9173c52f8aacbca9587" translate="yes" xml:space="preserve">
          <source>This may require some care: if the scrutinee may return several different cases of the same pattern, or raise distinct instances of the same exception, you may need to modify your code to separate those several cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e169cadd5567bf33a7c94a3b1845ac6d0d1577" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda004ff3f73690b7705e7353fdb4ee3d731450" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1628903663a2623d7b2394ae30e7945a09c2f99" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized versions of the &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f453b8d66f96d4df618c378488dc2f5cfbff31ff" translate="yes" xml:space="preserve">
          <source>This meta-module provides versions of the &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; modules where function arguments are systematically labeled. It is intended to be opened at the top of source files, as shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b7b70a1b67a465fca03531e3e7ca988aa3c7a2" translate="yes" xml:space="preserve">
          <source>This method will be called with the list of analysed and possibly merged Odoc_info.t_module structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cfabd3ff7747a40d003c4e1ce49d8233fcae6d" translate="yes" xml:space="preserve">
          <source>This module allows OCaml values to be registered with the C runtime under a symbolic name, so that C code can later call back registered OCaml functions, or raise registered OCaml exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f88a4ac39ab2683e26258770cfb0e2d8f5fd8c" translate="yes" xml:space="preserve">
          <source>This module allows to define a type &lt;code&gt;t&lt;/code&gt; with the &lt;code&gt;immediate64&lt;/code&gt; attribute. This attribute means that the type is immediate on 64 bit architectures. On other architectures, it might or might not be immediate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e533b385e01821d7ad15e0945c07d70b1844d76" translate="yes" xml:space="preserve">
          <source>This module implements a pretty-printing facility to format values within &lt;a href=&quot;format#boxes&quot;&gt;'pretty-printing boxes'&lt;/a&gt; and &lt;a href=&quot;format#tags&quot;&gt;'semantic tags'&lt;/a&gt; combined with a set of &lt;a href=&quot;format#fpp&quot;&gt;printf-like functions&lt;/a&gt;. The pretty-printer splits lines at specified &lt;a href=&quot;format#breaks&quot;&gt;break hints&lt;/a&gt;, and indents lines according to the box structure. Similarly, &lt;a href=&quot;format#tags&quot;&gt;semantic tags&lt;/a&gt; can be used to decouple text presentation from its contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe9c1d1946f164dc7ea31e649282f17763c3950" translate="yes" xml:space="preserve">
          <source>This module implements a simple 'standard' lexical analyzer, presented as a function from character streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by the set of keywords of your language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0125fd89be5c0e10d0ed6d49f7e1879412755c" translate="yes" xml:space="preserve">
          <source>This module implements applicative association tables, also known as finite maps or dictionaries, given a total ordering function over the keys. All operations over maps are purely applicative (no side-effects). The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce89672c48fa1f9bec12d607d59af82b35753a53" translate="yes" xml:space="preserve">
          <source>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622634e44efd00bdedccd5c131a38c8c057e6119" translate="yes" xml:space="preserve">
          <source>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da30f332376f7747f380e4c823a1b7a155244e7c" translate="yes" xml:space="preserve">
          <source>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as 'Bigarrays', to distinguish them from the standard OCaml arrays described in &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5803197dddf99e3ec90f036488d17a8b4740cf" translate="yes" xml:space="preserve">
          <source>This module implements queues (FIFOs), with in-place modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2b395d2566d5b178c77d76600076510ec457a8" translate="yes" xml:space="preserve">
          <source>This module implements stacks (LIFOs), with in-place modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90dc1cefe04c048afd0453d62a3c51d515ce8d7" translate="yes" xml:space="preserve">
          <source>This module implements synchronous inter-thread communications over channels. As in John Reppy's Concurrent ML system, the communication events are first-class values: they can be built and combined independently before being offered for communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3849f273edf21565de6b4e420886d0b2f60b00cd" translate="yes" xml:space="preserve">
          <source>This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2729905361f7f59d504ab6ed9996768ff5460796" translate="yes" xml:space="preserve">
          <source>This module is automatically opened at the beginning of each compilation. All components of this module can therefore be referred by their short name, without prefixing them by &lt;code&gt;Stdlib&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0333c95ed68f95f7342e2b757b9f08ce6a149992" translate="yes" xml:space="preserve">
          <source>This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a683452118741d40e0dc8977a811e67e4bf31a" translate="yes" xml:space="preserve">
          <source>This module is intended to be used through &lt;code&gt;open&amp;nbsp;MoreLabels&lt;/code&gt; which replaces &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; with their labeled counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e122c356078f81e1beb90b2b6032029724c402" translate="yes" xml:space="preserve">
          <source>This module is intended to be used via &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64267a0e80b390a500ec96cdaa100f7adf548198" translate="yes" xml:space="preserve">
          <source>This module provides a general mechanism for extracting options and arguments from the command line to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3394487a2bf0e7c8c8d6c1015677913e540ba5b0" translate="yes" xml:space="preserve">
          <source>This module provides a general mechanism for extracting options and arguments from the command line to the program. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c4387028b13ec67ddd195c281970404e139c47" translate="yes" xml:space="preserve">
          <source>This module provides a purely sequential implementation of the concurrent atomic references provided by the Multicore OCaml standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b609722b91ba2b158610f696a1988788495b0d03" translate="yes" xml:space="preserve">
          <source>This module provides arithmetic operations on complex numbers. Complex numbers are represented by their real and imaginary parts (cartesian representation). Each part is represented by a double-precision floating-point number (type &lt;code&gt;float&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c05832e9b7b531d3b4d16beaa91da5aa46e87d" translate="yes" xml:space="preserve">
          <source>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The algorithm used is MD5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a26eb45fe7af4a376a6ae294864852d297cbea" translate="yes" xml:space="preserve">
          <source>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5. This module should not be used for secure and sensitive cryptographic applications. For these kind of applications more recent and stronger cryptographic primitives should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7540f10133c093c21edec4564acef90adfe177" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection. The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbb035f066ee24f4ebaaacb2368ebd643cd2d0c" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int32&lt;/code&gt; of signed 32-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int32&lt;/code&gt; is guaranteed to be exactly 32-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int32&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e7fe24e618c6feb78fd56d32e5512c8633a081" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int64&lt;/code&gt; of signed 64-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int64&lt;/code&gt; is guaranteed to be exactly 64-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int64&lt;/code&gt; are taken modulo 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd560eafa9bf44786fbe70e70e377b41d3ae81e2" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;nativeint&lt;/code&gt; of signed 32-bit integers (on 32-bit platforms) or signed 64-bit integers (on 64-bit platforms). This integer type has exactly the same width as that of a pointer type in the C compiler. All arithmetic operations over &lt;code&gt;nativeint&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt; or 2&lt;sup&gt;64&lt;/sup&gt; depending on the word size of the architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288a280c92d0e752f41d14eee812057e14d86d83" translate="yes" xml:space="preserve">
          <source>This option has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa9dce6e9770df639633ba7481a47b5f4a85101" translate="yes" xml:space="preserve">
          <source>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter &amp;zwj;&lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; deals with the module system, chapter &amp;zwj;&lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; with the object-oriented features, chapter &amp;zwj;&lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; with extensions to the core language (labeled arguments and polymorphic variants), chapter &amp;zwj;&lt;a href=&quot;polymorphism#c%3Apolymorphism&quot;&gt;5&lt;/a&gt; with the limitations of polymorphism, and chapter &amp;zwj;&lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt; gives some advanced examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fa776a935837d0195b8b526844f025d4e6ce93" translate="yes" xml:space="preserve">
          <source>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; deals with the module system, chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; with the object-oriented features, chapter &lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; with extensions to the core language (labeled arguments and polymorphic variants), and chapter &lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt; gives some advanced examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc86cc4d49f38cd528229f18473c5150da317ea" translate="yes" xml:space="preserve">
          <source>This pretty-printing facility is implemented as an overlay on top of abstract &lt;a href=&quot;format#formatter&quot;&gt;formatters&lt;/a&gt; which provide basic output functions. Some formatters are predefined, notably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85ed63830f1cbd46d61e59847fbdc4998afedf8" translate="yes" xml:space="preserve">
          <source>This principle also applies to functions of several arguments whose return type is a type variable, as long as the role of each argument is not ambiguous. Labeling such functions may lead to awkward error messages when one attempts to omit labels in an application, as we have seen with ListLabels.fold_left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672f5a8d2001e1947d29714c5e2ccca5133a964a" translate="yes" xml:space="preserve">
          <source>This provides a convenient way to introduce local names for types and modules when defining a signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a45b4f1b855894d7e36f97483d0e12e2929c42" translate="yes" xml:space="preserve">
          <source>This reference is initially set to &lt;code&gt;false&lt;/code&gt; in standalone programs and to &lt;code&gt;true&lt;/code&gt; if the code is being executed under the interactive toplevel system &lt;code&gt;ocaml&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb60a37765a751859069418a148aa8f84ee1892" translate="yes" xml:space="preserve">
          <source>This requires that programs to be tested are instrumented to communicate with afl-fuzz. The native-code compiler &amp;ldquo;ocamlopt&amp;rdquo; can generate such instrumentation, allowing afl-fuzz to be used against programs written in OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52dcd9a1729658eb0c6b106d0c414385be78c303" translate="yes" xml:space="preserve">
          <source>This result in the error message &amp;ldquo;expression C of type foo cannot be used with type foo&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a02fce90d5e7f7129963fee4236b9d584135a5" translate="yes" xml:space="preserve">
          <source>This script expect to receive as an argument the directory containing the trace file. It will then copy the &lt;em&gt;CTF&lt;/em&gt; metadata file to the trace&amp;rsquo;s directory, and then decode the trace, printing each event in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9456a3c165c2c5114ee21374f6504d86e6983b" translate="yes" xml:space="preserve">
          <source>This second form also works for patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc3c124b4479b68cbf25dba521d9a1e132177df" translate="yes" xml:space="preserve">
          <source>This section contains some general guidelines for writing C stubs that use Windows Unicode APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f394592ed3600793f95e1254fcf350cda70b82c" translate="yes" xml:space="preserve">
          <source>This section describe how to make calling C functions cheaper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d9e3857acf6ed9216da0ef8ec0aa252128e3aa" translate="yes" xml:space="preserve">
          <source>This section describes a tool that is not yet officially supported but may be found useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aafc15cda9ee7ff87051d799ffe599afa951de" translate="yes" xml:space="preserve">
          <source>This section describes and explains in detail some warnings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffca379ae7271c0783a4ac241e377936af555ed8" translate="yes" xml:space="preserve">
          <source>This section describes and explains the most frequently encountered error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ad7ee467b01f5649ddd8facce322cfb81ef3ae" translate="yes" xml:space="preserve">
          <source>This section describes how OCaml data types are encoded in the value type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01693577ebb54a11b677d93676f308db58f638a4" translate="yes" xml:space="preserve">
          <source>This section describes the kinds of values that are manipulated by OCaml programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36e7060d9bec0558c1823961541205abf1df8d6" translate="yes" xml:space="preserve">
          <source>This section describes unsafe, low-level conversion functions between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the &lt;code&gt;-safe-string&lt;/code&gt; option. They are available for expert library authors, but for most purposes you should use the always-correct &lt;a href=&quot;bytes#VALto_string&quot;&gt;&lt;code&gt;Bytes.to_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bytes#VALof_string&quot;&gt;&lt;code&gt;Bytes.of_string&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4af804a24f712d9d8a0209fbdc3526515ff4bd" translate="yes" xml:space="preserve">
          <source>This section describes unsafe, low-level conversion functions between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the &lt;code&gt;-safe-string&lt;/code&gt; option. They are available for expert library authors, but for most purposes you should use the always-correct &lt;a href=&quot;byteslabels#VALto_string&quot;&gt;&lt;code&gt;BytesLabels.to_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;byteslabels#VALof_string&quot;&gt;&lt;code&gt;BytesLabels.of_string&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9f87ec885f096da88cc6ca28abd5b60c7d67fe" translate="yes" xml:space="preserve">
          <source>This section explains how C stub code that interfaces C or Fortran code with OCaml code can use Bigarrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87e2a72041af5e2c3e79f1dd47bab90b2e6d42e" translate="yes" xml:space="preserve">
          <source>This section illustrates the callback facilities described in section &amp;zwj;&lt;a href=&quot;#s%3Ac-callback&quot;&gt;18.7&lt;/a&gt;. We are going to package some OCaml functions in such a way that they can be linked with C code and called from C just like any C functions. The OCaml functions are defined in the following mod.ml OCaml source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cdd8bac2c7a5aeee310523309d1c53e8523783" translate="yes" xml:space="preserve">
          <source>This section illustrates the callback facilities described in section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;. We are going to package some OCaml functions in such a way that they can be linked with C code and called from C just like any C functions. The OCaml functions are defined in the following mod.ml OCaml source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903aefdf9956fc71e923a3df9d4dd16dd0134747" translate="yes" xml:space="preserve">
          <source>This section lists the known incompatibilities between the bytecode compiler and the native-code compiler. Except on those points, the two compilers should generate code that behave identically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b5904aff3b237cf95bcb17d1df036bc4ab134c" translate="yes" xml:space="preserve">
          <source>This section outlines how the functions from the Unix curses library can be made available to OCaml programs. First of all, here is the interface curses.ml that declares the curses primitives and data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf72a863251d3457b00bf469f5811d11fbf5a4e" translate="yes" xml:space="preserve">
          <source>This sequential implementation is provided in the interest of compatibility: when people will start writing code to run on Multicore, it would be nice if their use of Atomic was backward-compatible with older versions of OCaml without having to import additional compatibility layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254ed70371607b2c3851b67568dd926316b5ceae" translate="yes" xml:space="preserve">
          <source>This short notation for fields also works when constructing records:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e400965e58bbfd6200a8deb63c3134ffb7098b" translate="yes" xml:space="preserve">
          <source>This short section is intended to clarify the relationship between the names of the modules corresponding to compilation units and the names of the files that contain their compiled interface and compiled implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa0094a26c8735b882dd7c464be2f2468ee6f8" translate="yes" xml:space="preserve">
          <source>This shows the use of modules to group several class definitions that can in fact be thought of as a single unit. This unit would be provided by a bank for both internal and external uses. This is implemented as a functor that abstracts over the currency so that the same code can be used to provide accounts in different currencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48666abb0d053a2e67948abc2515711d3c441749" translate="yes" xml:space="preserve">
          <source>This simplifies to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b507c0600bf63aba874d8cc6091cf6ff9204d9c" translate="yes" xml:space="preserve">
          <source>This syntax can be very useful when defining recursive functions involving GADTs, see the section &amp;zwj;&lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; for a more detailed explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd8a59e7fc768a0f67909566216bc17b9fded83" translate="yes" xml:space="preserve">
          <source>This syntax can be very useful when defining recursive functions involving GADTs, see the section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; for a more detailed explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606749beda23122ec62e2057e7b85c14c94a4118" translate="yes" xml:space="preserve">
          <source>This transformation discovers closure variables that are known to be equal to specialised arguments. Such closure variables are replaced by the specialised arguments; the closure variables may then be removed by the &amp;ldquo;removal of unused closure variables&amp;rdquo; pass (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ca52136f921dd3470ad0eec8da036065e73e98" translate="yes" xml:space="preserve">
          <source>This transformation does not operate if it would cause the closure to contain more than twice as many closure variables as it did beforehand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a28d09c6743f0d934bbb9ee805f4686f7ff260e" translate="yes" xml:space="preserve">
          <source>This transformation is &lt;em&gt;not&lt;/em&gt; enabled by default. It may be enabled using the -unbox-closures flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4085b150ab05ea3b51f91b2bd36f0e92e0492fbb" translate="yes" xml:space="preserve">
          <source>This transformation is analogous to the removal of let-expressions whose defining expressions have no effects. It operates instead on symbol bindings, removing those that have no effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98eeafe0734234bf6e061a4b30996bb7f31b9996" translate="yes" xml:space="preserve">
          <source>This transformation is coherent with the intended semantics, including side-effects. That is, if the application of optional parameters shall produce side-effects, these are delayed until the received function is really applied to an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f7301c5b5d5afefc26a2bd6bf09c3b5a77941d" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-free-vars-of-closures is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107da9a0de966e43ce271c3dfca90682878bece5" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-specialised-args is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f81958a03cd80819ec888b7dadbd9b19a9762f" translate="yes" xml:space="preserve">
          <source>This transformation is only enabled by default for specialised arguments. It may be enabled for all arguments using the -remove-unused-arguments flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3540291a552cb80b3485979aeb16719df0b1d80" translate="yes" xml:space="preserve">
          <source>This transformation performs an analysis across the whole compilation unit to determine whether there exist closure variables that are never used. Such closure variables are then eliminated. (Note that this has to be a whole-unit analysis because a projection of a closure variable from some particular closure may have propagated to an arbitrary location within the code due to inlining.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e83b36cd0eeacff2b0fcd7e5886d6aedf97ee77" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130aa34f2abb76bf60b32cca15d066255d4d8d30" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure. Being process-specific, they must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f42130deca30ae8346b504b0eec48ca9c2365c" translate="yes" xml:space="preserve">
          <source>This type is particularly useful when defining function that can fail in common situations, for instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b107ea9cfcc09f2b2be2c72335ef153d3c3763" translate="yes" xml:space="preserve">
          <source>This type is used to implement the &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; module. It should not be used directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d17658b52fcfa2e5e13c67bf948e23dd381e2e" translate="yes" xml:space="preserve">
          <source>This type is used to iterate over the slots of a &lt;code&gt;raw_backtrace&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f53d6e1b80800322b1b4a103e25e988a76fb9d" translate="yes" xml:space="preserve">
          <source>This type is used to iterate over the slots of a &lt;code&gt;raw_backtrace&lt;/code&gt;. For most purposes, &lt;code&gt;backtrace_slots_of_raw_entry&lt;/code&gt; is easier to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2322d3b9d09a7e2ff55273a1e7e1bf51ca59dec" translate="yes" xml:space="preserve">
          <source>This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191b0eb7c35686bcb189014265a40f332069ddbd" translate="yes" xml:space="preserve">
          <source>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3e48f0f7c49da9ec952c4fe9ffee5be36732e2" translate="yes" xml:space="preserve">
          <source>Those annotations are introduced in the format strings using the &lt;code&gt;@&lt;/code&gt; character. For instance, &lt;code&gt;@&amp;nbsp;&lt;/code&gt; means a space break, &lt;code&gt;@,&lt;/code&gt; means a cut, &lt;code&gt;@[&lt;/code&gt; opens a new box, and &lt;code&gt;@]&lt;/code&gt; closes the last open box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0183ff3f98f4e87c7d8f00f861fde047cea5266" translate="yes" xml:space="preserve">
          <source>Those explicit type annotations can in fact be used anywhere. Most of the time they are unnecessary, but they are useful to guide disambiguation, to debug unexpected type errors, or combined with some of the more advanced features of OCaml described in later chapters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19021df6f2a2bbcef0c8a622652f87dbf2d6eed1" translate="yes" xml:space="preserve">
          <source>Though all examples so far were written in purely applicative style, OCaml is also equipped with full imperative features. This includes the usual while and for loops, as well as mutable data structures such as arrays. Arrays are either created by listing semicolon-separated element values between [| and |] brackets, or allocated and initialized with the Array.make function, then filled up later by assignments. For instance, the function below sums two vectors (represented as float arrays) componentwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="442734960d3874aabb05e4c0f886a1d056b06211" translate="yes" xml:space="preserve">
          <source>Thread creation and termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f5360fcdde9c0092d8683e0065551e707bd34e" translate="yes" xml:space="preserve">
          <source>Thread-compatible system calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2045ffa4a6ae2e8ac2ea21859b137e4ac2c45ee5" translate="yes" xml:space="preserve">
          <source>ThreadUnix</source>
          <target state="translated">ThreadUnix</target>
        </trans-unit>
        <trans-unit id="013b2a2d89313d1cae51597fa10d83179b049eb7" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eade1edda0a702cf28e0ef4fd84c23f49efcdfd9" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d763c9a3cec94432c50184761fc6f2428e98860e" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays. The &lt;code&gt;Array3&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of three-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0398dff7b2f64839c1ab8aac932358f9c7ab5983" translate="yes" xml:space="preserve">
          <source>Thus, semantic tag handling is in some sense transparent to pretty-printing and does not interfere with usual indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once &lt;code&gt;set_tags&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the pretty-printer engine honors tags and decorates the output accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="a6a4546fd81b122915404e74cff9ee54a97e6c89" translate="yes" xml:space="preserve">
          <source>Time functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="41bea1307711e3db755e8948c9ec2940bd8e5a31" translate="yes" xml:space="preserve">
          <source>Timeout for input operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a1cbb733d9363c6f97fb603ebe07c1187f0c4b" translate="yes" xml:space="preserve">
          <source>Timeout for output operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fb3076dc75c83c83101f40598cc392db271b82" translate="yes" xml:space="preserve">
          <source>Timeout in cpu time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab4ed36a26f207c2e296f6a9bb7588c6211437f" translate="yes" xml:space="preserve">
          <source>Timeout in virtual time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088594bde4f110fe47b51096bee5193b9d4cffe2" translate="yes" xml:space="preserve">
          <source>To adjust automatically the dimensions of the Bigarray to the actual size of the file, the major dimension (that is, the first dimension for an array with C layout, and the last dimension for an array with Fortran layout) can be given as &lt;code&gt;-1&lt;/code&gt;. &lt;code&gt;Genarray.map_file&lt;/code&gt; then determines the major dimension from the size of the file. The file must contain an integral number of sub-arrays as determined by the non-major dimensions, otherwise &lt;code&gt;Failure&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcb912fdb5200803e65274b62ebac43ebe889fc" translate="yes" xml:space="preserve">
          <source>To allow splitting long string literals across lines, the sequence \newline &amp;zwj;spaces-or-tabs (a backslash at the end of a line followed by any number of spaces and horizontal tabulations at the beginning of the next line) is ignored inside string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0661a33ab380eb57561703bce19cb91f7cdd834" translate="yes" xml:space="preserve">
          <source>To allow splitting long string literals across lines, the sequence \newlinespaces-or-tabs (a backslash at the end of a line followed by any number of spaces and horizontal tabulations at the beginning of the next line) is ignored inside string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307acf24c4315e13fca20cd97aee6950796edc41" translate="yes" xml:space="preserve">
          <source>To avoid ambiguities, naming labels in expressions cannot just be defined syntactically as the sequence of the three tokens ~, &lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt; and :, and have to be defined at the lexical level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6b4ed52355b5293c6127fa5925601acaeaf11e" translate="yes" xml:space="preserve">
          <source>To build the whole program, just invoke the C compiler as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c213abd6a15163ea6d392abe4c8d900d2d422d" translate="yes" xml:space="preserve">
          <source>To circumvent these dual difficulties, the type checker considers that any value returned by a function might rely on persistent mutable states behind the scene and should be given a weak type. This restriction on the type of mutable values and the results of function application is called the value restriction. Note that this value restriction is conservative: there are situations where the value restriction is too cautious and gives a weak type to a value that could be safely generalized to a polymorphic type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfd9516db0a5f37b1ad909f49077e73f5c3d083" translate="yes" xml:space="preserve">
          <source>To compile and link this program, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde604309077235c564ef6bb992b73c29478ef2a" translate="yes" xml:space="preserve">
          <source>To compile everything, execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463481e8191305706647c8346e602fd42723a3d3" translate="yes" xml:space="preserve">
          <source>To compile this interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b3ccadf9cce9fa5117bc1b3bfac7cb3a873f7e" translate="yes" xml:space="preserve">
          <source>To define arithmetic operations for the number type, we use pattern-matching on the two numbers involved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea4a5496e8ca41fa3884dcd1458f902dbff2ec8" translate="yes" xml:space="preserve">
          <source>To dynamically link C code with OCaml code, the C code must first be compiled into a shared library (under Unix) or DLL (under Windows). This involves 1- compiling the C files with appropriate C compiler flags for producing position-independent code (when required by the operating system), and 2- building a shared library from the resulting object files. The resulting shared library or DLL file must be installed in a place where ocamlrun can find it later at program start-up time (see section &amp;zwj;&lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). Finally (step 3), execute the ocamlc command with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327cad239718bab706e248d624ccb7ecb21c15f6" translate="yes" xml:space="preserve">
          <source>To dynamically link C code with OCaml code, the C code must first be compiled into a shared library (under Unix) or DLL (under Windows). This involves 1- compiling the C files with appropriate C compiler flags for producing position-independent code (when required by the operating system), and 2- building a shared library from the resulting object files. The resulting shared library or DLL file must be installed in a place where ocamlrun can find it later at program start-up time (see section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). Finally (step 3), execute the ocamlc command with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4a49b6e92a580be3d1ce7213ac6573529cfb93" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7902cf653d3b6806a962d736420aac3556c0af2" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a Bigarray whose elements are of kind &lt;code&gt;float32_elt&lt;/code&gt; contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type &lt;code&gt;float&lt;/code&gt;, which is 64-bit double precision floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8d6d0f0d08a9fa9eb4faaf97e838ad337fba45" translate="yes" xml:space="preserve">
          <source>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for Bigarrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9440719805fd4d3883c45311f6d371026f97469" translate="yes" xml:space="preserve">
          <source>To fuzz a large system without modifying build tools, OCaml&amp;rsquo;s configure script also accepts the afl-instrument option. If OCaml is configured with afl-instrument, then all programs compiled by ocamlopt will be instrumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49cf83522e4dd02edaed17398bc3794092a3e6c" translate="yes" xml:space="preserve">
          <source>To generate a bytecode executable that runs on this runtime system, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bc2f54fc054335414529814cf18901fad89b38" translate="yes" xml:space="preserve">
          <source>To handle custom tags, you need to define a custom generator, as explained in section &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;15.3.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d984b677b59e1ba119d9e288d010f2047bf07c" translate="yes" xml:space="preserve">
          <source>To handle custom tags, you need to define a custom generator, as explained in section &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a226b13d5aac9e91dcb364c97e1b727eb95a790b" translate="yes" xml:space="preserve">
          <source>To help you diagnose this error, run your program with the -v option to ocamlrun, or with the OCAMLRUNPARAM environment variable set to v=63. If it displays lots of &amp;ldquo;Growing stack&amp;hellip;&amp;rdquo; messages, this is probably a looping recursive function. If it displays lots of &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, with the heap size growing slowly, this is probably an attempt to construct a data structure with too many (infinitely many?) cells. If it displays few &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, but with a huge increment in the heap size, this is probably an attempt to build an excessively large array, string or byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2372771b07a4d167928768e2a883bc383b6e0f5" translate="yes" xml:space="preserve">
          <source>To illustrate the rules above, here is a C function that builds and returns a list containing the two integers given as parameters. First, we write it using the simplified allocation functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9316bbb60ea8ce0b1c90bf6112d6e8ade80ba7a" translate="yes" xml:space="preserve">
          <source>To implement these functions, we just have to provide the stub code; the core functions are already implemented in the curses library. The stub code file, curses_stubs.c, looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b952e965e16326f8fe35cdcad00515932cf1d1ca" translate="yes" xml:space="preserve">
          <source>To keep the generated automata small, rewrite those definitions with only one general &amp;ldquo;identifier&amp;rdquo; rule, followed by a hashtable lookup to separate keywords from identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23cb4ea2cf58c9454eccc5177ac6f043e990101" translate="yes" xml:space="preserve">
          <source>To keep the relaxed value restriction, we need to declare the abstract type 'a COLLECTION.t as covariant in 'a:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d11a9162bbc283c3d1d5bcb248f5b1b6ede824" translate="yes" xml:space="preserve">
          <source>To keep track of operations, we extend the class with a mutable field history and a private method trace to add an operation in the log. Then each method to be traced is redefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b5e7c8935211369728af60650fb3dfa58b7996" translate="yes" xml:space="preserve">
          <source>To know which methods to override and/or which methods are available, have a look at the different base implementations, depending on the kind of generator you are extending &amp;zwj;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e8a007425ee0f5fee02a060cc2a2384efe46e2" translate="yes" xml:space="preserve">
          <source>To know which methods to override and/or which methods are available, have a look at the different base implementations, depending on the kind of generator you are extending :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff8eee99072881c7dd4af3c5fa1af20b5deb63a" translate="yes" xml:space="preserve">
          <source>To link in &amp;ldquo;custom runtime&amp;rdquo; mode, execute the ocamlc command with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc12bb0039399b2211b5edf87b77c3207cbfd57" translate="yes" xml:space="preserve">
          <source>To make sure your programs can be compiled in profiling mode, avoid using any identifier that begins with __ocaml_prof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e4b280c7f58e4764b54d8abccf82639d2ae14" translate="yes" xml:space="preserve">
          <source>To make this even more comfortable, you may use type definitions as abbreviations for or-patterns. That is, if you have defined type myvariant = [`Tag1 of int | `Tag2 of bool], then the pattern #myvariant is equivalent to writing (`Tag1(_ : int) | `Tag2(_ : bool)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a622ca9104700efc8eba27769d5e6eccf540e9b" translate="yes" xml:space="preserve">
          <source>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; bytes into the sequence, then determine the length of the remainder of the representation using &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;, make sure the sequence is large enough to hold the remaining data, then read it, and finally call &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt; to unmarshal the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72d4392ca2173a1c9eef1f69d8ad84c58d851ec" translate="yes" xml:space="preserve">
          <source>To reason about the use of &lt;code&gt;unsafe_to_string&lt;/code&gt;, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7157f5deddeacc7b51617138d7fd940b256e41" translate="yes" xml:space="preserve">
          <source>To solve our problem, we can therefore use either the record solution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4019cbcbaea339fe27aab76ebea9127bab9094f" translate="yes" xml:space="preserve">
          <source>To solve this error, it is enough to add an explicit type annotation to specify the type at declaration time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25f95dc627a388c949e54ad1e4876e37a5fdec0" translate="yes" xml:space="preserve">
          <source>To speak in an &amp;ldquo;object-oriented&amp;rdquo; way, one can consider that each function has a main argument, its &lt;em&gt;object&lt;/em&gt;, and other arguments related with its action, the &lt;em&gt;parameters&lt;/em&gt;. To permit the combination of functions through functionals in commuting label mode, the object will not be labeled. Its role is clear from the function itself. The parameters are labeled with names reminding of their nature or their role. The best labels combine nature and role. When this is not possible the role is to be preferred, since the nature will often be given by the type itself. Obscure abbreviations should be avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387ff33570962c3e8b5dedb0a388bccd5c1fb297" translate="yes" xml:space="preserve">
          <source>To use Spacetime it is necessary to use an OCaml compiler that was configured with the -spacetime option. It is not possible to select Spacetime on a per-source-file basis or for a subset of files in a project; all files involved in the executable being profiled must be built with the Spacetime compiler. Only native code compilation is supported (not bytecode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed32f07860215af085ff436b7b7306a6815a9b78" translate="yes" xml:space="preserve">
          <source>To use the Flambda optimisers it is necessary to pass the -flambda option to the OCaml configure script. (There is no support for a single compiler that can operate in both Flambda and non-Flambda modes.) Code compiled with Flambda cannot be linked into the same program as code compiled without Flambda. Attempting to do this will result in a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25cebac05e12b33d1c5325eeaabd74f6b15cffcb" translate="yes" xml:space="preserve">
          <source>To use the functions in this module you must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485f8337c43e9300153d2cb4fa61c75f8999d64a" translate="yes" xml:space="preserve">
          <source>To use the labeled version of this module, add &lt;code&gt;module&amp;nbsp;Unix&lt;/code&gt;&lt;code&gt;&amp;nbsp;=&amp;nbsp;&lt;/code&gt;&lt;code&gt;UnixLabels&lt;/code&gt; in your implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3b40c35ac9b4dbb1547ab6397d847d576919f6" translate="yes" xml:space="preserve">
          <source>To use this function, one can wrap the Set.Make functor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e279465e252c0b80c2d1a6c8e50d696d2db937f5" translate="yes" xml:space="preserve">
          <source>To write C code that operates on OCaml values, the following include files are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659d8a056102ffd377f0cdfc671961480711f61a" translate="yes" xml:space="preserve">
          <source>Together, the relaxed value restriction and type parameter covariance help to avoid eta-expansion in many situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56dbc78473450158f36bd54d125933d056ecd869" translate="yes" xml:space="preserve">
          <source>Tokens and rules have precedences. By default, the precedence of a rule is the precedence of its rightmost terminal. You can override this default by using the %prec directive in the rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5736e6c11ff6d9830fab68fdeb2e9c96cdae31d6" translate="yes" xml:space="preserve">
          <source>Too many open files by the process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529311e8fdf6ab2db0e809d7fbb676ae1d82a50d" translate="yes" xml:space="preserve">
          <source>Too many open files in the system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282e2b703da2ac14021b09f04b30fd7f814e033a" translate="yes" xml:space="preserve">
          <source>Too many references: can't splice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15521e66130383b230f739bb2fc49edfc0a24250" translate="yes" xml:space="preserve">
          <source>Toplevel</source>
          <target state="translated">Toplevel</target>
        </trans-unit>
        <trans-unit id="52271cb5a0a7ab67a42426df16b8f5309e544d7d" translate="yes" xml:space="preserve">
          <source>Toplevel let-expressions may be lifted to symbol bindings to ensure that the corresponding bound variables are not captured by closures. If the defining expression of a given binding is found to be constant, it is bound as such (the technical term is a &lt;em&gt;let-symbol&lt;/em&gt; binding).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ed8cbf615841cdc04e1382dda216f960e589bf" translate="yes" xml:space="preserve">
          <source>Toplevel phrases can refer to identifiers defined in compilation units with the same mechanisms as for separately compiled units: either by using qualified names (Modulename.localname), or by using the open construct and unqualified names (see section &amp;zwj;&lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44cf452ae377637373f10a091314197af5f0b33" translate="yes" xml:space="preserve">
          <source>Toplevel phrases can refer to identifiers defined in compilation units with the same mechanisms as for separately compiled units: either by using qualified names (Modulename.localname), or by using the open construct and unqualified names (see section &lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d983275acca4ebd956f4ca99271a34f2702b6e" translate="yes" xml:space="preserve">
          <source>Total ordering between maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d503224bdd1f64388674e9ce0a963f9f4e37ff2" translate="yes" xml:space="preserve">
          <source>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d7c3d7b4f4e20c4b6494fc8ea71a5bcb4f2aaf" translate="yes" xml:space="preserve">
          <source>Total ordering between sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f44baf07265ef300d210f7ea6b516756e51c1c5" translate="yes" xml:space="preserve">
          <source>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34336f2b5f5540478a6b0046d27bf02690c7c02c" translate="yes" xml:space="preserve">
          <source>Total size of the major heap, in words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ce6b1a588e98221c2bce1023520067bc5af6c3" translate="yes" xml:space="preserve">
          <source>Trace/breakpoint trap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d86e87d3b5c7cc8eaa531c471cc6fe6401e236" translate="yes" xml:space="preserve">
          <source>Traces generated by the instrumented runtime can be analyzed with tooling available outside of the OCaml distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="8a199b624500a34255a39172a77785f3c1196171" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32401d5fba7510cc4407d77e41ee1d2a4fb4a675" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;. Not tail-recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a801d0a362583e8d49cf49a6efc625d6c92a83" translate="yes" xml:space="preserve">
          <source>Transform a pair of lists into a list of pairs: &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; is &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07edff8c6ab5d2b6ba73b34c78a1792f548b27e1" translate="yes" xml:space="preserve">
          <source>Transforming</source>
          <target state="translated">Transforming</target>
        </trans-unit>
        <trans-unit id="50dd5a15a0cecf0dd0826019c37ba6dc26f6bc64" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4688d50f3f86cb62a80baee37bcad030269d2b74" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ffd6275eb7e6db7a5aa37c560db9fe2b0e7ed8" translate="yes" xml:space="preserve">
          <source>Traversing</source>
          <target state="translated">Traversing</target>
        </trans-unit>
        <trans-unit id="5951a92d20e1af5270ceec7e9317847694484ddf" translate="yes" xml:space="preserve">
          <source>Treat Ocamldoc warnings as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417c217dcd227caf02540a67a10ab8cd2a50b328" translate="yes" xml:space="preserve">
          <source>Treat as errors the warnings enabled by the argument and as normal warnings the warnings disabled by the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66debbd01f97db729dc454195e358bf429f9ece9" translate="yes" xml:space="preserve">
          <source>Trigger a minor collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9159f861a187df7bb8aa25e8c7153d42d309321" translate="yes" xml:space="preserve">
          <source>Triggering finalization of allocated custom blocks (see section &amp;zwj;&lt;a href=&quot;#s%3Ac-custom&quot;&gt;18.9&lt;/a&gt;). For example, Stdlib.in_channel and Stdlib.out_channel are represented by custom blocks that enclose file descriptors, which are to be released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b695cc0fd391daf36faf1963153e5b6cb4a3b9" translate="yes" xml:space="preserve">
          <source>Triggering finalization of allocated custom blocks (see section &lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9&lt;/a&gt;). For example, Stdlib.in_channel and Stdlib.out_channel are represented by custom blocks that enclose file descriptors, which are to be released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e79023b8ee1b35da3de1efb771fce6d418e7dd" translate="yes" xml:space="preserve">
          <source>Triple the default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed552aedd0ce3f370d321354a40788014425b26f" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e10371a9b7e6b5bec4cec1afb346e6fcf56c47" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c18358e3f16eb9b759e71c30fca9e2c6ee55d3a" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532fe6ed68fa8e3a71fd02229c84119658bc5ab3" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a10351d651cbeb488e200041e184f6200f9b609" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer. The result is unspecified if the argument is &lt;code&gt;nan&lt;/code&gt; or falls outside the range of representable integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93981b89548137dc81009ceab881823b9341006a" translate="yes" xml:space="preserve">
          <source>Truncate to 0 length if existing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fed15abd46a43c683f271305b8f42f5b17141ef" translate="yes" xml:space="preserve">
          <source>Truncated bytecode file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5002c1234c7b95d88482d1369e0f6d0a4591c59b" translate="yes" xml:space="preserve">
          <source>Truncates the file corresponding to the given descriptor to the given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0347bdb2507eb59f16d15ec102ff4098f3d5b35" translate="yes" xml:space="preserve">
          <source>Truncates the named file to the given size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f06fe71a2621c8f57118b1fe5e796cfefcfdc4" translate="yes" xml:space="preserve">
          <source>Tuples are represented by pointers to blocks, with tag &amp;zwj;0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c43375c1d65c34fdff7dac4166175da7ec333a" translate="yes" xml:space="preserve">
          <source>Tuples are represented by pointers to blocks, with tag 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb08f9372966ada62d75d5d7d46f41e9ec29633" translate="yes" xml:space="preserve">
          <source>Tuples of values are written (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,v&lt;sub&gt;n&lt;/sub&gt;), standing for the n-tuple of values v&lt;sub&gt;1&lt;/sub&gt; to v&lt;sub&gt;n&lt;/sub&gt;. The current implementation supports tuple of up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec1382e4b69cd24377b95330f6e9bb58114f7bac" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a661500df8d1ec062b5d1e38538b3068fc8971" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9976aabbd5a9c1ab1aeea83f7f9166b0d664e3c3" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore slightly faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711678e3efb5338f51272a8b5178317c676c89f3" translate="yes" xml:space="preserve">
          <source>Two class type definitions match if they have the same type parameters and they expand to matching types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5091be2b30944df38716bba8e5b97b542f1edd17" translate="yes" xml:space="preserve">
          <source>Two flavors of semaphores are provided: counting semaphores and binary semaphores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4a19d22a2815840c01d0e4fbe627ac1ec3b2ca" translate="yes" xml:space="preserve">
          <source>Two functions are provided to raise two standard exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1661242be978210d8d5a1f77691405122d60e821" translate="yes" xml:space="preserve">
          <source>Two implementations of the threads library are available, depending on the capabilities of the operating system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7df99aa69f329ed15f7337f8f36f0ebf2312aad" translate="yes" xml:space="preserve">
          <source>Two integers &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to define a &lt;em&gt;valid substring&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;start+len&lt;/code&gt; are positions of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cefc13e3d298c2bb25661b6f6aa2482f697297" translate="yes" xml:space="preserve">
          <source>Two labels or constructors of the same name are defined in two mutually recursive types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d9c23b1cb7383bf898c8101cacf467f4231973" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid range of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67b45c324770bcbf92f640297940d5a30dc1257" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid substring of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ad4c7ee77f98430fd3a05a3935346ecc6ed421" translate="yes" xml:space="preserve">
          <source>Two syntactic forms are provided to define functions. The first form is introduced by the keyword function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019322ca2a87bdfa6e229ab6eaabec2277045691" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efde7c3ec175b7e2cd302f767b8885955c43c8f" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea97efc84b08c1dfa5507328a9a5eb75811c2159" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays. The &lt;code&gt;Array2&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of two-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a966b34064ea2bde71d174110a293dd3641eb6" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, no representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c2db94655456061e2fda2d94f1456bf5e6dcae" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation, no representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd26433f35fa9fba1fb5a1c64fd536c78f13267" translate="yes" xml:space="preserve">
          <source>Type abbreviations are not expanded when determining the arity of a primitive. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce1ff79a0b7e3f45e08e886eab851d95ab4453e" translate="yes" xml:space="preserve">
          <source>Type argument &lt;code&gt;'b&lt;/code&gt; is also the type of the first argument given to user's defined printing functions for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%t&lt;/code&gt; conversions, and user's defined reading functions for &lt;code&gt;%r&lt;/code&gt; conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbbc6fe5700486ef983078c89b775200e1dfb7c" translate="yes" xml:space="preserve">
          <source>Type constraint on GADT type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d901f4220b65f3d70d012f9e484a31bb0b370e19" translate="yes" xml:space="preserve">
          <source>Type constructor application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008b7ad7f73c68a43133ccff9ec196e28074c36f" translate="yes" xml:space="preserve">
          <source>Type constructors with no parameter, as in &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, are type expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e19918330a4b7e92b3dee85f135d9b90408d4a" translate="yes" xml:space="preserve">
          <source>Type declaration defining a new &amp;rsquo;()&amp;rsquo; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383e22354516abb8dd98b4675030118fe6e23fbe" translate="yes" xml:space="preserve">
          <source>Type definitions are introduced by the type keyword, and consist in one or several simple definitions, possibly mutually recursive, separated by the and keyword. Each simple definition defines one type constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80012d2e3c018c87cbaf804ec7fb6ccc51f86ae0" translate="yes" xml:space="preserve">
          <source>Type definitions bind type constructors to data types: either variant types, record types, type abbreviations, or abstract data types. They also bind the value constructors and record fields associated with the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cad2e5ed527706c404fda008c0fbc43d1739bde" translate="yes" xml:space="preserve">
          <source>Type expressions denote types in definitions of data types as well as in type constraints over patterns and expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f54858a82ae6c361b165ee97f22098dea3856f8" translate="yes" xml:space="preserve">
          <source>Type inference for GADTs is notoriously hard. This is due to the fact some types may become ambiguous when escaping from a branch. For instance, in the Int case above, n could have either type int or a, and they are not equivalent outside of that branch. As a first approximation, type inference will always work if a pattern-matching is annotated with types containing no free type variables (both on the scrutinee and the return type). This is the case in the above example, thanks to the type annotation containing only locally abstract types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c41d15644bc0e4699a63b1fcbb73b5b965f20ee" translate="yes" xml:space="preserve">
          <source>Type of formatted input functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf6e53f9d2885b8ecaefaa805ee9c2e406ebfb7" translate="yes" xml:space="preserve">
          <source>Type representing a file that will hold a series of heap snapshots together with additional information required to interpret those snapshots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1fb7e38670879b0890b7b24f14acf10d4a824d" translate="yes" xml:space="preserve">
          <source>Type variables ('a, 'b, &amp;hellip;) in a type t can be in either of two states: generalized (which means that the type t is valid for all possible instantiations of the variables) and not generalized (which means that the type t is valid only for one instantiation of the variables). In a let binding let name = expr, the type-checker normally generalizes as many type variables as possible in the type of expr. However, this leads to unsoundness (a well-typed program can crash) in conjunction with polymorphic mutable data structures. To avoid this, generalization is performed at let bindings only if the bound expression expr belongs to the class of &amp;ldquo;syntactic values&amp;rdquo;, which includes constants, identifiers, functions, tuples of syntactic values, etc. In all other cases (for instance, expr is a function application), a polymorphic mutable could have been created and generalization is therefore turned off for all variables occurring in contravariant or non-variant branches of the type. For instance, if the type of a non-value is 'a list the variable is generalizable (list is a covariant type constructor), but not in 'a list -&amp;gt; 'a list (the left branch of -&amp;gt; is contravariant) or 'a ref (ref is non-variant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3aef53774c7f5b428263ee8017835db5f94f3b" translate="yes" xml:space="preserve">
          <source>Type without principality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abe567be65d268f3a2696a5729946c3839700c3" translate="yes" xml:space="preserve">
          <source>Type-checking polymorphic variants is a subtle thing, and some expressions may result in more complex type information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd209f835b431620f2f7a16a1700ed3f687e554d" translate="yes" xml:space="preserve">
          <source>Type-level module aliases are used when checking module path equalities. That is, in a context where module name N is known to be an alias for P, not only these two module paths check as equal, but F (N) and F (P) are also recognized as equal. In the default compilation mode, this is the only difference with the previous approach of module aliases having just the same module type as the module they reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482b5d3e58f932060fa84ae1f7437ed62a8c84a5" translate="yes" xml:space="preserve">
          <source>Typing an interrupt character (usually ctrl-C) will not exit the debugger, but will terminate the action of any debugger command that is in progress and return to the debugger command level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c285dbae8ad75c11cf03e8d284872209563d4ef3" translate="yes" xml:space="preserve">
          <source>Uchar</source>
          <target state="translated">Uchar</target>
        </trans-unit>
        <trans-unit id="b677e5fef1be6d058b58bf6826880d3b971e64ab" translate="yes" xml:space="preserve">
          <source>Unary addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f695fa2b2a0f97bac964e65828d440f3804af708" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4484029bc001a1c51bfcd0596481e4db8652c6" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95141f64f4298daa6ecac13e37d4f744cc2fc09d" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a731455f59ced6b1f05e17234de09ab409ca508" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bc523ce5f481e4e4e3e37f7a2972ec888003bf" translate="yes" xml:space="preserve">
          <source>Unboxable type in primitive declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef308ac0940e6d74a453eb280aef926fedc4674" translate="yes" xml:space="preserve">
          <source>Unboxed integer values (ASCII code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6736fe7df2039684117bc316d99716a708ed0a5f" translate="yes" xml:space="preserve">
          <source>Unboxed integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e121c34de9aeb900b4b306f512b07e8a250bb6" translate="yes" xml:space="preserve">
          <source>Unboxing of the closure causes the value for x inside g to be passed as an argument to g rather than through its closure. This means that the closure of g becomes constant and may be lifted to toplevel, eliminating the runtime allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a0f02f56bad3e9e2035809eac95fd20eaae739" translate="yes" xml:space="preserve">
          <source>Uncaught exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6e9bbc140db8671611ddd7fc62a9229a86b7b8" translate="yes" xml:space="preserve">
          <source>Uncaught exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbda3791626315021f610d03deb27c5845679a10" translate="yes" xml:space="preserve">
          <source>Undeclared virtual method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4417ab4221f5d44f5639177b205205ee72e6ec" translate="yes" xml:space="preserve">
          <source>Under Unix and Cygwin, the command, the arguments, and the redirections if any are quoted using &lt;a href=&quot;filename#VALquote&quot;&gt;&lt;code&gt;Filename.quote&lt;/code&gt;&lt;/a&gt;, then concatenated. Under Win32, additional quoting is performed as required by the &lt;code&gt;cmd.exe&lt;/code&gt; shell that is called by &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ae8ab7df9ff2bd31ec5aefbc5d4b384fca6a0c" translate="yes" xml:space="preserve">
          <source>Under Windows ports (including Cygwin), comparison is case-insensitive, relying on &lt;code&gt;String.lowercase_ascii&lt;/code&gt;. Note that this does not match exactly the interpretation of case-insensitive filename equivalence from Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c30b17bfee8b41cae9acaf0fd4f36055ec37a0" translate="yes" xml:space="preserve">
          <source>Under Windows, use a forward slash (/) as the path separator instead of the usual backward slash (\). Under Unix, this option does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a98cf876c70e2d8f2c5c551aa28d19bc9e9f0b" translate="yes" xml:space="preserve">
          <source>Under the interactive system, the user types OCaml phrases terminated by ;; in response to the # prompt, and the system compiles them on the fly, executes them, and prints the outcome of evaluation. Phrases are either simple expressions, or let definitions of identifiers (either values or functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f972e21664aacd3d93f9c25c031fdd4f9b63cac" translate="yes" xml:space="preserve">
          <source>Unerasable optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855db78e2b7ecfbfa45751560055e580b1f0426b" translate="yes" xml:space="preserve">
          <source>Unescaped end-of-line in a string constant (non-portable code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430e184cd12c9c60b3c1f834e3311ddc5fd18ef3" translate="yes" xml:space="preserve">
          <source>Unexpected documentation comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26d585a4a4c58b3670977403cc6faff38857d45" translate="yes" xml:space="preserve">
          <source>Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a06870dcfd727858fe36ec3a78338d13e1109e1" translate="yes" xml:space="preserve">
          <source>Unicode mode: All path names, environment variables, command line arguments, etc. on the OCaml side are assumed to be encoded using UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2a3b5d1d14ff610dc48ac49c4fe2d90f085c55" translate="yes" xml:space="preserve">
          <source>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718811898739c2de10551b3e57d44b08120ca419" translate="yes" xml:space="preserve">
          <source>Unique ownership: the data may be accessed and mutated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="913f68f196b9229e63375dbfc548fa272e1c3652" translate="yes" xml:space="preserve">
          <source>Unit operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17d2a7a76cbbf26af7818ae32de850d9448591" translate="yes" xml:space="preserve">
          <source>Unit values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="9e87341cccc0656f2e5b6f6b5247bbf87754da13" translate="yes" xml:space="preserve">
          <source>Unix domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142fc83cd03cb48dcec9f0e42a287de6093e6ef6" translate="yes" xml:space="preserve">
          <source>Unix: Never use the strip command on executables produced by ocamlc -custom, this would remove the bytecode part of the executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4828c0275236c958b5d9f93626a6a151b8a88209" translate="yes" xml:space="preserve">
          <source>Unix: Security warning: never set the &amp;ldquo;setuid&amp;rdquo; or &amp;ldquo;setgid&amp;rdquo; bits on executables produced by ocamlc -custom, this would make them vulnerable to attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8628c58b8b0ed243ff4d2c25335007aa2662e49" translate="yes" xml:space="preserve">
          <source>Unix: The debugger is available on Unix systems that provide BSD sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2d5a3a8eb281aff095c532257d99f6e760b2f3" translate="yes" xml:space="preserve">
          <source>Unix: The following environment variables are also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ef177b89fca776de0c9cae01ff751ad7998744" translate="yes" xml:space="preserve">
          <source>Unix: The toplevel system is started by the command ocaml, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b888195998eac2b4be7e68badf7f6b41f579a285" translate="yes" xml:space="preserve">
          <source>Unix: This is material specific to the Unix family of operating systems, including Linux and macOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361cde79cb6eba9a80e1a3a1b776b3f1a76b9944" translate="yes" xml:space="preserve">
          <source>UnixLabels</source>
          <target state="translated">UnixLabels</target>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd278add8fd7700e1517d25235a824bc141942f" translate="yes" xml:space="preserve">
          <source>Unless overridden by an attribute (see below), specialisation of a function will not be attempted if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39064849c793d38854fa83e22673292ca5cc1ab" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unix#VALgetenv&quot;&gt;&lt;code&gt;Unix.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170fdfcfd23bafa2fc167cc8615430aab46288f6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unixlabels#VALgetenv&quot;&gt;&lt;code&gt;UnixLabels.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26dc7c0f8b5f19a49a3bac89490729e6e63f3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;em&gt;eventlog-tools&lt;/em&gt;, which possesses a specific knowledge of OCaml&amp;rsquo;s &lt;em&gt;Common Trace Format&lt;/em&gt; schema, it is required to provide the OCaml &lt;em&gt;metadata&lt;/em&gt; file to &lt;em&gt;babeltrace&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10e065515b33488b54ddec47d446cd640967c7" translate="yes" xml:space="preserve">
          <source>Unlike a regular type abbreviation, a private type abbreviation declares a type that is distinct from its implementation type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. However, coercions from the type to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are permitted. Moreover, the compiler &amp;ldquo;knows&amp;rdquo; the implementation type and can take advantage of this knowledge to perform type-directed optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80af5ea86d75496571d4eb5e961951632ea1c005" translate="yes" xml:space="preserve">
          <source>Unlike classes, which cannot be defined inside an expression, immediate objects can appear anywhere, using variables from their environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e450d4c92511601f39760b7d537c5cc9300ca0" translate="yes" xml:space="preserve">
          <source>Unlike constructed values, polymorphic variant values taking several arguments are not flattened. That is, `VConstr(v, w) is represented by a block of size 2, whose field number 1 contains the representation of the pair (v, w), rather than a block of size 3 containing v and w in fields 1 and 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf410a070338968c622e20408d5e4cb4a9c9cbd" translate="yes" xml:space="preserve">
          <source>Unlike most fuzzers, afl-fuzz observes the internal behaviour of the program being tested, and adjusts the test cases it generates to trigger unexplored execution paths. As a result, test cases generated by afl-fuzz cover more of the possible behaviours of the tested program than other fuzzers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b8debcdfd0af497e33fd32ebd0c329ed223c51" translate="yes" xml:space="preserve">
          <source>Unlike the core Stdlib module, submodules are not automatically &amp;ldquo;opened&amp;rdquo; when compilation starts, or when the toplevel system is launched. Hence it is necessary to use qualified identifiers to refer to the functions provided by these modules, or to add open directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0adb297358d6f84eb38585235f761f2474eba0" translate="yes" xml:space="preserve">
          <source>Unloading the dependent shared libraries that were loaded by the runtime, including dynlink plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e221fd771f76ac0c08ade26044bd31aad8410e11" translate="yes" xml:space="preserve">
          <source>Unlock a region</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbee51b6938b8833f6c9c14a960c32fc98b15cca" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b3fedb6918f76a1d2843a6217fb0459806116b" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex. Other threads suspended trying to lock the mutex will restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967ba8fb6e8f8143478c3728285a9c62c0f30241" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex. Other threads suspended trying to lock the mutex will restart. The mutex must have been previously locked by the thread that calls &lt;a href=&quot;mutex#VALunlock&quot;&gt;&lt;code&gt;Mutex.unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4d55156aa4689306af92e67c36608ab8808bc" translate="yes" xml:space="preserve">
          <source>Unneeded fields can be omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b0ad26af0b561093ef0ed3dfa3894398e55ee4" translate="yes" xml:space="preserve">
          <source>Unreachable case in a pattern-matching (based on type information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05779c93acf03e53c5e3dff1098251cef41b56c" translate="yes" xml:space="preserve">
          <source>Unsafe conversions (for advanced users)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b13f45b65846cb19caeb60345a2df74e3c0fec" translate="yes" xml:space="preserve">
          <source>Unsafely convert a byte sequence into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184711f70420afa3bb8971f5272f0cc7e5d58bbc" translate="yes" xml:space="preserve">
          <source>Unsafely convert a shared string to a byte sequence that should not be mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10f1dd8565cd1c52a800f50a4b69101c9d0316d" translate="yes" xml:space="preserve">
          <source>Unused ancestor variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2135e52f312e0c6e0e48ccbe7c4300233af3147" translate="yes" xml:space="preserve">
          <source>Unused blocks in the heap are automatically reclaimed by the garbage collector. This requires some cooperation from C code that manipulates heap-allocated blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d2bee7f4c5a8e21793774f016b9445cb2491e9" translate="yes" xml:space="preserve">
          <source>Unused constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8932307b60e4ea07a13fdca33701b5b386e6782" translate="yes" xml:space="preserve">
          <source>Unused extension constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce80385d6d0c6ec6ed8b2418d97b11a8b08e5a1" translate="yes" xml:space="preserve">
          <source>Unused for-loop index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd69a014e402f61b2816913ac1b533fe2cf4484" translate="yes" xml:space="preserve">
          <source>Unused function argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e88849e413a3426f34b869856edcd5da6f68428" translate="yes" xml:space="preserve">
          <source>Unused functor parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d908fc34cd65922d5192f731073878254bc325" translate="yes" xml:space="preserve">
          <source>Unused module declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ca9a5d74e69edb9e1f7c3d3fe760448d92b5d0" translate="yes" xml:space="preserve">
          <source>Unused open statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368828ea89de7758a83ef5a2303643e5169a7dc6" translate="yes" xml:space="preserve">
          <source>Unused open! statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd45978a6cade82e52fdd41f1ab2e9eff81f96c" translate="yes" xml:space="preserve">
          <source>Unused rec flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f8d493131a0a65a3df35bc380544a58e71361a" translate="yes" xml:space="preserve">
          <source>Unused type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d36a6d7c0770d8a403ea5d31dd91ea42c0b008" translate="yes" xml:space="preserve">
          <source>Unused value declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb036b86a60318fcf6bf365ea7870fc31e350c6" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed514447bdac477fcc7368e5493b6028c29815ca" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line. You can call this function in the semantic action of the rule that matches the end-of-line character. The function does nothing when position tracking is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537666d1dbd2fa0db7069f8d3cd01ec60272e5dd" translate="yes" xml:space="preserve">
          <source>Urgent condition on socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a643b76ebf1d85ac82c0fea6de291116e76f169" translate="yes" xml:space="preserve">
          <source>Use a reference to hold one of the two functions, as in :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739d4f5d5767f58211e673bb1ebe35dad451e751" translate="yes" xml:space="preserve">
          <source>Use a short form to display functors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151fed5b01cf4fdfa0cf96e7df2ca528006f940d" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker called to build the final executable and as the C compiler for compiling .c source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95d994a10737b249b1b6ca223f5268903a19eac" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option) and as the C compiler for compiling .c source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e56fe87118003db21cc87b9faea5b04603884d" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlc to call the bytecode compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aa8bdfb4a918e9e6c8a6c9078f5bcb7fa49544" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlopt to call the native-code compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a54deab044fad1c4ebb1e877ef8d4262ad6c2d" translate="yes" xml:space="preserve">
          <source>Use content of file as ocamldoc text to use as introduction (HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X and TeXinfo only). For HTML, the file is used to create the whole index.html file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bfae018cf53a781671cacffec6bc019506b2de" translate="yes" xml:space="preserve">
          <source>Use file as a script file name, even when it starts with a hyphen (-).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89af95620878921a365ac66230e7c38ab048bbd" translate="yes" xml:space="preserve">
          <source>Use filename as the Cascading Style Sheet file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78e4a0a07f4466e6a27ea7a18bff19f7ffd2bae" translate="yes" xml:space="preserve">
          <source>Use linear scan register allocation. Compiling with this allocator is faster than with the usual graph coloring allocator, sometimes quite drastically so for long functions and modules. On the other hand, the generated code can be a bit slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30651d527d291118e5c81ec20804fa7f8152da5e" translate="yes" xml:space="preserve">
          <source>Use of #-types to abbreviate polymorphic variant types is deprecated. If t is an exact variant type then #t translates to [&amp;lt;t], and #t[&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;] translates to [&amp;lt;t&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179cb603754bb4c16dcadb3f0efdb9ceb776af51" translate="yes" xml:space="preserve">
          <source>Use of the ocamlfind utility is recommended. However, if this is not possible, an alternative method may be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b672e57e082c051c9f8d5be383274df58d04c3" translate="yes" xml:space="preserve">
          <source>Use socket for communicating with the debugged program. See the description of the command set socket (section &amp;zwj;&lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;16.8.8&lt;/a&gt;) for the format of socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486b3ac03120a2b0d6cf25a7ef30edee35307954" translate="yes" xml:space="preserve">
          <source>Use socket for communicating with the debugged program. See the description of the command set socket (section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;) for the format of socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babde098406fd068128680f9d2260458e1e9bfbb" translate="yes" xml:space="preserve">
          <source>Use socket for communication with the program. socket can be either a file name, or an Internet port specification host:port, where host is a host name or an Internet address in dot notation, and port is a port number on the host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69190456e3d3b4a9937b9b8bc1a23ac4bcaa77e" translate="yes" xml:space="preserve">
          <source>Use symbolic formatter &lt;code&gt;ppf&lt;/code&gt; as usual, and retrieve symbolic items at end of pretty-printing by flushing symbolic output buffer &lt;code&gt;sob&lt;/code&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd5648874a47a9e1c6b2f8873e0f3b1a2133aed" translate="yes" xml:space="preserve">
          <source>Use the IA32 instructions to compute trigonometric and exponential functions, instead of calling the corresponding library routines. The functions affected are: atan, atan2, cos, log, log10, sin, sqrt and tan. The resulting code runs faster, but the range of supported arguments and the precision of the result can be reduced. In particular, trigonometric operations cos, sin, tan have their range reduced to [&amp;minus;2&lt;sup&gt;64&lt;/sup&gt;, 2&lt;sup&gt;64&lt;/sup&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7df00b2bebe3aff3a52ae3e64a0d6acf185eca" translate="yes" xml:space="preserve">
          <source>Use the processor instructions to compute trigonometric and exponential functions, instead of calling the corresponding library routines. The functions affected are: atan, atan2, cos, log, log10, sin, sqrt and tan. The resulting code runs faster, but the range of supported arguments and the precision of the result can be reduced. In particular, trigonometric operations cos, sin, tan have their range reduced to [&amp;minus;2&lt;sup&gt;64&lt;/sup&gt;, 2&lt;sup&gt;64&lt;/sup&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b4c58de40c5fb0e653f6415a4f1b48952e39fb" translate="yes" xml:space="preserve">
          <source>Use this function when your custom block holds only out-of-heap memory (memory allocated with malloc or caml_stat_alloc) and no other resources. used should be the number of bytes of out-of-heap memory that are held by your custom block. This function works like caml_alloc_custom except that the max parameter is under the control of the user (via the custom_major_ratio, custom_minor_ratio, and custom_minor_max_size parameters) and proportional to the heap sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7941ff55d3e49988c4c70473e63a19eae903c125" translate="yes" xml:space="preserve">
          <source>Use title as the title for the generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cc8398531eeec1655e1c8fcddb6c0c6fd1f30b" translate="yes" xml:space="preserve">
          <source>Useful functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f394ba35c69f78febcb28d6e3e5d50c70e2e7b0" translate="yes" xml:space="preserve">
          <source>Useless record with clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7150f5b0ccc9ad0053128f11ad4305cc1edea658" translate="yes" xml:space="preserve">
          <source>User id of the owner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565cf3c85ae326fd320b914df7dffad6039c9e02" translate="yes" xml:space="preserve">
          <source>User id, group id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21634717ab2d5493ce99d9e10587084f2fb636f2" translate="yes" xml:space="preserve">
          <source>User primitives are declared in an implementation file or struct&amp;hellip;end module expression using the external keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76bea74573cfe0bfd448177f94e560637c3a0b7" translate="yes" xml:space="preserve">
          <source>User primitives with arity greater than 5 should be implemented by two C functions. The first function, to be used in conjunction with the bytecode compiler ocamlc, receives two arguments: a pointer to an array of OCaml values (the values for the arguments), and an integer which is the number of arguments provided. The other function, to be used in conjunction with the native-code compiler ocamlopt, takes its arguments directly. For instance, here are the two C functions for the 7-argument primitive Nat.add_nat:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e2f5922d423f16a794e9dc47293889f985312b" translate="yes" xml:space="preserve">
          <source>User primitives with arity n &amp;le; 5 are implemented by C functions that take n arguments of type value, and return a result of type value. The type value is the type of the representations for OCaml values. It encodes objects of several base types (integers, floating-point numbers, strings, &amp;hellip;) as well as OCaml data structures. The type value and the associated conversion functions and macros are described in detail below. For instance, here is the declaration for the C function implementing the input primitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762efd31b9c09efddb154186f925907522846cd7" translate="yes" xml:space="preserve">
          <source>User primitives with arity n &amp;le; 5 are implemented by C functions that take n arguments of type value, and return a result of type value. The type value is the type of the representations for OCaml values. It encodes objects of several base types (integers, floating-point numbers, strings, &amp;zwj;&amp;hellip;) as well as OCaml data structures. The type value and the associated conversion functions and macros are described in detail below. For instance, here is the declaration for the C function implementing the input primitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc8df31d28f8bef488b448a18127e1554e1ec5c" translate="yes" xml:space="preserve">
          <source>User time for the children processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51ce85f72da94ad3e8baaae0981a64012711679" translate="yes" xml:space="preserve">
          <source>User time for the process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269caf30a531474b7d8f62fd8bc5f4d312f503d7" translate="yes" xml:space="preserve">
          <source>User-defined data structures include records and variants. Both are defined with the type declaration. Here, we declare a record type to represent rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b7a9c1cda7f0b25021511c2cba9fad3dba682c" translate="yes" xml:space="preserve">
          <source>Users can also define &lt;em&gt;and operators&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523c481222828c351b48f48cedb77b983332c9ab" translate="yes" xml:space="preserve">
          <source>Users can define &lt;em&gt;let operators&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7515319d18e38efa130281795ff468d3f181f0" translate="yes" xml:space="preserve">
          <source>Users can provide their own documentation generator to be used during step 2 instead of the default generators. All the information retrieved during the analysis step is available through the Odoc_info module, which gives access to all the types and functions representing the elements found in the given modules, with their associated description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686d35a1878d43f899780e120d4e310d31a7e4fc" translate="yes" xml:space="preserve">
          <source>Users of this module are encouraged to do &lt;code&gt;open&amp;nbsp;Bigarray&lt;/code&gt; in their source, then refer to array types and operations via short dot notation, e.g. &lt;code&gt;Array1.t&lt;/code&gt; or &lt;code&gt;Array2.sub&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aafe7611fe4c80acc31f514470ed26f519ac41" translate="yes" xml:space="preserve">
          <source>Using a generalized algebraic datatype (GADT) here allows writing well-typed polymorphic functions whose return type depend on the argument type, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186f5c930a2da2f4b139e25273ca52659b37d980" translate="yes" xml:space="preserve">
          <source>Using multiple threads (shared-memory concurrency) in a mixed OCaml/C application requires special precautions, which are described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4185b233b0e25ce53061fd3b5464cb0d929bdaf3" translate="yes" xml:space="preserve">
          <source>Using these attributes, it is possible to call C library functions with no indirection. For instance many math functions are defined this way in the OCaml standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a2ba33297635a5a100442a81946ae55e5b4d04" translate="yes" xml:space="preserve">
          <source>Using this mechanism, users of the library mylib.cma do not need to known that it references C code, nor whether this C code must be statically linked (using -custom) or dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41532f24be37374e2392e03dcd432e4f024ed57" translate="yes" xml:space="preserve">
          <source>Using this option may degrade the quality of generated code, but it reduces compilation time, both on clean and incremental builds. Indeed, with the native compiler, when the implementation of a compilation unit changes, all the units that depend on it may need to be recompiled &amp;ndash; because the cross-module information may have changed. If the compilation unit whose implementation changed was compiled with -opaque, no such recompilation needs to occur. This option can thus be used, for example, to get faster edit-compile-test feedback loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203e1ca511488e35dc039744252193ca885d3db1" translate="yes" xml:space="preserve">
          <source>Usually, the exhaustiveness check only tries to check whether the cases omitted from the pattern matching are typable or not. However, you can force it to try harder by adding &lt;em&gt;refutation cases&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="04aa2275978eeaf5c333af7b59fe2e0c90f69a4c" translate="yes" xml:space="preserve">
          <source>VM-level threads. This implementation performs time-sharing and context switching at the level of the OCaml virtual machine (bytecode interpreter). It is available on Unix systems, and supports only bytecode programs. It cannot be used with native-code programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e1b4eac2153fa2f4795d760b79561db8627b99" translate="yes" xml:space="preserve">
          <source>Val_bool(x) returns the OCaml boolean representing the truth value of the C integer x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e94cddb0996c3086e6aa59a514ec82cb5af2aeb" translate="yes" xml:space="preserve">
          <source>Val_int(0)</source>
          <target state="translated">Val_int(0)</target>
        </trans-unit>
        <trans-unit id="25e40da040a0c12ef6b4bb1d7758cf251f928ccd" translate="yes" xml:space="preserve">
          <source>Val_int(1)</source>
          <target state="translated">Val_int(1)</target>
        </trans-unit>
        <trans-unit id="e9cca6677134db576d9f41823ff8015b091892b7" translate="yes" xml:space="preserve">
          <source>Val_int(i) returns the value encoding the inti.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc663e78a10eafc288ec1404183ecc1e722e99b3" translate="yes" xml:space="preserve">
          <source>Val_long(l) returns the value encoding the long intl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708533d443ff5ad9bfce30739bbdb98c0fde38a4" translate="yes" xml:space="preserve">
          <source>Val_none represents the OCaml value None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89d186e5113422a8e6919d7df38f2c830163252" translate="yes" xml:space="preserve">
          <source>Val_true, Val_false represent the OCaml booleans true and false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="7b7c38fd2846399c3a4f294beacb165b7989b2b7" translate="yes" xml:space="preserve">
          <source>Values defined in tuple, as in let (x,y,z) = (1,2,3) are not kept by OCamldoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df0d057295bc592ab1965b6c77fca52e9a8d6d8" translate="yes" xml:space="preserve">
          <source>Values of a variant or record type declared private can be de-structured normally in pattern-matching or via the &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; notation for record accesses. However, values of these types cannot be constructed directly by constructor application or record construction. Moreover, assignment on a mutable field of a private record type is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1f9e546555b26d722af8ae1f8856ce883ea81b" translate="yes" xml:space="preserve">
          <source>Values of extensible variant types, for example exceptions (of extensible type &lt;code&gt;exn&lt;/code&gt;), returned by the unmarshaller should not be pattern-matched over through &lt;code&gt;match&amp;nbsp;...&amp;nbsp;with&lt;/code&gt; or &lt;code&gt;try&amp;nbsp;...&amp;nbsp;with&lt;/code&gt;, because unmarshalling does not preserve the information required for matching their constructors. Structural equalities with other extensible variant values does not work either. Most other uses such as Printexc.to_string, will still work as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a9ead228ce4b44ff6fa9fa633fd85106fce88469" translate="yes" xml:space="preserve">
          <source>Variables that appear in closure environments may themselves be boxed values. As such, they may be split into further closure variables, each of which corresponds to some projection from the original closure variable(s). This transformation is called &lt;em&gt;unboxing of closure variables&lt;/em&gt; or &lt;em&gt;unboxing of free variables of closures&lt;/em&gt;. It is only applied when there is reasonable certainty that there are no uses of the boxed free variable itself within the corresponding function bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94544efd875ca197c0357ce5be422f10d559a990" translate="yes" xml:space="preserve">
          <source>Variance describes how type constructors behave with respect to subtyping. Consider for instance a pair of type x and xy with x a subtype of xy, denoted x :&amp;gt; xy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7740708293bab268b6cdccd3b2b3105d72d56eb2" translate="yes" xml:space="preserve">
          <source>Variant values are either a constant constructor, or a non-constant constructor applied to a number of values. The former case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;; the latter case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(v&lt;sub&gt;1&lt;/sub&gt;, ... ,v&lt;sub&gt;n&lt;/sub&gt;), where the v&lt;sub&gt;i&lt;/sub&gt; are said to be the arguments of the non-constant constructor &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;. The parentheses may be omitted if there is only one argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f258f43c0222a52b02088ce228d5164e4202c0f3" translate="yes" xml:space="preserve">
          <source>Variants as presented in section &amp;zwj;&lt;a href=&quot;coreexamples#s%3Atut-recvariants&quot;&gt;1.4&lt;/a&gt; are a powerful tool to build data structures and algorithms. However they sometimes lack flexibility when used in modular programming. This is due to the fact that every constructor is assigned to a unique type when defined and used. Even if the same name appears in the definition of multiple types, the constructor itself belongs to only one type. Therefore, one cannot decide that a given constructor belongs to multiple types, or consider a value of some type to belong to some other type with more constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6fcc906c8b94204e9f80540ccb736117039b60" translate="yes" xml:space="preserve">
          <source>Variants as presented in section &lt;a href=&quot;coreexamples#s%3Atut-recvariants&quot;&gt;1.4&lt;/a&gt; are a powerful tool to build data structures and algorithms. However they sometimes lack flexibility when used in modular programming. This is due to the fact that every constructor is assigned to a unique type when defined and used. Even if the same name appears in the definition of multiple types, the constructor itself belongs to only one type. Therefore, one cannot decide that a given constructor belongs to multiple types, or consider a value of some type to belong to some other type with more constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defd91e4cb9da478b0d364b538e338f44780605a" translate="yes" xml:space="preserve">
          <source>Various characteristics of the OCaml Bigarray can be consulted from C as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1791879f0afda21c77fcdf13351b18a10a048118" translate="yes" xml:space="preserve">
          <source>Verbose mode. Display progress information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc93f5ac175e4f599a14011e6580fc7cd4bf97ed" translate="yes" xml:space="preserve">
          <source>Virtual instance variables were added in version 3.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="94f10d72f2176232cbf33b9b9b14740de63cf0c9" translate="yes" xml:space="preserve">
          <source>Wait until a non-ignored, non-blocked signal is delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e26e29aec6b9e363507c3295d1d357f540da00" translate="yes" xml:space="preserve">
          <source>Wait until one of the children processes die, and return its pid and termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53c4cd88232ecfc4592008efce859b27539051c" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c964679793a15053f9bc60ab25124e1cd8f63b1e" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels. The three list arguments are, respectively, a set of descriptors to check for reading (first argument), for writing (second argument), or for exceptional conditions (third argument). The fourth argument is the maximal timeout, in seconds; a negative fourth argument means no timeout (unbounded wait). The result is composed of three sets of descriptors: those ready for reading (first component), ready for writing (second component), and over which an exceptional condition is pending (third component).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c4fec1ee895767fc70c0290330ec024551e931" translate="yes" xml:space="preserve">
          <source>Waiting for file descriptors or processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdc343f664af6bf455c146e4304ebf776d509a8" translate="yes" xml:space="preserve">
          <source>Waits until all output written on the given file descriptor has been transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c66db7dd8fa9eda0d7fae5d4287c1b028a58fac" translate="yes" xml:space="preserve">
          <source>Warning 52 is there to prevent users from writing such fragile code in the first place. It does not occur on every matching on a literal string, but only in the case in which library authors expressed their intent to possibly change the constructor parameter value in the future, by using the attribute ocaml.warn_on_literal_pattern (see the manual section on builtin attributes in &lt;a href=&quot;attributes#ss%3Abuiltin-attributes&quot;&gt;8.12.1&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43338ae908e060e4a2fe4ebd54468c1f5df5e18f" translate="yes" xml:space="preserve">
          <source>Warning 57 is dedicated to these confusing cases where the specified left-to-right semantics is not equivalent to a non-deterministic semantics (any branch can be taken) relatively to a specific guard. More precisely, it warns when guard uses &amp;ldquo;ambiguous&amp;rdquo; variables, that are bound to different parts of the scrutinees by different sides of a or-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d46ffdf8d66bd8653cdefc4711e1d4925aba59" translate="yes" xml:space="preserve">
          <source>Warning numbers and letters which are out of the range of warnings that are currently defined are ignored. The warnings are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb4a60f1a2861c598eff1653b2b32f1785a6955" translate="yes" xml:space="preserve">
          <source>Warning numbers, letters and names which are not currently defined are ignored. The warnings are as follows (the name following each number specifies the mnemonic for that warning).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206f2d99f775f6c0030d57f5df574102132f9a4e" translate="yes" xml:space="preserve">
          <source>Warning on non-tail calls if @tailcall present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4fe3d506423f2f303c88f30c63f1455f72684d" translate="yes" xml:space="preserve">
          <source>Warning: If the output device of the pretty-printer is an output channel, repeated calls to &lt;code&gt;print_flush&lt;/code&gt; means repeated calls to &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; to flush the out channel; these explicit flush calls could foil the buffering strategy of output channels and could dramatically impact efficiency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeed1a9ddc8faa9785366b5b56daaeea8f4bc85c" translate="yes" xml:space="preserve">
          <source>Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the &lt;code&gt;Marshal.from_*&lt;/code&gt; functions is given as &lt;code&gt;'a&lt;/code&gt;, but this is misleading: the returned OCaml value does not possess type &lt;code&gt;'a&lt;/code&gt; for all &lt;code&gt;'a&lt;/code&gt;; it has one, unique type which cannot be determined at compile-time. The programmer should explicitly give the expected type of the returned value, using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f9837b70f002281732297feca2ee92ad79deed" translate="yes" xml:space="preserve">
          <source>Warning: mixing calls to pretty-printing functions of this module with calls to &lt;a href=&quot;stdlib&quot;&gt;&lt;code&gt;Stdlib&lt;/code&gt;&lt;/a&gt; low level output functions is error prone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be10b5fa87bfc72a683d87e69c9836c5eec8355c" translate="yes" xml:space="preserve">
          <source>Warning: the threads library is deprecated since version 4.08.0 of OCaml. Please switch to system threads, which have the same API. Lightweight threads with VM-level scheduling are provided by third-party libraries such as Lwt, but with a different API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461b5545b551a43d233140f163cd94622ad71616" translate="yes" xml:space="preserve">
          <source>We added print_endline &quot;lazy_two evaluation&quot; to see when the lazy expression is being evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f9b808c4ebc7ca886731051c46d1e0b955626c" translate="yes" xml:space="preserve">
          <source>We can also create a different kind of observer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d499139bd909cecce12873700b39b7d51639e5" translate="yes" xml:space="preserve">
          <source>We can also use lazy patterns in pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92cc615171f55d614bb69c4999244e87a3b2a6d1" translate="yes" xml:space="preserve">
          <source>We can apply this function to our store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a5f0a9709c52081ad4dfc756d77211d606cc3d" translate="yes" xml:space="preserve">
          <source>We can define a variant of backup that retains all copies. (We also add a method clear to manually erase all copies.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c79a613f0ce3961382adb27ff85c38372c8feaa" translate="yes" xml:space="preserve">
          <source>We can then select one implementation based on command-line arguments, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9fa09b79dd633060d36b6bddacc91dc3a48e89" translate="yes" xml:space="preserve">
          <source>We explain here the rules we applied when labeling OCaml libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99916877f63c0d92e57f380f6669743174a88f7e" translate="yes" xml:space="preserve">
          <source>We finish this introduction with a more complete example representative of the use of OCaml for symbolic processing: formal manipulations of arithmetic expressions containing variables. The following variant type describes the expressions we shall manipulate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bbe18b1f9a0ed2104dd3cee9b61a7eda1cf15b" translate="yes" xml:space="preserve">
          <source>We first consider the case of linear patterns, that is the case when all as bound variables are distinct. In &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; normally is string (or string option) except when &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; is a character constant, an underscore, a string constant of length one, a character set specification, or an alternation of those. Then, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; is char (or char option). Option types are introduced when overall rule matching does not imply matching of the bound sub-pattern. This is in particular the case of (&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;)? and of &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|(&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6822c23ba1ad8f02365bf80190a034387ff3d1" translate="yes" xml:space="preserve">
          <source>We first define a function to evaluate an expression given an environment that maps variable names to their values. For simplicity, the environment is represented as an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c893fa720bf9f99af9ed941bc43778057b94fe9" translate="yes" xml:space="preserve">
          <source>We have provided the &lt;a href=&quot;string#VALinit&quot;&gt;&lt;code&gt;String.init&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#VALmap&quot;&gt;&lt;code&gt;String.map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALmapi&quot;&gt;&lt;code&gt;String.mapi&lt;/code&gt;&lt;/a&gt; functions to cover most cases of building new strings. You should prefer those over &lt;code&gt;to_string&lt;/code&gt; or &lt;code&gt;unsafe_to_string&lt;/code&gt; whenever applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e997e614ce5467b0beba9472c3d7cf645ca20baa" translate="yes" xml:space="preserve">
          <source>We have seen that points and colored points have incompatible types. For instance, they cannot be mixed in the same list. However, a colored point can be coerced to a point, hiding its color method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d1884271f9999c046392d72f34e432867570e1" translate="yes" xml:space="preserve">
          <source>We illustrate inheritance by defining a class of colored points that inherits from the class of points. This class has all instance variables and all methods of class point, plus a new instance variable c and a new method color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9224c2732ce4c4c3d2e63c6afc04c8cd8c8d9" translate="yes" xml:space="preserve">
          <source>We make the method interest private, since clearly it should not be called freely from the outside. Here, it is only made accessible to subclasses that will manage monthly or yearly updates of the account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05df682a1f6f5e46b800692bc9a4a9b824c3c16" translate="yes" xml:space="preserve">
          <source>We now compile the OCaml code to a C object file and put it in a C library along with the stub code in modwrap.c and the OCaml runtime system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b0a8c86c819bd589244b573a951c5018c66dc0" translate="yes" xml:space="preserve">
          <source>We now create a new point p, instance of the point class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9e72dd84f2e2a1bac4efce2a171cca7af32b7f" translate="yes" xml:space="preserve">
          <source>We now give the GC rules corresponding to the low-level allocation functions caml_alloc_small and caml_alloc_shr. You can ignore those rules if you stick to the simplified allocation function caml_alloc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde80a3e10aa85c712afe16ab7e2341a6c678052" translate="yes" xml:space="preserve">
          <source>We now invoke some methods of p:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddf36c907f6ba061639dec7abaa73a666215441" translate="yes" xml:space="preserve">
          <source>We now refine this definition with a method to compute interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74647a14e3ed593ca08170fabed6ef0ef7ebd98" translate="yes" xml:space="preserve">
          <source>We said earlier that all OCaml objects are represented by the C type value, and one has to use macros such as Int_val to decode data from the value type. It is however possible to tell the OCaml native-code compiler to do this for us and pass arguments unboxed to the C function. Similarly it is possible to tell OCaml to expect the result unboxed and box it for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca3f24bc60b155d0819792bfa9331ce581c464f" translate="yes" xml:space="preserve">
          <source>We should soon fix a bug in the current definition: the deposit method can be used for withdrawing money by depositing negative amounts. We can fix this directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a0580da590e6d18812e52fcb9d241d72eb30f8" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you port your code to use the standard library version instead, as the changes required are minimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76922aca83aea453c196313c75e6f82cdc85b43" translate="yes" xml:space="preserve">
          <source>We then define a subclass money of comparable. The class money simply wraps floats as comparable objects. We will extend it below with more operations. We have to use a type constraint on the class parameter x because the primitive &amp;lt;= is a polymorphic function in OCaml. The inherit clause ensures that the type of objects of this class is an instance of #comparable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09f642369ffeb1d47d15e3a190a4aa7660841b9" translate="yes" xml:space="preserve">
          <source>We then recover polymorphism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df96e9f187249271f3cc2c30ce856d1def153907" translate="yes" xml:space="preserve">
          <source>We use lazy (expr) to delay the evaluation of some expression expr. For example, we can defer the computation of 1+1 until we need the result of that expression, 2. Let us see how we initialize a lazy expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8138516fe760085bbe99cc7f9cac0b5a490449c" translate="yes" xml:space="preserve">
          <source>We want to bind the function getenv in a way that works both under Unix and Windows. Under Unix this function has the prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d6d8214460953d9bf3607daeaf4f2e1dcf6dfd" translate="yes" xml:space="preserve">
          <source>We will not try here to explain in detail how type inference works. One must just understand that there is not enough information in the above program to deduce the correct type of g or bump. That is, there is no way to know whether an argument is optional or not, or which is the correct order, by looking only at how a function is applied. The strategy used by the compiler is to assume that there are no optional arguments, and that applications are done in the right order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="d22283d948c9488ada65248c6645510b567f8a49" translate="yes" xml:space="preserve">
          <source>Weak arrays cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; nor the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72045a1c4a2a8b8f303cdae651cfaef5a76eca1e" translate="yes" xml:space="preserve">
          <source>Weak hash sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e14058b3fbf260f23ab0c6884c945aa8da01d1a" translate="yes" xml:space="preserve">
          <source>What happens when a process tries to lock a region of a file that is already locked by the same process depends on the OS. On POSIX-compliant systems, the second lock operation succeeds and may &quot;promote&quot; the older lock from read lock to write lock. On Windows, the second lock operation will block or fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0988be2bfd0c6854f41080dea8b6f91bf9a1370d" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c21717a7fc138d58564167fcb6dd12bbcbe404" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal: &lt;code&gt;Signal_default&lt;/code&gt;: take the default behavior (usually: abort the program), &lt;code&gt;Signal_ignore&lt;/code&gt;: ignore the signal, &lt;code&gt;Signal_handle&amp;nbsp;f&lt;/code&gt;: call function &lt;code&gt;f&lt;/code&gt;, giving it the signal number as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013f727f75893e8217087a1af3c906ca342fa52" translate="yes" xml:space="preserve">
          <source>When -O2 is specified two rounds of optimisation are performed. The first round uses the default parameters (see above). The second uses the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf8e597524e8aee8c13ef1751d22f48ce086204" translate="yes" xml:space="preserve">
          <source>When -O3 is specified three rounds of optimisation are performed. The first two rounds are as for -O2. The third round uses the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51e2474b26cb6aa186686913f31b780794afaba" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class body, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a new object containing the instance variables and methods of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b82cf9cee86acdbc64dbbf0fb149429ecccc72a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class function, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a function expecting the same number of arguments and returning a new object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ac323c3ecca6b336d0c993fce513966e3c8814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;, &lt;code&gt;pp_set_geometry&amp;nbsp;ppf&amp;nbsp;~max_indent&amp;nbsp;~margin&lt;/code&gt; is equivalent to &lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin;&amp;nbsp;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent&lt;/code&gt;; and avoids the subtly incorrect &lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent;&amp;nbsp;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28129a04e7cd0c48e2322610116e87d33bc4f9d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Array.sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bdfe21627fc64c618784351aca6192eaa2423d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1feca9d22707497e3af035ccb842d458f8e939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;with_positions&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, lexer actions should not modify position fields. Doing it nevertheless could re-enable the &lt;code&gt;with_position&lt;/code&gt; mode and degrade performances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1130d10406644bd2995a03b20217aafac1d7c0" translate="yes" xml:space="preserve">
          <source>When OCaml bytecode produced by ocamlc -g is embedded in a C program, no debugging information is included, and therefore it is impossible to print stack backtraces on uncaught exceptions. This is not the case when native code produced by ocamlopt -g is embedded in a C program: stack backtrace information is available, but the backtrace mechanism needs to be turned on programmatically. This can be achieved from the OCaml side by calling Printexc.record_backtrace true in the initialization of one of the OCaml modules. This can also be achieved from the C side by calling caml_record_backtrace(Val_int(1)); in the OCaml-C glue code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34f78824091c7508d92682b1802b558ea0fa5f7" translate="yes" xml:space="preserve">
          <source>When OCaml calls the C code implementing a primitive, the master lock is held, therefore the C code has full access to the facilities of the run-time system. However, no other thread can execute OCaml code concurrently with the C code of the primitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731df544ab2a9ec7204d741cd8c2456b1fe24993" translate="yes" xml:space="preserve">
          <source>When a function is passed as an argument to a higher-order function, labels must match in both types. Neither adding nor removing labels are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dec26d8a7e9ea065435190bd81832097f83991b" translate="yes" xml:space="preserve">
          <source>When a recursive call to a function (within the definition of that function or another in the same mutually-recursive group) is inlined, the procedure is also known as &lt;em&gt;unrolling&lt;/em&gt;. This is somewhat akin to loop peeling. For example, given the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c166cb381f772c894053718af4cc540b7764c1" translate="yes" xml:space="preserve">
          <source>When a shift/reduce conflict cannot be resolved using the above method, then ocamlyacc will output a warning and the parser will always shift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c9efd30cc98ee4407de08fe91f7e2b81b5c1a5" translate="yes" xml:space="preserve">
          <source>When a type is unboxable (i.e. a record with a single argument or a concrete datatype with a single constructor of one argument) it will be unboxed unless annotated with [@@ocaml.boxed].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683b509729033268c58f4450cd64b5d3d02b55b7" translate="yes" xml:space="preserve">
          <source>When a type is unboxable it will be boxed unless annotated with [@@ocaml.unboxed]. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b5be3859c652fd4f119fc5dd900a23ee51ed0" translate="yes" xml:space="preserve">
          <source>When a type is visible under several module-paths, use the shortest one when printing the type&amp;rsquo;s name in inferred interfaces and error and warning messages. Identifier names starting with an underscore _ or containing double underscores __ incur a penalty of +10 when computing their length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41d0dc17088def45b04aa6a11a3b3a215c0e87e" translate="yes" xml:space="preserve">
          <source>When an or-pattern composed of variant tags is wrapped inside an alias-pattern, the alias is given a type containing only the tags enumerated in the or-pattern. This allows for many useful idioms, like incremental definition of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b38d80c97fd5053b560c8766f83a7af6d7bbf2" translate="yes" xml:space="preserve">
          <source>When appearing in a module signature, this definition specifies nothing on the type constructor, besides its number of parameters: its representation is hidden and it is assumed incompatible with any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690e2c95aca5c0bc8bb37466d7f1bfe8a47ce028" translate="yes" xml:space="preserve">
          <source>When both sides of the = sign are the same, it is possible to avoid repeating the field name by eliding the =field part:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9a1d592aa8045ca5f8c840dfe01b1a0d44dcfb" translate="yes" xml:space="preserve">
          <source>When converting an exception into a string, the printers will be invoked in the reverse order of their registrations, until a printer returns a &lt;code&gt;Some&amp;nbsp;s&lt;/code&gt; value (if no such printer exists, the runtime will use a generic printer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034158012eb7ccfe68c6898fd0ac8e5a62c3f38e" translate="yes" xml:space="preserve">
          <source>When exceptions are used as a control structure, it can be useful to make them as local as possible by using a locally defined exception. For instance, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1f2ef9b9ed142d065447a3892a3e48b77c3be4" translate="yes" xml:space="preserve">
          <source>When in -Oclassic mode, -inline behaves as in previous versions of the compiler: it is the maximum size of function to be considered for inlining. See section &lt;a href=&quot;#ss%3Aflambda-classic&quot;&gt;19.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1077be7d93082bb39e5870bf19a2eea51954852c" translate="yes" xml:space="preserve">
          <source>When in -Oclassic mode, -inline behaves as in previous versions of the compiler: it is the maximum size of function to be considered for inlining. See section &lt;a href=&quot;#ss%3Aflambda-classic&quot;&gt;21.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492ff2355909728e85c6f2a21a225e71b2f44177" translate="yes" xml:space="preserve">
          <source>When linking .cmalibraries, ignore -custom, -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9d6d9ab3ba56bf035a511bd9d449eca44727f4" translate="yes" xml:space="preserve">
          <source>When linking .cmxalibraries, ignore -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9786d60e36ba6a188f3be087530ee4ca55af901" translate="yes" xml:space="preserve">
          <source>When not in -Oclassic mode, -inline limits the total size of functions considered for inlining during any speculative inlining search. (See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;19.3.6&lt;/a&gt;.) Note that this parameter does not control the assessment as to whether any particular function may be inlined. Raising it to excessive amounts will not necessarily cause more functions to be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b73d8b95c745a7e82f1c332d3753eddb94d728d" translate="yes" xml:space="preserve">
          <source>When not in -Oclassic mode, -inline limits the total size of functions considered for inlining during any speculative inlining search. (See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.) Note that this parameter does not control the assessment as to whether any particular function may be inlined. Raising it to excessive amounts will not necessarily cause more functions to be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f386ef166191d4de341a91dd5a815dc5eed34230" translate="yes" xml:space="preserve">
          <source>When opening a semantic tag with name &lt;code&gt;t&lt;/code&gt;, the string &lt;code&gt;t&lt;/code&gt; is passed to the opening tag-marking function (the &lt;code&gt;mark_open_stag&lt;/code&gt; field of the record &lt;code&gt;tag_funs&lt;/code&gt;), that must return the opening tag marker for that name. When the next call to &lt;code&gt;close_stag&amp;nbsp;()&lt;/code&gt; happens, the semantic tag name &lt;code&gt;t&lt;/code&gt; is sent back to the closing tag-marking function (the &lt;code&gt;mark_close_stag&lt;/code&gt; field of record &lt;code&gt;tag_funs&lt;/code&gt;), that must return a closing tag marker for that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6a70f9cbe6b81b3df98290d76833a41a28f8d6" translate="yes" xml:space="preserve">
          <source>When pattern matching on records, it can be useful to match only few fields of a record. Eliding fields can be done either implicitly or explicitly by ending the record pattern with ; _. However, implicit field elision is at odd with pattern matching exhaustiveness checks. Enabling warning 9 prioritizes exhaustiveness checks over the convenience of implicit field elision and will warn on implicit field elision in record patterns. In particular, this warning can help to spot exhaustive record pattern that may need to be updated after the addition of new fields to a record type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76609a8a49e03dd9fd02fa1bebd9c6296cdf2d26" translate="yes" xml:space="preserve">
          <source>When printing a complex expression, a name of the form $integer is automatically assigned to its value. Such names are also assigned to parts of the value that cannot be printed because the maximal printing depth is exceeded. Named values can be printed later on with the commands p $integer or d $integer. Named values are valid only as long as the program is stopped. They are forgotten as soon as the program resumes execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31cc3eb55d7e0d6628001e85e93e466eecc068" translate="yes" xml:space="preserve">
          <source>When printing error messages, the toplevel system attempts to underline visually the location of the error. It consults the TERM variable to determines the type of output terminal and look up its capabilities in the terminal database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d7dd40d4664a834488e3a90e05acacdcd71cbb" translate="yes" xml:space="preserve">
          <source>When printing string values, non-ascii bytes ( &amp;gt; \0x7E ) are printed as decimal escape sequence if OCAMLTOP_UTF_8 is set to false. Otherwise, they are printed unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3624360ff971981bc315fd47d2593c900214b5" translate="yes" xml:space="preserve">
          <source>When scanning needs one more character, the given function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b6eef346373892dc63825b86c73cd321a24ef" translate="yes" xml:space="preserve">
          <source>When speculation starts the inlining threshold starts at the value set by -inline (or -inline-toplevel if appropriate, see above). Upon making a speculative inlining decision the threshold is reduced by the code size of the function being inlined. If the threshold becomes exhausted, at or below zero, no further speculation will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2861d14369b79117e494b17a13e3c456dfe6e4" translate="yes" xml:space="preserve">
          <source>When symbolic links are created to existing targets, this distinction doesn't matter and &lt;code&gt;symlink&lt;/code&gt; will automatically create the correct kind of symbolic link. The distinction matters when a symbolic link is created to a non-existent target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6a9ec1d0aaddbdc02b4a3efa6219fe94407366" translate="yes" xml:space="preserve">
          <source>When the body of a local open expression is delimited by [], [||], or {}, the parentheses can be omitted. For expression, parentheses can also be omitted for {&amp;lt;&amp;gt;}. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060d48655d567b2d042c60f8b5fbed496d586590" translate="yes" xml:space="preserve">
          <source>When the body of a local open pattern is delimited by [], [||], or {}, the parentheses can be omitted. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29adbac74a25822a7bfb536a7de8866290251fde" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a reference to a free module identifier Mod, it looks in the search path for a file named Mod.cmi or mod.cmi and loads the compiled interface contained in that file. As a consequence, renaming .cmi files is not advised: the name of a .cmi file must always correspond to the name of the compilation unit it implements. It is admissible to move them to another directory, if their base name is preserved, and the correct -I options are given to the compiler. The compiler will flag an error if it loads a .cmi file that has been renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504fc87ac9efbf21d3ea36072e2cab3a4f1c5a34" translate="yes" xml:space="preserve">
          <source>When the compiler flag -no-alias-deps is enabled, type-level module aliases are also exploited to avoid introducing dependencies between compilation units. Namely, a module alias referring to a module inside another compilation unit does not introduce a link-time dependency on that compilation unit, as long as it is not dereferenced; it still introduces a compile-time dependency if the interface needs to be read, &lt;em&gt;i.e.&lt;/em&gt; if the module is a submodule of the compilation unit, or if some type components are referred to. Additionally, accessing a module alias introduces a link-time dependency on the compilation unit containing the module referenced by the alias, rather than the compilation unit containing the alias. Note that these differences in link-time behavior may be incompatible with the previous behavior, as some compilation units might not be extracted from libraries, and their side-effects ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3aad510e70a7c27301bea92f55e2778f037e8a3" translate="yes" xml:space="preserve">
          <source>When the function has no more character to provide, it &lt;em&gt;must&lt;/em&gt; signal an end-of-input condition by raising the exception &lt;code&gt;End_of_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93016f799b9860f1f90e3e6d4310d2cea8085d23" translate="yes" xml:space="preserve">
          <source>When the input can not be read according to the format string specification, formatted input functions typically raise exception &lt;code&gt;Scan_failure&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f218c5e044857f4d05b8d252e8b08d203dafa61d" translate="yes" xml:space="preserve">
          <source>When the native compiler compiles an implementation, by default it produces a .cmx file containing information for cross-module optimization. It also expects .cmx files to be present for the dependencies of the currently compiled source, and uses them for optimization. Since OCaml 4.03, the compiler will emit a warning if it is unable to locate the .cmx file of one of those dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04821ef004e6a266283080b3e608b0f7733de10e" translate="yes" xml:space="preserve">
          <source>When the primitive function is applied in an OCaml program, the C function is called with the values of the expressions to which the primitive is applied as arguments. The value returned by the function is passed back to the OCaml program as the result of the function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6cf0de3a117389ad73da14031486bc78be69b6" translate="yes" xml:space="preserve">
          <source>When the program aborts due to an uncaught exception, print a detailed &amp;ldquo;back trace&amp;rdquo; of the execution, showing where the exception was raised and which function calls were outstanding at this point. The back trace is printed only if the bytecode executable contains debugging information, i.e. was compiled and linked with the -g option to ocamlc set. This is equivalent to setting the b flag in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce0660bb7b30ee2fd54ec7cc295742eecbaf44e" translate="yes" xml:space="preserve">
          <source>When the program issues a call to fork, the debugger can either follow the child or the parent. By default, the debugger follows the parent process. The variable follow_fork_mode controls this behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b792e8e2e3970fdf3425d9b17c7de05d84adfbe" translate="yes" xml:space="preserve">
          <source>When the program stops, the debugger automatically selects the currently executing frame and describes it briefly as the frame command does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760b4f611d27d0bba924332cb9173f6280707de0" translate="yes" xml:space="preserve">
          <source>When the systhreads version of the &lt;code&gt;Thread&lt;/code&gt; module is loaded, this function redirects to &lt;code&gt;Thread.sigmask&lt;/code&gt;. I.e., &lt;code&gt;sigprocmask&lt;/code&gt; only changes the mask of the current thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6709b785b4a5aea7c7211a96d782993cfbb1a1c" translate="yes" xml:space="preserve">
          <source>When there are several objects of same nature and role, they are all left unlabeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd94383fdf162fa4f337cc16327bc78a72fa7eb" translate="yes" xml:space="preserve">
          <source>When there is no preferable object, all arguments are labeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8788e9cfbdfd7cb22b01576e3dae5fe0c90b56db" translate="yes" xml:space="preserve">
          <source>When this form is used together with the infix syntax for attributes, the attributes are considered to apply to the payload:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb287ff6ca578030aeae7bf2e7df239b02ae43f0" translate="yes" xml:space="preserve">
          <source>When used in conjunction with a parser generated by ocamlyacc, the semantic actions compute a value belonging to the type token defined by the generated parsing module. (See the description of ocamlyacc below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f283aeb0bc8ab5225f11e88785f10ccc2fe8775" translate="yes" xml:space="preserve">
          <source>When using a symbolic formatter, all regular pretty-printing activities occur but output material is symbolic and stored in a buffer of output items. At the end of pretty-printing, flushing the output buffer allows post-processing of symbolic output before performing low level output operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa6f4fe7d77e2f540e510a58951685232221d1f" translate="yes" xml:space="preserve">
          <source>When using flambda:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23308a4fe88a862b61f8a4b2bfdb65916c66b9f8" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;dune&lt;/em&gt; build system, this compiler invocation can be replicated using the flagsstanza when building an executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ed891e71155c65d68d420f137010fab4ba7b75" translate="yes" xml:space="preserve">
          <source>When using the automatic snapshot mode the profiling output is written to a file called &quot;spacetime-&amp;lt;pid&amp;gt;&quot; where &amp;lt;pid&amp;gt; is the process ID of the program. (If the program forks and continues executing then multiple files may be produced with different pid numbers.) The profiling output is by default written to the current working directory when the program starts. This may be customised by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable to the name of the desired directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff46176bb17d161a544e001f6343d1c85b5b2dc6" translate="yes" xml:space="preserve">
          <source>When using this mechanism, one should be aware that an exception backtrace is attached to the thread that saw it raised, rather than to the exception itself. Practically, it means that the code related to &lt;code&gt;fn&lt;/code&gt; should not use the backtrace if it has itself raised an exception before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93078379b3b9b83afae408b8507c81787951e245" translate="yes" xml:space="preserve">
          <source>When using threads, it is guaranteed that allocation callbacks are always run in the thread where the allocation takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e6d6f6aef357dd76b888573f6bf7222fe68aed" translate="yes" xml:space="preserve">
          <source>When we finally need the result of a lazy expression, we can call Lazy.force on that expression to force its evaluation. The function force comes from standard-library module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e379a737e559586d930adc6d411789e8e1ca7925" translate="yes" xml:space="preserve">
          <source>When writing stubs that need to be compiled under both Windows and Unix, the stubs need to be written in a way that allow the necessary conversions under Windows but that also work under Unix, where typically nothing particular needs to be done to support Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eea22179b14eb02869c4ff4d62cac522860c71" translate="yes" xml:space="preserve">
          <source>When you want to use distinct names for the variable and the label appearing in the type, you can use a naming label of the form ~name:. This also applies when the argument is not a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41972dadb8c6dd136819857ca5e83412d7f72bdd" translate="yes" xml:space="preserve">
          <source>Whenever the search path is modified, the debugger will clear any information it may have cached about the files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e406d63a5b51f65514b45dd47778c4144e8d39" translate="yes" xml:space="preserve">
          <source>Whether or not a particular ocamlopt uses Flambda may be determined by invoking it with the -config option and looking for any line starting with &amp;ldquo;flambda:&amp;rdquo;. If such a line is present and says &amp;ldquo;true&amp;rdquo;, then Flambda is supported, otherwise it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198cc493c18a84d95fe966d8c299f76f1fc4db83" translate="yes" xml:space="preserve">
          <source>Whether the block comes from unmarshalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5856d8278faa115f8e3ece8304ad767ca6a8b6cd" translate="yes" xml:space="preserve">
          <source>Whether the given &lt;code&gt;inet_addr&lt;/code&gt; is an IPv6 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef49626fec86141035673c16c5b533b286ee1a42" translate="yes" xml:space="preserve">
          <source>Whether the machine currently executing the Caml program is big-endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a38a7988745c99aff596e8d4cb4566b84631f5" translate="yes" xml:space="preserve">
          <source>Whether to linger on closed connections that have data present, and for how long (in seconds)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaf1897a76792493551caf9cb7b76e9ccab26c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are handled by &lt;code&gt;formatter_out_functions.out_indent&lt;/code&gt;, the strings will be handled by &lt;code&gt;formatter_out_functions.out_string&lt;/code&gt;. This allows for a custom formatter that handles indentation distinctly, for example, outputs &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; tags or &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07082aff84d3d6c58c93479955b2b92cb4da2e5" translate="yes" xml:space="preserve">
          <source>While class types c1 and c2 are different, both object types c1 and c2 expand to the same object type (same method names and types). Yet, when the domain of a coercion is left implicit and its co-domain is an abbreviation of a known class type, then the class type, rather than the object type, is used to derive the coercion function. This allows leaving the domain implicit in most cases when coercing form a subclass to its superclass. The type of a coercion can always be seen as below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6158ac4d7d9e28767d8869ab18311d19f991dae7" translate="yes" xml:space="preserve">
          <source>While objects of either class will behave the same, objects of their subclasses will be different. In a subclass of bad_functional_point, the method move will keep returning an object of the parent class. On the contrary, in a subclass of functional_point, the method move will return an object of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1327d963e242926568cdcda69b6c7938e8212df6" translate="yes" xml:space="preserve">
          <source>While parameterized classes may be polymorphic in their contents, they are not enough to allow polymorphism of method use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537e22dedd240b673c1f40fc0ae35d5719dbfcd0" translate="yes" xml:space="preserve">
          <source>While providing an accurate estimate of potential performance loss is difficult, test on various OCaml programs showed a total running time increase ranging from 1% to 8%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2bae5cd8894f914083548969308228cab1140a" translate="yes" xml:space="preserve">
          <source>While the Unicode version under Windows has the prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133a040a06d4d9ee4fa55f4d12f1b1b3a635c70e" translate="yes" xml:space="preserve">
          <source>While they provide an increased comfort for writing function applications, labels and optional arguments have the pitfall that they cannot be inferred as completely as the rest of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc2b984675e89033322a631785f2e2695c39634" translate="yes" xml:space="preserve">
          <source>While this property is generally intuitive, there is at least one specific case where a different semantics might be expected. Consider a pattern followed by a when-guard: | &amp;zwj;p &amp;zwj;when &amp;zwj;g &amp;zwj;-&amp;gt; &amp;zwj;e, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a933a1213833424b3c999c684da426e0bacb55cf" translate="yes" xml:space="preserve">
          <source>While this property is generally intuitive, there is at least one specific case where a different semantics might be expected. Consider a pattern followed by a when-guard: |pwheng-&amp;gt;e, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd40bf9067e6d85c2521942cd5aea37e0ec3683" translate="yes" xml:space="preserve">
          <source>Whole-backtrace printing functions also skip some uninformative slots; in that case, &lt;code&gt;format&amp;nbsp;pos&amp;nbsp;slot&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ffaa03b305fc0126ea578346ae1d6b55f3dcbe" translate="yes" xml:space="preserve">
          <source>Wildcard pattern given as argument to a constant constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bb2ce358da3362d349dc7dffbbc028b2897662" translate="yes" xml:space="preserve">
          <source>Windows only: allow the file to be deleted while still open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2d346eb667eea590c331ddf31fccbcc4d6b831" translate="yes" xml:space="preserve">
          <source>Windows symbolic links are available in Windows Vista onwards. There are some important differences between Windows symlinks and their POSIX counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe946cc38b1b8f9f48fa7c868b06c619142edd3" translate="yes" xml:space="preserve">
          <source>Windows symbolic links come in two flavours: directory and regular, which designate whether the symbolic link points to a directory or a file. The type must be correct - a directory symlink which actually points to a file cannot be selected with chdir and a file symlink which actually points to a directory cannot be read or written (note that Cygwin's emulation layer ignores this distinction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447eabd50cdaa0e176b6a5e8a5c67d40d79f8b6f" translate="yes" xml:space="preserve">
          <source>Windows with the MSVC compiler: the object file produced by OCaml have been compiled with the /MD flag, and therefore all other object files linked with it should also be compiled with /MD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b5ddaa1ca629f6f8bdd33966c0453bae3a01fc" translate="yes" xml:space="preserve">
          <source>Windows: A fairly complete emulation of the Unix system calls is provided in the Windows version of OCaml. The end of this chapter gives more information on the functions that are not supported under Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77e2d4c781ed2ce4243a9db7811f83b915be1f7" translate="yes" xml:space="preserve">
          <source>Windows: The Cygwin port of OCaml fully implements all functions from the Unix module. The native Win32 ports implement a subset of them. Below is a list of the functions that are not implemented, or only partially implemented, by the Win32 ports. Functions not mentioned are fully implemented and behave as described previously in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1778d9d388d1318f9dac928bdbd83df7f0e1159a" translate="yes" xml:space="preserve">
          <source>Windows: The debugger is available under the Cygwin port of OCaml, but not under the native Win32 ports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0ea0d69723944a116d425d001950cc0dcecc11" translate="yes" xml:space="preserve">
          <source>Windows: This is material specific to Microsoft Windows (Vista, 7, 8, 10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9513167feb53aba08956064362d9c1f15e80c9" translate="yes" xml:space="preserve">
          <source>Windows: This is material specific to Microsoft Windows (XP, Vista, 7, 8, 10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59e24d63c516a909f266896c2e9ddb1141ca9e7" translate="yes" xml:space="preserve">
          <source>Windows: Under several versions of Windows, bytecode executable files are self-executable only if their name ends in .exe. It is recommended to always give .exe names to bytecode executables, e.g. compile with ocamlc -o myprog.exe ... rather than ocamlc -o myprog ....</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2edb2340a5c0f0e98f5830d04cf40b983609fdf" translate="yes" xml:space="preserve">
          <source>With a regular polymorphic algebraic data type, the type parameters of the type constructor are constant within the definition of the type. For instance, we can look at arbitrarily nested list defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793a0b884a8cef1f81c2be80c8c54572694c3562" translate="yes" xml:space="preserve">
          <source>With explicit polymorphic annotations, it becomes possible to implement any recursive function that depends only on the structure of the nested lists and not on the type of the elements. For instance, a more complex example would be to compute the total number of elements of the nested lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aaeec849cd83352f9371c6d87cc72eeb181cde0" translate="yes" xml:space="preserve">
          <source>With first-class modules, it is possible to parametrize some code over the implementation of a module without using a functor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e369349c1d2c6f7f1e4a71739bc82fddb2fe1cc" translate="yes" xml:space="preserve">
          <source>With ocamlopt, you should do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780b3948c4b7fbdb7b79edddbe07b3956efd1b1f" translate="yes" xml:space="preserve">
          <source>With polymorphic variants, this original assumption is removed. That is, a variant tag does not belong to any type in particular, the type system will just check that it is an admissible value according to its use. You need not define a type before using a variant tag. A variant type will be inferred independently for each of its uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78139198d9c10d6168a26db0f9a8f08c4bf0df4" translate="yes" xml:space="preserve">
          <source>With respect to the variance of their parameters, private types are handled like abstract types. That is, if a private type has parameters, their variance is the one explicitly given by prefixing the parameter by a &amp;lsquo;+&amp;rsquo; or a &amp;lsquo;-&amp;rsquo;, it is invariant otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6641a1c12f08009ac05530d30c3227fe41a7d60" translate="yes" xml:space="preserve">
          <source>With this argument, id_again is seen as a function definition by the type checker and can therefore be generalized. This kind of manipulation is called eta-expansion in lambda calculus and is sometimes referred under this name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419106f5e3d58ced85f242c86baeb4dedb2d9727" translate="yes" xml:space="preserve">
          <source>With this functional update notation, the record on the left-hand side of with is copied except for the fields on the right-hand side which are updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b229f3dc4b42a2159ecd907f5544fdc40dedc449" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer emphasizes the box structure: if a structural box does not fit fully on a simple line, a break hint also splits the line if the splitting ``moves to the left'' (i.e. the new line gets an indentation smaller than the one of the current line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02ea2020d35ee95ea72c4ffc4631170ac6fef86" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer prints as much as possible material on every line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e073b44d4d068d7117f272b8038adbf1bf5ea" translate="yes" xml:space="preserve">
          <source>Wosize_val(v) returns the size of the block v, in words, excluding the header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d9a524a7c3c6c486a85947f3196b96b6b69775" translate="yes" xml:space="preserve">
          <source>Write a 1-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e0f6125bd34169b0d388120ea7dd10db632157" translate="yes" xml:space="preserve">
          <source>Write a 2-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3640b1f7b9b33fc7967e17559e1e2a50f0a96852" translate="yes" xml:space="preserve">
          <source>Write a 4-byte float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbd154bff247d5a942dd8e5515ed553c1a7390b" translate="yes" xml:space="preserve">
          <source>Write a 4-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715165742f4e141b3ddb7a279940fc6b55c0ca2e" translate="yes" xml:space="preserve">
          <source>Write a 8-byte float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2facaf6686edb20cf3e9091a815ffb2e2b89b1ac" translate="yes" xml:space="preserve">
          <source>Write a 8-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82c9510edfabc9175be85bb68c20dc9b6e99492" translate="yes" xml:space="preserve">
          <source>Write a digest on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d1fa4a93435c8cbbf3ca7eea7b612c499a6c10" translate="yes" xml:space="preserve">
          <source>Write an array of 1-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c977d44c3cd5560e8b2da234f19e0a15bea610a7" translate="yes" xml:space="preserve">
          <source>Write an array of 2-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c403b19464f207843f099b264ced8a01ca18f0" translate="yes" xml:space="preserve">
          <source>Write an array of 4-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53373896e51a6637bb7fe916341a7d92236445d" translate="yes" xml:space="preserve">
          <source>Write an array of 8-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f7f0f906de0511a7edb65c46d9427e81dab512" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba782992ef61637de9988b9893ce1faa4dcb5a1" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel. The given integer is taken modulo 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c0bd41c52ac23c0adc744eacbe4d241a2b2ad3" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aceab15eda014863baa6a1c5355e0e7be3b34c" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel. The given integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. The only reliable way to read it back is through the &lt;a href=&quot;stdlib#VALinput_binary_int&quot;&gt;&lt;code&gt;input_binary_int&lt;/code&gt;&lt;/a&gt; function. The format is compatible across all machines for a given version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9567ae72bdfa38f1bb204519eda84c455c31af" translate="yes" xml:space="preserve">
          <source>Write permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdc89f50c7c2a8bac5ec4a97b5d467ab66c6f1d" translate="yes" xml:space="preserve">
          <source>Write the byte sequence on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c61c80c2e96a62e362a46979a59bd049103d97c" translate="yes" xml:space="preserve">
          <source>Write the character on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95495287973862b47913b4cbd3b67affb139553" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bac5ed5d8e6829ddf07dd242543be1e64e07c8" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;. See the description of module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; for more information. &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;marshal#VALto_channel&quot;&gt;&lt;code&gt;Marshal.to_channel&lt;/code&gt;&lt;/a&gt; with an empty list of flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0101de444dbaca2559f24fe3f82d42b10b30dff5" translate="yes" xml:space="preserve">
          <source>Write the string on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a1114690fa6f09d76b5358d5f1efe1b0b6f056" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O data integrity completion'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c9f295e008153f31321c142fb1d08220a8d6c0" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O file integrity completion'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2e597738f972d389ca423a6fd654d10536c9fa46" translate="yes" xml:space="preserve">
          <source>XDG_CONFIG_HOME, HOME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d29c2695b2ef20f173bccc3cde5734c046270e" translate="yes" xml:space="preserve">
          <source>Xavier Leroy,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3691ae14052440bcf4e7fcb1a5a144ad4c587994" translate="yes" xml:space="preserve">
          <source>Year - 1900</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0083fa1822201a52d16c81cc73e7189d19db00a" translate="yes" xml:space="preserve">
          <source>You can act the same way for other kinds of generators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661bf01810306e132b3e8ac6dd4b7a3ec66d1b02" translate="yes" xml:space="preserve">
          <source>You can avoid such risks by annotating the definition itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc3edf7fc664fefdda41a9a96260f03ffd5b4e8" translate="yes" xml:space="preserve">
          <source>You can do this as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7255127139f50ce009377216fee49d815fb08180" translate="yes" xml:space="preserve">
          <source>You can ignore the first two lines of the error message. What matters is the last one: putting self into an external reference would make it impossible to extend it through inheritance. We will see in section &amp;zwj;&lt;a href=&quot;#s%3Ausing-coercions&quot;&gt;3.12&lt;/a&gt; a workaround to this problem. Note however that, since immediate objects are not extensible, the problem does not occur with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28971cf504f1ddc3ef622da769c247b303992256" translate="yes" xml:space="preserve">
          <source>You can ignore the first two lines of the error message. What matters is the last one: putting self into an external reference would make it impossible to extend it through inheritance. We will see in section &lt;a href=&quot;#s%3Ausing-coercions&quot;&gt;3.12&lt;/a&gt; a workaround to this problem. Note however that, since immediate objects are not extensible, the problem does not occur with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf876e27628653e073122db73ce91332f1ff4bd" translate="yes" xml:space="preserve">
          <source>You can jump directly to a given time, without stopping on breakpoints, using the goto command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1517e86749fa6650d7e132b11082d485c41230a" translate="yes" xml:space="preserve">
          <source>You can see it in the following two examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97764d97435c3bd71f977265f2ea46ca12fa1c01" translate="yes" xml:space="preserve">
          <source>You can use custom tags in the documentation comments, but they will have no effect if the generator used does not handle them. To use a custom tag, for example foo, just put @foo with some text in your comment, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b38d338b3c2ca9796551e6f35bcbba46e9edaa6" translate="yes" xml:space="preserve">
          <source>You have neglected to load in memory an implementation for a module with #load. See section &amp;zwj;&lt;a href=&quot;#s%3Atoplevel-modules&quot;&gt;10.3&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b472c524eb05921f02c45d9ced45aad041cf07" translate="yes" xml:space="preserve">
          <source>You have neglected to load in memory an implementation for a module with #load. See section &lt;a href=&quot;#s%3Atoplevel-modules&quot;&gt;10.3&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4220d4e276f5f289cffdd8a85915703d07a3b840" translate="yes" xml:space="preserve">
          <source>You may also selectively coerce values through pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf234cd629ada47a347b6e57492abc4f3fdf6533" translate="yes" xml:space="preserve">
          <source>You may also use the explicit pretty-printing box management and printing functions provided by this module. This style is more basic but more verbose than the concise &lt;code&gt;fprintf&lt;/code&gt; format strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfde5a7f39920505c89726af4b9f5350dc3b7e2" translate="yes" xml:space="preserve">
          <source>You may consider this module as providing an extension to the &lt;code&gt;printf&lt;/code&gt; facility to provide automatic line splitting. The addition of pretty-printing annotations to your regular &lt;code&gt;printf&lt;/code&gt; format strings gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function &lt;a href=&quot;format#VALfprintf&quot;&gt;&lt;code&gt;Format.fprintf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c55f2f29b4cce66bf9146a0c9abe5ac5838e51" translate="yes" xml:space="preserve">
          <source>You must not call any of the OCaml runtime functions or macros between registering and storing the value. Neither must you store anything in the variable v (likewise, the location p) that is not a valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96720e5c70f0c8e2f8ccaf81279ef4c128c7988" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel also closes the underlying file descriptor (unless it was already closed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0596316547d32d2417575f8e486406afcba8d4b6" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel flushes the data and closes the underlying file descriptor (unless it has already been closed, in which case the buffered data is lost).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="8d53a00e5e95994b8c03087aae9edf99059c5fad" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdada8324810d78c81310e77d05c5f3da0c92d67" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68cb4683ebb48572f956e05c0df868074c28605" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays. The &lt;code&gt;Array0&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of zero-dimensional arrays that only contain a single scalar value. Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79bef1c4de4a640570f94b254d7bfb2f7421b7ab" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dbf8ee7b1d74aefca48d3a61e9ed381afdeb89" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b7c489fe99a39ef8cdcb8fb3b8664a53ec84ff" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5cbe1467b65f8d9900519467617a8e9a29e7a" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845419fd360a1d51826ed64f653c49eddf9d1058" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#constr-name&quot;&gt;constr-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2503669881fa83efc7ff33724be786ec3d3cae" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#field-name&quot;&gt;field-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3883afd3da5e8553f5497e863411b042b05c61" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#value-name&quot;&gt;value-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3c4bcaa3c0479eac0d8fb95567a1abb3c68695" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ] |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9edeebdd153fabd8c188de80c045c7c47a2803" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;modules#module-items&quot;&gt;module-items&lt;/a&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcfe0a951210d687a08d6058977844f3198309a" translate="yes" xml:space="preserve">
          <source>[ | ] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { |&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a69e212d262bdf5b8dceb1fc60d112e0cfb471" translate="yes" xml:space="preserve">
          <source>[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="324489a2771b36bc101aa148e24a3e655d9fbefd" translate="yes" xml:space="preserve">
          <source>[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="aa724c53356d3b4dd10ec752edff87fe8fc39d8d" translate="yes" xml:space="preserve">
          <source>[&amp;gt; [ &lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; ] { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f94b240e531c8610f1704309aff71882f6eef1" translate="yes" xml:space="preserve">
          <source>[&amp;gt;`Off|`On] list means that to match this list, you should at least be able to match `Off and `On, without argument. [&amp;lt;`On|`Off|`Number of int] means that f may be applied to `Off, `On (both without argument), or `Numbern where n is an integer. The &amp;gt; and &amp;lt; inside the variant types show that they may still be refined, either by defining more tags or by allowing less. As such, they contain an implicit type variable. Because each of the variant types appears only once in the whole type, their implicit type variables are not shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad6903b1e8f6d74baf8ed15aaa7c98dec0bfe16" translate="yes" xml:space="preserve">
          <source>[&amp;lt; [|] &lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; { |&lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; } [ &amp;gt; { `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt; ] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91eb9225aeaaf5af7e440003eeb19a446fe1d920" translate="yes" xml:space="preserve">
          <source>[(&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] )] { &lt;a href=&quot;#class-field&quot;&gt;class-field&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d332459a8ba97fd50bbeae640304bc22182f343f" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473bd68ac267366051f84c875ad4ace6aebe4cae" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }[g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb7650e47eb2575d7ca0470858a5635efb70add" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7b19cb3116ea384d28dd687eadb2b073f38b7b" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61094b365d5af7b66e564ec21f930d790211eec" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83c9c47ab710c338712ade1bc4a393a41751ad2" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacf6a0cec197455f287a5adce559a8f020b3e02" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc29186baa94b0abab18a9f475047bb35e1fc9a2" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe40a287c598706fca1aade30b36d274123cdd57" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ffbd17c903f06a785acfdcfb392df90e8cf1e8" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422ae3d0903630a4c50138d05c0e8a498cb95069" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca2e3a71d147da84be67f0e560ab01b47292baf" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d527c5d16c2e5a5291a799a508cda294dc70460a" translate="yes" xml:space="preserve">
          <source>[;;] ( &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } ) { [;;] &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ ;;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } } [;;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7163edf1f91d0eebff5427eae672e4d9cf5843d3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57597bf34709cec5f732c01b918e6017d6666d8" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#ext-variance&quot;&gt;ext-variance&lt;/a&gt;] '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d179c5500c82803598c1678e833f6bbaec0ee57" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdc6cfd24896e6dc6cc850526aa2efc82121c21" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt; { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae5c7c192768c8fe819028167bfdf1f70539395" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-equation&quot;&gt;type-equation&lt;/a&gt;] [&lt;a href=&quot;#type-representation&quot;&gt;type-representation&lt;/a&gt;] { &lt;a href=&quot;#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb557ec36f883c7b8a8a2afb3047a4bc1856325e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;a href=&quot;#type-information&quot;&gt;type-information&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6809e04c28f4434af2ef4e79379f732d256a70a" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#variance&quot;&gt;variance&lt;/a&gt;] '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd52a26acaa62bbd70ddc4c699130c536a848817" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;:=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; { &lt;a href=&quot;typedecl#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c164a669568d725674f36078be81d4f3c7961a9" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#variance&quot;&gt;variance&lt;/a&gt;] _</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599aa502a5589fb3a6adecc0003ea60cd7943675" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7becd2f7108116acae7b49a97d7c92f66bc838c4" translate="yes" xml:space="preserve">
          <source>[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="a97816c7ac1508516fe749441f17b541f6dcf1ee" translate="yes" xml:space="preserve">
          <source>[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="fd2a6aca4a2be8058771e31cb975908901937c52" translate="yes" xml:space="preserve">
          <source>[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="60d4d5c4116c206bd450f81da29e892eb2cfc4cc" translate="yes" xml:space="preserve">
          <source>[[&amp;gt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n&lt;/sub&gt;|`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+m&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+m&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b806d0e4f77e2e0284e335435cebcd99e7a7ce8" translate="yes" xml:space="preserve">
          <source>[[&amp;lt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281ba5c5173bc37bf1a7dd71c6bf39e34b706f2e" translate="yes" xml:space="preserve">
          <source>[[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]] &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edaf48cc7b2a7dd234e24dfdfd72e38b7085745" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdb79a53e34b6dece67887c1bdac5d4037750d1" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d9466df26d58df397c13d44c392690fb44a7e1" translate="yes" xml:space="preserve">
          <source>[^character-set]</source>
          <target state="translated">[^character-set]</target>
        </trans-unit>
        <trans-unit id="7e9127ed709ebc3b2ec8ae101c18c49d92bb9145" translate="yes" xml:space="preserve">
          <source>[character-set]</source>
          <target state="translated">[character-set]</target>
        </trans-unit>
        <trans-unit id="6ed3105102954a4c5db0c3f02bc020ebe496dcb6" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a4b15b9df9538ce82dd3ac08074b0490cbc30" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; {&lt;a href=&quot;#attribute&quot;&gt;attribute&lt;/a&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06443cf549c345bc7626b16c688d241250965c11" translate="yes" xml:space="preserve">
          <source>[string]</source>
          <target state="translated">[string]</target>
        </trans-unit>
        <trans-unit id="2d934f0af3ee8393994f2178a9aaf1dfde4cfb36" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;] =&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad86b23e23597d8ca554d7819990cc4c9fc9bec1" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069e56de2f322b59836b7247c8a473377b4491fe" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779656c2e21df39bbf7b04df8d51a67fffe27328" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] |]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28304d85650beb4b7ca0b1cd85ad4393d19fef0" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] |]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6705cd22604179bf5ed99551e23a447c9c18d9" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;|]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcf6c5142718c920ce70ae1f57d451f361dfc5c" translate="yes" xml:space="preserve">
          <source>[||]</source>
          <target state="translated">[||]</target>
        </trans-unit>
        <trans-unit id="d83bdb55caec3e2da5eb3c08a6d885915882f6a2" translate="yes" xml:space="preserve">
          <source>\ ( \ ∣ &quot; ∣ ' ∣ n ∣ t ∣ b ∣ r ∣ space )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4231f0670f5f242554b99dbd1517d52ef7e1f81" translate="yes" xml:space="preserve">
          <source>\ (0&amp;hellip;9) (0&amp;hellip;9) (0&amp;hellip;9)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab006bb8aacdf6e68299bc1dffccc9bcc8ac3eaf" translate="yes" xml:space="preserve">
          <source>\&quot;</source>
          <target state="translated">\&quot;</target>
        </trans-unit>
        <trans-unit id="9ca863000c0131ce2b74e96a2de49fddf5ae1e10" translate="yes" xml:space="preserve">
          <source>\'</source>
          <target state="translated">\'</target>
        </trans-unit>
        <trans-unit id="9e94758983980504af303ef297fd2bf9d9cea063" translate="yes" xml:space="preserve">
          <source>\\</source>
          <target state="translated">\\</target>
        </trans-unit>
        <trans-unit id="4629ca1b60e263bdc4326334b23323e0434717a5" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>
        </trans-unit>
        <trans-unit id="3c0a62cb2906cc36c4a919715511fc14bd0b1cfd" translate="yes" xml:space="preserve">
          <source>\ddd</source>
          <target state="translated">\ddd</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="1dcf1062839b7f3fa08ae441ebac44ab82ff2e68" translate="yes" xml:space="preserve">
          <source>\newline { space ∣ tab }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f694a8c8e5720726fe11abb727991dbfce0136de" translate="yes" xml:space="preserve">
          <source>\o (0&amp;hellip;3) (0&amp;hellip;7) (0&amp;hellip;7)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2d76adab6d6c193d82eb1139d9e333cf65dd47" translate="yes" xml:space="preserve">
          <source>\oooo</source>
          <target state="translated">\oooo</target>
        </trans-unit>
        <trans-unit id="f12c84902108895980702c88db900ceea2d2ec01" translate="yes" xml:space="preserve">
          <source>\r</source>
          <target state="translated">\r</target>
        </trans-unit>
        <trans-unit id="16f8ba5a70c8e28946b3f0c93ffa5aa96ba95209" translate="yes" xml:space="preserve">
          <source>\space</source>
          <target state="translated">\space</target>
        </trans-unit>
        <trans-unit id="8bf81043e29dfc96a6fe1f30f7116f552de6e7d7" translate="yes" xml:space="preserve">
          <source>\t</source>
          <target state="translated">\t</target>
        </trans-unit>
        <trans-unit id="3ba84b441afbba0b1e2988ce22de81d518262043" translate="yes" xml:space="preserve">
          <source>\u{ { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f }&lt;sup&gt;+&lt;/sup&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b81fd78bdbb47b0a5ab4c46880e42421325e8df" translate="yes" xml:space="preserve">
          <source>\x (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44b0007f5fd55a953e09798658cb34da7bff02a" translate="yes" xml:space="preserve">
          <source>\xhh</source>
          <target state="translated">\xhh</target>
        </trans-unit>
        <trans-unit id="1288030afca6d49c1dce35c928f3a45658b3416e" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5aa8a0d688e811d242601925f92373e777ce4cef" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of [&amp;amp;] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; { &amp;amp;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1dc47e3d6863a7150f87ad565a12a951c55d0d" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e267804f3a59e590fa4fca005068eefe79eac" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af146e2e56d33085b35edb85f563497a0b676506" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589c478ac1da3277879e28e45c6d0d868a9a6ad6" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d701b7ecdfa0b9cb1d420b43c29ef0f3936f8e4" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97864d59da3aa41f746baaafd3463b784bc5abc" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection. This does not fully close the file descriptor associated with the channel, which you must remember to free via &lt;a href=&quot;stdlib#VALclose_in&quot;&gt;&lt;code&gt;close_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716971f89f753fc7aad67107c265548c7d9791d3" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unixlabels#VALopen_connection&quot;&gt;&lt;code&gt;UnixLabels.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa00406c3cd6c2ab4021edf2356e1e2e96cd8348" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unixlabels#VALopen_connection&quot;&gt;&lt;code&gt;UnixLabels.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection. This does not fully close the file descriptor associated with the channel, which you must remember to free via &lt;a href=&quot;stdlib#VALclose_in&quot;&gt;&lt;code&gt;close_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="ea5d250a9bdc29bd5f4b1349eff20396c9d6398a" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;metadata file&lt;/em&gt;, part of the OCaml distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3627b94701cbc5c760ad13bdc0b33a3b8054c03e" translate="yes" xml:space="preserve">
          <source>a byte sequence or string used as buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410ad4856c009112cb4466316bac03d480442255" translate="yes" xml:space="preserve">
          <source>a comparison function, e.g.Stdlib.compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffd5a6bca2d01c99caa3fbbfd548e1dd1dc49fc" translate="yes" xml:space="preserve">
          <source>a function to be applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0ee58df51bd23faa083dba2ed61cb6a7c8e44a" translate="yes" xml:space="preserve">
          <source>a length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0657a72d73073160443670ebf5cfedadba059" translate="yes" xml:space="preserve">
          <source>a library that provides the bytecode interpreter, the memory manager, and the standard primitives;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a66798daedccc860fc63fdf1ae2b663c64b1042" translate="yes" xml:space="preserve">
          <source>a non empty sequence of alphanumeric or &lt;code&gt;_&lt;/code&gt; characters,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4562ef2047fcddffcf8799aaa36e3a820d8e26" translate="yes" xml:space="preserve">
          <source>a position in a string, array or byte sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3597e8b38da36ab0c1d981d56037dc661f5feac2" translate="yes" xml:space="preserve">
          <source>a scanning indication (see scanning &lt;a href=&quot;scanf#indication&quot;&gt;&lt;i&gt;Scanning indications in format strings&lt;/i&gt;&lt;/a&gt;) has been encountered,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c98cfe033b7435d226fa7c4e0c163564903b703" translate="yes" xml:space="preserve">
          <source>a whitespace has been found (see &lt;a href=&quot;scanf#space&quot;&gt;&lt;i&gt;The space character in format strings&lt;/i&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f12541afcce175fb34bb05a79c95b76e765488b" translate="yes" xml:space="preserve">
          <source>access</source>
          <target state="translated">access</target>
        </trans-unit>
        <trans-unit id="73468898c9988e2f9e409b93e8bff16eaa79c0ba" translate="yes" xml:space="preserve">
          <source>alarm</source>
          <target state="translated">alarm</target>
        </trans-unit>
        <trans-unit id="ddb7aa66cca7d817b1bc050ddff1df3a3d3313a2" translate="yes" xml:space="preserve">
          <source>alias for &lt;a href=&quot;obj#TYPEt&quot;&gt;&lt;code&gt;Obj.t&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f245e454c594b6a6e02040aa04d0a87b60ce23e" translate="yes" xml:space="preserve">
          <source>all options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90ec074822453e3c07fb7ab40474dcc71b73158" translate="yes" xml:space="preserve">
          <source>all warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161d19cec4448cddf6f1df51bee30d4aee2ae72c" translate="yes" xml:space="preserve">
          <source>allocation functions (to create structured OCaml objects)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="c048122841cd0af39592cb281c9fb203718804c1" translate="yes" xml:space="preserve">
          <source>always raise Not_found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ecbcd070942bfb49c0a12b9a7ec1efd9ba5ea" translate="yes" xml:space="preserve">
          <source>always return 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c8e94591336deee254ea0cc7c2b84a3db46c0a" translate="yes" xml:space="preserve">
          <source>always returns [|1|] (since 2.00)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a99e3d4f923f05ce72c18387d14c99c8d94a725" translate="yes" xml:space="preserve">
          <source>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped &lt;code&gt;$&lt;/code&gt; character is a &lt;code&gt;$&lt;/code&gt; that immediately follows a backslash character; it then stands for a plain &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f561344ac08966f1d833c5f80ae36885b0ccc2db" translate="yes" xml:space="preserve">
          <source>an ephemeron cf &lt;a href=&quot;ephemeron&quot;&gt;&lt;code&gt;Ephemeron&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e268d2a4a07f3246144968e6813834db67163851" translate="yes" xml:space="preserve">
          <source>an ephemeron with an arbitrary number of keys of the same type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cd3ac13cb54892b26741dbb166711f8f8454ec" translate="yes" xml:space="preserve">
          <source>an ephemeron with one key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5370fc85d98d86b50c6ae717df05ae2178d72709" translate="yes" xml:space="preserve">
          <source>an ephemeron with two keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cd4ed7af141353dc06d425f19ec6f0174f1e40" translate="yes" xml:space="preserve">
          <source>an operation mode or a flag list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e68bf7052e323752495fd36eb5da81f37ffaa4" translate="yes" xml:space="preserve">
          <source>an unboxed integer;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7685d508f910a53eb29bb82f0913de7a8437fc" translate="yes" xml:space="preserve">
          <source>analysis of the source files;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d0949396bb159e985c5c968ec72002296c91a20c" translate="yes" xml:space="preserve">
          <source>and ( &amp;hellip; ) for the other grouping situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e243fd1598527c063c99e3c63851d61bb6bfc77" translate="yes" xml:space="preserve">
          <source>and (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9922f3e883eaa547f62f38fc740e5bebdd032962" translate="yes" xml:space="preserve">
          <source>and S with module M = N denotes the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135f68d2f2ba0ad3e5c9525d8a98fd85e8d326a" translate="yes" xml:space="preserve">
          <source>and a &lt;em&gt;trace file&lt;/em&gt;, generated by the runtime in the program being traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae5f607273fb6b8801476b6d4cb87cc1e985618" translate="yes" xml:space="preserve">
          <source>and as a result obtain a Mylib compilation unit, containing physically A and B as submodules, and with no dependencies on their respective compilation units. Here is a concrete example of a possible alternative approach:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e29eacfd66e6128d91b4e2e0d0efc56f09f7ab0" translate="yes" xml:space="preserve">
          <source>and attach several observers to the same object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04afbc59ec07d5cd168b50a57fcdba7a2dc031d7" translate="yes" xml:space="preserve">
          <source>and even use the alternative syntax for declaring functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6469a87a5b418647e9fa1d15ae7d5a10f99bdded" translate="yes" xml:space="preserve">
          <source>and link mod1.cmo before mod2.cmo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3522d8409fab2c8bd7a9a935e5958b1545b923" translate="yes" xml:space="preserve">
          <source>and not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb7579c980b6977ec641cb0d678c02d8d41f49d" translate="yes" xml:space="preserve">
          <source>and one on the result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c66020d5a4a796b432d2d3f2eb08a6fbfd7761" translate="yes" xml:space="preserve">
          <source>and structured input-output (the functions from the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module, as well as &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144cf0ff7c73bffecc1589a4d490aabaa5c658aa" translate="yes" xml:space="preserve">
          <source>and the compiler will emit warning 50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9890a7a2830cc4814f3a238d40f7dd8ee611982a" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -custom and -cclib -lmylib options, achieving the same effect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1c85b81e1502a02da4141f1ac7368f38fd4b9b" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -dllib -lmylib option, achieving the same effect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6c1e93df972fdb89a4efdabb2e6a30ae642fd5" translate="yes" xml:space="preserve">
          <source>and then apply them using this convenient syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be865b252a2a8e9c53f840f52c864386e874af8b" translate="yes" xml:space="preserve">
          <source>and then ask users to provide the -custom and -cclib -lmylib options themselves at link-time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478c17c32f1bc3336788616eaad90d7da7f5fbd4" translate="yes" xml:space="preserve">
          <source>and then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d22cfbed814dcb099f0e8e67505f5a70d8eb06c" translate="yes" xml:space="preserve">
          <source>and universally quantified object methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f3c67631f2732767dad5f715563cd89ad668cf" translate="yes" xml:space="preserve">
          <source>and used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96e234c3b1fd505f14ec96a363efd96eb569033" translate="yes" xml:space="preserve">
          <source>and, &lt;a href=&quot;expr#hevea_manual.kwd21&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;typedecl#hevea_manual.kwd93&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd122&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd144&quot;&gt;7.9.3&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd146&quot;&gt;7.9.4&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd149&quot;&gt;7.9.5&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd154&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd183&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;manual024#hevea_manual.kwd207&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#hevea_manual.kwd215&quot;&gt;8.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78a0dbec27997c1afa661cc0130d0ef25877671" translate="yes" xml:space="preserve">
          <source>and-operator</source>
          <target state="translated">and-operator</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="97aa373d2868b633a71970cbafb44ac0d10e9bd5" translate="yes" xml:space="preserve">
          <source>arg1_type -&amp;gt; arg2_type -&amp;gt; ... -&amp;gt; return_type. For example, the type inferred for insert, 'a -&amp;gt; 'a list -&amp;gt; 'a list, means that insert takes two arguments, an element of any type 'a and a list with elements of the same type 'a and returns a list of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="be976c9e3ea651e90f3e19650398efe5d38b4ca1" translate="yes" xml:space="preserve">
          <source>as a consequence, scanning a &lt;code&gt;%s&lt;/code&gt; conversion never raises exception &lt;code&gt;End_of_file&lt;/code&gt;: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or &lt;code&gt;&quot;&quot;&lt;/code&gt; if none were ever read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b953d2a9813da51eff31ce5c0d74db5b4435257" translate="yes" xml:space="preserve">
          <source>as mentioned above, a &lt;code&gt;%s&lt;/code&gt; conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06307b62a784724a222e8111cfba9c75dd2eeba4" translate="yes" xml:space="preserve">
          <source>as, &lt;a href=&quot;types#hevea_manual.kwd7&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd8&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd9&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd15&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd16&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd17&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd124&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd132&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1294692e88bc3cf578b0cf93126b82e453a3a24f" translate="yes" xml:space="preserve">
          <source>asr</source>
          <target state="translated">asr</target>
        </trans-unit>
        <trans-unit id="173bd3aa4f99ba650649627effe8f47f679d7eb5" translate="yes" xml:space="preserve">
          <source>asr, &lt;a href=&quot;names#hevea_manual.kwd6&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd57&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd76&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd83&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e6234fdd662a3db73c32822887385e189a0e4c" translate="yes" xml:space="preserve">
          <source>assert, &lt;a href=&quot;expr#hevea_manual.kwd86&quot;&gt;7.7.8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635740097092e2b68a7644b5822ee2b10f283f3e" translate="yes" xml:space="preserve">
          <source>assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ad025fd42fe9ff686831aa8d53087f4ec6eef49" translate="yes" xml:space="preserve">
          <source>at the end of pretty-printing, flush the pretty-printer to display all the remaining material, e.g. evaluate &lt;code&gt;print_newline&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68c8b4d7fc1eb33ed288e6ff174b420fcadbab4" translate="yes" xml:space="preserve">
          <source>attr-id</source>
          <target state="translated">attr-id</target>
        </trans-unit>
        <trans-unit id="8d6f70260aa9cdd6cb0e7d628096d35d26e1ecb9" translate="yes" xml:space="preserve">
          <source>attr-payload</source>
          <target state="translated">attr-payload</target>
        </trans-unit>
        <trans-unit id="2c317cd0735d9046d7675c475fa1c6dce647953f" translate="yes" xml:space="preserve">
          <source>attribute</source>
          <target state="translated">attribute</target>
        </trans-unit>
        <trans-unit id="132060a9542263d8600782a359c79ea7e4420a18" translate="yes" xml:space="preserve">
          <source>attribute:</source>
          <target state="translated">attribute:</target>
        </trans-unit>
        <trans-unit id="0d612c12d2ac33625bf3e0351b6f5e4f73829fa8" translate="yes" xml:space="preserve">
          <source>auto</source>
          <target state="translated">auto</target>
        </trans-unit>
        <trans-unit id="e8a88cd5f1730052658100ac7c480655d9bb0697" translate="yes" xml:space="preserve">
          <source>avoids the rejection to the left of the inner boxes and print respectively &lt;code&gt;&quot;123456789&quot;&lt;/code&gt; and &lt;code&gt;&quot;123456789A&quot;&lt;/code&gt; . Note also that vertical boxes never fit on a line whereas horizontal boxes always fully fit on the current line. Opening a box may split a line whereas the contents may have fit. If this behavior is problematic, it can be curtailed by setting the maximum indentation limit to &lt;code&gt;margin&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. Note that setting the maximum indentation limit to &lt;code&gt;margin&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
