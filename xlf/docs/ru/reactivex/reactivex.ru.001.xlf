<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="8bb1a4880b71bbf96c77904b471633be02e4f575" translate="yes" xml:space="preserve">
          <source>&amp;copy; ReactiveX contributors</source>
          <target state="translated">&amp;copy; Авторы ReactiveX</target>
        </trans-unit>
        <trans-unit id="ada27a33bf9c68fb3cbac205322beb072f9bf4a3" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcat&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMap&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;selectConcat&lt;/code&gt; &amp;raquo; - это псевдоним для &lt;code&gt;concatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f33193ba4ed9e4a70c0886da9f44ed6474f4347" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectConcatObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;concatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;selectConcatObserver&lt;/code&gt; &amp;raquo; - это псевдоним для &lt;code&gt;concatMapObserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="011bbafe1b211deabe6d4d163f504bc37bba4438" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectMany&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMap&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;selectMany&lt;/code&gt; &amp;raquo; - это псевдоним для &lt;code&gt;flatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652d537945ac6e2a2be380a114ed6b84ec433624" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectManyObserver&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapObserver&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;selectManyObserver&lt;/code&gt; &amp;raquo; - это псевдоним для &lt;code&gt;flatMapObserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8858fe29d08b4ac07353302ff7337adc9c17e17e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;&lt;code&gt;selectSwitch&lt;/code&gt;&amp;rdquo; is an alias for &lt;code&gt;flatMapLatest&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;selectSwitch&lt;/code&gt; &amp;raquo; - это псевдоним для &lt;code&gt;flatMapLatest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a182db8bfa5293706ee292aab892f1c223187092" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Hot&amp;rdquo; and &amp;ldquo;Cold&amp;rdquo; Observables</source>
          <target state="translated">&amp;laquo;Горячие&amp;raquo; и &amp;laquo;холодные&amp;raquo; наблюдаемые</target>
        </trans-unit>
        <trans-unit id="628e3c0ed13b486bb51f51ba494993cd92feca15" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;The Observable Contract,&amp;rdquo; which you may see referenced in various places in source documentation and in the pages on this site, is an attempt at a formal definition of an Observable, based originally on the 2010 document &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; from Microsoft that described its Rx.NET implementation of ReactiveX.</source>
          <target state="translated">&amp;laquo;Наблюдаемый контракт&amp;raquo;, на который вы можете ссылаться в различных местах в исходной документации и на страницах этого сайта, является попыткой формального определения наблюдаемого, первоначально основанного на документе &lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkID=205219&quot;&gt;&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;&lt;/a&gt; от Microsoft от 2010 года, в котором описывается его Реализация ReactiveX в Rx.NET.</target>
        </trans-unit>
        <trans-unit id="3064f51b892e08b0c317bd603ed6b1c5496873e8" translate="yes" xml:space="preserve">
          <source>(If, on the other hand, you want to append a sequence of items to the end of those normally emitted by an Observable, you want the &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; operator.)</source>
          <target state="translated">(Если, с другой стороны, вы хотите добавить последовательность элементов в конец тех, которые обычно генерируются Observable, вам нужен оператор &lt;a href=&quot;concat&quot;&gt;Concat&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="33d18aff50d4af9918043a17429ab9d8422faab7" translate="yes" xml:space="preserve">
          <source>(optional) a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; or an Observable:</source>
          <target state="translated">(необязательно) &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; или наблюдаемое:</target>
        </trans-unit>
        <trans-unit id="10a49259eb5c4104d411ab272baaefc70db9d42e" translate="yes" xml:space="preserve">
          <source>(required) a function that accepts an item from the source Observable and returns its key</source>
          <target state="translated">(обязательно) функция, которая принимает элемент из исходного Observable и возвращает его ключ</target>
        </trans-unit>
        <trans-unit id="472fde8dfbd26d60ec634739e7c5baef720d6a9e" translate="yes" xml:space="preserve">
          <source>(required) a function that returns an Observable, the emissions from which trigger the termination of any open Observables</source>
          <target state="translated">(обязательно) функция, которая возвращает Observable, выбросы из которой вызывают завершение любых открытых Observable</target>
        </trans-unit>
        <trans-unit id="8ec0db89f0508beecc88e44a4f261c96a84f7a76" translate="yes" xml:space="preserve">
          <source>), you only use two methods to subscribe:</source>
          <target state="translated">), вы используете только два метода для подписки:</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">, и</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="d2f39249308876151e8d9b31ac981ad614b505db" translate="yes" xml:space="preserve">
          <source>. An Observable</source>
          <target state="translated">. Наблюдаемое</target>
        </trans-unit>
        <trans-unit id="b1ac4cc21e92b26c247d2d196cac30ab387310d2" translate="yes" xml:space="preserve">
          <source>. Then that observer reacts to whatever item or sequence of items the Observable</source>
          <target state="translated">. Затем этот наблюдатель реагирует на любой элемент или последовательность элементов, которые наблюдаемый</target>
        </trans-unit>
        <trans-unit id="51fe6dc75cfc49521ecb18667ffda03016ec73bf" translate="yes" xml:space="preserve">
          <source>. This pattern facilitates concurrent operations because it does not need to block while waiting for the Observable to emit objects, but instead it creates a sentry in the form of an observer that stands ready to react appropriately at whatever future time the Observable does so.</source>
          <target state="translated">. Этот шаблон облегчает параллельные операции, потому что ему не нужно блокировать, ожидая, пока Observable испускает объекты, но вместо этого он создает часового в виде наблюдателя, который готов отреагировать соответствующим образом в любое время, когда Observable сделает это.</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="b3bae60012f7a78cc91257251e629489a51994ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt;&lt;code&gt;first( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-take&quot;&gt;&lt;code&gt;take(1)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt;&lt;code&gt;single( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-first-and-takefirst&quot;&gt; &lt;code&gt;first( )&lt;/code&gt; &lt;/a&gt; определяется как&lt;a href=&quot;filtering-observables#wiki-take&quot;&gt; &lt;code&gt;take(1)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;observable-utility-operators#wiki-single-and-singleordefault&quot;&gt; &lt;code&gt;single( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59266734c85708062c27299be8478b239f26b4ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt;&lt;code&gt;ignoreElements( )&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt;&lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;filtering-observables#wiki-ignoreelements&quot;&gt; &lt;code&gt;ignoreElements( )&lt;/code&gt; &lt;/a&gt; определяется как&lt;a href=&quot;filtering-observables#wiki-filter&quot;&gt; &lt;code&gt;filter(alwaysFalse( ))&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4667e98d48cafefe965c6cfbbf931c271b1e90b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Подводные камни реализаций операторов (часть 1)&lt;/a&gt; и &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(часть 2)&lt;/a&gt; Давида Карнок.</target>
        </trans-unit>
        <trans-unit id="e206efd342d6f311e4eaf22aa1dad1f1c530786a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Продвинутый RxJava: Тема&lt;/a&gt; от Давида Карнок</target>
        </trans-unit>
        <trans-unit id="47f33eda1a69dd738f1849ddb4b492a4b2e5509d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="translated">&lt;a href=&quot;http://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn и ObserveOn,&lt;/a&gt; автор: Давид Карнок</target>
        </trans-unit>
        <trans-unit id="e230c3946af5006280175d640abe4d4a13419ba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt;: Operator, Operator&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/&quot;&gt;&lt;cite&gt;Grokking RxJava&lt;/cite&gt; : оператор, оператор&lt;/a&gt; Дэн Лью</target>
        </trans-unit>
        <trans-unit id="d3d0073935807280d0be6f71fbb272c064199c60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Loading data from multiple sources with RxJava&lt;/a&gt; by Dan Lew (example using Concat and First)</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/&quot;&gt;Загрузка данных из нескольких источников с помощью RxJava&lt;/a&gt; от Дэна Лью (пример с использованием Concat и First)</target>
        </trans-unit>
        <trans-unit id="88b0f482a744066f1f064e5f01147915d1aa0700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Deferring Observable code until subscription in RxJava&lt;/a&gt; by Dan Lew</source>
          <target state="translated">&lt;a href=&quot;http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/&quot;&gt;Отсрочка наблюдаемого кода до подписки в RxJava&lt;/a&gt; от Дэна Лью</target>
        </trans-unit>
        <trans-unit id="f1ca84472fb7904b99b27002018564cb5a4547cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Experimentation with RxJava&lt;/a&gt; by Joan Zapata</source>
          <target state="translated">&lt;a href=&quot;http://blog.joanzapata.com/experimentation-with-rx/&quot;&gt;Эксперименты с RxJava,&lt;/a&gt; автор Joan Zapata</target>
        </trans-unit>
        <trans-unit id="c03861d52c0ac7e93ae1206503fa91b22d7f7e21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Wedding Party&lt;/cite&gt;: Share, Publish, Refcount, and All That Jazz&lt;/a&gt; by Kaushik Gopal</source>
          <target state="translated">&lt;a href=&quot;http://blog.kaush.co/2015/01/21/rxjava-tip-for-the-day-share-publish-refcount-and-all-that-jazz/&quot;&gt;&lt;cite&gt;Свадебная вечеринка&lt;/cite&gt; : поделиться, опубликовать, пересчитать и все в этом джазе&lt;/a&gt; от Кошика Гопала</target>
        </trans-unit>
        <trans-unit id="5ce980c6203942d6328150d8b1c308fa22c0eaa5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Animations of Rx operators: GroupBy&lt;/a&gt; by Tamir Dresher</source>
          <target state="translated">&lt;a href=&quot;http://blogs.microsoft.co.il/iblogger/2015/08/11/animations-of-rx-operators-groupby/&quot;&gt;Анимации операторов Rx: GroupBy&lt;/a&gt; Тамир Дрешер</target>
        </trans-unit>
        <trans-unit id="fbfa59fd65771d372675362d61976b92c09f6c20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;To Use or Not to Use Subject&lt;/a&gt; from</source>
          <target state="translated">&lt;a href=&quot;http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx&quot;&gt;Использовать или не использовать тему&lt;/a&gt; из</target>
        </trans-unit>
        <trans-unit id="759d49d6a27ee607b3399f224c41924b74508d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Mastering observables&lt;/cite&gt;&lt;/a&gt; (from the Couchbase Server documentation)</source>
          <target state="translated">&lt;a href=&quot;http://docs.couchbase.com/developer/java-2.0/observables.html&quot;&gt;&lt;cite&gt;Освоение наблюдаемых&lt;/cite&gt;&lt;/a&gt; (из документации Couchbase Server)</target>
        </trans-unit>
        <trans-unit id="896a64d54c6458d527ffcfd1ff702993ee89e715" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Triangular_number&quot;&gt;треугольные числа&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0cf025e741372bc56b5fa846f8b8c00cb06df70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable transformation: concatMap() vs. flatMap()&lt;/a&gt; by Fernando Cejas</source>
          <target state="translated">&lt;a href=&quot;http://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/&quot;&gt;RxJava Observable преобразование: concatMap () против flatMap ()&lt;/a&gt; от Фернандо Сехаса</target>
        </trans-unit>
        <trans-unit id="28d3f563e622ffc28d2ef40034bcd9d4f00ca617" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Async Abstractions using rx-java&lt;/a&gt; by Biju Kunjummen,</source>
          <target state="translated">&lt;a href=&quot;http://java.dzone.com/articles/async-abstractios-using-rx&quot;&gt;Асинхронные абстракции с использованием rx-java&lt;/a&gt; от Biju Kunjummen,</target>
        </trans-unit>
        <trans-unit id="8a54c1db4af03308f492e88a17125cdba0d0c092" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Recursive Observables with RxJava&lt;/cite&gt;&lt;/a&gt; by Jon Schneider</source>
          <target state="translated">&lt;a href=&quot;http://jschneider.io/2014/11/26/Recursive-Observables-with-Rx-Java.html&quot;&gt;&lt;cite&gt;Рекурсивные наблюдаемые с RxJava&lt;/cite&gt;&lt;/a&gt; от Джона Шнайдера</target>
        </trans-unit>
        <trans-unit id="16022b407d5c10a64a78eb6bcb293d94191d92c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Another &lt;code&gt;Scheduler&lt;/code&gt; method&lt;/a&gt; allows you to schedule an action to take place at regular intervals. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed, and then every 250ms thereafter:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedulePeriodically(rx.functions.Action0,%20long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;Другой метод &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; позволяет запланировать действие, которое будет происходить через регулярные промежутки времени. В следующем примере планируется выполнение &lt;code&gt;someAction&lt;/code&gt; в &lt;code&gt;someScheduler&lt;/code&gt; по прошествии 500 мс, а затем каждые 250 мс:</target>
        </trans-unit>
        <trans-unit id="a37f7ccc01d776219ff3c86d486170b61368bb91" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt;The &lt;code&gt;TestScheduler&lt;/code&gt;&lt;/a&gt; allows you to exercise fine-tuned manual control over how the Scheduler&amp;rsquo;s clock behaves. This can be useful for testing interactions that depend on precise arrangements of actions in time. This Scheduler has three additional methods:</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/TestScheduler.html&quot;&gt; &lt;code&gt;TestScheduler&lt;/code&gt; &lt;/a&gt; позволяет осуществлять тонкое настроенный ручное управление над тем, как часами ведут себя планировщик. Это может быть полезно для тестирования взаимодействий, которые зависят от точного распределения действий во времени. У этого Планировщика есть три дополнительных метода:</target>
        </trans-unit>
        <trans-unit id="1b99f29bcb2b76c81e30b2a8987e758a20001805" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="translated">&lt;a href=&quot;http://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: понимание ObservOn () и subscribeOn ()&lt;/a&gt; Томаса Нильда</target>
        </trans-unit>
        <trans-unit id="d5434e93f83f2e22d891275d0648442c8413f6ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt;&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;&lt;cite&gt;Примеры потоковой передачи RxJava&lt;/cite&gt;&lt;/a&gt; от Грэма Ли</target>
        </trans-unit>
        <trans-unit id="1d280bc18cadf90c9c47536bb1dda083a732e6f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examlpes&lt;/a&gt; by Graham Lea</source>
          <target state="translated">&lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;Примеры потоков RxJava&lt;/a&gt; от Грэма Ли</target>
        </trans-unit>
        <trans-unit id="74f17e88de08b7b705152e13a4c7159ebecfb889" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Aligning packets with JSON documents&lt;/a&gt; with the &lt;code&gt;split&lt;/code&gt; operator</source>
          <target state="translated">&lt;a href=&quot;http://www.nurkiewicz.com/2014/12/accessing-meetups-streaming-api-with.html&quot;&gt;Выравнивание пакетов с документами JSON&lt;/a&gt; с помощью оператора &lt;code&gt;split&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f646afbe00e0bfa7ba10a96b4ffa0e66bb17b8c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Реализация ваших собственных наблюдаемых операторов&lt;/a&gt; (в RxJS) Деннис Стоянов</target>
        </trans-unit>
        <trans-unit id="8de4cdb66506641a1d2be3db34ce3c18d520fb41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Использование планировщиков&lt;/a&gt; Дениса Стоянова</target>
        </trans-unit>
        <trans-unit id="704f937aee915cf54084238d4d732aaafe152536" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Использование предметов&lt;/a&gt; Дениса Стоянова</target>
        </trans-unit>
        <trans-unit id="4848d0a67536767bfc3a46b25a389c6c12411971" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt; &lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt; &lt;/a&gt; из книги Дениса Стоянова RxJS</target>
        </trans-unit>
        <trans-unit id="4d3ad2689ab54eb0e90eeaa55c13b2942af325ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Наблюдаемый объект&lt;/a&gt; (RxJS) Дениса Стоянова</target>
        </trans-unit>
        <trans-unit id="05fc805666c7d298737b623ab15f7e3dc904dae7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Планировщики&lt;/a&gt; Дениса Стоянова</target>
        </trans-unit>
        <trans-unit id="3189bb2a65685a675d2fc7b27dec30afc63ad7c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="translated">&lt;a href=&quot;http://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Какой оператор я использую? &lt;/a&gt;Денниса Стоянова (аналогичное дерево решений, специфичное для операторов RxJS)</target>
        </trans-unit>
        <trans-unit id="ce8e12a5cf50d130360fa140e3c6026b7357fde7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Turning a callback into an Rx Observable&lt;/a&gt; by @afterecho</source>
          <target state="translated">&lt;a href=&quot;https://afterecho.uk/blog/turning-a-callback-into-an-rx-observable.html&quot;&gt;Превращение обратного вызова в Rx Observable с&lt;/a&gt; помощью @afterecho</target>
        </trans-unit>
        <trans-unit id="d451c54e66d39cc9799f024ed509b3bc96bce3c7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations.html&quot;&gt;Pitfalls of Operator Implementations (part 1)&lt;/a&gt; and &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;(part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90c5beaed2cc1c90c5fe7861f00e4aad4f4a6d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/subjects-part-1.html&quot;&gt;Advanced RxJava: Subject&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf363991e89c8a0e87e6dfba9b6738ed9428569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://akarnokd.blogspot.hu/2016/03/subscribeon-and-observeon.html&quot;&gt;Advanced Reactive Java: SubscribeOn and ObserveOn&lt;/a&gt; by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93a2223081711dc6a16e0d515e0ae72c9ea57ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Introducing the Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-introducing-the-observable&quot;&gt;Знакомство с наблюдаемым&lt;/a&gt; от Джафара Хусейна (видеоурок по JavaScript)</target>
        </trans-unit>
        <trans-unit id="334e700ad37dedaa75e68b424f31c8fa60b1fb0a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Using the map method with Observable&lt;/a&gt; by Jafar Husain (JavaScript Video Tutorial)</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/lessons/javascript-using-the-map-method-with-observable&quot;&gt;Использование метода карты с Observable&lt;/a&gt; от Джафара Хусейна (видеоурок по JavaScript)</target>
        </trans-unit>
        <trans-unit id="cf0782f3a6b69844aa73c07760234981973bbc5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_number&quot;&gt;triangular numbers&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97a092a417ac6514a68c890f6e9a31313afc87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;2 minute introduction to Rx&lt;/cite&gt;&lt;/a&gt; by Andre Staltz (&amp;ldquo;Think of an Observable as an asynchronous immutable array.&amp;rdquo;)</source>
          <target state="translated">&lt;a href=&quot;https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877&quot;&gt;&lt;cite&gt;Двухминутное введение в Rx&lt;/cite&gt;&lt;/a&gt; от Андре Стальца (&amp;laquo;Думайте о Observable как об асинхронном неизменяемом массиве&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="f57e3b7ba34ac94a726bbf8003c34e5a0fd3f3d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Testing Reactive Applications&lt;/a&gt; by Ben Christensen</source>
          <target state="translated">&lt;a href=&quot;https://speakerdeck.com/benjchristensen/applying-rxjava-to-existing-applications-at-philly-ete-2015&quot;&gt;Тестирование реактивных приложений&lt;/a&gt; , Бен Кристенсен</target>
        </trans-unit>
        <trans-unit id="c038a5a05f5d042c0ec78b36075a87e20bcb7315" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tomstechnicalblog.blogspot.hu/2016/02/rxjava-understanding-observeon-and.html&quot;&gt;RxJava: Understanding observeOn() and subscribeOn()&lt;/a&gt; by Thomas Nield</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b94d44ddd170ba627080334d6de635cf9dee2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/implementing_your_own_operators.html&quot;&gt;Implementing Your Own Observable Operators&lt;/a&gt; (in RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fe549f38289b6afce34aa2e3fca82da4136bd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/scheduling_and_concurrency.html&quot;&gt;Using Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d766df35d7fb238b4d6047220476f351b1b95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/subjects.html&quot;&gt;Using Subjects&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640a5616bb195204bbe098f76af869fe354cb507" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/helpers/pluck.html&quot;&gt;&lt;code&gt;Rx.helpers.pluck(property)&lt;/code&gt;&lt;/a&gt; from Dennis Stoyanov&amp;rsquo;s RxJS book</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d252ced924a06312f6659b0016eb34bf29753054" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/observable/index.html&quot;&gt;Observable object&lt;/a&gt; (RxJS) by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89bc9845079206996bf7fc699562b453e2b49b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/schedulers/index.html&quot;&gt;Schedulers&lt;/a&gt; by Dennis Stoyanov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c215d1c35116530a5569ecbd77ec8011180980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html&quot;&gt;Which Operator do I use?&lt;/a&gt; by Dennis Stoyanov (a similar decision tree, specific to RxJS operators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64d773c526ed13fecf935007c5b8b42451946ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt;&lt;code&gt;reduce(a)&lt;/code&gt;&lt;/a&gt; is defined as &lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt;&lt;code&gt;scan(a)&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;filtering-observables#wiki-last&quot;&gt;&lt;code&gt;last( )&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mathematical-and-aggregate-operators#wiki-reduce&quot;&gt; &lt;code&gt;reduce(a)&lt;/code&gt; &lt;/a&gt; определяется как&lt;a href=&quot;transforming-observables#wiki-scan&quot;&gt; &lt;code&gt;scan(a)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;filtering-observables#wiki-last&quot;&gt; &lt;code&gt;last( )&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aedba0e61fd807ab73f1bcd257861ff700c36541" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/all&quot;&gt;&lt;code&gt;All&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">&lt;a href=&quot;operators/all&quot;&gt; &lt;code&gt;All&lt;/code&gt; &lt;/a&gt; - определить, все ли элементы, испускаемые Observable, соответствуют некоторым критериям.</target>
        </trans-unit>
        <trans-unit id="cf4af39a8182c43692831b7f5254a2e5a28ab5e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/amb&quot;&gt;&lt;code&gt;Amb&lt;/code&gt;&lt;/a&gt; &amp;mdash; given two or more source Observables, emit all of the items from only the first of these Observables to emit an item</source>
          <target state="translated">&lt;a href=&quot;operators/amb&quot;&gt; &lt;code&gt;Amb&lt;/code&gt; &lt;/a&gt; - учитывая два или более исходных Observable, испускайте все элементы только из первого из этих Observables, чтобы испустить элемент</target>
        </trans-unit>
        <trans-unit id="6abf056e15446abb733a1356236897d0eb88fbc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/and-then-when&quot;&gt;&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine sets of items emitted by two or more Observables by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">&lt;a href=&quot;operators/and-then-when&quot;&gt; &lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; &lt;/a&gt; - объединить наборы элементов, испускаемых двумя или более Observable посредствомпосредников &lt;code&gt;Pattern&lt;/code&gt; и &lt;code&gt;Plan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ebf0c5f54c5bec720782a934c3ac450d6d61240" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/average&quot;&gt;&lt;code&gt;Average&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">&lt;a href=&quot;operators/average&quot;&gt; &lt;code&gt;Average&lt;/code&gt; &lt;/a&gt; - вычисляет среднее значение чисел, выдаваемых наблюдаемым объектом, и выдает это среднее.</target>
        </trans-unit>
        <trans-unit id="e5b94b62bcc7c953efa686abfda740c404bb41fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;backpressure operators&lt;/strong&gt;&lt;/a&gt; &amp;mdash; strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">&lt;a href=&quot;operators/backpressure&quot;&gt;&lt;strong&gt;операторы противодавления&lt;/strong&gt;&lt;/a&gt; - стратегии для работы с Observables, которые производят элементы быстрее, чем их потребляют их наблюдатели</target>
        </trans-unit>
        <trans-unit id="f4188b6a7d79bcd68189ca1745286160ac1b4b8b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; - периодически собирайте предметы из Observable в связки и выпускайте эти связки, а не выпускайте предметы по одному.</target>
        </trans-unit>
        <trans-unit id="af1e7131303f464e9943733bedda780f33c1a666" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/catch&quot;&gt;&lt;code&gt;Catch&lt;/code&gt;&lt;/a&gt; &amp;mdash; recover from an &lt;code&gt;onError&lt;/code&gt; notification by continuing the sequence without error</source>
          <target state="translated">&lt;a href=&quot;operators/catch&quot;&gt; &lt;code&gt;Catch&lt;/code&gt; &lt;/a&gt; - восстановление &lt;code&gt;onError&lt;/code&gt; уведомления onError путем продолжения последовательности без ошибок</target>
        </trans-unit>
        <trans-unit id="7da57d968e0e4216a34863a171db7ab41b9812ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/combinelatest&quot;&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/a&gt; &amp;mdash; when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/combinelatest&quot;&gt; &lt;code&gt;CombineLatest&lt;/code&gt; &lt;/a&gt; - когда элемент создается одним из двух Observable, объединить последний элемент, созданный каждым Observable через указанную функцию, и создать элементы на основе результатов этой функции.</target>
        </trans-unit>
        <trans-unit id="b5080500198e0f8811c8452bb3beb14dec470f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/concat&quot;&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">&lt;a href=&quot;operators/concat&quot;&gt; &lt;code&gt;Concat&lt;/code&gt; &lt;/a&gt; - испускать выбросы от двух или более Observable, не чередуя их</target>
        </trans-unit>
        <trans-unit id="56ae6daf6671ffcf155c2fa5c4d803d4f7af8682" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/connect&quot;&gt;&lt;code&gt;Connect&lt;/code&gt;&lt;/a&gt; &amp;mdash; instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">&lt;a href=&quot;operators/connect&quot;&gt; &lt;code&gt;Connect&lt;/code&gt; &lt;/a&gt; - проинструктируйте подключаемый Observable начать рассылку элементов своим подписчикам.</target>
        </trans-unit>
        <trans-unit id="55e31fa5a564732c4705e3cfc70e314969dc504c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/contains&quot;&gt;&lt;code&gt;Contains&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether an Observable emits a particular item or not</source>
          <target state="translated">&lt;a href=&quot;operators/contains&quot;&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;/a&gt; - определяет, испускает ли Observable конкретный элемент или нет</target>
        </trans-unit>
        <trans-unit id="7bd2683bd64c47ab143020ad6a8b004e6473f895" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/count&quot;&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/a&gt; &amp;mdash; count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">&lt;a href=&quot;operators/count&quot;&gt; &lt;code&gt;Count&lt;/code&gt; &lt;/a&gt; - подсчитать количество элементов, выданных источником Observable, и выдать только это значение</target>
        </trans-unit>
        <trans-unit id="b703b9011ffb0e21799b507e8d5b7991453ff2f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;Create&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable from scratch by calling observer methods programmatically</source>
          <target state="translated">&lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;Create&lt;/code&gt; &lt;/a&gt; - создать Observable с нуля, программно вызывая методы наблюдателя.</target>
        </trans-unit>
        <trans-unit id="d520a5275eeadd415b96286025e57173c2f421ef" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/debounce&quot;&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/a&gt; &amp;mdash; only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">&lt;a href=&quot;operators/debounce&quot;&gt; &lt;code&gt;Debounce&lt;/code&gt; &lt;/a&gt; - испускать элемент из Observable только в том случае, если определенный промежуток времени прошел без испускания другого элемента</target>
        </trans-unit>
        <trans-unit id="bcbedf41620fc26c55f3a79460e1936597cd6376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defaultifempty&quot;&gt;&lt;code&gt;DefaultIfEmpty&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">&lt;a href=&quot;operators/defaultifempty&quot;&gt; &lt;code&gt;DefaultIfEmpty&lt;/code&gt; &lt;/a&gt; - испускает элементы из исходного Observable или элемента по умолчанию, если исходный Observable ничего не излучает</target>
        </trans-unit>
        <trans-unit id="1ead6b29bf678adce5dda8d26b2b84e8a029610e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/defer&quot;&gt;&lt;code&gt;Defer&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">&lt;a href=&quot;operators/defer&quot;&gt; &lt;code&gt;Defer&lt;/code&gt; &lt;/a&gt; - не создавать Observable, пока наблюдатель не подпишется, и создать новый Observable для каждого наблюдателя</target>
        </trans-unit>
        <trans-unit id="c877468ebfffede1767292c312dce60b414b3e7e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/delay&quot;&gt;&lt;code&gt;Delay&lt;/code&gt;&lt;/a&gt; &amp;mdash; shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">&lt;a href=&quot;operators/delay&quot;&gt; &lt;code&gt;Delay&lt;/code&gt; &lt;/a&gt; - сдвигает выбросы наблюдаемого вперед во времени на определенную величину.</target>
        </trans-unit>
        <trans-unit id="cfd3bc1c02474c98160f5c3daaaf519e81d28a2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/distinct&quot;&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress duplicate items emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/distinct&quot;&gt; &lt;code&gt;Distinct&lt;/code&gt; &lt;/a&gt; - подавить повторяющиеся элементы, испускаемые Observable</target>
        </trans-unit>
        <trans-unit id="a0bcec9b0ef7199fdfb5d4143f346557af694831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/do&quot;&gt;&lt;code&gt;Do&lt;/code&gt;&lt;/a&gt; &amp;mdash; register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">&lt;a href=&quot;operators/do&quot;&gt; &lt;code&gt;Do&lt;/code&gt; &lt;/a&gt; - зарегистрировать действие, которое будет выполнять различные наблюдаемые события жизненного цикла.</target>
        </trans-unit>
        <trans-unit id="d78138361fd31ace0165e9d2c41fa553949f98a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/elementat&quot;&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only item</source>
          <target state="translated">&lt;a href=&quot;operators/elementat&quot;&gt; &lt;code&gt;ElementAt&lt;/code&gt; &lt;/a&gt; - вывести только элемент</target>
        </trans-unit>
        <trans-unit id="b8ea48737e4cf7e24239f531b16f54742f291f19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/empty-never-throw&quot;&gt;&lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;&lt;/a&gt; &amp;mdash; create Observables that have very precise and limited behavior</source>
          <target state="translated">&lt;a href=&quot;operators/empty-never-throw&quot;&gt; &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; &lt;/a&gt; - создавать Observables, которые имеют очень точное и ограниченное поведение</target>
        </trans-unit>
        <trans-unit id="39d35f0e202be5da8bca269f843088bbc301dc44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/a&gt; - выдавать из Observable только те элементы, которые проходят проверку предиката.</target>
        </trans-unit>
        <trans-unit id="6e10a2781542f87afbf33eb4a144578a352afb60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; (RxScala version of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt; (версия&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; RxScala)</target>
        </trans-unit>
        <trans-unit id="9af7efb0e5277caa8bcb4ca047ec46c742ccb1fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/filter&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/filter&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; (альтернативное название&lt;strong&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="59b1e5aa586c9c45e855a67c901087f73288790f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;First&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first item, or the first item that meets a condition, from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;First&lt;/code&gt; &lt;/a&gt; - испускать только первый элемент или первый элемент, который соответствует условию, из наблюдаемого</target>
        </trans-unit>
        <trans-unit id="0333194f18a33a7a679904ac05075d80fb58292e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/first&quot;&gt;&lt;code&gt;Next&lt;/code&gt;&lt;/a&gt; (BlockingObservable version)</source>
          <target state="translated">&lt;a href=&quot;operators/first&quot;&gt; &lt;code&gt;Next&lt;/code&gt; &lt;/a&gt; (версия BlockingObservable)</target>
        </trans-unit>
        <trans-unit id="5e51f771a5f9140c8f1c5f545f5f8d7fa162868d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/flatmap&quot;&gt;&lt;code&gt;FlatMap&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">&lt;a href=&quot;operators/flatmap&quot;&gt; &lt;code&gt;FlatMap&lt;/code&gt; &lt;/a&gt; - преобразуйте элементы, испускаемые Observable, в Observable, а затем сгладьте выбросы от них в один Observable</target>
        </trans-unit>
        <trans-unit id="71f2ef1fb92d5f7acf826243fcc2a2bbb36aecb1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert some other object or data structure into an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; - преобразовать какой-либо другой объект или структуру данных в Observable</target>
        </trans-unit>
        <trans-unit id="c784fcd85d0d9eee95eec8546747974634737771" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/groupby&quot;&gt;&lt;code&gt;GroupBy&lt;/code&gt;&lt;/a&gt; &amp;mdash; divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</source>
          <target state="translated">&lt;a href=&quot;operators/groupby&quot;&gt; &lt;code&gt;GroupBy&lt;/code&gt; &lt;/a&gt; - разделите Observable на набор Observable, каждый из которых испускает разные группы элементов из исходного Observable, организованных по ключу.</target>
        </trans-unit>
        <trans-unit id="961f7bdad0209a178b650ec75f14ba3dbab617cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/ignoreelements&quot;&gt;&lt;code&gt;IgnoreElements&lt;/code&gt;&lt;/a&gt; &amp;mdash; do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">&lt;a href=&quot;operators/ignoreelements&quot;&gt; &lt;code&gt;IgnoreElements&lt;/code&gt; &lt;/a&gt; - не испускать никаких элементов из Observable, но отражать его уведомление о завершении</target>
        </trans-unit>
        <trans-unit id="a7a0c12a44344d7075bd1bab89a82bb9105a316b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a sequence of integers spaced by a particular time interval</source>
          <target state="translated">&lt;a href=&quot;operators/interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; - создайте Observable, который испускает последовательность целых чисел, разделенных определенным интервалом времени.</target>
        </trans-unit>
        <trans-unit id="82c0927b758a710d223a235baa006d1ad82eacf1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/join&quot;&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">&lt;a href=&quot;operators/join&quot;&gt; &lt;code&gt;Join&lt;/code&gt; &lt;/a&gt; - объединить элементы, испускаемые двумя Observable, всякий раз, когда элемент из одного Observable испускается в течение временного окна, определенного в соответствии с элементом, испускаемым другим Observable</target>
        </trans-unit>
        <trans-unit id="f789526a11cbf951f3017cad8bb11a7e4f2ae5f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/just&quot;&gt;&lt;code&gt;Just&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an object or a set of objects into an Observable that emits that or those objects</source>
          <target state="translated">&lt;a href=&quot;operators/just&quot;&gt; &lt;code&gt;Just&lt;/code&gt; &lt;/a&gt; - преобразовать объект или набор объектов в Observable, который испускает те или иные объекты</target>
        </trans-unit>
        <trans-unit id="f24150c757b2d9fe51daa5b9af6362ed547f642d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;Last&lt;/code&gt; &lt;/a&gt; - испускать только последний элемент, выпущенный Observable</target>
        </trans-unit>
        <trans-unit id="3cfa4568e3237e07a49192561a240de86776b19c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/last&quot;&gt;&lt;code&gt;takeRight&lt;/code&gt;&lt;/a&gt; (see also: &lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/last&quot;&gt; &lt;code&gt;takeRight&lt;/code&gt; &lt;/a&gt; (см. также&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6273a6a4cb7f838288a2e07ef52f0d3d06baaf4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; &amp;mdash; transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; - трансформируйте элементы, испускаемые Observable, применяя функцию к каждому элементу</target>
        </trans-unit>
        <trans-unit id="9b1ea99f33b2d42aa36a7fc325095d80ff73e6e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/map&quot;&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/a&gt; (alternate name of &lt;strong&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/map&quot;&gt; &lt;code&gt;Select&lt;/code&gt; &lt;/a&gt; (альтернативное название&lt;strong&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="cce6754f280c0d41eb1e96d9819d872ea7cbb479" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt;&lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">&lt;a href=&quot;operators/materialize-dematerialize&quot;&gt; &lt;code&gt;Materialize&lt;/code&gt; / &lt;code&gt;Dematerialize&lt;/code&gt; &lt;/a&gt; - представить как отправленные элементы, так и отправленные уведомления как отправленные элементы, или отменить этот процесс</target>
        </trans-unit>
        <trans-unit id="e43ea78d80899fb195485fd3038b95794736c693" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/max&quot;&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the maximum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/max&quot;&gt; &lt;code&gt;Max&lt;/code&gt; &lt;/a&gt; - определить и испустить элемент с максимальным значением, выдаваемый Observable</target>
        </trans-unit>
        <trans-unit id="896d525218ff0dfffdd195a9e6eee022104a5cda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/merge&quot;&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine multiple Observables into one by merging their emissions</source>
          <target state="translated">&lt;a href=&quot;operators/merge&quot;&gt; &lt;code&gt;Merge&lt;/code&gt; &lt;/a&gt; - объединить несколько наблюдаемых в один, объединив их выбросы.</target>
        </trans-unit>
        <trans-unit id="0f540a11749020205078336f04e2c0c14a5a0beb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/min&quot;&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine, and emit, the minimum-valued item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/min&quot;&gt; &lt;code&gt;Min&lt;/code&gt; &lt;/a&gt; - определить и испустить элемент с минимальной стоимостью, выпущенный Observable</target>
        </trans-unit>
        <trans-unit id="78c97bac5d1832ec1abde2e15368384c4243e8cc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/observeon&quot;&gt;&lt;code&gt;ObserveOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler on which an observer will observe this Observable</source>
          <target state="translated">&lt;a href=&quot;operators/observeon&quot;&gt; &lt;code&gt;ObserveOn&lt;/code&gt; &lt;/a&gt; - укажите планировщик, на котором наблюдатель будет наблюдать за этим Observable</target>
        </trans-unit>
        <trans-unit id="58e4de04374963ac6f0703deddf542b57beab534" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/publish&quot;&gt;&lt;code&gt;Publish&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">&lt;a href=&quot;operators/publish&quot;&gt; &lt;code&gt;Publish&lt;/code&gt; &lt;/a&gt; - преобразовать обычный Observable в подключаемый Observable</target>
        </trans-unit>
        <trans-unit id="6d19d53dfbba576a9be303d133898023ec0f1468" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a range of sequential integers</source>
          <target state="translated">&lt;a href=&quot;operators/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; - создайте Observable, который испускает ряд последовательных целых чисел</target>
        </trans-unit>
        <trans-unit id="220d9225db54aea0568c311fb54c1b1af2b03d83" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/reduce&quot;&gt;&lt;code&gt;Reduce&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">&lt;a href=&quot;operators/reduce&quot;&gt; &lt;code&gt;Reduce&lt;/code&gt; &lt;/a&gt; - применить функцию к каждому элементу, испускаемому Observable, последовательно, и испустить окончательное значение</target>
        </trans-unit>
        <trans-unit id="f2ebff59c0c373b115b3a5c2d65e3f91e16e588e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/refcount&quot;&gt;&lt;code&gt;RefCount&lt;/code&gt;&lt;/a&gt; &amp;mdash; make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">&lt;a href=&quot;operators/refcount&quot;&gt; &lt;code&gt;RefCount&lt;/code&gt; &lt;/a&gt; - заставить Connectable Observable вести себя как обычный Observable</target>
        </trans-unit>
        <trans-unit id="e6ec521fdbc793707013621bfc8fb2ba153a0cd8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/repeat&quot;&gt;&lt;code&gt;Repeat&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a particular item or sequence of items repeatedly</source>
          <target state="translated">&lt;a href=&quot;operators/repeat&quot;&gt; &lt;code&gt;Repeat&lt;/code&gt; &lt;/a&gt; - создать Observable, который многократно испускает определенный элемент или последовательность элементов.</target>
        </trans-unit>
        <trans-unit id="2804cd9e5f0367f7c9558927abf3a72ef9c06ac4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/replay&quot;&gt;&lt;code&gt;Replay&lt;/code&gt;&lt;/a&gt; &amp;mdash; ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">&lt;a href=&quot;operators/replay&quot;&gt; &lt;code&gt;Replay&lt;/code&gt; &lt;/a&gt; - убедитесь, что все наблюдатели видят одну и ту же последовательность отправленных элементов, даже если они подписываются после того, как Observable начал выпускать элементы.</target>
        </trans-unit>
        <trans-unit id="00ec748f863300265c910192f8f5af498feb4f55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/retry&quot;&gt;&lt;code&gt;Retry&lt;/code&gt;&lt;/a&gt; &amp;mdash; if a source Observable sends an &lt;code&gt;onError&lt;/code&gt; notification, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">&lt;a href=&quot;operators/retry&quot;&gt; &lt;code&gt;Retry&lt;/code&gt; &lt;/a&gt; - если источник Observable отправляетуведомление &lt;code&gt;onError&lt;/code&gt; , повторно подпишитесь на него в надежде, что он завершится без ошибок</target>
        </trans-unit>
        <trans-unit id="fe03930f3581f4dad5c8a3922092b89e1191d93d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sample&quot;&gt;&lt;code&gt;Sample&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit the most recent item emitted by an Observable within periodic time intervals</source>
          <target state="translated">&lt;a href=&quot;operators/sample&quot;&gt; &lt;code&gt;Sample&lt;/code&gt; &lt;/a&gt; - генерировать самый последний элемент, выпущенный Observable в периодические интервалы времени</target>
        </trans-unit>
        <trans-unit id="d75c698d2f0fe31254942270f4f860c2edd619a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/scan&quot;&gt;&lt;code&gt;Scan&lt;/code&gt;&lt;/a&gt; &amp;mdash; apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">&lt;a href=&quot;operators/scan&quot;&gt; &lt;code&gt;Scan&lt;/code&gt; &lt;/a&gt; - применить функцию к каждому элементу, испускаемому Observable, последовательно, и испустить каждое последующее значение</target>
        </trans-unit>
        <trans-unit id="eb4dcaeae3f881353f0198da0ed07774810c96e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sequenceequal&quot;&gt;&lt;code&gt;SequenceEqual&lt;/code&gt;&lt;/a&gt; &amp;mdash; determine whether two Observables emit the same sequence of items</source>
          <target state="translated">&lt;a href=&quot;operators/sequenceequal&quot;&gt; &lt;code&gt;SequenceEqual&lt;/code&gt; &lt;/a&gt; - определяет, испускают ли два Observable одну и ту же последовательность элементов</target>
        </trans-unit>
        <trans-unit id="ca9082009ddd16283a5a15007359dd764bf941bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/serialize&quot;&gt;&lt;code&gt;Serialize&lt;/code&gt;&lt;/a&gt; &amp;mdash; force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">&lt;a href=&quot;operators/serialize&quot;&gt; &lt;code&gt;Serialize&lt;/code&gt; &lt;/a&gt; - заставить Observable выполнять сериализованные вызовы и вести себя хорошо</target>
        </trans-unit>
        <trans-unit id="3c5b3dde082c7f134651c5c0ee0f77c10d8849f7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skip&quot;&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the first</source>
          <target state="translated">&lt;a href=&quot;operators/skip&quot;&gt; &lt;code&gt;Skip&lt;/code&gt; &lt;/a&gt; - подавить первое</target>
        </trans-unit>
        <trans-unit id="57c550f6342285873d1251001f507a49dd499b9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skiplast&quot;&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; suppress the last</source>
          <target state="translated">&lt;a href=&quot;operators/skiplast&quot;&gt; &lt;code&gt;SkipLast&lt;/code&gt; &lt;/a&gt; - подавить последнее</target>
        </trans-unit>
        <trans-unit id="e4091fcbf30f6cac5a853be94132763f8026869c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipuntil&quot;&gt;&lt;code&gt;SkipUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">&lt;a href=&quot;operators/skipuntil&quot;&gt; &lt;code&gt;SkipUntil&lt;/code&gt; &lt;/a&gt; - отбрасывать элементы, испускаемые Observable, пока второй Observable не испустит элемент</target>
        </trans-unit>
        <trans-unit id="7a2508b5d42729a80bcadabbd948ac432565126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/skipwhile&quot;&gt;&lt;code&gt;SkipWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/skipwhile&quot;&gt; &lt;code&gt;SkipWhile&lt;/code&gt; &lt;/a&gt; - отбрасывать элементы, испускаемые Observable, пока указанное условие не станет ложным</target>
        </trans-unit>
        <trans-unit id="715557b9c7b5c8b25056c589cc3f188f11be2cc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/start&quot;&gt;&lt;code&gt;Start&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits the return value of a function</source>
          <target state="translated">&lt;a href=&quot;operators/start&quot;&gt; &lt;code&gt;Start&lt;/code&gt; &lt;/a&gt; - создать Observable, который испускает возвращаемое значение функции</target>
        </trans-unit>
        <trans-unit id="8a16879f166f96ec4f6c887a4b17c95425000b2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/startwith&quot;&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">&lt;a href=&quot;operators/startwith&quot;&gt; &lt;code&gt;StartWith&lt;/code&gt; &lt;/a&gt; - испускает указанную последовательность элементов до начала испускания элементов из источника Observable</target>
        </trans-unit>
        <trans-unit id="d0ff74e8a6826625e34447a02f61eea2babf5abb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;&lt;code&gt;Subscribe&lt;/code&gt;&lt;/a&gt; &amp;mdash; operate upon the emissions and notifications from an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt; &lt;code&gt;Subscribe&lt;/code&gt; &lt;/a&gt; - оперируйте выбросами и уведомлениями от наблюдаемого</target>
        </trans-unit>
        <trans-unit id="1b8c65f3783b491e2da19c9577fc47f408f83f9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribe&quot;&gt;The &lt;code&gt;Subscribe&lt;/code&gt; method&lt;/a&gt; is how you connect an observer to an Observable. Your observer implements some subset of the following methods:</source>
          <target state="translated">&lt;a href=&quot;operators/subscribe&quot;&gt; &lt;code&gt;Subscribe&lt;/code&gt; метод&lt;/a&gt; , как подключить наблюдателя к наблюдаемому. Ваш наблюдатель реализует подмножество следующих методов:</target>
        </trans-unit>
        <trans-unit id="20bd35f3cd630e6729cd59d5f5871941dbba7336" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/subscribeon&quot;&gt;&lt;code&gt;SubscribeOn&lt;/code&gt;&lt;/a&gt; &amp;mdash; specify the scheduler an Observable should use when it is subscribed to</source>
          <target state="translated">&lt;a href=&quot;operators/subscribeon&quot;&gt; &lt;code&gt;SubscribeOn&lt;/code&gt; &lt;/a&gt; - укажите планировщик, который Observable должен использовать, когда он подписан на</target>
        </trans-unit>
        <trans-unit id="f2c9b8fa32c3e32960d4065945b8d21ee9ae586d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;Sum&lt;/code&gt;&lt;/a&gt; &amp;mdash; calculate the sum of numbers emitted by an Observable and emit this sum</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;/a&gt; - вычислить сумму чисел, выданных Observable, и выдать эту сумму</target>
        </trans-unit>
        <trans-unit id="fff5479ffc0e2648d627b6a506e5a3ac0a369e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/sum&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; (string)</source>
          <target state="translated">&lt;a href=&quot;operators/sum&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; (строка)</target>
        </trans-unit>
        <trans-unit id="12270334cc52f8a9daf70d2dd8a4a15c526d5d82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/a&gt; - преобразовать Observable, который испускает Observable, в один Observable, который испускает элементы, испускаемые последними из этих Observable</target>
        </trans-unit>
        <trans-unit id="18cfa275521a80308ec35ddf6041423b53915ce9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/switch&quot;&gt;&lt;code&gt;latest&lt;/code&gt;&lt;/a&gt; (Rx.rb version of &lt;strong&gt;&lt;code&gt;Switch&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/switch&quot;&gt; &lt;code&gt;latest&lt;/code&gt; &lt;/a&gt; (Rx.rb версия&lt;strong&gt; &lt;code&gt;Switch&lt;/code&gt; &lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="c512d0a45fbef14a0ca00b1ba15611f0f470c5fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/take&quot;&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the first</source>
          <target state="translated">&lt;a href=&quot;operators/take&quot;&gt; &lt;code&gt;Take&lt;/code&gt; &lt;/a&gt; - испускай только первый</target>
        </trans-unit>
        <trans-unit id="2f2c659ea7a1fbd932f5dfd6f64cbda8bd8e8b88" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takelast&quot;&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/a&gt; &amp;mdash; emit only the last</source>
          <target state="translated">&lt;a href=&quot;operators/takelast&quot;&gt; &lt;code&gt;TakeLast&lt;/code&gt; &lt;/a&gt; - выдавать только последние</target>
        </trans-unit>
        <trans-unit id="40a4532cb238dde4e68093af52658f5445b11adf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takeuntil&quot;&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">&lt;a href=&quot;operators/takeuntil&quot;&gt; &lt;code&gt;TakeUntil&lt;/code&gt; &lt;/a&gt; - отбрасывать элементы, выпущенные Observable после того, как второй Observable испускает элемент или завершает работу</target>
        </trans-unit>
        <trans-unit id="92a388db3da085f5150944c06f479a2f12efe907" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/takewhile&quot;&gt;&lt;code&gt;TakeWhile&lt;/code&gt;&lt;/a&gt; &amp;mdash; discard items emitted by an Observable after a specified condition becomes false</source>
          <target state="translated">&lt;a href=&quot;operators/takewhile&quot;&gt; &lt;code&gt;TakeWhile&lt;/code&gt; &lt;/a&gt; - отбрасывать элементы, испускаемые Observable после того, как указанное условие становится ложным</target>
        </trans-unit>
        <trans-unit id="90712fbd60a57bf67f06b86afd680c3c52c8c0e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeinterval&quot;&gt;&lt;code&gt;TimeInterval&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">&lt;a href=&quot;operators/timeinterval&quot;&gt; &lt;code&gt;TimeInterval&lt;/code&gt; &lt;/a&gt; - преобразовать Observable, который испускает элементы, в тот, который испускает индикацию количества времени, прошедшего между этими выбросами</target>
        </trans-unit>
        <trans-unit id="56fae76408c63619174d789717205ca81e57c61d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timeout&quot;&gt;&lt;code&gt;Timeout&lt;/code&gt;&lt;/a&gt; &amp;mdash; mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">&lt;a href=&quot;operators/timeout&quot;&gt; &lt;code&gt;Timeout&lt;/code&gt; &lt;/a&gt; - отражает исходный Observable, но выдает уведомление об ошибке, если определенный период времени проходит без каких-либо излучаемых элементов</target>
        </trans-unit>
        <trans-unit id="17b4d7785cee0739e289b4511c57a47b43fb0a69" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; &amp;mdash; create an Observable that emits a single item after a given delay</source>
          <target state="translated">&lt;a href=&quot;operators/timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; - создайте Observable, который испускает один элемент после заданной задержки.</target>
        </trans-unit>
        <trans-unit id="8153fd468994e7f23f93090e11c64478da3a861a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; &amp;mdash; attach a timestamp to each item emitted by an Observable</source>
          <target state="translated">&lt;a href=&quot;operators/timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt;Отметка времени - прикрепите отметку времени к каждому элементу, излучаемому Observable</target>
        </trans-unit>
        <trans-unit id="08036d386b50af7605f69d72032e90ec9b7ae3be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/to&quot;&gt;&lt;code&gt;To&lt;/code&gt;&lt;/a&gt; &amp;mdash; convert an Observable into another object or data structure</source>
          <target state="translated">&lt;a href=&quot;operators/to&quot;&gt; &lt;code&gt;To&lt;/code&gt; &lt;/a&gt; - преобразовать Observable в другой объект или структуру данных</target>
        </trans-unit>
        <trans-unit id="a27441bb348b701709f46ba2a9e1fd000edbe104" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/using&quot;&gt;&lt;code&gt;Using&lt;/code&gt;&lt;/a&gt; &amp;mdash; create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">&lt;a href=&quot;operators/using&quot;&gt; &lt;code&gt;Using&lt;/code&gt; &lt;/a&gt; - создание одноразового ресурса, срок жизни которого такой же, как у наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="4e7798a9984bb26f086d17dce14b65fb99ceeb7d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; &amp;mdash; periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">&lt;a href=&quot;operators/window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; - периодически разделяйте элементы из Observable на Observable окна и генерируйте эти окна, а не по одному за раз</target>
        </trans-unit>
        <trans-unit id="c5cf183eb5d366413ed5d5c204d8b7fa6f3b0e5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/a&gt; &amp;mdash; combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;Zip&lt;/code&gt; &lt;/a&gt; - объединить выбросы нескольких Observable вместе с помощью указанной функции и создать отдельные элементы для каждой комбинации на основе результатов этой функции</target>
        </trans-unit>
        <trans-unit id="1d6d8e38830f49548b2c4afc11148786a0b1e918" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; (версия&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; для&lt;/strong&gt; RxClojure)</target>
        </trans-unit>
        <trans-unit id="79293a7f079b9373f12db529fcf04630f0840459" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;operators/zip&quot;&gt;&lt;code&gt;mapCat&lt;/code&gt;&lt;/a&gt; (RxClojure version of &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt;)</source>
          <target state="translated">&lt;a href=&quot;operators/zip&quot;&gt; &lt;code&gt;mapCat&lt;/code&gt; &lt;/a&gt; (версия&lt;strong&gt; &lt;code&gt;Zip&lt;/code&gt; для&lt;/strong&gt; RxClojure)</target>
        </trans-unit>
        <trans-unit id="bc842fac1c68ceb5773485119db93147ac0c6b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;Single&lt;/tt&gt;&lt;/a&gt; &amp;mdash; a specialized version of an Observable that emits only a single item</source>
          <target state="translated">&lt;a href=&quot;single&quot;&gt;&lt;tt&gt;Single&lt;/tt&gt;&lt;/a&gt; - специализированная версия Observable, которая испускает только один элемент</target>
        </trans-unit>
        <trans-unit id="84438b704c9fca4e5527512cd5c27340544d75ab" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Buffer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : буфер - простой</target>
        </trans-unit>
        <trans-unit id="8e3999cc1a087194796f932be496866a6f0182c3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="9dfeeecdc7b7288e5ea70c6c892c1d944664cf48" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: CombineLatest &amp;mdash; Parallel Execution</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : CombineLatest - параллельное выполнение</target>
        </trans-unit>
        <trans-unit id="f6b4feb080d4814c3633843d31049b4ae614c799" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; cold observable</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Concat - холодное наблюдение</target>
        </trans-unit>
        <trans-unit id="c0e2ed6732260c865ef6eccba85b4ddc0466e81a" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Concat &amp;mdash; hot observable</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Concat - горячо наблюдаемый</target>
        </trans-unit>
        <trans-unit id="7f1e8f5e8387df20c1e2eec385011ae6468129f3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Delay &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : задержка - простой</target>
        </trans-unit>
        <trans-unit id="e9cd41c26800564ad47aa6441382096c455b8e77" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : создать</target>
        </trans-unit>
        <trans-unit id="b9ed1f3ab8250846a6b02df43301b10c649c335e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: GroupJoin &amp;mdash; Joins two streams by matching by one of their attributes</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : GroupJoin - объединяет два потока путем сопоставления по одному из их атрибутов</target>
        </trans-unit>
        <trans-unit id="f4a401a286d1a0539e3f17195639b2743803c2c5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: ISubject&amp;lt;T&amp;gt; and ISubject&amp;lt;T1,T2&amp;gt;</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : ISubject &amp;lt;T&amp;gt; и ISubject &amp;lt;T1, T2&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4497c7c8e023a9337eb5395666b4310b2d91e7e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : интервал - простой</target>
        </trans-unit>
        <trans-unit id="a953c40a21409172145703f425a7a60796dd5e88" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Interval &amp;mdash; With TimeInterval()</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Interval - с TimeInterval ()</target>
        </trans-unit>
        <trans-unit id="65190ea0c6ca0b42f3664eb352fbfe370afd6443" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : слияние</target>
        </trans-unit>
        <trans-unit id="38e8128889f9b5776897d04d41bfbd2cef9c6fde" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observation Operators</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : операторы наблюдения</target>
        </trans-unit>
        <trans-unit id="49730b290b423f322940dab1ff7061f932845d63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Observing the Passing of Time</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : наблюдение за течением времени</target>
        </trans-unit>
        <trans-unit id="bdfc989ca6ffd7c7cbf77916f7081d7bbbcf3c03" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Publish &amp;mdash; Sharing a subscription with multiple Observers</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : публикация - совместное использование подписки с несколькими наблюдателями</target>
        </trans-unit>
        <trans-unit id="82e1b94cb3df3df1bc50246ed5e11b9d9a413f3e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : диапазон</target>
        </trans-unit>
        <trans-unit id="fd72099514d7ac2d1520ae4b1cd03541ecb3d75b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Sample &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : образец - простой</target>
        </trans-unit>
        <trans-unit id="9d5982dbcf362e5fe59b0b1a74ae7c356eb14b62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Select &amp;mdash; Indexed</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Выбрать - проиндексировано</target>
        </trans-unit>
        <trans-unit id="758e63347c494706666595c451133580e55bb6b1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Start &amp;mdash; Run Code Asynchronously</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : запуск - асинхронный запуск кода</target>
        </trans-unit>
        <trans-unit id="c2323d4a4016773c83f1325ef75d2d80d33e98d7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Throttle &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Дроссель - Простой</target>
        </trans-unit>
        <trans-unit id="d228cb755846dd4e2bab50fb5eab415316bfec1c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timeout &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Тайм-аут - простой</target>
        </trans-unit>
        <trans-unit id="002c8dac44d68094923f2810a86c6d928664e2f1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timer &amp;mdash; Simple</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : Таймер - Простой</target>
        </trans-unit>
        <trans-unit id="8cb1c8d362fc1bea83ee3e202602ece035e7c32e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Timestamp</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : отметка времени</target>
        </trans-unit>
        <trans-unit id="6ee1829693fce377b6ff46cbe5704191231dfef0" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;101 Rx Samples&lt;/cite&gt; : окно</target>
        </trans-unit>
        <trans-unit id="7e1cda1b914a8d023f1dc4d23b17ff394f90c636" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;101 Rx Samples&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;Образцы 101 Rx&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="a4bda5dfe90db399b7c4b0b87d01c88b07162ee5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebounceBuffer: Use publish(), debounce() and buffer() together to capture bursts of events.&lt;/cite&gt; by Ben Christensen</source>
          <target state="translated">&lt;cite&gt;DebounceBuffer: используйте вместе publish (), debounce () и buffer () для захвата пакетов событий. &lt;/cite&gt;Бен Кристенсен</target>
        </trans-unit>
        <trans-unit id="a2c0ae8f6836ea32e237cbdd5a36d5da68d09d69" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;DebouncedBuffer With RxJava&lt;/cite&gt; by Gopal Kaushik</source>
          <target state="translated">&lt;cite&gt;DebouncedBuffer с RxJava&lt;/cite&gt; от Гопала &lt;cite&gt;Кошика&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="eda16f284575e40f90ac1dc6981b546622a0c621" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Aggregate</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Aggregate</target>
        </trans-unit>
        <trans-unit id="29247369a4b0d247d97753a93d41653acdcc1b2c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: All</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : все</target>
        </trans-unit>
        <trans-unit id="93019059f558486ba0ef91989fbb8dc88733b68e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: And-Then-When</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : And-Then-When</target>
        </trans-unit>
        <trans-unit id="dc360128e41bbeba319356f06f179ae8502f246c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: AsyncSubject</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : AsyncSubject</target>
        </trans-unit>
        <trans-unit id="035b87099a1834a0e066b29f62655685da21f8a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: BehaviorSubject</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="8bc61a26f41cc061366ee6101362cf6f70d41f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Buffer</target>
        </trans-unit>
        <trans-unit id="5b117e897e1a17fe032c5af3a2ce613ff6014d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Buffer revisited</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : новый взгляд на буфер</target>
        </trans-unit>
        <trans-unit id="ab41ea4f239b99143925cd4be6c94ac1e3cfefa7" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Cast and OfType</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Cast и OfType</target>
        </trans-unit>
        <trans-unit id="dd718e0e229c64fe1688ec231dd8353c9a412db9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Catch</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Catch</target>
        </trans-unit>
        <trans-unit id="b321cc1c9b76079278935ccb62bff36d39200bc5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: CombineLatest</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : CombineLatest</target>
        </trans-unit>
        <trans-unit id="116fa0f10acbbeea88e8d3059138b6ffe66c5444" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Concat</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Concat</target>
        </trans-unit>
        <trans-unit id="1528f7d4c47527e0e461233c282602ab6d7c644e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Contains</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : содержит</target>
        </trans-unit>
        <trans-unit id="3cbe58edf946b3f8dfb0bb7c462598c80afc1e93" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Count</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Count</target>
        </trans-unit>
        <trans-unit id="c35d04abcc5dd65704022c34cf83804415cc2818" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Create</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Create</target>
        </trans-unit>
        <trans-unit id="c1fd0c382a8358907465f71dddc50255a92ecd52" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: DefaultIfEmpty</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="b0b4c1fb3d3566c798e145f7923dc2a08228d7a6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Delay</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Delay</target>
        </trans-unit>
        <trans-unit id="b54a5e164dffee3139f0b8af5169e80489a8e13b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Distinct and DistinctUntilChanged</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Distinct и DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="777d04576f3bc70403fbe3a7bb1a9372ec841588" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Do</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Do</target>
        </trans-unit>
        <trans-unit id="8eb3452c0d7a0dadb569326b2e61144cf85c9fd3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ElementAt and ElementAtUntilChanged</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : ElementAt и ElementAtUntilChanged</target>
        </trans-unit>
        <trans-unit id="102fcee9f7ec081921ab59ef89ed1c5e6b30e5de" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Finally</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : наконец</target>
        </trans-unit>
        <trans-unit id="23ea11e182295d6ed28a6220510e239e26b5282e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: First</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : первое</target>
        </trans-unit>
        <trans-unit id="c115a63e4865e74a4f8c5c291e91b00b3a150355" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Generate</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : создание</target>
        </trans-unit>
        <trans-unit id="60542fbfdcd01dc53807bc0478ce040a8e2f6f10" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupBy</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : GroupBy</target>
        </trans-unit>
        <trans-unit id="540568cfdc74e1f0a4c7b8678fd0356e93246f46" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: GroupJoin</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : GroupJoin</target>
        </trans-unit>
        <trans-unit id="6339c110750aea5eb774297c37884bfcde2b0f79" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObservable</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : IObservable</target>
        </trans-unit>
        <trans-unit id="c3d98673531f7a8b8b3f9e8256945795eeabd6f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IObserver</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : IObserver</target>
        </trans-unit>
        <trans-unit id="fd627340831e496d98293a5f69462983384dde95" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: IgnoreElements</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : IgnoreElements</target>
        </trans-unit>
        <trans-unit id="62256229d5203f226886b8e64e6ea284cf6957eb" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Interval</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Interval</target>
        </trans-unit>
        <trans-unit id="0c4474d3483ee629a00095c34b8d299693d81065" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Join</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Присоединяйтесь</target>
        </trans-unit>
        <trans-unit id="87545688a3ea5ebc6e25e2842e72c8dd9c5d1e62" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Last</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Last</target>
        </trans-unit>
        <trans-unit id="0de669709c1879b9f542aa4f94c433bcc8290782" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Leaving the monad</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : выход из монады</target>
        </trans-unit>
        <trans-unit id="1ec1f4dfc1029c5aa7773b137724641aade3c9a3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Materialize and Dematerialize</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : материализация и дематериализация</target>
        </trans-unit>
        <trans-unit id="b04f7fc5eb7b8ba52c2a9a92360ca02e81cf40ad" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Merge</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Merge</target>
        </trans-unit>
        <trans-unit id="fa7869d155329c64ed405fc5786876dad056073d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Min, Max, Sum, and Average</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Min, Max, Sum и Average</target>
        </trans-unit>
        <trans-unit id="d365b1eb7a9536f57568dab1fe5dd916f25bda8d" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Publish &amp;amp; Connect</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : публикация и подключение</target>
        </trans-unit>
        <trans-unit id="e878ce5258868ac3eb4fdf5d6843d2c8b3a76f7b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Range</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Range</target>
        </trans-unit>
        <trans-unit id="c1cf07af2c8eace50997f716a98f99e4c0971f00" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: RefCount</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : RefCount</target>
        </trans-unit>
        <trans-unit id="084764999a741c143088232da1c0321b35e44092" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Repeat</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : повторить</target>
        </trans-unit>
        <trans-unit id="26de299ed749b577f696b62b39924a8a9e30ef6b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Replay</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Replay</target>
        </trans-unit>
        <trans-unit id="c06a12ff37836439265ffeb4d10fc8154fcfaa4f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: ReplaySubject</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : ReplaySubject</target>
        </trans-unit>
        <trans-unit id="b30bd9ac68d920b64f5efe285e03d588837291f5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Retry</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Retry</target>
        </trans-unit>
        <trans-unit id="54854f0097fa9244f288e39b24e48e27f8b83e4b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Return</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Return</target>
        </trans-unit>
        <trans-unit id="79e2be634bb26a274d4fdf88c706025ebeaa2d11" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Sample</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : образец</target>
        </trans-unit>
        <trans-unit id="1e1001379cadd511d49b86bafe6e12c95acd7607" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scan</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Scan</target>
        </trans-unit>
        <trans-unit id="dc0d36e7e05dd4add274fb3feede439a3a19fa5b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Scheduling and Threading</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : планирование и потоки</target>
        </trans-unit>
        <trans-unit id="d7dab96b686167a434b97d22488b8cb79d6c5417" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Select</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Выбрать</target>
        </trans-unit>
        <trans-unit id="477286cb919491f0f63e72a8903656eb7a6282c1" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SelectMany</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SelectMany</target>
        </trans-unit>
        <trans-unit id="ee1800b1d9f701e32bfd1c70be2fcb64008e74f8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SequenceEqual</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SequenceEqual</target>
        </trans-unit>
        <trans-unit id="ed818ec833039363080c9f8f4e89173be2b16966" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Simple Factory Methods</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : простые фабричные методы</target>
        </trans-unit>
        <trans-unit id="fd00bb3e997d8645bdf8fe33420a70c94cda4c6e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Single</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Single</target>
        </trans-unit>
        <trans-unit id="b745a93a790b9dad2a52091e6386fcbbc51de6ee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Skip and Take</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Skip and Take</target>
        </trans-unit>
        <trans-unit id="1443306acabe169cf8f390ed1c3f8bbc6913bfee" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipLast and TakeLast</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SkipLast и TakeLast</target>
        </trans-unit>
        <trans-unit id="5cfe8d6a7fee34f4bb8d00922555c4a8c705669f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipUntil and TakeUntil</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SkipUntil и TakeUntil</target>
        </trans-unit>
        <trans-unit id="b6650c255e70bfd3620e12c3cc72fedf90eadf2e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SkipWhile and TakeWhile</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SkipWhile и TakeWhile</target>
        </trans-unit>
        <trans-unit id="8cc66b563aabc4fbedb00d8119ba74bacef0ab41" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: StartWith</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : StartWith</target>
        </trans-unit>
        <trans-unit id="9086b49d24c6b80e0f6a79b601213b2ce91d13b5" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Subject</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Тема</target>
        </trans-unit>
        <trans-unit id="9a983fed5c5e768256355b29f51e96fa5bbb549e" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: SubscribeOn and ObserveOn</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : SubscribeOn и ObserveOn</target>
        </trans-unit>
        <trans-unit id="83b0d127d96097cab2795ab626cee0a49915b626" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Switch</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Switch</target>
        </trans-unit>
        <trans-unit id="598171f79ea0f898758ff883e3ad03569f596954" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Throttle</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Throttle</target>
        </trans-unit>
        <trans-unit id="c2b85e9531a48451320c69fba5b56201a54cdb7f" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timeout</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : тайм-аут</target>
        </trans-unit>
        <trans-unit id="e98b8b62bdf570f0a4177044a6de1ba2c46e8d5c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timer</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Таймер</target>
        </trans-unit>
        <trans-unit id="7aaa2e22718c5ee322409e5e0fbbf4c9fbefbd6c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Timestamp and TimeInterval</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Timestamp и TimeInterval</target>
        </trans-unit>
        <trans-unit id="8b1306a6995c5be8256f3ea632e95419c48355f6" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Using</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Использование</target>
        </trans-unit>
        <trans-unit id="82e2eaaf295a67907acba8525225401373b5b6e8" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Where</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : где</target>
        </trans-unit>
        <trans-unit id="88acce28317e2934f05b0089a12e44c31a31df21" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Window</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Window</target>
        </trans-unit>
        <trans-unit id="311056bb87e8631686c9a13f7a9aa24b48a750b3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Introduction to Rx&lt;/cite&gt;: Zip</source>
          <target state="translated">&lt;cite&gt;Введение в Rx&lt;/cite&gt; : Zip</target>
        </trans-unit>
        <trans-unit id="6c9f75058fd74c2e40d3fbad984b2426f71c5f1b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt;: &amp;ldquo;What does the new ManySelect operator do?&amp;rdquo;</source>
          <target state="translated">&lt;cite&gt;Microsoft Developer Network&lt;/cite&gt; : &amp;laquo;Что делает новый оператор ManySelect?&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="a2513d452931404692c534110e17b00bb086db47" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Рекомендации по проектированию Rx&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="f16b13d1d2d48a4ab59af38cc3f2786f48280ae9" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop: Schedulers&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Мастерская Rx: Планировщики&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="69b16a529d6fb7f077c4e534c2ba8a41a8b5195c" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Introduction</source>
          <target state="translated">&lt;cite&gt;Мастерская Rx&lt;/cite&gt; : Введение</target>
        </trans-unit>
        <trans-unit id="5e372f7712619b05579788c28d99a8619d24c02b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;Rx Workshop&lt;/cite&gt;: Schedulers</source>
          <target state="translated">&lt;cite&gt;Мастерская Rx&lt;/cite&gt; : Планировщики</target>
        </trans-unit>
        <trans-unit id="5060b2e8a80327e13489eab521802fc2c1470513" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJS Design Guidelines&lt;/cite&gt;</source>
          <target state="translated">&lt;cite&gt;Рекомендации по дизайну RxJS&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="84472df2bda697a25594c7286ae6152a2914a3d3" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;RxJava Threading Examples&lt;/cite&gt; by Graham Lea</source>
          <target state="translated">&lt;cite&gt;Примеры потоковой передачи RxJava&lt;/cite&gt; от Грэма Ли</target>
        </trans-unit>
        <trans-unit id="3c89a5198e1f457a5def50b38dd05269b98b494b" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;StackOverflow&lt;/cite&gt;: What is a &amp;ldquo;Scheduler&amp;rdquo; in RxJS</source>
          <target state="translated">&lt;cite&gt;StackOverflow&lt;/cite&gt; : что такое &amp;laquo;планировщик&amp;raquo; в RxJS</target>
        </trans-unit>
        <trans-unit id="99ad2748ced1a268c1da5ba38bef169ec3221a63" translate="yes" xml:space="preserve">
          <source>&lt;cite&gt;ad-hockery&lt;/cite&gt;: Simple Background Polling with RxJava</source>
          <target state="translated">&lt;cite&gt;ad-hockery&lt;/cite&gt; : простой фоновый опрос с помощью RxJava</target>
        </trans-unit>
        <trans-unit id="fdc895a0d19a290d9d7e1ce1ff10f8f31be62c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt;. This behaves similarly to &lt;code&gt;stopAndWait&lt;/code&gt; but has an internal buffer of</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; . Он ведет себя аналогично &lt;code&gt;stopAndWait&lt;/code&gt; , но имеет внутренний буфер размером</target>
        </trans-unit>
        <trans-unit id="ee8c7fe962e91ed4b8f8c0b825242e59e8443a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;All&lt;/code&gt;, &lt;code&gt;Amb&lt;/code&gt;, &lt;code&gt;Contains&lt;/code&gt;, &lt;code&gt;DefaultIfEmpty&lt;/code&gt;, &lt;code&gt;SequenceEqual&lt;/code&gt;, &lt;code&gt;SkipUntil&lt;/code&gt;, &lt;code&gt;SkipWhile&lt;/code&gt;, &lt;code&gt;TakeUntil&lt;/code&gt;, and &lt;code&gt;TakeWhile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;All&lt;/code&gt; , &lt;code&gt;Amb&lt;/code&gt; , &lt;code&gt;Contains&lt;/code&gt; , &lt;code&gt;DefaultIfEmpty&lt;/code&gt; , &lt;code&gt;SequenceEqual&lt;/code&gt; , &lt;code&gt;SkipUntil&lt;/code&gt; , &lt;code&gt;SkipWhile&lt;/code&gt; , &lt;code&gt;TakeUntil&lt;/code&gt; и &lt;code&gt;TakeWhile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6d4b2413273db5421b89d5d4bf5bbc759de0ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;And&lt;/code&gt;/&lt;code&gt;Then&lt;/code&gt;/&lt;code&gt;When&lt;/code&gt;, &lt;code&gt;CombineLatest&lt;/code&gt;, &lt;code&gt;Join&lt;/code&gt;, &lt;code&gt;Merge&lt;/code&gt;, &lt;code&gt;StartWith&lt;/code&gt;, &lt;code&gt;Switch&lt;/code&gt;, and &lt;code&gt;Zip&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;And&lt;/code&gt; / &lt;code&gt;Then&lt;/code&gt; / &lt;code&gt;When&lt;/code&gt; , &lt;code&gt;CombineLatest&lt;/code&gt; , &lt;code&gt;Join&lt;/code&gt; , &lt;code&gt;Merge&lt;/code&gt; , &lt;code&gt;StartWith&lt;/code&gt; , &lt;code&gt;Switch&lt;/code&gt; и &lt;code&gt;Zip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7126635798dce02399a0d9194f6641dfa46c0068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Average&lt;/code&gt;, &lt;code&gt;Concat&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt;, &lt;code&gt;Min&lt;/code&gt;, &lt;code&gt;Reduce&lt;/code&gt;, and &lt;code&gt;Sum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Average&lt;/code&gt; , &lt;code&gt;Concat&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; , &lt;code&gt;Max&lt;/code&gt; , &lt;code&gt;Min&lt;/code&gt; , &lt;code&gt;Reduce&lt;/code&gt; и &lt;code&gt;Sum&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c5c2eccca242affd9bbd13eb09e3476a9ed7742" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; takes a single function as its parameter, and this function behaves much like an &lt;code&gt;onNext&lt;/code&gt; function in the subscription to an ordinary Observable. The &lt;code&gt;forEach&lt;/code&gt; operator itself blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; completes, and it is by unblocking, rather than by calling a callback function, that it indicates that it is complete. If it encounters an error it will throw a &lt;code&gt;RuntimeException&lt;/code&gt; (rather than calling an analogue to the &lt;code&gt;onError&lt;/code&gt; callback).</source>
          <target state="translated">&lt;code&gt;BlockingObservable.forEach&lt;/code&gt; принимает в качестве параметра одну функцию, и эта функция ведет себя так же, как функция &lt;code&gt;onNext&lt;/code&gt; в подписке на обычный Observable. Сам оператор &lt;code&gt;forEach&lt;/code&gt; блокируется до тех пор, пока &lt;code&gt;BlockingObservable&lt;/code&gt; не завершится, и это означает, что он завершен путем разблокировки, а не путем вызова функции обратного вызова. Если он обнаруживает ошибку, он &lt;code&gt;RuntimeException&lt;/code&gt; (вместо вызова аналога обратного вызова &lt;code&gt;onError&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9fbef09e1b4ea0717efe751ffcefe7699946c25c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;BufferOpenings&lt;/code&gt;, that emits &lt;code&gt;TBufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;IList&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;TBufferOpening&lt;/code&gt; object into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;Buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;IList&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;Buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; отслеживает Observable, &lt;code&gt;BufferOpenings&lt;/code&gt; , который испускает объекты &lt;code&gt;TBufferOpening&lt;/code&gt; . Каждый раз, когда он наблюдает за таким переданным элементом, он создает новый список &lt;code&gt;IList&lt;/code&gt; , чтобы начать сбор элементов, &lt;code&gt;TBufferOpening&lt;/code&gt; исходным Observable, и передает объект &lt;code&gt;bufferClosingSelector&lt;/code&gt; функцию bufferClosingSelector . Эта функция возвращает Observable. &lt;code&gt;Buffer&lt;/code&gt; отслеживает этот Observable, и когда он обнаруживает отправленный из него элемент, он закрывает &lt;code&gt;IList&lt;/code&gt; и испускает его как собственное излучение.</target>
        </trans-unit>
        <trans-unit id="17d76f7cc4ba89864f1b43d8207b52f2436f06ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;IList&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;IList&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;Buffer(count)&lt;/code&gt; испускает неперекрывающиеся буферы в форме &lt;code&gt;IList&lt;/code&gt; s, каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (последний переданный &lt;code&gt;IList&lt;/code&gt; может иметь меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="7081d72299cbb568724327709a714b40f340cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;IList&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;Buffer(count, skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальный элемент и последующие &lt;code&gt;count-1&lt;/code&gt; . Он испускает эти буферы как &lt;code&gt;IList&lt;/code&gt; s. В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="0da2abc6a4d49055692e67ed62d86fc2cb0e1e82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first list, since the subscription to the source Observable. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan)&lt;/code&gt; генерирует новый список элементов &lt;code&gt;IList&lt;/code&gt; , каждый раз в &lt;code&gt;timeSpan&lt;/code&gt; промежутка времени timeSpan , содержащий все элементы, выпущенные источником Observable с момента предыдущего выпуска пакета или, в случае первого списка, с момента подписки на источник Observable. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом .</target>
        </trans-unit>
        <trans-unit id="fe0db02107ba69f00dfab9f9466aa0e853bf477c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; emits a new &lt;code&gt;IList&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; has elapsed since its last list emission, it emits a list of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, count)&lt;/code&gt; испускает новый &lt;code&gt;IList&lt;/code&gt; элементов для каждого &lt;code&gt;count&lt;/code&gt; элементов, испускаемых исходным Observable, или, если &lt;code&gt;timeSpan&lt;/code&gt; истек с момента его последнего выпуска списка, он выдает список из того количества элементов, которое исходный Observable испустил в этом диапазоне , даже если это меньше, чем &lt;code&gt;count&lt;/code&gt; . Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом .</target>
        </trans-unit>
        <trans-unit id="8b47fc6baedd7b73f21f5f4d7959f2aa975a8452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; creates a new &lt;code&gt;IList&lt;/code&gt; of items every &lt;code&gt;timeShift&lt;/code&gt; period of time, and fills this list with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; time has passed since the list&amp;rsquo;s creation, before emitting this &lt;code&gt;IList&lt;/code&gt; as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted lists will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes an &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;Buffer(timeSpan, timeShift)&lt;/code&gt; создает новый &lt;code&gt;IList&lt;/code&gt; элементов каждый период времени &lt;code&gt;timeShift&lt;/code&gt; и заполняет этот список каждым элементом, испускаемым источником Observable с этого времени до &lt;code&gt;timeSpan&lt;/code&gt; пор, пока не истечет время timeSpan с момента создания списка, прежде чем испускать этот &lt;code&gt;IList&lt;/code&gt; как собственный эмиссия. Если &lt;code&gt;timeSpan&lt;/code&gt; больше, чем &lt;code&gt;timeShift&lt;/code&gt; , генерируемые списки будут представлять периоды времени, которые перекрываются, и поэтому они могут содержать повторяющиеся элементы. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом .</target>
        </trans-unit>
        <trans-unit id="dabc780819d59525df52a91f7676a389f3e0f2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;FlatMap&lt;/code&gt;, &lt;code&gt;GroupBy&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Scan&lt;/code&gt;, and &lt;code&gt;Window&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;FlatMap&lt;/code&gt; , &lt;code&gt;GroupBy&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Scan&lt;/code&gt; и &lt;code&gt;Window&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36249d8634975dadb84d72123168f8247b877485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Catch&lt;/code&gt; and &lt;code&gt;Retry&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Catch&lt;/code&gt; и &lt;code&gt;Retry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e26c0b89264fa68e936ea021b56c4aec1f096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Connect&lt;/code&gt;, &lt;code&gt;Publish&lt;/code&gt;, &lt;code&gt;RefCount&lt;/code&gt;, and &lt;code&gt;Replay&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Connect&lt;/code&gt; , &lt;code&gt;Publish&lt;/code&gt; , &lt;code&gt;RefCount&lt;/code&gt; и &lt;code&gt;Replay&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2352bf3b7789aa73de64405f99b50a6b876dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Defer&lt;/code&gt;, &lt;code&gt;Empty&lt;/code&gt;/&lt;code&gt;Never&lt;/code&gt;/&lt;code&gt;Throw&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt;, &lt;code&gt;Interval&lt;/code&gt;, &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;Repeat&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt;, and &lt;code&gt;Timer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Defer&lt;/code&gt; , &lt;code&gt;Empty&lt;/code&gt; / &lt;code&gt;Never&lt;/code&gt; / &lt;code&gt;Throw&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; , &lt;code&gt;Interval&lt;/code&gt; , &lt;code&gt;Just&lt;/code&gt; , &lt;code&gt;Range&lt;/code&gt; , &lt;code&gt;Repeat&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; и &lt;code&gt;Timer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af0cc0f15199ef85fbb9ecd6605602fd48b0e87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Debounce&lt;/code&gt;, &lt;code&gt;Distinct&lt;/code&gt;, &lt;code&gt;ElementAt&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;IgnoreElements&lt;/code&gt;, &lt;code&gt;Last&lt;/code&gt;, &lt;code&gt;Sample&lt;/code&gt;, &lt;code&gt;Skip&lt;/code&gt;, &lt;code&gt;SkipLast&lt;/code&gt;, &lt;code&gt;Take&lt;/code&gt;, and &lt;code&gt;TakeLast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Debounce&lt;/code&gt; , &lt;code&gt;Distinct&lt;/code&gt; , &lt;code&gt;ElementAt&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; , &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;IgnoreElements&lt;/code&gt; , &lt;code&gt;Last&lt;/code&gt; , &lt;code&gt;Sample&lt;/code&gt; , &lt;code&gt;Skip&lt;/code&gt; , &lt;code&gt;SkipLast&lt;/code&gt; , &lt;code&gt;Take&lt;/code&gt; и &lt;code&gt;TakeLast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a5f8d43efabcb2ababea7b078ba251a574b59be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Delay&lt;/code&gt;, &lt;code&gt;Do&lt;/code&gt;, &lt;code&gt;Materialize&lt;/code&gt;/&lt;code&gt;Dematerialize&lt;/code&gt;, &lt;code&gt;ObserveOn&lt;/code&gt;, &lt;code&gt;Serialize&lt;/code&gt;, &lt;code&gt;Subscribe&lt;/code&gt;, &lt;code&gt;SubscribeOn&lt;/code&gt;, &lt;code&gt;TimeInterval&lt;/code&gt;, &lt;code&gt;Timeout&lt;/code&gt;, &lt;code&gt;Timestamp&lt;/code&gt;, and &lt;code&gt;Using&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Delay&lt;/code&gt; , &lt;code&gt;Do&lt;/code&gt; , &lt;code&gt;Materialize&lt;/code&gt; / &lt;code&gt;Dematerialize&lt;/code&gt; , &lt;code&gt;ObserveOn&lt;/code&gt; , &lt;code&gt;Serialize&lt;/code&gt; , &lt;code&gt;Subscribe&lt;/code&gt; , &lt;code&gt;SubscribeOn&lt;/code&gt; , &lt;code&gt;TimeInterval&lt;/code&gt; , &lt;code&gt;Timeout&lt;/code&gt; , &lt;code&gt;Timestamp&lt;/code&gt; и &lt;code&gt;Using&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1b4675304049fa90cdf432a831ba6b5c8ac581b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PublishSubject&lt;/code&gt; emits to an observer only those items that are emitted by the source Observable(s) subsequent to the time of the subscription.</source>
          <target state="translated">&lt;code&gt;PublishSubject&lt;/code&gt; отправляет наблюдателю только те элементы, которые были отправлены исходным Observable (ами) после времени подписки.</target>
        </trans-unit>
        <trans-unit id="95c856f5db49856ca93f078770fa39860cfdd2e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaySubject&lt;/code&gt; emits to any observer all of the items that were emitted by the source Observable(s), regardless of when the observer subscribes.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; отправляет любому наблюдателю все элементы, которые были отправлены исходным Observable (ами), независимо от того, когда наблюдатель подписывается.</target>
        </trans-unit>
        <trans-unit id="3d6e191c77e6cb37262a32efe110a3b46253be77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e2656e1a12907334ba6ba9dbb22e19905e2e0d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a145b69fbb341823a7e2b8ac1730617d11c3e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Window(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="652dd811848564f467f4c6881792205b07b1ddcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;average&lt;/code&gt; находится в следующих распределениях:</target>
        </trans-unit>
        <trans-unit id="9a5d83aa14e9a24c0de81cecf086101bb52aa929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;List&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer(boundary)&lt;/code&gt; контролирует наблюдаемую &lt;code&gt;boundary&lt;/code&gt; . Каждый раз, когда Observable испускает элемент, он создает новый &lt;code&gt;List&lt;/code&gt; , чтобы начать сбор элементов, выпущенных исходным Observable, и испускает предыдущий &lt;code&gt;List&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="697675068739693864b5220ff9294b45d325c570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(boundary&lt;/code&gt;[&lt;code&gt;, initialCapacity&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(boundary&lt;/code&gt; [ &lt;code&gt;, initialCapacity&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bbfe617dacf8cd6bfdd7ec53d1681abb55514b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt;. Each time that Observable emits an item, it creates a new collection to begin collecting items emitted by the source Observable and emits the previous collection.</source>
          <target state="translated">&lt;code&gt;buffer(bufferBoundaries)&lt;/code&gt; контролирует Observable, &lt;code&gt;bufferBoundaries&lt;/code&gt; . Каждый раз, когда Observable испускает элемент, он создает новую коллекцию, чтобы начать сбор элементов, выпущенных исходным Observable, и испускает предыдущую коллекцию.</target>
        </trans-unit>
        <trans-unit id="5308080ad587c5e4577043e64860d26d587755fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new &lt;code&gt;List&lt;/code&gt; to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;closingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it closes the &lt;code&gt;List&lt;/code&gt; and emits it as its own emission.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; контролирует Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; , который испускает объекты &lt;code&gt;BufferOpening&lt;/code&gt; . Каждый раз, когда он наблюдает за таким испущенным элементом, он создает новый &lt;code&gt;List&lt;/code&gt; чтобы начать сбор элементов, испускаемых исходным Observable, и передает &lt;code&gt;bufferOpenings&lt;/code&gt; Observable в функцию &lt;code&gt;closingSelector&lt;/code&gt; . Эта функция возвращает Observable. &lt;code&gt;buffer&lt;/code&gt; контролирует этот Observable, и когда он обнаруживает отправленный из него элемент, он закрывает &lt;code&gt;List&lt;/code&gt; и излучает его как собственное излучение.</target>
        </trans-unit>
        <trans-unit id="2570789cc0e868e96a6ac6bd1dc1fbc11fe2d472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; monitors an Observable, &lt;code&gt;bufferOpenings&lt;/code&gt;, that emits &lt;code&gt;BufferOpening&lt;/code&gt; objects. Each time it observes such an emitted item, it creates a new collection to begin collecting items emitted by the source Observable and it passes the &lt;code&gt;bufferOpenings&lt;/code&gt; Observable into the &lt;code&gt;bufferClosingSelector&lt;/code&gt; function. That function returns an Observable. &lt;code&gt;buffer&lt;/code&gt; monitors that Observable and when it detects an emitted item from it, it emits the current collection and begins a new one.</source>
          <target state="translated">&lt;code&gt;buffer(bufferOpenings, bufferClosingSelector)&lt;/code&gt; контролирует Observable, &lt;code&gt;bufferOpenings&lt;/code&gt; , который испускает объекты &lt;code&gt;BufferOpening&lt;/code&gt; . Каждый раз, когда он наблюдает за таким испущенным элементом, он создает новую коллекцию, чтобы начать сбор элементов, испускаемых исходным Observable, и передает &lt;code&gt;bufferOpenings&lt;/code&gt; Observable в функцию &lt;code&gt;bufferClosingSelector&lt;/code&gt; . Эта функция возвращает Observable. &lt;code&gt;buffer&lt;/code&gt; отслеживает этот Observable, и когда он обнаруживает отправленный из него элемент, он испускает текущую коллекцию и начинает новую.</target>
        </trans-unit>
        <trans-unit id="a6fe61d7081d96d83ff99876095e8a6fd192610b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; monitors an Observable, &lt;code&gt;buffer_openings&lt;/code&gt;. Each time that Observable emits an item, it creates a new array to begin collecting items emitted by the source Observable and emits the previous array.</source>
          <target state="translated">&lt;code&gt;buffer(buffer_openings=boundaryObservable)&lt;/code&gt; контролирует Observable, &lt;code&gt;buffer_openings&lt;/code&gt; . Каждый раз, когда Observable испускает элемент, он создает новый массив, чтобы начать сбор элементов, выпущенных исходным Observable, и испускает предыдущий массив.</target>
        </trans-unit>
        <trans-unit id="863a8824c4e8d667b06cdd3b24a0e6ddd6012b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; begins collecting items emitted by the source Observable immediately upon subscription, and also calls the &lt;code&gt;closing_selector&lt;/code&gt; function to generate a second Observable. It monitors this new Observable and, when it completes or emits an item, it emits the current array, begins a new array to collect items from the source Observable, and calls &lt;code&gt;closing_selector&lt;/code&gt; again to generate a new Observable to monitor in order to determine when to emit the new array. It repeats this process until the source Observable terminates, whereupon it emits the final array.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=closingSelector)&lt;/code&gt; начинает сбор элементов, выпущенных исходным Observable, сразу после подписки, а также вызывает функцию &lt;code&gt;closing_selector&lt;/code&gt; для генерации второго Observable. Он отслеживает этот новый Observable и, когда он завершает или испускает элемент, он излучает текущий массив, начинает новый массив для сбора элементов из исходного Observable и снова вызывает &lt;code&gt;closing_selector&lt;/code&gt; для создания нового Observable для мониторинга, чтобы определить, когда следует испустить новый массив. Он повторяет этот процесс до тех пор, пока исходный Observable не завершится, после чего он испускает окончательный массив.</target>
        </trans-unit>
        <trans-unit id="bd4258a2e6df22ec7068de8e9b1e62f83c9e1a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; begins by calling &lt;code&gt;closing_selector&lt;/code&gt; to get an Observable. It monitors this Observable, and, whenever it emits an item, &lt;code&gt;buffer&lt;/code&gt; creates a new array, begins to collect items subsequently emitted by the source Observable into this array, and calls &lt;code&gt;buffer_closing_selector&lt;/code&gt; to get a new Observable to govern the closing of that array. When this new Observable emits an item or terminates, &lt;code&gt;buffer&lt;/code&gt; closes and emits the array that the Observable governs.</source>
          <target state="translated">&lt;code&gt;buffer(closing_selector=openingSelector,&amp;nbsp;buffer_closing_selector=closingSelector)&lt;/code&gt; начинается с вызова &lt;code&gt;closing_selector&lt;/code&gt; для получения Observable. Он контролирует этот Observable, и всякий раз, когда он испускает элемент, &lt;code&gt;buffer&lt;/code&gt; создает новый массив, начинает собирать элементы, впоследствии отправленные исходным Observable в этот массив, и вызывает &lt;code&gt;buffer_closing_selector&lt;/code&gt; , чтобы получить новый Observable для управления закрытием этого массива. Когда этот новый Observable испускает элемент или завершается, &lt;code&gt;buffer&lt;/code&gt; закрывается и излучает массив, которым управляет Observable.</target>
        </trans-unit>
        <trans-unit id="46e14b0f10edb4752edcbe58757c5d212bbc1279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;List&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;List&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; испускает неперекрывающиеся буферы в виде &lt;code&gt;List&lt;/code&gt; s, каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (окончательный переданный &lt;code&gt;List&lt;/code&gt; может иметь меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="2056abba30f4856c7d26994b3b4bbf8b8a30285a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;vector&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted &lt;code&gt;vector&lt;/code&gt; may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer(count)&lt;/code&gt; испускает неперекрывающиеся буферы в виде &lt;code&gt;vector&lt;/code&gt; , каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (последний переданный &lt;code&gt;vector&lt;/code&gt; может иметь меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="2ee3ca99f3c9242184fe103637a7205a45e39454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;List&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальный элемент и последующие &lt;code&gt;count-1&lt;/code&gt; . Он испускает эти буферы как &lt;code&gt;List&lt;/code&gt; s. В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="c22dda51013aba339b4f5301fae6b2e4da5eccb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;vector&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer(count, skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальным элементом и последующими &lt;code&gt;count-1&lt;/code&gt; . Он испускает эти буферы как &lt;code&gt;vector&lt;/code&gt; . В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="583f8a99c7e6fa0453a17cde605fa702f865a085" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2109d7bb913a1ea95726f4100c1cebac8aa2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="491a83da4e4bb96760c09269a5758b2ad4a9dafe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64fa6aff05106cdc04eb3c628a3821de1a4df244" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; creates a new &lt;code&gt;List&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; period of time, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; time has passed since the bundle&amp;rsquo;s creation, before emitting this &lt;code&gt;List&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift, unit)&lt;/code&gt; создает новый &lt;code&gt;List&lt;/code&gt; элементов каждый период времени с &lt;code&gt;timeshift&lt;/code&gt; и заполняет этот пакет каждым элементом, испускаемым источником Observable с этого времени до тех пор, пока временной &lt;code&gt;timespan&lt;/code&gt; не пройдет с момента создания пакета, прежде чем отправлять этот &lt;code&gt;List&lt;/code&gt; как собственная эмиссия. Если &lt;code&gt;timeshift&lt;/code&gt; &lt;code&gt;timespan&lt;/code&gt; больше, чем временной сдвиг , генерируемые пакеты будут представлять периоды времени, которые перекрываются, и поэтому они могут содержать повторяющиеся элементы. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; По умолчанию этот вариант использует планировщик &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b98a3f859f7bbc620366a633025b1515dde55a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; creates a new array of items every &lt;code&gt;timeshift&lt;/code&gt; milliseconds, and fills this array with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since the array&amp;rsquo;s creation, before emitting this array as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, timeshift=timeshift)&lt;/code&gt; создает новый массив элементов каждые миллисекунды с &lt;code&gt;timeshift&lt;/code&gt; и заполняет этот массив каждым элементом, испускаемым источником Observable с этого времени до тех пор, пока временной &lt;code&gt;timespan&lt;/code&gt; миллисекундах не пройдет с момента создания массива, прежде чем испускать этот массив как собственный эмиссия. Если &lt;code&gt;timeshift&lt;/code&gt; &lt;code&gt;timespan&lt;/code&gt; больше, чем временной сдвиг , генерируемые массивы будут представлять периоды времени, которые перекрываются, и поэтому они могут содержать повторяющиеся элементы. Существует также версия этого варианта оператора, который принимает параметр &lt;code&gt;scheduler&lt;/code&gt; и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0533305f953f0a309e5df453b9e133d20568e589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; Scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; периодически генерирует новый &lt;code&gt;List&lt;/code&gt; элементов, каждый &lt;code&gt;timespan&lt;/code&gt; времени, содержащий все элементы, выпущенные источником Observable с момента предыдущего выпуска пакета или, в случае первого пакета, с момента подписки на источник Observable . Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; по умолчанию в этом варианте используется Планировщик &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e360891f0984ef4090aa7ada4740dcbb4f704617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; amount of time, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit)&lt;/code&gt; периодически генерирует новый &lt;code&gt;List&lt;/code&gt; элементов, каждый &lt;code&gt;timespan&lt;/code&gt; времени, содержащий все элементы, выпущенные источником Observable с момента предыдущего выпуска пакета или, в случае первого пакета, с момента подписки на источник Observable . Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; По умолчанию этот вариант использует планировщик &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8371395551452bb18051c520c2f4b5a089268672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; emits a new &lt;code&gt;List&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; has elapsed since its last bundle emission, it emits a bundle of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;computation&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer(timespan, unit, count)&lt;/code&gt; испускает новый &lt;code&gt;List&lt;/code&gt; элементов для каждого &lt;code&gt;count&lt;/code&gt; элементов, выпущенных исходным Observable, или, если &lt;code&gt;timespan&lt;/code&gt; истек с момента его последнего выпуска пакета, он выдает набор из того количества элементов, которое исходный Observable испустил в этот промежуток, даже если он меньше, чем &lt;code&gt;count&lt;/code&gt; . Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; По умолчанию этот вариант использует планировщик &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="065b6459d070388eac1369f1d551fcb749fb19e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="19c3817e4bc1a4a104318a507d1f1df1dcce46ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; требуется один из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="f240d669d61624f913fe346aa844fe8dd4cbf0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count)&lt;/code&gt; emits non-overlapping buffers, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may contain fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count)&lt;/code&gt; генерирует неперекрывающиеся буферы, каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (конечный переданный буфер может содержать меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="29a77fe8590e836748bec1afceb482424cc55b73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and a new one for every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones, emitting each buffer when it is complete. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;bufferWithCount(count, skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и новый для каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальный элемент и последующие &lt;code&gt;count-1&lt;/code&gt; , испуская каждый буфер, когда он заполнен. В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="4d936831debc89a8b2338b3a3007dc091decf55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithCount&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithCount&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="725109d45ba1846de8a6b8392b6391092d1a98ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; emits a new collection of items periodically, every &lt;code&gt;timeSpan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan)&lt;/code&gt; генерирует новую коллекцию элементов, каждый &lt;code&gt;timeSpan&lt;/code&gt; миллисекундах timeSpan , содержащую все элементы, выпущенные источником Observable с момента предыдущего выпуска пакета или, в случае первого пакета, с момента подписки на исходный Observable. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6826b6f33554f8fb1de2ebf021c2cadcb4cd9c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; creates a new collection of items every &lt;code&gt;timeShift&lt;/code&gt; milliseconds, and fills this bundle with every item emitted by the source Observable from that time until &lt;code&gt;timeSpan&lt;/code&gt; milliseconds has passed since the collection&amp;rsquo;s creation, before emitting this collection as its own emission. If &lt;code&gt;timeSpan&lt;/code&gt; is longer than &lt;code&gt;timeShift&lt;/code&gt;, the emitted bundles will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTime(timeSpan, timeShift)&lt;/code&gt; создает новую коллекцию элементов каждый &lt;code&gt;timeShift&lt;/code&gt; миллисекундах timeShift и заполняет этот пакет каждым элементом, испускаемым источником Observable с этого времени до &lt;code&gt;timeSpan&lt;/code&gt; пор, пока timeSpan миллисекунд не пройдет с момента создания коллекции, прежде чем испускать эту коллекцию как собственную эмиссию. Если &lt;code&gt;timeSpan&lt;/code&gt; длиннее &lt;code&gt;timeShift&lt;/code&gt; , генерируемые пакеты будут представлять периоды времени, которые перекрываются, и поэтому они могут содержать повторяющиеся элементы. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65d0e7bcf4ac65e74eca9ba20646e209c2c82ff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; и &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; находятся в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="5725f9a1a6a7c85dc4d290333be130a63966d6a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTime&lt;/code&gt; and &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; require one of the following distributions:</source>
          <target state="translated">&lt;code&gt;bufferWithTime&lt;/code&gt; и &lt;code&gt;bufferWithTimeOrCount&lt;/code&gt; требуют одного из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="29da60953849f79c94578371fc21981b0e02a7a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; emits a new collection of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timeSpan&lt;/code&gt; milliseconds have elapsed since its last collection emission, it emits a collection of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;bufferWithTimeOrCount(timeSpan, count)&lt;/code&gt; испускает новую коллекцию элементов для каждого &lt;code&gt;count&lt;/code&gt; элементов, испускаемых исходным Observable, или, если &lt;code&gt;timeSpan&lt;/code&gt; миллисекунды прошли с момента его последнего выпуска коллекции, он испускает коллекцию из того количества элементов, которое исходный Observable испустил в этом span, даже если это меньше, чем &lt;code&gt;count&lt;/code&gt; . Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa343001bbb40cc3e8b3cc541b1d7a9764e511ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count)&lt;/code&gt; emits non-overlapping buffers in the form of arrays, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted array may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count)&lt;/code&gt; испускает неперекрывающиеся буферы в виде массивов, каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (конечный переданный массив может иметь меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="b64633ff8b9b99511e1f91464f9c7b8f23d5b394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as arrays. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;buffer_with_count(count, skip=skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальный элемент и последующие &lt;code&gt;count-1&lt;/code&gt; . Он излучает эти буферы в виде массивов. В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="da6265be2e09c0f88dba2c30d63bf9e68b96a9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; испускает новый массив элементов периодически, каждые &lt;code&gt;timespan&lt;/code&gt; миллисекунд, содержащий все элементы , излучаемые источником наблюдаемого с момента предыдущего пучка излучения или, в случае первого пучка, с момента подписки на источник наблюдаемы.</target>
        </trans-unit>
        <trans-unit id="2c21c1882f580b27cb8db9eac720ea9eaf14d8e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; emits a new array of items periodically, every &lt;code&gt;timespan&lt;/code&gt; milliseconds, containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time(timespan)&lt;/code&gt; испускает новый массив элементов периодически, каждые &lt;code&gt;timespan&lt;/code&gt; миллисекунд, содержащий все элементы , излучаемые источником наблюдаемого с момента предыдущего пучка излучения или, в случае первого пучка, с момента подписки на источник наблюдаемы. Существует также версия этого варианта оператора, который принимает параметр &lt;code&gt;scheduler&lt;/code&gt; и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedb9b5d750555c146f9ea815130104bd7cdac7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; emits a new array of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; milliseconds have elapsed since its last bundle emission, it emits an array of however many items the source Observable has emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. There is also a version of this variant of the operator that takes a &lt;code&gt;scheduler&lt;/code&gt; parameter and uses it to govern the timespan; by default this variant uses the &lt;code&gt;timeout&lt;/code&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;buffer_with_time_or_count(timespan, count)&lt;/code&gt; испускает новый массив элементов для каждого &lt;code&gt;count&lt;/code&gt; элементов, испускаемых исходным Observable, или, если &lt;code&gt;timespan&lt;/code&gt; миллисекундах истек с момента его последнего выпуска пакета, он испускает массив из того количества элементов, которое исходный Observable испустил в этом span, даже если это меньше, чем &lt;code&gt;count&lt;/code&gt; . Существует также версия этого варианта оператора, который принимает параметр &lt;code&gt;scheduler&lt;/code&gt; и использует его для управления временным интервалом; по умолчанию в этом варианте используется планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8efbc0dfab77384e5695e0391a88f43d1c0aa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;switchCase&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; / &lt;code&gt;switchCase&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="21ab85f941795ebebc7621966c024835b3854ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="6eada5ba41149936eb42223cb804a2da3d2fb07e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;collect&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e34bcdea7b0a4428fe34327e1ecd484b3e7fa08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; and &lt;code&gt;concatAll&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; и &lt;code&gt;concatAll&lt;/code&gt; встречаются в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="fc4f8fb42b68e7c7b7e5316591de9ce7532f3f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables (or Promises) as parameters (or a single array of Observables or Promises), and concatenates them in the order they appear in the parameter list (or array). It exists as both an Observable prototype method and as an instance method.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; принимает переменное количество Observables (или Promises) в качестве параметров (или один массив Observables или Promises) и объединяет их в том порядке, в котором они появляются в списке параметров (или массиве). Он существует как метод-прототип Observable, так и как метод экземпляра.</target>
        </trans-unit>
        <trans-unit id="8a05f7b7657968ed6c712decc49d7b955c8b6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; is an instance method that operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; - это метод экземпляра, который работает с Observable of Observables, объединяя каждый из этих Observable в том порядке, в котором они генерируются.</target>
        </trans-unit>
        <trans-unit id="e66c4829b49a33917cc27c0640b2259d52e1e55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatAll&lt;/code&gt; operates on an Observable of Observables, concatinating each of these Observables in the order they are emitted.</source>
          <target state="translated">&lt;code&gt;concatAll&lt;/code&gt; работает с Observable из Observables, объединяя каждый из этих Observable в том порядке, в котором они генерируются.</target>
        </trans-unit>
        <trans-unit id="c0409c43e5cc9d6d379c8bea27199652abd6f255" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMap&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="7d029702d3e9b15b15c6b4d30027e9cc6d70b4e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;concatMapObserver&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="bfb35a6a3b4f9a20c3186e62ff7a21cb33bee0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; is found in the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; находится в следующих пакетах:</target>
        </trans-unit>
        <trans-unit id="9640f1d7fa4ad35d3539ac1d849fef7fe71caa33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connect&lt;/code&gt; requires one of the following packages:</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; требуется один из следующих пакетов:</target>
        </trans-unit>
        <trans-unit id="c5e5e027558b94847fe199fe7233b289d43c3988" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;contains&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="f02a10531ba2d78eaba589a48c7af53fab6e76c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; is part of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; является частью следующих пакетов:</target>
        </trans-unit>
        <trans-unit id="0fcbf042928888fd25281733fb74efa8027c00f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; requires one of any of the following packages:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; требуется один из следующих пакетов:</target>
        </trans-unit>
        <trans-unit id="8a6fbc195a31b898bd2620e8000a89499dcc9336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9606d8bf5fdf3394981d341c49d099b55449f265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="4fb2205ee6a769cc0527dc0468e5653d34418731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; and &lt;code&gt;debounceWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; и &lt;code&gt;debounceWithSelector&lt;/code&gt; находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="f6ec38915190181a63aae2734403ec6811aa79ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="0501ae0183e1bc12b30af5067f70d83fa221b7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; does not by default operate on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; по умолчанию не работает с конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4d06d8cc0b00cad69791240d6a9faa69aef0a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="0453f1952ccc6ca5fae76fdaa5a6430077591489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&lt;/code&gt;, &lt;code&gt;delaySubscription&lt;/code&gt;, and &lt;code&gt;delayWithSelector&lt;/code&gt; require &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt; and are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;delay&lt;/code&gt; , &lt;code&gt;delaySubscription&lt;/code&gt; и &lt;code&gt;delayWithSelector&lt;/code&gt; требуют &lt;code&gt;rx.lite.js&lt;/code&gt; или &lt;code&gt;rx.lite.compat.js&lt;/code&gt; и находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="a42e6eae40facebfc9412f8cd67d437d4ba55fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delaySubscription&lt;/code&gt; is similar to &lt;code&gt;delay&lt;/code&gt; but rather than timeshifting the emissions from the source Observable, it timeshifts the moment of subscription to that Observable. You pass to this operator a time value (either a &lt;code&gt;Number&lt;/code&gt;, in which case this sets the number of milliseconds of delay, or a &lt;code&gt;Date&lt;/code&gt;, in which case this sets an absolute future time at which &lt;code&gt;delaySubscription&lt;/code&gt; will trigger the subscription). You may optionally pass a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, which &lt;code&gt;delaySubscription&lt;/code&gt; will use to govern the delay period or trigger time.</source>
          <target state="translated">&lt;code&gt;delaySubscription&lt;/code&gt; похож на &lt;code&gt;delay&lt;/code&gt; но вместо того, чтобы сдвигать во времени выбросы от источника Observable, он сдвигает момент подписки на этот Observable. Вы передаете этому оператору значение времени (либо &lt;code&gt;Number&lt;/code&gt; , в этом случае это устанавливает количество миллисекунд задержки, либо &lt;code&gt;Date&lt;/code&gt; , и в этом случае это устанавливает абсолютное время в будущем, при котором &lt;code&gt;delaySubscription&lt;/code&gt; запускает подписку). При желании вы можете передать &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; в качестве второго параметра, который &lt;code&gt;delaySubscription&lt;/code&gt; будет использовать для управления периодом задержки или временем запуска.</target>
        </trans-unit>
        <trans-unit id="e7adbe72591784b4a714d2eb115365bb13e4cea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWithSelector&lt;/code&gt; is like &lt;code&gt;delay&lt;/code&gt; but does not use a constant delay duration (or absolute time), but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">&lt;code&gt;delayWithSelector&lt;/code&gt; похож на &lt;code&gt;delay&lt;/code&gt; , но не использует постоянную длительность задержки (или абсолютное время), но устанавливает длительность задержки для каждого элемента, передавая каждый элемент из исходного Observable в функцию, которая возвращает Observable, а затем отслеживает эти Observable. Когда любой такой Observable завершается, Observable, возвращенный &lt;code&gt;delay&lt;/code&gt; испускает связанный элемент.</target>
        </trans-unit>
        <trans-unit id="85526d492d5d878f590368951b13d664cbf0ab56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d70c73d8be9dbb0a7ddccccd361323bf2f38ab4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; встречается в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="2ca4c8f4b2a43c908128d7d73fdfa0aeec78bd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; обращает этот процесс: преобразование отправленных объектов &lt;code&gt;Notification&lt;/code&gt; из исходного Observable в уведомления из результирующего Observable.</target>
        </trans-unit>
        <trans-unit id="df41a1151275a1c436292bf439c78eb32a392ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; reverses this process: converting the emitted &lt;code&gt;Notification&lt;/code&gt; objects from the source Observable into notifications from the resulting Observable. The following example dematerializes the materialized Observable from the previous section:</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; обращает этот процесс: преобразование отправленных объектов &lt;code&gt;Notification&lt;/code&gt; из исходного Observable в уведомления из результирующего Observable. В следующем примере дематериализуется материализованный Observable из предыдущего раздела:</target>
        </trans-unit>
        <trans-unit id="575b0cbaa7c437c082382619ee3d2b599c5d8aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; и &lt;code&gt;distinctUntilChanged&lt;/code&gt; встречаются в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="f65514f172ddc744697e1b142c1194449befad2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinct&lt;/code&gt; and &lt;code&gt;distinctUntilChanged&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; и &lt;code&gt;distinctUntilChanged&lt;/code&gt; по умолчанию не работают ни с одним конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01a0882d7b2db85098410d045d7dff19792f7aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt;, &lt;code&gt;doOnNext&lt;/code&gt;/&lt;code&gt;tapOnNext&lt;/code&gt;, &lt;code&gt;doOnError&lt;/code&gt;/&lt;code&gt;tapOnError&lt;/code&gt;, &lt;code&gt;doOnCompleted&lt;/code&gt;/&lt;code&gt;tapOnCompleted&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; , &lt;code&gt;doOnNext&lt;/code&gt; / &lt;code&gt;tapOnNext&lt;/code&gt; , &lt;code&gt;doOnError&lt;/code&gt; / &lt;code&gt;tapOnError&lt;/code&gt; , &lt;code&gt;doOnCompleted&lt;/code&gt; / &lt;code&gt;tapOnCompleted&lt;/code&gt; , и, &lt;code&gt;finally&lt;/code&gt; находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="ba28eb2a98755e124f1d52b5b9dcc8bd04262dc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;doWhile&lt;/code&gt; is found in each of the following distributions.</source>
          <target state="translated">&lt;code&gt;doWhile&lt;/code&gt; находится в каждом из следующих дистрибутивов.</target>
        </trans-unit>
        <trans-unit id="8aee9c417fde4cd2d46ade859aa7f69f1f2a52e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; and &lt;code&gt;elementAtOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; и &lt;code&gt;elementAtOrDefault&lt;/code&gt; по умолчанию не работают с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0e41302836be86491f3b9837b34145fcc104fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="26d85c47be76d2b86ddbf1d36c82dae7e0563118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="1144ef5b59f5d111eb78cf1787143dd56d384a19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;every&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;every&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="3575ee1fc6c15b236ec3868735424258902118a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="b2c7c4225690df0f39e51c9f6112ab29eac89a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; требуется один из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="2cd400c1c5833ab09d2d1362e8821a842f57ba3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; и &lt;code&gt;where&lt;/code&gt; находятся в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="b4160a64d95ca2627e911591e307254638dca079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b415955a2aa1c5cbed5857327ffa9aa9dba51fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finallyDo&lt;/code&gt; is deprecated since RxJava 1.1.1, in favor of &lt;code&gt;doAfterTerminate&lt;/code&gt; with the same behavior.</source>
          <target state="translated">&lt;code&gt;finallyDo&lt;/code&gt; устарел с RxJava 1.1.1 в пользу &lt;code&gt;doAfterTerminate&lt;/code&gt; с таким же поведением.</target>
        </trans-unit>
        <trans-unit id="df5fe9a72c0b449743099df91b382964ece8478c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findIndex&lt;/code&gt;, and &lt;code&gt;first&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; , &lt;code&gt;findIndex&lt;/code&gt; и &lt;code&gt;first&lt;/code&gt; находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="9f9e2cc1497254c384bab408eec27fc4e6d63a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="a2968359c689419c3b851f5749fe9db70e799191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;singleOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; , &lt;code&gt;single&lt;/code&gt; , &lt;code&gt;singleOrDefault&lt;/code&gt; и &lt;code&gt;takeFirst&lt;/code&gt; по умолчанию не работают ни с одним конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc69e12ef4eb80735da7a8ffa7381624d352d14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;firstOrDefault&lt;/code&gt; также имеет вариант, которому вы можете передать функцию предиката, так что его Observable будет выдавать первый элемент из исходного Observable, который предикат оценивает как &lt;code&gt;true&lt;/code&gt; , или элемент по умолчанию, если никакие элементы, излучаемые исходным Observable, не передают предикат.</target>
        </trans-unit>
        <trans-unit id="06f0ceae9a2712cef444daa2be24a1a18e0220a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="a73ed2b1d04a2afe67083d006a5767d38008225d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">&lt;code&gt;flatMap&lt;/code&gt; работает так же хорошо, если предоставляемая вами функция преобразует элементы из исходных Observables в Observables, в Promises или в массивы.</target>
        </trans-unit>
        <trans-unit id="e5e16d10a285700e7dab486c58a155a35a9ce31e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapLatest&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapLatest&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="8c825a3961cc54c6c6ef805e3fd98b58b8f603ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable. It accepts a different transformation function to respond to &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; notifications and to return an Observable for each.</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; создает (и выравнивает) новый Observable для каждого элемента &lt;em&gt;и уведомления&lt;/em&gt; из исходного Observable. Он принимает разные функции преобразования для ответа на &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; и &lt;code&gt;onCompleted&lt;/code&gt; и для возврата Observable для каждого.</target>
        </trans-unit>
        <trans-unit id="f51b699df8e1441a48690c6b1971732a8b76801f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatMapObserver&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;flatMapObserver&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="ef78b641e6d3a740830c8f89647cba368bc89806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flatten&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence. A variant of this operator allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;flatten&lt;/code&gt; to try to be subscribed to at any time. It it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;flatten&lt;/code&gt; принимает в качестве параметра Observable, который испускает Observables. Он объединяет элементы, испускаемые каждым из этих Observable, для создания своей собственной единой Observable последовательности. Вариант этого оператора позволяет вам передать &lt;code&gt;Int&lt;/code&gt; , указывающее максимальное количество этих испускаемых Observables, на которые вы хотите &lt;code&gt;flatten&lt;/code&gt; чтобы попытаться подписаться на него в любое время. Если он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f490d9df4739ffcbdfd79e77f05c1a12ad66261d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flattenDelayError&lt;/code&gt; is similar to &lt;code&gt;flatten&lt;/code&gt; except that it will always emit all items from all of the emitted Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observables have finished emitting items.</source>
          <target state="translated">&lt;code&gt;flattenDelayError&lt;/code&gt; подобна &lt;code&gt;flatten&lt;/code&gt; за исключением того, что он всегда будет излучать все элементы из всех испускаемых наблюдаемых , даже если более из этих наблюдаемых один или завершается с &lt;code&gt;onError&lt;/code&gt; уведомления до того , как другие Наблюдаемые закончили излучающие элементы.</target>
        </trans-unit>
        <trans-unit id="a0c2292ff2aabdc802f42755a7f15ac367b4fbc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="11e1a4342d8e23599b8291e0535a43c3e1c8b990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, however you can pass the variant that converts a Future a Scheduler as an optional second parameter, and it will use that Scheduler to govern the Future.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; , однако вы можете передать вариант, который преобразует Future a Scheduler в качестве необязательного второго параметра, и он будет использовать этот планировщик для управления Future.</target>
        </trans-unit>
        <trans-unit id="5df439cbc86cf0b9ba3bedfa57ed66e6100a4072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="a65f1e48b7bb0d9d9d719896dcd792a4cfc83fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromCallback&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="2a72db4b80dc8bad54f16580c97b432c8b2daadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="07265cef8fee5d99da56092ca85c52c79f93584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromNodeCallback&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromNodeCallback&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="6a2ed748a3852498d48388eaf367201f153d93fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromPromise&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;fromPromise&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="2c3520858faf7a23e64e6c3d2f6e3307fbd26f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="0afae411108bbc561cc1122700b256b35c45fbaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; is found in the following distribution:</source>
          <target state="translated">&lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; находится в следующем дистрибутиве:</target>
        </trans-unit>
        <trans-unit id="52da1d549ee7151f9db69e4a561c0990d7a46355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generateWithRelativeTime&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;generateWithRelativeTime&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="4a23135807c49156cdc8b6752177c1f0c084e2c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91ad833301d1835f103f1baa096fee152ae86986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupBy&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupBy&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="0e3a79fda5beb1254249bb177d0da34e38313a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupByUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;groupByUntil&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="0893202a0ecab0d0f8ea3b772158225e7098703c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;groupJoin&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;groupJoin&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f5d0735a424248247ad9aae5cc496d8ece526a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="477fd73d586b9fcbec825cd0ec0de785a84f39a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69048ec3ceda893dbaff054dda9cc09355fcca6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignoreElements&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;ignoreElements&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="faf6f3923e8284b46d6b215d9e7373efbab268c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indexOf&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;indexOf&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="fccd0f02c09cee4ec7aa4d5fa8f66c339d4d6f8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave*&lt;/code&gt; is similar but operates on an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;interleave*&lt;/code&gt; аналогичен, но работает с Observable of Observables.</target>
        </trans-unit>
        <trans-unit id="7b50914802b5744bb9a29e53495e66d8ae29742e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interleave&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but more deliberate about how it interleaves the items from the source Observables: the resulting Observable emits the first item emitted by the first source Observable, then the first item emitted by the second source Observable, and so forth, and having reached the last source Observable, then emits the second item emitted by the first source Observable, the second item emitted by the second source Observable, and so forth, until all of the source Observables terminate.</source>
          <target state="translated">&lt;code&gt;interleave&lt;/code&gt; похоже на &lt;code&gt;merge&lt;/code&gt; , но более продумано, как оно чередует элементы из исходных Observable: полученный Observable испускает первый элемент, излучаемый первым источником Observable, затем первый элемент, излучаемый вторым источником Observable, и так далее, и имеющий достиг последнего источника Observable, затем испускает второй элемент, излучаемый первым источником Observable, второй элемент, излучаемый вторым источником Observable, и так далее, пока все исходные Observable не завершатся.</target>
        </trans-unit>
        <trans-unit id="7264e5224d0efb5bbea1588870c9d1c16097664b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; находится в следующих распределениях:</target>
        </trans-unit>
        <trans-unit id="0f6fbc36a92a3bb6ea90875470f4264e24b6511f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There are also variants that allow you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; работает по умолчанию в &lt;a href=&quot;../scheduler&quot;&gt;Планировщике &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; . Есть также варианты, которые позволяют вам установить планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="d4788908a9674cee42b2359c4082011fd9d64a96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can optionally pass in a different Scheduler as a second parameter, and &lt;code&gt;interval&lt;/code&gt; will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; работает по умолчанию с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , или вы можете дополнительно передать другой планировщик в качестве второго параметра, и вместо этого &lt;code&gt;interval&lt;/code&gt; будет работать с этим планировщиком.</target>
        </trans-unit>
        <trans-unit id="45aed2147ce95798c6a80412108c06c33d406eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="396a69205a9eb0971c9c7f55db588708f79c4271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; and &lt;code&gt;groupJoin&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; и &lt;code&gt;groupJoin&lt;/code&gt; находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="0266ff7e3c64a16c14367e7d9c449c8da592883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a69e5a2478476a9c491318f02a1ebcb2c00072d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jortSort&lt;/code&gt; and &lt;code&gt;jortSortUntil&lt;/code&gt; are found in the following distribution:</source>
          <target state="translated">&lt;code&gt;jortSort&lt;/code&gt; и &lt;code&gt;jortSortUntil&lt;/code&gt; находятся в следующем дистрибутиве:</target>
        </trans-unit>
        <trans-unit id="5a9b0c411484d69c52e4c13d11908433ad2a8d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;just&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;just&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34d74f67c03c213281eab1d7970a0f0aa9fb5f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; и &lt;code&gt;lastOrDefault&lt;/code&gt; по умолчанию не работают с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a533c3a569a685efc0f2ff08c697bf6945290e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="a7a36090f51769beb59adcc22b7e8c1ea2e87040" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastOrDefault&lt;/code&gt; also has a variant to which you can pass a predicate function, so that its Observable will emit the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;, or the default item if no items emitted by the source Observable pass the predicate.</source>
          <target state="translated">&lt;code&gt;lastOrDefault&lt;/code&gt; также имеет вариант, которому вы можете передать функцию предиката, так что его Observable будет выдавать последний элемент из исходного Observable, который предикат оценивает как &lt;code&gt;true&lt;/code&gt; , или элемент по умолчанию, если никакие элементы, излучаемые источником Observable, не передают предикат.</target>
        </trans-unit>
        <trans-unit id="7aacfc7731f6c17a90c6eb8a8408b8626b6b4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; internally transforms each item emitted by the source Observable into an Observable that emits that item and all items subsequently emitted by the source Observable, in the same order. So, for example, it internally transforms an Observable that emits the numbers 1,2,3 into three Observables: one that emits 1,2,3, one that emits 2,3, and one that emits 3.</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; внутренне преобразует каждый элемент, излучаемый исходным Observable, в Observable, который излучает этот элемент, и все элементы, впоследствии порождаемые исходным Observable, в том же порядке. Так, например, он внутренне преобразует Observable, который испускает числа 1,2,3, в три Observable: один, который испускает 1,2,3, второй, который испускает 2,3, и один, который испускает 3.</target>
        </trans-unit>
        <trans-unit id="852bf5291fc644db30f6e600aef002fc5fd9aca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; можно найти в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="09057d142824186fbe022f1998c81ae84e72dcae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;manySelect&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;manySelect&lt;/code&gt; требуется один из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="5e1e17116f83269cfcbfba129278c4ac51598937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;select&lt;/code&gt; and &lt;code&gt;pluck&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; / &lt;code&gt;select&lt;/code&gt; и &lt;code&gt;pluck&lt;/code&gt; можно найти в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="c48520b92abdd1b6f13c2e1a944c18d0136643e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; по умолчанию не работает ни с каким конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03109dd70ccd2d5f3ce0b4ab597c88f2b1775f8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;maxBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; и &lt;code&gt;maxBy&lt;/code&gt; находятся в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="177fec1f130af6e4eaca7a4228a28a204b1d0476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxBy&lt;/code&gt; emits a list. If more than one item has the maximum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;maxBy&lt;/code&gt; выдает список. Если более чем один элемент имеет максимальное значение ключа, каждый такой элемент будет представлен в списке.</target>
        </trans-unit>
        <trans-unit id="027592fb8ecb9365d5e058e59e73870c0dd9b14f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge*&lt;/code&gt; converts an Observable that emits Observables into a single Observable that emits all of the items emitted by all of the emitted Observables.</source>
          <target state="translated">&lt;code&gt;merge*&lt;/code&gt; преобразует Observable, который испускает Observables, в один Observable, который испускает все элементы, испускаемые всеми испускаемыми Observable.</target>
        </trans-unit>
        <trans-unit id="d15ed57f77ad2ac1e3613ef0567150f3e1436e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error*&lt;/code&gt; is a similarly-modified version of &lt;code&gt;merge*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge-delay-error*&lt;/code&gt; - это модифицированная аналогично версия &lt;code&gt;merge*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e67f6049e6dc049459c7c289d724002ca5233350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge-delay-error&lt;/code&gt; is like &lt;code&gt;merge&lt;/code&gt;, but will emit all items from all of the merged Observables even if one or more of those Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification while emissions are still pending.</source>
          <target state="translated">&lt;code&gt;merge-delay-error&lt;/code&gt; похожа на &lt;code&gt;merge&lt;/code&gt; , но испускает все элементы из всех объединенных Observables, даже если один или несколько из этих Observables завершаются с уведомлением &lt;code&gt;onError&lt;/code&gt; , пока выбросы еще не завершены.</target>
        </trans-unit>
        <trans-unit id="ee7977d5c910e7ed3bb342e6e05eb0de4027e714" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; converts two or more Observables into a single Observable that emits all of the items emitted by all of those Observables.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; преобразует два или более Observable в один Observable, который испускает все элементы, испускаемые всеми этими Observable.</target>
        </trans-unit>
        <trans-unit id="9b76e9c0a1d27549afef80505e42f88c49ea336f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; merges a second Observable into the one it is operating on to create a new merged Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; объединяет второй Observable с тем, над которым он работает, чтобы создать новый объединенный Observable.</target>
        </trans-unit>
        <trans-unit id="d6eb56447889e6eff2f5548660c3d51a27016c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes a second Observable as a parameter and merges that Observable with the one the &lt;code&gt;merge&lt;/code&gt; operator is applied to in order to create a new output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; принимает второй Observable в качестве параметра и объединяет этот Observable с тем, к которому применяется оператор &lt;code&gt;merge&lt;/code&gt; , чтобы создать новый выходной Observable.</target>
        </trans-unit>
        <trans-unit id="614290ed812f3587868cc3180159ce55ec920f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; takes as its parameter an Observable that emits Observables. It merges the items emitted by each of these Observables to create its own single Observable sequence.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; принимает в качестве параметра Observable, который испускает Observables. Он объединяет элементы, испускаемые каждым из этих Observable, для создания своей собственной единой Observable последовательности.</target>
        </trans-unit>
        <trans-unit id="bf87e244577c5c553ce2ac58ddee944690c8ba13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="0395844b120445f674db48bf21d82e4cc405b67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; is like this second variant of &lt;code&gt;merge&lt;/code&gt; except that it does not allow you to set this maximum subscription count. It only takes the single parameter of an Observable of Observables.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; похож на второй вариант &lt;code&gt;merge&lt;/code&gt; за исключением того, что он не позволяет вам устанавливать максимальное количество подписок. Он принимает только один параметр Observable of Observables.</target>
        </trans-unit>
        <trans-unit id="e97640809c79f9e4649a2564f86200103b701783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; behaves much like &lt;code&gt;merge&lt;/code&gt;. The exception is when one of the Observables being merged terminates with an &lt;code&gt;onError&lt;/code&gt; notification. If this happens with &lt;code&gt;merge&lt;/code&gt;, the merged Observable will immediately issue an &lt;code&gt;onError&lt;/code&gt; notification and terminate. &lt;code&gt;mergeDelayError&lt;/code&gt;, on the other hand, will hold off on reporting the error until it has given any other non-error-producing Observables that it is merging a chance to finish emitting their items, and it will emit those itself, and will only terminate with an &lt;code&gt;onError&lt;/code&gt; notification when all of the other merged Observables have finished.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; во многом похож на &lt;code&gt;merge&lt;/code&gt; . Исключение составляют &lt;code&gt;onError&lt;/code&gt; когда один из объединенных Observables завершается уведомлением onError . Если это произойдет при &lt;code&gt;merge&lt;/code&gt; , объединенный Observable немедленно &lt;code&gt;onError&lt;/code&gt; уведомление onError и завершится. &lt;code&gt;mergeDelayError&lt;/code&gt; , с другой стороны, будет задерживать сообщение об ошибке до тех пор, пока он не предоставит другим наблюдаемым объектам, не вызывающим ошибок, что он объединяет шанс закончить испускание своих элементов, и он сам испустит их, и завершится только с &lt;code&gt;onError&lt;/code&gt; уведомление , когда все другие объединены Наблюдаемые закончили.</target>
        </trans-unit>
        <trans-unit id="a167493a245b87e171e08f6f02fdf1ad8bc9e2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; has fewer variants. You cannot pass it an Iterable or Array of Observables, but you can pass it an Observable that emits Observables or between one and nine individual Observables as parameters. There is not an instance method version of &lt;code&gt;mergeDelayError&lt;/code&gt; as there is for &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; имеет меньше вариантов. Вы не можете передать ему Iterable или Array of Observables, но вы можете передать ему Observable, который испускает Observables или от одного до девяти отдельных Observable в качестве параметров. Не существует версии метода экземпляра &lt;code&gt;mergeDelayError&lt;/code&gt; , как для &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0cfd0dcaa2b00079a42cbbc16dfd8134a7228f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="5df4328bd8b1f65ea0f113efcd6669bdfaa33239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeDelayError&lt;/code&gt; is similar to &lt;code&gt;merge&lt;/code&gt; except that it will always emit all items from both Observables even if one of the Observables terminates with an &lt;code&gt;onError&lt;/code&gt; notification before the other Observable has finished emitting items.</source>
          <target state="translated">&lt;code&gt;mergeDelayError&lt;/code&gt; похож на &lt;code&gt;merge&lt;/code&gt; за исключением того, что он всегда будет генерировать все элементы из обоих Observable, даже если один из Observable завершается с уведомлением &lt;code&gt;onError&lt;/code&gt; до того, как другой Observable завершит выпуск элементов.</target>
        </trans-unit>
        <trans-unit id="b82f40498bf692a5a78433f62179f34c2ce3ab0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; and its alias &lt;code&gt;merge_observable&lt;/code&gt; take as their single parameter an Observable that emits Observables. They merge the emissions of all of these Observables to create their own Observable.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; и его псевдоним &lt;code&gt;merge_observable&lt;/code&gt; принимают в качестве единственного параметра Observable, который испускает Observables. Они объединяют выбросы всех этих Observable, чтобы создать свой собственный Observable.</target>
        </trans-unit>
        <trans-unit id="bf6c5d2e202b7b40759b72a1934f54b5e9a83c2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_all&lt;/code&gt; is like &lt;code&gt;merge_concurrent(1)&lt;/code&gt;. It subscribes to each emitted Observable one at a time, mirroring its emissions as its own, and waiting to subscribe to the next Observable until the present one terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification. In this respect it is more like a Concat variant.</source>
          <target state="translated">&lt;code&gt;merge_all&lt;/code&gt; похож на &lt;code&gt;merge_concurrent(1)&lt;/code&gt; . Он подписывается на каждый отправленный Observable по одному, отражая его выбросы как свои собственные и ожидая подписки на следующий Observable, пока текущий не завершится уведомлением &lt;code&gt;onCompleted&lt;/code&gt; . В этом отношении он больше похож на вариант Concat.</target>
        </trans-unit>
        <trans-unit id="b9b205f7b96cb7796621bb13f277b683df3a9c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_concurrent&lt;/code&gt; operates on an Observable that emits Observables, merging the emissions from each of these Observables into its own emissions. You can optionally pass it an integer parameter indicating how many of these emitted Observables &lt;code&gt;merge_concurrent&lt;/code&gt; should try to subscribe to concurrently. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification. The default is 1, which makes it equivalent to &lt;code&gt;merge_all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge_concurrent&lt;/code&gt; работает с Observable, который испускает Observables, объединяя выбросы от каждого из этих Observable в свои собственные выбросы. При желании вы можете передать ему целочисленный параметр, указывающий, сколько из этих испускаемых Observable &lt;code&gt;merge_concurrent&lt;/code&gt; следует попытаться подписаться одновременно. Как только он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; . По умолчанию 1, что эквивалентно &lt;code&gt;merge_all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd6a4567c47afea1f9ff91a96e2a66d903320fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;minBy&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; и &lt;code&gt;minBy&lt;/code&gt; находятся в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="fe33d78b21d502ce077f3e6214cf1f1e0a7a2b32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minBy&lt;/code&gt; emits a list. If more than one item has the minimum key value, each such item will be represented in the list.</source>
          <target state="translated">&lt;code&gt;minBy&lt;/code&gt; выдает список. Если более чем один элемент имеет минимальное значение ключа, каждый такой элемент будет представлен в списке.</target>
        </trans-unit>
        <trans-unit id="7f478b05a123aaaa05e677793d3fd97a7fc5e6e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="1d1866924109e9670646683e6e6766eb97e7a636" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; можно найти в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="14dc5b4b8485471c8c4af3ad8e073920b5b1958d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;of&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="79a718b7958aac2f3f301ac09717b03f007e843a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ofType&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ofType&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="897f67f71a1a6044cc793578bc84958ce3a7edc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureBuffer&lt;/code&gt; maintains a buffer of all unobserved emissions from the source Observable and emits them to downstream observers according to the requests they generate.</source>
          <target state="translated">&lt;code&gt;onBackpressureBuffer&lt;/code&gt; поддерживает буфер всех ненаблюдаемых излучений от источника Observable и отправляет их нижестоящим наблюдателям в соответствии с запросами, которые они генерируют.</target>
        </trans-unit>
        <trans-unit id="cae0fdf6c6ae888dae1f1dca903ede5835c8e193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureDrop&lt;/code&gt; drops emissions from the source Observable unless there is a pending request from a downstream observer, in which case it will emit enough items to fulfill the request.</source>
          <target state="translated">&lt;code&gt;onBackpressureDrop&lt;/code&gt; отбрасывает выбросы из источника Observable, если нет ожидающего запроса от нижележащего наблюдателя, и в этом случае он будет выдавать достаточно элементов для выполнения запроса.</target>
        </trans-unit>
        <trans-unit id="8dad14f2756c6a7c1c084ae4a7d8630d2936a429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onBackpressureLatest&lt;/code&gt; (new in RxJava 1.1) holds on to the most-recently emitted item from the source Observable and immediately emits that item to its observer upon request. It drops any other items that it observes between requests from its observer.</source>
          <target state="translated">&lt;code&gt;onBackpressureLatest&lt;/code&gt; (новое в RxJava 1.1) удерживает последний отправленный элемент из исходного Observable и немедленно отправляет этот элемент своему наблюдателю по запросу. Он отбрасывает любые другие элементы, которые он наблюдает между запросами от своего наблюдателя.</target>
        </trans-unit>
        <trans-unit id="dcb4b05219c46f2a0b6b1c9f6f952ca7e8293a54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorFlatMap&lt;/code&gt; handles a special case: a source Observable that is noncompliant with &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt; in such a way that it may interleave &lt;code&gt;onError&lt;/code&gt; notifications with its emissions without terminating. This operator allows you to replace those &lt;code&gt;onError&lt;/code&gt; notifications with the emissions of an Observable of your choosing without unsubscribing from the source, so that any future items emitted from the source will be passed along to observers as though the sequence had not been interrupted with an &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;onErrorFlatMap&lt;/code&gt; обрабатывает особый случай: источник Observable, который не &lt;a href=&quot;../contract&quot;&gt;соответствует контракту Observable&lt;/a&gt; таким образом, что он может чередовать уведомления &lt;code&gt;onError&lt;/code&gt; со своими выбросами без завершения работы. Этот оператор позволяет вам заменить эти уведомления &lt;code&gt;onError&lt;/code&gt; выбросами объекта Observable по вашему выбору без отказа от подписки на источник, так что любые будущие элементы, отправленные из источника, будут передаваться наблюдателям, как если бы последовательность не была прервана с помощью &lt;code&gt;onError&lt;/code&gt; уведомление.</target>
        </trans-unit>
        <trans-unit id="2b872759b6ef289a58cf969ce8164979b4a51e72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="95ce8ec757b038f51c2a32661634197b973e09f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; и &lt;code&gt;onError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd7ec9d67ac28a19f77f9e07b0ebd85713ac02e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; и &lt;code&gt;onCompleted&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4196398c53c4e2d07989c689f8952690797af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; находятся в следующих распределениях:</target>
        </trans-unit>
        <trans-unit id="3c770e3f67c8bd25718da8165ccdb6ade967737f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition-all&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;step&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;step&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;n&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (which is the default if you omit the &lt;code&gt;step&lt;/code&gt; parameter) then the window size is the same as the step size and there will be a one-to-one correspondence between the items emitted by the source Observable and the items emitted by the collection of window Observables. If &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; the windows will overlap by &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; items; if &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; the windows will drop &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">&lt;code&gt;partition-all&lt;/code&gt; сразу открывает свое первое окно. Он открывает новое окно, начиная с каждого элемента &lt;code&gt;step&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;step&lt;/code&gt; равен 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно &lt;code&gt;onError&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; элементов или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или onError от источника Observable. Если &lt;code&gt;step&amp;nbsp;=&amp;nbsp;n&lt;/code&gt; (это значение по умолчанию, если вы опускаете параметр &lt;code&gt;step&lt;/code&gt; ), то размер окна такой же, как размер шага, и будет однозначное соответствие между элементами, испускаемыми исходным Observable, и отправляемыми элементами. коллекцией оконных Observables. Если &lt;code&gt;step&amp;nbsp;&amp;lt;&amp;nbsp;n&lt;/code&gt; окна будут перекрываться &lt;code&gt;n&amp;nbsp;&amp;minus;&amp;nbsp;step&lt;/code&gt; элементами; если &lt;code&gt;step&amp;nbsp;&amp;gt;&amp;nbsp;n&lt;/code&gt; окна будут отбрасывать &lt;code&gt;step&amp;nbsp;&amp;minus;&amp;nbsp;n&lt;/code&gt; элементов из источника Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="f84833cea1699df3f9c2492c38f87c6af17d1f1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; не работает по умолчанию с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; , но есть вариант, который позволяет вам установить планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="eafc670c3b2d8e5043fd46a8907dcc34eb1f5b13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="517b7b00820d459d58d54fad2526893d4209d655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operates by default on the &lt;code&gt;currentThread&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but there is a variant that allows you to set the Scheduler by passing one in as the optional third parameter.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;currentThread&lt;/code&gt; , но есть вариант, который позволяет вам установить планировщик, передав один в качестве необязательного третьего параметра.</target>
        </trans-unit>
        <trans-unit id="a05f7cc6a3cc8526b6a38205df25a5634604f34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d54f7eb381b9a648070132276d93e7ee0df8d0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="657f9e448cd627b5f491b7783525a31edf1ce8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; требуется один из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="0129da905d929db4ea918fd5191306e7b396dbfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="4d8010dd75a4a1c1c6ac0ecdc7cdf94b599657a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="0999f08cc9f2ca4d3eeb983282250b4bcab5e4a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeat&lt;/code&gt; работает по умолчанию в &lt;a href=&quot;../scheduler&quot;&gt;планировщике &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; . Существует также вариант, который позволяет вам установить планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="161c846b7dafa9a83956414dd4c228d2f2b26cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeatWhen&lt;/code&gt; operates by default on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. There is also a variant that allows you to set the Scheduler by passing one in as a parameter.</source>
          <target state="translated">&lt;code&gt;repeatWhen&lt;/code&gt; работает по умолчанию в &lt;a href=&quot;../scheduler&quot;&gt;планировщике &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; . Существует также вариант, который позволяет вам установить планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="89b5f2f16447f11ba64e3a948984ca696d80d8a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replay&lt;/code&gt; and &lt;code&gt;shareReplay&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;replay&lt;/code&gt; и &lt;code&gt;shareReplay&lt;/code&gt; находятся в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="c00fe8d32c6838f3365164673884bc9df59b8c18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; по умолчанию работает в &lt;a href=&quot;../scheduler&quot;&gt;планировщике &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76be19f4fc07a54681d48e171bccef56c65fb404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="6cd834c8bce0a7dab20890b38a2731341bb7b199" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single argument, a count of the number of times it should try resubscribing to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; принимает один аргумент - количество попыток повторной подписки на источник Observable при обнаружении ошибок. Если это количество превышено, &lt;code&gt;retry&lt;/code&gt; не будет пытаться повторно &lt;code&gt;onError&lt;/code&gt; а вместо этого передаст своим наблюдателям уведомление onError .</target>
        </trans-unit>
        <trans-unit id="46ac3633b230eaa4da4ae659b81b5fd1fd01a960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; принимает единственный необязательный параметр - количество попыток повторной подписки и зеркального отражения исходного Observable при обнаружении ошибок. Если это количество превышено, &lt;code&gt;retry&lt;/code&gt; не будет пытаться повторно &lt;code&gt;onError&lt;/code&gt; а вместо этого передаст своим наблюдателям уведомление onError .</target>
        </trans-unit>
        <trans-unit id="78968626021de35abce2defdd55ea6bc88f55708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt; takes a single optional parameter, a count of the number of times it should try resubscribing to and mirroring the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe and will instead pass the &lt;code&gt;onError&lt;/code&gt; notification to its observers. If you omit this parameter, &lt;code&gt;retry&lt;/code&gt; will attempt to resubscribe and mirror indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; принимает единственный необязательный параметр - количество попыток повторной подписки и зеркального отражения исходного Observable при обнаружении ошибок. Если это количество превышено, &lt;code&gt;retry&lt;/code&gt; не будет пытаться повторно &lt;code&gt;onError&lt;/code&gt; а вместо этого передаст своим наблюдателям уведомление onError . Если вы опустите этот параметр, &lt;code&gt;retry&lt;/code&gt; будет пытаться повторно подписаться и зеркалировать на неопределенное время, независимо от того, сколько уведомлений &lt;code&gt;onError&lt;/code&gt; он получит.</target>
        </trans-unit>
        <trans-unit id="7e3bb930ea61541d82eaef3c327715478723458b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryInfinitely&lt;/code&gt;, on the other hand, will attempt to resubscribe to and mirror the source Observable indefinitely, no matter how many &lt;code&gt;onError&lt;/code&gt; notifications it receives.</source>
          <target state="translated">&lt;code&gt;retryInfinitely&lt;/code&gt; , с другой стороны, будет пытаться повторно &lt;code&gt;onError&lt;/code&gt; на источник Observable и отражать его на неопределенный срок, независимо от того, сколько уведомлений onError он получает.</target>
        </trans-unit>
        <trans-unit id="eaab55adc8c8a728f1f75c3bb1edfb90ef94d65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retryWhen&lt;/code&gt; by default operates on the &lt;code&gt;trampoline&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, and there is also a version that accepts a Scheduler as a parameter.</source>
          <target state="translated">&lt;code&gt;retryWhen&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;trampoline&lt;/code&gt; , а также существует версия, которая принимает планировщик в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="4120f82ca0762ba3c67980e47fd96b3d4ff4e869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="6865b6419ccb621e514ec4fb6db7f12fbeb36594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;/&lt;code&gt;just&lt;/code&gt; operates by default on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can also pass in a Scheduler of your choosing as an optional second parameter, in which case it will operate on that Scheduler instead.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; / &lt;code&gt;just&lt;/code&gt; работает по умолчанию с &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; , но вы также можете передать планировщик по вашему выбору в качестве дополнительного второго параметра, и в этом случае он будет работать с этим планировщиком.</target>
        </trans-unit>
        <trans-unit id="7b4047a0ea36585603f6ec748627509f0b4a9855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.compat.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.compat.js&lt;/code&gt; (требуется &lt;code&gt;rx.binding.js&lt;/code&gt; и либо &lt;code&gt;rx.js&lt;/code&gt; , либо &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="99d0dd6df299ad0b8c56978d03652785c9ad339a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.async.js&lt;/code&gt; (requires &lt;code&gt;rx.binding.js&lt;/code&gt; and either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.async.js&lt;/code&gt; (требуется &lt;code&gt;rx.binding.js&lt;/code&gt; и либо &lt;code&gt;rx.js&lt;/code&gt; , либо &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="39644825f66c15f5ee185ab93766411f09e927f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (требуется &lt;code&gt;rx.js&lt;/code&gt; или &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a93ed12dffc1802ecae7f2aae2ec6a8f70ebd5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (требуется &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; или &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8b53d4d110e21e5825ad980e2a5e7cb13d935856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (требуется либо &lt;code&gt;rx.js&lt;/code&gt; , либо &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="be2cc3de70d097deb29bf9d0c5b850ca4930bbc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.binding.js&lt;/code&gt; (requires either &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.binding.js&lt;/code&gt; (требуется либо &lt;code&gt;rx.lite.js&lt;/code&gt; , либо &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2357fcc02566cafce52d99070b5f15ba04fcac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; (требуется &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; или &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b80c6ea09cb52e61d700bbdb778801b2438d5986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.experimental.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt;, &lt;code&gt;rx.compat.js&lt;/code&gt;, &lt;code&gt;rx.lite.js&lt;/code&gt;, or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.experimental.js&lt;/code&gt; (требуется либо &lt;code&gt;rx.js&lt;/code&gt; , &lt;code&gt;rx.compat.js&lt;/code&gt; , &lt;code&gt;rx.lite.js&lt;/code&gt; , либо &lt;code&gt;rx.lite.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6cc8c4efacdb08ca9c78c34c4d28e124e3430c88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; (требуется &lt;code&gt;rx.js&lt;/code&gt; или &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9e6345f31b107cb0269a8802101482908e912220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; (requires either &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; (требуется либо &lt;code&gt;rx.js&lt;/code&gt; , либо &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0a2f74b508eb1599da60aa8c859b12c78401a19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.time.js&lt;/code&gt; requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rx.time.js&lt;/code&gt; требует &lt;code&gt;rx.js&lt;/code&gt; или &lt;code&gt;rx.compat.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55ebf3cb3c682607b13423bb830edbe481a23fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rx.timejs&lt;/code&gt; (requires &lt;code&gt;rx.js&lt;/code&gt; or &lt;code&gt;rx.compat.js&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;rx.timejs&lt;/code&gt; (требуется &lt;code&gt;rx.js&lt;/code&gt; или &lt;code&gt;rx.compat.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="fc4cf9e648d81d20eae0105dc67ee6d7971f1afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample&lt;/code&gt; and &lt;code&gt;throttleFirst&lt;/code&gt; operate by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;. They are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sample&lt;/code&gt; и &lt;code&gt;throttleFirst&lt;/code&gt; по умолчанию работают с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; . Они находятся в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="9642d89ad52f3aff730c9fe3b50d35f97e92dedf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scan&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;scan&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="becbe9059426bc4fdaba799ee68f66c3ae0ff3d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; встречается в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="5d1811fd6d4b8cc5e673ff4d9dd6085e1bd30090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; требует одного из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="b8c4ac4b83afedf5680116e88c507a16fc48b2f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; and &lt;code&gt;shareValue&lt;/code&gt; are found in the following distributions:</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; и &lt;code&gt;shareValue&lt;/code&gt; находятся в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="a461966af16fa4245c4bf73e1a8c7b411d6636cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and emits the sole item emitted by the source Observable that matches that predicate, or notifies of an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; также имеет версию, которая принимает предикат и испускает единственный элемент, излучаемый источником Observable, который соответствует этому предикату, или уведомляет об исключении, если ровно один такой элемент не соответствует.</target>
        </trans-unit>
        <trans-unit id="bb3c85771d4d9bde7a35c9a62319373f3d8d96cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;single&lt;/code&gt; also has a version that accepts a predicate, and returns the sole item emitted by the source Observable that matches that predicate, or throws an exception if exactly one such item does not match.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; также имеет версию, которая принимает предикат и возвращает единственный элемент, излучаемый источником Observable, который соответствует этому предикату, или выдает исключение, если точно один такой элемент не соответствует.</target>
        </trans-unit>
        <trans-unit id="d6b89edd7f0936e1694c251ce2e83ac36b9534cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skip&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="7842b740b14a1bb4f092eb32d23be6838b6de48c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="fd24cf6d6309824f9efd2307264bd0c82d87abd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional second parameter.</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного второго параметра.</target>
        </trans-unit>
        <trans-unit id="1b0ea964517cee199a2e9698d0f8b9b282d1a2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipLastWithTime&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="f855d9577dee628df260ad5b16cd6e2f479e252e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0efb342bef695a8ba90ab5c3a186c1d1e80d96db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntil&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="0054a1a7c41a519ebdff4961eb2a9c6387f209df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipUntilWithTime&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="aedae37e764a8cae3228eb19bf3866cfec747304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d271030a25e4748daf89de63d1f23c0bf647fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;skipWhile&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="59d8fb08b646ff0db07c057e6b35171eb8becd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6b6f01fe681143dafffd2ce2f286570c01a2fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="340607a150f05545c373687c169c0693f97e838b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; creates a new buffer starting with the first emitted item from the source Observable, and every &lt;code&gt;skip&lt;/code&gt; items thereafter, and fills each buffer with &lt;code&gt;count&lt;/code&gt; items: the initial item and &lt;code&gt;count-1&lt;/code&gt; subsequent ones. It emits these buffers as &lt;code&gt;Seq&lt;/code&gt;s. Depending on the values of &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;skip&lt;/code&gt; these buffers may overlap (multiple buffers may contain the same item), or they may have gaps (where items emitted by the source Observable are not represented in any buffer).</source>
          <target state="translated">&lt;code&gt;slidingBuffer(count, skip)&lt;/code&gt; создает новый буфер, начиная с первого отправленного элемента из исходного Observable, и каждого &lt;code&gt;skip&lt;/code&gt; элемента после этого, и заполняет каждый буфер элементами &lt;code&gt;count&lt;/code&gt; : начальный элемент и последующие &lt;code&gt;count-1&lt;/code&gt; . Он передает эти буферы как &lt;code&gt;Seq&lt;/code&gt; s. В зависимости от значений &lt;code&gt;count&lt;/code&gt; и &lt;code&gt;skip&lt;/code&gt; эти буферы могут перекрываться (несколько буферов могут содержать один и тот же элемент) или они могут иметь пробелы (где элементы, выдаваемые исходным Observable, не представлены ни в каком буфере).</target>
        </trans-unit>
        <trans-unit id="e800efd9702220c22509e95b689d97ed23b2e491" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; monitors the &lt;code&gt;openings&lt;/code&gt; Observable, and, whenever it emits an &lt;code&gt;Opening&lt;/code&gt; item, &lt;code&gt;slidingBuffer&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt;, begins to collect items subsequently emitted by the source Observable into this buffer, and calls &lt;code&gt;closings&lt;/code&gt; to get a new Observable to govern the closing of that buffer. When this new Observable emits an item or terminates, &lt;code&gt;slidingBuffer&lt;/code&gt; closes and emits the &lt;code&gt;Seq&lt;/code&gt;that the Observable governs.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(openings,closings)&lt;/code&gt; контролирует &lt;code&gt;openings&lt;/code&gt; Observable, и всякий раз, когда он испускает элемент &lt;code&gt;Opening&lt;/code&gt; , &lt;code&gt;slidingBuffer&lt;/code&gt; создает новый &lt;code&gt;Seq&lt;/code&gt; , начинает собирать элементы, впоследствии отправленные источником Observable в этот буфер, и вызывает &lt;code&gt;closings&lt;/code&gt; чтобы получить новый Observable для управления закрытие этого буфера. Когда этот новый Observable испускает элемент или завершается, &lt;code&gt;slidingBuffer&lt;/code&gt; закрывается и выдает &lt;code&gt;Seq&lt;/code&gt; , которым управляет Observable.</target>
        </trans-unit>
        <trans-unit id="3a2d8b32d98cd2d85f509ed919d5b6fe0c839176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; creates a new &lt;code&gt;Seq&lt;/code&gt; of items every &lt;code&gt;timeshift&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), and fills this buffer with every item emitted by the source Observable from that time until &lt;code&gt;timespan&lt;/code&gt; (also a &lt;code&gt;Duration&lt;/code&gt;) has passed since the buffer&amp;rsquo;s creation, before emitting this &lt;code&gt;Seq&lt;/code&gt; as its own emission. If &lt;code&gt;timespan&lt;/code&gt; is longer than &lt;code&gt;timeshift&lt;/code&gt;, the emitted arrays will represent time periods that overlap and so they may contain duplicate items. There is also a version of this variant of the operator that takes a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; as a parameter and uses it to govern the timespan.</source>
          <target state="translated">&lt;code&gt;slidingBuffer(timespan, timeshift)&lt;/code&gt; создает новый &lt;code&gt;Seq&lt;/code&gt; предметов , каждый &lt;code&gt;timeshift&lt;/code&gt; (а &lt;code&gt;Duration&lt;/code&gt; ), и заполняет этот буфер с каждым пунктом , испускаемого источником наблюдаемого с того времени , пока &lt;code&gt;timespan&lt;/code&gt; (также &lt;code&gt;Duration&lt;/code&gt; ) не прошло с момента создания буфера, перед испусканием этот &lt;code&gt;Seq&lt;/code&gt; как его собственная эмиссия. Если &lt;code&gt;timeshift&lt;/code&gt; &lt;code&gt;timespan&lt;/code&gt; больше, чем временной сдвиг , генерируемые массивы будут представлять периоды времени, которые перекрываются, и поэтому они могут содержать повторяющиеся элементы. Существует также версия этого варианта оператора, который принимает &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; в качестве параметра и использует его для управления временным интервалом.</target>
        </trans-unit>
        <trans-unit id="24dd0a01354cced0a2acf0aa8063d70ee7f154a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="ed91665030b67875ffc98a470567ddb8eb0537e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startAsync&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="7557812c5d12bce96afff2c6f2acef59e4f6bf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startWith&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;startWith&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="21a9ba7e0e5a1992b4c0bbcf9fa451a208dde737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribeOn&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;subscribeOn&lt;/code&gt; можно найти в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="e82eb96c199934418a5718cf08684f1241d7a926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sum&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;sum&lt;/code&gt; находится в следующих распределениях:</target>
        </trans-unit>
        <trans-unit id="d70375bcfc9c823861ed0e18d51cf92d8acf08eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="7b1afa68f56894c76f703ac9f3769b28164434fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; можно найти в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="7a4525d7b7fbc759ff9dd8eb06674f4280a9073b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="2941ac03f0842c43596c3b89634f04257ea7c68b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; also has its duration-based variant, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt;, which is similar to &lt;code&gt;takeLastWithTime&lt;/code&gt; except that it emits its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; также имеет свой вариант, основанный на продолжительности, &lt;code&gt;takeLastBufferWithTime&lt;/code&gt; , который похож на &lt;code&gt;takeLastWithTime&lt;/code&gt; , за исключением того, что он испускает свои элементы не индивидуально, а собирает их в единый массив элементов, который выдается как единый элемент.</target>
        </trans-unit>
        <trans-unit id="fc5a21060536e4921b09043d6957f61a67e85859" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBuffer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBuffer&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="d02450ab9c999ca1cdd1497e8d7bf3269e1ad1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastBufferWithTime&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="b665df985a737dfb05ba93333df8ea966170a9ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; by default operates the timer on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; and emits items on the &lt;code&gt;currentThread&lt;/code&gt; Scheduler, but you may also pass in Schedulers of your choosing to override these, as an optional second and third parameters, respectively.</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; по умолчанию управляет таймером в &lt;a href=&quot;../scheduler&quot;&gt;планировщике &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; и генерирует элементы в планировщике &lt;code&gt;currentThread&lt;/code&gt; , но вы также можете передать планировщики по своему выбору, чтобы переопределить их, как необязательные второй и третий параметры, соответственно.</target>
        </trans-unit>
        <trans-unit id="14da141683decf3ce03f63343d83fd24c709bfb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLastWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeLastWithTime&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="c20c87a0557376049c73e16b9f4ff3c38215594a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37d6c84288e3575f42359e8018cdff6b7b45d977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="9042095065b7d2b25a7d1e092da6338622f2d9fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntilWithTime&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeUntilWithTime&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="eb79aed0b0d7386fc7de8e365183d8e2e8e7ca97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df06abff8c84fc5b0f1f4a67410984a32d92db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="8a8ebe39bb4a1d479f5ac26c962f779363985e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleFirst&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">&lt;code&gt;throttleFirst&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете дополнительно передать планировщик по вашему выбору в качестве третьего параметра.</target>
        </trans-unit>
        <trans-unit id="e58e7fab93ffb2601599bf75a4c5989ad7f8b9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="12fb397d3568ae4d036414110394066d39b1ed4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; по умолчанию работает с &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; , но также имеет вариант, который позволяет вам указать планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="757c130c5ec90e41b55716e7d8ceb364f6a8e288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , но также имеет вариант, который позволяет указать планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="71b3b52092b0ce3ee3f4d96c9a24a943c2d938d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeInterval&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeInterval&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="7b213b55f226a478725826835dafe9681d5f8644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;timeoutWithSelector&lt;/code&gt; are found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; и &lt;code&gt;timeoutWithSelector&lt;/code&gt; находятся в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="1ce975a53ac15047ca82f47b9d9d146a0d85da69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWithSelector&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;Error: Timeout&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;timeoutWithSelector&lt;/code&gt; не использует постоянную продолжительность тайм-аута, но устанавливает его длительность тайм-аута для каждого элемента, передавая каждый элемент из исходного Observable в функцию, которая возвращает Observable, а затем отслеживает эти Observable. Если любой такой Observable завершается до того, как исходный Observable испускает другой элемент, это считается условием тайм-аута и запускает уведомление &lt;code&gt;onError&lt;/code&gt; (&amp;laquo; &lt;code&gt;Error: Timeout&lt;/code&gt; &amp;raquo;) из Observable &lt;code&gt;timeoutWithSelector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73773bfa5b563e9eba5535983817af426985e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , или вы можете переопределить это, передав Планировщик в качестве последнего параметра.</target>
        </trans-unit>
        <trans-unit id="2cbc3a49fd6d590f7657eb64c4bf3aee582bf2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, or you can override this by passing in a Scheduler as a final parameter.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; По умолчанию таймер работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , или вы можете изменить это, передав Планировщик в качестве последнего параметра.</target>
        </trans-unit>
        <trans-unit id="166b0d0c1925597895a20348e99d636f269ba52f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="a6994ab170fc57b3c6ae8b13a3eb78514353eada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single number zero after a delay period you specify.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; возвращает Observable, который выдает одно число ноль после указанного вами периода задержки.</target>
        </trans-unit>
        <trans-unit id="9d152bee231bbb8e03f92f397a5f47c8bc06dd80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; but also has a variant that allows you to choose the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; по умолчанию работает с &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщиком,&lt;/a&gt; но также имеет вариант, который позволяет вам выбрать планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="5c4b64c965f491d895a7583ac5fd6181c6b636c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; by default operates on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but also has a variant that allows you to specify the Scheduler by passing it in as a parameter.</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , но также имеет вариант, который позволяет указать планировщик, передав его в качестве параметра.</target>
        </trans-unit>
        <trans-unit id="44cd8475782d97de9ca5e1e58e9b309ed7b54305" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; находится в каждом из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="51c19fb0c2dc91fdd7ff204e2e2b3dde5ed1cea6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="f2436f143a44933d4ae386a7d36228fa95d3b9e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toAsync&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">&lt;code&gt;toAsync&lt;/code&gt; находится в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="7bf929490433a6f89a9386a35013a74f1cafb6c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toList&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480dfc94c15fb8040d8e100d3fa4d5194e955fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c39b03d1c2b125af83fb8e2d096e30c15ec785" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMap&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toMap&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="ac9c9dc84a67060553324ea4b1a5883b58175151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toMultiMap&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toMultiMap&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea2ad74dcc9fb9b4b1703685d68edf066c0841f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSet&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;toSet&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="ec7965f3d811250e08e8d9ceb0744100f593b518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toSortedList&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;toSortedList&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46584cfb17a9dfd026e64a70ece0028c2345433e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="946b7fdda870bee85c6810d8f4b8baea15808387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tumbling(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114b0ca34209466be8813d092973923f1b9b4190" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; monitors an Observable, &lt;code&gt;boundary&lt;/code&gt;. Each time that Observable emits an item, it creates a new &lt;code&gt;Seq&lt;/code&gt; to begin collecting items emitted by the source Observable and emits the previous &lt;code&gt;Seq&lt;/code&gt;. This variant of the operator has an optional second parameter, &lt;code&gt;initialCapacity&lt;/code&gt; with which you can indicate the expected size of these buffers so as to make memory allocation more efficient.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(boundary)&lt;/code&gt; отслеживает наблюдаемую &lt;code&gt;boundary&lt;/code&gt; . Каждый раз, когда Observable испускает элемент, он создает новый &lt;code&gt;Seq&lt;/code&gt; , чтобы начать сбор элементов, выпущенных источником Observable, и испускает предыдущий &lt;code&gt;Seq&lt;/code&gt; . Этот вариант оператора имеет необязательный второй параметр &lt;code&gt;initialCapacity&lt;/code&gt; , с помощью которого вы можете указать ожидаемый размер этих буферов, чтобы сделать распределение памяти более эффективным.</target>
        </trans-unit>
        <trans-unit id="d46125dcac2cbaa797114df6c032348ed56b10dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; emits non-overlapping buffers in the form of &lt;code&gt;Seq&lt;/code&gt;s, each of which contains at most &lt;code&gt;count&lt;/code&gt; items from the source Observable (the final emitted buffer may have fewer than &lt;code&gt;count&lt;/code&gt; items).</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(count)&lt;/code&gt; испускает неперекрывающиеся буферы в форме &lt;code&gt;Seq&lt;/code&gt; s, каждый из которых содержит не более &lt;code&gt;count&lt;/code&gt; элементов из исходного Observable (последний переданный буфер может иметь меньше, чем &lt;code&gt;count&lt;/code&gt; элементов).</target>
        </trans-unit>
        <trans-unit id="bfd1e55878e9963160e69e3e46fbcc3ba5b0c630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items periodically, every &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;), containing all items emitted by the source Observable since the previous bundle emission or, in the case of the first bundle, since the subscription to the source Observable. This variant of the operator has an optional second parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan)&lt;/code&gt; испускает новый &lt;code&gt;Seq&lt;/code&gt; элементов периодически, каждый &lt;code&gt;timespan&lt;/code&gt; (а &lt;code&gt;Duration&lt;/code&gt; ), содержащий все элементы , излучаемые источник наблюдаемого после предыдущей эмиссии пучка или, в случае первого пучка, с момента подписки на источник наблюдаем. Этот вариант оператора имеет необязательный второй параметр, &lt;code&gt;scheduler&lt;/code&gt; , с помощью которого вы можете установить &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; который вы хотите управлять расчетом временного интервала.</target>
        </trans-unit>
        <trans-unit id="b21cd4f65fc506789ef4e59831405d1e22f95404" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; emits a new &lt;code&gt;Seq&lt;/code&gt; of items for every &lt;code&gt;count&lt;/code&gt; items emitted by the source Observable, or, if &lt;code&gt;timespan&lt;/code&gt; (a &lt;code&gt;Duration&lt;/code&gt;) has elapsed since its last bundle emission, it emits a &lt;code&gt;Seq&lt;/code&gt; containing however many items the source Observable emitted in that span, even if this is fewer than &lt;code&gt;count&lt;/code&gt;. This variant of the operator has an optional third parameter, &lt;code&gt;scheduler&lt;/code&gt;, with which you can set the &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; that you want to govern the timespan calculation.</source>
          <target state="translated">&lt;code&gt;tumblingBuffer(timespan, count)&lt;/code&gt; испускает новый &lt;code&gt;Seq&lt;/code&gt; элементов для каждого элемента &lt;code&gt;count&lt;/code&gt; , испускаемого исходным Observable, или, если &lt;code&gt;timespan&lt;/code&gt; ( &lt;code&gt;Duration&lt;/code&gt; ) истек с момента его последнего выпуска пакета, он испускает &lt;code&gt;Seq&lt;/code&gt; , содержащий столько элементов, сколько отправил исходный Observable в этом промежутке, даже если это меньше, чем &lt;code&gt;count&lt;/code&gt; . Этот вариант оператора имеет необязательный третий параметр, &lt;code&gt;scheduler&lt;/code&gt; , с помощью которого вы можете установить &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; который вы хотите управлять расчетом временного интервала.</target>
        </trans-unit>
        <trans-unit id="3dbb96ec506e9ea7b859c90a031a511f04f5a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67fe99075e97e899a8a29e4d7d6bbf8bc6656d37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is found in each of the following distributions:</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; находится в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="9180af64681c5e6bbe87c5747504627d06e37279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; is found in the &lt;code&gt;rx.experimental.js&lt;/code&gt; distribution. It requires one of the following distributions:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; находится в дистрибутиве &lt;code&gt;rx.experimental.js&lt;/code&gt; . Требуется один из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="33cff6c004ac3784284d1aafacb977d88056d9a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, timeshift, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa5feef256593decbc4e3c0668b5c74c2b7542ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit, count&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit, count&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88858274463fe4c29e450ff892be4ab3cdd04ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window(timespan, unit&lt;/code&gt;[&lt;code&gt;, scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window(timespan, unit&lt;/code&gt; [ &lt;code&gt;, scheduler&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8df2411d37d8d9a19673d8cc2fca09e073fe8588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan,timeShift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0082a3e53e214cc5277d43c253721adf6ffebe46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTime(timeSpan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afd4e92b2e4ccb74b8e4469f1bd7c11303336a25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount(timeSpan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ba9f5753ce09bb018d7eea164bf09706e308337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;windowWithTimeOrCount&lt;/code&gt; немедленно открывает свое первое окно. Он закрывает открытое окно и открывает еще один раз &lt;code&gt;timespan&lt;/code&gt; миллисекунды (измеренные при необходимости на определенный &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; ) или всякий раз , когда в настоящее время открытого окна имеет излучаемый &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует таковым из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="fd00380205a686ee17604d17356c523c0e72c3a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period, skip&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period, skip&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5db0580b8d43ac68544b774f2554c7d3ba35e259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(period&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(period&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82e83f25479adacc961806d24bc915b042ddee0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan,timeshift&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fee332926b0d48f2889ec46f5f950b3c4e76d18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time(timespan&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d3d2c45562db6fe6c52b9d1508809b4531e5ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt;[&lt;code&gt;, coordination&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(period, count&lt;/code&gt; [ &lt;code&gt;, coordination&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f76e50530b051a16903cb3a749bbf3d0ebcbc93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count(timespan,count&lt;/code&gt;[&lt;code&gt;,scheduler&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="641566bee8a202a27ae03c144854e648d69bf89d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (optionally computed by a given Coordination) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; немедленно открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;period&lt;/code&gt; времени (необязательно вычисляемый заданной Координацией) или всякий раз, когда открытое в настоящее время окно выдало &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует исходному Observable.</target>
        </trans-unit>
        <trans-unit id="58c4c18c7ec6364acc53cb5fe05e73f534b19a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window_with_time_or_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">&lt;code&gt;window_with_time_or_count&lt;/code&gt; немедленно открывает свое первое окно. Он закрывает открытое окно и открывает еще один раз &lt;code&gt;timespan&lt;/code&gt; миллисекунды (измеренные при необходимости на определенный &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; ) или всякий раз , когда в настоящее время открытого окна имеет излучаемый &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. &lt;code&gt;window_with_time_or_count&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует исходному Observable.</target>
        </trans-unit>
        <trans-unit id="dc83188733343337e00c5f1f317f3281f7cb8498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; accepts a variable number of Observables or Promises as parameters, followed by a function that accepts one item emitted by each of those Observables or resolved by those Promises as input and produces a single item to be emitted by the resulting Observable.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; принимает переменное количество Observables или Promises в качестве параметров, за которыми следует функция, которая принимает один элемент, выдаваемый каждым из этих Observable или разрешенный этими обещаниями, в качестве входных данных и создает один элемент, который будет выдан результирующим Observable.</target>
        </trans-unit>
        <trans-unit id="36e1debe572209b748af04eb0b1aaf0617354592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;zipWith&lt;/code&gt; do not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; и &lt;code&gt;zipWith&lt;/code&gt; по умолчанию не работают с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4541e5aef8fc275a2be0435a981bbc433ea604d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zipArray&lt;/code&gt; accepts a variable number of Observables as parameters and returns an Observable that emits arrays, each one containing the</source>
          <target state="translated">&lt;code&gt;zipArray&lt;/code&gt; принимает переменное количество Observable в качестве параметров и возвращает Observable, который генерирует массивы, каждый из которых содержит</target>
        </trans-unit>
        <trans-unit id="73c6161ea024bd469cc2d9d1691023d9244d7b73" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item from each source Observable.</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; элемент из каждого источника Observable.</target>
        </trans-unit>
        <trans-unit id="2e3866d4dc2075c3f5d0d914e8fb5c6c5cf655d6" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;th&lt;/sup&gt; item that it expected.</source>
          <target state="translated">&lt;sup&gt;th&lt;/sup&gt; элемент, который он ожидал.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="5a9ea636768e98730048d960cb7b94ce27c67345" translate="yes" xml:space="preserve">
          <source>A Decision Tree of Observable Operators</source>
          <target state="translated">Дерево решений наблюдаемых операторов</target>
        </trans-unit>
        <trans-unit id="2b08c72f6a37159d94745e3d486d34e86abda5ad" translate="yes" xml:space="preserve">
          <source>A Single is something like an Observable, but instead of emitting a series of values &amp;mdash; anywhere from none at all to an infinite number &amp;mdash; it always either emits one value or an error notification.</source>
          <target state="translated">Single - это что-то вроде Observable, но вместо того, чтобы испускать серию значений - от нуля до бесконечного числа - он всегда выдает одно значение или уведомление об ошибке.</target>
        </trans-unit>
        <trans-unit id="ab0a565fcadf77db3f8a879c0832ebb221aa9780" translate="yes" xml:space="preserve">
          <source>A Single will call only one of these methods, and will only call it once. Upon calling either method, the Single terminates and the subscription to it ends.</source>
          <target state="translated">Одиночный вызовет только один из этих методов,и вызовет его только один раз.При вызове любого из этих методов сингл прекращает свое существование,и подписка на него прекращается.</target>
        </trans-unit>
        <trans-unit id="59605fccb31cb127c02c09296155efa5fe013b9c" translate="yes" xml:space="preserve">
          <source>A Subject is a sort of bridge or proxy that is available in some implementations of ReactiveX that acts both as an observer and as an Observable. Because it is an observer, it can subscribe to one or more Observables, and because it is an Observable, it can pass through the items it observes by reemitting them, and it can also emit new items.</source>
          <target state="translated">Субъект-это своего рода мост или прокси-сервер,доступный в некоторых реализациях ReactiveX,который действует и как наблюдатель,и как наблюдаемый.Так как он является наблюдателем,он может подписаться на один или несколько Наблюдателей,а так как он является Наблюдателем,он может пропускать наблюдаемые элементы,повторяя их,а также может испускать новые элементы.</target>
        </trans-unit>
        <trans-unit id="e5115867d3f9ec7f7973522f38b1446136baf293" translate="yes" xml:space="preserve">
          <source>A chain of Observable operators do not operate independently on the original Observable that originates the chain, but they operate &lt;em&gt;in turn&lt;/em&gt;, each one operating on the Observable generated by the operator immediately previous in the chain.</source>
          <target state="translated">Цепочка операторов Observable не работает независимо с исходным Observable, который порождает цепочку, но они работают &lt;em&gt;по очереди&lt;/em&gt; , каждый из которых работает с Observable, созданным оператором, непосредственно предшествующим в цепочке.</target>
        </trans-unit>
        <trans-unit id="4aa1692172bf25b6129069ba0c0eaa218eb4bcab" translate="yes" xml:space="preserve">
          <source>A more complete &lt;code&gt;subscribe&lt;/code&gt; call example looks like this:</source>
          <target state="translated">Более полный пример вызова &lt;code&gt;subscribe&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="e0af329e9352bf7003c7730a1fbf549f05c11689" translate="yes" xml:space="preserve">
          <source>A related operator, IsEmpty returns an Observable that emits &lt;code&gt;true&lt;/code&gt; if and only if the source Observable completes without emitting any items. It emits &lt;code&gt;false&lt;/code&gt; if the source Observable emits an item.</source>
          <target state="translated">Связанный оператор IsEmpty возвращает Observable, который генерирует &lt;code&gt;true&lt;/code&gt; тогда и только тогда, когда исходный Observable завершается без выдачи каких-либо элементов. Он выдает &lt;code&gt;false&lt;/code&gt; , если источник Observable испускает элемент.</target>
        </trans-unit>
        <trans-unit id="3bd6fdbcf4ffd98efa9870facaa7222cee24194a" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the &lt;code&gt;windowed(&lt;/code&gt;</source>
          <target state="translated">Вторая возможность - использовать &lt;code&gt;windowed(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="470bb39ca8f873b411a9bf2795442d8e2de5abb2" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;forkJoin&lt;/code&gt; exists as a prototype function, and you call it on an instance of one source Observable, passing it another source Observable as a parameter. As a second parameter, you pass it a function that combines the final item emitted by the two source Observables into the sole item to be emitted by the resulting Observable.</source>
          <target state="translated">Второй вариант &lt;code&gt;forkJoin&lt;/code&gt; существует как функция-прототип, и вы вызываете его в экземпляре одного источника Observable, передавая ему другой источник Observable в качестве параметра. В качестве второго параметра вы передаете ему функцию, которая объединяет последний элемент, излучаемый двумя исходными Observable, в единственный элемент, который будет выдан результирующим Observable.</target>
        </trans-unit>
        <trans-unit id="80636dd32da61a598e55857994e632bbd4be9e7d" translate="yes" xml:space="preserve">
          <source>A second variant of &lt;code&gt;timeout&lt;/code&gt; differs from the first in that instead of issuing an error notification in case of a timeout condition, it instead immediately switches to a backup Observable that you specify.</source>
          <target state="translated">Второй вариант &lt;code&gt;timeout&lt;/code&gt; отличается от первого тем, что вместо выдачи уведомления об ошибке в случае тайм-аута он немедленно переключается на указанную вами резервную копию Observable.</target>
        </trans-unit>
        <trans-unit id="1014e078d9399bc4430b8c0f57f75f79b89ad343" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxGroovy 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">Вторая версия этого оператора была выпущена в RxGroovy 1.1. Он использует функцию предиката, которая оценивает элементы, испускаемые исходным Observable, а не вторым Observable, чтобы завершить результирующую последовательность Observable. Таким образом, он ведет себя аналогично &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a7d4a46c5c7bc15a9d7db1fc1edb5b764d3a73" translate="yes" xml:space="preserve">
          <source>A second version of this operator was released in RxJava 1.1. It uses a predicate function that evaluates the items emitted by the source Observable, rather than a second Observable, to terminate the resulting Observable sequence. In this way, it behaves in a similar way to &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt;.</source>
          <target state="translated">Вторая версия этого оператора была выпущена в RxJava 1.1. Он использует функцию предиката, которая оценивает элементы, испускаемые исходным Observable, а не вторым Observable, чтобы завершить результирующую последовательность Observable. Таким образом, он ведет себя аналогично &lt;a href=&quot;takewhile&quot;&gt;TakeWhile&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc9c3e84a8e5b9e18d52bf83f76d74a848d15d8" translate="yes" xml:space="preserve">
          <source>A similar operator is &lt;code&gt;ofObjectChanges&lt;/code&gt;. It returns an Observable that emits any changes made to a particular object, as reported by its &lt;code&gt;Object.observe&lt;/code&gt; method. It is also found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">Аналогичный оператор - &lt;code&gt;ofObjectChanges&lt;/code&gt; . Он возвращает Observable, который испускает любые изменения, внесенные в конкретный объект, как сообщает его метод &lt;code&gt;Object.observe&lt;/code&gt; . Он также встречается только в дистрибутиве &lt;code&gt;rx.all.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d9b3babb124228b9672822ea408e026abe9f755" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Int count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Третий вариант &lt;code&gt;retry&lt;/code&gt; принимает в качестве параметра функцию-предикат. Вы пишете эту функцию так, чтобы она принимала два аргумента: счетчик Int, указывающий, сколько попыток было выполнено до сих пор, и Throwable, указывающий на ошибку, которая вызвала уведомление &lt;code&gt;onError&lt;/code&gt; . Эта функция возвращает логическое значение, чтобы указать, следует ли &lt;code&gt;retry&lt;/code&gt; подписки и отражать исходный Observable. Если этого не произойдет , то &lt;code&gt;retry&lt;/code&gt; проходит последнее &lt;code&gt;onError&lt;/code&gt; уведомления своих наблюдателей.</target>
        </trans-unit>
        <trans-unit id="c9c9ea5b2183ed2e503c70773c2a45edce947b6d" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;retry&lt;/code&gt; takes a predicate function as a parameter. You write this function to accept two arguments: an Integer count of how many retries have taken place thusfar, and a Throwable indicating the error that caused the &lt;code&gt;onError&lt;/code&gt; notification. This function returns a Boolean to indicate whether or not &lt;code&gt;retry&lt;/code&gt; should resubscribe to and mirror the source Observable. If it does not, then &lt;code&gt;retry&lt;/code&gt; passes the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Третий вариант &lt;code&gt;retry&lt;/code&gt; принимает в качестве параметра функцию-предикат. Вы пишете эту функцию, чтобы принимать два аргумента: целочисленное количество повторных попыток, имевших место до этого момента, и Throwable, указывающий на ошибку, &lt;code&gt;onError&lt;/code&gt; уведомление onError . Эта функция возвращает логическое значение, чтобы указать, следует ли &lt;code&gt;retry&lt;/code&gt; подписки и отражать исходный Observable. Если этого не произойдет , то &lt;code&gt;retry&lt;/code&gt; проходит последнее &lt;code&gt;onError&lt;/code&gt; уведомления своих наблюдателей.</target>
        </trans-unit>
        <trans-unit id="59dc0040b390fb0df014aee4d31dbc580181dd4c" translate="yes" xml:space="preserve">
          <source>A third variant of &lt;code&gt;timeout&lt;/code&gt; does not use a constant timeout duration, but sets its timeout duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. If any such Observable completes before the source Observable emits another item, this is considered a timeout condition, and triggers an &lt;code&gt;onError&lt;/code&gt; notification (&amp;ldquo;&lt;code&gt;TimeoutException&lt;/code&gt;&amp;rdquo;) from the Observable &lt;code&gt;timeout&lt;/code&gt; returns.</source>
          <target state="translated">Третий вариант &lt;code&gt;timeout&lt;/code&gt; не использует постоянную продолжительность тайм-аута, но устанавливает его длительность тайм-аута для каждого элемента, передавая каждый элемент из исходного Observable в функцию, которая возвращает Observable, а затем отслеживает эти Observable. Если любой из таких Observable завершается до того, как исходный Observable испускает другой элемент, это считается условием тайм-аута и запускает уведомление &lt;code&gt;onError&lt;/code&gt; (&amp;laquo; &lt;code&gt;TimeoutException&lt;/code&gt; &amp;raquo;) из возвращаемого &lt;code&gt;timeout&lt;/code&gt; Observable .</target>
        </trans-unit>
        <trans-unit id="e63b86ec2cc6e89e587945cf3c2a65042288e202" translate="yes" xml:space="preserve">
          <source>A toolbox of useful Operators for working with Observables</source>
          <target state="translated">Инструментарий полезных Операторов для работы с Наблюдателями</target>
        </trans-unit>
        <trans-unit id="12bf70fec688d32e9df77570a93f7d9de2beb9f6" translate="yes" xml:space="preserve">
          <source>A typical implementation of the Subscribe operator may accept one to three methods (which then constitute the observer), or it may accept an object (sometimes called an &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt;) that implements the interface which includes those three methods:</source>
          <target state="translated">Типичная реализация оператора Subscribe может принимать от одного до трех методов (которые затем составляют наблюдателя) или может принимать объект (иногда называемый &lt;code&gt;Observer&lt;/code&gt; или &lt;code&gt;Subscriber&lt;/code&gt; ), который реализует интерфейс, который включает эти три метода:</target>
        </trans-unit>
        <trans-unit id="326f047b7addbda19eb8d949bed620511187ece5" translate="yes" xml:space="preserve">
          <source>A variant of distinct that only compares emitted items from the source Observable against their immediate predecessors in order to determine whether or not they are distinct.</source>
          <target state="translated">Вариант отличия,который только сравнивает испускаемые предметы из источника,наблюдаемого с их непосредственными предшественниками,чтобы определить,являются ли они отличными или нет.</target>
        </trans-unit>
        <trans-unit id="628cd375e74040d3f1575481baed0a36bf589549" translate="yes" xml:space="preserve">
          <source>A variant of this operator &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; allows you to pass in an &lt;code&gt;Int&lt;/code&gt; indicating the maximum number of these emitted Observables you want &lt;code&gt;merge&lt;/code&gt; to try to be subscribed to at any time. If it hits this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Вариант этого оператора &lt;code&gt;merge(maxConcurrent:)&lt;/code&gt; позволяет вам передать &lt;code&gt;Int&lt;/code&gt; , указывающее максимальное количество этих испускаемых Observable, на которые вы хотите &lt;code&gt;merge&lt;/code&gt; чтобы попытаться подписаться на него в любое время. Если он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d35ccc7301b7ce4feccd9c396c10c5d8cca3b515" translate="yes" xml:space="preserve">
          <source>A variant of this operator, called &lt;code&gt;ofWithScheduler&lt;/code&gt; takes a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as its first parameter, and operates the resulting Observable on this Scheduler.</source>
          <target state="translated">Вариант этого оператора, называемый &lt;code&gt;ofWithScheduler&lt;/code&gt; , принимает &lt;a href=&quot;../scheduler&quot;&gt;планировщик в&lt;/a&gt; качестве первого параметра и управляет результирующим Observable в этом планировщике.</target>
        </trans-unit>
        <trans-unit id="c0925a0e0dd3f224e5197c574ea37e59cffa4f0d" translate="yes" xml:space="preserve">
          <source>A version of the timeout operator allows you to switch to a backup Single rather than sending an error notification if the timeout expires:</source>
          <target state="translated">Версия оператора таймаута позволяет переключиться на резервную Single,а не посылать уведомление об ошибке по истечении таймаута:</target>
        </trans-unit>
        <trans-unit id="95c20b67a1841fd8175f5bbf824b5bd0534f744a" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxGroovy 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">Версия этого оператора, представленная в RxGroovy 1.1, позволяет вам установить емкость буфера; применение этого оператора приведет к завершению работы результирующего Observable с ошибкой, если этот буфер переполнен. Вторая версия, представленная в том же выпуске, позволяет вам установить &lt;code&gt;Action&lt;/code&gt; которое &lt;code&gt;onBackpressureBuffer&lt;/code&gt; будет вызывать, если буфер переполнен.</target>
        </trans-unit>
        <trans-unit id="f994ec3ff86b720b838d74d54795039e7a5aa034" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in RxJava 1.1 allows you to set the capacity of the buffer; applying this operator will cause the resulting Observable to terminate with an error if this buffer is overrun. A second version, introduced during the same release, allows you to set an &lt;code&gt;Action&lt;/code&gt; that &lt;code&gt;onBackpressureBuffer&lt;/code&gt; will call if the buffer is overrun.</source>
          <target state="translated">Версия этого оператора, представленная в RxJava 1.1, позволяет вам устанавливать емкость буфера; применение этого оператора приведет к завершению работы результирующего Observable с ошибкой, если этот буфер переполнен. Вторая версия, представленная в том же выпуске, позволяет вам установить &lt;code&gt;Action&lt;/code&gt; которое &lt;code&gt;onBackpressureBuffer&lt;/code&gt; будет вызывать, если буфер переполнен.</target>
        </trans-unit>
        <trans-unit id="17462ee811b15366ad770504e8600c231368974f" translate="yes" xml:space="preserve">
          <source>A version of this operator that was introduced in the 1.1 release notifies you, by means of an &lt;code&gt;Action&lt;/code&gt; you pass as a parameter, when an item has been dropped and which item was dropped.</source>
          <target state="translated">Версия этого оператора, представленная в выпуске 1.1, уведомляет вас с помощью &lt;code&gt;Action&lt;/code&gt; вы передаете в качестве параметра, когда элемент был отброшен и какой элемент был отброшен.</target>
        </trans-unit>
        <trans-unit id="850d4acf22d3a4e1c03049abdf78b9a93ef3eccf" translate="yes" xml:space="preserve">
          <source>A version of this variant of the operator (still in Beta as of this writing) takes an additional &lt;code&gt;int&lt;/code&gt; parameter. This parameter sets the maximum number of concurrent subscriptions that &lt;code&gt;flatMap&lt;/code&gt; will attempt to have to the Observables that the items emitted by the source Observable map to. When it reaches this maximum number, it will wait for one of those Observables to terminate before subscribing to another.</source>
          <target state="translated">Версия этого варианта оператора (все еще находящаяся в бета-версии на момент написания этой статьи) принимает дополнительный параметр типа &lt;code&gt;int&lt;/code&gt; . Этот параметр устанавливает максимальное количество одновременных подписок, которые &lt;code&gt;flatMap&lt;/code&gt; будет пытаться иметь для Observable, на которые отображаются элементы, отправленные исходным Observable. Когда он достигнет этого максимального числа, он будет ждать завершения работы одного из этих Observable, прежде чем подписываться на другой.</target>
        </trans-unit>
        <trans-unit id="6cf0103a4b2b868a1a60d776479c80ac940f5052" translate="yes" xml:space="preserve">
          <source>A well-formed finite Observable must attempt to call either the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method exactly once or its &lt;code&gt;onError&lt;/code&gt; method exactly once, and must not thereafter attempt to call any of the observer&amp;rsquo;s other methods.</source>
          <target state="translated">Правильно сформированный конечный Observable должен попытаться вызвать либо метод наблюдателя &lt;code&gt;onCompleted&lt;/code&gt; ровно один раз, либо его метод &lt;code&gt;onError&lt;/code&gt; ровно один раз, и не должен после этого пытаться вызвать какой-либо из других методов наблюдателя.</target>
        </trans-unit>
        <trans-unit id="653657e1f29569ba5423fd7a08a85817bf13a50d" translate="yes" xml:space="preserve">
          <source>A well-formed, finite Observable will invoke its observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt; method zero or more times, and then will invoke either the &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; method exactly once. The Materialize operator converts this series of invocations &amp;mdash; both the original &lt;code&gt;onNext&lt;/code&gt; notifications and the terminal &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification &amp;mdash; into a series of &lt;em&gt;items&lt;/em&gt; emitted by an Observable.</source>
          <target state="translated">Правильно сформированный конечный Observable вызовет метод &lt;code&gt;onNext&lt;/code&gt; своего наблюдателя ноль или более раз, а затем вызовет метод &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; ровно один раз. Оператор Materialize преобразует эту серию вызовов - как исходные уведомления &lt;code&gt;onNext&lt;/code&gt; ,так и уведомления терминала &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; - в серию &lt;em&gt;элементов&lt;/em&gt; , генерируемых Observable.</target>
        </trans-unit>
        <trans-unit id="805825d0f7d22f43a512c60285f688fee71614c5" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="translated">Advanced RxJava: Планировщики ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;часть 1&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;часть 2&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;часть 3&lt;/a&gt; ) ( &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;часть 4&lt;/a&gt; ), автор: Давид Карнок</target>
        </trans-unit>
        <trans-unit id="2da723bb85690e2a91f692590ad213ef381dda90" translate="yes" xml:space="preserve">
          <source>Advanced RxJava: Schedulers (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/schedulers-part-1.html&quot;&gt;part 1&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-2.html&quot;&gt;part 2&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-3.html&quot;&gt;part 3&lt;/a&gt;) (&lt;a href=&quot;https://akarnokd.blogspot.hu/2015/06/schedulers-part-4-final.html&quot;&gt;part 4&lt;/a&gt;) by D&amp;aacute;vid Karnok</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf48d7677040c3e9d2bf95bb0839fd2703291b5" translate="yes" xml:space="preserve">
          <source>Alias for Map</source>
          <target state="translated">Псевдоним для карты</target>
        </trans-unit>
        <trans-unit id="4ba6cd005270d28a5da0365e14fbe1da3cdff860" translate="yes" xml:space="preserve">
          <source>Alias for filter</source>
          <target state="translated">Псевдоним для фильтрации</target>
        </trans-unit>
        <trans-unit id="2c0fb5d23e5194856f864607d264c2dcc4f20d1e" translate="yes" xml:space="preserve">
          <source>Alias for flatMap</source>
          <target state="translated">Псевдоним для flatMap</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c80ac46ff1f8aeeb94f7a8999a13b0a1e6062b2c" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">Также в классе &lt;code&gt;StringObservable&lt;/code&gt; , который не является частью ядра RxGroovy, есть специальный оператор сопоставления, называемый &lt;code&gt;byLine&lt;/code&gt; , который преобразует Observable, который испускает строки, в Observable, который испускает строки текста, путем буферизации строк из исходного Observable до строки- корм находится в одном из них.</target>
        </trans-unit>
        <trans-unit id="9b4f6274689c272bebb2b489085539520b4a1e6a" translate="yes" xml:space="preserve">
          <source>Also in the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is a specialty mapping operator called &lt;code&gt;byLine&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits lines of text, by buffering the strings from the source Observable until a line-feed is found in one of them.</source>
          <target state="translated">Также в классе &lt;code&gt;StringObservable&lt;/code&gt; , который не является частью ядра RxJava, есть специальный оператор сопоставления, называемый &lt;code&gt;byLine&lt;/code&gt; , который преобразует Observable, который испускает строки, в Observable, который испускает строки текста, путем буферизации строк из исходного Observable до строки- корм находится в одном из них.</target>
        </trans-unit>
        <trans-unit id="9dd5794be8096ff7869d94f283eedcf7b7672bb9" translate="yes" xml:space="preserve">
          <source>Amb</source>
          <target state="translated">Amb</target>
        </trans-unit>
        <trans-unit id="851ac2f8e49b2f26ad526a214ceca7b96c49f162" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AsyncSubject&lt;/code&gt; emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes. (If the source Observable does not emit any values, the &lt;code&gt;AsyncSubject&lt;/code&gt; also completes without emitting any values.)</source>
          <target state="translated">&lt;code&gt;AsyncSubject&lt;/code&gt; испускает последнее значение (и только последнее значение) , испускаемого источником наблюдаема, и только после этого источника Наблюдаемые завершается. (Если исходный Observable не &lt;code&gt;AsyncSubject&lt;/code&gt; никаких значений, AsyncSubject также завершается без выдачи каких-либо значений.)</target>
        </trans-unit>
        <trans-unit id="7cd649dc1e5fe644141b9e448ab2c1ac4a152926" translate="yes" xml:space="preserve">
          <source>An Alphabetical List of Observable Operators</source>
          <target state="translated">Алфавитный список наблюдаемых операторов.</target>
        </trans-unit>
        <trans-unit id="2839cacd293e99aa08485d95a5eaad72408dc3f8" translate="yes" xml:space="preserve">
          <source>An Observable calls this method after it has called &lt;code&gt;onNext&lt;/code&gt; for the final time, if it has not encountered any errors.</source>
          <target state="translated">Observable вызывает этот метод после того, как он в последний раз вызвал &lt;code&gt;onNext&lt;/code&gt; , если он не обнаружил никаких ошибок.</target>
        </trans-unit>
        <trans-unit id="2ea9db047d5da0996289f4901a31c06634ef96eb" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. It will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error.</source>
          <target state="translated">Observable вызывает этот метод, чтобы указать, что он не смог сгенерировать ожидаемые данные или обнаружил другую ошибку. Он не будет делать дальнейших вызовов &lt;code&gt;onNext&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; . Метод &lt;code&gt;onError&lt;/code&gt; принимает в качестве параметра указание на причину ошибки.</target>
        </trans-unit>
        <trans-unit id="42c53d34a4f49cf4f5df1fa4953366bbd8ebe91d" translate="yes" xml:space="preserve">
          <source>An Observable calls this method to indicate that it has failed to generate the expected data or has encountered some other error. This stops the Observable and it will not make further calls to &lt;code&gt;onNext&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;. The &lt;code&gt;onError&lt;/code&gt; method takes as its parameter an indication of what caused the error (sometimes an object like an Exception or Throwable, other times a simple string, depending on the implementation).</source>
          <target state="translated">Observable вызывает этот метод, чтобы указать, что он не смог сгенерировать ожидаемые данные или обнаружил другую ошибку. Это останавливает Observable, и он больше не будет &lt;code&gt;onNext&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; . Метод &lt;code&gt;onError&lt;/code&gt; принимает в качестве параметра указание на причину ошибки (иногда такой объект, как Exception или Throwable, а иногда - простая строка, в зависимости от реализации).</target>
        </trans-unit>
        <trans-unit id="74d2f09477c8a4f1394bf039fd16d24d7fa53421" translate="yes" xml:space="preserve">
          <source>An Observable calls this method whenever the Observable emits an item. This method takes as a parameter the item emitted by the Observable.</source>
          <target state="translated">Наблюдаемый вызывает этот метод всякий раз,когда Наблюдаемый испускает элемент.Этот метод принимает в качестве параметра элемент,излучаемый наблюдаемым.</target>
        </trans-unit>
        <trans-unit id="16a9dcd358629f823cb0ef4d649474083b6c5bb3" translate="yes" xml:space="preserve">
          <source>An Observable communicates with its observers with the following</source>
          <target state="translated">Наблюдатель общается со своими наблюдателями следующим образом.</target>
        </trans-unit>
        <trans-unit id="6a76c3a98e43666ea0eb0740c08e3a7cbd79ab65" translate="yes" xml:space="preserve">
          <source>An Observable is called a &amp;ldquo;cold&amp;rdquo; Observable if it does not begin to emit items until an observer has subscribed to it; an Observable is called a &amp;ldquo;hot&amp;rdquo; Observable if it may begin emitting items at any time, and a subscriber may begin observing the sequence of emitted items at some point after its commencement, missing out on any items emitted previously to the time of the subscription.</source>
          <target state="translated">Observable называется &amp;laquo;холодным&amp;raquo; Observable, если он не начинает излучать элементы, пока на него не подписался наблюдатель; Observable называется &amp;laquo;горячим&amp;raquo; Observable, если он может начать отправку элементов в любое время, и подписчик может начать наблюдение за последовательностью отправленных элементов в какой-то момент после его начала, пропуская любые элементы, отправленные ранее до момента подписки. .</target>
        </trans-unit>
        <trans-unit id="d7bf7c542baf1867dd7cef5a402b7db67b5190bd" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="translated">Observable - это асинхронный / push &lt;a href=&quot;http://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;laquo;двойной&amp;raquo;&lt;/a&gt; к синхронному / pull Iterable.</target>
        </trans-unit>
        <trans-unit id="cb13486a1c65cc1a873f5114a61e7ce2d85fd09a" translate="yes" xml:space="preserve">
          <source>An Observable is the asynchronous/push &lt;a href=&quot;https://en.wikipedia.org/wiki/Dual_(category_theory)&quot;&gt;&amp;ldquo;dual&amp;rdquo;&lt;/a&gt; to the synchronous/pull Iterable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbafffea1979fbff2b9d19c9947eecf861d10073" translate="yes" xml:space="preserve">
          <source>An Observable may begin issuing notifications to an observer immediately after the Observable receives a Subscribe notification from the observer.</source>
          <target state="translated">Наблюдатель может начать выдавать уведомления наблюдателю сразу же после того,как наблюдатель получит от наблюдателя уведомление о подписке.</target>
        </trans-unit>
        <trans-unit id="a7c3d8f2d0e01af84eba974448d28b40c4172a8e" translate="yes" xml:space="preserve">
          <source>An Observable may emit no items at all. An Observable may also never terminate with either an OnCompleted or an OnError notification. That is to say that it is proper for an Observable to issue no notifications, to issue only an OnCompleted or an OnError notification, or to issue only OnNext notifications.</source>
          <target state="translated">Наблюдатель не может испускать никаких предметов.Наблюдаемый также может никогда не закончиться с уведомлением об Ошибке или OnCompleteted.Это означает,что наблюдателю следует не выпускать никаких уведомлений,выпускать только OnCompleteted или OnError,или выпускать только OnNext-уведомления.</target>
        </trans-unit>
        <trans-unit id="cf2b11572810d9a5ac8311dae558136ea173beb4" translate="yes" xml:space="preserve">
          <source>An Observable may make zero or more OnNext notifications, each representing a single emitted item, and it may then follow those emission notifications by either an OnCompleted or an OnError notification, but not both. Upon issuing an OnCompleted or OnError notification, it may not thereafter issue any further notifications.</source>
          <target state="translated">Наблюдатель может сделать ноль или более уведомлений OnNext,каждое из которых представляет собой единичный испускаемый элемент,и затем он может следовать за этими уведомлениями об испускаемых элементах либо уведомлением OnCompleteted,либо уведомлением об ошибке OnError,но не тем и другим.После того,как сообщение OnCompleteted или OnError будет опубликовано,он не может впоследствии публиковать никаких дальнейших уведомлений.</target>
        </trans-unit>
        <trans-unit id="645e6d39de346178f5938830b549355de0e6e3e5" translate="yes" xml:space="preserve">
          <source>An Observable that does not implement backpressure should respond to a Request notification from an observer by issuing an OnError notification that indicates that backpressure is not supported.</source>
          <target state="translated">Наблюдатель,не реализующий противодавление,должен ответить на запрос уведомления от наблюдателя,выпустив уведомление об ошибке OnError,указывающее на то,что противодавление не поддерживается.</target>
        </trans-unit>
        <trans-unit id="689703d4ac79bcdd377cfb6c92ab325f0021d3b4" translate="yes" xml:space="preserve">
          <source>An OnError notification must contain the cause of the error (that is to say, it is invalid to call OnError with a &lt;code&gt;null&lt;/code&gt; value).</source>
          <target state="translated">Уведомление OnError должно содержать причину ошибки (то есть недопустимо вызывать OnError с &lt;code&gt;null&lt;/code&gt; значением).</target>
        </trans-unit>
        <trans-unit id="0ff87217adf75afaa1c6885b1ac6c1d5742a3cbd" translate="yes" xml:space="preserve">
          <source>An advantage of this approach is that when you have a bunch of tasks that are not dependent on each other, you can start them all at the same time rather than waiting for each one to finish before starting the next one &amp;mdash; that way, your entire bundle of tasks only takes as long to complete as the longest task in the bundle.</source>
          <target state="translated">Преимущество этого подхода заключается в том, что когда у вас есть набор задач, которые не зависят друг от друга, вы можете запускать их все одновременно, а не ждать завершения каждой, прежде чем начинать следующую - таким образом, весь ваш Пакет задач занимает ровно столько времени, чтобы выполнить самую длинную задачу в пакете.</target>
        </trans-unit>
        <trans-unit id="d85814a55f42e0261226556859d609d250a378ba" translate="yes" xml:space="preserve">
          <source>An even simpler operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (also not part of the standard RxGroovy set of operators) is &lt;code&gt;ifThen&lt;/code&gt;. This operator checks a condition and then either mirrors the source Observable or an empty Observable depending on the result.</source>
          <target state="translated">Еще более простой оператор в необязательном &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; (также не являющийся частью стандартного набора операторов &lt;code&gt;ifThen&lt;/code&gt; ) - ifThen . Этот оператор проверяет условие, а затем либо отражает исходный Observable, либо пустой Observable в зависимости от результата.</target>
        </trans-unit>
        <trans-unit id="0f829bc7f8186b73be4fd6d24d31abb651902daa" translate="yes" xml:space="preserve">
          <source>An observer communicates with its Observable by means of the following notifications:</source>
          <target state="translated">Наблюдатель общается со своим Наблюдателем посредством следующих уведомлений:</target>
        </trans-unit>
        <trans-unit id="6c74c14e78b3bf3709270805f239144c3e35aa94" translate="yes" xml:space="preserve">
          <source>An optional third parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) allows you to choose an item that &lt;code&gt;first&lt;/code&gt; will emit if the source Observable does not emit any items (or if it does not emit the</source>
          <target state="translated">Необязательный третий параметр (с именем &lt;code&gt;defaultValue&lt;/code&gt; ) позволяет вам выбрать элемент, который &lt;code&gt;first&lt;/code&gt; будет испускать, если исходный Observable не испускает никаких элементов (или если он не испускает</target>
        </trans-unit>
        <trans-unit id="e16bafd99d71f935206c53ee2503366667c35c3c" translate="yes" xml:space="preserve">
          <source>And importantly: with ReactiveX you can later change your mind, and radically change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.</source>
          <target state="translated">И что немаловажно:с помощью ReactiveX вы сможете впоследствии изменить свое мнение и радикально изменить основную природу вашей &quot;наблюдаемой&quot; реализации,не ломая при этом потребителей вашей &quot;наблюдаемой&quot;.</target>
        </trans-unit>
        <trans-unit id="214cbe57ae28db943c3ec9b46b47b3101daf0c7b" translate="yes" xml:space="preserve">
          <source>And that variant also has a cousin that will switch to a specified backup Observable rather than emitting an error upon hitting a timeout condition.</source>
          <target state="translated">И у этого варианта также есть двоюродный брат,который переключится на указанную резервную копию Observable вместо того,чтобы выдавать ошибку при попадании в состояние таймаута.</target>
        </trans-unit>
        <trans-unit id="6fd733cd8e342ef935e8375aac0d129d8c255f6b" translate="yes" xml:space="preserve">
          <source>And there is a variant of &lt;code&gt;delaySubscription&lt;/code&gt; that uses an Observable (returned by a function you supply) rather than a fixed duration in order to set the subscription delay.</source>
          <target state="translated">И есть вариант &lt;code&gt;delaySubscription&lt;/code&gt; , который использует Observable (возвращаемый функцией, которую вы предоставляете), а не фиксированную продолжительность, чтобы установить задержку подписки.</target>
        </trans-unit>
        <trans-unit id="d8ee68728e1626f87277753fcdb831fc09c7b3d5" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and emits the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and makes an error notification if multiple items match.</source>
          <target state="translated">Также существует &lt;code&gt;singleOrDefault&lt;/code&gt; которая принимает функцию предиката и генерирует единственный элемент из исходного Observable, который соответствует этому предикату, если таковой имеется; элемент по умолчанию, если таких элементов нет; и выдает уведомление об ошибке, если совпадают несколько элементов.</target>
        </trans-unit>
        <trans-unit id="f667a90816681f20bf11089e389629e58978843f" translate="yes" xml:space="preserve">
          <source>And there is also a verion of &lt;code&gt;singleOrDefault&lt;/code&gt; that takes a predicate function and returns the sole item from the source Observable that matches that predicate, if any; the default item if no such items match; and throws an error if multiple items match.</source>
          <target state="translated">Также существует &lt;code&gt;singleOrDefault&lt;/code&gt; которая принимает функцию предиката и возвращает единственный элемент из исходного Observable, который соответствует этому предикату, если таковой имеется; элемент по умолчанию, если таких элементов нет; и выдает ошибку, если совпадают несколько элементов.</target>
        </trans-unit>
        <trans-unit id="10883d7bc99bd25d1b6cd9f78cf866a8856bbf98" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">И, как и в случае с &lt;code&gt;first&lt;/code&gt; , существует вариант &lt;code&gt;firstOrDefault&lt;/code&gt; , который принимает функцию предиката в качестве аргумента и извлекает первый элемент из источника &lt;code&gt;BlockingObservable&lt;/code&gt; , который удовлетворяет этому предикату, или элемент по умолчанию, если не было создано ни одного удовлетворительного элемента.</target>
        </trans-unit>
        <trans-unit id="b61cf36b9bbc9f1f59d3790764d487afdbb2624c" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;first&lt;/code&gt;, there is a &lt;code&gt;firstOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and returns the first item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">И, как и в случае с &lt;code&gt;first&lt;/code&gt; , существует вариант &lt;code&gt;firstOrDefault&lt;/code&gt; , который принимает функцию предиката в качестве аргумента и возвращает первый элемент из источника &lt;code&gt;BlockingObservable&lt;/code&gt; , который удовлетворяет этому предикату, или элемент по умолчанию, если не было создано ни одного удовлетворительного элемента.</target>
        </trans-unit>
        <trans-unit id="5d569317120812ad4b1a0a46c5a1a37fce2c43e2" translate="yes" xml:space="preserve">
          <source>And, as with &lt;code&gt;last&lt;/code&gt;, there is a &lt;code&gt;lastOrDefault&lt;/code&gt; variant that takes a predicate function as an argument and retrieves the last item from the source &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies that predicate, or a default item instead if no satisfying item was emitted.</source>
          <target state="translated">И, как и в случае с &lt;code&gt;last&lt;/code&gt; , существует вариант &lt;code&gt;lastOrDefault&lt;/code&gt; , который принимает в качестве аргумента функцию предиката и извлекает последний элемент из источника &lt;code&gt;BlockingObservable&lt;/code&gt; , который удовлетворяет этому предикату, или элемент по умолчанию, если не было создано ни одного удовлетворительного элемента.</target>
        </trans-unit>
        <trans-unit id="8251dbbd4d407b2ba611d6bab161e9f49c31af8d" translate="yes" xml:space="preserve">
          <source>And/Then/When</source>
          <target state="translated">And/Then/When</target>
        </trans-unit>
        <trans-unit id="5e3f7fc4502eaa43261cf03af6ffe0dd602b81e7" translate="yes" xml:space="preserve">
          <source>Another variant allows you to instruct &lt;code&gt;timeout&lt;/code&gt; to switch to a backup Observable that you specify, rather than terminating with an error, if the timeout condition is triggered. To use this variant, pass the backup Observable (or &lt;code&gt;Promise&lt;/code&gt;) as the second parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Другой вариант позволяет вам указать &lt;code&gt;timeout&lt;/code&gt; для переключения на указанную вами резервную копию Observable, а не завершаться с ошибкой, если срабатывает условие тайм-аута. Чтобы использовать этот вариант, передайте резервную копию Observable (или &lt;code&gt;Promise&lt;/code&gt; ) в качестве второго параметра &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a94542011650405c857cbde913a1b92445107e" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;Retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;Retry(2)&lt;/code&gt; means that &lt;code&gt;Retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">Другой вариант &lt;code&gt;Retry&lt;/code&gt; принимает единственный параметр: количество уведомлений &lt;code&gt;onError&lt;/code&gt; ,которые оно должно быть готово принять, прежде чем оно тоже выйдет из строя, и передает &lt;code&gt;onError&lt;/code&gt; своим наблюдателям. Например, &lt;code&gt;Retry(2)&lt;/code&gt; означает, что &lt;code&gt;Retry&lt;/code&gt; повторно &lt;code&gt;onError&lt;/code&gt; на источник Observable и отразит его в первый раз, когда получит уведомление onError , но завершится с ошибкой во второй раз.</target>
        </trans-unit>
        <trans-unit id="02efaeb4d2bdd19b23fcdfa7078d0965b0543f39" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits a item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">Другой вариант &lt;code&gt;delay&lt;/code&gt; не использует постоянную продолжительность задержки, но устанавливает ее длительность для каждого элемента, передавая каждый элемент из источника Observable в функцию, которая возвращает Observable, а затем отслеживает эти Observable. Когда любой из таких Observable испускает элемент или завершается, Observable, возвращенный &lt;code&gt;delay&lt;/code&gt; испускает связанный элемент.</target>
        </trans-unit>
        <trans-unit id="f2cb02c7b8b0dc8585c179d8f7a980076f44300b" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;delay&lt;/code&gt; does not use a constant delay duration, but sets its delay duration on a per-item basis by passing each item from the source Observable into a function that returns an Observable and then monitoring those Observables. When any such Observable emits an item or completes, the Observable returned by &lt;code&gt;delay&lt;/code&gt; emits the associated item.</source>
          <target state="translated">Другой вариант &lt;code&gt;delay&lt;/code&gt; не использует постоянную продолжительность задержки, но устанавливает ее длительность для каждого элемента, передавая каждый элемент из источника Observable в функцию, которая возвращает Observable, а затем отслеживает эти Observable. Когда любой такой Observable испускает элемент или завершает его, Observable, возвращенный &lt;code&gt;delay&lt;/code&gt; испускает связанный элемент.</target>
        </trans-unit>
        <trans-unit id="18e4f38385f3555737f4cc37f65db6f2b2cb3f98" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of &lt;code&gt;onError&lt;/code&gt; notification it should be willing to accept before it too fails and passes the &lt;code&gt;onError&lt;/code&gt; to its observers. For example, &lt;code&gt;retry(2)&lt;/code&gt; means that &lt;code&gt;retry&lt;/code&gt; will resubscribe to and mirror the source Observable the first time it receives an &lt;code&gt;onError&lt;/code&gt; notification, but will terminate with an error the second time this happens.</source>
          <target state="translated">Другой вариант &lt;code&gt;retry&lt;/code&gt; принимает единственный параметр: количество уведомлений &lt;code&gt;onError&lt;/code&gt; ,которые оно должно быть готово принять, прежде чем оно тоже не сработает, и передает &lt;code&gt;onError&lt;/code&gt; своим наблюдателям. Например, &lt;code&gt;retry(2)&lt;/code&gt; означает, что &lt;code&gt;retry&lt;/code&gt; повторно подпишется и отразит исходный Observable при первом &lt;code&gt;onError&lt;/code&gt; уведомления onError , но завершится с ошибкой во второй раз.</target>
        </trans-unit>
        <trans-unit id="53a31e30b7b7961ac8ac1fd52bd1e592dd652cbb" translate="yes" xml:space="preserve">
          <source>Another variant of &lt;code&gt;retry&lt;/code&gt; takes a single parameter: a count of the number of times it should try to resubscribe to the source Observable when it encounters errors. If this count is exceeded, &lt;code&gt;retry&lt;/code&gt; will not attempt to resubscribe again and will instead pass the latest &lt;code&gt;onError&lt;/code&gt; notification to its observers.</source>
          <target state="translated">Другой вариант &lt;code&gt;retry&lt;/code&gt; принимает один параметр: количество попыток повторной подписки на источник Observable при обнаружении ошибок. Если это количество превышено, &lt;code&gt;retry&lt;/code&gt; не будет пытаться повторно подписаться снова, а вместо этого передаст последнее уведомление &lt;code&gt;onError&lt;/code&gt; своим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="180c4e210c4586ad6515a4efe0a7bfdaf14fb209" translate="yes" xml:space="preserve">
          <source>Another version combines items from the source Observable with the Observable triggered by those source items, and emits these combinations.</source>
          <target state="translated">Другая версия сочетает элементы из источника &quot;Наблюдаемый&quot; и &quot;Наблюдаемый&quot;,вызванные этими элементами источника,и излучает эти комбинации.</target>
        </trans-unit>
        <trans-unit id="9c3e74fdeb39fa8f79f8b41f914729603db3668b" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;flatMap&lt;/code&gt; creates (and flattens) a new Observable for each item &lt;em&gt;and notification&lt;/em&gt; from the source Observable.</source>
          <target state="translated">Другая версия &lt;code&gt;flatMap&lt;/code&gt; создает (и выравнивает) новый Observable для каждого элемента &lt;em&gt;и уведомления&lt;/em&gt; от исходного Observable.</target>
        </trans-unit>
        <trans-unit id="416f48df8cc3910b8bb048511d0a6e4801002873" translate="yes" xml:space="preserve">
          <source>Another version of &lt;code&gt;groupBy&lt;/code&gt; allows you to pass in a transformative function that changes the elements before they are emitted by the resulting &lt;code&gt;GroupedObservable&lt;/code&gt;s.</source>
          <target state="translated">Другая версия &lt;code&gt;groupBy&lt;/code&gt; позволяет передавать трансформирующую функцию, которая изменяет элементы до того, как они будут &lt;code&gt;GroupedObservable&lt;/code&gt; результирующими объектами GroupedObservable .</target>
        </trans-unit>
        <trans-unit id="6cbe5dee754659834a3070a07a4de32cd17c626d" translate="yes" xml:space="preserve">
          <source>Another version takes two or more Singles and merges them into an Observable that emits the items emitted by the source Singles (in an arbitrary order):</source>
          <target state="translated">Другая версия берёт два или более Одиночных и объединяет их в Наблюдаемый,который испускает элементы,испускаемые источником Одиночных (в произвольном порядке):</target>
        </trans-unit>
        <trans-unit id="5fc07229ca716771de12a56cf5816c03a72ab3bb" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.</source>
          <target state="translated">Применяет функцию аккумулятора над наблюдаемой последовательностью и возвращает каждый промежуточный результат.В качестве исходного значения аккумулятора используется опциональное значение посевного материала.</target>
        </trans-unit>
        <trans-unit id="e968236df359a0c3a3b48d1101e20c7334bc87e3" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.</source>
          <target state="translated">Применяет функцию аккумулятора над наблюдаемой последовательностью,возвращая результат суммирования в виде одного элемента в последовательности результатов.В качестве исходного значения аккумулятора используется указанное начальное значение.</target>
        </trans-unit>
        <trans-unit id="6482ebf54fcf3fef454ac6beb793ddcb408e9393" translate="yes" xml:space="preserve">
          <source>As an alternative to using &lt;code&gt;request&lt;/code&gt; to pull items from a &lt;code&gt;ControlledObservable&lt;/code&gt;, you may apply the &lt;code&gt;stopAndWait&lt;/code&gt; operator to it. This operator will request a new item from the Observable each time its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; routine receives the latest item.</source>
          <target state="translated">В качестве альтернативы использованию &lt;code&gt;request&lt;/code&gt; на извлечение элементов из &lt;code&gt;ControlledObservable&lt;/code&gt; вы можете применить к &lt;code&gt;stopAndWait&lt;/code&gt; оператор stopAndWait . Этот оператор будет запрашивать новый элемент у Observable каждый раз, &lt;code&gt;onNext&lt;/code&gt; подпрограмма onNext его наблюдателей получает последний элемент.</target>
        </trans-unit>
        <trans-unit id="3e2402a383d153594ac341c580a389f352b429f3" translate="yes" xml:space="preserve">
          <source>As shown in the above diagram, an &lt;code&gt;onError&lt;/code&gt; notification from any of the source Observables will immediately be passed through to observers and will terminate the merged Observable.</source>
          <target state="translated">Как показано на диаграмме выше, уведомление &lt;code&gt;onError&lt;/code&gt; от любого из исходных Observable будет немедленно передано наблюдателям и завершит объединенный Observable.</target>
        </trans-unit>
        <trans-unit id="2944d9f0e54e8337eac2b3e9e3efb8980e22c066" translate="yes" xml:space="preserve">
          <source>As shown in this illustration, the SubscribeOn operator designates which thread the Observable will begin operating on, no matter at what point in the chain of operators that operator is called. ObserveOn, on the other hand, affects the thread that the Observable will use &lt;em&gt;below&lt;/em&gt; where that operator appears. For this reason, you may call ObserveOn multiple times at various points during the chain of Observable operators in order to change on which threads certain of those operators operate.</source>
          <target state="translated">Как показано на этой иллюстрации, оператор SubscribeOn указывает, в каком потоке Observable начнет работать, независимо от того, в какой точке цепочки операторов вызывается этот оператор. ObserveOn, с другой стороны, влияет на поток, который Observable будет использовать &lt;em&gt;ниже,&lt;/em&gt; где появляется этот оператор. По этой причине вы можете вызывать ObserveOn несколько раз в различных точках цепочки операторов Observable, чтобы изменить, в каких потоках работают некоторые из этих операторов.</target>
        </trans-unit>
        <trans-unit id="90336d424ebddac61136082a2c6d772454fe8231" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;distinct&lt;/code&gt;, there is also a version of &lt;code&gt;distinctUntilChanged&lt;/code&gt; that accepts a key selector function and that uses the resulting key to determine whether or not two adjacently-emitted items are distinct.</source>
          <target state="translated">Как и в случае с &lt;code&gt;distinct&lt;/code&gt; , существует также версия &lt;code&gt;distinctUntilChanged&lt;/code&gt; которая принимает функцию выбора ключа и использует полученный ключ, чтобы определить, являются ли два соседних элемента различными.</target>
        </trans-unit>
        <trans-unit id="ea92b7b4b8b9fa35e6026e8b95b2e25ebb1fc5c4" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that emits a default item if the source Observable is empty, although it will still notify of an error if the source Observable emits more than one item.</source>
          <target state="translated">Как и в случае с &lt;code&gt;firstOrDefault&lt;/code&gt; , существует также &lt;code&gt;singleOrDefault&lt;/code&gt; , который генерирует элемент по умолчанию, если исходный Observable пуст, хотя он все равно будет уведомлять об ошибке, если исходный Observable испускает более одного элемента.</target>
        </trans-unit>
        <trans-unit id="d92ac954f9b7869499152c6f9dac87389cc9d017" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;firstOrDefault&lt;/code&gt; there is also a &lt;code&gt;singleOrDefault&lt;/code&gt; that returns a default item if the source Observable is empty, although it will still throw an error if the source Observable emits more than one item.</source>
          <target state="translated">Как и в случае с &lt;code&gt;firstOrDefault&lt;/code&gt; , существует также &lt;code&gt;singleOrDefault&lt;/code&gt; , который возвращает элемент по умолчанию, если исходный Observable пуст, хотя он все равно выдаст ошибку, если исходный Observable испускает более одного элемента.</target>
        </trans-unit>
        <trans-unit id="9dca8bd3303f27dee6fa18df112035b5a22c5486" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;flatMap&lt;/code&gt;, &lt;code&gt;concatMap&lt;/code&gt; works just as well if the function you provide transforms items from the source Observables into Observables, into Promises, or into arrays.</source>
          <target state="translated">Как и &lt;code&gt;flatMap&lt;/code&gt; , &lt;code&gt;concatMap&lt;/code&gt; работает так же хорошо, если предоставляемая вами функция преобразует элементы из исходных Observables в Observables, в Promises или в массивы.</target>
        </trans-unit>
        <trans-unit id="c6e9229a21e2a7672f82daa0c3b3a03f4a076628" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;first&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no first element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;firstOrDefault&lt;/code&gt; method.</source>
          <target state="translated">Как и в случае с операторами фильтрации, &lt;code&gt;first&lt;/code&gt; метод &lt;code&gt;BlockingObservable&lt;/code&gt; вызовет &lt;code&gt;NoSuchElementException&lt;/code&gt; если в исходном &lt;code&gt;BlockingObservable&lt;/code&gt; нет первого элемента . Чтобы вместо этого вернуть элемент по умолчанию в таких случаях, используйте метод &lt;code&gt;firstOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3967a0eb108ca47a2858158ed9dfb9574c5f8ca" translate="yes" xml:space="preserve">
          <source>As with the filtering operators, the &lt;code&gt;last&lt;/code&gt; method of &lt;code&gt;BlockingObservable&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; if there is no last element in the source &lt;code&gt;BlockingObservable&lt;/code&gt;. To return a default item instead in such cases, use the &lt;code&gt;lastOrDefault&lt;/code&gt; method.</source>
          <target state="translated">Как и в случае с операторами фильтрации, &lt;code&gt;last&lt;/code&gt; метод &lt;code&gt;BlockingObservable&lt;/code&gt; вызовет &lt;code&gt;NoSuchElementException&lt;/code&gt; если в исходном &lt;code&gt;BlockingObservable&lt;/code&gt; нет последнего элемента . Чтобы вместо этого вернуть элемент по умолчанию в таких случаях, используйте метод &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fcf5a04971327e7fdf42936464bd21e8b771ab5" translate="yes" xml:space="preserve">
          <source>Aside from passing these Schedulers in to RxJava Observable operators, you can also use them to schedule your own work on Subscriptions. The following example uses &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;the &lt;code&gt;schedule&lt;/code&gt; method&lt;/a&gt; of &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;the &lt;code&gt;Scheduler.Worker&lt;/code&gt; class&lt;/a&gt; to schedule work on the &lt;code&gt;newThread&lt;/code&gt; Scheduler:</source>
          <target state="translated">Помимо передачи этих планировщиков операторам RxJava Observable, вы также можете использовать их для планирования своей собственной работы над подписками. В следующем примере &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0)&quot;&gt;в &lt;code&gt;schedule&lt;/code&gt; метод&lt;/a&gt; из &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html&quot;&gt;в &lt;code&gt;Scheduler.Worker&lt;/code&gt; класса&lt;/a&gt; к графику работы на &lt;code&gt;newThread&lt;/code&gt; Планировщик:</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="4cd01c057417c6358415753c1e3270378ba8ff9e" translate="yes" xml:space="preserve">
          <source>At any time after it receives an OnSubscribe notification, an observer may issue a Request notification to the Observable it has subscribed to. This notification requests a particular number of items. The Observable responds to such a Request by emitting no more items to the observer than the number of items the observer requests. However the Observable may, in addition, issue an OnCompleted or OnError notification, and it may even issue such a notification before the observer requests any items at all.</source>
          <target state="translated">В любое время после получения уведомления о подписке на услугу Наблюдатель может направить Запрос на уведомление Наблюдателю,на которого он подписан.Это уведомление запрашивает определенное количество элементов.Наблюдатель отвечает на такой Запрос,направляя наблюдателю не больше элементов,чем количество элементов,запрошенных наблюдателем.Однако Наблюдатель может,в дополнение к этому,направить уведомление о Завершённом или Ошибке,и он может даже направить такое уведомление до того,как наблюдатель вообще запросит какое-либо количество элементов.</target>
        </trans-unit>
        <trans-unit id="8a7c2b7fecd45fc8d48965e405aa02103af88d8a" translate="yes" xml:space="preserve">
          <source>Attach the observer to that Observable by</source>
          <target state="translated">Прикрепить наблюдателя к наблюдателю с помощью</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bfded4a21da8efbb2fa839d4b2207399ba6ad7be" translate="yes" xml:space="preserve">
          <source>Backpressure</source>
          <target state="translated">Backpressure</target>
        </trans-unit>
        <trans-unit id="35262f52104832142bf6755bccc1f3e12433d190" translate="yes" xml:space="preserve">
          <source>Backpressure Operators</source>
          <target state="translated">Операторы противодавления</target>
        </trans-unit>
        <trans-unit id="d2eb3d3593072fa90c30c72ab2ea8bae6bdb0314" translate="yes" xml:space="preserve">
          <source>Backpressure is optional; not all ReactiveX implementations include backpressure, and in those that do, not all Observables or operators honor backpressure. An Observable &lt;em&gt;may&lt;/em&gt; implement backpressure if it detects that its observer implements</source>
          <target state="translated">Противодавление необязательно; не все реализации ReactiveX включают противодавление, а в тех, которые включают, не все Observables или операторы соблюдают противодавление. Observable &lt;em&gt;может&lt;/em&gt; реализовать противодавление, если обнаружит, что его наблюдатель реализует</target>
        </trans-unit>
        <trans-unit id="c17bead9671f0fa78aeae30852ed269b9a2823ed" translate="yes" xml:space="preserve">
          <source>Backpressure-related Operators</source>
          <target state="translated">Операторы,связанные с противодавлением</target>
        </trans-unit>
        <trans-unit id="430ace144fb8a573f293eacace0939475b0d212a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onErrorFlatMap&lt;/code&gt; is designed to work with pathological source Observables that do not terminate after issuing an error, it is mostly useful in debugging/testing scenarios.</source>
          <target state="translated">Поскольку &lt;code&gt;onErrorFlatMap&lt;/code&gt; предназначен для работы с патологическими объектами Observables, которые не завершаются после выдачи ошибки, это в основном полезно в сценариях отладки / тестирования.</target>
        </trans-unit>
        <trans-unit id="fd066d9d682432c2ab720b8c76cae63bcdae1811" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items (that is, it produces a &lt;em&gt;hot&lt;/em&gt; Observable), it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this operator and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;code&gt;Subject&lt;/code&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">Поскольку &lt;code&gt;runAsync&lt;/code&gt; немедленно вызывает &lt;code&gt;Action&lt;/code&gt; и начинает генерировать элементы (то есть создает &lt;em&gt;горячий&lt;/em&gt; Observable), возможно, что некоторые элементы могут быть потеряны в интервале между тем, когда вы устанавливаете &lt;code&gt;StoppableObservable&lt;/code&gt; с этим оператором и когда ваш &lt;code&gt;Observer&lt;/code&gt; готов к получить предметы. Если это проблема, вы можете использовать вариант &lt;code&gt;runAsync&lt;/code&gt; , который также принимает &lt;code&gt;Subject&lt;/code&gt; , и передать &lt;code&gt;ReplaySubject&lt;/code&gt; , с помощью которого вы можете получить недостающие элементы.</target>
        </trans-unit>
        <trans-unit id="580926df80f2bb9b9ffac06756ddd1d4eed2fe8f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;runAsync&lt;/code&gt; immediately invokes the &lt;code&gt;Action&lt;/code&gt; and begins emitting the items, it is possible that some items may be lost in the interval between when you establish the &lt;code&gt;StoppableObservable&lt;/code&gt; with this method and when your &lt;code&gt;Observer&lt;/code&gt; is ready to receive items. If this is a problem, you can use the variant of &lt;code&gt;runAsync&lt;/code&gt; that also accepts a &lt;a href=&quot;../subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; and pass a &lt;code&gt;ReplaySubject&lt;/code&gt; with which you can retrieve the otherwise-missing items.</source>
          <target state="translated">Поскольку &lt;code&gt;runAsync&lt;/code&gt; немедленно вызывает &lt;code&gt;Action&lt;/code&gt; и начинает генерировать элементы, возможно, что некоторые элементы могут быть потеряны в интервале между установкой &lt;code&gt;StoppableObservable&lt;/code&gt; с помощью этого метода и тем, когда ваш &lt;code&gt;Observer&lt;/code&gt; готов принять элементы. Если это проблема, вы можете использовать вариант &lt;code&gt;runAsync&lt;/code&gt; , который также принимает &lt;a href=&quot;../subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; ,&lt;/a&gt; и передать &lt;code&gt;ReplaySubject&lt;/code&gt; , с помощью которого вы можете получить недостающие элементы.</target>
        </trans-unit>
        <trans-unit id="45d4b461dae7aa4c7f69430372ef95db326bbe71" translate="yes" xml:space="preserve">
          <source>Because a Subject subscribes to an Observable, it will trigger that Observable to begin emitting items (if that Observable is &amp;ldquo;cold&amp;rdquo; &amp;mdash; that is, if it waits for a subscription before it begins to emit items). This can have the effect of making the resulting Subject a &amp;ldquo;hot&amp;rdquo; Observable variant of the original &amp;ldquo;cold&amp;rdquo; Observable.</source>
          <target state="translated">Поскольку Subject подписывается на Observable, он запускает этот Observable, чтобы начать испускать элементы (если этот Observable &amp;laquo;холодный&amp;raquo; - то есть, если он ожидает подписки, прежде чем он начнет выпускать элементы). Это может привести к тому, что получившийся объект станет &amp;laquo;горячим&amp;raquo; наблюдаемым вариантом исходного &amp;laquo;холодного&amp;raquo; наблюдаемого.</target>
        </trans-unit>
        <trans-unit id="eea3c830df555c58d5b9d3068d47dee7f418f5fe" translate="yes" xml:space="preserve">
          <source>Because it is possible that more than one of the merged Observables encountered an error, &lt;code&gt;mergeDelayError&lt;/code&gt; may pass information about &lt;em&gt;multiple&lt;/em&gt; errors in the &lt;code&gt;onError&lt;/code&gt; notification (it will never invoke the observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method more than once). For this reason, if you want to know the nature of these errors, you should write your observers&amp;rsquo; &lt;code&gt;onError&lt;/code&gt; methods so that they accept a parameter of the class &lt;code&gt;CompositeException&lt;/code&gt;.</source>
          <target state="translated">Поскольку возможно, что более чем один из объединенных Observable обнаружил ошибку, &lt;code&gt;mergeDelayError&lt;/code&gt; может передавать информацию о &lt;em&gt;нескольких&lt;/em&gt; ошибках в уведомлении &lt;code&gt;onError&lt;/code&gt; (он никогда не будет вызывать метод &lt;code&gt;onError&lt;/code&gt; наблюдателя более одного раза). По этой причине, если вы хотите узнать природу этих ошибок, вам следует написать методы &lt;code&gt;onError&lt;/code&gt; для своих наблюдателей, чтобы они принимали параметр класса &lt;code&gt;CompositeException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40504d93089e459126b9f714fa64da0432bf9cb2" translate="yes" xml:space="preserve">
          <source>Before an Observable terminates it must first issue either an OnCompleted or OnError notification to all of the observers that are subscribed to it.</source>
          <target state="translated">Перед тем,как наблюдатель прекратит свою деятельность,он должен сначала уведомить всех наблюдателей,которые на него подписались,либо о том,что он завершил свою деятельность,либо о том,что он совершил ошибку.</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="c7edc1ce6b23272555c0452f3036c8ab489ea4bc" translate="yes" xml:space="preserve">
          <source>Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making them more manageable. You could, for example, close and emit a buffer of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">Буфер может уменьшить последовательность многих элементов до последовательности меньшего количества буферов элементов,делая их более управляемыми.Можно,например,закрывать и испускать буфер элементов из лопнувшего Наблюдаемого периодически,с регулярными интервалами времени.</target>
        </trans-unit>
        <trans-unit id="d726676ef856039a619e5c8fc3b22b65bd1d7d3f" translate="yes" xml:space="preserve">
          <source>But as with Futures, while callbacks are easy to use with a single level of asynchronous execution, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;with nested composition they become unwieldy&lt;/a&gt;.</source>
          <target state="translated">Но, как и в случае с Futures, хотя обратные вызовы просты в использовании с одним уровнем асинхронного выполнения, &lt;a href=&quot;https://gist.github.com/4677544&quot;&gt;с вложенной композицией они становятся громоздкими&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3806ea89275a484caaeb8fb736ffc6a0c360406a" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;delay&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delay&lt;/code&gt;</source>
          <target state="translated">По умолчанию этот вариант &lt;code&gt;delay&lt;/code&gt; работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете выбрать другой планировщик, передав его в качестве необязательного третьего параметра для &lt;code&gt;delay&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="853cd838d6aa239dfebc6fe472f15b378a7e9fd0" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;</source>
          <target state="translated">По умолчанию этот вариант &lt;code&gt;timeout&lt;/code&gt; работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете выбрать другой планировщик, передав его в качестве необязательного третьего параметра для &lt;code&gt;timeout&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27c7c6971a230126aa6e972a720f0bb289a01e7e" translate="yes" xml:space="preserve">
          <source>By default this variant of &lt;code&gt;timeout&lt;/code&gt; operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">По умолчанию этот вариант &lt;code&gt;timeout&lt;/code&gt; работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете выбрать другой планировщик, передав его в качестве необязательного третьего параметра для &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b5e38e8783b4ae293ff3a5deb6299790a6fded1" translate="yes" xml:space="preserve">
          <source>By default, an Observable and the chain of operators that you apply to it will do its work, and will notify its observers, on the same thread on which its &lt;code&gt;Subscribe&lt;/code&gt; method is called. The SubscribeOn operator changes this behavior by specifying a different Scheduler on which the Observable should operate. The ObserveOn operator specifies a different Scheduler that the Observable will use to send notifications to its observers.</source>
          <target state="translated">По умолчанию Observable и цепочка операторов, которые вы применяете к нему, будут выполнять свою работу и уведомлять своих наблюдателей в том же потоке, в котором вызывается его метод &lt;code&gt;Subscribe&lt;/code&gt; . Оператор SubscribeOn изменяет это поведение, указывая другой планировщик, на котором должен работать Observable. Оператор ObserveOn указывает другой планировщик, который Observable будет использовать для отправки уведомлений своим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="349ec7cf4de33246924ed8834527eb97fcddde0c" translate="yes" xml:space="preserve">
          <source>By the terms of &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt;, it may call &lt;code&gt;onNext&lt;/code&gt; zero or more times, and then may follow those calls with a call to either &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; but not both, which will be its last call. By convention, in this document, calls to &lt;code&gt;onNext&lt;/code&gt; are usually called &amp;ldquo;emissions&amp;rdquo; of items, whereas calls to &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; are called &amp;ldquo;notifications.&amp;rdquo;</source>
          <target state="translated">По условиям &lt;a href=&quot;contract&quot;&gt;контракта Observable&lt;/a&gt; он может вызывать &lt;code&gt;onNext&lt;/code&gt; ноль или более раз, а затем может следовать за этими вызовами с вызовом либо &lt;code&gt;onCompleted&lt;/code&gt; , либо &lt;code&gt;onError&lt;/code&gt; , но не обоих, что будет его последним вызовом. По соглашению в этом документе вызовы &lt;code&gt;onNext&lt;/code&gt; обычно называются &amp;laquo;выбросами&amp;raquo; элементов, тогда как вызовы &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; называются &amp;laquo;уведомлениями&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ad7f884b18f0e71ef27dcc9eb107c69b22184b8e" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements at the end of an observable sequence. This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.</source>
          <target state="translated">Обходит определенное количество элементов в конце наблюдаемой последовательности.Этот оператор накапливает очередь длиной,достаточной для хранения первых `считанных` элементов.По мере поступления большего количества элементов,элементы берутся из передней части очереди и выводятся на результирующую последовательность.Это приводит к задержке элементов.</target>
        </trans-unit>
        <trans-unit id="56a26a63bf2967d76012cc29baf8e343e4f53b12" translate="yes" xml:space="preserve">
          <source>Bypasses a specified number of elements in an observable sequence and then returns the remaining elements. Transform the items emitted by an Observable into Observables, and mirror those items emitted by the most-recently transformed Observable. The flatMapLatest operator is similar to the flatMap and concatMap methods described above, however, rather than emitting all of the items emitted by all of the Observables that the operator generates by transforming items from the source Observable, flatMapLatest instead emits items from each such transformed Observable only until the next such Observable is emitted, then it ignores the previous one and begins emitting items emitted by the new one.</source>
          <target state="translated">Обходит определенное количество элементов в наблюдаемой последовательности,а затем возвращает оставшиеся элементы.Преобразовывает элементы,излучаемые наблюдателем,в наблюдаемые и зеркально отражает элементы,излучаемые самым последним преобразованным наблюдателем.Оператор flatMapLatest аналогичен методу flatMap и concatMap,описанному выше,однако,вместо того,чтобы испускать все элементы,испускаемые всеми Observables,которые оператор генерирует,преобразовывая элементы из источника Observable,flatMapLatest вместо этого испускает элементы из каждого такого преобразованного Observable только до тех пор,пока не будет испущен следующий такой Observable,затем он игнорирует предыдущий и начинает испускать элементы,испускаемые новым элементом.</target>
        </trans-unit>
        <trans-unit id="49745efca49c630e89bcd950cbd9b790a40a26ec" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.</source>
          <target state="translated">Обходит элементы в наблюдаемой последовательности до тех пор,пока заданное условие истинно,и затем возвращает оставшиеся элементы.</target>
        </trans-unit>
        <trans-unit id="5074688d8a8d1a7a2f2146111a01a2d5efa03be4" translate="yes" xml:space="preserve">
          <source>Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</source>
          <target state="translated">Обходит элементы в наблюдаемой последовательности до тех пор,пока заданное условие истинно,и затем возвращает оставшиеся элементы.Индекс элемента используется в логике предикатной функции.</target>
        </trans-unit>
        <trans-unit id="78dc0e523eb5336a4517027ee20f8ce8c1283c64" translate="yes" xml:space="preserve">
          <source>Call a &lt;code&gt;ConnectableObservable&lt;/code&gt;&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; method to instruct it to begin emitting the items from its underlying Observable to its Subscribers.</source>
          <target state="translated">Вызов &lt;code&gt;ConnectableObservable&lt;/code&gt; &amp;laquo;ы &lt;code&gt;connect&lt;/code&gt; метод инструктировать его , чтобы начать излучающие элементы из лежащего в его основе Наблюдаемого своих абонентов.</target>
        </trans-unit>
        <trans-unit id="c805453a51ab6e5402991a6b7905abbb82969b88" translate="yes" xml:space="preserve">
          <source>Call a method.</source>
          <target state="translated">Вызывай метод.</target>
        </trans-unit>
        <trans-unit id="846a84e9501ad053efd6f0622ac43a7f2f1a41f9" translate="yes" xml:space="preserve">
          <source>Callbacks Have Their Own Problems</source>
          <target state="translated">У обратных вызовов есть свои проблемы.</target>
        </trans-unit>
        <trans-unit id="5d0513dc45b99b203cc47abe5101858366b0aaa9" translate="yes" xml:space="preserve">
          <source>Callbacks solve the problem of premature blocking on &lt;code&gt;Future.get()&lt;/code&gt; by not allowing anything to block. They are naturally efficient because they execute when the response is ready.</source>
          <target state="translated">&lt;code&gt;Future.get()&lt;/code&gt; решают проблему преждевременной блокировки Future.get () , не позволяя ничего блокировать. Они естественно эффективны, потому что выполняются, когда готов ответ.</target>
        </trans-unit>
        <trans-unit id="fadfad0ea9282bb47746b81a6a4235042d5882c1" translate="yes" xml:space="preserve">
          <source>Canonical, core operator names are in &lt;strong&gt;boldface&lt;/strong&gt;. Other entries represent language-specific variants of these operators or specialty operators outside of the main ReactiveX core set of operators.</source>
          <target state="translated">Канонические, основные имена операторов &lt;strong&gt;выделены жирным шрифтом&lt;/strong&gt; . Другие записи представляют собой языковые варианты этих операторов или специальные операторы, не входящие в основной набор операторов ReactiveX.</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="e6f5247c2c2f3a3279ed51693bfefd3a423b8bf0" translate="yes" xml:space="preserve">
          <source>Chaining Operators</source>
          <target state="translated">цепные операторы</target>
        </trans-unit>
        <trans-unit id="902bd9921de41f5d7e6b42366eb8310a65a2c945" translate="yes" xml:space="preserve">
          <source>Chaining Your Custom Operators with Standard RxJava Operators</source>
          <target state="translated">Привязывание ваших пользовательских операторов к стандартным операторам RxJava</target>
        </trans-unit>
        <trans-unit id="d75951d379af65c103f979b689d8cd3675b822a8" translate="yes" xml:space="preserve">
          <source>Checking or Setting Unsubscribed Status</source>
          <target state="translated">Проверка или настройка статуса &quot;Неподписан&quot;.</target>
        </trans-unit>
        <trans-unit id="4fe96207c9c96f4636acc27e3c848d00d3a71f54" translate="yes" xml:space="preserve">
          <source>Cold Observables are ideal for the reactive pull model of backpressure implemented by some implementations of ReactiveX (which is described elsewhere). Hot Observables typically do not cope well with a reactive pull model, and are better candidates for other flow control strategies, such as the use of the operators described on this page, or operators like &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt;, &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt;, or &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt;.</source>
          <target state="translated">Cold Observables идеальны для реактивной модели противодавления, реализуемой некоторыми реализациями ReactiveX (которая описана в другом месте). Hot Observables обычно плохо справляются с моделью реактивного вытягивания и являются лучшими кандидатами для других стратегий управления потоком, таких как использование операторов, описанных на этой странице, или операторов, таких как &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt; , &lt;a href=&quot;sample&quot;&gt;Sample&lt;/a&gt; , &lt;a href=&quot;debounce&quot;&gt;Debounce&lt;/a&gt; или &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a4a4428705e4ab030e6ba205ec9858d5968be1b" translate="yes" xml:space="preserve">
          <source>Combine an Observable together with another Observable by merging their emissions into a single Observable.</source>
          <target state="translated">Объедините &quot;Наблюдаемое&quot; с другим &quot;Наблюдаемым&quot;,объединив их выбросы в один &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="6eaeb8e90e404219d2475ade2286223421965733" translate="yes" xml:space="preserve">
          <source>CombineLatest</source>
          <target state="translated">CombineLatest</target>
        </trans-unit>
        <trans-unit id="6c3a08025c1d0f1b566061e55f26255f61bfc3ba" translate="yes" xml:space="preserve">
          <source>Combining</source>
          <target state="translated">Combining</target>
        </trans-unit>
        <trans-unit id="88d3a1111da9d1eda1c639562973e23995473442" translate="yes" xml:space="preserve">
          <source>Combining Observables</source>
          <target state="translated">Комбинированные наблюдения</target>
        </trans-unit>
        <trans-unit id="5747c92bf0fa0eeb7e1e03446b2293ecf1be9ebd" translate="yes" xml:space="preserve">
          <source>Composition via Observable Operators</source>
          <target state="translated">Состав через Наблюдательных Операторов</target>
        </trans-unit>
        <trans-unit id="ae5c874513b4df302338425830ff176188a2f641" translate="yes" xml:space="preserve">
          <source>Composition via Single Operators</source>
          <target state="translated">Состав через одного оператора</target>
        </trans-unit>
        <trans-unit id="3304bad3c3afa5d187ab48d870d028da8b016b08" translate="yes" xml:space="preserve">
          <source>Computes the average of an observable sequence of values.</source>
          <target state="translated">Вычисляет среднее значение наблюдаемой последовательности значений.</target>
        </trans-unit>
        <trans-unit id="086146e076b0941ac82db3612259103a8c72834b" translate="yes" xml:space="preserve">
          <source>Computes the sum of a sequence of values</source>
          <target state="translated">Вычисляет сумму последовательности значений</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="af22bc2cd4677bc8c0a76b729fa90aba7f0a85a8" translate="yes" xml:space="preserve">
          <source>Concat waits to subscribe to each additional Observable that you pass to it until the previous Observable completes. Note that because of this, if you try to concatenate a &amp;ldquo;hot&amp;rdquo; Observable, that is, one that begins emitting items immediately and before it is subscribed to, Concat will not see, and therefore will not emit, any items that Observable emits before all previous Observables complete and Concat subscribes to the &amp;ldquo;hot&amp;rdquo; Observable.</source>
          <target state="translated">Concat ожидает подписки на каждый дополнительный Observable, который вы ему передаете, пока не завершится предыдущий Observable. Обратите внимание, что из-за этого, если вы попытаетесь объединить &amp;laquo;горячий&amp;raquo; Observable, то есть тот, который начинает генерировать элементы сразу и до того, как он подписан, Concat не увидит и, следовательно, не будет генерировать любые элементы, которые Observable испускает до все предыдущие Observable завершены, и Concat подписывается на &amp;laquo;горячий&amp;raquo; Observable.</target>
        </trans-unit>
        <trans-unit id="31a49591ac407c790c483a17d515d9fb2a8a38be" translate="yes" xml:space="preserve">
          <source>ConcatMap</source>
          <target state="translated">ConcatMap</target>
        </trans-unit>
        <trans-unit id="7d817faef75bfe91293d3714de7420c6573f23e2" translate="yes" xml:space="preserve">
          <source>Concatenate an observable sequence onto the end of the source observable.</source>
          <target state="translated">Сконцентрируйте наблюдаемую последовательность на конце наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="105eca8e21d6f9c476cc3a553058b085eb5233eb" translate="yes" xml:space="preserve">
          <source>Concatenates a sequence of observable sequences into a single observable sequence.</source>
          <target state="translated">Концентрирует последовательность наблюдаемых последовательностей в одну наблюдаемую последовательность.</target>
        </trans-unit>
        <trans-unit id="769151df54c355c60c55756c44028ce4f3ae5d6a" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean</source>
          <target state="translated">Условный и булевский</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">Условные и булевые операторы</target>
        </trans-unit>
        <trans-unit id="b65463cb6a42a17de514acc4659f7fd331e0876a" translate="yes" xml:space="preserve">
          <source>Connect</source>
          <target state="translated">Connect</target>
        </trans-unit>
        <trans-unit id="1f7db7f19ce7165e91e31ee1d9b3ccf7f4d5ddb2" translate="yes" xml:space="preserve">
          <source>Connectable</source>
          <target state="translated">Connectable</target>
        </trans-unit>
        <trans-unit id="7b18cca5708f430e8e5e76af7d6ca811b7d401af" translate="yes" xml:space="preserve">
          <source>Connectable Observable Operators</source>
          <target state="translated">Подключаемые наблюдаемые операторы</target>
        </trans-unit>
        <trans-unit id="33e15d008d511f3101566a2e25203ef2a3f605a0" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contains</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="0815d31f649e51c84f54caac71abf843ed3f8bb3" translate="yes" xml:space="preserve">
          <source>Continues an observable sequence that is terminated by an exception with the next observable sequence.</source>
          <target state="translated">Продолжает наблюдаемую последовательность,которая завершается исключением со следующей наблюдаемой последовательностью.</target>
        </trans-unit>
        <trans-unit id="6e687c89a4954fc6df4498ea2002f2818d836141" translate="yes" xml:space="preserve">
          <source>Converting Observables</source>
          <target state="translated">Преобразующие наблюдатели</target>
        </trans-unit>
        <trans-unit id="a54800ec0ba74d95f4ae763fd411edb7cb335d1b" translate="yes" xml:space="preserve">
          <source>Converts a promise into an observable</source>
          <target state="translated">Превращает обещание в наблюдаемое</target>
        </trans-unit>
        <trans-unit id="f6fd01b29250836779bf34c8cd915aff0e9c6ef1" translate="yes" xml:space="preserve">
          <source>Converts an Iterator into an observable sequence</source>
          <target state="translated">Преобразует итератор в наблюдаемую последовательность.</target>
        </trans-unit>
        <trans-unit id="ff785cfdb5ffb690f81079fc7680305d01077af0" translate="yes" xml:space="preserve">
          <source>Converts an array to an observable sequence</source>
          <target state="translated">Преобразует массив в наблюдаемую последовательность</target>
        </trans-unit>
        <trans-unit id="66e12969c225cc6d65e18210488acb826eba907e" translate="yes" xml:space="preserve">
          <source>Count</source>
          <target state="translated">Count</target>
        </trans-unit>
        <trans-unit id="6e157c5da4410b7e9de85f5c93026b9176e69064" translate="yes" xml:space="preserve">
          <source>Create</source>
          <target state="translated">Create</target>
        </trans-unit>
        <trans-unit id="3017d922d76f674ffb9131a65a9d9805b40b649a" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence containing a single element which is an array containing all the elements of the source sequence.</source>
          <target state="translated">Создает наблюдаемую последовательность,содержащую один элемент-массив,содержащий все элементы исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="ba20da44f8a1b3b058041022a942932e59185655" translate="yes" xml:space="preserve">
          <source>Creates an observable sequence from a specified subscribeAction callable implementation.</source>
          <target state="translated">Создает наблюдаемую последовательность из определенной вызываемой реализации subscribeAction.</target>
        </trans-unit>
        <trans-unit id="92bf119aef55197510b4be1bbec7191fb09b536e" translate="yes" xml:space="preserve">
          <source>Creating</source>
          <target state="translated">Creating</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">Создание наблюдений</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="7cb67bc80f28063e0c70dca78f5ac1f7a7e27b33" translate="yes" xml:space="preserve">
          <source>DZone</source>
          <target state="translated">DZone</target>
        </trans-unit>
        <trans-unit id="9d15bbaea70fed040952f827d04bf23d37deee20" translate="yes" xml:space="preserve">
          <source>Dave Sexton&amp;rsquo;s blog</source>
          <target state="translated">Блог Дэйва Секстона</target>
        </trans-unit>
        <trans-unit id="ba25d0847d81dc2070dc7517ad59c0bcd4bf477c" translate="yes" xml:space="preserve">
          <source>Debounce</source>
          <target state="translated">Debounce</target>
        </trans-unit>
        <trans-unit id="7ee8d644320fde72f64c3c02faecdd18b75c6696" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxGroovy Observable Operators</source>
          <target state="translated">Планировщики по умолчанию для наблюдаемых операторов RxGroovy</target>
        </trans-unit>
        <trans-unit id="1b9dcde6cb5b0bfc6c5ca51b240a6adb12ef894c" translate="yes" xml:space="preserve">
          <source>Default Schedulers for RxJava 1.x Observable Operators</source>
          <target state="translated">Планировщики по умолчанию для RxJava 1.x Наблюдаемые операторы</target>
        </trans-unit>
        <trans-unit id="123deaeef87eca8cb2b99f856d5107f914acdc3a" translate="yes" xml:space="preserve">
          <source>DefaultIfEmpty</source>
          <target state="translated">DefaultIfEmpty</target>
        </trans-unit>
        <trans-unit id="c4357816d34305505b749a4ff11d936352064da0" translate="yes" xml:space="preserve">
          <source>Defer</source>
          <target state="translated">Defer</target>
        </trans-unit>
        <trans-unit id="530d7bc391670a9d12abc2c95fba599d8d6a4fa3" translate="yes" xml:space="preserve">
          <source>Define a method that does something useful with the return value from the asynchronous call; this method is part of the</source>
          <target state="translated">Определите метод,который делает что-то полезное с возвращаемым значением из асинхронного вызова;этот метод является частью метода</target>
        </trans-unit>
        <trans-unit id="c776a2467c885ed63c4827a40f24318ee838b755" translate="yes" xml:space="preserve">
          <source>Define the asynchronous call itself as an</source>
          <target state="translated">Определите асинхронный вызов как</target>
        </trans-unit>
        <trans-unit id="1d05798be1bf5aad240451b19cea28a1042183aa" translate="yes" xml:space="preserve">
          <source>Define your operator as a public class that implements the &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt;&lt;code&gt;Operator&lt;/code&gt;&lt;/a&gt; interface, like so:</source>
          <target state="translated">Определите своего оператора как общедоступный класс, реализующий интерфейс &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.Operator.html&quot;&gt; &lt;code&gt;Operator&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="24eb06fa1daed4a5e60d45a988c3f8068a35cdf2" translate="yes" xml:space="preserve">
          <source>DelaySubscription</source>
          <target state="translated">DelaySubscription</target>
        </trans-unit>
        <trans-unit id="17582fe13ad63f1268f0a279d97ba7524dcb4b53" translate="yes" xml:space="preserve">
          <source>Delayed and Periodic Schedulers</source>
          <target state="translated">Задержанные и периодические планировщики</target>
        </trans-unit>
        <trans-unit id="b9573648319d57f22c34e294a58048517caa06a5" translate="yes" xml:space="preserve">
          <source>Dematerialize</source>
          <target state="translated">Dematerialize</target>
        </trans-unit>
        <trans-unit id="8a57a3d654adf9c3caf76455456be92d962c8113" translate="yes" xml:space="preserve">
          <source>Dematerializes the explicit notification values of an observable sequence as implicit notifications.</source>
          <target state="translated">Дематериализует явные значения уведомлений наблюдаемой последовательности как неявные уведомления.</target>
        </trans-unit>
        <trans-unit id="4faf2e90a3c1b400f4ee9d8c8176a362bc102d3a" translate="yes" xml:space="preserve">
          <source>Distinct</source>
          <target state="translated">Distinct</target>
        </trans-unit>
        <trans-unit id="1fa9ca2d50e91f64ba10b23625a789d1d514ba76" translate="yes" xml:space="preserve">
          <source>DistinctUntilChanged</source>
          <target state="translated">DistinctUntilChanged</target>
        </trans-unit>
        <trans-unit id="22bdf47be3fd0a53ecdf5d6edbde0a2c6b97f0e0" translate="yes" xml:space="preserve">
          <source>Do</source>
          <target state="translated">Do</target>
        </trans-unit>
        <trans-unit id="990799e2354088401f54e49252cb9cd2887b10be" translate="yes" xml:space="preserve">
          <source>Do not block within your operator.</source>
          <target state="translated">Не блокируйте внутри оператора.</target>
        </trans-unit>
        <trans-unit id="bde4f7dc6a6a9b2fc7ddc5c5285b6941c477da41" translate="yes" xml:space="preserve">
          <source>Each element of the array is produced as an emission. The difference between this method and &lt;code&gt;Observable.just&lt;/code&gt; is that the latter emits the whole array as one emission.</source>
          <target state="translated">Каждый элемент массива создается как излучение. Разница между этим методом и &lt;code&gt;Observable.just&lt;/code&gt; в том, что последний излучает весь массив как одно излучение.</target>
        </trans-unit>
        <trans-unit id="7a91a226ecfae7f33d903980a454ab6aaa9b48e8" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX has its own naming quirks. There is no canonical naming standard, though there are many commonalities between implementations.</source>
          <target state="translated">Каждая языковая реализация ReactiveX имеет свои особенности именования.Канонического стандарта именования не существует,хотя между реализациями есть много общих черт.</target>
        </trans-unit>
        <trans-unit id="cef6d442e8c8b1f7447957e1c9784e5f4cc239dc" translate="yes" xml:space="preserve">
          <source>Each language-specific implementation of ReactiveX implements a set of operators. Although there is much overlap between implementations, there are also some operators that are only implemented in certain implementations. Also, each implementation tends to name its operators to resemble those of similar methods that are already familiar from other contexts in that language.</source>
          <target state="translated">Каждая языковая реализация ReactiveX реализует набор операторов.Несмотря на то,что между реализациями существует большое пересечение,существуют также некоторые операторы,которые реализуются только в определенных реализациях.Кроме того,каждая реализация имеет тенденцию называть свои операторы так,чтобы они напоминали методы,уже знакомые в других контекстах этого языка.</target>
        </trans-unit>
        <trans-unit id="b41b061bd9083507610ef2dcf5baaac02b4db60a" translate="yes" xml:space="preserve">
          <source>ElementAt</source>
          <target state="translated">ElementAt</target>
        </trans-unit>
        <trans-unit id="5c002992eecc90de6e3515445216429d901f6529" translate="yes" xml:space="preserve">
          <source>Emit only those items from an Observable that pass a predicate test.</source>
          <target state="translated">Выпускайте только те предметы из &quot;Наблюдателя&quot;,которые проходят предикатный тест.</target>
        </trans-unit>
        <trans-unit id="3159fe421b3221381b3c778dc1c3c26e4540be37" translate="yes" xml:space="preserve">
          <source>Empty</source>
          <target state="translated">Empty</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">Операторы обработки ошибок</target>
        </trans-unit>
        <trans-unit id="9c83f123791849e254666f68cc88dae689457e0d" translate="yes" xml:space="preserve">
          <source>Errors the observable sequence if no item is emitted in the specified time. When a timeout occurs, this operator errors with an instance of Rx\Exception\TimeoutException</source>
          <target state="translated">Ошибка наблюдаемой последовательности,если в указанное время не выдается ни одного элемента.При наступлении таймаута данный оператор выдает ошибку с экземпляром Rx\Exception\TimeoutException.</target>
        </trans-unit>
        <trans-unit id="8c51d8ac13956137d7379dd1c673b6057e36f8fc" translate="yes" xml:space="preserve">
          <source>Establishing Observers</source>
          <target state="translated">Создание Наблюдателей</target>
        </trans-unit>
        <trans-unit id="ec7a78ddd1e28dabdd3fb142de5c9c3d0907593c" translate="yes" xml:space="preserve">
          <source>Example code showing how similar high-order functions can be applied to an Iterable and an Observable</source>
          <target state="translated">Пример кода,показывающий,как похожие функции высокого порядка могут быть применены к функциям &quot;Iterable&quot; и &quot;Observable&quot;.</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="b3d1e836b8c9937992dbfac26e772ac39afe998a" translate="yes" xml:space="preserve">
          <source>Filtering Observables</source>
          <target state="translated">Фильтрующие наблюдения</target>
        </trans-unit>
        <trans-unit id="8978f6a09cf524ab9596b508a2479904c83591c3" translate="yes" xml:space="preserve">
          <source>Finally, there is an alphabetical list of most of the operators available in the many language-specific implementations of ReactiveX. These link to the page that documents the core operator that most closely resembles the language-specific operator (so, for instance, the Rx.NET &amp;ldquo;SelectMany&amp;rdquo; operator links to the documentation of the FlatMap ReactiveX operator, of which &amp;ldquo;SelectMany&amp;rdquo; is the Rx.NET implementation).</source>
          <target state="translated">Наконец, есть алфавитный список большинства операторов, доступных во многих языковых реализациях ReactiveX. Они ссылаются на страницу, которая документирует основной оператор, который больше всего похож на оператор, зависящий от языка (так, например, оператор Rx.NET &amp;laquo;SelectMany&amp;raquo; ссылается на документацию оператора FlatMap ReactiveX, из которых &amp;laquo;SelectMany&amp;raquo; является Реализация Rx.NET).</target>
        </trans-unit>
        <trans-unit id="9f2160fad1531c502a9ce03c129b6f655416e93f" translate="yes" xml:space="preserve">
          <source>Finally, you can pass it an object that implements either of the &lt;code&gt;Observer&lt;/code&gt; or &lt;code&gt;Subscriber&lt;/code&gt; interfaces. The &lt;code&gt;Observer&lt;/code&gt; interface consists of the three previously-described &amp;ldquo;&lt;code&gt;on&lt;/code&gt;&amp;rdquo; methods. The &lt;code&gt;Subscriber&lt;/code&gt; interface implements these also, and adds a number of additional methods that facilitate reactive pull backpressure and that permit the Subscriber to unsubscribe to an Observable before it completes.</source>
          <target state="translated">Наконец, вы можете передать ему объект, реализующий либо интерфейсы &lt;code&gt;Observer&lt;/code&gt; , либо &lt;code&gt;Subscriber&lt;/code&gt; . Интерфейс &lt;code&gt;Observer&lt;/code&gt; состоит из трех ранее описанных методов &lt;code&gt;on&lt;/code&gt; . Интерфейс &lt;code&gt;Subscriber&lt;/code&gt; реализует их и добавляет ряд дополнительных методов, которые облегчают реактивное обратное давление и позволяют подписчику отказаться от подписки на Observable до его завершения.</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="c5bda5b47fc05cd947485d9dcbc97c118c87af17" translate="yes" xml:space="preserve">
          <source>FlatMap</source>
          <target state="translated">FlatMap</target>
        </trans-unit>
        <trans-unit id="273946dd5d2d1288f9b2aafed80ce36284371ce6" translate="yes" xml:space="preserve">
          <source>For example there is the &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; naming pattern (e.g. &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;). In some contexts such names would indicate methods by means of which event handlers are &lt;em&gt;registered&lt;/em&gt;. In ReactiveX, however, they name the event handlers themselves.</source>
          <target state="translated">Например, есть шаблон именования &lt;code&gt;on&lt;i&gt;Event&lt;/i&gt;&lt;/code&gt; (например, &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; ). В некоторых контекстах такие имена будут указывать на методы, с помощью которых &lt;em&gt;регистрируются&lt;/em&gt; обработчики событий . Однако в ReactiveX они называют сами обработчики событий.</target>
        </trans-unit>
        <trans-unit id="217442e28d51221a4fdad0309844d07ab64be02a" translate="yes" xml:space="preserve">
          <source>For example, imagine using the &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; operator to zip together two infinite Observables, one of which emits items twice as frequently as the other. A naive implementation of the operator would have to maintain an ever-expanding buffer of items emitted by the faster Observable to eventually combine with items emitted by the slower one. This could cause ReactiveX to seize an unwieldy amount of system resources.</source>
          <target state="translated">Например, представьте, что вы используете оператор &lt;a href=&quot;zip&quot;&gt;Zip&lt;/a&gt; для соединения двух бесконечных Observable, один из которых испускает элементы в два раза чаще, чем другой. Наивная реализация оператора должна была бы поддерживать постоянно расширяющийся буфер элементов, генерируемых более быстрым Observable, чтобы в конечном итоге объединиться с элементами, генерируемыми более медленным. Это может привести к тому, что ReactiveX захватит громоздкое количество системных ресурсов.</target>
        </trans-unit>
        <trans-unit id="2c04f7c1d2fb4ddd89c1509683905da7e098003b" translate="yes" xml:space="preserve">
          <source>For example, the following code merges the &lt;code&gt;odds&lt;/code&gt; and &lt;code&gt;evens&lt;/code&gt; into a single Observable. (The &lt;code&gt;subscribeOn&lt;/code&gt; operator makes &lt;code&gt;odds&lt;/code&gt; operate on a different thread from &lt;code&gt;evens&lt;/code&gt; so that the two Observables may both emit items at the same time, to demonstrate how Merge may interleave these items.)</source>
          <target state="translated">Например, следующий код объединяет &lt;code&gt;odds&lt;/code&gt; и &lt;code&gt;evens&lt;/code&gt; в один Observable. (Оператор &lt;code&gt;subscribeOn&lt;/code&gt; заставляет &lt;code&gt;odds&lt;/code&gt; работать в другом потоке, а не в &lt;code&gt;evens&lt;/code&gt; , так что два Observable могут испускать элементы одновременно, чтобы продемонстрировать, как Merge может чередовать эти элементы.)</target>
        </trans-unit>
        <trans-unit id="dc05c0ee12f75173f33b61a359852128b084b9e1" translate="yes" xml:space="preserve">
          <source>For example, the following code takes a list of unsorted integers, converts it into an Observable, then converts that Observable into one that emits the original list in sorted form as a single item:</source>
          <target state="translated">Например,следующий код берет список несортированных целых чисел,преобразует его в Наблюдаемый,затем преобразует этот Наблюдаемый в тот,который излучает исходный список в отсортированном виде в виде одного элемента:</target>
        </trans-unit>
        <trans-unit id="fbbdfcad6b5a5793860447cf0201a70bee8a2b57" translate="yes" xml:space="preserve">
          <source>For example, the following code uses &lt;code&gt;reduce&lt;/code&gt; to compute, and then emit as an Observable, the sum of the numbers emitted by the source Observable:</source>
          <target state="translated">Например, следующий код использует &lt;code&gt;reduce&lt;/code&gt; для вычисления, а затем выдаёт как Observable сумму чисел, выданных исходным Observable:</target>
        </trans-unit>
        <trans-unit id="875655c8a87dcab782ffad12361168b23205728f" translate="yes" xml:space="preserve">
          <source>For example, the following rather pointless code takes a list of integers, converts it into an Observable, then converts that Observable into one that emits the original list as a single item:</source>
          <target state="translated">Например,следующий довольно бессмысленный код берет список целых чисел,преобразует его в &quot;Наблюдаемый&quot;,а затем преобразует этот &quot;Наблюдаемый&quot; в тот,который излучает исходный список в виде одного элемента:</target>
        </trans-unit>
        <trans-unit id="b4afe05eb65cfed34c46b0c5cfa9d72af6ef87ec" translate="yes" xml:space="preserve">
          <source>For the special case of &lt;code&gt;take(0)&lt;/code&gt; you can also pass as a second parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;take&lt;/code&gt; will use to immediately schedule a call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">В особом случае &lt;code&gt;take(0)&lt;/code&gt; вы также можете передать в качестве второго параметра &lt;a href=&quot;../scheduler&quot;&gt;планировщик,&lt;/a&gt; который &lt;code&gt;take&lt;/code&gt; будет использовать для немедленного планирования вызова &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e288d7fa19e1bf4757ab1d8f5269ca19ed723b7" translate="yes" xml:space="preserve">
          <source>For this reason, instead of subscribing to a Single with the three methods you use to respond to notifications from an Observable (</source>
          <target state="translated">По этой причине,вместо того,чтобы подписываться на Single с тремя методами,которые вы используете для ответа на уведомления от Наблюдателя (</target>
        </trans-unit>
        <trans-unit id="2737986da43814cbc95d7c442ca5b8a689aa03a4" translate="yes" xml:space="preserve">
          <source>For this reason, most ReactiveX implementations have methods that allow you to convert certain language-specific objects and data structures into Observables.</source>
          <target state="translated">По этой причине в большинстве реализаций ReactiveX есть методы,позволяющие преобразовывать определенные языковые объекты и структуры данных в Observables.</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="392276019fcc1d5272942bce719b6342fcb81e7b" translate="yes" xml:space="preserve">
          <source>From the Observer&amp;rsquo;s point of view, it doesn&amp;rsquo;t matter!</source>
          <target state="translated">С точки зрения наблюдателя это не имеет значения!</target>
        </trans-unit>
        <trans-unit id="42428a2d2e461a43cab074a94ea7b862a5694eb9" translate="yes" xml:space="preserve">
          <source>Furthermore, some of these names have different implications in other contexts, or seem awkward in the idiom of a particular implementing language.</source>
          <target state="translated">Кроме того,некоторые из этих названий имеют различные последствия в других контекстах или представляются неудобными в идиоме конкретного языка осуществления.</target>
        </trans-unit>
        <trans-unit id="1d3db6203d1cee531e933dc661377957741fd7c7" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.</source>
          <target state="translated">Генерирует наблюдаемую последовательность интегральных чисел в заданном диапазоне,используя указанный планировщик для рассылки сообщений наблюдателя.</target>
        </trans-unit>
        <trans-unit id="92d0f29396a5c34e31ebc967172deef307fe570f" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence that repeats the given element the specified number of times.</source>
          <target state="translated">Генерирует наблюдаемую последовательность,которая повторяет заданное количество раз для данного элемента.</target>
        </trans-unit>
        <trans-unit id="7b53270ad371697bc1e589de2e23706a1f6bcaa9" translate="yes" xml:space="preserve">
          <source>Go on with your business; whenever the call returns, the observer&amp;rsquo;s method will begin to operate on its return value or values &amp;mdash; the</source>
          <target state="translated">Продолжайте заниматься своим делом; всякий раз, когда вызов возвращается, метод наблюдателя начинает работать с возвращаемым значением или значениями -</target>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="5b580ccc31ee66edb3fbe2b6a9872b6baf3565df" translate="yes" xml:space="preserve">
          <source>Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.</source>
          <target state="translated">Группирует элементы наблюдаемой последовательности в соответствии с заданной ключевой селекторной функцией и сравнивает и выбирает результирующие элементы с помощью заданной функции.</target>
        </trans-unit>
        <trans-unit id="ec80db1447579253ebd9672ba573bfff5db58f5b" translate="yes" xml:space="preserve">
          <source>Here is an example that provides its own sorting function: in this case, one that sorts numbers according to how close they are to the number 5.</source>
          <target state="translated">Приведем пример,в котором предусмотрена собственная функция сортировки:в данном случае сортировщик,который сортирует числа в соответствии с тем,насколько они близки к числу 5.</target>
        </trans-unit>
        <trans-unit id="ed3a2bd6db43943919933044f161c73f3f3b3390" translate="yes" xml:space="preserve">
          <source>Hides the identity of an observable sequence.</source>
          <target state="translated">Скрывает идентичность наблюдаемой последовательности.</target>
        </trans-unit>
        <trans-unit id="1f4a28cce6229ef2c4b35941085f06d550791705" translate="yes" xml:space="preserve">
          <source>How is this Observable implemented?</source>
          <target state="translated">Как это &quot;Наблюдаемое&quot; реализовано?</target>
        </trans-unit>
        <trans-unit id="85f43fbd596793edf6bbe3749bc8742ef91cfde4" translate="yes" xml:space="preserve">
          <source>However, if the source Observable terminates with an error, the &lt;code&gt;BehaviorSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Однако, если исходный Observable завершается с ошибкой, &lt;code&gt;BehaviorSubject&lt;/code&gt; не будет передавать какие-либо элементы последующим наблюдателям, а просто передаст уведомление об ошибке от исходного Observable.</target>
        </trans-unit>
        <trans-unit id="77b8c0a40d90b726e62fff83e0e5d057ad8f6562" translate="yes" xml:space="preserve">
          <source>I want an Observable that does not start emitting items to subscribers until asked</source>
          <target state="translated">Я хочу &quot;Наблюдателя&quot;,который не начинает излучать элементы подписчикам,пока не спросит.</target>
        </trans-unit>
        <trans-unit id="96e0c99e2ca6299088acf813f3684ac6db4f290d" translate="yes" xml:space="preserve">
          <source>I want an Observable that will notify observers of an error</source>
          <target state="translated">Я хочу наблюдателя,который уведомит наблюдателей об ошибке.</target>
        </trans-unit>
        <trans-unit id="93ac8f52c641ecf8295c3126651b68566f69ca55" translate="yes" xml:space="preserve">
          <source>I want an Observable to invoke a particular action when certain events occur</source>
          <target state="translated">Я хочу,чтобы наблюдатель вызывал определенное действие,когда происходят определенные события.</target>
        </trans-unit>
        <trans-unit id="71de0f2184ab945ae7071514e5714fa44c58f556" translate="yes" xml:space="preserve">
          <source>I want an Observable to recover gracefully</source>
          <target state="translated">Я хочу,чтобы наблюдатель изящно восстановился</target>
        </trans-unit>
        <trans-unit id="bf4218745ff4559c04307408b48fa3c0d95b2e3c" translate="yes" xml:space="preserve">
          <source>I want an operator to operate on a particular &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">Я хочу, чтобы оператор работал с конкретным &lt;a href=&quot;http://reactivex.io/scheduler.html&quot;&gt;планировщиком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bcee030a9b0fc7754e86e874779c1dd0d6fbcf4" translate="yes" xml:space="preserve">
          <source>I want to collect items from an Observable and reemit them as buffers of items</source>
          <target state="translated">Я хочу собирать предметы из Наблюдаемого и возвращать их в качестве буферов предметов.</target>
        </trans-unit>
        <trans-unit id="9da6c79bd44786fa9d805be97358190877889323" translate="yes" xml:space="preserve">
          <source>I want to convert the entire sequence of items emitted by an Observable into some other data structure</source>
          <target state="translated">Я хочу преобразовать всю последовательность элементов,испускаемых наблюдателем,в какую-то другую структуру данных.</target>
        </trans-unit>
        <trans-unit id="99621e91d6f81783ccbca5febefcff99798c51ba" translate="yes" xml:space="preserve">
          <source>I want to create a new Observable</source>
          <target state="translated">Я хочу создать новый Наблюдательный</target>
        </trans-unit>
        <trans-unit id="e95392e6ebe4cd2b8d976a6b5dc15ebcc8652c19" translate="yes" xml:space="preserve">
          <source>I want to create a resource that has the same lifespan as the Observable</source>
          <target state="translated">Я хочу создать ресурс,который будет иметь такую же продолжительность жизни,как и &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="e1e5a804f40a4ae53ad6d865409b7eb39972641d" translate="yes" xml:space="preserve">
          <source>I want to create an Observable by combining other Observables</source>
          <target state="translated">Я хочу создать Наблюдателя,комбинируя другие Наблюдатели.</target>
        </trans-unit>
        <trans-unit id="bba42083fc42c06c02ced02fc27975097eda340f" translate="yes" xml:space="preserve">
          <source>I want to emit the items from an Observable after transforming them</source>
          <target state="translated">Я хочу излучать предметы от Наблюдателя после их трансформации.</target>
        </trans-unit>
        <trans-unit id="678a797d3d44a8e136336de41859f44d87ea12d0" translate="yes" xml:space="preserve">
          <source>I want to evaluate the entire sequence of items emitted by an Observable</source>
          <target state="translated">Я хочу оценить всю последовательность элементов,излучаемых Наблюдателем.</target>
        </trans-unit>
        <trans-unit id="342d9df0dc00c6409e061ccbe8bd7a43ec0f1e2f" translate="yes" xml:space="preserve">
          <source>I want to ignore all items emitted by an Observable and only pass along its completed/error notification</source>
          <target state="translated">Я хочу проигнорировать все элементы,излучаемые наблюдателем,и пройти только по его завершенному/уведомлению об ошибке.</target>
        </trans-unit>
        <trans-unit id="ac1e59137d512a13724ce068546bdef43aa1b2cf" translate="yes" xml:space="preserve">
          <source>I want to mirror an Observable but prefix items to its sequence</source>
          <target state="translated">Я хочу зеркально отобразить Наблюдаемые,но префиксные элементы в его последовательности.</target>
        </trans-unit>
        <trans-unit id="7bdd0d540cc5c4d1feeab4c1bf757d0bb5b1651e" translate="yes" xml:space="preserve">
          <source>I want to reemit items from an Observable only on condition that it was the first of a collection of Observables to emit an item</source>
          <target state="translated">Я хочу получить предметы из &quot;Наблюдателя&quot; только при условии,что он был первым из коллекции &quot;Наблюдателей&quot;,который выпустил предмет.</target>
        </trans-unit>
        <trans-unit id="afea5ad42757cc0909b83ee4ce1bb6c62bd02f89" translate="yes" xml:space="preserve">
          <source>I want to reemit only certain items from an Observable</source>
          <target state="translated">Я хочу вернуть только некоторые вещи от Наблюдателя.</target>
        </trans-unit>
        <trans-unit id="55e5e42e408215716d6b5f291913c77f52df5dd6" translate="yes" xml:space="preserve">
          <source>I want to retrieve a particular item emitted by an Observable:</source>
          <target state="translated">Я хочу получить конкретный предмет,излучаемый Наблюдателем:</target>
        </trans-unit>
        <trans-unit id="386e533e7f72fc5f43c8113497f862fc5eede916" translate="yes" xml:space="preserve">
          <source>I want to shift the items emitted by an Observable forward in time before reemitting them</source>
          <target state="translated">Я хочу сдвинуть предметы,излучаемые Наблюдателем,вперед по времени,прежде чем возвращать их.</target>
        </trans-unit>
        <trans-unit id="86a6925e0701483bb01af42b8def481ec4f9b265" translate="yes" xml:space="preserve">
          <source>I want to split one Observable into multiple Observables</source>
          <target state="translated">Я хочу разделить одну Наблюдаемую на несколько Наблюдаемых.</target>
        </trans-unit>
        <trans-unit id="51428b8b50c14765922c8b036cca4988742e7efd" translate="yes" xml:space="preserve">
          <source>I want to subscribe to an Observable and receive a &lt;code&gt;Future&lt;/code&gt; that blocks until the Observable completes</source>
          <target state="translated">Я хочу подписаться на Observable и получить &lt;code&gt;Future&lt;/code&gt; , который блокируется, пока Observable не завершится</target>
        </trans-unit>
        <trans-unit id="1e67d5551cb9e7fce5308aac618b27ccc290f104" translate="yes" xml:space="preserve">
          <source>I want to transform items &lt;em&gt;and&lt;/em&gt; notifications from an Observable into items and reemit them</source>
          <target state="translated">Я хочу преобразовать элементы &lt;em&gt;и&lt;/em&gt; уведомления из Observable в элементы и повторно отправить их</target>
        </trans-unit>
        <trans-unit id="caced85795e91d7af9dfe4ed9e1f46fd5fea7321" translate="yes" xml:space="preserve">
          <source>If a second observer subscribes to an Observable that is already emitting items to a first observer, it is up to the Observable whether it will thenceforth emit the same items to each observer, or whether it will replay the complete sequence of items from the beginning to the second observer, or whether it will emit a wholly different sequence of items to the second observer. There is no general guarantee that two observers of the same Observable will see the same sequence of items.</source>
          <target state="translated">Если второй наблюдатель подписывается на Наблюдателя,который уже испускает предметы первому наблюдателю,то от Наблюдателя зависит,будет ли он испускать те же самые предметы каждому наблюдателю,или же он будет переигрывать полную последовательность предметов от начала до второго наблюдателя,или же он будет испускать совершенно другую последовательность предметов второму наблюдателю.Нет общей гарантии,что два наблюдателя одного и того же Наблюдателя увидят одну и ту же последовательность предметов.</target>
        </trans-unit>
        <trans-unit id="a0ef7637d7666db7b1cac27130564f15f9858d6b" translate="yes" xml:space="preserve">
          <source>If an Observable has not issued an OnCompleted or OnError notification, an observer may consider it to be still active (even if it is not currently emitting items) and may issue it notifications (such as an Unsubscribe or Request notification). When an Observable does issue an OnCompleted or OnError notification, the Observable may release its resources and terminate, and its observers should not attempt to communicate with it any further.</source>
          <target state="translated">Если Наблюдатель не выпустил уведомление о OnCompleteted или OnError,наблюдатель может считать,что он все еще активен (даже если в данный момент он не испускает элементы)и может выдать ему уведомления (например,уведомление об отказе от подписки или уведомление о запросе).Когда Наблюдатель все-таки издает Заполненное уведомление или Уведомление об Ошибке,Наблюдатель может высвободить свои ресурсы и прекратить работу,а его наблюдатели не должны пытаться общаться с ним дальше.</target>
        </trans-unit>
        <trans-unit id="ec7b046dde03b5ea699c95f5183b34be3f0cf4c2" translate="yes" xml:space="preserve">
          <source>If an Observable implements backpressure and its observer employs backpressure, the Observable will not begin to emit items to the observer immediately upon subscription. Instead, it will issue an OnSubscribe notification to the observer.</source>
          <target state="translated">Если наблюдаемый создает противодавление,а его наблюдатель использует противодавление,он не начнет излучать предметы наблюдателю сразу же после подписки.Вместо этого,он будет выдавать наблюдателю уведомление о подписке.</target>
        </trans-unit>
        <trans-unit id="733ae6509dbabf4aba675cc3ed47501f58834086" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;mergeAll&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the resulting Observable will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">Если любой из отдельных Observable, переданных в &lt;code&gt;merge&lt;/code&gt; или &lt;code&gt;mergeAll&lt;/code&gt; , завершается уведомлением &lt;code&gt;onError&lt;/code&gt; , результирующий Observable немедленно завершается с &lt;code&gt;onError&lt;/code&gt; уведомлением . Если вы предпочитаете слияние, которое продолжает выдавать результаты оставшихся безошибочных Observables перед сообщением об ошибке, используйте вместо этого &lt;code&gt;mergeDelayError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd3e9e82373d3dfce17c1d4311251fdd13222d5" translate="yes" xml:space="preserve">
          <source>If any of the individual Observables passed into &lt;code&gt;merge&lt;/code&gt; terminates with an &lt;code&gt;onError&lt;/code&gt; notification, the Observable produced by &lt;code&gt;merge&lt;/code&gt; itself will immediately terminate with an &lt;code&gt;onError&lt;/code&gt; notification. If you would prefer a merge that continues emitting the results of the remaining, error-free Observables before reporting the error, use &lt;code&gt;mergeDelayError&lt;/code&gt; instead.</source>
          <target state="translated">Если какой-либо из отдельных Observable, переданных в &lt;code&gt;merge&lt;/code&gt; завершается уведомлением &lt;code&gt;onError&lt;/code&gt; , Observable, созданный самим &lt;code&gt;merge&lt;/code&gt; , немедленно завершается с &lt;code&gt;onError&lt;/code&gt; уведомлением . Если вы предпочитаете слияние, которое продолжает выдавать результаты оставшихся безошибочных Observables перед сообщением об ошибке, используйте вместо этого &lt;code&gt;mergeDelayError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d250294c4e6c5532d682c6ee0dcbdc73daefb50" translate="yes" xml:space="preserve">
          <source>If instead you want the Observable to emit a default value in such a case, you can pass a second parameter (named &lt;code&gt;defaultValue&lt;/code&gt;) to &lt;code&gt;last&lt;/code&gt;:</source>
          <target state="translated">Если вместо этого вы хотите, чтобы Observable выдавал значение по умолчанию в таком случае, вы можете передать второй параметр (с именем &lt;code&gt;defaultValue&lt;/code&gt; ) в &lt;code&gt;last&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="72eba74aab57235e91614104d881cad347d5f3c6" translate="yes" xml:space="preserve">
          <source>If the Observable produces more items than the observer requests, it is up to the Observable whether it will discard the excess items, store them to emit at a later time, or use some other strategy to deal with the overflow.</source>
          <target state="translated">Если &quot;Наблюдатель&quot; производит больше элементов,чем требует наблюдатель,то &quot;Наблюдатель&quot; должен решить,будет ли он избавляться от лишних элементов,хранить их для испускания в более позднее время или использовать какую-либо другую стратегию для борьбы с переполнением.</target>
        </trans-unit>
        <trans-unit id="574236c3473cbd9e1a8324c3c8b4368c27b83052" translate="yes" xml:space="preserve">
          <source>If the predicate function returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; will increment the tally of items that it will report when the source Observable completes. If you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable, simply pass &lt;code&gt;count&lt;/code&gt; a predicate that always returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">Если функция предиката возвращает &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; будет увеличивать количество элементов, о которых она сообщит, когда исходный Observable завершится. Если вы хотите подсчитать &lt;em&gt;все&lt;/em&gt; элементы, испускаемые исходным Observable, просто передайте &lt;code&gt;count&lt;/code&gt; предикат, который всегда возвращает &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8eef9a5d07bff0abbbfddd99e1e6d78b055ea35c" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;first&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">Если исходный Observable не испускает никаких элементов (или элементов, соответствующих предикату), &lt;code&gt;first&lt;/code&gt; будет завершено сообщение &amp;laquo; &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;rdquo; &lt;code&gt;onError&lt;/code&gt; уведомление.</target>
        </trans-unit>
        <trans-unit id="9453ca79c20e7c3d4fd2ab97401f3e8fafa02aee" translate="yes" xml:space="preserve">
          <source>If the source Observable emits no items (or no items that match the predicate), &lt;code&gt;last&lt;/code&gt; will terminate with a &amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo; &lt;code&gt;onError&lt;/code&gt; notification.</source>
          <target state="translated">Если исходный Observable не испускает никаких элементов (или элементов, соответствующих предикату), &lt;code&gt;last&lt;/code&gt; завершится сообщением &amp;laquo; &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;rdquo; &lt;code&gt;onError&lt;/code&gt; уведомление.</target>
        </trans-unit>
        <trans-unit id="aa8c354d5fd059c1f261a3b43af7ba6bf089e618" translate="yes" xml:space="preserve">
          <source>If the source Observable invokes &lt;code&gt;onCompleted&lt;/code&gt; before emitting any items, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will emit an empty list before invoking &lt;code&gt;onCompleted&lt;/code&gt;. If the source Observable invokes &lt;code&gt;onError&lt;/code&gt;, the Observable returned by &lt;code&gt;toList&lt;/code&gt; will immediately invoke the &lt;code&gt;onError&lt;/code&gt; methods of its observers.</source>
          <target state="translated">Если исходный Observable вызывает &lt;code&gt;onCompleted&lt;/code&gt; перед выдачей каких-либо элементов, Observable, возвращаемый &lt;code&gt;toList&lt;/code&gt; , будет выдавать пустой список перед вызовом &lt;code&gt;onCompleted&lt;/code&gt; . Если исходный Observable вызывает &lt;code&gt;onError&lt;/code&gt; , Observable, возвращаемый &lt;code&gt;toList&lt;/code&gt; , немедленно вызовет методы &lt;code&gt;onError&lt;/code&gt; своих наблюдателей.</target>
        </trans-unit>
        <trans-unit id="ecb1875188746c3fc8a2a22c90eacf4a3b187726" translate="yes" xml:space="preserve">
          <source>If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.</source>
          <target state="translated">Если источник &quot;Наблюдаемый&quot; пуст,он возвращает &quot;Наблюдаемый&quot;,который испускает истину,в противном случае он испускает ложь.</target>
        </trans-unit>
        <trans-unit id="2e65b113c5ab2efc19f456b3ae0c066cd172ca0d" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, Count will pass this error notification along without emitting an item first. If the source Observable does not terminate at all, Count will neither emit an item nor terminate.</source>
          <target state="translated">Если источник &quot;Наблюдаемый&quot; заканчивается с ошибкой,счетчик передает это уведомление об ошибке,не выдавая сначала элемент.Если источник &quot;Наблюдаемый&quot; не завершается вообще,счетчик не передает сообщение об ошибке и не завершается.</target>
        </trans-unit>
        <trans-unit id="f688a0570f5d1b8ac889532c92767877018306e3" translate="yes" xml:space="preserve">
          <source>If the source Observable terminates with an error, the &lt;code&gt;PublishSubject&lt;/code&gt; will not emit any items to subsequent observers, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Если исходный Observable завершается с ошибкой, &lt;code&gt;PublishSubject&lt;/code&gt; не будет передавать какие-либо элементы последующим наблюдателям, а просто передаст уведомление об ошибке из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="9bb4470ea625098ffc957da0e83887d5445085ec" translate="yes" xml:space="preserve">
          <source>If there is no element in the source sequence with the index value you specify, &lt;code&gt;elementAt&lt;/code&gt; will issue an &lt;code&gt;onError&lt;/code&gt; notification: &amp;ldquo;&lt;code&gt;Argument out of range&lt;/code&gt;&amp;rdquo;</source>
          <target state="translated">Если нет элемента в исходной последовательности со значением индекса вы укажете, &lt;code&gt;elementAt&lt;/code&gt; выдаст &lt;code&gt;onError&lt;/code&gt; уведомление: &amp;laquo; &lt;code&gt;Argument out of range&lt;/code&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0e894ab20d3a46c26c42e98c6dfcddf872f60c1f" translate="yes" xml:space="preserve">
          <source>If you apply the Replay operator to an Observable before you convert it into a connectable Observable, the resulting connectable Observable will always emit the same complete sequence to any future observers, even those observers that subscribe after the connectable Observable has begun to emit items to other subscribed observers.</source>
          <target state="translated">Если вы примените оператор Replay к наблюдателю до преобразования его в подключаемый наблюдатель,то в результате подключаемый наблюдатель всегда будет излучать одну и ту же полную последовательность любым будущим наблюдателям,даже тем наблюдателям,которые подписались на него после того,как подключаемый наблюдатель начал излучать элементы другим подписавшимся наблюдателям.</target>
        </trans-unit>
        <trans-unit id="3097ba365bdc02567dbcce3f4aa13b9f891570a9" translate="yes" xml:space="preserve">
          <source>If you are only interested in the first item emitted by an Observable, or the first item that meets some criteria, you can filter the Observable with the First operator.</source>
          <target state="translated">Если вас интересует только первый элемент,излучаемый наблюдателем,или первый элемент,отвечающий некоторым критериям,вы можете отфильтровать наблюдателя с помощью оператора &quot;Первый&quot;.</target>
        </trans-unit>
        <trans-unit id="52c46bce5c8de030e8f87b590429e41a9b0aa7c5" translate="yes" xml:space="preserve">
          <source>If you are only interested in the last item emitted by an Observable, or the last item that meets some criteria, you can filter the Observable with the Last operator.</source>
          <target state="translated">Если вас интересует только последний элемент,излучаемый наблюдателем,или последний элемент,отвечающий некоторым критериям,вы можете отфильтровать наблюдаемого с помощью оператора Last (Последний).</target>
        </trans-unit>
        <trans-unit id="cde6dfb819e5be751bb6438b8bc1e8380bd27d52" translate="yes" xml:space="preserve">
          <source>If you are unable to guarantee that your operator conforms to the above two tenets, you can add the &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt;&lt;code&gt;serialize( )&lt;/code&gt;&lt;/a&gt; operator to it to force the correct behavior.</source>
          <target state="translated">Если вы не можете гарантировать, что ваш оператор соответствует двум указанным выше принципам, вы можете добавить к нему оператор &lt;a href=&quot;observable-utility-operators#serialize&quot;&gt; &lt;code&gt;serialize( )&lt;/code&gt; &lt;/a&gt; чтобы добиться правильного поведения.</target>
        </trans-unit>
        <trans-unit id="2cb580494f8e2917761a21353dfc55e61852dd40" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausable&lt;/code&gt; operator, it will drop (ignore) any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will continue to pass along emitted items to its observers.</source>
          <target state="translated">Если вы вызываете метод &lt;code&gt;pause&lt;/code&gt; для &lt;code&gt;PausableObservable&lt;/code&gt; , созданного с &lt;code&gt;pausable&lt;/code&gt; оператора pausable , он отбрасывает (игнорирует) любые элементы, испускаемые базовым источником Observable до тех пор, пока вы не вызовете его &lt;code&gt;resume&lt;/code&gt; метод , после чего он продолжит передавать испущенные элементы своему наблюдатели.</target>
        </trans-unit>
        <trans-unit id="0ebf1e42c4df41cf02c078fef78bef390ab290dc" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;pause&lt;/code&gt; method of a &lt;code&gt;PausableObservable&lt;/code&gt; created with the &lt;code&gt;pausableBuffered&lt;/code&gt; operator, it will buffer any items emitted by the underlying source Observable until such time as you call its &lt;code&gt;resume&lt;/code&gt; method, whereupon it will emit those buffered items and then continue to pass along any additional emitted items to its observers.</source>
          <target state="translated">Если вы вызываете метод &lt;code&gt;pause&lt;/code&gt; объекта &lt;code&gt;PausableObservable&lt;/code&gt; , созданного с &lt;code&gt;pausableBuffered&lt;/code&gt; оператора pausableBuffered , он буферизует любые элементы, испускаемые базовым источником Observable, до тех пор, пока вы не вызовете его &lt;code&gt;resume&lt;/code&gt; метод , после чего он выдаст эти буферизованные элементы, а затем продолжит передавать любые дополнительные отправленные предметы своим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="0c2ab002bb963be41d5c16f8da5e55d6b8a3fce9" translate="yes" xml:space="preserve">
          <source>If you do not care about the items being emitted by an Observable, but you do want to be notified when it completes or when it terminates with an error, you can apply the &lt;code&gt;ignoreElements&lt;/code&gt; operator to the Observable, which will ensure that it will never call its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt; handlers.</source>
          <target state="translated">Если вас не интересуют элементы, генерируемые Observable, но вы хотите получать уведомления, когда он завершается или когда он завершается с ошибкой, вы можете применить оператор &lt;code&gt;ignoreElements&lt;/code&gt; к Observable, который гарантирует, что он никогда не будет вызывать обработчики &lt;code&gt;onNext&lt;/code&gt; его наблюдателей .</target>
        </trans-unit>
        <trans-unit id="1d22ca088df792825f2a6dd1d5192358b2d0b360" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window&lt;/code&gt; uses the &lt;code&gt;computation&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Если вы не укажете планировщик, этот вариант &lt;code&gt;window&lt;/code&gt; по умолчанию использует планировщик &lt;code&gt;computation&lt;/code&gt; для своего таймера.</target>
        </trans-unit>
        <trans-unit id="100e150c378c4889cd317549f1e83b99541904e3" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Если вы не укажете планировщик, этот вариант &lt;code&gt;windowWithTime&lt;/code&gt; по умолчанию использует планировщик &lt;code&gt;timeout&lt;/code&gt; для своего таймера.</target>
        </trans-unit>
        <trans-unit id="888dd3de98d14ac68c9106daa319827d52cfb772" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Если вы не укажете Scheduler, этот вариант &lt;code&gt;windowWithTimeOrCount&lt;/code&gt; использует &lt;code&gt;timeout&lt;/code&gt; планировщик для своего таймера.</target>
        </trans-unit>
        <trans-unit id="b2211604bc2e7c059844a1087c3b24f75a19cf04" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Если вы не указываете планировщик, этот вариант &lt;code&gt;window_with_time&lt;/code&gt; по умолчанию использует планировщик &lt;code&gt;timeout&lt;/code&gt; для своего таймера.</target>
        </trans-unit>
        <trans-unit id="c494ea4ea43f0b89b77c160f3bc5c87d3d7f3fd4" translate="yes" xml:space="preserve">
          <source>If you do not specify a Scheduler, this variant of &lt;code&gt;window_with_time_or_count&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler for its timer by default.</source>
          <target state="translated">Если вы не укажете Scheduler, этот вариант &lt;code&gt;window_with_time_or_count&lt;/code&gt; по умолчанию использует &lt;code&gt;timeout&lt;/code&gt; Scheduler для своего таймера.</target>
        </trans-unit>
        <trans-unit id="d565ade5214a4fb6f8454dd74c4548834ae2dc50" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Subject&lt;/code&gt; and you want to pass it along to some other agent without exposing its &lt;code&gt;Subscriber&lt;/code&gt; interface, you can mask it by calling its &lt;code&gt;asObservable&lt;/code&gt; method, which will return the Subject as a pure &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="translated">Если у вас есть &lt;code&gt;Subject&lt;/code&gt; и вы хотите передать его какому-то другому агенту, не раскрывая его интерфейс &lt;code&gt;Subscriber&lt;/code&gt; , вы можете замаскировать его, вызвав его метод &lt;code&gt;asObservable&lt;/code&gt; , который вернет Subject как чистый &lt;code&gt;Observable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f599ae77d4264a95da87490e66763c1573b59a6f" translate="yes" xml:space="preserve">
          <source>If you pass an Enumerable or Observable of Observables, you have the option of also passing in an integer indicating the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Если вы передаете Enumerable или Observable of Observables, у вас есть возможность также передать целое число, указывающее максимальное количество тех Observable, на которые он должен пытаться подписаться одновременно. Как только он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57eb4e1625176691f9e6cc11d8fa0b29717c9f7b" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">Если вы передадите отрицательное значение индекса, &lt;code&gt;elementAt&lt;/code&gt; выдаст исключение &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd08e0ec3efa5ea25eaca8fcf04453442b6d2375" translate="yes" xml:space="preserve">
          <source>If you pass in a negative index value, or if the source Observable emits fewer than &lt;code&gt;&lt;i&gt;index
       value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; items, &lt;code&gt;elementAt&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;.</source>
          <target state="translated">Если вы передадите отрицательное значение индекса или если исходный Observable излучает меньше, чем &lt;code&gt;&lt;i&gt;index value&lt;/i&gt;&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; , &lt;code&gt;elementAt&lt;/code&gt; выдаст исключение &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb67bd2fcbd71bad891a7d78a921dd997297707" translate="yes" xml:space="preserve">
          <source>If you pass in an Observable of Observables, you have the option of also passing in a value indicating to &lt;code&gt;merge&lt;/code&gt; the maximum number of those Observables it should attempt to be subscribed to simultaneously. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Если вы передаете Observable of Observables, у вас есть возможность также передать значение, указывающее на &lt;code&gt;merge&lt;/code&gt; максимального количества тех Observable, на которые он должен пытаться подписаться одновременно. Как только он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb5aeff66e4f4beed635dbbd159c10910227639f" translate="yes" xml:space="preserve">
          <source>If you pass it no parameters, it will trigger a subscription to the underlying Observable, but will ignore its emissions and notifications. This will activate a cold Observable.</source>
          <target state="translated">Если вы не передадите ему никаких параметров,он вызовет подписку на базовый Наблюдаемый,но проигнорирует его выбросы и уведомления.Это активирует холодный Наблюдаемый.</target>
        </trans-unit>
        <trans-unit id="cc00be547db596f59e064ee2c08761c5578d5d79" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, or if an operator like &lt;code&gt;take&lt;/code&gt; that you apply to the &lt;code&gt;GroupedObservable&lt;/code&gt; unsubscribes from it, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a &lt;em&gt;new&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; to match the key. In other words, unsubscribing from a &lt;code&gt;GroupedObservable&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; cause &lt;code&gt;groupBy&lt;/code&gt; to swallow items from its group. For example, see the following code:</source>
          <target state="translated">Если вы &lt;code&gt;GroupedObservable&lt;/code&gt; от подписки на один из GroupedObservable или если такой оператор, как &lt;code&gt;take&lt;/code&gt; , который вы применяете к &lt;code&gt;GroupedObservable&lt;/code&gt; , отписывается от него, этот &lt;code&gt;GroupedObservable&lt;/code&gt; будет прекращен. Если исходный Observable позже испускает элемент, ключ которого совпадает с &lt;code&gt;GroupedObservable&lt;/code&gt; , который был прекращен таким образом, &lt;code&gt;groupBy&lt;/code&gt; создаст и испустит &lt;em&gt;новый &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; , соответствующий ключу. Другими словами, &lt;code&gt;GroupedObservable&lt;/code&gt; от подписки на GroupedObservable &lt;em&gt;не&lt;/em&gt; приведет к тому, что groupBy будет &lt;code&gt;groupBy&lt;/code&gt; элементы из своей группы. Например, см. Следующий код:</target>
        </trans-unit>
        <trans-unit id="f27ee58c426e22c185bfcc111ee4433c42e68d05" translate="yes" xml:space="preserve">
          <source>If you unsubscribe from one of the &lt;code&gt;GroupedObservable&lt;/code&gt;s, that &lt;code&gt;GroupedObservable&lt;/code&gt; will be terminated. If the source Observable later emits an item whose key matches the &lt;code&gt;GroupedObservable&lt;/code&gt; that was terminated in this way, &lt;code&gt;groupBy&lt;/code&gt; will create and emit a new &lt;code&gt;GroupedObservable&lt;/code&gt; to match the key.</source>
          <target state="translated">Если вы откажетесь от подписки на один из &lt;code&gt;GroupedObservable&lt;/code&gt; , этот &lt;code&gt;GroupedObservable&lt;/code&gt; будет прекращен. Если исходный Observable позже испускает элемент, ключ которого соответствует &lt;code&gt;GroupedObservable&lt;/code&gt; , который был завершен таким образом, &lt;code&gt;groupBy&lt;/code&gt; создаст и испустит новый &lt;code&gt;GroupedObservable&lt;/code&gt; соответствующий ключу.</target>
        </trans-unit>
        <trans-unit id="54bb9339c9f0a6407d30c5087cb9c774545f641e" translate="yes" xml:space="preserve">
          <source>If you use a &lt;code&gt;ReplaySubject&lt;/code&gt; as an observer, take care not to call its &lt;code&gt;onNext&lt;/code&gt; method (or its other &lt;code&gt;on&lt;/code&gt; methods) from multiple threads, as this could lead to coincident (non-sequential) calls, which violates &lt;a href=&quot;contract&quot;&gt;the Observable contract&lt;/a&gt; and creates an ambiguity in the resulting Subject as to which item or notification should be replayed first.</source>
          <target state="translated">Если вы используете &lt;code&gt;ReplaySubject&lt;/code&gt; в качестве наблюдателя, будьте осторожны, чтобы не вызывать его метод &lt;code&gt;onNext&lt;/code&gt; (или его другие методы &lt;code&gt;on&lt;/code&gt; ) из нескольких потоков, так как это может привести к совпадающим (непоследовательным) вызовам, что нарушает &lt;a href=&quot;contract&quot;&gt;контракт Observable.&lt;/a&gt; и создает неоднозначность в итоговой теме, какой элемент или уведомление следует воспроизвести в первую очередь.</target>
        </trans-unit>
        <trans-unit id="ee0d3520b5f3d10a48dc017e12fbce21ddb7dc02" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator (or its synonym, &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt;) on an Observable, and that Observable emits fewer than</source>
          <target state="translated">Если вы используете оператор &lt;code&gt;take(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; (или его синоним &lt;code&gt;limit(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; ) на Observable, и этот Observable излучает меньше, чем</target>
        </trans-unit>
        <trans-unit id="cb665f0140ca7cfd676978a94899df0df149f98a" translate="yes" xml:space="preserve">
          <source>If you want an Observable to emit a specific sequence of items before it begins emitting the items normally expected from it, apply the StartWith operator to it.</source>
          <target state="translated">Если Вы хотите,чтобы наблюдаемый испускал определенную последовательность элементов до того,как он начнет испускать элементы,обычно ожидаемые от него,применяйте к нему оператор StartWith.</target>
        </trans-unit>
        <trans-unit id="ed9b26cc4846dd7ff3a51b44674d518103045141" translate="yes" xml:space="preserve">
          <source>If you want to convert an Observable that may emit multiple items into a &lt;code&gt;Future&lt;/code&gt;, try something like this: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите преобразовать Observable, который может испускать несколько элементов в &lt;code&gt;Future&lt;/code&gt; , попробуйте что-нибудь вроде этого: &lt;code&gt;myObservable.toList().toBlocking().toFuture()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="126fda7bd3aebaa0b8ff116732464d2b0b7d7b8b" translate="yes" xml:space="preserve">
          <source>If you want to implement your own operator, see &lt;a href=&quot;implement-operator&quot;&gt;Implementing Your Own Operators&lt;/a&gt;.</source>
          <target state="translated">Если вы хотите реализовать собственный оператор, см. &lt;a href=&quot;implement-operator&quot;&gt;Раздел &amp;laquo;Реализация собственных операторов&amp;raquo;.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f09f724f096a4aeef1d6681ca23a57c6938f183" translate="yes" xml:space="preserve">
          <source>If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular</source>
          <target state="translated">Если вы хотите ввести многопоточность в ваш каскад наблюдаемых операторов,вы можете сделать это,дав указание этим операторам (или определенным наблюдателям)оперировать с конкретными</target>
        </trans-unit>
        <trans-unit id="bf253b6526751dab305e3b5af636233ab2cfc540" translate="yes" xml:space="preserve">
          <source>If your operator is designed to &lt;em&gt;originate&lt;/em&gt; an Observable, rather than to transform or react to a source Observable, use the &lt;a href=&quot;operators/create&quot;&gt;&lt;code&gt;create( )&lt;/code&gt;&lt;/a&gt; method rather than trying to implement &lt;code&gt;Observable&lt;/code&gt; manually. Otherwise, follow the instructions below.</source>
          <target state="translated">Если ваш оператор предназначен для &lt;em&gt;происходит&lt;/em&gt; наблюдаемый, вместо того , чтобы трансформировать или реагировать на источник наблюдаемого, используйте &lt;a href=&quot;operators/create&quot;&gt; &lt;code&gt;create( )&lt;/code&gt; &lt;/a&gt; метод , а не пытаться реализовать &lt;code&gt;Observable&lt;/code&gt; вручную. В противном случае следуйте приведенным ниже инструкциям.</target>
        </trans-unit>
        <trans-unit id="1a4b5013699939e2ed2c63f5435fe7f247de7353" translate="yes" xml:space="preserve">
          <source>If your operator uses functions or lambdas that are passed in as parameters (predicates, for instance), note that these may be sources of exceptions, and be prepared to catch these and notify subscribers via &lt;code&gt;onError( )&lt;/code&gt; calls.</source>
          <target state="translated">Если ваш оператор использует функции или лямбда-выражения, которые передаются в качестве параметров (например, предикаты), обратите внимание, что они могут быть источниками исключений, и будьте готовы их перехватить и уведомить подписчиков через &lt;code&gt;onError( )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d10a49a1c9f362ffcdd30bcc2d70e20ca8a33fb" translate="yes" xml:space="preserve">
          <source>IgnoreElements</source>
          <target state="translated">IgnoreElements</target>
        </trans-unit>
        <trans-unit id="6e3bf6a26e7b015407f7e23c30d9aad02237ac19" translate="yes" xml:space="preserve">
          <source>Implementing Your Operator</source>
          <target state="translated">Внедрение Вашего оператора</target>
        </trans-unit>
        <trans-unit id="080201a38e03e3f517b6f68adc6f2cdb032d6de9" translate="yes" xml:space="preserve">
          <source>Implementing Your Own Operators</source>
          <target state="translated">Внедрение собственных операторов</target>
        </trans-unit>
        <trans-unit id="d9746961ed48f27eba42c580dc7c910e85405477" translate="yes" xml:space="preserve">
          <source>In ReactiveX an</source>
          <target state="translated">В ReactiveX an</target>
        </trans-unit>
        <trans-unit id="e07101b5e398b22985de43fce99e80ccc71f4b18" translate="yes" xml:space="preserve">
          <source>In ReactiveX it is not difficult to get into a situation in which an Observable is emitting items more rapidly than an operator or observer can consume them. This presents the problem of what to do with such a growing backlog of unconsumed items.</source>
          <target state="translated">В ReactiveX нетрудно попасть в ситуацию,когда наблюдаемый испускает предметы быстрее,чем оператор или наблюдатель может их потреблять.В связи с этим возникает проблема,что делать с таким растущим количеством невостребованных предметов.</target>
        </trans-unit>
        <trans-unit id="4d88767b8ff979df7115dbd13cc1795448ccafca" translate="yes" xml:space="preserve">
          <source>In Rx.NET the Observable this operator creates emits an Integer value, but there is also a &lt;code&gt;LongCount&lt;/code&gt; whose Observable emits a Long value. With both variants, you can either pass the source Observable in to the operator as a parameter or you can call the operator as an instance method of the source Observable (in which case you omit the parameter).</source>
          <target state="translated">В Rx.NET объект Observable, создаваемый этим оператором, выдает целочисленное значение, но есть также &lt;code&gt;LongCount&lt;/code&gt; , Observable которого генерирует значение типа Long. В обоих вариантах вы можете либо передать исходный Observable в оператор в качестве параметра, либо вы можете вызвать оператор как метод экземпляра исходного Observable (в этом случае вы опускаете параметр).</target>
        </trans-unit>
        <trans-unit id="082753d6aa99a3e49c22beaa10c53f7d50ccf53c" translate="yes" xml:space="preserve">
          <source>In Rx.NET there are several variants of Buffer. For each variety you can either pass in the source Observable as the first parameter, or you can call it as an instance method of the source Observable (in which case you can omit that parameter):</source>
          <target state="translated">В Rx.NET существует несколько вариантов буфера.Для каждого сорта можно либо передать в источник Observable в качестве первого параметра,либо назвать его методом экземпляра источника Observable (в этом случае можно опустить этот параметр):</target>
        </trans-unit>
        <trans-unit id="866459115059c570312783d7d933eb56a2044752" translate="yes" xml:space="preserve">
          <source>In Rx.rb you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">В Rx.rb у вас есть возможность передать предикат &lt;code&gt;count&lt;/code&gt; , который принимает в качестве параметра элемент, выданный источником Observable. Если вы это сделаете, &lt;code&gt;count&lt;/code&gt; будет выдавать счетчик только тех элементов из исходного Observable, которые предикат оценивает как &lt;code&gt;true&lt;/code&gt; . В противном случае он будет выдавать количество всех элементов, выпущенных исходным Observable.</target>
        </trans-unit>
        <trans-unit id="174c58d2e87272ea8e66142ea84c078a35283c3e" translate="yes" xml:space="preserve">
          <source>In Rx.rb, &lt;code&gt;on_error_resume_next&lt;/code&gt; inherits the misleading nomenclature from Rx.NET in that it concatenates the second Observable sequence to the source sequence whether that source sequence terminates normally or with an error.</source>
          <target state="translated">В Rx.rb &lt;code&gt;on_error_resume_next&lt;/code&gt; наследует вводящую в заблуждение номенклатуру от Rx.NET в том смысле, что он объединяет вторую наблюдаемую последовательность с исходной последовательностью, независимо от того, завершается эта исходная последовательность нормально или с ошибкой.</target>
        </trans-unit>
        <trans-unit id="3dc1fcc902763003b44007791de3712de7a57a0c" translate="yes" xml:space="preserve">
          <source>In Rx.rb, the &lt;code&gt;concat&lt;/code&gt; operator operates on two Observables as an instance operator, or on an array of Observables as a class method.</source>
          <target state="translated">В Rx.rb, то &lt;code&gt;concat&lt;/code&gt; оператор работает на двух наблюдаемых как оператор экземпляра, или на массив наблюдаемых в качестве метода класса.</target>
        </trans-unit>
        <trans-unit id="c3abf8fb4fa82e726050a8136a37f39dd9dbaf32" translate="yes" xml:space="preserve">
          <source>In RxClojure &lt;code&gt;concat&lt;/code&gt; concatenates some number of individual Observables together in the order in which they are given.</source>
          <target state="translated">В RxClojure &lt;code&gt;concat&lt;/code&gt; объединяющее некоторое количество отдельных наблюдаемых вместе в том порядке , в котором они даны.</target>
        </trans-unit>
        <trans-unit id="bc54b08c66d20cbbb553766813dfa06d5c1e25ba" translate="yes" xml:space="preserve">
          <source>In RxClojure there are six operators of concern here:</source>
          <target state="translated">В RxClojure есть шесть операторов,представляющих интерес:</target>
        </trans-unit>
        <trans-unit id="659fe011d5c89b01a2304a5c8e2bb81d2ad313c9" translate="yes" xml:space="preserve">
          <source>In RxGroovy the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">В RxGroovy оператор называется &lt;code&gt;count&lt;/code&gt; , а Observable, который он создает, выдает целочисленное значение. Существует также &lt;code&gt;countLong&lt;/code&gt; , Observable которого испускает значение Long.</target>
        </trans-unit>
        <trans-unit id="d76cd52669eae9e069058fa6344e3c8d433d43c8" translate="yes" xml:space="preserve">
          <source>In RxGroovy there are several variants of Buffer:</source>
          <target state="translated">В RxGroovy есть несколько вариантов буфера:</target>
        </trans-unit>
        <trans-unit id="03bd02f7f4db8f2104aaf4dd90fc1dad471cf32a" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">В RxGroovy есть множество операторов &lt;code&gt;replay&lt;/code&gt; которые возвращают подключаемый Observable. Вы должны &lt;a href=&quot;publish&quot;&gt;опубликовать&lt;/a&gt; этот подключаемый Observable до того, как наблюдатели смогут на него подписаться, а затем &lt;a href=&quot;connect&quot;&gt;подключиться&lt;/a&gt; к нему, чтобы наблюдать за его излучением.</target>
        </trans-unit>
        <trans-unit id="4db754926010b838dcaf35e54ecc9e4308fc9f4d" translate="yes" xml:space="preserve">
          <source>In RxGroovy there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">В RxGroovy также есть версия оператора &lt;a href=&quot;from&quot;&gt;From,&lt;/a&gt; которая преобразует &lt;code&gt;Future&lt;/code&gt; в Observable и в этом плане напоминает оператор Start.</target>
        </trans-unit>
        <trans-unit id="7572e0a31faefbf7ff70dca0814645c09d2770c6" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">В RxGroovy &lt;code&gt;doWhile&lt;/code&gt; не является частью стандартного набора операторов, но является частью необязательного &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; . &lt;code&gt;doWhile&lt;/code&gt; проверяет условие после каждого повторения исходной последовательности и повторяет его только в том случае, если это условие истинно.</target>
        </trans-unit>
        <trans-unit id="3aa8ae88df582d489c98f809e108617b6f090787" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns. For example:</source>
          <target state="translated">В RxGroovy, &lt;code&gt;materialize&lt;/code&gt; преобразует уведомления из источника Observable в объекты &lt;code&gt;Notification&lt;/code&gt; и испускает их как выбросы из Observable, которые он возвращает. Например:</target>
        </trans-unit>
        <trans-unit id="237f50a50a7216fd4056fb13f9fb3ed56266ba27" translate="yes" xml:space="preserve">
          <source>In RxGroovy, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">В RxGroovy &lt;code&gt;whileDo&lt;/code&gt; не является частью стандартного набора операторов, но является частью необязательного &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; . &lt;code&gt;whileDo&lt;/code&gt; проверяет условие перед каждым повторением исходной последовательности и повторяет его только в том случае, если это условие истинно.</target>
        </trans-unit>
        <trans-unit id="dc4459eb5576a0985852d40aad97090be35fe7fe" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy оператор &lt;code&gt;connect&lt;/code&gt; - это метод интерфейса &lt;code&gt;ConnectableObservable&lt;/code&gt; . Вы можете использовать оператор &lt;code&gt;publish&lt;/code&gt; для преобразования обычного Observable в &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0218c1d751cc26a5e8cbb187a070d185be55fd96" translate="yes" xml:space="preserve">
          <source>In RxGroovy, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">В RxGroovy оператор &lt;code&gt;from&lt;/code&gt; может преобразовывать Future, Iterable или Array. В случае Iterable или Array результирующий Observable будет выдавать каждый элемент, содержащийся в Iterable или Array.</target>
        </trans-unit>
        <trans-unit id="077b76d936cc54a4fbdf52bb6a3d71bca4542ef9" translate="yes" xml:space="preserve">
          <source>In RxGroovy, these are not part of the core ReactiveX implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">В RxGroovy они не являются частью основной реализации ReactiveX, но находятся в виде &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;then&lt;/code&gt; , и &lt;code&gt;when&lt;/code&gt; в &lt;code&gt;rxjava-joins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c6ab7a826f68ee896f9e7bbec6a50b13018591" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy этот оператор фильтрации реализован как &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; и &lt;code&gt;takeFirst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29837dbff839813080383499d8c69a5c010c8559" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy этот оператор фильтрации реализован как &lt;code&gt;last&lt;/code&gt; и &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="524670218e1528528dc3e43a23a6e9ec903626f3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy этот оператор реализован как &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a0032a96a9e999b2568c2953d3e8ba98be07a8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy этот оператор реализован как &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab9e4908bb4235f47b80c1c77b023791f672cb3" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">В RxGroovy этот оператор реализован как &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5071f8b712a1a2faafa543e15f33108e9b05eb0e" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">В RxGroovy этот оператор реализован как &lt;code&gt;takeUntil&lt;/code&gt; . Обратите внимание, что второй Observable может заставить &lt;code&gt;takeUntil&lt;/code&gt; прекратить выдачу элементов либо путем выдачи элемента, либо путем выдачи &lt;code&gt;onError&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; уведомления .</target>
        </trans-unit>
        <trans-unit id="da02f4576a4b5a5747703904db2371ebcf038e26" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">В RxGroovy этот оператор находится не в ядре ReactiveX, а является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; , где он реализован с помощью четырех операторов , &lt;code&gt;averageFloat&lt;/code&gt; типа: &lt;code&gt;averageDouble&lt;/code&gt; , averageFloat , &lt;code&gt;averageInteger&lt;/code&gt; и &lt;code&gt;averageLong&lt;/code&gt; . В следующем примере показано, как работают эти операторы:</target>
        </trans-unit>
        <trans-unit id="badd3303a8eb778bfc48d7a87db09f83d8fb14fa" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;. The following example shows how these operators work:</source>
          <target state="translated">В RxGroovy этот оператор находится не в ядре ReactiveX, а является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; , где он реализован с помощью четырех операторов , &lt;code&gt;sumFloat&lt;/code&gt; типа: &lt;code&gt;sumDouble&lt;/code&gt; , sumFloat , &lt;code&gt;sumInteger&lt;/code&gt; и &lt;code&gt;sumLong&lt;/code&gt; . В следующем примере показано, как работают эти операторы:</target>
        </trans-unit>
        <trans-unit id="c07cae2ff645e10f1475b173e92b2e4d1731fbd8" translate="yes" xml:space="preserve">
          <source>In RxGroovy, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">В RxGroovy этого оператора нет в ядре ReactiveX, но он является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f81aa6294cb9c74bcf4eb9eeea361e7952d8bb" translate="yes" xml:space="preserve">
          <source>In RxJS the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate takes the form of a function that takes three parameters:</source>
          <target state="translated">В RxJS оператор &lt;code&gt;count&lt;/code&gt; подсчитывает количество элементов в исходном Observable, которые удовлетворяют указанному предикату. Этот предикат принимает форму функции, которая принимает три параметра:</target>
        </trans-unit>
        <trans-unit id="089ff40ee2d57ffddd76d98e11442fdb0f93e79e" translate="yes" xml:space="preserve">
          <source>In RxJS there are two versions of the &lt;code&gt;timer&lt;/code&gt; operator.</source>
          <target state="translated">В RxJS есть две версии оператора &lt;code&gt;timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546ed95cf4899b2546736d0dc77f0000eca5cc15" translate="yes" xml:space="preserve">
          <source>In RxJS you can set the per-item delay in two ways: by passing a number of milliseconds into the &lt;code&gt;delay&lt;/code&gt; operator (which will delay each emission by that amount of time), or by passing in a &lt;code&gt;Date&lt;/code&gt; object (which will delay the beginning of the sequence of emissions until that absolute point in time).</source>
          <target state="translated">В RxJS вы можете установить задержку для каждого элемента двумя способами: передав определенное количество миллисекунд в оператор &lt;code&gt;delay&lt;/code&gt; (который будет задерживать каждую эмиссию на это количество времени) или передав объект &lt;code&gt;Date&lt;/code&gt; (который задержит начало последовательности выбросов до этого абсолютного момента времени).</target>
        </trans-unit>
        <trans-unit id="a91657e27431e8473a66e219d9cffa8076861683" translate="yes" xml:space="preserve">
          <source>In RxJS you obtain Schedulers from the &lt;code&gt;Rx.Scheduler&lt;/code&gt; object or as independently-implemented objects. The following table shows the varieties of Scheduler that are available to you in RxJS:.</source>
          <target state="translated">В RxJS вы получаете планировщики из объекта &lt;code&gt;Rx.Scheduler&lt;/code&gt; или как независимо реализованные объекты. В следующей таблице показаны разновидности Планировщика, доступные вам в RxJS:</target>
        </trans-unit>
        <trans-unit id="59380515fb1764dd57d6d356f045c860c3897dad" translate="yes" xml:space="preserve">
          <source>In RxJS, &lt;code&gt;sequenceEqual&lt;/code&gt; is a method of a particular Observable instance, so you pass it exactly one other Observable to compare the instance to. You can optionally pass a second parameter: a function that accepts two items and returns &lt;code&gt;true&lt;/code&gt; if they are equal according to a standard of your choosing. &lt;code&gt;sequenceEqual&lt;/code&gt; returns an Observable that will emit a &lt;code&gt;true&lt;/code&gt; if the two Observables emit the same set of items in the same order before completing, or a &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">В RxJS &lt;code&gt;sequenceEqual&lt;/code&gt; - это метод конкретного экземпляра Observable, поэтому вы передаете ему ровно один другой Observable, с которым он будет сравнивать. При желании вы можете передать второй параметр: функцию, которая принимает два элемента и возвращает &lt;code&gt;true&lt;/code&gt; если они равны в соответствии с выбранным вами стандартом. &lt;code&gt;sequenceEqual&lt;/code&gt; возвращает Observable, который будет выдавать &lt;code&gt;true&lt;/code&gt; , если два Observable перед завершением передают один и тот же набор элементов в том же порядке, или &lt;code&gt;false&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="e39fb67c9a541a9b33aa36d76685b7973746c9cf" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; prototype. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">В RxJS оператор &lt;code&gt;connect&lt;/code&gt; - это метод прототипа &lt;code&gt;ConnectableObservable&lt;/code&gt; . Вы можете использовать оператор &lt;code&gt;publish&lt;/code&gt; для преобразования обычного Observable в &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1dad5015733748479ef787bfb5054f381799c6" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;distinct&lt;/code&gt; operator has two optional parameters:</source>
          <target state="translated">В RxJS &lt;code&gt;distinct&lt;/code&gt; оператор имеет два необязательных параметра:</target>
        </trans-unit>
        <trans-unit id="60aeaf00dfd42ac1f2aa979d31edd932b2e05c96" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;from&lt;/code&gt; operator converts an array-like or iterable object into an Observable that emits the items in that array or iterable. A String, in this context, is treated as an array of characters.</source>
          <target state="translated">В RxJS оператор &lt;code&gt;from&lt;/code&gt; преобразует подобный массиву или итерируемый объект в Observable, который испускает элементы в этом массиве или итерируемом. Строка в этом контексте рассматривается как массив символов.</target>
        </trans-unit>
        <trans-unit id="32f572fa2a9a0912cc3687d3d2b76c82ee440842" translate="yes" xml:space="preserve">
          <source>In RxJS, the &lt;code&gt;publish&lt;/code&gt; operator takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the returned &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">В RxJS оператор &lt;code&gt;publish&lt;/code&gt; принимает функцию в качестве параметра. Эта функция принимает в качестве параметра переданный элемент из исходного Observable и создает элемент, который будет передан вместо него возвращенным &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220a1ea76599fe696f6ff55d0b0240936d7391d9" translate="yes" xml:space="preserve">
          <source>In RxJS, you can subscribe to an Observable in two ways:</source>
          <target state="translated">В RxJS вы можете подписаться на Наблюдателя двумя способами:</target>
        </trans-unit>
        <trans-unit id="f0434c25ac778b06dc0f0e430a507026d4ffcd13" translate="yes" xml:space="preserve">
          <source>In RxJava the operator is called &lt;code&gt;count&lt;/code&gt; and the Observable it creates emits an Integer value. There is also a &lt;code&gt;countLong&lt;/code&gt; whose Observable emits a Long value.</source>
          <target state="translated">В RxJava оператор называется &lt;code&gt;count&lt;/code&gt; , а Observable, который он создает, выдает целочисленное значение. Существует также &lt;code&gt;countLong&lt;/code&gt; , Observable которого испускает значение Long.</target>
        </trans-unit>
        <trans-unit id="1b4d2614f2ccefc9538a2a5b53a4e9f2384b8a21" translate="yes" xml:space="preserve">
          <source>In RxJava there are several variants of Buffer:</source>
          <target state="translated">В RxJava есть несколько вариантов буфера:</target>
        </trans-unit>
        <trans-unit id="5324a1b154d0b35b0430e397999d44bbb2293830" translate="yes" xml:space="preserve">
          <source>In RxJava there is a variety of the &lt;code&gt;replay&lt;/code&gt; operator that returns a connectable Observable. You must &lt;a href=&quot;publish&quot;&gt;Publish&lt;/a&gt; this connectable Observable before observers can subscribe to it, and then &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; to it in order to observe its emissions.</source>
          <target state="translated">В RxJava есть множество операторов &lt;code&gt;replay&lt;/code&gt; которые возвращают подключаемый Observable. Вы должны &lt;a href=&quot;publish&quot;&gt;опубликовать&lt;/a&gt; этот подключаемый Observable, прежде чем наблюдатели смогут подписаться на него, а затем &lt;a href=&quot;connect&quot;&gt;подключиться&lt;/a&gt; к нему, чтобы наблюдать за его излучением.</target>
        </trans-unit>
        <trans-unit id="fa9a02b1a23712e12eaf9bf38e6513173d05aad6" translate="yes" xml:space="preserve">
          <source>In RxJava there is also a version of the &lt;a href=&quot;from&quot;&gt;From&lt;/a&gt; operator that converts a &lt;code&gt;Future&lt;/code&gt; into an Observable, and in this way resembles the Start operator.</source>
          <target state="translated">В RxJava также есть версия оператора &lt;a href=&quot;from&quot;&gt;From,&lt;/a&gt; которая преобразует &lt;code&gt;Future&lt;/code&gt; в Observable и в этом плане напоминает оператор Start.</target>
        </trans-unit>
        <trans-unit id="d66e9a41859140e63d2a513b65a3eb33c3064950" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;doWhile&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;doWhile&lt;/code&gt; checks a condition after each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">В RxJava &lt;code&gt;doWhile&lt;/code&gt; не является частью стандартного набора операторов, но является частью необязательного &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; . &lt;code&gt;doWhile&lt;/code&gt; проверяет условие после каждого повторения исходной последовательности и повторяет его только в том случае, если это условие истинно.</target>
        </trans-unit>
        <trans-unit id="278ec5920441fdbb971e38eb40408f25e66352a0" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;materialize&lt;/code&gt; transforms the notifications from the source Observable into &lt;code&gt;Notification&lt;/code&gt; objects and emits them as the emissions from the Observable it returns.</source>
          <target state="translated">В RxJava, &lt;code&gt;materialize&lt;/code&gt; преобразует уведомления из исходного Observable в объекты &lt;code&gt;Notification&lt;/code&gt; и испускает их как выбросы из Observable, которые он возвращает.</target>
        </trans-unit>
        <trans-unit id="b9040120474fb9e9d6678ef11c5d331e3831055d" translate="yes" xml:space="preserve">
          <source>In RxJava, &lt;code&gt;whileDo&lt;/code&gt; is not part of the standard set of operators, but is part of the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package. &lt;code&gt;whileDo&lt;/code&gt; checks a condition before each repetition of the source sequence, and only repeats it if that condition is true.</source>
          <target state="translated">В RxJava &lt;code&gt;whileDo&lt;/code&gt; не является частью стандартного набора операторов, но является частью необязательного &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; . &lt;code&gt;whileDo&lt;/code&gt; проверяет условие перед каждым повторением исходной последовательности и повторяет его только в том случае, если это условие истинно.</target>
        </trans-unit>
        <trans-unit id="7cda80172d796ec17e6de8b0b3fb7df8961f5322" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;connect&lt;/code&gt; operator is a method of the &lt;code&gt;ConnectableObservable&lt;/code&gt; interface. You can use the &lt;code&gt;publish&lt;/code&gt; operator to convert an ordinary Observable into a &lt;code&gt;ConnectableObservable&lt;/code&gt;.</source>
          <target state="translated">В RxJava оператор &lt;code&gt;connect&lt;/code&gt; - это метод интерфейса &lt;code&gt;ConnectableObservable&lt;/code&gt; . Вы можете использовать оператор &lt;code&gt;publish&lt;/code&gt; для преобразования обычного Observable в &lt;code&gt;ConnectableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d915aa8a6371b24d546a898d5927650d68298d10" translate="yes" xml:space="preserve">
          <source>In RxJava, the &lt;code&gt;from&lt;/code&gt; operator can convert a Future, an Iterable, or an Array. In the case of an Iterable or an Array, the resulting Observable will emit each item contained in the Iterable or Array.</source>
          <target state="translated">В RxJava оператор &lt;code&gt;from&lt;/code&gt; может преобразовывать Future, Iterable или Array. В случае Iterable или Array результирующий Observable будет выдавать каждый элемент, содержащийся в Iterable или Array.</target>
        </trans-unit>
        <trans-unit id="8aa6f776ef4b58ae93606199eab5d7aae9f12a1b" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;firstOrDefault&lt;/code&gt;, and &lt;code&gt;takeFirst&lt;/code&gt;.</source>
          <target state="translated">В RxJava этот оператор фильтрации реализован как &lt;code&gt;first&lt;/code&gt; , &lt;code&gt;firstOrDefault&lt;/code&gt; и &lt;code&gt;takeFirst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a4f120274458ea753c59c58263b7e7f5ac97cf7" translate="yes" xml:space="preserve">
          <source>In RxJava, this filtering operator is implemented as &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt;.</source>
          <target state="translated">В RxJava этот оператор фильтрации реализован как &lt;code&gt;last&lt;/code&gt; и &lt;code&gt;lastOrDefault&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aaf45cbe7681d9fc78492e0e1abae440e60cdd8" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">В RxJava этот оператор реализован как &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad7d874d083f1f23b84c1a24058def9a12d847a5" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">В RxJava этот оператор реализован как &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0df78c0cd8e0c04b88996b41f57536868e395ae" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">В RxJava этот оператор реализован как &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c04fd97bf99939674e16f0e2e06fb85b1f5316" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is implemented as &lt;code&gt;takeUntil&lt;/code&gt;. Note that the second Observable can cause &lt;code&gt;takeUntil&lt;/code&gt; to quit emitting items either by emitting an item or by issuing an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">В RxJava этот оператор реализован как &lt;code&gt;takeUntil&lt;/code&gt; . Обратите внимание, что второй Observable может заставить &lt;code&gt;takeUntil&lt;/code&gt; прекратить выдачу элементов либо путем выдачи элемента, либо путем выдачи уведомления &lt;code&gt;onError&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cafebc8da2c395e45b748adaf4d16e424147df6" translate="yes" xml:space="preserve">
          <source>In RxJava, this operator is not in the ReactiveX core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module.</source>
          <target state="translated">В RxJava этого оператора нет в ядре ReactiveX, но он является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa451d401756cfb43e0af09e28153a9dcf363ef1" translate="yes" xml:space="preserve">
          <source>In RxJs the &lt;code&gt;replay&lt;/code&gt; operator takes four optional parameters and returns an ordinary Observable:</source>
          <target state="translated">В RxJs оператор &lt;code&gt;replay&lt;/code&gt; принимает четыре необязательных параметра и возвращает обычный Observable:</target>
        </trans-unit>
        <trans-unit id="e5f6338e063dd1fe484cfc1e5f6bdc92e7874c61" translate="yes" xml:space="preserve">
          <source>In RxKotlin there are several variants of Buffer:</source>
          <target state="translated">В RxKotlin есть несколько вариантов буфера:</target>
        </trans-unit>
        <trans-unit id="09f9d22e6333dc41077c541c793d2b34999696d3" translate="yes" xml:space="preserve">
          <source>In RxPY &lt;code&gt;concat&lt;/code&gt; takes a variable number of Observables as parameters (or an array of Observables), and concatenates them in the order they appear in the parameter list (or array).</source>
          <target state="translated">В RxPY &lt;code&gt;concat&lt;/code&gt; принимает переменное число наблюдаемых в качестве параметров (или массив), наблюдаемых и сцепляет их в порядке их появления в списке параметров (или массива).</target>
        </trans-unit>
        <trans-unit id="e73aa488412dc01ff1bb9df22470c5c2d99a3e49" translate="yes" xml:space="preserve">
          <source>In RxPY you have the option to pass &lt;code&gt;count&lt;/code&gt; a predicate that takes an item emitted by the source Observable as a parameter. If you do so, &lt;code&gt;count&lt;/code&gt; will emit a count only of those items from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;. Otherwise, it will emit a count of all items emitted by the source Observable.</source>
          <target state="translated">В RxPY у вас есть возможность передать предикат &lt;code&gt;count&lt;/code&gt; , который принимает в качестве параметра элемент, излучаемый источником Observable. Если вы это сделаете, &lt;code&gt;count&lt;/code&gt; будет выдавать счетчик только тех элементов из исходного Observable, которые предикат оценивает как &lt;code&gt;true&lt;/code&gt; . В противном случае он будет выдавать количество всех элементов, выпущенных исходным Observable.</target>
        </trans-unit>
        <trans-unit id="0b529c9a0dc4b531af4b60f80f6f0cf3876ca4b7" translate="yes" xml:space="preserve">
          <source>In RxScala the operator &lt;code&gt;count&lt;/code&gt; counts the number of items in the source Observable that satisfy a specified predicate. That predicate accepts an emitted item as a parameter and returns a Boolean. &lt;code&gt;count&lt;/code&gt; will emit a count of all items for which this predicate returned &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">В RxScala оператор &lt;code&gt;count&lt;/code&gt; подсчитывает количество элементов в исходном Observable, удовлетворяющих заданному предикату. Этот предикат принимает в качестве параметра переданный элемент и возвращает логическое значение. &lt;code&gt;count&lt;/code&gt; выдаст количество всех элементов, для которых этот предикат вернул &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16ec499010df4b2455c2dfd317e76e966b3946e5" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.from&lt;/code&gt; class method.</source>
          <target state="translated">В Swift это реализовано с помощью метода класса &lt;code&gt;Observable.from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138a5f790b58f03a816d8788ec73857af8ed119a" translate="yes" xml:space="preserve">
          <source>In Swift, this is implemented using the &lt;code&gt;Observable.just&lt;/code&gt; class method.</source>
          <target state="translated">В Swift это реализовано с помощью метода класса &lt;code&gt;Observable.just&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e45263cc87b0ac4023f88773e7a4a3cd1488684" translate="yes" xml:space="preserve">
          <source>In addition, in the &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, you have available to you the following operators that convert actions, callables, functions, and runnables into Observables that emit the results of those things:</source>
          <target state="translated">Кроме того, в пакете &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; вам доступны следующие операторы, которые преобразуют действия, вызываемые объекты, функции и запускаемые объекты в Observables, которые генерируют результаты этих действий:</target>
        </trans-unit>
        <trans-unit id="c705eb2803752c9ee28584efe3fc60abb165fff0" translate="yes" xml:space="preserve">
          <source>In an ordinary method call &amp;mdash; that is, &lt;em&gt;not&lt;/em&gt; the sort of asynchronous, parallel calls typical in ReactiveX &amp;mdash; the flow is something like this:</source>
          <target state="translated">При обычном вызове метода - то есть &lt;em&gt;не&lt;/em&gt; в виде асинхронных параллельных вызовов, типичных для ReactiveX - поток выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="70afa1a17dffe1d75fa8ae4871f89baf7ba04903" translate="yes" xml:space="preserve">
          <source>In general, notify subscribers of error conditions immediately, rather than making an effort to emit more items first.</source>
          <target state="translated">В общем,немедленно уведомляйте абонентов об ошибках,вместо того,чтобы пытаться сначала выпустить больше единиц товара.</target>
        </trans-unit>
        <trans-unit id="b51d0ee6ef32193720cf5577081be13382e0461c" translate="yes" xml:space="preserve">
          <source>In many ReactiveX implementations there is a second operator, MergeDelayError, that changes this behavior &amp;mdash; reserving &lt;code&gt;onError&lt;/code&gt; notifications until all of the merged Observables complete and only then passing it along to the observers:</source>
          <target state="translated">Во многих реализациях ReactiveX есть второй оператор, MergeDelayError, который изменяет это поведение - резервирует уведомления &lt;code&gt;onError&lt;/code&gt; до тех пор, пока все объединенные Observables не завершатся, и только затем передает их наблюдателям:</target>
        </trans-unit>
        <trans-unit id="df1c152b88bf70837256cdf207124847c96b400f" translate="yes" xml:space="preserve">
          <source>In many software programming tasks, you more or less expect that the instructions you write will execute and complete incrementally, one-at-a-time, in order as you have written them. But in ReactiveX, many instructions may execute in parallel and their results are later captured, in arbitrary order, by &amp;ldquo;observers.&amp;rdquo; Rather than &lt;em&gt;calling&lt;/em&gt; a method, you define a mechanism for retrieving and transforming the data, in the form of an &amp;ldquo;Observable,&amp;rdquo; and then &lt;em&gt;subscribe&lt;/em&gt; an observer to it, at which point the previously-defined mechanism fires into action with the observer standing sentry to capture and respond to its emissions whenever they are ready.</source>
          <target state="translated">Во многих задачах программирования программного обеспечения вы более или менее ожидаете, что написанные вами инструкции будут выполняться постепенно, по одной за раз, в том порядке, в котором вы их написали. Но в ReactiveX многие инструкции могут выполняться параллельно, а их результаты позже фиксируются в произвольном порядке &amp;laquo;наблюдателями&amp;raquo;. Вместо того, чтобы &lt;em&gt;вызывать&lt;/em&gt; метод, вы определяете механизм для извлечения и преобразования данных в форме &amp;laquo;наблюдаемого&amp;raquo;, а затем &lt;em&gt;подписываете&lt;/em&gt; на него наблюдателя, после чего срабатывает ранее определенный механизм с наблюдателем, стоящим на страже. улавливать и реагировать на его выбросы, когда они будут готовы.</target>
        </trans-unit>
        <trans-unit id="af1cde5def7e314848c7b5ea89de136a83b3d54d" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">В других документах и ​​других контекстах то, что мы называем &amp;laquo;наблюдателем&amp;raquo;, иногда называют &amp;laquo;подписчиком&amp;raquo;, &amp;laquo;наблюдателем&amp;raquo; или &amp;laquo;реактором&amp;raquo;. Эту модель в целом часто называют &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;laquo;реакторной схемой&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a661195d6805be9c148ca5aaa5480f83dbbbe3f" translate="yes" xml:space="preserve">
          <source>In other documents and other contexts, what we are calling an &amp;ldquo;observer&amp;rdquo; is sometimes called a &amp;ldquo;subscriber,&amp;rdquo; &amp;ldquo;watcher,&amp;rdquo; or &amp;ldquo;reactor.&amp;rdquo; This model in general is often referred to as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reactor_pattern&quot;&gt;&amp;ldquo;reactor pattern&amp;rdquo;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c110d63fdae361275771c2c4e8b7c4bd49374d1" translate="yes" xml:space="preserve">
          <source>In several of the language-specific implementations there is also an operator that does &lt;em&gt;not&lt;/em&gt; interleave the emissions from the transformed Observables, but instead emits these emissions in strict order, often called ConcatMap or something similar.</source>
          <target state="translated">В некоторых реализациях, зависящих от языка, также есть оператор, который &lt;em&gt;не&lt;/em&gt; чередует выбросы преобразованных Observables, а вместо этого испускает эти выбросы в строгом порядке, часто называемом ConcatMap или чем-то подобным.</target>
        </trans-unit>
        <trans-unit id="93bfb63abe1513baa690460365bb2e32de9329bf" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations there is also a ConcatMap operator (a.k.a. &lt;code&gt;concat_all&lt;/code&gt;, &lt;code&gt;concat_map&lt;/code&gt;, &lt;code&gt;concatMapObserver&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;forIn&lt;/code&gt;/&lt;code&gt;for_in&lt;/code&gt;, &lt;code&gt;mapcat&lt;/code&gt;, &lt;code&gt;selectConcat&lt;/code&gt;, or &lt;code&gt;selectConcatObserver&lt;/code&gt;) that transforms the items emitted by a source Observable into corresponding Observables and then concatenates the items emitted by each of these Observables in the order in which they are observed and transformed.</source>
          <target state="translated">В некоторых реализациях ReactiveX также есть оператор ConcatMap (он же &lt;code&gt;concat_all&lt;/code&gt; , &lt;code&gt;concat_map&lt;/code&gt; , &lt;code&gt;concatMapObserver&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;forIn&lt;/code&gt; / &lt;code&gt;for_in&lt;/code&gt; , &lt;code&gt;mapcat&lt;/code&gt; , &lt;code&gt;selectConcat&lt;/code&gt; или &lt;code&gt;selectConcatObserver&lt;/code&gt; ), который преобразует элементы, испускаемые исходным Observable, в соответствующие Observable, а затем объединяет элементы, испускаемые каждый из этих Observable в том порядке, в котором они наблюдаются и преобразуются.</target>
        </trans-unit>
        <trans-unit id="49d6b73f37ee57d71fdff6d16884e54ade3b0ef5" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is a specialized observer interface, &lt;code&gt;Subscriber&lt;/code&gt;, that implements an &lt;code&gt;unsubscribe&lt;/code&gt; method. You can call this method to indicate that the Subscriber is no longer interested in any of the Observables it is currently subscribed to. Those Observables can then (if they have no other interested observers) choose to stop generating new items to emit.</source>
          <target state="translated">В некоторых реализациях ReactiveX есть специализированный интерфейс наблюдателя &lt;code&gt;Subscriber&lt;/code&gt; , который реализует метод &lt;code&gt;unsubscribe&lt;/code&gt; от подписки . Вы можете вызвать этот метод, чтобы указать, что подписчик больше не интересуется какими-либо наблюдаемыми объектами, на которые он в настоящее время подписан. Затем эти Observables могут (если у них нет других заинтересованных наблюдателей) прекратить генерировать новые элементы для испускания.</target>
        </trans-unit>
        <trans-unit id="2949e25812bc031cf61fa47668bcad6970f74f74" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, there is an operator called something like &amp;ldquo;OnErrorResumeNext&amp;rdquo; that behaves like a Catch variant: specifically reacting to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. In others, there is an operator with that name that behaves more like a Concat variant: performing the concatenation operation regardless of whether the source Observable terminates normally or with an error. This is unfortunate and confusing, but something we have to live with.</source>
          <target state="translated">В некоторых реализациях ReactiveX есть оператор, называемый чем-то вроде &amp;laquo;OnErrorResumeNext&amp;raquo;, который ведет себя как вариант Catch: конкретно реагирует на уведомление &lt;code&gt;onError&lt;/code&gt; от исходного Observable. В других случаях есть оператор с таким именем, который ведет себя больше как вариант Concat: выполнение операции конкатенации независимо от того, завершается ли исходный Observable нормально или с ошибкой. Это прискорбно и сбивает с толку, но нам приходится смириться.</target>
        </trans-unit>
        <trans-unit id="feb01da6c51b0285d3263e371d3483d2cae53174" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="translated">В некоторых реализациях ReactiveX вашему оператору может потребоваться учитывать стратегии &amp;laquo;противодавления&amp;raquo; этой реализации. (См., Например, &amp;laquo; &lt;a href=&quot;http://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Подводные камни реализации операторов&amp;raquo; (часть 2)&lt;/a&gt; Давида Карнока.)</target>
        </trans-unit>
        <trans-unit id="d86788d80735e9747737d806466553a36e139407" translate="yes" xml:space="preserve">
          <source>In some ReactiveX implementations, your operator may need to be sensitive to that implementation&amp;rsquo;s &amp;ldquo;backpressure&amp;rdquo; strategies. (See, for example: &lt;a href=&quot;https://akarnokd.blogspot.hu/2015/05/pitfalls-of-operator-implementations_14.html&quot;&gt;Pitfalls of Operator Implementations (part 2)&lt;/a&gt; by D&amp;aacute;vid Karnok.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d968bca48f34a1b9d629e8c8e5bc7f1f9e7409" translate="yes" xml:space="preserve">
          <source>In some circumstances, waiting until the last minute (that is, until subscription time) to generate the Observable can ensure that this Observable contains the freshest data.</source>
          <target state="translated">В некоторых случаях,ожидание до последней минуты (то есть до момента подписки)для генерации &quot;Наблюдателя&quot; может гарантировать,что этот &quot;Наблюдатель&quot; содержит самые свежие данные.</target>
        </trans-unit>
        <trans-unit id="0d97597b94f7d0965b9edaef42c16ac57210f4bf" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also an operator that converts an Observable into a &amp;ldquo;Blocking&amp;rdquo; Observable. A Blocking Observable extends the ordinary Observable by providing a set of methods, operating on the items emitted by the Observable, that block. Some of the To operators are in this Blocking Observable set of extended operations.</source>
          <target state="translated">В некоторых реализациях ReactiveX также есть оператор, который преобразует Observable в &amp;laquo;Blocking&amp;raquo; Observable. Блокирующий Observable расширяет обычный Observable, предоставляя набор методов, работающих с элементами, испускаемыми Observable в этом блоке. Некоторые из операторов To входят в этот набор расширенных операций Blocking Observable.</target>
        </trans-unit>
        <trans-unit id="f8063bc63842afdac26b9e318a09b125cd96bc99" translate="yes" xml:space="preserve">
          <source>In some implementations of ReactiveX, there is also something called a &amp;ldquo;Connectable&amp;rdquo; Observable. Such an Observable does not begin emitting items until its &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; method is called, whether or not any observers have subscribed to it.</source>
          <target state="translated">В некоторых реализациях ReactiveX есть также нечто, называемое &amp;laquo;подключаемым&amp;raquo; наблюдаемым. Такой Observable не начинает излучать элементы до тех пор, пока не будет вызван его метод &lt;a href=&quot;operators/connect&quot;&gt;Connect&lt;/a&gt; , независимо от того, подписались ли на него какие-либо наблюдатели.</target>
        </trans-unit>
        <trans-unit id="037dec5a983c9517e8c8c6b9e8942bbe78e32581" translate="yes" xml:space="preserve">
          <source>In some implementations there are variants that allow you to adjust the criteria by which two items are considered &amp;ldquo;distinct.&amp;rdquo; In some, there is a variant of the operator that only compares an item against its immediate predecessor for distinctness, thereby filtering only &lt;em&gt;consecutive&lt;/em&gt; duplicate items from the sequence.</source>
          <target state="translated">В некоторых реализациях есть варианты, которые позволяют настраивать критерии, по которым два элемента считаются &amp;laquo;разными&amp;raquo;. В некоторых случаях существует вариант оператора, который сравнивает элемент только с его непосредственным предшественником на предмет различимости, тем самым фильтруя только &lt;em&gt;последовательные&lt;/em&gt; повторяющиеся элементы из последовательности.</target>
        </trans-unit>
        <trans-unit id="1dd136608bd7e489e77433f289366dd451d69a68" translate="yes" xml:space="preserve">
          <source>In some implementations there is also a Single operator. It behaves similarly to First except that it waits until the source Observable terminates in order to guarantee that it only emits a single item (otherwise, rather than emitting that item, it terminates with an error). You can use this to not only take the first item from the source Observable but to also guarantee that there was only one item.</source>
          <target state="translated">В некоторых реализациях также присутствует один оператор.Он ведет себя аналогично First за исключением того,что ждет окончания работы источника Observable,чтобы гарантировать,что он испускает только один элемент (в противном случае,вместо того,чтобы испускать этот элемент,он завершается с ошибкой).С помощью этого оператора можно не только забрать первый элемент у источника Observable,но и гарантировать,что он испускает только один элемент.</target>
        </trans-unit>
        <trans-unit id="6e0dc45fcc76d537e1792d8725c9220fda83cacf" translate="yes" xml:space="preserve">
          <source>In some implementations there is also an UnsubscribeOn operator.</source>
          <target state="translated">В некоторых реализациях также присутствует оператор UnsubscribeOn.</target>
        </trans-unit>
        <trans-unit id="12e47960cd978595f0079e3a0166c1245438c4c9" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;First&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item at such time as the source Observable emits that item. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;Take(1)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;elementat&quot;&gt;&lt;code&gt;ElementAt(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В некоторых реализациях &lt;code&gt;First&lt;/code&gt; реализован не как оператор фильтрации, который возвращает Observable, а как функция блокировки, которая возвращает конкретный элемент в то время, когда исходный Observable излучает этот элемент. В этих реализациях, если вместо этого вам нужен оператор фильтрации, возможно, вам повезет с &lt;a href=&quot;take&quot;&gt; &lt;code&gt;Take(1)&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;elementat&quot;&gt; &lt;code&gt;ElementAt(0)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4334a2a1ddeb5e11e72e20d2fc45eef1bd9c0c63" translate="yes" xml:space="preserve">
          <source>In some implementations, &lt;code&gt;Last&lt;/code&gt; is not implemented as a filtering operator that returns an Observable, but as a blocking function that returns a particular item when the source Observable terminates. In those implementations, if you instead want a filtering operator, you may have better luck with &lt;a href=&quot;take&quot;&gt;&lt;code&gt;TakeLast(1)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В некоторых реализациях &lt;code&gt;Last&lt;/code&gt; не реализован как оператор фильтрации, возвращающий Observable, а как функция блокировки, которая возвращает определенный элемент, когда исходный Observable завершается. В этих реализациях, если вам нужен оператор фильтрации, возможно, вам повезет с &lt;a href=&quot;take&quot;&gt; &lt;code&gt;TakeLast(1)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a21a2695ee7461574576b39692f2c5743113615" translate="yes" xml:space="preserve">
          <source>In some implementations, there is also a ThrottleFirst operator that is similar, but emits not the most-recently emitted item in the sample period, but the &lt;em&gt;first&lt;/em&gt; item that was emitted during that period.</source>
          <target state="translated">В некоторых реализациях также есть аналогичный оператор ThrottleFirst, но он генерирует не последний отправленный элемент в период выборки, а &lt;em&gt;первый&lt;/em&gt; элемент, который был отправлен в течение этого периода.</target>
        </trans-unit>
        <trans-unit id="a6343b30db7af9b5aa728419488dd86296f2eea2" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxGroovy core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">В классе &lt;code&gt;StringObservable&lt;/code&gt; , который не является частью ядра RxGroovy, также есть специальный оператор сопоставления, &lt;code&gt;encode&lt;/code&gt; , который преобразует Observable, который испускает строки, в Observable, который испускает байтовые массивы, которые соответствуют границам символов многобайтовых символов в исходных строках.</target>
        </trans-unit>
        <trans-unit id="978e2cb0f06af222730ceae268a71aa2cf8778d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;StringObservable&lt;/code&gt; class that is not part of the RxJava core there is also a specialty mapping operator, &lt;code&gt;encode&lt;/code&gt;, that transforms an Observable that emits strings into an Observable that emits byte arrays that respect character boundaries of multibyte characters in the original strings.</source>
          <target state="translated">В классе &lt;code&gt;StringObservable&lt;/code&gt; , который не является частью ядра RxJava, также есть специальный оператор сопоставления, &lt;code&gt;encode&lt;/code&gt; , который преобразует Observable, который испускает строки, в Observable, который испускает байтовые массивы, которые уважают границы символов многобайтовых символов в исходных строках.</target>
        </trans-unit>
        <trans-unit id="2c205481240cf9f67657691f8018f19dd3c8c2fa" translate="yes" xml:space="preserve">
          <source>In the above code, the source Observable emits the sequence &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt;. When it emits the first item in this sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;code&gt;GroupedObservable&lt;/code&gt; with the key of &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;flatMap&lt;/code&gt; operator applies the &lt;code&gt;take(1)&lt;/code&gt; operator to that &lt;code&gt;GroupedObservable&lt;/code&gt;, which gives it the item (&lt;code&gt;1&lt;/code&gt;) that it emits and that also unsubscribes from the &lt;code&gt;GroupedObservable&lt;/code&gt;, which is terminated. When the source Observable emits the second item in its sequence, the &lt;code&gt;groupBy&lt;/code&gt; operator creates and emits a &lt;em&gt;second&lt;/em&gt;&lt;code&gt;GroupedObservable&lt;/code&gt; with the same key (&lt;code&gt;0&lt;/code&gt;) to replace the one that was terminated. &lt;code&gt;flatMap&lt;/code&gt; again applies &lt;code&gt;take(1)&lt;/code&gt; to this new &lt;code&gt;GroupedObservable&lt;/code&gt; to retrieve the new item to emit (&lt;code&gt;2&lt;/code&gt;) and to unsubscribe from and terminate the &lt;code&gt;GroupedObservable&lt;/code&gt;, and this process repeats for the remaining items in the source sequence.</source>
          <target state="translated">В приведенном выше коде исходный Observable испускает последовательность &lt;code&gt;{ 1 2 3 4 5 }&lt;/code&gt; . Когда он генерирует первый элемент в этой последовательности, оператор &lt;code&gt;groupBy&lt;/code&gt; создает и испускает &lt;code&gt;GroupedObservable&lt;/code&gt; с ключом &lt;code&gt;0&lt;/code&gt; . Оператор &lt;code&gt;flatMap&lt;/code&gt; применяет оператор &lt;code&gt;take(1)&lt;/code&gt; к этому &lt;code&gt;GroupedObservable&lt;/code&gt; , который дает ему элемент ( &lt;code&gt;1&lt;/code&gt; ), который он излучает, а также &lt;code&gt;GroupedObservable&lt;/code&gt; подписку на GroupedObservable , которая завершается. Когда исходный Observable испускает второй элемент в своей последовательности, оператор &lt;code&gt;groupBy&lt;/code&gt; создает и испускает &lt;em&gt;второй &lt;/em&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; с тем же ключом ( &lt;code&gt;0&lt;/code&gt; ) для замены прерванной. &lt;code&gt;flatMap&lt;/code&gt; снова применяет &lt;code&gt;take(1)&lt;/code&gt; к этому новому &lt;code&gt;GroupedObservable&lt;/code&gt; , чтобы получить новый элемент для emit ( &lt;code&gt;2&lt;/code&gt; ), а также отказаться от подписки и завершить &lt;code&gt;GroupedObservable&lt;/code&gt; , и этот процесс повторяется для остальных элементов в исходной последовательности.</target>
        </trans-unit>
        <trans-unit id="3a01097bd263f962d72c9a363627040454cd407d" translate="yes" xml:space="preserve">
          <source>In the asynchronous model the flow goes more like this:</source>
          <target state="translated">В асинхронной модели поток идет скорее так:</target>
        </trans-unit>
        <trans-unit id="9b52ecbc0dd6f70ce33a2a266322bee10c5b7034" translate="yes" xml:space="preserve">
          <source>In the case of Action, the process is similar, but there is no return value. In this case, the Observable created by this operator will emit a &lt;code&gt;null&lt;/code&gt; before terminating.</source>
          <target state="translated">В случае Action процесс аналогичен, но нет возвращаемого значения. В этом случае Observable, созданный этим оператором, перед завершением будет выдавать &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fae0c623313d6102a6c3767b510998af08ec342" translate="yes" xml:space="preserve">
          <source>In the case of a Future, it will emit the single result of the &lt;code&gt;get&lt;/code&gt; call. You may optionally pass the version of &lt;code&gt;from&lt;/code&gt; that accepts a future two additional parameters indicating a timeout span and the units of time that span is denominated in. The resulting Observable will terminate with an error if that span of time passes before the Future responds with a value.</source>
          <target state="translated">В случае Future он выдаст единственный результат вызова &lt;code&gt;get&lt;/code&gt; . При желании вы можете передать версию &lt;code&gt;from&lt;/code&gt; , которая принимает в будущем два дополнительных параметра, указывающих интервал тайм-аута и единицы времени, в которых обозначен интервал. Результирующий Observable завершится с ошибкой, если этот промежуток времени пройдет до того, как Future ответит стоимость.</target>
        </trans-unit>
        <trans-unit id="f0dcc4a6d4282af18fc9e92a4494b472d3679b88" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (не являющемся частью RxGroovy по умолчанию) есть также оператор &lt;code&gt;join&lt;/code&gt; который преобразует Observable, который испускает последовательность строк, в Observable, который испускает одну строку, представляющую конкатенацию каждой из них, разделенную строкой. по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="0af1cd94fd507d9f3d910ef5d0527af5287336a9" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (по умолчанию не является частью RxGroovy) есть также оператор &lt;code&gt;split&lt;/code&gt; который преобразует Observable of Strings в Observable of Strings, который обрабатывает исходную последовательность как поток и разделяет ее на указанной границе регулярного выражения, а затем объединяет результаты этого раскола.</target>
        </trans-unit>
        <trans-unit id="eb5fda7ff19786c8da468ff346658e01540bcd69" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxGroovy by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (не являющемся частью RxGroovy по умолчанию) есть также оператор &lt;code&gt;stringConcat&lt;/code&gt; , который преобразует Observable, который испускает последовательность строк, в Observable, который выдает одну строку, представляющую их все конкатенации.</target>
        </trans-unit>
        <trans-unit id="a7212957ad6271a30e781217f05729777cde9078" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;join&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of each of them, delimited by a string of your choosing.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (не являющемся частью RxJava по умолчанию) есть также оператор &lt;code&gt;join&lt;/code&gt; который преобразует Observable, который испускает последовательность строк, в Observable, который испускает единственную строку, представляющую конкатенацию каждой из них, разделенную строкой по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="dbcfee3dbda596d98d950905c64f0d80750c8c34" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;split&lt;/code&gt; operator that converts an Observable of Strings into an Observable of Strings that treats the source sequence as a stream and splits it on a specified regex boundary, then merges the results of this split.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (который по умолчанию не является частью RxJava) есть также оператор &lt;code&gt;split&lt;/code&gt; который преобразует Observable of Strings в Observable of Strings, который обрабатывает исходную последовательность как поток и разделяет ее на указанной границе регулярного выражения, а затем объединяет результаты этого раскола.</target>
        </trans-unit>
        <trans-unit id="80fab375b638934674bb3b50669b96064b97edfb" translate="yes" xml:space="preserve">
          <source>In the distinct &lt;code&gt;StringObservable&lt;/code&gt; class (not part of RxJava by default) there is also a &lt;code&gt;stringConcat&lt;/code&gt; operator that converts an Observable that emits a sequence of strings into an Observable that emits a single string that represents the concatenation of them all.</source>
          <target state="translated">В отдельном классе &lt;code&gt;StringObservable&lt;/code&gt; (не являющемся частью RxJava по умолчанию) есть также оператор &lt;code&gt;stringConcat&lt;/code&gt; , который преобразует Observable, который испускает последовательность строк, в Observable, который испускает одну строку, представляющую их объединение.</target>
        </trans-unit>
        <trans-unit id="4360fc13798a2ced2520c5e5f6f7e632c555c696" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxGroovy, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">В отдельном пакете &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; , который по умолчанию не входит в RxGroovy, также есть функция &lt;code&gt;runAsync&lt;/code&gt; . Pass &lt;code&gt;runAsync&lt;/code&gt; &lt;code&gt;Action&lt;/code&gt; и &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , и он будет возвращать &lt;code&gt;StoppableObservable&lt;/code&gt; , который использует указанный &lt;code&gt;Action&lt;/code&gt; для создания предметов , которые он излучает.</target>
        </trans-unit>
        <trans-unit id="85226d29791a941dfdc4a830caf1c1b4e7fa5b2f" translate="yes" xml:space="preserve">
          <source>In the separate &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; package, which is not included by default with RxJava, there is also a &lt;code&gt;runAsync&lt;/code&gt; function. Pass &lt;code&gt;runAsync&lt;/code&gt; an &lt;code&gt;Action&lt;/code&gt; and a &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;, and it will return a &lt;code&gt;StoppableObservable&lt;/code&gt; that uses the specified &lt;code&gt;Action&lt;/code&gt; to generate items that it emits.</source>
          <target state="translated">В отдельном пакете &lt;code&gt;RxJavaAsyncUtil&lt;/code&gt; , который по умолчанию не включен в RxJava, также есть функция &lt;code&gt;runAsync&lt;/code&gt; . Pass &lt;code&gt;runAsync&lt;/code&gt; &lt;code&gt;Action&lt;/code&gt; и &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; , и он будет возвращать &lt;code&gt;StoppableObservable&lt;/code&gt; , который использует указанный &lt;code&gt;Action&lt;/code&gt; для создания предметов , которые он излучает.</target>
        </trans-unit>
        <trans-unit id="9c13cd89c3c45da83ad846b47b1bedfc77c6fafa" translate="yes" xml:space="preserve">
          <source>In this way you can include a &lt;code&gt;Future&lt;/code&gt; that returns an Observable in a cascade of Observables as a peer to other Observables.</source>
          <target state="translated">Таким образом, вы можете включить &lt;code&gt;Future&lt;/code&gt; , который возвращает Observable в каскаде Observables в качестве однорангового элемента для других Observable.</target>
        </trans-unit>
        <trans-unit id="4249028943582ec355115c174d01896c5b993590" translate="yes" xml:space="preserve">
          <source>In this way, each item emitted by the resulting Observable is a function of the corresponding item in the source Observable and all of the items emitted by the source Observable after it.</source>
          <target state="translated">Таким образом,каждый элемент,излучаемый результирующим &quot;Наблюдаемым&quot;,является функцией соответствующего элемента в источнике &quot;Наблюдаемым&quot;,а все элементы,излучаемые источником &quot;Наблюдаемым&quot; после него.</target>
        </trans-unit>
        <trans-unit id="72cba1d7a40bef7433b1f435b701d906c44bcbac" translate="yes" xml:space="preserve">
          <source>Instead of passing multiple Observables (up to nine) into &lt;code&gt;merge&lt;/code&gt;, you could also pass in a &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (or other Iterable) of Observables, an Array of Observables, or even an Observable that emits Observables, and &lt;code&gt;merge&lt;/code&gt; will merge their output into the output of a single Observable:</source>
          <target state="translated">Вместо передачи нескольких Observables (до девяти) в &lt;code&gt;merge&lt;/code&gt; вы также можете передать &lt;code&gt;List&amp;lt;&amp;gt;&lt;/code&gt; (или другой Iterable) Observables, массив Observables или даже Observable, который испускает Observables, и &lt;code&gt;merge&lt;/code&gt; объединит их вывод в вывод одного Observable:</target>
        </trans-unit>
        <trans-unit id="011efcd591019b5969a332a24dff728a8107dbe2" translate="yes" xml:space="preserve">
          <source>Interval</source>
          <target state="translated">Interval</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="21bcc15c6b9dfe99deeeef31607f80ad9a914de1" translate="yes" xml:space="preserve">
          <source>Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence. This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline. When using do, it is important to note that the Observer may receive additional events after a stream has completed or errored (such as when using a repeat or resubscribing). If you are using an Observable that extends the AbstractObservable, you will not receive these events. For this special case, use the DoObserver. doOnNext, doOnError, and doOnCompleted uses the DoObserver internally and will receive these additional events.</source>
          <target state="translated">Вызывает действие для каждого элемента наблюдаемой последовательности и вызывает действие при грациозном или исключительном завершении наблюдаемой последовательности.Этот метод может быть использован для отладки,протоколирования и т.д.поведения запроса,перехватывая поток сообщений для выполнения произвольных действий для сообщений на конвейере.При использовании do важно отметить,что наблюдатель может получать дополнительные события после завершения или стирания потока (например,при использовании повтора или переподписки).Если вы используете Наблюдатель,который расширяет абстрактно-отзывное окно,вы не будете получать эти события.Для этого специального случая используйте DoObserver.doOnNext,doOnError и doOnCompleted использует DoObserver внутренне и будет получать эти дополнительные события.</target>
        </trans-unit>
        <trans-unit id="7d0b0f09c8bd2482d8e9bdd538591ca34488ba8f" translate="yes" xml:space="preserve">
          <source>Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.</source>
          <target state="translated">Асинхронно вызывает указанную функцию на указанном планировщике,перемещая результат через наблюдаемую последовательность.</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="e9a2dbf8c765801c6abecc06d035b1c259eda973" translate="yes" xml:space="preserve">
          <source>It decides whether to resubscribe and remirror the source Observable by passing that Observable&amp;rsquo;s termination notifications (error or completed) to a notification handler as &lt;code&gt;void&lt;/code&gt; emissions. This notification handler acts as an Observable operator, taking an Observable that emits these &lt;code&gt;void&lt;/code&gt; notifications as input, and returning an Observable that emits &lt;code&gt;void&lt;/code&gt; items (meaning, resubscribe and mirror the source Observable) or terminates (meaning, terminate the sequence emitted by &lt;code&gt;repeatWhen&lt;/code&gt;).</source>
          <target state="translated">Он решает, следует ли повторно подписаться и повторно отразить исходный Observable, передав уведомления о завершении этого Observable (об ошибках или завершенных) обработчику уведомлений в качестве &lt;code&gt;void&lt;/code&gt; выбросов. Этот обработчик уведомлений действует как оператор Observable, принимая Observable, который испускает эти &lt;code&gt;void&lt;/code&gt; - уведомления, в качестве входных данных и возвращает Observable, который испускает &lt;code&gt;void&lt;/code&gt; элементы (что означает &lt;code&gt;repeatWhen&lt;/code&gt; и зеркальное отображение исходного Observable) или завершается (то есть завершает последовательность, созданную методом repeatWhen ) .</target>
        </trans-unit>
        <trans-unit id="b05b47ee27b95bf575e3effc01ae6ec08f9813b1" translate="yes" xml:space="preserve">
          <source>It does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">По умолчанию он не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2649f51f97bc1799c96a9e6cbbf8c69285c15c00" translate="yes" xml:space="preserve">
          <source>It does not have the variant that uses the emissions from a second Observable to regulate the sampling periodicity.</source>
          <target state="translated">У него нет варианта,использующего выбросы от второго наблюдаемого для регулирования периодичности выборки.</target>
        </trans-unit>
        <trans-unit id="db3a19396735f14c2206b8954fc9b9b7c96aadb3" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="translated">Он расширяет &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;шаблон наблюдателя&lt;/a&gt; для поддержки последовательностей данных и / или событий и добавляет операторы, которые позволяют вам декларативно составлять последовательности вместе, абстрагируясь от проблем, связанных с такими вещами, как низкоуровневые потоки, синхронизация, безопасность потоков, параллельные структуры данных и не- блокировка ввода / вывода.</target>
        </trans-unit>
        <trans-unit id="26cfd44aee2d1282f7da2850ed9a6868a5ea9b7a" translate="yes" xml:space="preserve">
          <source>It extends &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the observer pattern&lt;/a&gt; to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety, concurrent data structures, and non-blocking I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39092222be5c5128f83455e200a511d51d81a068" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="translated">Это &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;трудно использовать фьючерсы , чтобы оптимально условного создания сообщения асинхронного выполнение потоков&lt;/a&gt; (или невозможно, так как латентность каждого запроса изменяется во время выполнения). Это , конечно, &lt;a href=&quot;http://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;можно сделать&lt;/a&gt; , но быстро усложняется (и, следовательно, подвержено ошибкам) ​​или преждевременно блокируется &lt;code&gt;Future.get()&lt;/code&gt; , что исключает преимущества асинхронного выполнения.</target>
        </trans-unit>
        <trans-unit id="891f0aee785e089e9cb621d4692d8eb9f94a2f80" translate="yes" xml:space="preserve">
          <source>It is &lt;a href=&quot;https://gist.github.com/4671081#file-futuresb-java-L163&quot;&gt;difficult to use Futures to optimally compose conditional asynchronous execution flows&lt;/a&gt; (or impossible, since latencies of each request vary at runtime). This &lt;a href=&quot;https://www.amazon.com/gp/product/0321349601?ie=UTF8&amp;amp;tag=none0b69&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321349601&quot;&gt;can be done&lt;/a&gt;, of course, but it quickly becomes complicated (and thus error-prone) or it prematurely blocks on &lt;code&gt;Future.get()&lt;/code&gt;, which eliminates the benefit of asynchronous execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f071bee56464f0e79be82a201585f9d5ef9e78d" translate="yes" xml:space="preserve">
          <source>It is a bad idea to use &lt;code&gt;reduce&lt;/code&gt; to collect emitted items into a mutable data structure. Instead, use &lt;code&gt;collect&lt;/code&gt; for that purpose.</source>
          <target state="translated">Плохая идея использовать &lt;code&gt;reduce&lt;/code&gt; для сбора переданных элементов в изменяемую структуру данных. Вместо этого используйте для этой цели &lt;code&gt;collect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18385c80df1400f4f48ad03f26fe11b4b8b04677" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state from within the function you pass to &lt;code&gt;create&lt;/code&gt; so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">Хорошей практикой является проверка состояния &lt;code&gt;isUnsubscribed&lt;/code&gt; наблюдателя из функции, которую вы передаете для &lt;code&gt;create&lt;/code&gt; чтобы ваш Observable мог прекратить генерировать элементы или выполнять дорогостоящие вычисления, когда больше нет заинтересованного наблюдателя.</target>
        </trans-unit>
        <trans-unit id="f7151837303b01430de52221292363b8696a1db7" translate="yes" xml:space="preserve">
          <source>It is good practice to check the observer&amp;rsquo;s &lt;code&gt;isUnsubscribed&lt;/code&gt; state so that your Observable can stop emitting items or doing expensive calculations when there is no longer an interested observer.</source>
          <target state="translated">Хорошей практикой является проверка состояния &lt;code&gt;isUnsubscribed&lt;/code&gt; наблюдателя, чтобы ваш Observable мог перестать испускать элементы или выполнять дорогостоящие вычисления, когда больше нет заинтересованного наблюдателя.</target>
        </trans-unit>
        <trans-unit id="9807d8fc75f41fdce45545c5c2eab52b2cde18ce" translate="yes" xml:space="preserve">
          <source>It is possible for an Observable to invoke its observers&amp;rsquo; methods asynchronously, perhaps from different threads. This could make such an Observable violate &lt;a href=&quot;../contract&quot;&gt;the Observable contract&lt;/a&gt;, in that it might try to send an &lt;code&gt;OnCompleted&lt;/code&gt; or &lt;code&gt;OnError&lt;/code&gt; notification before one of its &lt;code&gt;OnNext&lt;/code&gt; notifications, or it might make an &lt;code&gt;OnNext&lt;/code&gt; notification from two different threads concurrently. You can force such an Observable to be well-behaved and synchronous by applying the Serialize operator to it.</source>
          <target state="translated">Наблюдаемый объект может вызывать методы своих наблюдателей асинхронно, возможно, из разных потоков. Это может привести к тому, что такой Observable нарушит &lt;a href=&quot;../contract&quot;&gt;контракт Observable&lt;/a&gt; , поскольку он может попытаться отправить уведомление &lt;code&gt;OnCompleted&lt;/code&gt; или &lt;code&gt;OnError&lt;/code&gt; перед одним из своих уведомлений &lt;code&gt;OnNext&lt;/code&gt; , или он может сделать уведомление &lt;code&gt;OnNext&lt;/code&gt; одновременно из двух разных потоков. Вы можете заставить такой Observable вести себя хорошо и синхронно, применив к нему оператор Serialize.</target>
        </trans-unit>
        <trans-unit id="6eff2d2cefa3f5847f61455d90784355746d0b04" translate="yes" xml:space="preserve">
          <source>It is sometimes called &amp;ldquo;functional reactive programming&amp;rdquo; but this is a misnomer. ReactiveX may be functional, and it may be reactive, but &amp;ldquo;functional reactive programming&amp;rdquo; is a different animal. One main point of difference is that functional reactive programming operates on values that change &lt;em&gt;continuously&lt;/em&gt; over time, while ReactiveX operates on &lt;em&gt;discrete&lt;/em&gt; values that are emitted over time. (See &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;Conal Elliott&amp;rsquo;s work for more-precise information on functional reactive programming&lt;/a&gt;.)</source>
          <target state="translated">Иногда это называют &amp;laquo;функциональным реактивным программированием&amp;raquo;, но это неправильное название. ReactiveX может быть функциональным и реактивным, но &amp;laquo;функциональное реактивное программирование&amp;raquo; - другое дело. Одно из основных различий заключается в том, что функциональное реактивное программирование работает со значениями, которые &lt;em&gt;постоянно&lt;/em&gt; меняются с течением времени, в то время как ReactiveX работает с &lt;em&gt;дискретными&lt;/em&gt; значениями, которые генерируются с течением времени. (Более &lt;a href=&quot;https://github.com/conal/essence-and-origins-of-frp&quot;&gt;подробную информацию о функциональном реактивном программировании&lt;/a&gt; см. В работе Конала Эллиотта .)</target>
        </trans-unit>
        <trans-unit id="fdbf510bdf3d816e45ee8d48f0cc1228dc05a4a9" translate="yes" xml:space="preserve">
          <source>It is usually best that you compose new operators by combining existing ones, to the extent that this is possible, rather than reinventing the wheel. RxJava itself does this with some of its standard operators, for example:</source>
          <target state="translated">Обычно лучше всего составлять новые операторы,комбинируя существующие,насколько это возможно,вместо того,чтобы изобретать колесо заново.Сам RxJava делает это,например,с некоторыми из своих стандартных операторов:</target>
        </trans-unit>
        <trans-unit id="89174431a1a966b8fb514184bda6c8efce66dfd4" translate="yes" xml:space="preserve">
          <source>It may call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method any number of times, but these calls must be non-overlapping.</source>
          <target state="translated">Он может вызывать метод &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; подписчика любое количество раз, но эти вызовы не должны перекрываться.</target>
        </trans-unit>
        <trans-unit id="f1823f48cd27350e850e10e37c5ce6fe62ec4444" translate="yes" xml:space="preserve">
          <source>It may call either a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onCompleted( )&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onError( )&lt;/code&gt;&lt;/a&gt; method, but not both, exactly once, and it may not subsequently call a Subscriber's &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt;&lt;code&gt;onNext( )&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Он может вызывать либо метод подписчика &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onCompleted( )&lt;/code&gt; &lt;/a&gt; либо &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onError( )&lt;/code&gt; &lt;/a&gt; , но не оба, ровно один раз, и он не может впоследствии вызывать метод &lt;a href=&quot;observable#onnext-oncompleted-and-onerror&quot;&gt; &lt;code&gt;onNext( )&lt;/code&gt; &lt;/a&gt; подписчика .</target>
        </trans-unit>
        <trans-unit id="2f070c7f11576ed486233e35474ddda41c4700b8" translate="yes" xml:space="preserve">
          <source>It requires one of the following distributions:</source>
          <target state="translated">Для этого требуется одно из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="ca33803823f2ece4ecb5834672e63305ef95cfe5" translate="yes" xml:space="preserve">
          <source>It requires one of the following packages:</source>
          <target state="translated">Для этого требуется один из следующих пакетов:</target>
        </trans-unit>
        <trans-unit id="94d3d61d261c2ecef4925faed7443e2f2b6b049b" translate="yes" xml:space="preserve">
          <source>It requires one of the following:</source>
          <target state="translated">Для этого нужно одно из следующих:</target>
        </trans-unit>
        <trans-unit id="595e4e764020b5cf5ee3bcbb8f01313e97b8eb51" translate="yes" xml:space="preserve">
          <source>It will also emit this same final value to any subsequent observers. However, if the source Observable terminates with an error, the &lt;code&gt;AsyncSubject&lt;/code&gt; will not emit any items, but will simply pass along the error notification from the source Observable.</source>
          <target state="translated">Он также будет передавать это же окончательное значение всем последующим наблюдателям. Однако, если исходный Observable завершается с ошибкой, &lt;code&gt;AsyncSubject&lt;/code&gt; не будет выдавать никаких элементов, а просто передаст уведомление об ошибке из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="34f02c71d6fa00b4deeade3bfbabd8b4f0199f33" translate="yes" xml:space="preserve">
          <source>Iterable (pull)</source>
          <target state="translated">Неустранимый (тяга)</target>
        </trans-unit>
        <trans-unit id="77c1c3007f7e0cc78d64781295922fced377fcae" translate="yes" xml:space="preserve">
          <source>Iterables, for example, can be thought of as a sort of synchronous Observable; Futures, as a sort of Observable that always emits only a single item. By explicitly converting such objects to Observables, you allow them to interact as peers with other Observables.</source>
          <target state="translated">Иterables,например,можно считать своего рода синхронным Observable;Futures,как своего рода Observable,который всегда испускает только один элемент.Явно преобразовывая такие объекты в Observables,вы позволяете им взаимодействовать как одно целое с другими Observables.</target>
        </trans-unit>
        <trans-unit id="d4315de8eb96f9d5efab572bae1c956c26e04d48" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt;&lt;code&gt;all(Predicate)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#all(io.reactivex.functions.Predicate)&quot;&gt; &lt;code&gt;all(Predicate)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c2d2bb807348c5a5bb2c5970e7049467cbc2bc0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d652bb88043ecd2f247b688bb25aba237a1670" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#ambWith(io.reactivex.ObservableSource)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt; Javadoc: ambWith ​​(наблюдаемый)</target>
        </trans-unit>
        <trans-unit id="79801e93b31ea69def0891c5ca351103123a0395" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#empty()&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d612270b0b6dae224275e36de2f214e983b9162a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt;&lt;code&gt;error(Throwable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.lang.Throwable)&quot;&gt; &lt;code&gt;error(Throwable)&lt;/code&gt; &lt;/a&gt; Javadoc: ошибка (возможность выброса)</target>
        </trans-unit>
        <trans-unit id="739b3189dd25d213d0efe5f2677878877c3bb018" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt;&lt;code&gt;error(Callable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#error(java.util.concurrent.Callable)&quot;&gt; &lt;code&gt;error(Callable)&lt;/code&gt; &lt;/a&gt; Javadoc: ошибка (вызываемая)</target>
        </trans-unit>
        <trans-unit id="00d7842c837d4d62344821564ad93d023e2720cb" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt;&lt;code&gt;never()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#never()&quot;&gt; &lt;code&gt;never()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8d8819c38a240885157cbd94598334402e3674d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt;&lt;code&gt;all(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#all(rx.functions.Func1)&quot;&gt; &lt;code&gt;all(Func1)&lt;/code&gt; &lt;/a&gt; Javadoc: все (Func1)</target>
        </trans-unit>
        <trans-unit id="d6e16a78f86bba91a61a8a39b0bee1639141b4a0" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt;&lt;code&gt;amb(Iterable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(java.lang.Iterable)&quot;&gt; &lt;code&gt;amb(Iterable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb914eb34da607efe1851c51fece981b8a5d93ad" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;amb(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observable parameters)</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#amb(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;amb(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (есть также версии, которые принимают до девяти параметров Observable)</target>
        </trans-unit>
        <trans-unit id="6fa8dcea2523bcdb9be5374ff461051895601ef9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt;&lt;code&gt;ambWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#ambWith(rx.Observable)&quot;&gt; &lt;code&gt;ambWith(Observable)&lt;/code&gt; &lt;/a&gt; Javadoc: ambWith ​​(наблюдаемый)</target>
        </trans-unit>
        <trans-unit id="9ac6f58e233b25dd5d275d2b6dbbeb82402fadfd" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt;&lt;code&gt;buffer(int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)&quot;&gt; &lt;code&gt;buffer(int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f4da8ad769c45ae36504e5e4b7db9678f04beed" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt;&lt;code&gt;buffer(int,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)&quot;&gt; &lt;code&gt;buffer(int,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3114cc9509b09ba21be9976417c1d41b12b542" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (длинный, TimeUnit)</target>
        </trans-unit>
        <trans-unit id="f079df920af6fbe33cc7438b0af7d1b861068b58" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (длинный, TimeUnit, int)</target>
        </trans-unit>
        <trans-unit id="a7f01ab7dca8a888386fa5570d9f0b2e382b0f4a" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,int,Scheduler)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (длинный, TimeUnit, int, Scheduler)</target>
        </trans-unit>
        <trans-unit id="a169daeda654c4fee9bff30b2d8a9d0424179071" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (длинный, TimeUnit, Scheduler)</target>
        </trans-unit>
        <trans-unit id="3b62647dc23afa8babf67cfbc877e420f4ebb819" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a877f462a5deb198dfc0204b93c36359d93eae06" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;buffer(long,long,TimeUnit,Scheduler)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86d0c1c1c839634afc3f6c3c4a219ba201e6a4f2" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt;&lt;code&gt;buffer(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)&quot;&gt; &lt;code&gt;buffer(Observable)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="507fd0d63c19e5259957c06f2c5e974b2361ac5e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt;&lt;code&gt;buffer(Observable,int)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)&quot;&gt; &lt;code&gt;buffer(Observable,int)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19480f4a8a048d195247eca7c8ae389d06924f5d" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt;&lt;code&gt;buffer(Observable,Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)&quot;&gt; &lt;code&gt;buffer(Observable,Func1)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (наблюдаемый, Func1)</target>
        </trans-unit>
        <trans-unit id="24c5bc0bbf6f71e96eeb78bdbb7b8d2effc287b6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt;&lt;code&gt;buffer(Func0)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)&quot;&gt; &lt;code&gt;buffer(Func0)&lt;/code&gt; &lt;/a&gt; Javadoc: буфер (Func0)</target>
        </trans-unit>
        <trans-unit id="4208c1d7ad4205ea40fa25a698af88ff2e762b45" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt;&lt;code&gt;cast(Class)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)&quot;&gt; &lt;code&gt;cast(Class)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef3db7ed2c0b62e5c36cbfc3fa2ca492c81d1a49" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt;&lt;code&gt;collect(Func0,Action2)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#collect(rx.functions.Func0,%20rx.functions.Action2)&quot;&gt; &lt;code&gt;collect(Func0,Action2)&lt;/code&gt; &lt;/a&gt; Javadoc: собирать (Func0, Action2)</target>
        </trans-unit>
        <trans-unit id="fa67b873ecab3613f6b64ce78a0bdc32e5926fa9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt;&lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(java.util.List,%20rx.functions.FuncN)&quot;&gt; &lt;code&gt;combineLatest(List,FuncN)&lt;/code&gt; &lt;/a&gt; Javadoc: combLatest (Список, FuncN)</target>
        </trans-unit>
        <trans-unit id="ec7df6aac2f2e3c95a112f207b4dbda0f7a7d0c6" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt;&lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc : &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#combineLatest(rx.Observable,%20rx.Observable,%20rx.functions.Func2)&quot;&gt; &lt;code&gt;combineLatest(Observable,Observable,Func2)&lt;/code&gt; &lt;/a&gt; (есть также версии, которые занимают до девяти Observable)</target>
        </trans-unit>
        <trans-unit id="065654bfbdd9b9bee866590ec170ff626ea47e08" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable&amp;lt;Observable&amp;gt;)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5260958a449491f7610db2dc9bb82bc9b45e109" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt;&lt;code&gt;concat(Observable,Observable)&lt;/code&gt;&lt;/a&gt; (there are also versions that take up to nine Observables)</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concat(rx.Observable,%20rx.Observable)&quot;&gt; &lt;code&gt;concat(Observable,Observable)&lt;/code&gt; &lt;/a&gt; (есть также версии, которые занимают до девяти Observable)</target>
        </trans-unit>
        <trans-unit id="50e62fe96dcbddd17b24ab4cd101fe1c35a3d6df" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt;&lt;code&gt;concatMap(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatMap(rx.functions.Func1)&quot;&gt; &lt;code&gt;concatMap(Func1)&lt;/code&gt; &lt;/a&gt; Javadoc: concatMap (Func1)</target>
        </trans-unit>
        <trans-unit id="d7f8062d4eceee18625891f695512adafea0ce1b" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt;&lt;code&gt;concatWith(Observable)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#concatWith(rx.Observable)&quot;&gt; &lt;code&gt;concatWith(Observable)&lt;/code&gt; &lt;/a&gt; Javadoc: concatWith (наблюдаемый)</target>
        </trans-unit>
        <trans-unit id="af422290d005f62aabe996a727d72476d3979818" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt;&lt;code&gt;contains(Object)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#contains(java.lang.Object)&quot;&gt; &lt;code&gt;contains(Object)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70bacf76ad19d833c6f617bc4a72f0211c2df6b9" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#count()&quot;&gt; &lt;code&gt;count()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0135bdfd6a0be2f5741df4e612e42cc09264016" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt;&lt;code&gt;countLong()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#countLong()&quot;&gt; &lt;code&gt;countLong()&lt;/code&gt; &lt;/a&gt; Javadoc: countLong ()</target>
        </trans-unit>
        <trans-unit id="c6913a045e4bd9b5ec923b8deed52b537c92fcf3" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt;&lt;code&gt;create(OnSubscribe)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#create(rx.Observable.OnSubscribe)&quot;&gt; &lt;code&gt;create(OnSubscribe)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd4e32a121d2f3b9718d60b90e2a55ca637ed7d5" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt;&lt;code&gt;debounce(Func1)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#debounce(rx.functions.Func1)&quot;&gt; &lt;code&gt;debounce(Func1)&lt;/code&gt; &lt;/a&gt; Javadoc: debounce (Func1)</target>
        </trans-unit>
        <trans-unit id="14e04e6e0b8a579ec0455332f25d673a969ebe63" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt;&lt;code&gt;defaultIfEmpty(T)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defaultIfEmpty(T)&quot;&gt; &lt;code&gt;defaultIfEmpty(T)&lt;/code&gt; &lt;/a&gt; Javadoc: defaultIfEmpty (T)</target>
        </trans-unit>
        <trans-unit id="3665f849f7caae696ee21ed577b42416b67b5e53" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#defer(rx.functions.Func0)&quot;&gt; &lt;code&gt;defer()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f24e91a0b092b6e002922bb2340a890ca0edec33" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;delay(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;delay(long,TimeUnit)&lt;/code&gt; &lt;/a&gt; Javadoc: delay (long, TimeUnit)</target>
        </trans-unit>
        <trans-unit id="ef2b29abfc91519e0f51d0c4dd0da82457c7399e" translate="yes" xml:space="preserve">
          <source>Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Документация Javadoc: &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Observable.html#delay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
