<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="reactivex">
    <body>
      <group id="reactivex">
        <trans-unit id="f5d7502112fc6c6bc22f5954998236a234451144" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e39e3ebbd25b567a97952287d377f9dae46b1c0" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;flatMap&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;flatMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f077e0cc4cfe6bf3c028003c80b9ae5b157fd428" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;fromArray&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;fromArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b71e2639dccca221658beee3b68b0525f8c77c8" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;groupBy&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;groupBy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9916754d02cb0d973418e8391606187b45956ca6" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;interval&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;interval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b760f4145f402cdc5420771d6e1151f2a06de8da" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;isEmpty&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;isEmpty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16116a7b668cca5d9439ac3a3ca7d54d9b133461" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fc1ccafcfb97baebb8bd97326f2f23c28b35e49" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;materialize&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;materialize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76875c04b837873dcd31c8449d16fa059f7870ab" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0987649d4b1736b2e29d839f81da6f526eb76397" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfb77faaa650d26d52f5de5afa6c6bd396dfd0ce" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;min&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="017dc67c4a849a1251c77bfa3411d93149abd809" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;multicast&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;multicast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00ed05e070d003d51c053edd5a9e7b29bad0df10" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор начиная &lt;code&gt;of&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a3c98782a2dd2547d369b2e20d29b9952c61aa" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;race&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;race&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82122604dff8c582e8b41c4f09dfbbd520c069a2" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="473a8cbcb88e3eee1374fa8e2366eac0779b0eab" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;reduce&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae89a5966069a54119867d62660c604b5ac7a9f7" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;repeat&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;repeat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e88cb82aff2a86450a63b1f47ab7113866dd0383" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;replay&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;replay&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8309810456d4c8a3fb450f989511d4ca97a5f2" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;retry&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;retry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96be0190f3d3fc503c91d590063f44a320119576" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;scan&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;scan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1f0adb2d5724b28a03046eb2fab6cbfbe6b5aaf" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;share&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07fce018a2c4e1d4d94e654bd3c25c477e5c0c91" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6570ec1baeff52881f92e79c2ad9a4da861a904f" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;skipLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dff7eb9ed29c2313f0cfe0f58e8fba3b2c63e5a" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;skipUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="513b3a413de80dce65d0e00666f5ef5b4c9bf1aa" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;skipWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;skipWhile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e88c511ae3daafbdf76d321b9151b57384484df" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c92b4fc46698d2ae7e26b71de9c32b8c2f6d57e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;startWith&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;startWith&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="832b05105e23624efd86948b924c0f1751818125" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;subscribe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c957f67ad24104a39df6f836fb6b54d70740467" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;sum&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;sum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bdaa3c05aeaf63bae13f0195ca2226795340d12" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;switch&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce05f8533b11c7671d9d453c18145c2e8aed7a22" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e8faa39d887fc4a77c0cbb2a2c07c63d30adbe" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;takeLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9becd98fcde7eb00ee90cbeb4094c495b3d5449" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeUntil&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;takeUntil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7223b628e1c69a31ea40c4223bef42898a005c0e" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;takeWhile&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;takeWhile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b814ec6e39fbd54b10a0d923b95126e6d3bdfd9b" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;throttle&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;throttle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="254b8b5c4b6eb7da28ffdb42f62793a649138295" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a0ffc10f609a37f26f3bbd9752db98ae852d52" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timer&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5a871540bb6d5bbc165c1c3a01d55f9f615992" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;timestamp&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как отметку &lt;code&gt;timestamp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e559c3811597bfc4934e6a3753e9dd2d48a76d" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;toArray&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;toArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d89610894d0e11591b07a8d0b5f707e52e20aff" translate="yes" xml:space="preserve">
          <source>RxPHP implements this operator as &lt;code&gt;zip&lt;/code&gt;.</source>
          <target state="translated">RxPHP реализует этот оператор как &lt;code&gt;zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="693dd13c486759895879d696fa0d950298a01163" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b08fa4aafa83a12fa7ebfe42e4da8aa1978130dc" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;catch_exception on_error_resume_next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f487b92c7d1f5f02bf47e49e97edd32c9562bb8b" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;concat concatAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d7f9553e8f51cdbaa07acff1e4f8c35eb5adb9f" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; RxPY</target>
        </trans-unit>
        <trans-unit id="7140c2e79a019dcc0f9830e029714291144461e3" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;merge merge_all merge_observable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c81899aa32f6f63c27070385f97d5d03d71bd" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;retry&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;retry&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad2236de8db3968c25d85d2b6cf0e5652cd401c7" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0daa3267a7976fd4c6108e56152747f06dda4357" translate="yes" xml:space="preserve">
          <source>RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</source>
          <target state="translated">RxPY &lt;code&gt;window window_with_count window_with_time window_with_time_or_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="270f2d48778b0f06758b9264a8433fde64b901fd" translate="yes" xml:space="preserve">
          <source>RxPY has several Buffer variants: &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;buffer_with_count&lt;/code&gt;, &lt;code&gt;buffer_with_time&lt;/code&gt;, and &lt;code&gt;buffer_with_time_or_count&lt;/code&gt;. For each of these variants there are optional parameters that change the behavior of the operator. As always in RxPY, when an operator may take more than one optional parameter, be sure to name the parameter in the parameter list when you call the operator so as to avoid ambiguity.</source>
          <target state="translated">RxPY имеет несколько вариантов &lt;code&gt;buffer&lt;/code&gt; : buffer , &lt;code&gt;buffer_with_count&lt;/code&gt; , &lt;code&gt;buffer_with_time&lt;/code&gt; и &lt;code&gt;buffer_with_time_or_count&lt;/code&gt; . Для каждого из этих вариантов есть необязательные параметры, изменяющие поведение оператора. Как всегда в RxPY, когда оператор может принимать более одного необязательного параметра, обязательно укажите имя параметра в списке параметров при вызове оператора, чтобы избежать двусмысленности.</target>
        </trans-unit>
        <trans-unit id="1fd6654db5dccbd88806c19c104c30fa3099b447" translate="yes" xml:space="preserve">
          <source>RxPY implements the Catch operator with two distinct operators:</source>
          <target state="translated">RxPY реализует оператора Catch с двумя разными операторами:</target>
        </trans-unit>
        <trans-unit id="997bbecd73d735cf76caff6f3e11f3b5f278d21c" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;merge_all&lt;/code&gt;/&lt;code&gt;merge_observable&lt;/code&gt;.</source>
          <target state="translated">RxPY реализует этот оператор как &lt;code&gt;merge&lt;/code&gt; и &lt;code&gt;merge_all&lt;/code&gt; / &lt;code&gt;merge_observable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64854a6b85df528ef6e41cdcd85374b370c89a23" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;retry&lt;/code&gt;:</source>
          <target state="translated">RxPY реализует этот оператор как &lt;code&gt;retry&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ad669011fa261f9e28135fcb0af82aed927e312b" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator as &lt;code&gt;start_with&lt;/code&gt;. It accepts an array of items which it prepends to the resulting Observable sequence in the order they appear in the array before it emits the items from the source Observable.</source>
          <target state="translated">RxPY реализует этот оператор как &lt;code&gt;start_with&lt;/code&gt; . Он принимает массив элементов, которые он добавляет к результирующей последовательности Observable в том порядке, в котором они появляются в массиве, прежде чем он испускает элементы из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="7ec7900945bed69788945e976470cea403e81661" translate="yes" xml:space="preserve">
          <source>RxPY implements this operator with several variants of four different functions.</source>
          <target state="translated">RxPY реализует этот оператор с несколькими вариантами четырех различных функций.</target>
        </trans-unit>
        <trans-unit id="f1d67170a06e97a4449045c839dc5d1e2382b69d" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;+:&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;+:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcef499d4c4fb2f6d94f8c4cef84a8b26d465d06" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;concat ++&lt;/code&gt;</source>
          <target state="translated">RxScala concat &lt;code&gt;concat ++&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e990f0e0a54de0238f215152d4442c39ce492c0" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;count length longCount size&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;count length longCount size&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed829eaad25e9f641868bfa691741709980df995" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</source>
          <target state="translated">RxScala Flatten &lt;code&gt;flatten flattenDelayError merge mergeDelayError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d9b6011a4b7d18c76b5a21d4203132c6cd933ab" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;onErrorFlatMap onErrorResumeNext onErrorReturn onExceptionResumeNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="563a94ee27ba81015d3aeed667733daeed349e03" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;retry retryWhen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e07e71d4f4652a21fd420d1ab1de3e2951e86f7" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;sliding tumbling&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sliding tumbling&lt;/code&gt; RxScala</target>
        </trans-unit>
        <trans-unit id="4ba1f219f82e8f92570a08b4c69107dc38cc7ceb" translate="yes" xml:space="preserve">
          <source>RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt;</source>
          <target state="translated">RxScala &lt;code&gt;slidingBuffer tumblingBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39a7d257695fedcf6f7513b3c29a4532e1ea9e0b" translate="yes" xml:space="preserve">
          <source>RxScala has two varieties of Buffer &amp;mdash; &lt;code&gt;slidingBuffer&lt;/code&gt; and &lt;code&gt;tumblingBuffer&lt;/code&gt; &amp;mdash; each of which has variants with different ways of assembling the buffers they emit:</source>
          <target state="translated">RxScala имеет две разновидности буфер - &lt;code&gt;slidingBuffer&lt;/code&gt; и &lt;code&gt;tumblingBuffer&lt;/code&gt; - каждый из которых имеет варианты с различными способами сборки буферов они испускают:</target>
        </trans-unit>
        <trans-unit id="49dbca94ff276bf9d442df62b994dee8a001be10" translate="yes" xml:space="preserve">
          <source>RxScala has two versions of this operator: &lt;code&gt;retry&lt;/code&gt; and &lt;code&gt;retryWhen&lt;/code&gt;.</source>
          <target state="translated">RxScala имеет две версии этого оператора: &lt;code&gt;retry&lt;/code&gt; и &lt;code&gt;retryWhen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a52c08948f140da58bfdcde6019760eb047a5893" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;flatten&lt;/code&gt;, &lt;code&gt;flattenDelayError&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, and &lt;code&gt;mergeDelayError&lt;/code&gt;.</source>
          <target state="translated">RxScala реализует этот оператор , как &lt;code&gt;flatten&lt;/code&gt; , &lt;code&gt;flattenDelayError&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; и &lt;code&gt;mergeDelayError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39eccc9709809defbe492077eaf3cc6d83d3e433" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator as &lt;code&gt;sliding&lt;/code&gt; (creates windows that may overlap or have gaps) and &lt;code&gt;tumbling&lt;/code&gt; (creates windows whose collective emissions match those of the source Observable one-to-one).</source>
          <target state="translated">RxScala реализует этот оператор как &lt;code&gt;sliding&lt;/code&gt; (создает окна, которые могут перекрываться или иметь промежутки) и &lt;code&gt;tumbling&lt;/code&gt; (создает окна, совокупные выбросы которых совпадают с исходным Observable один к одному).</target>
        </trans-unit>
        <trans-unit id="abd5b95c1e25b6159372d87c175648f0d5290301" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator in two ways. There is a &lt;code&gt;concat&lt;/code&gt; operator that accepts an Observable of Observables as its parameter, and then concatenates each of these Observables in the order they are emitted. There is also a &lt;code&gt;++&lt;/code&gt; operator that concatenates one Observable to another.</source>
          <target state="translated">RxScala реализует этот оператор двумя способами. Существует оператор &lt;code&gt;concat&lt;/code&gt; , который принимает Observable of Observables в качестве параметра, а затем объединяет каждый из этих Observable в том порядке, в котором они генерируются. Также существует оператор &lt;code&gt;++&lt;/code&gt; , который объединяет один Observable с другим.</target>
        </trans-unit>
        <trans-unit id="cea120686efc2c1a225b8c5d36b8c8a2546ed795" translate="yes" xml:space="preserve">
          <source>RxScala implements this operator with &lt;code&gt;+:&lt;/code&gt; It takes an item and an Observable as parameters, and prepends the item to the items emitted by the Observable as its own Observable sequence.</source>
          <target state="translated">RxScala реализует этот оператор с помощью &lt;code&gt;+:&lt;/code&gt; он принимает элемент и Observable в качестве параметров и добавляет элемент к элементам, генерируемым Observable, как свою собственную последовательность Observable.</target>
        </trans-unit>
        <trans-unit id="7aee45e741f377a8920ab095d941fa4d0aa645e1" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;create generate&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;create generate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3db1b8cf654b640f6385d1a6b05692292a59ad5f" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;from toObservable&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;from toObservable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4c9d6bed1ede16cf84de597f7384adbcd65a4df" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;just sequenceOf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d4e8e91a479b7c9366d77f396ae487f990b467c" translate="yes" xml:space="preserve">
          <source>RxSwift &lt;code&gt;merge&lt;/code&gt;</source>
          <target state="translated">RxSwift &lt;code&gt;merge&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a00334313be967429412cd5d38086f0879ce4fd" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="translated">RxSwift реализует этот оператор как &lt;code&gt;create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="588e95814c5e31b0ac881ca2f54f2f8d85b98a60" translate="yes" xml:space="preserve">
          <source>RxSwift implements this operator as &lt;code&gt;merge&lt;/code&gt;.</source>
          <target state="translated">RxSwift реализует этот оператор как &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08fe3e272ac8a840ae0419188778167b77dfba85" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;buffer_with_count buffer_with_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85e804e67cc2836d4ddbb8cf5a880cac3b949246" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;concat merge_all&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf397e3bfea0116e080b5016e227d6d855282363" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; Rxrb</target>
        </trans-unit>
        <trans-unit id="3c58630d6a27e4165c3459321a03d4d7999ee328" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;merge merge_all merge_concurrent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42b8dfaca4f34d142d3e9d8366843183b5a84671" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;on_error_resume_next rescue_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df48fa3e5b8f8a30e164ea1f4851bd4e9bed232c" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;retry retry_infinitely&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;retry retry_infinitely&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a50ff5d458a6a3a00e213fe188f13ef8d6625fa8" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;start_with&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;start_with&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="714fa5ff8b3c9def68b57d14f6d9b843dccdf5c5" translate="yes" xml:space="preserve">
          <source>Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</source>
          <target state="translated">Rxrb &lt;code&gt;window_with_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58fabfa70811950fc1a8c6e0d56faec87e4e08cb" translate="yes" xml:space="preserve">
          <source>Sample</source>
          <target state="translated">Sample</target>
        </trans-unit>
        <trans-unit id="db412b35391491a23074f474e3dd7ab6ca4b7fa3" translate="yes" xml:space="preserve">
          <source>Sample Code</source>
          <target state="translated">Образец кода</target>
        </trans-unit>
        <trans-unit id="28cba55d2aadf568463a9e7e645f8c7b1eed5e8b" translate="yes" xml:space="preserve">
          <source>Scan</source>
          <target state="translated">Scan</target>
        </trans-unit>
        <trans-unit id="cdcb4d8493703e86ddd0f22eb1ff805a9c89e0d9" translate="yes" xml:space="preserve">
          <source>Scheduler</source>
          <target state="translated">Scheduler</target>
        </trans-unit>
        <trans-unit id="e87e52ff4851168a4b90a0a3101d9e9213c6f05e" translate="yes" xml:space="preserve">
          <source>Schedulers</source>
          <target state="translated">Schedulers</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="fe62ba3ec2492fa0dd21300f90b4d59db54088d3" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;start&quot;&gt;Start&lt;/a&gt; operator for more information about those operators.</source>
          <target state="translated">См. Оператор &lt;a href=&quot;start&quot;&gt;Start&lt;/a&gt; для получения дополнительной информации об этих операторах.</target>
        </trans-unit>
        <trans-unit id="49229070d9275f2e39ff0135c499c3ec82be4d2d" translate="yes" xml:space="preserve">
          <source>SequenceEqual</source>
          <target state="translated">SequenceEqual</target>
        </trans-unit>
        <trans-unit id="6d6721069e94a67d89931555797dda0103cb23bb" translate="yes" xml:space="preserve">
          <source>Serialize</source>
          <target state="translated">Serialize</target>
        </trans-unit>
        <trans-unit id="dd1186892a2f5c2bd17cd7d41f90482e39bd02c5" translate="yes" xml:space="preserve">
          <source>Single</source>
          <target state="translated">Single</target>
        </trans-unit>
        <trans-unit id="3da474537ac378c616d6b301acc1674bc348cecd" translate="yes" xml:space="preserve">
          <source>Skip</source>
          <target state="translated">Skip</target>
        </trans-unit>
        <trans-unit id="cff8beecc61f3252bacde95ccb2d21cb2c7bb3de" translate="yes" xml:space="preserve">
          <source>SkipLast</source>
          <target state="translated">SkipLast</target>
        </trans-unit>
        <trans-unit id="bd69ea5a210dcd2d5ba05305f96e8abd8c637cac" translate="yes" xml:space="preserve">
          <source>SkipUntil</source>
          <target state="translated">SkipUntil</target>
        </trans-unit>
        <trans-unit id="22e179bea92af551a86509fda88cb097314902ec" translate="yes" xml:space="preserve">
          <source>SkipWhile</source>
          <target state="translated">SkipWhile</target>
        </trans-unit>
        <trans-unit id="58ecadbac79fe5cc51359cb68804c30a5376637e" translate="yes" xml:space="preserve">
          <source>Some Notes on Naming Conventions</source>
          <target state="translated">Некоторые записки о конвенциях по наименованию</target>
        </trans-unit>
        <trans-unit id="0b85a6daf91059f7033cbb077e016fc28a7f815d" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxGroovy have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">Некоторые наблюдаемые операторы в RxGroovy имеют альтернативные формы,которые позволяют задать,какой Scheduler оператор будет использовать для (хотя бы некоторой части)своей работы.Другие не работают на определенном Планировщике,или работают на определенном Планировщике по умолчанию.К ним относятся те,которые имеют определенный Планировщик по умолчанию:</target>
        </trans-unit>
        <trans-unit id="fbcdf6312e8b52916c1de7617e91f5554391d0ef" translate="yes" xml:space="preserve">
          <source>Some Observable operators in RxJava have alternate forms that allow you to set which Scheduler the operator will use for (at least some part of) its operation. Others do not operate on any particular Scheduler, or operate on a particular default Scheduler. Those that have a particular default Scheduler include:</source>
          <target state="translated">Некоторые наблюдаемые операторы в RxJava имеют альтернативные формы,которые позволяют задать,какой Scheduler оператор будет использовать для (хотя бы некоторой части)своей работы.Другие не работают на определенном Планировщике,или работают на определенном Планировщике по умолчанию.К ним относятся те,которые имеют определенный Планировщик по умолчанию:</target>
        </trans-unit>
        <trans-unit id="38cb086c4a233cb1a5333ff9d36f701c059eb82f" translate="yes" xml:space="preserve">
          <source>Some ReactiveX Observable operators have variants that take a Scheduler as a parameter. These instruct the operator to do some or all of its work on a particular Scheduler.</source>
          <target state="translated">Некоторые операторы ReactiveX Observable имеют варианты,принимающие в качестве параметра планировщик.Они инструктируют оператора выполнять часть или всю работу над определенным Планировщиком.</target>
        </trans-unit>
        <trans-unit id="4ac9202dc9541026835ce69df02b385e6fb504c2" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;firstOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">Несколько сбивает с толку, есть также операторы &lt;code&gt;BlockingObservable&lt;/code&gt; , вызываемые &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;firstOrDefault&lt;/code&gt; , которые блокируют, а затем возвращают элементы, а не немедленно возвращают Observables.</target>
        </trans-unit>
        <trans-unit id="1fee22cfdb8ade626b92fda4b1958a7e7558e18d" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, there are also &lt;code&gt;BlockingObservable&lt;/code&gt; operators called &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;lastOrDefault&lt;/code&gt; that block and then return items, rather than immediately returning Observables.</source>
          <target state="translated">Несколько сбивает с толку, есть также операторы &lt;code&gt;BlockingObservable&lt;/code&gt; , называемые &lt;code&gt;last&lt;/code&gt; и &lt;code&gt;lastOrDefault&lt;/code&gt; , которые блокируют, а затем возвращают элементы, а не немедленно возвращают Observables.</target>
        </trans-unit>
        <trans-unit id="2083d000ffd0eaf7ff35e1d13313255d25a9dcad" translate="yes" xml:space="preserve">
          <source>Specialty Observables that have more precisely-controlled subscription dynamics</source>
          <target state="translated">Особенности Наблюдатели,которые имеют более точно контролируемую динамику подписки</target>
        </trans-unit>
        <trans-unit id="952f375412e89ff213a8aca383d18e5691354347" translate="yes" xml:space="preserve">
          <source>Start</source>
          <target state="translated">Start</target>
        </trans-unit>
        <trans-unit id="c0fcf7ef2af334dc9a60fd70a03cde9ff6d0d67c" translate="yes" xml:space="preserve">
          <source>StartWith</source>
          <target state="translated">StartWith</target>
        </trans-unit>
        <trans-unit id="1bee4f94669039b2e98e1615609a98c4999cb704" translate="yes" xml:space="preserve">
          <source>Store the return value from that method in a variable.</source>
          <target state="translated">Храните возвращаемое значение этого метода в переменной.</target>
        </trans-unit>
        <trans-unit id="8d183dbdcea3b29906090bd83fa6fa37923cc8ec" translate="yes" xml:space="preserve">
          <source>Subject</source>
          <target state="translated">Subject</target>
        </trans-unit>
        <trans-unit id="d6981f74767d6c63d6062ad21b3bdfcd0d0d6602" translate="yes" xml:space="preserve">
          <source>Subscribe</source>
          <target state="translated">Subscribe</target>
        </trans-unit>
        <trans-unit id="b64e02707b3e5c59a9924b22e0b846d7b7419584" translate="yes" xml:space="preserve">
          <source>SubscribeOn</source>
          <target state="translated">SubscribeOn</target>
        </trans-unit>
        <trans-unit id="d43687ae3f766f223ccfd61d7f61537fe7c5cb98" translate="yes" xml:space="preserve">
          <source>Subscribing and Unsubscribing</source>
          <target state="translated">Подписка и отказ от подписки</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="a5692ec6b5b1da2cd6263a5d9d0a45278c9c4f55" translate="yes" xml:space="preserve">
          <source>Switch subscribes to an Observable that emits Observables. Each time it observes one of these emitted Observables, the Observable returned by Switch unsubscribes from the previously-emitted Observable begins emitting items from the latest Observable. Note that it will unsubscribe from the previously-emitted Observable when a new Observable is emitted from the source Observable, not when the new Observable emits an item. This means that items emitted by the previous Observable between the time the subsequent Observable is emitted and the time that subsequent Observable itself begins emitting items will be dropped (as with the yellow circle in the diagram above).</source>
          <target state="translated">Переключатель подписывается на Наблюдатель,который излучает Наблюдатели.Каждый раз,когда он наблюдает за одним из этих &quot;Наблюдаемых&quot;,&quot;Наблюдаемый&quot;,возвращаемый Переключателем unsubscribescribe из предыдущего &quot;Наблюдаемого&quot;,начинает испускать элементы из последнего &quot;Наблюдаемого&quot;.Обратите внимание,что он отпишется от ранее отпущенного Наблюдаемого,когда из источника будет выделено новое Наблюдаемое,а не когда из нового Наблюдаемого будет выделено какое-либо изделие.Это означает,что элементы,излучаемые предыдущим Наблюдаемым в промежутке между моментом подачи следующего Наблюдаемого и моментом начала подачи самого следующего Наблюдаемого,будут сброшены (как в случае с желтым кружком на рисунке выше).</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="56806a1ffdde7ef9980b8850997e6a7523aaf863" translate="yes" xml:space="preserve">
          <source>Take</source>
          <target state="translated">Take</target>
        </trans-unit>
        <trans-unit id="5dcddcd939a62e3fadc4a275cfbff50387ce425c" translate="yes" xml:space="preserve">
          <source>TakeLast</source>
          <target state="translated">TakeLast</target>
        </trans-unit>
        <trans-unit id="9fcf25633e653a4948dd51bdc131ece0fd641fd5" translate="yes" xml:space="preserve">
          <source>TakeLastBuffer</source>
          <target state="translated">TakeLastBuffer</target>
        </trans-unit>
        <trans-unit id="6aa5940e9dd4c148413441073a4cc00a8f767785" translate="yes" xml:space="preserve">
          <source>TakeUntil</source>
          <target state="translated">TakeUntil</target>
        </trans-unit>
        <trans-unit id="3a51f26ad628e90629aea4f7cb0d24e3af6895e3" translate="yes" xml:space="preserve">
          <source>TakeWhile</source>
          <target state="translated">TakeWhile</target>
        </trans-unit>
        <trans-unit id="460dcd29ba7372ee8c706f180c5f17bea77b1f32" translate="yes" xml:space="preserve">
          <source>Takes a transforming function that operates on each element.</source>
          <target state="translated">Принимает преобразующую функцию,которая работает на каждом элементе.</target>
        </trans-unit>
        <trans-unit id="f7b71bba78008ddb77fc959998b4ce8821595bc5" translate="yes" xml:space="preserve">
          <source>Techniques like &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; are straightforward to use for &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;a single level of asynchronous execution&lt;/a&gt; but they start to add &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;non-trivial complexity&lt;/a&gt; when they&amp;rsquo;re nested.</source>
          <target state="translated">Такие методы, как &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; , просто использовать для &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;одного уровня асинхронного выполнения,&lt;/a&gt; но они начинают добавлять &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;нетривиальную сложность,&lt;/a&gt; когда они вложены.</target>
        </trans-unit>
        <trans-unit id="921c91a69fe6363fdaf8bafdf810efd4bf0646d8" translate="yes" xml:space="preserve">
          <source>Techniques like &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html&quot;&gt;Java Futures&lt;/a&gt; are straightforward to use for &lt;a href=&quot;https://gist.github.com/4670979&quot;&gt;a single level of asynchronous execution&lt;/a&gt; but they start to add &lt;a href=&quot;https://gist.github.com/4671081&quot;&gt;non-trivial complexity&lt;/a&gt; when they&amp;rsquo;re nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8118896f61d1f07d69ebf7d91ff45f22736deb" translate="yes" xml:space="preserve">
          <source>Test Scheduler</source>
          <target state="translated">Планировщик тестов</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="d10b3f041bfb2c3ec591fc7431252ff0aa39e7c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;merge&quot;&gt;Merge&lt;/a&gt; operator is also similar. It combines the emissions of two or more Observables, but may interleave them, whereas Concat never interleaves the emissions from multiple Observables.</source>
          <target state="translated">Оператор &lt;a href=&quot;merge&quot;&gt;слияния&lt;/a&gt; также похож. Он объединяет выбросы двух или более Observable, но может чередовать их, тогда как Concat никогда не чередует выбросы от нескольких Observable.</target>
        </trans-unit>
        <trans-unit id="6baefa7e9f9fcf85d05a1f29dafd893921c34fe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;observeon&quot;&gt;ObserveOn&lt;/a&gt; operator is similar, but more limited. It instructs the Observable to send notifications to observers on a specified Scheduler.</source>
          <target state="translated">Оператор &lt;a href=&quot;observeon&quot;&gt;ObserveOn&lt;/a&gt; аналогичен, но более ограничен. Он инструктирует Observable отправлять уведомления наблюдателям в указанном планировщике.</target>
        </trans-unit>
        <trans-unit id="f304d9aafcbc1e3a4ceb81b1ed4873b673f3f5eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;startwith&quot;&gt;StartWith&lt;/a&gt; operator is similar to Concat, but &lt;em&gt;prepends&lt;/em&gt;, rather than appends, items or emissions of items to those emitted by a source Observable.</source>
          <target state="translated">&lt;a href=&quot;startwith&quot;&gt;StartWith&lt;/a&gt; оператор аналогичен Concat, но &lt;em&gt;Добавление в начале&lt;/em&gt; , а не добавляет, предметов или выбросов элементов для тех , излучаемых источника наблюдаем.</target>
        </trans-unit>
        <trans-unit id="b4fbf4d3f33e46f4107fb78991ae6736b2b937af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;subscribeon&quot;&gt;SubscribeOn&lt;/a&gt; operator is similar, but it instructs the Observable to &lt;em&gt;itself&lt;/em&gt; operate on the specified Scheduler, as well as notifying its observers on that Scheduler.</source>
          <target state="translated">Оператор &lt;a href=&quot;subscribeon&quot;&gt;SubscribeOn&lt;/a&gt; аналогичен, но он инструктирует Observable самому &lt;em&gt;себе&lt;/em&gt; работать с указанным планировщиком, а также уведомляет своих наблюдателей об этом планировщике.</target>
        </trans-unit>
        <trans-unit id="49008cbd0eaec3057954e658f6781db5c9ae198a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; operator is similar to Buffer but collects items into separate Observables rather than into data structures before reemitting them.</source>
          <target state="translated">Оператор &lt;a href=&quot;window&quot;&gt;Window&lt;/a&gt; похож на Buffer, но собирает элементы в отдельные Observables, а не в структуры данных перед их повторной отправкой.</target>
        </trans-unit>
        <trans-unit id="b199fbd77dba31c34f4c4ce3e9dfed07aa603b91" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Action&lt;/code&gt; accepts an &lt;code&gt;Observer&lt;/code&gt; and a &lt;code&gt;Subscription&lt;/code&gt;. It uses the &lt;code&gt;Subscription&lt;/code&gt; to check for the &lt;code&gt;isUnsubscribed&lt;/code&gt; condition, upon which it will stop emitting items. You can also manually stop a &lt;code&gt;StoppableObservable&lt;/code&gt; at any time by calling its &lt;code&gt;unsubscribe&lt;/code&gt; method (which will also unsubscribe the &lt;code&gt;Subscription&lt;/code&gt; you have associated with the &lt;code&gt;StoppableObservable&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Action&lt;/code&gt; принимает &lt;code&gt;Observer&lt;/code&gt; и &lt;code&gt;Subscription&lt;/code&gt; . Он использует &lt;code&gt;Subscription&lt;/code&gt; для проверки условия &lt;code&gt;isUnsubscribed&lt;/code&gt; , после чего прекращает отправку элементов. Вы также можете вручную остановить &lt;code&gt;StoppableObservable&lt;/code&gt; в любое время, вызвав его метод отказа от &lt;code&gt;unsubscribe&lt;/code&gt; (который также &lt;code&gt;StoppableObservable&lt;/code&gt; &lt;code&gt;Subscription&lt;/code&gt; вы связали с StoppableObservable ).</target>
        </trans-unit>
        <trans-unit id="4c70ce024057f9c87440087a96f9e5498f333be4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; Methods</source>
          <target state="translated">В &lt;code&gt;BlockingObservable&lt;/code&gt; методы</target>
        </trans-unit>
        <trans-unit id="ad1dffc2751d9cb748f91bf966099a5d8311f9ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlockingObservable&lt;/code&gt; methods do not transform an Observable into another, filtered Observable, but rather they break out of the Observable cascade, blocking until the Observable emits the desired item, and then return that item itself.</source>
          <target state="translated">В &lt;code&gt;BlockingObservable&lt;/code&gt; методов не трансформирующие Наблюдаемый в другую, фильтрует Observable, а они ломаются из Наблюдаемой каскады, блокирования до наблюдаемого испускают нужный пункт, а затем возвращают этот элемент сами.</target>
        </trans-unit>
        <trans-unit id="e36745296ecb1b3339f4a779c2c85cc4ac305d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Catch&lt;/code&gt; operator has a variant that allows you to specify which sort of Exception you want to catch. If you use that variant of the operator, any other Exceptions will be passed through to the observer as if the &lt;code&gt;Catch&lt;/code&gt; operator had not been applied.</source>
          <target state="translated">У оператора &lt;code&gt;Catch&lt;/code&gt; есть вариант, который позволяет вам указать, какой тип исключения вы хотите перехватить. Если вы используете этот вариант оператора, любые другие исключения будут переданы наблюдателю, как если бы оператор &lt;code&gt;Catch&lt;/code&gt; не применялся.</target>
        </trans-unit>
        <trans-unit id="bdf5a795f14235ad0056e88296b8e1c0457d71fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ElementAt&lt;/code&gt; operator pulls an item located at a specified index location in the sequence of items emitted by the source Observable and emits that item as its own sole emission.</source>
          <target state="translated">Оператор &lt;code&gt;ElementAt&lt;/code&gt; извлекает элемент, расположенный в указанном месте индекса в последовательности элементов, выдаваемых источником Observable, и излучает этот элемент как свое собственное излучение.</target>
        </trans-unit>
        <trans-unit id="c9ca6a8982e977288317bbaf760bb05436d1fac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Join&lt;/code&gt; operator combines the items emitted by two Observables, and selects which items to combine based on duration-windows that you define on a per-item basis. You implement these windows as Observables whose lifespans begin with each item emitted by either Observable. When such a window-defining Observable either emits an item or completes, the window for the item it is associated with closes. So long as an item&amp;rsquo;s window is open, it will combine with any item emitted by the other Observable. You define the function by which the items combine.</source>
          <target state="translated">Оператор &lt;code&gt;Join&lt;/code&gt; объединяет элементы, генерируемые двумя Observable, и выбирает, какие элементы объединить, на основе окон продолжительности, которые вы определяете для каждого элемента. Вы реализуете эти окна как Observable, чья продолжительность жизни начинается с каждого элемента, генерируемого Observable. Когда такой определяющий окно Observable либо излучает элемент, либо завершает работу, окно для элемента, с которым он связан, закрывается. Пока окно элемента открыто, оно будет объединяться с любым элементом, испускаемым другим Observable. Вы определяете функцию, с помощью которой элементы объединяются.</target>
        </trans-unit>
        <trans-unit id="49b6f233307919ab9a0d77721efeeeb85eb2427b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StringObservable&lt;/code&gt; class, which is not a default part of RxGroovy, also includes the &lt;code&gt;decode&lt;/code&gt; operator which converts a stream of multibyte characters into an Observable that emits byte arrays that respect the character boundaries.</source>
          <target state="translated">Класс &lt;code&gt;StringObservable&lt;/code&gt; , который не является частью RxGroovy по умолчанию, также включает в себя оператор &lt;code&gt;decode&lt;/code&gt; который преобразует поток многобайтовых символов в Observable, который генерирует байтовые массивы, соблюдающие границы символа.</target>
        </trans-unit>
        <trans-unit id="4647c758a074dfb5917c11c1702ea9f0320221fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Worker&lt;/code&gt; is also a &lt;code&gt;Subscription&lt;/code&gt; and so you can (and should, eventually) call its &lt;code&gt;unsubscribe&lt;/code&gt; method to signal that it can halt work and release resources:</source>
          <target state="translated">&lt;code&gt;Worker&lt;/code&gt; также &lt;code&gt;Subscription&lt;/code&gt; , и поэтому вы можете (и должны, в конце концов) вызвать его &lt;code&gt;unsubscribe&lt;/code&gt; методы сигнала , который может остановить работу и освободить ресурсы:</target>
        </trans-unit>
        <trans-unit id="62aae628c204daa23511b0a50e55402c802b725c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Zip&lt;/code&gt; method returns an Observable that applies a function of your choosing to the combination of items emitted, in sequence, by two (or more) other Observables, with the results of this function becoming the items emitted by the returned Observable. It applies this function in strict sequence, so the first item emitted by the new Observable will be the result of the function applied to the first item emitted by Observable #1 and the first item emitted by Observable #2; the second item emitted by the new zip-Observable will be the result of the function applied to the second item emitted by Observable #1 and the second item emitted by Observable #2; and so forth. It will only emit as many items as the number of items emitted by the source Observable that emits the fewest items.</source>
          <target state="translated">Метод &lt;code&gt;Zip&lt;/code&gt; возвращает Observable, который применяет выбранную вами функцию к комбинации элементов, испускаемых последовательно двумя (или более) другими Observable, при этом результаты этой функции становятся элементами, испускаемыми возвращенным Observable. Он применяет эту функцию в строгой последовательности, поэтому первый элемент, созданный новым Observable, будет результатом функции, примененной к первому элементу, созданному Observable # 1, и первому элементу, созданному Observable # 2; второй элемент, созданный новым zip-Observable, будет результатом функции, примененной ко второму элементу, созданному Observable # 1, и второму элементу, созданному Observable # 2; и так далее. Он будет генерировать столько элементов, сколько количество элементов, выпущенных источником Observable, который излучает наименьшее количество элементов.</target>
        </trans-unit>
        <trans-unit id="e5691c91ab07a55b1c3fb75c15c16429d75b4d53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cast&lt;/code&gt; operator is a specialized version of Map that transforms each item from the source Observable by casting it into a particular Class before reemitting it.</source>
          <target state="translated">Оператор &lt;code&gt;cast&lt;/code&gt; - это специализированная версия Map, которая преобразует каждый элемент из исходного Observable путем преобразования его в конкретный класс перед его повторной отправкой.</target>
        </trans-unit>
        <trans-unit id="2d52bc5228a5c99adbd13b94db13bf682b4106af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collect&lt;/code&gt; operator is similar to &lt;code&gt;reduce&lt;/code&gt; but is specialized for the purpose of collecting the whole set of items emitted by the source Observable into a single mutable data structure to be emitted by the resulting Observable. Pass it two parameters:</source>
          <target state="translated">Оператор &lt;code&gt;collect&lt;/code&gt; аналогичен оператору &lt;code&gt;reduce&lt;/code&gt; , но специализируется на сборе всего набора элементов, выдаваемых исходным Observable, в единую изменяемую структуру данных, которая будет выдана результирующим Observable. Передайте ему два параметра:</target>
        </trans-unit>
        <trans-unit id="6cf0adfab79277c51e5dafe6774782092f0c83c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concat*&lt;/code&gt; operator concatenates the Observables emitted by an Observable together, in the order in which they are emitted.</source>
          <target state="translated">Оператор &lt;code&gt;concat*&lt;/code&gt; объединяет Observable, генерируемые Observable, вместе в том порядке, в котором они генерируются.</target>
        </trans-unit>
        <trans-unit id="262174a50de88e018bb2bb7470c296853e50fc00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Disposable&lt;/code&gt;. You can call that &lt;code&gt;Disposable&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;dispose&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">Метод &lt;code&gt;connect&lt;/code&gt; возвращает &lt;code&gt;Disposable&lt;/code&gt; . Вы можете назвать это &lt;code&gt;Disposable&lt;/code&gt; объекта &lt;code&gt;dispose&lt;/code&gt; метод поручить Наблюдаемые прекратить излучающие элементы для своих абонентов.</target>
        </trans-unit>
        <trans-unit id="0f476bb86d90183235c41e4ed71417a68f5fc2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect&lt;/code&gt; method returns a &lt;code&gt;Subscription&lt;/code&gt;. You can call that &lt;code&gt;Subscription&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;unsubscribe&lt;/code&gt; method to instruct the Observable to stop emitting items to its Subscribers.</source>
          <target state="translated">Метод &lt;code&gt;connect&lt;/code&gt; возвращает &lt;code&gt;Subscription&lt;/code&gt; . Вы можете назвать это &lt;code&gt;Subscription&lt;/code&gt; объекта &lt;code&gt;unsubscribe&lt;/code&gt; метод поручить Наблюдаемые прекратить излучающие элементы для своих абонентов.</target>
        </trans-unit>
        <trans-unit id="32a0f2e47fcf367aab2c4d2fea54935a14d32d23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; operator in RxJS takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item.</source>
          <target state="translated">Оператор &lt;code&gt;contains&lt;/code&gt; в RxJS принимает необязательный второй параметр: отсчитываемый от нуля индекс в исходной последовательности Observable, с которой начинается поиск элемента.</target>
        </trans-unit>
        <trans-unit id="13a54029acae7bece88ccff45131ab5c099597a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debounceWithSelector&lt;/code&gt; operator throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">Оператор &lt;code&gt;debounceWithSelector&lt;/code&gt; регулирует источник Observable, применяя функцию к каждому элементу, который он излучает, эта функция генерирует Observable. Если исходный Observable испускает другой элемент до того, как этот вновь созданный Observable завершится, &lt;code&gt;debounce&lt;/code&gt; подавит этот элемент.</target>
        </trans-unit>
        <trans-unit id="e81c335785cb73611f872b22bd602a71298e93a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doAfterTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">Оператор &lt;code&gt;doAfterTerminate&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться сразу &lt;em&gt;после&lt;/em&gt; завершения результирующего Observable, как обычно, так и с ошибкой.</target>
        </trans-unit>
        <trans-unit id="0623a20ead85e594b09a4929adac2bbbb7b3f224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnCompleted&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates normally, calling &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;doOnCompleted&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться, если результирующий Observable завершится нормально, вызывая &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0026ae0169af251d209c2da5abd0bfa704cfab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnEach&lt;/code&gt; operator allows you to establish a callback that the resulting Observable will call each time it emits an item. You can pass this callback either in the form of an &lt;code&gt;Action&lt;/code&gt; that takes an &lt;code&gt;onNext&lt;/code&gt; variety of &lt;code&gt;Notification&lt;/code&gt; as its sole parameter, or you can pass in an Observer whose &lt;code&gt;onNext&lt;/code&gt; method will be called as if it had subscribed to the Observable.</source>
          <target state="translated">Оператор &lt;code&gt;doOnEach&lt;/code&gt; позволяет вам установить обратный вызов, который результирующий Observable будет вызывать каждый раз, когда он испускает элемент. Вы можете передать этот обратный вызов либо в форме &lt;code&gt;Action&lt;/code&gt; , который принимает разновидность &lt;code&gt;Notification&lt;/code&gt; &lt;code&gt;onNext&lt;/code&gt; в качестве единственного параметра, либо вы можете передать Observer, чей метод &lt;code&gt;onNext&lt;/code&gt; будет вызываться, как если бы он подписался на Observable.</target>
        </trans-unit>
        <trans-unit id="eabd4c3f21534a441bc83130020ea0729317f2bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnError&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called if the resulting Observable terminates abnormally, calling &lt;code&gt;onError&lt;/code&gt;. This &lt;code&gt;Action&lt;/code&gt; will be passed the &lt;code&gt;Throwable&lt;/code&gt; representing the error.</source>
          <target state="translated">Оператор &lt;code&gt;doOnError&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться, если результирующий Observable завершится ненормально, вызывая &lt;code&gt;onError&lt;/code&gt; . Этому &lt;code&gt;Action&lt;/code&gt; будет передан &lt;code&gt;Throwable&lt;/code&gt; , представляющий ошибку.</target>
        </trans-unit>
        <trans-unit id="a69c5948b6c36fdf006d228347957b8e8b5a82cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnNext&lt;/code&gt; operator is much like &lt;code&gt;doOnEach(Action1)&lt;/code&gt; except that the &lt;code&gt;Action&lt;/code&gt; that you pass it as a parameter does not accept a &lt;code&gt;Notification&lt;/code&gt; but instead simply accepts the emitted item.</source>
          <target state="translated">Оператор &lt;code&gt;doOnNext&lt;/code&gt; очень похож на &lt;code&gt;doOnEach(Action1)&lt;/code&gt; за исключением того, что &lt;code&gt;Action&lt;/code&gt; которое вы передаете в качестве параметра, не принимает &lt;code&gt;Notification&lt;/code&gt; а вместо этого просто принимает отправленный элемент.</target>
        </trans-unit>
        <trans-unit id="47b3486778ac1c48193054633dd037f987fce4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxGroovy 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">Оператор &lt;code&gt;doOnRequest&lt;/code&gt; (новый в RxGroovy 1.1) регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться всякий раз, когда наблюдатель запрашивает дополнительные элементы из результирующего Observable. Это &lt;code&gt;Action&lt;/code&gt; получает в качестве параметра количество элементов, которые запрашивает наблюдатель.</target>
        </trans-unit>
        <trans-unit id="ae2db8da5cb25f3493e2edbab4c991c3a890fa95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnRequest&lt;/code&gt; operator (new in RxJava 1.1) registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer requests additional items from the resulting Observable. That &lt;code&gt;Action&lt;/code&gt; receives as its parameter the number of items that the observer is requesting.</source>
          <target state="translated">Оператор &lt;code&gt;doOnRequest&lt;/code&gt; (новый в RxJava 1.1) регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться всякий раз, когда наблюдатель запрашивает дополнительные элементы из результирующего Observable. Это &lt;code&gt;Action&lt;/code&gt; получает в качестве параметра количество элементов, которые запрашивает наблюдатель.</target>
        </trans-unit>
        <trans-unit id="a7c2c85aa48da67b4394be68c9693a243657f00f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnSubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer subscribes to the resulting Observable.</source>
          <target state="translated">Оператор &lt;code&gt;doOnSubscribe&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться всякий раз, когда наблюдатель подписывается на результирующий Observable.</target>
        </trans-unit>
        <trans-unit id="22e4b3cb15d1500d61d8e8dd0104bea7baad9fd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnTerminate&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;before&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">Оператор &lt;code&gt;doOnTerminate&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться непосредственно &lt;em&gt;перед&lt;/em&gt; завершением результирующего Observable, как обычно, так и с ошибкой.</target>
        </trans-unit>
        <trans-unit id="c98415bf041e0eacfd89ab746aa429e8bbfe6ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doOnUnsubscribe&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called whenever an observer unsubscribes from the resulting Observable.</source>
          <target state="translated">Оператор &lt;code&gt;doOnUnsubscribe&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться всякий раз, когда наблюдатель отменяет подписку на полученный Observable.</target>
        </trans-unit>
        <trans-unit id="f94bf58f6f661938712ce1a2d3b96c007a0d9cc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finallyDo&lt;/code&gt; operator registers an &lt;code&gt;Action&lt;/code&gt; which will be called just &lt;em&gt;after&lt;/em&gt; the resulting Observable terminates, whether normally or with an error.</source>
          <target state="translated">Оператор &lt;code&gt;finallyDo&lt;/code&gt; регистрирует &lt;code&gt;Action&lt;/code&gt; которое будет вызываться сразу &lt;em&gt;после&lt;/em&gt; завершения результирующего Observable, как обычно, так и с ошибкой.</target>
        </trans-unit>
        <trans-unit id="ab085823e86e31a61ddfb7113f37699ef32a735d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find&lt;/code&gt; operator is much like &lt;code&gt;first&lt;/code&gt; except that the predicate argument is mandatory, and it behaves differently if no item from the source Observable matches the predicate. While &lt;code&gt;first&lt;/code&gt; will send an &lt;code&gt;onError&lt;/code&gt; notification in such a case, &lt;code&gt;find&lt;/code&gt; will instead emit an &lt;code&gt;undefined&lt;/code&gt; item.</source>
          <target state="translated">Оператор &lt;code&gt;find&lt;/code&gt; очень похож на &lt;code&gt;first&lt;/code&gt; , за исключением того, что аргумент предиката является обязательным и ведет себя иначе, если ни один элемент из исходного Observable не соответствует предикату. Хотя в таком случае &lt;code&gt;first&lt;/code&gt; будет отправлено уведомление &lt;code&gt;onError&lt;/code&gt; , &lt;code&gt;find&lt;/code&gt; вместо этого выдаст &lt;code&gt;undefined&lt;/code&gt; элемент.</target>
        </trans-unit>
        <trans-unit id="4c6c877a3737234f454d67e02db333027e5f3786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator in RxJS takes as its parameter a predicate function. It returns an Observable that emits either a single number &amp;mdash; the zero-based index of the first item in the source Observable sequence that matches the predicate &amp;mdash; or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item matches.</source>
          <target state="translated">Оператор &lt;code&gt;findIndex&lt;/code&gt; в RxJS принимает в качестве параметра функцию-предикат. Он возвращает Observable, который выдает либо одно число - отсчитываемый от нуля индекс первого элемента в исходной последовательности Observable, которая соответствует предикату, - либо &lt;code&gt;&amp;minus;1&lt;/code&gt; если такой элемент не соответствует.</target>
        </trans-unit>
        <trans-unit id="ed0159e9a2450a5d952076a8e5cd9627bcd97c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findIndex&lt;/code&gt; operator is similar to &lt;code&gt;find&lt;/code&gt;, except that instead of emitting the item that matches the predicate (or &lt;code&gt;undefined&lt;/code&gt;), it emits the zero-based index of that item in the source Observable&amp;rsquo;s sequence (or &lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">Оператор &lt;code&gt;findIndex&lt;/code&gt; аналогичен оператору &lt;code&gt;find&lt;/code&gt; , за исключением того, что вместо выдачи элемента, который соответствует предикату (или &lt;code&gt;undefined&lt;/code&gt; ), он выдает отсчитываемый от нуля индекс этого элемента в исходной последовательности Observable (или &lt;code&gt;-1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="49be14c47d2aafe03c88558e00c4c6dde3f02fbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items</source>
          <target state="translated">Оператор &lt;code&gt;firstOrDefault&lt;/code&gt; аналогичен оператору &lt;code&gt;first&lt;/code&gt; , но вы передаете ему элемент по умолчанию, который он может генерировать, если исходный Observable не может передать какие-либо элементы.</target>
        </trans-unit>
        <trans-unit id="488465a4fa2c1a64f9853dcc9ecfc03937a36cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapIterable&lt;/code&gt; variants pair up source items and generated &lt;code&gt;Iterable&lt;/code&gt;s rather than source items and generated Observables, but otherwise work in much the same way.</source>
          <target state="translated">&lt;code&gt;flatMapIterable&lt;/code&gt; варианта пары вверх элементы источника и генерируются &lt;code&gt;Iterable&lt;/code&gt; S , а не элементы источника и генерируемые наблюдаемых характеристики , но в противном случае работы во многом таким же образом.</target>
        </trans-unit>
        <trans-unit id="c4df8dce680a0580207e8db092ab428c79083578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flatMapLatest&lt;/code&gt; operator behaves much like the standard FlatMap operator, except that whenever a new item is emitted by the source Observable, it will unsubscribe to and stop mirroring the Observable that was generated from the previously-emitted item, and begin only mirroring the current one.</source>
          <target state="translated">Оператор &lt;code&gt;flatMapLatest&lt;/code&gt; ведет себя во многом так же, как стандартный оператор FlatMap, за исключением того, что всякий раз, когда источник Observable генерирует новый элемент, он отменяет подписку на Observable, который был сгенерирован из ранее выданного элемента, и прекращает его зеркальное отображение, и начинает только зеркальное отображение текущего. .</target>
        </trans-unit>
        <trans-unit id="c482ae55d97cbd55598c3be35323d33a7e002821" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; operator (and its alias, &lt;code&gt;forIn&lt;/code&gt;) is very similar to &lt;code&gt;concatMap&lt;/code&gt;, though it has a converse flexibility. While &lt;code&gt;concatMap&lt;/code&gt; operates on an Observable source and can use Observable, Promise, or array intermediaries to generate its output sequence; &lt;code&gt;for&lt;/code&gt; always uses Observables as its intermediaries, but can operate on a source that is either an Observable, a Promise, or an array.</source>
          <target state="translated">Оператор &lt;code&gt;for&lt;/code&gt; (и его псевдоним &lt;code&gt;forIn&lt;/code&gt; ) очень похож на &lt;code&gt;concatMap&lt;/code&gt; , но имеет обратную гибкость. Хотя &lt;code&gt;concatMap&lt;/code&gt; работает с источником Observable и может использовать посредников Observable, Promise или массивов для генерации своей выходной последовательности; &lt;code&gt;for&lt;/code&gt; всегда использует Observables в качестве посредников, но может работать с источником, который является либо Observable, либо Promise, либо массивом.</target>
        </trans-unit>
        <trans-unit id="f48d8db17cfa63ab694c9c09d245ea6942591cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forEach&lt;/code&gt; operators are simpler versions of &lt;code&gt;subscribe&lt;/code&gt;. You can pass them between one and three functions, which will be interpreted as follows:</source>
          <target state="translated">Операторы &lt;code&gt;forEach&lt;/code&gt; - это более простые версии &lt;code&gt;subscribe&lt;/code&gt; . Вы можете передать их от одной до трех функций, которые будут интерпретироваться следующим образом:</target>
        </trans-unit>
        <trans-unit id="1a921457487d3264a61dac1881821287ea0f75ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromCallback&lt;/code&gt; operator takes a function as a parameter, calls this function, and emits the value returned from it as its single emission.</source>
          <target state="translated">Оператор &lt;code&gt;fromCallback&lt;/code&gt; принимает функцию в качестве параметра, вызывает эту функцию и выдает значение, возвращаемое из нее, как ее единственное излучение.</target>
        </trans-unit>
        <trans-unit id="b504d654fb237651e5ac6a12e8bcfa06d02077fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEvent&lt;/code&gt; operator takes an &amp;ldquo;element&amp;rdquo; and an event name as parameters, and it then listens for events of that name taking place on that element. It returns an Observable that emits those events. An &amp;ldquo;element&amp;rdquo; may be a simple</source>
          <target state="translated">Оператор &lt;code&gt;fromEvent&lt;/code&gt; принимает в качестве параметров &amp;laquo;элемент&amp;raquo; и имя события, а затем прослушивает события с этим именем, происходящие в этом элементе. Он возвращает Observable, который генерирует эти события. &amp;laquo;Элемент&amp;raquo; может быть простым</target>
        </trans-unit>
        <trans-unit id="0cebc7b8cc69c87290f5ce391d54f63ba6b5075c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromEventPattern&lt;/code&gt; operator is similar, except that instead of taking an element and an event name as parameters, it takes two functions as parameters. The first function attaches an event listener to a variety of events on a variety of elements; the second function removes this set of listeners. In this way you can establish a single Observable that emits items representing a variety of events and a variety of target elements.</source>
          <target state="translated">Оператор &lt;code&gt;fromEventPattern&lt;/code&gt; аналогичен, за исключением того, что вместо того, чтобы принимать в качестве параметров элемент и имя события, он принимает две функции в качестве параметров. Первая функция прикрепляет прослушиватель событий к множеству событий на множестве элементов; вторая функция удаляет этот набор слушателей. Таким образом, вы можете установить один Observable, который испускает элементы, представляющие множество событий и множество целевых элементов.</target>
        </trans-unit>
        <trans-unit id="d0506ce1478017fe5fb5c14f3f465e3af698614d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getIterator&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">Оператор &lt;code&gt;getIterator&lt;/code&gt; применяется к подклассу &lt;code&gt;BlockingObservable&lt;/code&gt; , поэтому для его использования необходимо сначала преобразовать исходный Observable в &lt;code&gt;BlockingObservable&lt;/code&gt; с помощью метода &lt;code&gt;BlockingObservable.from&lt;/code&gt; или оператора &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdfd2efb1b4f9b5b207f496d9028e62a7244995f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;groupJoin&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">Оператор &lt;code&gt;groupJoin&lt;/code&gt; принимает четыре параметра:</target>
        </trans-unit>
        <trans-unit id="29d22ca65d9c540689bc8b0ce26cca9ce3db4440" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator in RxJS is similar to &lt;code&gt;contains&lt;/code&gt; but rather than returning an Observable that emits &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; it returns an Observable that emits the index of the item in the source Observable sequence, or &lt;code&gt;&amp;minus;1&lt;/code&gt; if no such item was emitted.</source>
          <target state="translated">Оператор &lt;code&gt;indexOf&lt;/code&gt; в RxJS аналогичен оператору &lt;code&gt;contains&lt;/code&gt; , но вместо возврата Observable, который испускает &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; , он возвращает Observable, который испускает индекс элемента в исходной последовательности Observable, или &lt;code&gt;&amp;minus;1&lt;/code&gt; если такой элемент не был отправлен.</target>
        </trans-unit>
        <trans-unit id="77be1ee57cc41fc2f9e2f8bfb2756ab14303f199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexOf&lt;/code&gt; operator takes an optional second parameter: a zero-based index into the source Observable&amp;rsquo;s sequence at which to start searching for the item. The index value that the resulting Observable emits will be relative to this start point, not to the beginning of the sequence.</source>
          <target state="translated">Оператор &lt;code&gt;indexOf&lt;/code&gt; принимает необязательный второй параметр: отсчитываемый от нуля индекс в исходной последовательности Observable, с которой начинается поиск элемента. Значение индекса, которое излучает результирующий Observable, будет относиться к этой начальной точке, а не к началу последовательности.</target>
        </trans-unit>
        <trans-unit id="5552c7e46b5a139352e9da9264ebc154edea5fd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;join&lt;/code&gt; operator takes four parameters:</source>
          <target state="translated">Оператор &lt;code&gt;join&lt;/code&gt; принимает четыре параметра:</target>
        </trans-unit>
        <trans-unit id="96dab761cc41cd45ea19644cf7e7ad30cb22e0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lastOrDefault&lt;/code&gt; operator is similar to &lt;code&gt;last&lt;/code&gt;, but you pass it a default item that it can emit if the source Observable fails to emit any items.</source>
          <target state="translated">Оператор &lt;code&gt;lastOrDefault&lt;/code&gt; аналогичен оператору &lt;code&gt;last&lt;/code&gt; , но вы передаете ему элемент по умолчанию, который он может генерировать, если исходный Observable не может передать какие-либо элементы.</target>
        </trans-unit>
        <trans-unit id="bb5672f422c4c2cb70cc9c1f677ba66ad8eba847" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;latest&lt;/code&gt; operator is similar, but rather than blocking to wait for the next emitted item, it immediately returns the most-recently-emitted item, and only blocks if the Observable has not yet emitted anything.</source>
          <target state="translated">&lt;code&gt;latest&lt;/code&gt; оператор похож, но не блокирует ждать следующего излучаемого элемента, он сразу же возвращает наиболее недавно излучаемый элемент, а только те блоки , если Наблюдаемые еще не излучается ничего.</target>
        </trans-unit>
        <trans-unit id="72bbe7b92507d29558aef3a62856379c4ffcb4c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; (or &lt;code&gt;letBind&lt;/code&gt;) operator is available in the following packages:</source>
          <target state="translated">Оператор &lt;code&gt;let&lt;/code&gt; (или &lt;code&gt;letBind&lt;/code&gt; ) доступен в следующих пакетах:</target>
        </trans-unit>
        <trans-unit id="d3bdb3993ae70293143f7eee67ab351fa4c6141f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;manySelect&lt;/code&gt; operator is often described as a &amp;ldquo;comonadic bind.&amp;rdquo; If that clears things up for you, you&amp;rsquo;re welcome. Elsewise, here&amp;rsquo;s an explanation:</source>
          <target state="translated">Оператор &lt;code&gt;manySelect&lt;/code&gt; часто описывается как &amp;laquo;комонадное связывание&amp;raquo;. Если это проясняет вам ситуацию, милости просим. В противном случае вот объяснение:</target>
        </trans-unit>
        <trans-unit id="36db071dc02b975954bc90d1b46fa778860971d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;</source>
          <target state="translated">Оператор &lt;code&gt;maxBy&lt;/code&gt; похож на &lt;code&gt;max&lt;/code&gt; , но вместо того, чтобы испускать элемент с максимальным значением, он испускает элемент с максимальным &lt;em&gt;ключом&lt;/em&gt; , где этот ключ создается на основе функции, которую вы предоставляете &lt;code&gt;maxBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13aa9ca81dae630ad2f0bf87c356c068d922d3c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxBy&lt;/code&gt; operator is similar to &lt;code&gt;max&lt;/code&gt;, but instead of emitting the item with the maximum value, it emits the item with the maximum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;maxBy&lt;/code&gt;. &lt;code&gt;maxBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">Оператор &lt;code&gt;maxBy&lt;/code&gt; похож на &lt;code&gt;max&lt;/code&gt; , но вместо того, чтобы испускать элемент с максимальным значением, он испускает элемент с максимальным &lt;em&gt;ключом&lt;/em&gt; , где этот ключ создается на основе функции, которую вы предоставляете &lt;code&gt;maxBy&lt;/code&gt; . &lt;code&gt;maxBy&lt;/code&gt; также принимает необязательный второй параметр: функцию сравнения, которую он будет использовать вместо значения по умолчанию для сравнения ключей двух элементов.</target>
        </trans-unit>
        <trans-unit id="e62a7b488d66dfd66eccaab522c33c28dcfbaa4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge_all&lt;/code&gt; operator, despite its name, really behaves like a Concat variant in Rx.rb. It accepts an Observable of Observables as its parameter, and concatenates the emissions from these Observables.</source>
          <target state="translated">Оператор &lt;code&gt;merge_all&lt;/code&gt; , несмотря на свое название, действительно ведет себя как вариант Concat в Rx.rb. Он принимает в качестве параметра Observable of Observables и объединяет выбросы от этих Observable.</target>
        </trans-unit>
        <trans-unit id="591507d6d1fd978b9d1b908bc6f44f533f339a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;</source>
          <target state="translated">Оператор &lt;code&gt;minBy&lt;/code&gt; похож на &lt;code&gt;min&lt;/code&gt; , но вместо того, чтобы испускать элемент с минимальным значением, он выдает элемент с минимальным &lt;em&gt;ключом&lt;/em&gt; , где этот ключ создается на основе функции, которую вы предоставляете &lt;code&gt;minBy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d75ab372e084506ae5ab756f24870c2c7e50227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minBy&lt;/code&gt; operator is similar to &lt;code&gt;min&lt;/code&gt;, but instead of emitting the item with the minimum value, it emits the item with the minimum &lt;em&gt;key&lt;/em&gt;, where that key is generated based on a function you provide to &lt;code&gt;minBy&lt;/code&gt;. &lt;code&gt;minBy&lt;/code&gt; also takes an optional second parameter: a comparer function that it will use instead of its default to compare the keys of the two items.</source>
          <target state="translated">Оператор &lt;code&gt;minBy&lt;/code&gt; похож на &lt;code&gt;min&lt;/code&gt; , но вместо того , чтобы генерировать элемент с минимальным значением, он генерирует элемент с минимальным &lt;em&gt;ключом&lt;/em&gt; , где этот ключ генерируется на основе функции, которую вы предоставляете &lt;code&gt;minBy&lt;/code&gt; . &lt;code&gt;minBy&lt;/code&gt; также принимает необязательный второй параметр: функцию сравнения, которую он будет использовать вместо значения по умолчанию для сравнения ключей двух элементов.</target>
        </trans-unit>
        <trans-unit id="d97994082600972d411b156dd140c1aa7e0d3d6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mostRecent&lt;/code&gt; operator similarly allows you to iterate over the emissions of a &lt;code&gt;BlockingObservable&lt;/code&gt;, but its Iterable always immediately returns a value: either a default item you provide (if the &lt;code&gt;BlockingObservable&lt;/code&gt; has not yet emitted an item), or the latest item the &lt;code&gt;BlockingObservable&lt;/code&gt; has emitted.</source>
          <target state="translated">Оператор &lt;code&gt;mostRecent&lt;/code&gt; аналогичным образом позволяет вам перебирать выбросы &lt;code&gt;BlockingObservable&lt;/code&gt; , но его Iterable всегда немедленно возвращает значение: либо предоставленный вами элемент по умолчанию (если &lt;code&gt;BlockingObservable&lt;/code&gt; еще не выпустил элемент), либо последний элемент, который &lt;code&gt;BlockingObservable&lt;/code&gt; испустил. .</target>
        </trans-unit>
        <trans-unit id="40070d4eb2002addde3a0bbcd673ca113e9d039a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multicast&lt;/code&gt; operator is available in the following packages:</source>
          <target state="translated">Оператор &lt;code&gt;multicast&lt;/code&gt; доступен в следующих пакетах:</target>
        </trans-unit>
        <trans-unit id="d99a2921d18b7527e96c7b586a0ec6bb398d2cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; operator blocks until the &lt;code&gt;BlockingObservable&lt;/code&gt; emits another item, and then returns that item. You can call this function repeatedly to get successive items from the &lt;code&gt;BlockingObservable&lt;/code&gt;, effectively iterating over its emissions in a blocking fashion.</source>
          <target state="translated">На &lt;code&gt;next&lt;/code&gt; оператор блокирует до тех пор , &lt;code&gt;BlockingObservable&lt;/code&gt; выделяет еще один элемент, а затем возвращает этот элемент. Вы можете вызывать эту функцию несколько раз, чтобы получать последовательные элементы из &lt;code&gt;BlockingObservable&lt;/code&gt; , эффективно перебирая его выбросы в режиме блокировки.</target>
        </trans-unit>
        <trans-unit id="85e2b7ee1fbcbbebfd708d668c59aba89dff308d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;of&lt;/code&gt; operator accepts a number of items as parameters, and returns an Observable that emits each of these parameters, in order, as its emitted sequence.</source>
          <target state="translated">Оператор &lt;code&gt;of&lt;/code&gt; принимает ряд элементов в качестве параметров и возвращает Observable, который испускает каждый из этих параметров, в порядке его испускаемой последовательности.</target>
        </trans-unit>
        <trans-unit id="0a820b931d7dd03c56a7bc833c9808fde84e35de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable, as shown in the following sample code:</source>
          <target state="translated">Метод &lt;code&gt;onErrorResumeNext&lt;/code&gt; возвращает Observable, который отражает поведение исходного Observable, если только этот Observable не вызывает &lt;code&gt;onError&lt;/code&gt; ,и в этом случае вместо распространения этой ошибки на наблюдателя &lt;code&gt;onErrorResumeNext&lt;/code&gt; вместо этого начнет зеркальное отображение второй резервной копии Observable, как показано в следующем примере код:</target>
        </trans-unit>
        <trans-unit id="ad40b93d8ffe52cf75d26afebbdddd1c044c1f25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorResumeNext&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will instead begin mirroring a second, backup Observable.</source>
          <target state="translated">Метод &lt;code&gt;onErrorResumeNext&lt;/code&gt; возвращает Observable, который отражает поведение исходного Observable, если только этот Observable не вызывает &lt;code&gt;onError&lt;/code&gt; ,и в этом случае вместо передачи этой ошибки наблюдателю &lt;code&gt;onErrorResumeNext&lt;/code&gt; вместо этого начнет зеркальное отображение второй резервной копии Observable.</target>
        </trans-unit>
        <trans-unit id="c4940c7c617c2992ba7a9a3fde9d89a1bdc8cbef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method, as shown in the following sample code:</source>
          <target state="translated">Метод &lt;code&gt;onErrorReturn&lt;/code&gt; возвращает Observable, который отражает поведение исходного Observable, если только этот Observable не вызывает &lt;code&gt;onError&lt;/code&gt; ,и в этом случае вместо того, чтобы распространять эту ошибку наблюдателю, &lt;code&gt;onErrorReturn&lt;/code&gt; вместо этого испускает указанный элемент и вызывает метод наблюдателя &lt;code&gt;onCompleted&lt;/code&gt; , как показано на следующий пример кода:</target>
        </trans-unit>
        <trans-unit id="c06d877f3382ecaf88c2f18aa56d9eaa6fd9a9b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onErrorReturn&lt;/code&gt; method returns an Observable that mirrors the behavior of the source Observable, unless that Observable invokes &lt;code&gt;onError&lt;/code&gt; in which case, rather than propagating that error to the observer, &lt;code&gt;onErrorReturn&lt;/code&gt; will instead emit a specified item and invoke the observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method.</source>
          <target state="translated">Метод &lt;code&gt;onErrorReturn&lt;/code&gt; возвращает Observable, который отражает поведение исходного Observable, если только этот Observable не вызывает &lt;code&gt;onError&lt;/code&gt; ,и в этом случае вместо распространения этой ошибки на наблюдателя &lt;code&gt;onErrorReturn&lt;/code&gt; вместо этого испускает указанный элемент и вызывает метод наблюдателя &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be807f21af7c141df25f9522d621998041537c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishLast&lt;/code&gt; operator is similar to &lt;code&gt;publish&lt;/code&gt;, and takes a similarly-behaving function as its parameter. It differs from &lt;code&gt;publish&lt;/code&gt; in that instead of applying that function to, and emitting an item for &lt;em&gt;every&lt;/em&gt; item emitted by the source Observable subsequent to the connection, it only applies that function to and emits an item for the &lt;em&gt;last&lt;/em&gt; item that was emitted by the source Observable, when that source Observable terminates normally.</source>
          <target state="translated">Оператор &lt;code&gt;publishLast&lt;/code&gt; похож на оператор &lt;code&gt;publish&lt;/code&gt; и принимает в качестве параметра аналогичную функцию. Он отличается от &lt;code&gt;publish&lt;/code&gt; тем, что вместо применения этой функции и выдачи элемента для &lt;em&gt;каждого&lt;/em&gt; элемента, испускаемого источником Observable после соединения, он применяет эту функцию только к и излучает элемент для &lt;em&gt;последнего&lt;/em&gt; элемента, который был отправлен источником. Observable, когда этот источник Observable завершается нормально.</target>
        </trans-unit>
        <trans-unit id="0ad4a30567f8a80138c1fb085ce842dcf7162d10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;publishValue&lt;/code&gt; operator takes, in addition to the function described above, an initial item to be emitted by the resulting &lt;code&gt;ConnectableObservable&lt;/code&gt; at connection time before emitting the items from the source Observable. It will not, however, emit this initial item to observers that subscribe after the time of connection.</source>
          <target state="translated">Оператор &lt;code&gt;publishValue&lt;/code&gt; принимает, в дополнение к функции, описанной выше, начальный элемент, который должен быть отправлен результирующим &lt;code&gt;ConnectableObservable&lt;/code&gt; во время соединения перед отправкой элементов из исходного Observable. Однако он не будет передавать этот начальный элемент наблюдателям, которые подписываются после времени соединения.</target>
        </trans-unit>
        <trans-unit id="ef3ba3331ca4825acc2f08213d614824f15ad040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce&lt;/code&gt; operator returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. Then it emits the final result from the final call to your function as the sole output from the returned Observable.</source>
          <target state="translated">Оператор &lt;code&gt;reduce&lt;/code&gt; возвращает Observable, который применяет функцию по вашему выбору к первому элементу, испускаемому источником Observable, затем передает результат этой функции вместе со вторым элементом, созданным исходным Observable, в ту же функцию, а затем передает результат эта функция вместе с третьим элементом в одну и ту же функцию и так далее, пока все элементы не будут отправлены исходным Observable. Затем он испускает окончательный результат последнего вызова вашей функции в качестве единственного вывода возвращенного Observable.</target>
        </trans-unit>
        <trans-unit id="c50635278b4d9cf4361974e6d4a3581ebf3b7068" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retryWhen&lt;/code&gt; operator is similar to &lt;code&gt;retry&lt;/code&gt; but decides whether or not to resubscribe to and mirror the source Observable by passing the Throwable from the &lt;code&gt;onError&lt;/code&gt; notification to a function that generates a second Observable, and observes its result to determine what to do. If that result is an emitted item, &lt;code&gt;retryWhen&lt;/code&gt; resubscribes to and mirrors the source and the process repeats; if that result is an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;retryWhen&lt;/code&gt; passes this notification on to its observers and terminates.</source>
          <target state="translated">Оператор &lt;code&gt;retryWhen&lt;/code&gt; аналогичен retry, но решает, следует ли &lt;code&gt;retry&lt;/code&gt; подписаться на источник Observable и отразить его, передав Throwable из уведомления &lt;code&gt;onError&lt;/code&gt; в функцию, которая генерирует второй Observable, и наблюдает за его результатом, чтобы определить, что делать. Если этот результат является &lt;code&gt;retryWhen&lt;/code&gt; элементом, retryWhen повторно подпишется на источник и зеркалирует его, и процесс повторяется; если этот результат является уведомлением &lt;code&gt;onError&lt;/code&gt; , &lt;code&gt;retryWhen&lt;/code&gt; передает это уведомление своим наблюдателям и завершается.</target>
        </trans-unit>
        <trans-unit id="1e6bf6540cbdcb6dcb36a0ac93c13041a34e1638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;deferFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt; that returns an Observable. &lt;code&gt;deferFuture&lt;/code&gt; returns an Observable, but does not call the function you provide until such time as an observer subscribes to the Observable it returns. When it does so, it immediately calls &lt;code&gt;get&lt;/code&gt; on the resulting &lt;code&gt;Future&lt;/code&gt;, and then mirrors the emissions from the Observable returned by the &lt;code&gt;Future&lt;/code&gt; as its own emissions.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;deferFuture&lt;/code&gt; . Вы передаете ему функцию, которая возвращает &lt;code&gt;Future&lt;/code&gt; , которая возвращает Observable. &lt;code&gt;deferFuture&lt;/code&gt; возвращает Observable, но не вызывает предоставленную вами функцию до тех пор, пока наблюдатель не подписывается на Observable, который он возвращает. Когда он это делает, он немедленно вызывает &lt;code&gt;get&lt;/code&gt; в результирующем &lt;code&gt;Future&lt;/code&gt; , а затем отражает выбросы из Observable, возвращаемые &lt;code&gt;Future&lt;/code&gt; , как свои собственные выбросы.</target>
        </trans-unit>
        <trans-unit id="b6770bc4bfc1cbd7c9c042c3a7028aadacca1d7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;forEachFuture&lt;/code&gt; operator. It is not really a variant of the Start operator, but something all its own. You pass &lt;code&gt;forEachFuture&lt;/code&gt; some subset of the typical observer methods (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) and the Observable will call these methods in the usual way. But &lt;code&gt;forEachFuture&lt;/code&gt; itself returns a &lt;code&gt;Future&lt;/code&gt; that blocks on &lt;code&gt;get&lt;/code&gt; until the source Observable completes, then returns either the completion or error, depending on how the Observable completed.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;forEachFuture&lt;/code&gt; . На самом деле это не вариант оператора Start, а нечто особенное. Вы передаете &lt;code&gt;forEachFuture&lt;/code&gt; некоторое подмножество типичных методов наблюдателя ( &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; и &lt;code&gt;onCompleted&lt;/code&gt; ), и Observable будет вызывать эти методы обычным образом. Но &lt;code&gt;forEachFuture&lt;/code&gt; сам возвращает &lt;code&gt;Future&lt;/code&gt; , который блокируется при &lt;code&gt;get&lt;/code&gt; до завершения исходного Observable, а затем возвращает либо завершение, либо ошибку, в зависимости от того, как завершился Observable.</target>
        </trans-unit>
        <trans-unit id="af59112ac4850a63fc254aa64a91b1cced9a1539" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromAction&lt;/code&gt; operator. It accepts an &lt;code&gt;Action&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromAction&lt;/code&gt; upon termination of the &lt;code&gt;Action&lt;/code&gt;</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;fromAction&lt;/code&gt; . Он принимает &lt;code&gt;Action&lt;/code&gt; как свой параметр и возвращает Observable, который испускает элемент, который вы передаете &lt;code&gt;fromAction&lt;/code&gt; после завершения &lt;code&gt;Action&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eeead452a5c5a5cc79393668e2fbe3048778760f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromCallable&lt;/code&gt; operator. It accepts a &lt;code&gt;Callable&lt;/code&gt; as its parameter, and returns an Observable that emits the result of this callable as its sole emission.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;fromCallable&lt;/code&gt; . Он принимает &lt;code&gt;Callable&lt;/code&gt; в качестве параметра и возвращает Observable, который испускает результат этого вызываемого объекта в качестве его единственной эмиссии.</target>
        </trans-unit>
        <trans-unit id="869f3624eb8dd7143ac5769078e3b3bf39bdeacb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;fromRunnable&lt;/code&gt; operator. It accepts a &lt;code&gt;Runnable&lt;/code&gt; as its parameter, and returns an Observable that emits the item you pass to &lt;code&gt;fromRunnable&lt;/code&gt; upon termination of the &lt;code&gt;Runnable&lt;/code&gt;</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;fromRunnable&lt;/code&gt; . Он принимает &lt;code&gt;Runnable&lt;/code&gt; в качестве параметра и возвращает Observable, который испускает элемент, который вы передаете &lt;code&gt;fromRunnable&lt;/code&gt; после завершения &lt;code&gt;Runnable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="469f2cf19937130bc28a1acc9ff8718d9ef9be41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;runAsync&lt;/code&gt; operator. It is peculiar in that it creates a specialization of an Observable called a &lt;code&gt;StoppableObservable&lt;/code&gt;.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;runAsync&lt;/code&gt; . Его особенность состоит в том, что он создает специализацию Observable, называемую &lt;code&gt;StoppableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1442c42f4ea4865297a5c8db2d9c56e62b53341d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;startFuture&lt;/code&gt; operator. You pass it a function that returns a &lt;code&gt;Future&lt;/code&gt;. &lt;code&gt;startFuture&lt;/code&gt; calls this function immediately to obtain the &lt;code&gt;Future&lt;/code&gt;, and calls the &lt;code&gt;Future&lt;/code&gt;&amp;rsquo;s &lt;code&gt;get&lt;/code&gt; method to try to obtain its value. It returns an Observable to which it will emit this value to any subsequent observers.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает оператор &lt;code&gt;startFuture&lt;/code&gt; . Вы передаете ему функцию, которая возвращает &lt;code&gt;Future&lt;/code&gt; . &lt;code&gt;startFuture&lt;/code&gt; называет эту функцию сразу , чтобы получить &lt;code&gt;Future&lt;/code&gt; , и называет &lt;code&gt;Future&lt;/code&gt; &amp;laquo;s &lt;code&gt;get&lt;/code&gt; метод , чтобы попытаться получить его значение. Он возвращает Observable, которому он будет передавать это значение всем последующим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="0110d272415178479fa0159e8336538a9e94137d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module also includes the &lt;code&gt;toAsync&lt;/code&gt;, &lt;code&gt;asyncAction&lt;/code&gt;, and &lt;code&gt;asyncFunc&lt;/code&gt; operators. These accept a function or an Action as their parameter. In the case of a function, this variant of the operator calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer (just as the &lt;code&gt;start&lt;/code&gt; operator does).</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; также включает &lt;code&gt;toAsync&lt;/code&gt; , &lt;code&gt;asyncAction&lt;/code&gt; и &lt;code&gt;asyncFunc&lt;/code&gt; . Они принимают функцию или действие в качестве параметра. В случае функции этот вариант оператора вызывает эту функцию для получения значения, а затем возвращает Observable, который будет передавать это значение каждому последующему наблюдателю (так же, как это делает оператор &lt;code&gt;start&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7be42e7b16a28f4014f78f36d0e314f07de76b6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rxjava-async&lt;/code&gt; module includes the &lt;code&gt;start&lt;/code&gt; operator, which accepts a function as its parameter, calls that function to retrieve a value, and then returns an Observable that will emit that value to each subsequent observer.</source>
          <target state="translated">Модуль &lt;code&gt;rxjava-async&lt;/code&gt; включает в себя оператор &lt;code&gt;start&lt;/code&gt; , который принимает функцию в качестве параметра, вызывает эту функцию для получения значения, а затем возвращает Observable, который будет передавать это значение каждому последующему наблюдателю.</target>
        </trans-unit>
        <trans-unit id="4f8c7e051e0ffc1dd123fcc2382d4e1c11f27579" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar to &lt;code&gt;first&lt;/code&gt;, but throws a &lt;code&gt;NoSuchElementException&lt;/code&gt; if the source Observable does not emit exactly one item before successfully completing.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; оператор аналогичен &lt;code&gt;first&lt;/code&gt; , но бросает &lt;code&gt;NoSuchElementException&lt;/code&gt; если источник Наблюдаемые не выделяет ровно один элемент , прежде успешного завершения.</target>
        </trans-unit>
        <trans-unit id="bb64af0ef2e08065bfe61294a45e041863a9ac27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;single&lt;/code&gt; operator is similar, except that it only emits its item once the source Observable successfully completes after emitting one item (or one item that matches the predicate). If it emits either no such items or more than one such item, &lt;code&gt;single&lt;/code&gt; will terminate with an &lt;code&gt;onError&lt;/code&gt; notitifcation (&amp;ldquo;&lt;code&gt;Sequence contains no elements.&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; оператора аналогично, за исключением того, что он только излучает деталь раз источник Наблюдаемое успешно завершает после испускания одного элемента (или один элемент , который соответствует предикат). Если он не выдает таких элементов или более одного такого элемента, &lt;code&gt;single&lt;/code&gt; будет завершаться &lt;code&gt;onError&lt;/code&gt; onError (&amp;laquo; &lt;code&gt;Sequence contains no elements.&lt;/code&gt; &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="975834fced6458372b9bc9efc7befcc06fefa34a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;skipLastWithTime&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;skipLastWithTime&lt;/code&gt; принимает временную продолжительность, а не количество элементов. Он отбрасывает те элементы, которые испускаются в течение этого окончательного срока жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая количество миллисекунд в качестве параметра &lt;code&gt;skipLastWithTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42674eed65675fac56a7f9c41a8d7093c454e05d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skipWhile&lt;/code&gt; operator returns an Observable that discards items emitted by the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable emits that item and the remainder of the items emitted by the source Observable.</source>
          <target state="translated">Оператор &lt;code&gt;skipWhile&lt;/code&gt; возвращает Observable, который отбрасывает элементы, испускаемые источником Observable, до тех пор, пока функция, примененная к элементу, испускаемому этим Observable, не вернет &lt;code&gt;false&lt;/code&gt; , после чего новый Observable испускает этот элемент, а остальные элементы, испускаемые источником Наблюдаемый.</target>
        </trans-unit>
        <trans-unit id="61e37780715c55b30e2b068ed45a07ffc42fa7ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeFirst&lt;/code&gt; operator behaves similarly to &lt;code&gt;first&lt;/code&gt;, with the exception of how these operators behave wihen the source Observable emits no items that satisfy the predicate. In such a case, &lt;code&gt;first&lt;/code&gt; will throw a &lt;code&gt;NoSuchElementException&lt;/code&gt; while &lt;code&gt;takeFirst&lt;/code&gt; will return an empty Observable (one that calls &lt;code&gt;onCompleted&lt;/code&gt; but never calls &lt;code&gt;onNext&lt;/code&gt;).</source>
          <target state="translated">Оператор &lt;code&gt;takeFirst&lt;/code&gt; ведет себя аналогично оператору &lt;code&gt;first&lt;/code&gt; , за исключением того, как ведут себя эти операторы, когда исходный Observable не генерирует элементы, удовлетворяющие предикату. В таком случае &lt;code&gt;first&lt;/code&gt; будет сгенерировано &lt;code&gt;NoSuchElementException&lt;/code&gt; а &lt;code&gt;takeFirst&lt;/code&gt; вернет пустой Observable (тот, который вызывает &lt;code&gt;onCompleted&lt;/code&gt; , но никогда не вызывает &lt;code&gt;onNext&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f059b182f05a90e4230cc52c9c5f554288c6cca6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeLastWithTime&lt;/code&gt; operator takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a number of milliseconds as a parameter to &lt;code&gt;takeLastWithTime&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;takeLastWithTime&lt;/code&gt; принимает временную продолжительность, а не количество элементов. Он испускает только те элементы, которые испускаются в течение этого окончательного срока жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая количество миллисекунд в качестве параметра &lt;code&gt;takeLastWithTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94b28280db1122b56b19ce27ccbcf5cc220169d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;takeWhile&lt;/code&gt; operator returns an Observable that mirrors the behavior of the source Observable until such time as a function, applied to an item emitted by that Observable, returns &lt;code&gt;false&lt;/code&gt;, whereupon the new Observable terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Оператор &lt;code&gt;takeWhile&lt;/code&gt; возвращает Observable, который отражает поведение исходного Observable до тех пор, пока функция, примененная к элементу, испускаемому этим Observable, не вернет &lt;code&gt;false&lt;/code&gt; , после чего новый Observable завершится уведомлением &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae782d3a96f85e5b21ff4352810ad74a7d494b59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeInterval&lt;/code&gt; operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">Оператор &lt;code&gt;timeInterval&lt;/code&gt; преобразует источник Observable в Observable, который выдает индикацию количества времени, прошедшего между последовательными выбросами источника Observable. Первое излучение этого нового Observable указывает количество времени, прошедшее между моментом, когда наблюдатель подписался на Observable, и временем, когда исходный Observable выпустил свой первый элемент. Нет соответствующей эмиссии, отмечающей количество времени, прошедшего между последней эмиссией источника Observable и последующим вызовом &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd66b7722a88e540f0f6db427e117d46daa8c75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method attaches a timestamp to each item emitted by the source Observable before emitting that item as part of its own sequence. The timestamp indicates when the item was emitted by the source Observable.</source>
          <target state="translated">Метод &lt;code&gt;timestamp&lt;/code&gt; прикрепляет временную метку к каждому элементу, испускаемому источником Observable, перед тем, как испускать этот элемент как часть своей собственной последовательности. Отметка времени указывает, когда элемент был отправлен источником Observable.</target>
        </trans-unit>
        <trans-unit id="d062c9b41bc51b27701d92c9cfc8c88e8ea2c104" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timestamp&lt;/code&gt; method converts an Observable that emits items of type</source>
          <target state="translated">Метод &lt;code&gt;timestamp&lt;/code&gt; преобразует Observable, который испускает элементы типа</target>
        </trans-unit>
        <trans-unit id="4e038e086711c592371f2bd9b8f09e9f604e3815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toFuture&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">Оператор &lt;code&gt;toFuture&lt;/code&gt; применяется к подклассу &lt;code&gt;BlockingObservable&lt;/code&gt; , поэтому для его использования необходимо сначала преобразовать исходный Observable в &lt;code&gt;BlockingObservable&lt;/code&gt; с помощью метода &lt;code&gt;BlockingObservable.from&lt;/code&gt; или оператора &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73cc88f0171268077175c8d986e14f4bd5fa9b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toIterable&lt;/code&gt; operator applies to the &lt;code&gt;BlockingObservable&lt;/code&gt; subclass, so in order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">Оператор &lt;code&gt;toIterable&lt;/code&gt; применяется к подклассу &lt;code&gt;BlockingObservable&lt;/code&gt; , поэтому для его использования необходимо сначала преобразовать исходный Observable в &lt;code&gt;BlockingObservable&lt;/code&gt; с помощью метода &lt;code&gt;BlockingObservable.from&lt;/code&gt; или оператора &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10c97d4a81b3f34d3ab42da8c6e198078743bb1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a &lt;code&gt;Map&lt;/code&gt; and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">Оператор &lt;code&gt;toMap&lt;/code&gt; собирает элементы, излучаемые исходным Observable, в &lt;code&gt;Map&lt;/code&gt; , а затем выдает эту карту. Вы предоставляете функцию, которая генерирует ключ для каждого отправленного элемента. Вы также можете дополнительно предоставить функцию, которая преобразует выданный элемент в значение, которое будет сохранено на карте (по умолчанию это значение является самим элементом).</target>
        </trans-unit>
        <trans-unit id="bd3162034b145b60b1dabc6e226bf4a2715689b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMap&lt;/code&gt; operator collects the items emitted by the source Observable into a map (by default, a &lt;code&gt;HashMap&lt;/code&gt;, but you can optionally supply a factory function that generates another &lt;code&gt;Map&lt;/code&gt; variety) and then emits that map. You supply a function that generates the key for each emitted item. You may also optionally supply a function that converts an emitted item into the value to be stored in the map (by default, the item itself is this value).</source>
          <target state="translated">Оператор &lt;code&gt;toMap&lt;/code&gt; собирает элементы, испускаемые исходным Observable, в карту (по умолчанию, &lt;code&gt;HashMap&lt;/code&gt; , но вы можете дополнительно предоставить фабричную функцию, которая генерирует другой вариант &lt;code&gt;Map&lt;/code&gt; ), а затем выдает эту карту. Вы предоставляете функцию, которая генерирует ключ для каждого отправленного элемента. Вы также можете дополнительно предоставить функцию, которая преобразует выданный элемент в значение, которое будет сохранено на карте (по умолчанию это значение является самим элементом).</target>
        </trans-unit>
        <trans-unit id="8c85856ebe3a9af3c38faf028b0cefff356663db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toMultiMap&lt;/code&gt; operator is similar to &lt;code&gt;toMap&lt;/code&gt; except that the map it generates is also an &lt;code&gt;ArrayList&lt;/code&gt; (by default; or you can pass an optional factory method as a fourth parameter by which you generate the variety of collection you prefer).</source>
          <target state="translated">Оператор &lt;code&gt;toMultiMap&lt;/code&gt; похож на &lt;code&gt;toMap&lt;/code&gt; , за исключением того, что генерируемая им карта также является &lt;code&gt;ArrayList&lt;/code&gt; (по умолчанию; или вы можете передать необязательный фабричный метод в качестве четвертого параметра, с помощью которого вы создаете разнообразие коллекций, которое вы предпочитаете).</target>
        </trans-unit>
        <trans-unit id="b17e7ff34781fb007d4e482cc00354dcd6940aeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toSortedList&lt;/code&gt; operator behaves much like &lt;code&gt;toList&lt;/code&gt; except that it sorts the resulting list. By default it sorts the list naturally in ascending order by means of the &lt;code&gt;Comparable&lt;/code&gt; interface. If any of the items emitted by the Observable does not support &lt;code&gt;Comparable&lt;/code&gt; with respect to the type of every other item emitted by the Observable, &lt;code&gt;toSortedList&lt;/code&gt; will throw an exception. However, you can change this default behavior by also passing in to &lt;code&gt;toSortedList&lt;/code&gt; a function that takes as its parameters two items and returns a number; &lt;code&gt;toSortedList&lt;/code&gt; will then use that function instead of &lt;code&gt;Comparable&lt;/code&gt; to sort the items.</source>
          <target state="translated">Оператор &lt;code&gt;toSortedList&lt;/code&gt; ведет себя так же, как &lt;code&gt;toList&lt;/code&gt; , за исключением того, что сортирует результирующий список. По умолчанию он сортирует список в порядке возрастания с помощью интерфейса &lt;code&gt;Comparable&lt;/code&gt; . Если какой-либо из элементов , &lt;code&gt;toSortedList&lt;/code&gt; Observable, не поддерживает &lt;code&gt;Comparable&lt;/code&gt; по отношению к типу каждого другого элемента, генерируемого Observable, toSortedList вызовет исключение. Однако вы можете изменить это поведение по умолчанию, также передав &lt;code&gt;toSortedList&lt;/code&gt; функцию, которая принимает в качестве параметров два элемента и возвращает число; &lt;code&gt;toSortedList&lt;/code&gt; будет использовать эту функцию вместо &lt;code&gt;Comparable&lt;/code&gt; для сортировки элементов.</target>
        </trans-unit>
        <trans-unit id="3179857647a979a434a7b8365890ceca652b913a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipWith&lt;/code&gt; instance version of this operator always takes two parameters. The first parameter may be either a simple Observable, or an iterable (as in the illustration above).</source>
          <target state="translated">&lt;code&gt;zipWith&lt;/code&gt; экземпляр версия этого оператора всегда принимает два параметра. Первый параметр может быть либо простым Observable, либо итеративным (как на иллюстрации выше).</target>
        </trans-unit>
        <trans-unit id="0c52166841e40a260b713af70e53c187dda20628" translate="yes" xml:space="preserve">
          <source>The Average operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the average of all of the numbers emitted by the source Observable.</source>
          <target state="translated">Оператор Average работает с наблюдаемым,который испускает числа (или элементы,которые могут быть оценены как числа),и испускает одно значение:среднее из всех чисел,испускаемых источником Наблюдаемый.</target>
        </trans-unit>
        <trans-unit id="fc6a2968bca993acc6e3b8fced16ce05fe639169" translate="yes" xml:space="preserve">
          <source>The Buffer operator transforms an Observable that emits items into an Observable that emits buffered collections of those items. There are a number of variants in the various language-specific implementations of Buffer that differ in how they choose which items go in which buffers.</source>
          <target state="translated">Оператор буфера преобразует Observable,который испускает элементы,в Observable,который испускает буферизованные коллекции этих элементов.В различных языковых реализациях буфера существует несколько вариантов,различающихся тем,как они выбирают,какие элементы идут в какие буферы.</target>
        </trans-unit>
        <trans-unit id="b37590bfa8c82144f5bf2ba003877989832559fd" translate="yes" xml:space="preserve">
          <source>The Catch operator intercepts an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable and, instead of passing it through to any observers, replaces it with some other item or sequence of items, potentially allowing the resulting Observable to terminate normally or not to terminate at all.</source>
          <target state="translated">Оператор Catch перехватывает уведомление &lt;code&gt;onError&lt;/code&gt; от исходного Observable и, вместо того, чтобы передавать его любым наблюдателям, заменяет его каким-либо другим элементом или последовательностью элементов, потенциально позволяя результирующему Observable завершиться нормально или не завершиться вообще.</target>
        </trans-unit>
        <trans-unit id="cfe27529276a28575971e7809bb99f71747e9097" translate="yes" xml:space="preserve">
          <source>The CombineLatest operator behaves in a similar way to Zip, but while Zip emits items only when &lt;em&gt;each&lt;/em&gt; of the zipped source Observables have emitted a previously unzipped item, CombineLatest emits an item whenever &lt;em&gt;any&lt;/em&gt; of the source Observables emits an item (so long as each of the source Observables has emitted at least one item). When any of the source Observables emits an item, CombineLatest combines the most recently emitted items from each of the other source Observables, using a function you provide, and emits the return value from that function.</source>
          <target state="translated">Оператор CombineLatest ведет себя аналогично Zip, но в то время как Zip выдает элементы только тогда, когда &lt;em&gt;каждый&lt;/em&gt; из заархивированных исходных Observables выпустил ранее разархивированный элемент, CombineLatest выдает элемент всякий раз, когда &lt;em&gt;какой-либо&lt;/em&gt; из исходных Observables излучает элемент (при условии, что каждый из Источник Observables испустил хотя бы один элемент). Когда какой-либо из исходных Observables испускает элемент, CombineLatest объединяет последние излучаемые элементы из каждого из других исходных Observables, используя предоставленную вами функцию, и выдает возвращаемое значение из этой функции.</target>
        </trans-unit>
        <trans-unit id="4854908f534b02106795e7f1522975b573795081" translate="yes" xml:space="preserve">
          <source>The Concat operator concatenates the output of multiple Observables so that they act like a single Observable, with all of the items emitted by the first Observable being emitted before any of the items emitted by the second Observable (and so forth, if there are more than two).</source>
          <target state="translated">Оператор Концентрата соединяет вывод нескольких Наблюдателей так,что они действуют как один Наблюдаемый,при этом все элементы,испускаемые первым Наблюдаемым,испускаются перед любым из элементов,испускаемых вторым Наблюдаемым (и т.д.,если их более двух).</target>
        </trans-unit>
        <trans-unit id="90fa54f98f8f36aa66596ae7ba4f7c4c568cf2d8" translate="yes" xml:space="preserve">
          <source>The Contract Governing Notifications</source>
          <target state="translated">Уведомления,регулирующие исполнение контрактов</target>
        </trans-unit>
        <trans-unit id="716ae1fda32d1fa3b632bdf5455ead7fa3ced17a" translate="yes" xml:space="preserve">
          <source>The Count operator transforms an Observable that emits items into an Observable that emits a single value that represents the number of items emitted by the source Observable.</source>
          <target state="translated">Оператор счета преобразует &quot;Наблюдаемый&quot;,который испускает элементы,в &quot;Наблюдаемый&quot;,который испускает единственное значение,представляющее количество элементов,испускаемых источником &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="eefbe49fbb86c9fbec17d91d5ce7f466a4fe2e49" translate="yes" xml:space="preserve">
          <source>The Debounce operator filters out items emitted by the source Observable that are rapidly followed by another emitted item.</source>
          <target state="translated">Оператор Debounce отфильтровывает элементы,излучаемые источником Observable,которые быстро следуют за другим излучаемым элементом.</target>
        </trans-unit>
        <trans-unit id="36b504754ec03844f1798737da9f41be4f33e797" translate="yes" xml:space="preserve">
          <source>The DefaultIfEmpty operator simply mirrors the source Observable exactly if the source Observable emits any items. If the source Observable terminates normally (with an &lt;code&gt;onComplete&lt;/code&gt;) without emitting any items, the Observable returned from DefaultIfEmpty will instead emit a default item of your choosing before it too completes.</source>
          <target state="translated">Оператор DefaultIfEmpty просто отражает исходный Observable, если исходный Observable испускает какие-либо элементы. Если исходный Observable завершается нормально (с &lt;code&gt;onComplete&lt;/code&gt; ) без выдачи каких-либо элементов, Observable, возвращенный из DefaultIfEmpty, вместо этого выдаст элемент по умолчанию по вашему выбору, прежде чем он тоже завершится.</target>
        </trans-unit>
        <trans-unit id="8094e68c11bae1e54b9179fa5c2f24a885dbe086" translate="yes" xml:space="preserve">
          <source>The Defer operator waits until an observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual sequence.</source>
          <target state="translated">Оператор &quot;Дефер&quot; ждет,пока наблюдатель не подпишется на него,а затем генерирует &quot;Наблюдаемый&quot;,обычно с заводской функцией &quot;Наблюдаемый&quot;.Он делает это заново для каждого абонента,поэтому,хотя каждый абонент может думать,что он подписывается на одну и ту же функцию Observable,на самом деле каждый абонент получает свою собственную индивидуальную последовательность.</target>
        </trans-unit>
        <trans-unit id="4453fd69500a642f20d1c4768d4bf67d31976c31" translate="yes" xml:space="preserve">
          <source>The Delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable&amp;rsquo;s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</source>
          <target state="translated">Оператор Delay изменяет свой источник Observable, делая паузу на определенное время (которое вы указываете) перед выдачей каждого из элементов исходного Observable. Это приводит к сдвигу всей последовательности элементов, выдаваемых Observable, вперед во времени на указанное приращение.</target>
        </trans-unit>
        <trans-unit id="43e2b2596602d7cec271e9c62cbe5303137d7dc9" translate="yes" xml:space="preserve">
          <source>The Dematerialize operator reverses this process. It operates on an Observable that has previously been transformed by Materialize and returns it to its original form.</source>
          <target state="translated">Оператор Dematerialize отменяет этот процесс.Он работает на наблюдаемом,который ранее был преобразован Материализовать,и возвращает его в исходную форму.</target>
        </trans-unit>
        <trans-unit id="b62495a350947c5ebd5c22f8327b5c1e7b3d4cd9" translate="yes" xml:space="preserve">
          <source>The Distinct operator filters an Observable by only allowing items through that have not already been emitted.</source>
          <target state="translated">Оператор Distinct отфильтровывает наблюдаемое,пропуская только те элементы,которые еще не были излучены.</target>
        </trans-unit>
        <trans-unit id="02a861b98764748360b643c6b91378962eece519" translate="yes" xml:space="preserve">
          <source>The Empty, Never, and Throw operators generate Observables with very specific and limited behavior. These are useful for testing purposes, and sometimes also for combining with other Observables or as parameters to operators that expect other Observables as parameters.</source>
          <target state="translated">Операторы &quot;Пустота&quot;,&quot;Никогда&quot; и &quot;Выброс&quot; генерируют &quot;Наблюдатели&quot; с очень специфическим и ограниченным поведением.Они полезны для тестирования,а иногда и для комбинирования с другими наблюдателями или в качестве параметров для операторов,которые ожидают,что в качестве параметров будут использоваться другие наблюдатели.</target>
        </trans-unit>
        <trans-unit id="b833020b17b2958e2855725d6a76e2d9fa4b4dca" translate="yes" xml:space="preserve">
          <source>The Filter operator filters an Observable by only allowing items through that pass a test that you specify in the form of a predicate function.</source>
          <target state="translated">Оператор &quot;Фильтр&quot; фильтрует &quot;Наблюдаемое&quot;,пропуская через него только те элементы,которые проходят тест,заданный вами в виде предикатной функции.</target>
        </trans-unit>
        <trans-unit id="69c03b864d44f0df8a889b8aea1579db6062a264" translate="yes" xml:space="preserve">
          <source>The Filtering Operators</source>
          <target state="translated">Фильтрующие операторы</target>
        </trans-unit>
        <trans-unit id="35e86997505ba385effc0556a5f7cfa65bd4638e" translate="yes" xml:space="preserve">
          <source>The FlatMap operator transforms an Observable by applying a function that you specify to each item emitted by the source Observable, where that function returns an Observable that itself emits items. FlatMap then merges the emissions of these resulting Observables, emitting these merged results as its own sequence.</source>
          <target state="translated">Оператор FlatMap преобразует элемент Observable,применяя функцию,которую вы указываете к каждому элементу,излучаемому источником Observable,где эта функция возвращает элемент Observable,который сам по себе излучает элемент.Затем FlatMap объединяет излучения этих результирующих элементов Observables,выбрасывая эти объединенные результаты как свою собственную последовательность.</target>
        </trans-unit>
        <trans-unit id="fd1bbbdbc4127c19ee97953d85194e7977a5f6a3" translate="yes" xml:space="preserve">
          <source>The GroupBy operator divides an Observable that emits items into an Observable that emits Observables, each one of which emits some subset of the items from the original source Observable. Which items end up on which Observable is typically decided by a discriminating function that evaluates each item and assigns it a key. All items with the same key are emitted by the same Observable.</source>
          <target state="translated">Оператор GroupBy разделяет объект &quot;Наблюдаемый&quot; на объект &quot;Наблюдаемый&quot;,каждый из которых выделяет какую-либо часть объекта из первоначального источника &quot;Наблюдаемый&quot;.Какие объекты,в конечном счете,на которых стоит &quot;Наблюдаемое&quot;,обычно определяются функцией дискриминации,которая оценивает каждый объект и присваивает ему ключ.Все элементы с одним и тем же ключом обозначаются одним и тем же Observable.</target>
        </trans-unit>
        <trans-unit id="4906ba388d3e33ac64376a578c10705e279fef4b" translate="yes" xml:space="preserve">
          <source>The IgnoreElements operator suppresses all of the items emitted by the source Observable, but allows its termination notification (either &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt;) to pass through unchanged.</source>
          <target state="translated">Оператор IgnoreElements подавляет все элементы, испускаемые исходным Observable, но позволяет его уведомлению о завершении ( &lt;code&gt;onError&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; ) проходить без изменений.</target>
        </trans-unit>
        <trans-unit id="244dd77637d5c3358021f0f2debf08aa419dec57" translate="yes" xml:space="preserve">
          <source>The Interval operator returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between emissions.</source>
          <target state="translated">Оператор Интервал возвращает Observable,который испускает бесконечную последовательность восходящих целых чисел,с постоянным интервалом времени выбора между излучениями.</target>
        </trans-unit>
        <trans-unit id="83607c5f15eb7b829a081b94cbd6b0b250bb3353" translate="yes" xml:space="preserve">
          <source>The Just operator converts an item into an Observable that emits that item.</source>
          <target state="translated">Оператор &quot;Просто&quot; преобразует элемент в &quot;Наблюдатель&quot;,который излучает этот элемент.</target>
        </trans-unit>
        <trans-unit id="5bd2b8fa13d538c5571233b8167d384ea2844854" translate="yes" xml:space="preserve">
          <source>The Map operator applies a function of your choosing to each item emitted by the source Observable, and returns an Observable that emits the results of these function applications.</source>
          <target state="translated">Оператор карты применяет выбранную Вами функцию к каждому элементу,излучаемому источником Observable,и возвращает Observable,который излучает результаты применения этих функций.</target>
        </trans-unit>
        <trans-unit id="2e2bf97ad1f3f2ffc00e16ec5b3d4fbcf84a3701" translate="yes" xml:space="preserve">
          <source>The Max operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the largest number.</source>
          <target state="translated">Оператор Max работает с наблюдателем,который испускает номера (или элементы,которые могут быть оценены как номера),и испускает один элемент:элемент с наибольшим номером.</target>
        </trans-unit>
        <trans-unit id="09deece6c140d29e662b3b8432858ad0d37f4465" translate="yes" xml:space="preserve">
          <source>The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single item: the item with the smallest number.</source>
          <target state="translated">Оператор Min работает с наблюдателем,который испускает номера (или элементы,которые могут быть оценены как номера),и испускает один элемент:элемент с наименьшим номером.</target>
        </trans-unit>
        <trans-unit id="247ee8fc9c213eb2ead2d9c86fe90bf5295d1c49" translate="yes" xml:space="preserve">
          <source>The Observable Contract</source>
          <target state="translated">Соблюдаемый договор</target>
        </trans-unit>
        <trans-unit id="afbdd322f220a1cf0b12ad4fca765fe243613c51" translate="yes" xml:space="preserve">
          <source>The Observable type adds two missing semantics to &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the Gang of Four&amp;rsquo;s Observer pattern&lt;/a&gt;, to match those that are available in the Iterable type:</source>
          <target state="translated">Тип Observable добавляет две недостающие семантики к &lt;a href=&quot;http://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;шаблону Observer Gang of Four&lt;/a&gt; , чтобы соответствовать тем, которые доступны в типе Iterable:</target>
        </trans-unit>
        <trans-unit id="1ba3f7166c0f2972deb23126d9da35eb1c6a74c8" translate="yes" xml:space="preserve">
          <source>The Observable type adds two missing semantics to &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;the Gang of Four&amp;rsquo;s Observer pattern&lt;/a&gt;, to match those that are available in the Iterable type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03703c1687e9f63689cb91bc87825dd48181098" translate="yes" xml:space="preserve">
          <source>The Operators of ReactiveX</source>
          <target state="translated">Операторы ReactiveX</target>
        </trans-unit>
        <trans-unit id="bcdd731b4af0f836d80c51d8a9da6714524f68a6" translate="yes" xml:space="preserve">
          <source>The Range operator emits a range of sequential integers, in order, where you select the start of the range and its length.</source>
          <target state="translated">Оператор Range излучает диапазон последовательных целых чисел в порядке,в котором Вы выбираете начало диапазона и его длину.</target>
        </trans-unit>
        <trans-unit id="1292751da07b37b3a1750a8a6de0cbc7053adb8e" translate="yes" xml:space="preserve">
          <source>The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple, composable operations that you use for collections of data items like arrays. It frees you from tangled webs of callbacks, and thereby makes your code more readable and less prone to bugs.</source>
          <target state="translated">Модель ReactiveX Observable позволяет обрабатывать потоки асинхронных событий с помощью тех же простых,составных операций,которые вы используете для сбора элементов данных,таких как массивы.Она освобождает вас от запутанных паутин обратных вызовов,и тем самым делает ваш код более читабельным и менее склонным к ошибкам.</target>
        </trans-unit>
        <trans-unit id="cc1f638a75607049534396bafa35741b496cbeea" translate="yes" xml:space="preserve">
          <source>The Reduce operator applies a function to the first item emitted by the source Observable and then feeds the result of the function back into the function along with the second item emitted by the source Observable, continuing this process until the source Observable emits its final item and completes, whereupon the Observable returned from Reduce emits the final value returned from the function.</source>
          <target state="translated">Оператор &quot;Уменьшить&quot; применяет функцию к первому элементу,выданному источником &quot;Наблюдаемый&quot;,а затем передает результат функции обратно в функцию вместе со вторым элементом,выданным источником &quot;Наблюдаемый&quot;,продолжая этот процесс до тех пор,пока источник &quot;Наблюдаемый&quot; не выдаст свой конечный элемент и не завершит его,после чего &quot;Наблюдаемый&quot;,возвращаемый из &quot;Уменьшить&quot;,выдаст конечное значение,возвращаемое из функции.</target>
        </trans-unit>
        <trans-unit id="7f8c08d1ff0948c74616bcf19db4f6f8a4e9fe87" translate="yes" xml:space="preserve">
          <source>The RefCount operator automates the process of connecting to and disconnecting from a connectable Observable. It operates on a connectable Observable and returns an ordinary Observable. When the first observer subscribes to this Observable, RefCount connects to the underlying connectable Observable. RefCount then keeps track of how many other observers subscribe to it and does not disconnect from the underlying connectable Observable until the last observer has done so.</source>
          <target state="translated">Оператор RefCount автоматизирует процесс подключения и отключения от подключаемого наблюдаемого.Он работает на подключаемой наблюдаемой и возвращает обычную наблюдаемую.Когда первый наблюдатель подписывается на этот Наблюдаемый,RefCount подключается к основному Наблюдаемому.Затем RefCount отслеживает,сколько на него подписалось других наблюдателей,и не отсоединяется от базового Obsecable до тех пор,пока последний наблюдатель не сделает этого.</target>
        </trans-unit>
        <trans-unit id="1cea294e1ffba2cbf07229f7aff488094f37bf6f" translate="yes" xml:space="preserve">
          <source>The Repeat operator emits an item repeatedly. Some implementations of this operator allow you to repeat a &lt;em&gt;sequence&lt;/em&gt; of items, and some permit you to limit the number of repetitions.</source>
          <target state="translated">Оператор Repeat повторяет элемент. Некоторые реализации этого оператора позволяют повторять &lt;em&gt;последовательность&lt;/em&gt; элементов, а некоторые позволяют ограничивать количество повторений.</target>
        </trans-unit>
        <trans-unit id="badd34737b53e718812dd79b36e046f4b576f530" translate="yes" xml:space="preserve">
          <source>The Retry operator responds to an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable by not passing that call through to its observers, but instead by resubscribing to the source Observable and giving it another opportunity to complete its sequence without error. Retry always passes &lt;code&gt;onNext&lt;/code&gt; notifications through to its observers, even from sequences that terminate with an error, so this can cause duplicate emissions (as shown in the diagram above).</source>
          <target state="translated">Оператор Retry отвечает на уведомление &lt;code&gt;onError&lt;/code&gt; от исходного Observable, не передавая этот вызов своим наблюдателям, а вместо этого повторно подписываясь на исходный Observable и давая ему еще одну возможность завершить свою последовательность без ошибок. Retry всегда передает уведомления &lt;code&gt;onNext&lt;/code&gt; своим наблюдателям, даже из последовательностей, которые завершаются ошибкой, поэтому это может вызвать дублирующиеся выбросы (как показано на диаграмме выше).</target>
        </trans-unit>
        <trans-unit id="f9e7265419f42c07e2f8a5a6eb856db0dde19aff" translate="yes" xml:space="preserve">
          <source>The Sample operator periodically looks at an Observable and emits whichever item it has most recently emitted since the previous sampling.</source>
          <target state="translated">Оператор пробы периодически смотрит на &quot;Наблюдаемый&quot; и выбрасывает тот элемент,который он выбрасывал последний раз после предыдущего отбора проб.</target>
        </trans-unit>
        <trans-unit id="399e6bf961037a1119d6673c281659e506bab0ce" translate="yes" xml:space="preserve">
          <source>The Scan operator applies a function to the first item emitted by the source Observable and then emits the result of that function as its own first emission. It also feeds the result of the function back into the function along with the second item emitted by the source Observable in order to generate its second emission. It continues to feed back its own subsequent emissions along with the subsequent emissions from the source Observable in order to create the rest of its sequence.</source>
          <target state="translated">Оператор &quot;Сканирование&quot; применяет функцию к первому элементу,излучаемому источником &quot;Наблюдаемый&quot;,а затем излучает результат этой функции в качестве собственного первого излучения.Кроме того,оператор передает результат функции обратно в функцию вместе со вторым элементом,излучаемым источником &quot;Наблюдаемый&quot;,для генерации своего второго излучения.Она продолжает возвращать свои собственные последующие выбросы вместе с последующими выбросами от источника &quot;Наблюдаемый&quot;,чтобы создать остальную часть своей последовательности.</target>
        </trans-unit>
        <trans-unit id="8619aba5918a01d54d25dd0af57ab74dbd5313ec" translate="yes" xml:space="preserve">
          <source>The SkipUntil subscribes to the source Observable, but ignores its emissions until such time as a second Observable emits an item, at which point SkipUntil begins to mirror the source Observable.</source>
          <target state="translated">SkipUntil подписывается на источник Observable,но игнорирует его излучение до тех пор,пока второй наблюдаемый не испускает элемент,и в этот момент SkipUntil начинает зеркальное отображение источника Observable.</target>
        </trans-unit>
        <trans-unit id="6bb80afbe18d713aa7db356067ed9ca165eb2ac8" translate="yes" xml:space="preserve">
          <source>The SkipWhile subscribes to the source Observable, but ignores its emissions until such time as some condition you specify becomes false, at which point SkipWhile begins to mirror the source Observable.</source>
          <target state="translated">SkipWhile подписывается на источник Observable,но игнорирует его излучение до тех пор,пока какое-либо указанное вами условие не станет ложным,и в этот момент SkipWhile начинает зеркалировать источник Observable.</target>
        </trans-unit>
        <trans-unit id="321f848f6f6b99a515297203275ce7935c3c1b6c" translate="yes" xml:space="preserve">
          <source>The Subscribe operator is the glue that connects an observer to an Observable. In order for an observer to see the items being emitted by an Observable, or to receive error or completed notifications from the Observable, it must first subscribe to that Observable with this operator.</source>
          <target state="translated">Оператор подписки-это клей,соединяющий наблюдателя с наблюдателем.Для того,чтобы наблюдатель мог видеть элементы,излучаемые наблюдателем,или получать от него уведомления об ошибках или заполненные уведомления,он должен сначала подписаться на этот &quot;Наблюдатель&quot; у этого оператора.</target>
        </trans-unit>
        <trans-unit id="68817eb3363e4643e27a12a3a79cfd77fbc75f84" translate="yes" xml:space="preserve">
          <source>The Sum operator operates on an Observable that emits numbers (or items that can be evaluated as numbers), and emits a single value: the sum of all of the numbers emitted by the source Observable.</source>
          <target state="translated">Оператор &quot;Сумма&quot; работает с наблюдаемым,который испускает числа (или элементы,которые могут быть оценены как числа),и испускает единственное значение:сумму всех чисел,испускаемых источником &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="5499fa88e4c4fbb3fd161535ad060b25542b021f" translate="yes" xml:space="preserve">
          <source>The TakeUntil subscribes and begins mirroring the source Observable. It also monitors a second Observable that you provide. If this second Observable emits an item or sends a termination notification, the Observable returned by TakeUntil stops mirroring the source Observable and terminates.</source>
          <target state="translated">TakeUntil подписывается и начинает зеркальное отображение источника Observable.Он также отслеживает второй &quot;Наблюдаемый&quot;,который вы предоставляете.Если этот второй Наблюдаемый выбрасывает элемент или посылает уведомление об окончании,возвращаемый TakeUntil Наблюдаемый прекращает зеркалирование источника Наблюдаемый и прекращает работу.</target>
        </trans-unit>
        <trans-unit id="d6300871c96270a7b7ca7ce40e8b54e51ae2bbe3" translate="yes" xml:space="preserve">
          <source>The TakeWhile mirrors the source Observable until such time as some condition you specify becomes false, at which point TakeWhile stops mirroring the source Observable and terminates its own Observable.</source>
          <target state="translated">TakeWhile зеркалирует источник Observable до тех пор,пока какое-либо указанное вами условие не станет ложным,и в этот момент TakeWhile перестает зеркалировать источник Observable и прекращает свое собственное Observable.</target>
        </trans-unit>
        <trans-unit id="9b9d7306675e43c2b6a657987c0d20922a8ac2b2" translate="yes" xml:space="preserve">
          <source>The TimeInterval operator intercepts the items from the source Observable and emits in their place objects that indicate the amount of time that elapsed between pairs of emissions.</source>
          <target state="translated">Оператор TimeInterval перехватывает элементы от источника Observable и испускает на их место объекты,которые указывают на количество времени,прошедшего между парами излучений.</target>
        </trans-unit>
        <trans-unit id="606d848af5e8d890114a4201e94f633faae68708" translate="yes" xml:space="preserve">
          <source>The Timeout operator allows you to abort an Observable with an &lt;code&gt;onError&lt;/code&gt; termination if that Observable fails to emit any items during a specified span of time.</source>
          <target state="translated">Оператор Timeout позволяет вам прервать Observable с завершением &lt;code&gt;onError&lt;/code&gt; , если этот Observable не может выдать какие-либо элементы в течение указанного промежутка времени.</target>
        </trans-unit>
        <trans-unit id="c92d7746cdf82983c7af4d7a45f125b462cfb156" translate="yes" xml:space="preserve">
          <source>The Timer operator creates an Observable that emits one particular item after a span of time that you specify.</source>
          <target state="translated">Оператор &quot;Таймер&quot; создает &quot;Наблюдатель&quot;,который испускает один конкретный элемент через заданный промежуток времени.</target>
        </trans-unit>
        <trans-unit id="d6f22a25ac9ea4e36d2fb3e2fc77ff657b78a01f" translate="yes" xml:space="preserve">
          <source>The Timestamp operator attaches a timestamp to each item emitted by the source Observable before reemitting that item in its own sequence. The timestamp indicates at what time the item was emitted.</source>
          <target state="translated">Оператор Timestamp (метка времени)прикрепляет метку времени к каждому элементу,излучаемому источником Observable (наблюдаемый),перед повторным использованием этого элемента в его собственной последовательности.Метка времени указывает на то,в какое время был выпущен данный элемент.</target>
        </trans-unit>
        <trans-unit id="f72aef25813cb6cd23e767b6322029a7b84433dd" translate="yes" xml:space="preserve">
          <source>The Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.</source>
          <target state="translated">Оператор Use (Использование)-это способ,с помощью которого вы можете инструктировать Наблюдателя создать ресурс,существующий только в течение срока службы Наблюдателя и утилизируемый по окончании срока службы Наблюдателя.</target>
        </trans-unit>
        <trans-unit id="28cafaed855fc19783c71ce1747806f4b0aa50d5" translate="yes" xml:space="preserve">
          <source>The above operators are available in the following packages:</source>
          <target state="translated">Вышеперечисленные операторы доступны в следующих пакетах:</target>
        </trans-unit>
        <trans-unit id="c7faf4cedb9be89a2fe4a7e2e6bb1c77cd930efc" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;subscribe&lt;/code&gt; returns an object that implements the &lt;code&gt;Subscription&lt;/code&gt; interface. This interface includes the &lt;code&gt;unsubscribe&lt;/code&gt; method that you can call at any time to sever the subscription that &lt;code&gt;subscribe&lt;/code&gt; established between the Observable and the observer (or the methods that stand in for the observer).</source>
          <target state="translated">Вызов &lt;code&gt;subscribe&lt;/code&gt; возвращает объект, реализующий интерфейс &lt;code&gt;Subscription&lt;/code&gt; . Этот интерфейс включает в себя &lt;code&gt;unsubscribe&lt;/code&gt; метод , который вы можете позвонить в любое время , чтобы разъединить подписку, &lt;code&gt;subscribe&lt;/code&gt; установленной между наблюдаемым и наблюдателем (или методами , которые стоят для наблюдателя).</target>
        </trans-unit>
        <trans-unit id="89f14f94d842a0f3914f20a36dfd9eb22a7c4ee7" translate="yes" xml:space="preserve">
          <source>The combination of the And, Then, and When operators behave much like the Zip operator, but they do so by means of intermediate data structures. And accepts two or more Observables and combines the emissions from each, one set at a time, into &lt;code&gt;Pattern&lt;/code&gt; objects. Then operates on such &lt;code&gt;Pattern&lt;/code&gt; objects, transforming them in a &lt;code&gt;Plan&lt;/code&gt;. When in turn transforms these various &lt;code&gt;Plan&lt;/code&gt; objects into emissions from an Observable.</source>
          <target state="translated">Комбинация операторов And, Then и When ведет себя так же, как оператор Zip, но делает это с помощью промежуточных структур данных. И принимает два или более Observable и объединяет выбросы от каждого из них, по одному за раз, в объекты &lt;code&gt;Pattern&lt;/code&gt; . Затем работает с такими объектами &lt;code&gt;Pattern&lt;/code&gt; , преобразовывая их в &lt;code&gt;Plan&lt;/code&gt; . When, в свою очередь, преобразует эти различные объекты &lt;code&gt;Plan&lt;/code&gt; в выбросы из Observable.</target>
        </trans-unit>
        <trans-unit id="db1846a8b74a433edfdaca33027d099c7038cffa" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;code&gt;Observable.from&lt;/code&gt; is that the latter's parameter is an array or a sequence, and emits each of its element as one emission.</source>
          <target state="translated">Разница между this и &lt;code&gt;Observable.from&lt;/code&gt; в том, что параметр последнего является массивом или последовательностью и испускает каждый из своих элементов как одно излучение.</target>
        </trans-unit>
        <trans-unit id="3dd77ae05f13d67f165ceb07a061686373523030" translate="yes" xml:space="preserve">
          <source>The first variant &amp;mdash; called either &lt;code&gt;debounce&lt;/code&gt; or &lt;code&gt;throttleWithTimeout&lt;/code&gt; &amp;mdash; accepts as its parameter a duration, defined as an integer number of milliseconds, and it suppresses any emitted items that are followed by other emitted items during that duration since the first item&amp;rsquo;s emission.</source>
          <target state="translated">Первый вариант, называемый либо &lt;code&gt;debounce&lt;/code&gt; , либо &lt;code&gt;throttleWithTimeout&lt;/code&gt; , принимает в качестве параметра длительность, определяемую как целое число миллисекунд, и подавляет любые отправленные элементы, за которыми следуют другие отправленные элементы в течение этого периода с момента выпуска первого элемента.</target>
        </trans-unit>
        <trans-unit id="0c61ffb36d85b092e0b11ad4b92c123ffd6cbe1d" translate="yes" xml:space="preserve">
          <source>The first variant accepts as its parameter a periodicity, defined as an integer number of milliseconds, and it samples the source Observable periodically at that frequency.</source>
          <target state="translated">Первый вариант принимает в качестве своего параметра периодичность,определяемую как целое число миллисекунд,и сэмплирует источник,наблюдаемый периодически на этой частоте.</target>
        </trans-unit>
        <trans-unit id="4d4daf5fefc143f2fe82e85dd951f60c3b004540" translate="yes" xml:space="preserve">
          <source>The first variant accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;timeout&lt;/code&gt; starts a timer, and if that timer exceeds the duration before the source Observable emits another item, &lt;code&gt;timeout&lt;/code&gt; terminates its Observable with an error (&lt;code&gt;TimeoutException&lt;/code&gt;).</source>
          <target state="translated">Первый вариант принимает параметры, которые определяют продолжительность времени (количество времени и &lt;code&gt;TimeUnit&lt;/code&gt; ,в котором это количество выражается). Каждый раз, когда исходный Observable испускает элемент, &lt;code&gt;timeout&lt;/code&gt; запускает таймер, и если этот таймер превышает продолжительность до того, как исходный Observable испускает другой элемент, &lt;code&gt;timeout&lt;/code&gt; завершает его Observable с ошибкой ( &lt;code&gt;TimeoutException&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8cc80ffffa2d22148369eee22ce57927273f33be" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;delay&lt;/code&gt; accepts parameters that define a duration of time (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in). Each time the source Observable emits an item, &lt;code&gt;delay&lt;/code&gt; starts a timer, and when that timer reaches the given duration, the Observable returned from &lt;code&gt;delay&lt;/code&gt; emits the same item.</source>
          <target state="translated">Первый вариант &lt;code&gt;delay&lt;/code&gt; принимает параметры, которые определяют продолжительность времени (количество времени и &lt;code&gt;TimeUnit&lt;/code&gt; ,в котором это количество выражается). Каждый раз, когда исходный Observable излучает элемент, &lt;code&gt;delay&lt;/code&gt; запускает таймер, и когда этот таймер достигает заданной продолжительности, Observable, возвращенный из &lt;code&gt;delay&lt;/code&gt; , излучает тот же элемент.</target>
        </trans-unit>
        <trans-unit id="46f0163399b285d3092a9a3d89985a4428677721" translate="yes" xml:space="preserve">
          <source>The first variant of &lt;code&gt;merge&lt;/code&gt; is an instance operator that takes a variable number of Observables as parameters, merging each of these Observables with the source (instance) Observables to produce its single output Observable.</source>
          <target state="translated">Первый вариант &lt;code&gt;merge&lt;/code&gt; - это оператор экземпляра, который принимает переменное количество Observable в качестве параметров, объединяя каждый из этих Observable с источником (экземпляром) Observable для создания своего единственного выходного Observable.</target>
        </trans-unit>
        <trans-unit id="aa4845689320f7786a7ce0dd8a6cc3a35c2ebdd4" translate="yes" xml:space="preserve">
          <source>The first version of &lt;code&gt;timer&lt;/code&gt; returns an Observable that emits a single item after a delay period you specify. You can specify the delay either as a &lt;code&gt;Date&lt;/code&gt; object (which means, delay until that absolute moment) or as an integer (which means, delay that many milliseconds).</source>
          <target state="translated">Первая версия &lt;code&gt;timer&lt;/code&gt; возвращает Observable, который излучает один элемент после указанного вами периода задержки. Вы можете указать задержку либо как объект &lt;code&gt;Date&lt;/code&gt; (что означает задержку до этого абсолютного момента), либо как целое число (что означает задержку на столько миллисекунд).</target>
        </trans-unit>
        <trans-unit id="654d2ddaea67b293e03667eacbdc39c059d37abf" translate="yes" xml:space="preserve">
          <source>The following code constructs an Observable that emits the numbers between one and a million, and then samples that Observable every ten milliseconds to see what number it is emitting at that moment.</source>
          <target state="translated">Следующий код конструирует Observable,который испускает числа от одного до миллиона,а затем примеряет,что Observable каждые десять миллисекунд,чтобы увидеть,какое число он испускает в данный момент.</target>
        </trans-unit>
        <trans-unit id="2de73bda505de7252f71c673c86fe20f971b7d67" translate="yes" xml:space="preserve">
          <source>The following example shows how you can chain a custom operator (in this example: &lt;code&gt;myOperator&lt;/code&gt;) along with standard RxJava operators by using the &lt;code&gt;lift( )&lt;/code&gt; operator:</source>
          <target state="translated">В следующем примере показано, как можно &lt;code&gt;myOperator&lt;/code&gt; пользовательский оператор (в этом примере: myOperator ) вместе со стандартными операторами RxJava с помощью оператора &lt;code&gt;lift( )&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d81c2a7bcb04a9212a58697cff7090bccdb6252" translate="yes" xml:space="preserve">
          <source>The following sample code uses &lt;code&gt;groupBy&lt;/code&gt; to transform a list of numbers into two lists, grouped by whether or not the numbers are even:</source>
          <target state="translated">В следующем примере кода &lt;code&gt;groupBy&lt;/code&gt; используется для преобразования списка чисел в два списка, сгруппированных по четности чисел:</target>
        </trans-unit>
        <trans-unit id="ea6ac1a648626d38582a5054601f86ada31f1cdf" translate="yes" xml:space="preserve">
          <source>The following section will show how to form the scaffolding of your operator so that it will work correctly with &lt;code&gt;lift( )&lt;/code&gt;.</source>
          <target state="translated">В следующем разделе будет показано, как сформировать строительные леса вашего оператора, чтобы он правильно работал с &lt;code&gt;lift( )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="253b6d42be3a506a59fbdcf2b0d6ab30d54c2bb5" translate="yes" xml:space="preserve">
          <source>The following sections of this page will give marble diagrams that explain these operators schematically. This diagram explains how Singles are represented in marble diagrams:</source>
          <target state="translated">В следующих разделах этой страницы будут приведены мраморные диаграммы,схематично объясняющие эти операторы.Эта диаграмма объясняет,как Одиночные Одиночные Одиночные Представлены в диаграммах мрамора:</target>
        </trans-unit>
        <trans-unit id="a84f1d1885dd7b824328237a193222ffa087c297" translate="yes" xml:space="preserve">
          <source>The functions described in this section are all found in each of the following distributions:</source>
          <target state="translated">Все функции,описанные в этом разделе,присутствуют в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="aaf5e9f52491f23699e57321ab3d9e121b260a8e" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, in the code sample above, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">Экземплярная версия &lt;code&gt;merge&lt;/code&gt; - &lt;code&gt;mergeWith&lt;/code&gt; , поэтому, например, в приведенном выше примере кода вместо записи &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; вы также можете написать &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e8c42029acb7473a36750cf098482de5a83900" translate="yes" xml:space="preserve">
          <source>The instance version of &lt;code&gt;merge&lt;/code&gt; is &lt;code&gt;mergeWith&lt;/code&gt;, so, for example, instead of writing &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; you could also write &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt;.</source>
          <target state="translated">Экземплярная версия &lt;code&gt;merge&lt;/code&gt; - &lt;code&gt;mergeWith&lt;/code&gt; , поэтому, например, вместо записи &lt;code&gt;Observable.merge(odds,evens)&lt;/code&gt; вы также можете написать &lt;code&gt;odds.mergeWith(evens)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8953a5933d5a16119ad112dc5a75d223543853" translate="yes" xml:space="preserve">
          <source>The last argument to &lt;code&gt;zip&lt;/code&gt; is a function that accepts an item from each of the Observables being zipped and emits an item to be emitted in response by the Observable returned from &lt;code&gt;zip&lt;/code&gt;. You can provide the Observables to be zipped together to &lt;code&gt;zip&lt;/code&gt; either as between two and nine individual parameters, or as a single parameter: either an Iterable of Observables or an Observable that emits Observables (as in the illustration above).</source>
          <target state="translated">Последний аргумент &lt;code&gt;zip&lt;/code&gt; - это функция, которая принимает элемент от каждого из заархивированных Observable и генерирует элемент, который будет отправлен в ответ Observable, возвращенным из &lt;code&gt;zip&lt;/code&gt; . Вы можете предоставить Observable, которые будут заархивированы вместе для &lt;code&gt;zip&lt;/code&gt; , либо от двух до девяти отдельных параметров, либо как один параметр: либо Iterable of Observables, либо Observable, который испускает Observables (как на иллюстрации выше).</target>
        </trans-unit>
        <trans-unit id="5fb92e256f51bccbbcb15f80dac8fed9a700c156" translate="yes" xml:space="preserve">
          <source>The parameter, whether a tuple (i.e. &lt;code&gt;(1, 2, 3)&lt;/code&gt;) or an array (i.e. &lt;code&gt;[1,2,3]&lt;/code&gt;) is produced as one emission.</source>
          <target state="translated">Параметр, будь то кортеж (например, &lt;code&gt;(1, 2, 3)&lt;/code&gt; ) или массив (например, &lt;code&gt;[1,2,3]&lt;/code&gt; ), создается как одно излучение.</target>
        </trans-unit>
        <trans-unit id="e6863eccf319c5c010a867abbdb3ab75de53a4cc" translate="yes" xml:space="preserve">
          <source>The predicate function itself takes three arguments:</source>
          <target state="translated">Сама предикатная функция принимает три аргумента:</target>
        </trans-unit>
        <trans-unit id="55144d4df6ac43ab12e89905c1250932b67b903c" translate="yes" xml:space="preserve">
          <source>The predicate function takes three parameters:</source>
          <target state="translated">Предикатная функция принимает три параметра:</target>
        </trans-unit>
        <trans-unit id="f2e56bda3ccada06fa656085e73c8b6e0dee801d" translate="yes" xml:space="preserve">
          <source>The real power comes with the &amp;ldquo;reactive extensions&amp;rdquo; (hence &amp;ldquo;ReactiveX&amp;rdquo;) &amp;mdash; operators that allow you to transform, combine, manipulate, and work with the sequences of items emitted by Observables.</source>
          <target state="translated">Настоящая мощь приходит с &amp;laquo;реактивными расширениями&amp;raquo; (отсюда &amp;laquo;ReactiveX&amp;raquo;) - операторами, которые позволяют вам преобразовывать, комбинировать, манипулировать и работать с последовательностями элементов, генерируемых Observables.</target>
        </trans-unit>
        <trans-unit id="44eca70b029fe849bd6ef526e9e90e367585dfc9" translate="yes" xml:space="preserve">
          <source>The results of this unsubscription will cascade back through the chain of operators that applies to the Observable that the observer subscribed to, and this will cause each link in the chain to stop emitting items. This is not guaranteed to happen immediately, however, and it is possible for an Observable to generate and attempt to emit items for a while even after no observers remain to observe these emissions.</source>
          <target state="translated">Результаты этой отписки будут каскадированы назад по цепочке операторов,которая применяется к Наблюдателю,на которого подписывается наблюдатель,и это приведет к тому,что каждое звено в цепочке перестанет испускать предметы.Однако это не гарантируется сразу же,и наблюдатель может генерировать и пытаться генерировать элементы в течение некоторого времени даже после того,как ни один наблюдатель не останется наблюдать за этими выбросами.</target>
        </trans-unit>
        <trans-unit id="0f7d52b3373d09ac8d1c47f35ca4249eb74f508c" translate="yes" xml:space="preserve">
          <source>The second variant accepts as its parameter an Observable, and it samples the source Observable whenever this second Observable emits an item.</source>
          <target state="translated">Второй вариант принимает в качестве параметра &quot;Наблюдаемый&quot;,и каждый раз,когда этот второй &quot;Наблюдаемый&quot; испускает элемент,он выбирает источник &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="96a965140ca52079c513552d1152f6627ca655d7" translate="yes" xml:space="preserve">
          <source>The second variant of &lt;code&gt;merge&lt;/code&gt; is a prototype (class) operator that accepts two parameters. The second of these is an Observable that emits the Observables you want to merge. The first is a number that indicates the maximum number of these emitted Observables that you want &lt;code&gt;merge&lt;/code&gt; to attempt to be subscribed to at any moment. Once it reaches this maximum subscription count, it will refrain from subscribing to any other Observables emitted by the source Observable until such time as one of the already-subscribed-to Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Второй вариант &lt;code&gt;merge&lt;/code&gt; - это оператор прототипа (класса), который принимает два параметра. Второй из них - это Observable, который испускает Observables, которые вы хотите объединить. Первый - это число, которое указывает максимальное количество этих испускаемых Observable, на которые вы хотите, чтобы &lt;code&gt;merge&lt;/code&gt; попыталось подписаться в любой момент. Как только он достигнет этого максимального количества подписок, он будет воздерживаться от подписки на любые другие Observable, испускаемые источником Observable, до тех пор, пока один из Observable, на который уже подписан, не выдаст уведомление &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e968e081d2b1a1b80a32c5783a3beb2f47d20ff6" translate="yes" xml:space="preserve">
          <source>The transforming function gets three parameters:</source>
          <target state="translated">Функция преобразования получает три параметра:</target>
        </trans-unit>
        <trans-unit id="d776b341ab49eb64280d0e25e6eb6356060e9290" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;delay&lt;/code&gt; that uses a per-item Observable to set the delay has a variant that allows you to pass in a function that returns an Observable that acts as a delay timer for the subscription to the source Observable (in the absence of this, &lt;code&gt;delay&lt;/code&gt; subscribes to the source Observable as soon as an observer subscribes to the Observable returned by &lt;code&gt;delay&lt;/code&gt;).</source>
          <target state="translated">Вариант &lt;code&gt;delay&lt;/code&gt; который использует для каждого элемента Observable для установки задержки, имеет вариант, который позволяет вам передать функцию, которая возвращает Observable, который действует как таймер задержки для подписки на исходный Observable (в отсутствие этого, &lt;code&gt;delay&lt;/code&gt; подписывается на источник Observable, как только наблюдатель подписывается на Observable, возвращаемый &lt;code&gt;delay&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="adc1ba9017e6bcdf3a2740ab73cfafc6559474ce" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeout&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in a function that returns an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item).</source>
          <target state="translated">Вариант &lt;code&gt;timeout&lt;/code&gt; который использует для каждого элемента Observable для установки тайм-аута, имеет вариант, который позволяет вам передать функцию, которая возвращает Observable, который действует как таймер тайм-аута для самого первого элемента, испускаемого источником Observable (при отсутствии из этого не будет тайм-аута для первого элемента).</target>
        </trans-unit>
        <trans-unit id="dac97b2b169057bbb0f51b05b81737a793abbd1a" translate="yes" xml:space="preserve">
          <source>The variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that uses a per-item Observable to set the timeout has a variant that allows you to pass in an Observable that acts as a timeout timer for the very first item emitted by the source Observable (in the absence of this, there would be no timeout for the first item; that is to say, the default Observable that governs this first timeout period is &lt;code&gt;Rx.Observable.never()&lt;/code&gt;).</source>
          <target state="translated">Вариант &lt;code&gt;timeoutWithSelector&lt;/code&gt; , который использует Observable для каждого элемента для установки тайм-аута, имеет вариант, который позволяет вам передать Observable, который действует как таймер тайм-аута для самого первого элемента, испускаемого источником Observable (в отсутствие этого есть не будет тайм-аут для первого элемента; то есть по умолчанию Observable, который управляет этим первым периодом тайм-аута, - &lt;code&gt;Rx.Observable.never()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="76e86c71c2cfc919caec20c620ae9ee1c2891b71" translate="yes" xml:space="preserve">
          <source>The various RxGroovy implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">Различные реализации Start RxGroovy находятся в необязательном &lt;code&gt;rxjava-async&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69d9d1fff4b37940fbc6c5e8b43dc2bfa9e40934" translate="yes" xml:space="preserve">
          <source>The various RxJava implementations of Start are found in the optional &lt;code&gt;rxjava-async&lt;/code&gt; module.</source>
          <target state="translated">Различные реализации Start в &lt;code&gt;rxjava-async&lt;/code&gt; находятся в необязательном модуле rxjava-async .</target>
        </trans-unit>
        <trans-unit id="5d2372405de754e029a63b317c742a70f865da43" translate="yes" xml:space="preserve">
          <source>The various language-specific implementations of ReactiveX have a variety of operators that you can use to convert an Observable, or a sequence of items emitted by an Observable, into another variety of object or data structure. Some of these block until the Observable terminates and then produce an equivalent object or data structure; others return an Observable that emits such an object or data structure.</source>
          <target state="translated">Различные языковые реализации ReactiveX имеют множество операторов,которые можно использовать для преобразования наблюдаемого,или последовательности элементов,испускаемых наблюдаемым,в другое разнообразие объектов или структуры данных.Некоторые из этих блоков до тех пор,пока обозримый не завершит свою работу и не создаст эквивалентный объект или структуру данных;другие возвращают обозримый,который испускает такой объект или структуру данных.</target>
        </trans-unit>
        <trans-unit id="8a3803202cc409cc722e7f519df7c21e3cad47af" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;manySelect&lt;/code&gt; passes each of these Observables into a function that you provide, and emits, as the emissions from the Observable that &lt;code&gt;manySelect&lt;/code&gt; returns, the return values from those function calls.</source>
          <target state="translated">Затем &lt;code&gt;manySelect&lt;/code&gt; передает каждый из этих Observable в функцию, которую вы предоставляете, и испускает, как выбросы из Observable, которые возвращает &lt;code&gt;manySelect&lt;/code&gt; , возвращаемые значения из этих вызовов функций.</target>
        </trans-unit>
        <trans-unit id="33a18cef9dc87a7ca6a904f01a814fcba80c85d2" translate="yes" xml:space="preserve">
          <source>There are a number of ways that programming languages have for obtaining values as the result of calculations, with names like functions, futures, actions, callables, runnables, and so forth. The operators grouped here under the Start operator category make these things behave like Observables so that they can be chained with other Observables in an Observable cascade</source>
          <target state="translated">Существует ряд способов,которыми языки программирования располагают для получения значений в результате вычислений,с такими именами,как функции,фьючерсы,действия,вызовы,runnables и так далее.Операторы,сгруппированные здесь под категорией операторов Start,заставляют эти вещи вести себя как Observables,так что они могут быть сцеплены с другими Observables в каскаде Observable</target>
        </trans-unit>
        <trans-unit id="73e88b632040f4debf71d15f62a7edac8dafa11d" translate="yes" xml:space="preserve">
          <source>There are a variety of strategies with which you can exercise flow control and backpressure in ReactiveX in order to alleviate the problems caused when a quickly-producing Observable meets a slow-consuming observer, which include, in some ReactiveX implementations, reactive pull backpressure and some backpressure-specific operators.</source>
          <target state="translated">Существует множество стратегий,с помощью которых вы можете осуществлять управление потоком и противодавлением в ReactiveX,чтобы смягчить проблемы,возникающие,когда быстро производящийся Наблюдаемый встречает медленно потребляющего наблюдателя,который включает в себя,в некоторых реализациях ReactiveX,противодавление реактивной тяги и некоторые операторы,специфичные для противодавления.</target>
        </trans-unit>
        <trans-unit id="e49413915d5649a099917d12a2f59331c6b6ecb2" translate="yes" xml:space="preserve">
          <source>There are also several other operators that perform similar functions.</source>
          <target state="translated">Есть также несколько других операторов,выполняющих аналогичные функции.</target>
        </trans-unit>
        <trans-unit id="61a06999b013c4f11472882f535a3c0cecf8baa5" translate="yes" xml:space="preserve">
          <source>There are also two operators that convert an ordinary Observable into at &lt;code&gt;PausableObservable&lt;/code&gt;.</source>
          <target state="translated">Также есть два оператора, которые преобразуют обычный Observable в at &lt;code&gt;PausableObservable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd75322c8a8e345487e962bdedb9cc23338cdd4" translate="yes" xml:space="preserve">
          <source>There are also versions of &lt;code&gt;ReplaySubject&lt;/code&gt; that will throw away old items once the replay buffer threatens to grow beyond a certain size, or when a specified timespan has passed since the items were originally emitted.</source>
          <target state="translated">Существуют также версии &lt;code&gt;ReplaySubject&lt;/code&gt; , которые выбрасывают старые элементы, когда буфер воспроизведения угрожает вырасти за пределы определенного размера или по прошествии определенного промежутка времени с момента исходной отправки элементов.</target>
        </trans-unit>
        <trans-unit id="f6c86c5d109c333c0cb181ff21e7e549c1d9978e" translate="yes" xml:space="preserve">
          <source>There are four varieties of &lt;code&gt;Subject&lt;/code&gt; that are designed for particular use cases. Not all of these are available in all implementations, and some implementations use other naming conventions (for example, in RxScala, what is called a &amp;ldquo;PublishSubject&amp;rdquo; here is known simply as a &amp;ldquo;Subject&amp;rdquo;):</source>
          <target state="translated">Существует четыре разновидности &lt;code&gt;Subject&lt;/code&gt; , разработанные для конкретных случаев использования. Не все из них доступны во всех реализациях, а в некоторых реализациях используются другие соглашения об именах (например, в RxScala то, что называется &amp;laquo;PublishSubject&amp;raquo;, здесь называется просто &amp;laquo;Subject&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="e3d50a06b7b01adde087a728ea4e55f5179a3c5f" translate="yes" xml:space="preserve">
          <source>There are many terms used to describe this model of asynchronous programming and design. This document will use the following terms: An</source>
          <target state="translated">Для описания этой модели асинхронного программирования и проектирования используется множество терминов.В настоящем документе будут использоваться следующие термины:.</target>
        </trans-unit>
        <trans-unit id="c22e405785cca51fa4bed377c8c7a316e925a3fa" translate="yes" xml:space="preserve">
          <source>There are other patterns, like the Builder Pattern, in which a variety of methods of a particular class operate on an item of that same class by modifying that object through the operation of the method. These patterns also allow you to chain the methods in a similar way. But while in the Builder Pattern, the order in which the methods appear in the chain does not usually matter, with the Observable operators &lt;em&gt;order matters&lt;/em&gt;.</source>
          <target state="translated">Существуют и другие шаблоны, такие как шаблон Builder, в котором множество методов определенного класса работают с элементом того же класса, изменяя этот объект посредством операции метода. Эти шаблоны также позволяют аналогичным образом объединять методы. Но в шаблоне Builder порядок, в котором методы появляются в цепочке, обычно не имеет значения, а &lt;em&gt;порядок&lt;/em&gt; операторов Observable &lt;em&gt;имеет значение&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea34fdc274aea1e52da5c7d9e60582c49187d9f7" translate="yes" xml:space="preserve">
          <source>There are several variants of the Catch operator, and a variety of names used by different ReactiveX implementations to describe this operation, as you can see in the sections below.</source>
          <target state="translated">Существует несколько вариантов оператора Catch,а также различные имена,используемые в различных реализациях ReactiveX для описания этой операции,как показано в разделах ниже.</target>
        </trans-unit>
        <trans-unit id="6d11bb624ef1904bb9f2ab36c1280a55a7979979" translate="yes" xml:space="preserve">
          <source>There are several variants of the Window operator in Rx.NET.</source>
          <target state="translated">В Rx.NET существует несколько вариантов оператора Window.</target>
        </trans-unit>
        <trans-unit id="07798f4e8bae1bc378e7ef680bdb140ecb41085a" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxGroovy.</source>
          <target state="translated">В RxGroovy есть несколько разновидностей Window.</target>
        </trans-unit>
        <trans-unit id="fe6adaab352a0a35969e744faa35420dfb689712" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxJava.</source>
          <target state="translated">В RxJava есть несколько разновидностей Window.</target>
        </trans-unit>
        <trans-unit id="f5e80cf04e90857ed90a075f8cf480a3a0d35901" translate="yes" xml:space="preserve">
          <source>There are several varieties of Window in RxKotlin.</source>
          <target state="translated">В RxKotlin есть несколько разновидностей &quot;Окна&quot;.</target>
        </trans-unit>
        <trans-unit id="18c6f13171d4c2450de4807dd5e71c2d51ac49cb" translate="yes" xml:space="preserve">
          <source>There are several, specialized From variants in RxJS:</source>
          <target state="translated">В RxJS есть несколько,специализированных From вариантов:</target>
        </trans-unit>
        <trans-unit id="c2aafde972aa8a0b7ac30764bbba82ab7263e0b7" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;debounce&lt;/code&gt; (that does not have a &lt;code&gt;throttleWithTimeout&lt;/code&gt; alias) that throttles the source Observable by applying a function to each item it emits, this function generating an Observable. If the source Observable emits another item before this newly-generated Observable terminates, &lt;code&gt;debounce&lt;/code&gt; will suppress the item.</source>
          <target state="translated">Существует также вариант &lt;code&gt;debounce&lt;/code&gt; (у которого нет псевдонима &lt;code&gt;throttleWithTimeout&lt;/code&gt; ), который ограничивает источник Observable, применяя функцию к каждому элементу, который он излучает, эта функция генерирует Observable. Если исходный Observable испускает другой элемент до того, как этот вновь созданный Observable завершится, &lt;code&gt;debounce&lt;/code&gt; подавит этот элемент.</target>
        </trans-unit>
        <trans-unit id="27a314ac81cd792286fe509248ef7e647165cd74" translate="yes" xml:space="preserve">
          <source>There ia also a variant of &lt;code&gt;sample&lt;/code&gt; (that does not have a &lt;code&gt;throttleLast&lt;/code&gt; alias) that samples the source Observable each time a second Observable emits an item (or when it terminates). You pass in that second Observable as the parameter to &lt;code&gt;sample&lt;/code&gt;.</source>
          <target state="translated">Существует также вариант &lt;code&gt;sample&lt;/code&gt; (у которого нет псевдонима &lt;code&gt;throttleLast&lt;/code&gt; ), который производит выборку источника Observable каждый раз, когда второй Observable испускает элемент (или когда он завершается). Вы передаете второй Observable в качестве параметра для &lt;code&gt;sample&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4c828574f32cd2c4544bf3aa850a7f8f332980" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxGroovy set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">В дополнительном &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; есть несколько похожий оператор (он не является частью стандартного набора операторов RxGroovy). Оператор &lt;code&gt;switchCase&lt;/code&gt; условно создает и возвращает один из набора возможных Observable.</target>
        </trans-unit>
        <trans-unit id="b0dccba89c1599405c711aa1cf5bd05e76ced379" translate="yes" xml:space="preserve">
          <source>There is a somewhat similar operator in the optional &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; package (it is not part of the standard RxJava set of operators). The &lt;code&gt;switchCase&lt;/code&gt; operator conditionally creates and returns one of a set of possible Observables.</source>
          <target state="translated">В дополнительном &lt;code&gt;rxjava-computation-expressions&lt;/code&gt; есть несколько похожий оператор (он не является частью стандартного набора операторов RxJava). Оператор &lt;code&gt;switchCase&lt;/code&gt; условно создает и возвращает один из набора возможных Observable.</target>
        </trans-unit>
        <trans-unit id="8b280f16d9def0775a32cceafee35e54eb2b99f3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;BlockingObservable&lt;/code&gt; method called &lt;code&gt;forEach&lt;/code&gt; that is somewhat similar. In order to use it, you must first convert your source Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; by means of either the &lt;code&gt;BlockingObservable.from&lt;/code&gt; method or the &lt;code&gt;Observable.toBlocking&lt;/code&gt; operator.</source>
          <target state="translated">Существует также метод &lt;code&gt;BlockingObservable&lt;/code&gt; , называемый &lt;code&gt;forEach&lt;/code&gt; , который в чем-то похож. Чтобы использовать его, вы должны сначала преобразовать исходный Observable в &lt;code&gt;BlockingObservable&lt;/code&gt; с помощью метода &lt;code&gt;BlockingObservable.from&lt;/code&gt; или оператора &lt;code&gt;Observable.toBlocking&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="756e49dd09eebbec81d8a98370d0d54627dacd33" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Существует также оператор &lt;code&gt;concatMap&lt;/code&gt; , который похож на оператор &lt;code&gt;flatMap&lt;/code&gt; , но он объединяет, а не объединяет полученные Observables, чтобы сгенерировать свою собственную последовательность.</target>
        </trans-unit>
        <trans-unit id="610870ff67a503579cdb5b83dc6b88cf5b2ca5bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMap&lt;/code&gt; operator, which is like the simpler version of the &lt;code&gt;flatMap&lt;/code&gt; operator, but it concatenates rather than merges the resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Существует также оператор &lt;code&gt;concatMap&lt;/code&gt; , который похож на более простую версию оператора &lt;code&gt;flatMap&lt;/code&gt; , но он объединяет, а не объединяет полученные Observables, чтобы сгенерировать свою собственную последовательность.</target>
        </trans-unit>
        <trans-unit id="09afc2ecb73970aa3e173379620bf2dbd67958e3" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;concatMapObserver&lt;/code&gt; operator, which is like the &lt;code&gt;flatMapObserver&lt;/code&gt; operator, in that it creates Observables to merge from both the emissions and terminal notifications of the source Observable, but it concatenates rather than merges these resulting Observables in order to generate its own sequence.</source>
          <target state="translated">Существует также оператор &lt;code&gt;concatMapObserver&lt;/code&gt; , который похож на оператор &lt;code&gt;flatMapObserver&lt;/code&gt; в том, что он создает Observables для слияния как из выбросов, так и из оконечных уведомлений исходного Observable, но он объединяет, а не объединяет эти результирующие Observable, чтобы сгенерировать свою собственную последовательность.</target>
        </trans-unit>
        <trans-unit id="f9e703f230d8766cf702a843852917ca049479cb" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromNodeCallback&lt;/code&gt; operator, which is specialized for the types of callback functions found in Node.js.</source>
          <target state="translated">Существует также оператор &lt;code&gt;fromNodeCallback&lt;/code&gt; , который специализируется на типах функций обратного вызова, имеющихся в Node.js.</target>
        </trans-unit>
        <trans-unit id="0adc1cf4895a72eb26c43ab8483af0d51f693087" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;fromPromise&lt;/code&gt; operator that converts a Promise into an Observable, converting its &lt;code&gt;resolve&lt;/code&gt; calls into &lt;code&gt;onNext&lt;/code&gt; notifications, and its &lt;code&gt;reject&lt;/code&gt; calls into &lt;code&gt;onError&lt;/code&gt; notifications.</source>
          <target state="translated">Существует также оператор &lt;code&gt;fromPromise&lt;/code&gt; , который преобразует Promise в Observable, преобразуя его вызовы &lt;code&gt;resolve&lt;/code&gt; в уведомления &lt;code&gt;onNext&lt;/code&gt; , а его вызовы &lt;code&gt;reject&lt;/code&gt; в уведомления &lt;code&gt;onError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa226a63caa5b60f8b21383025ba4a7f512229e" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSort&lt;/code&gt; operator that performs a test on the entire sequence of items emitted by the source Observable. If those items are emitted in sorted order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;true&lt;/code&gt; and then complete. If any of the items emitted by the source Observable is out of sort order, upon the successful completion of the source Observable, the Observable returned from &lt;code&gt;jortSort&lt;/code&gt; will emit &lt;code&gt;false&lt;/code&gt; and then complete.</source>
          <target state="translated">Также существует оператор &lt;code&gt;jortSort&lt;/code&gt; , который выполняет проверку всей последовательности элементов, выдаваемых исходным Observable. Если эти элементы отправляются в отсортированном порядке, после успешного завершения исходного Observable, Observable, возвращенный из &lt;code&gt;jortSort&lt;/code&gt; , выдаст &lt;code&gt;true&lt;/code&gt; , а затем завершится. Если какой-либо из элементов, выданных исходным Observable, не соответствует порядку сортировки, после успешного завершения исходного Observable Observable, возвращенный из &lt;code&gt;jortSort&lt;/code&gt; , выдаст &lt;code&gt;false&lt;/code&gt; , а затем завершится.</target>
        </trans-unit>
        <trans-unit id="f9b14ade97497781729ad307d8e9c95d0d12c215" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;jortSortUntil&lt;/code&gt; operator. It does not wait until the source Observable completes to evaluate its sequence for sortedness, as &lt;code&gt;jortSort&lt;/code&gt; does, but waits until a second Observable emits an item to do so.</source>
          <target state="translated">Также есть оператор &lt;code&gt;jortSortUntil&lt;/code&gt; . Он не ждет, пока исходный Observable завершит оценку своей последовательности на предмет сортировки, как &lt;code&gt;jortSort&lt;/code&gt; делает jortSort , но ждет, пока второй Observable не испустит элемент для этого.</target>
        </trans-unit>
        <trans-unit id="3b92b6af0c8024980674892ceec6ad6d8a9afe31" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;let&lt;/code&gt; operator (the alias &lt;code&gt;letBind&lt;/code&gt; is available for browsers such as Internet Explorer before IE9 where &amp;ldquo;&lt;code&gt;let&lt;/code&gt;&amp;rdquo; is forbidden). It is similar to &lt;code&gt;multicast&lt;/code&gt; but does not multicast the underlying Observable through a Subject:</source>
          <target state="translated">Также существует оператор &lt;code&gt;let&lt;/code&gt; (псевдоним &lt;code&gt;letBind&lt;/code&gt; доступен для браузеров, таких как Internet Explorer до IE9, где &amp;laquo; &lt;code&gt;let&lt;/code&gt; &amp;raquo; запрещена). Это похоже на &lt;code&gt;multicast&lt;/code&gt; но не выполняет многоадресную рассылку базового Observable через Subject:</target>
        </trans-unit>
        <trans-unit id="33bf4c5e7b8fe133a7bee1aa2fed01e21ee7ee8f" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;pairs&lt;/code&gt; operator. This operator accepts an Object, and returns an Observable that emits, as key/value pairs, the attributes of that object.</source>
          <target state="translated">Также есть оператор &lt;code&gt;pairs&lt;/code&gt; . Этот оператор принимает объект и возвращает объект Observable, который испускает в виде пар ключ / значение атрибуты этого объекта.</target>
        </trans-unit>
        <trans-unit id="106ca88c78fe1594ed237ab370c3a39e226e56bd" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order.</source>
          <target state="translated">Существует также оператор &lt;code&gt;share&lt;/code&gt; , который эквивалентен применению операторов &lt;code&gt;publish&lt;/code&gt; и &lt;code&gt;refCount&lt;/code&gt; к Observable в указанном порядке.</target>
        </trans-unit>
        <trans-unit id="a951647b57d362f06673c5f1bcc698b8bc2b55bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;share&lt;/code&gt; operator, which is the equivalent of applying both the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;refCount&lt;/code&gt; operators to an Observable, in that order. A variant called &lt;code&gt;shareValue&lt;/code&gt; takes as a parameter a single item that it will emit to any subscribers before beginning to emit items from the source Observable.</source>
          <target state="translated">Существует также оператор &lt;code&gt;share&lt;/code&gt; , который эквивалентен применению операторов &lt;code&gt;publish&lt;/code&gt; и &lt;code&gt;refCount&lt;/code&gt; к Observable в указанном порядке. Вариант с именем &lt;code&gt;shareValue&lt;/code&gt; принимает в качестве параметра один элемент, который он отправит всем подписчикам перед началом отправки элементов из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="5dce3334b047123b8d59d3f575f95fd87a1a54bc" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;shareReplay&lt;/code&gt; operator, which keeps track of the number of observers, and disconnects from the source Observable when that number drops to zero. &lt;code&gt;shareReplay&lt;/code&gt; takes three optional parameters and returns an ordinary Observable:</source>
          <target state="translated">Существует также оператор &lt;code&gt;shareReplay&lt;/code&gt; , который отслеживает количество наблюдателей и отключается от источника Observable, когда это число падает до нуля. &lt;code&gt;shareReplay&lt;/code&gt; принимает три необязательных параметра и возвращает обычный Observable:</target>
        </trans-unit>
        <trans-unit id="ebdcc8b43b2ed321ef1ee5bf75bf2c4c54ccb1c8" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;skipUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration in place of an Observable, but this is described on the &lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt; operator page.</source>
          <target state="translated">Существует также оператор &lt;code&gt;skipUntilWithTime&lt;/code&gt; , которому вы можете передать абсолютное время или начальную длительность вместо Observable, но это описано на странице оператора &lt;a href=&quot;skip&quot;&gt;Skip&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13c54d80bc681ecd346bb753e654764813e1a20a" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;takeUntilWithTime&lt;/code&gt; operator to which you can pass an absolute time or an initial duration, but this is described on the &lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt; operator page.</source>
          <target state="translated">Существует также оператор &lt;code&gt;takeUntilWithTime&lt;/code&gt; , которому можно передать абсолютное время или начальную длительность, но это описано на странице оператора &lt;a href=&quot;take&quot;&gt;Take&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="187361ed609c2e791463629d8bb597c987424287" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">Также существует оператор &lt;code&gt;throttleFirst&lt;/code&gt; , который отличается от &lt;code&gt;sample&lt;/code&gt; тем, что он испускает &lt;em&gt;первый&lt;/em&gt; элемент, испускаемый источником Observable в каждом периоде выборки, а не &lt;em&gt;последний отправленный&lt;/em&gt; элемент.</target>
        </trans-unit>
        <trans-unit id="6a39d834bd09c5835d19907919ecad6d0b1b92c4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;code&gt;throttleFirst&lt;/code&gt; operator, which differs from &lt;code&gt;throttleLast&lt;/code&gt;/&lt;code&gt;sample&lt;/code&gt; in that it emits the &lt;em&gt;first&lt;/em&gt; item emitted by the source Observable in each sampling period rather than the &lt;em&gt;most recently emitted&lt;/em&gt; item.</source>
          <target state="translated">Существует также оператор &lt;code&gt;throttleFirst&lt;/code&gt; , который отличается от &lt;code&gt;throttleLast&lt;/code&gt; / &lt;code&gt;sample&lt;/code&gt; тем, что он испускает &lt;em&gt;первый&lt;/em&gt; элемент, испускаемый источником Observable в каждом периоде выборки, а не &lt;em&gt;последний отправленный&lt;/em&gt; элемент.</target>
        </trans-unit>
        <trans-unit id="1abf445457383a8d1a550a4666c34b283fc4d7f8" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxGroovy 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">В RxGroovy 1.1 также есть новый оператор, называемый &lt;code&gt;switchIfEmpty&lt;/code&gt; , который вместо выдачи резервного &lt;em&gt;значения,&lt;/em&gt; если исходный Observable завершается без передачи каких-либо элементов, он испускает выбросы из резервного &lt;em&gt;Observable&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1d407e02d3cef84f4a97e1dea8d87f2761215549" translate="yes" xml:space="preserve">
          <source>There is also a new operator in RxJava 1.1 called &lt;code&gt;switchIfEmpty&lt;/code&gt; that, rather than emitting a backup &lt;em&gt;value&lt;/em&gt; if the source Observable terminates without having emitted any items, it emits the emissions from a backup &lt;em&gt;Observable&lt;/em&gt;.</source>
          <target state="translated">В RxJava 1.1 также есть новый оператор, называемый &lt;code&gt;switchIfEmpty&lt;/code&gt; , который вместо того, чтобы генерировать резервное &lt;em&gt;значение,&lt;/em&gt; если исходный Observable завершает свою работу без отправки каких-либо элементов, он испускает выбросы из резервного &lt;em&gt;Observable&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="88e452542892fa3f048cc208ee51de7ba7b6bfa7" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxGroovy that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">В RxGroovy также существует специализированная форма оператора &quot;Фильтр&quot;,который фильтрует &quot;Наблюдаемое&quot; так,что он испускает только элементы определенного класса.</target>
        </trans-unit>
        <trans-unit id="cad5015a738f042fbcc8fcbefa23870ac6109eda" translate="yes" xml:space="preserve">
          <source>There is also a specialized form of the Filter operator in RxJava that filters an Observable so that it only emits items of a particular class.</source>
          <target state="translated">Существует также специализированная форма оператора Filter в RxJava,которая фильтрует &quot;Наблюдаемый&quot; так,что он испускает только элементы определенного класса.</target>
        </trans-unit>
        <trans-unit id="30fba8f0a70d3997f65d6c4711bb2800ae22ab62" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;scan&lt;/code&gt; to which you can pass a seed value to pass to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator. Note that if you use this version, &lt;code&gt;scan&lt;/code&gt; will emit this seed value as its own initial emission. Note also that passing a seed of &lt;code&gt;null&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as passing no seed at all. A &lt;code&gt;null&lt;/code&gt; seed is a valid variety of seed.</source>
          <target state="translated">Существует также вариант &lt;code&gt;scan&lt;/code&gt; при котором вы можете передать начальное значение для передачи в функцию аккумулятора при первом вызове (для первого выброса из источника Observable) вместо результата из отсутствующего предыдущего вызова аккумулятора. . Обратите внимание, что если вы используете эту версию, &lt;code&gt;scan&lt;/code&gt; выдаст это начальное значение как собственное начальное излучение. Также обратите внимание, что передача &lt;code&gt;null&lt;/code&gt; семени - это &lt;em&gt;не&lt;/em&gt; то же самое, что передача нулевого семени. &lt;code&gt;null&lt;/code&gt; семян является допустимым разнообразие семян.</target>
        </trans-unit>
        <trans-unit id="c27cc229fc79800fa19cb934a76962c6dbbba751" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skip&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">Существует также вариант &lt;code&gt;skip&lt;/code&gt; который занимает временную продолжительность, а не количество элементов. Он отбрасывает те элементы, которые излучаются в течение этой начальной продолжительности жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая отрезок времени, и единицы времени, в которых эта длина обозначается как параметры, которые нужно &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9feb05589b0e81a02e0e7767bb09a69dfc4a56cf" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;skipLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It drops those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;skipLast&lt;/code&gt;.</source>
          <target state="translated">Также существует вариант &lt;code&gt;skipLast&lt;/code&gt; , который требует временной продолжительности, а не количества элементов. Он отбрасывает те элементы, которые испускаются в течение этого окончательного срока жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая отрезок времени, и единицы времени, в которых эта длина обозначается, как параметры &lt;code&gt;skipLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08051516481f1b3895ac9cf3adcd62adbae06014" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;take&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It results in an Observable that emits only those items that are emitted during that initial duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="translated">Существует также вариант &lt;code&gt;take&lt;/code&gt; который занимает временную продолжительность, а не количество предметов. В результате получается Observable, который испускает только те элементы, которые излучаются в течение этой начальной продолжительности жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая отрезок времени, и единицы времени, в которых эта длина обозначается как параметры, которые нужно &lt;code&gt;take&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="449128271b54eccb75227b4a5514bce689da6853" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;takeLast&lt;/code&gt; that takes a temporal duration rather than a quantity of items. It emits only those items that are emitted during that final duration of the source Observable&amp;rsquo;s lifespan. You set this duration by passing in a length of time and the time units this length is denominated in as parameters to &lt;code&gt;takeLast&lt;/code&gt;.</source>
          <target state="translated">Существует также вариант &lt;code&gt;takeLast&lt;/code&gt; , который требует временной продолжительности, а не количества элементов. Он испускает только те элементы, которые испускаются в течение этого окончательного срока жизни исходного Observable. Вы устанавливаете эту продолжительность, передавая отрезок времени, и единицы времени, в которых эта длина обозначается, как параметры &lt;code&gt;takeLast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a59fb0727f4b59bbb076c9c5305d1643bae8cd28" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeout&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">Существует также вариант &lt;code&gt;timeout&lt;/code&gt; который использует для каждого элемента Observable для установки продолжительности тайм-аута и переключается на резервную Observable в случае тайм-аута.</target>
        </trans-unit>
        <trans-unit id="031e84f5098d34601fbcb52c5bc13125fa8050ff" translate="yes" xml:space="preserve">
          <source>There is also a variant of &lt;code&gt;timeoutWithSelector&lt;/code&gt; that both uses a per-item Observable to set the timeout duration and switches to a backup Observable in case of a timeout.</source>
          <target state="translated">Существует также вариант &lt;code&gt;timeoutWithSelector&lt;/code&gt; , который использует для каждого элемента Observable для установки продолжительности тайм-аута и переключается на резервную Observable в случае тайм-аута.</target>
        </trans-unit>
        <trans-unit id="36700f3cd710204d79349671ecb78d033b6e018a" translate="yes" xml:space="preserve">
          <source>There is also a variant of this operator that takes a function as a parameter. This function operates on items emitted by the source Observable to generate a &amp;ldquo;key.&amp;rdquo; It is these keys, then, and not the items themselves, that &lt;code&gt;distinct&lt;/code&gt; will compare to determine whether or not two items are distinct.</source>
          <target state="translated">Существует также вариант этого оператора, который принимает функцию в качестве параметра. Эта функция работает с элементами, испускаемыми источником Observable, для генерации &amp;laquo;ключа&amp;raquo;. Именно эти ключи, то и не сами предметы, которые &lt;code&gt;distinct&lt;/code&gt; сравнит , чтобы определить , действительно ли два элемента различны.</target>
        </trans-unit>
        <trans-unit id="f10041ebeaec7e7413aaa8734dfe5111f3042d93" translate="yes" xml:space="preserve">
          <source>There is also a variant that combines the two methods. It emits the minimum of the number of items emitted during a specified time window &lt;em&gt;or&lt;/em&gt; a particular count of items.</source>
          <target state="translated">Также существует вариант, сочетающий два метода. Он генерирует минимальное количество элементов, выпущенных в течение определенного временного окна &lt;em&gt;или&lt;/em&gt; определенного количества элементов.</target>
        </trans-unit>
        <trans-unit id="0b8726cf18549a2cf1149657d39c80c83857f5b1" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes an emitted item from the source Observable as a parameter and produces the item that will be emitted in its place by the resulting Observable.</source>
          <target state="translated">Существует также вариант,который принимает функцию в качестве параметра.Эта функция принимает излучаемый элемент от источника Observable в качестве параметра и производит элемент,который будет излучаться на его место результирующим Observable.</target>
        </trans-unit>
        <trans-unit id="dc97cb652e36868458024e656ee272ac5b84c26e" translate="yes" xml:space="preserve">
          <source>There is also a variant that takes a function as a parameter. This function takes as a parameter the &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying Observable sequence. This function produces and returns a new Observable sequence.</source>
          <target state="translated">Существует также вариант, который принимает функцию в качестве параметра. Эта функция принимает в качестве параметра &lt;code&gt;ConnectableObservable&lt;/code&gt; , который использует одну подписку для базовой последовательности Observable. Эта функция создает и возвращает новую наблюдаемую последовательность.</target>
        </trans-unit>
        <trans-unit id="e5ae115f084cc2ab1aee05d0a43efa252b4c5426" translate="yes" xml:space="preserve">
          <source>There is also a variety of &lt;code&gt;replay&lt;/code&gt; that returns an ordinary Observable. These variants take as a parameter a transformative function; this function accepts an item emitted by the source Observable as its parameter, and returns an item to be emitted by the resulting Observable. So really, this operator does not replay the source Observable but instead replays the source Observable &lt;em&gt;as transformed&lt;/em&gt; by this function.</source>
          <target state="translated">Также существует множество &lt;code&gt;replay&lt;/code&gt; которые возвращают обычный Observable. Эти варианты принимают в качестве параметра преобразующую функцию; эта функция принимает в качестве параметра элемент, излучаемый исходным Observable, и возвращает элемент, который будет передан результирующим Observable. На самом деле, этот оператор не воспроизводит исходный Observable, а вместо этого воспроизводит исходный Observable, &lt;em&gt;преобразованный&lt;/em&gt; этой функцией.</target>
        </trans-unit>
        <trans-unit id="ff00967c6f2b2f7e162cb2796c317c702c4a18eb" translate="yes" xml:space="preserve">
          <source>There is also a variety that takes a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; as an argument:</source>
          <target state="translated">Существует также множество вариантов, в которых в качестве аргумента используется &lt;a href=&quot;scheduler&quot;&gt;планировщик&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6900629b96a56ae8022ad8f2d925a1196485317c" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;delayWithSelector&lt;/code&gt; that takes an additional (first) argument: an Observable that sets a delay before &lt;code&gt;delayWithSelector&lt;/code&gt; subscribes to the source Observable after it itself is subscribed to.</source>
          <target state="translated">Существует также версия &lt;code&gt;delayWithSelector&lt;/code&gt; , которая принимает дополнительный (первый) аргумент: Observable, который устанавливает задержку до того, как &lt;code&gt;delayWithSelector&lt;/code&gt; подпишется на исходный Observable после того, как он сам подписан.</target>
        </trans-unit>
        <trans-unit id="762fea989b34f515305f58f64134c4f4bcc94a1a" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxGroovy 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">Существует также версия &lt;code&gt;interval&lt;/code&gt; , которая возвращает Observable, который выдает один ноль после указанной задержки, а затем выдает постепенно увеличивающиеся числа после этого с определенной периодичностью. Эта версия &lt;code&gt;interval&lt;/code&gt; называлась &lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt; в RxGroovy 1.0.0, но с тех пор этот метод устарел и заменен &lt;code&gt;interval&lt;/code&gt; с таким же поведением.</target>
        </trans-unit>
        <trans-unit id="522b1ee6207e40a9269cf62e4c01ec31cdfb8604" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;interval&lt;/code&gt; that returns an Observable that emits a single zero after a specified delay, and then emits incrementally increasing numbers periodically thereafter on a specified periodicity. This version of &lt;code&gt;interval&lt;/code&gt; was called &lt;a href=&quot;timer&quot;&gt;&lt;code&gt;timer&lt;/code&gt;&lt;/a&gt; in RxJava 1.0.0, but that method has since been deprecated in favor of the one named &lt;code&gt;interval&lt;/code&gt; with the same behavior.</source>
          <target state="translated">Существует также версия &lt;code&gt;interval&lt;/code&gt; , которая возвращает Observable, который выдает один ноль после указанной задержки, а затем выдает постепенно увеличивающиеся числа, периодически после этого с указанной периодичностью. Эта версия &lt;code&gt;interval&lt;/code&gt; называлась &lt;a href=&quot;timer&quot;&gt; &lt;code&gt;timer&lt;/code&gt; &lt;/a&gt; в RxJava 1.0.0, но с тех пор этот метод устарел и заменен &lt;code&gt;interval&lt;/code&gt; с таким же поведением.</target>
        </trans-unit>
        <trans-unit id="fc631c74156b96e656eb92df791645c1d24072f1" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;reduce&lt;/code&gt; to which you can pass a seed item in addition to an accumulator function. Note that passing a &lt;code&gt;null&lt;/code&gt; seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of &lt;code&gt;null&lt;/code&gt;, you will be seeding your reduction with the item &lt;code&gt;null&lt;/code&gt;. Note also that if you do pass in a seed, and the source Observable emits no items, reduce will emit the seed and complete normally without error.</source>
          <target state="translated">Существует также версия &lt;code&gt;reduce&lt;/code&gt; в которую вы можете передать начальный элемент в дополнение к функции аккумулятора. Обратите внимание, что передача &lt;code&gt;null&lt;/code&gt; семени - это не то же самое, что не передавать семя. Поведение будет другим. Если вы передадите начальное значение &lt;code&gt;null&lt;/code&gt; , вы начнете свое сокращение с помощью элемента &lt;code&gt;null&lt;/code&gt; . Также обратите внимание, что если вы передаете семя, а исходный Observable не генерирует никаких элементов, reduce выдаст семя и завершится нормально без ошибок.</target>
        </trans-unit>
        <trans-unit id="5202b7fb8ff33cff94a68a1b5e152acba79749b9" translate="yes" xml:space="preserve">
          <source>There is also a version of &lt;code&gt;timer&lt;/code&gt; that returns an Observable that emits a single item after a specified delay, and then emits items periodically thereafter on a specified periodicity. In this way it behaves a bit more like the &lt;a href=&quot;interval&quot;&gt;Interval&lt;/a&gt; operator.</source>
          <target state="translated">Существует также версия &lt;code&gt;timer&lt;/code&gt; который возвращает Observable, который генерирует один элемент после указанной задержки, а затем периодически выпускает элементы с указанной периодичностью. Таким образом, он больше похож на оператор &lt;a href=&quot;interval&quot;&gt;Interval&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="539cbb5c3fad3008ba0960da437343ef5a498e5a" translate="yes" xml:space="preserve">
          <source>There is also a version of this operator that allows you to perform the delay on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;:</source>
          <target state="translated">Также существует версия этого оператора, которая позволяет выполнять задержку в конкретном &lt;a href=&quot;scheduler&quot;&gt;Планировщике&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="139c58d44cf810efd4f9f9031e89d1cd0ddb3c18" translate="yes" xml:space="preserve">
          <source>There is also an &lt;code&gt;ofArrayChanges&lt;/code&gt; operator that monitors an Array with the &lt;code&gt;Array.observe&lt;/code&gt; method, and returns an Observable that emits any changes that take place in the array. This operator is found only in the &lt;code&gt;rx.all.js&lt;/code&gt; distribution.</source>
          <target state="translated">Также существует оператор &lt;code&gt;ofArrayChanges&lt;/code&gt; , который отслеживает массив с &lt;code&gt;Array.observe&lt;/code&gt; метода Array.observe и возвращает Observable, который генерирует любые изменения, происходящие в массиве. Этот оператор есть только в дистрибутиве &lt;code&gt;rx.all.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8eddbc3c124fb70ba958a1ab03bc7c5cb95d456" translate="yes" xml:space="preserve">
          <source>There is also an instance method, &lt;code&gt;concatWith&lt;/code&gt;, such that &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; is equivalent to &lt;code&gt;a.concatWith(b)&lt;/code&gt;.</source>
          <target state="translated">Также существует метод экземпляра &lt;code&gt;concatWith&lt;/code&gt; , такой что &lt;code&gt;Observable.concat(a,b)&lt;/code&gt; эквивалентен &lt;code&gt;a.concatWith(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38523a50cc8364b3f16b29daf3c937099c5ef9b5" translate="yes" xml:space="preserve">
          <source>There is also an instance version of this operator:</source>
          <target state="translated">Также существует экземпляровая версия этого оператора:</target>
        </trans-unit>
        <trans-unit id="a6ab646dfb9f2df1243f7f0eecb8d5ca2c659762" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;pluck&lt;/code&gt; which is a simpler version of this operator. It transforms the elements emitted by the source Observable by extracting a single named property from those elements and emitting that property in their place.</source>
          <target state="translated">Также существует оператор &lt;code&gt;pluck&lt;/code&gt; , который является более простой версией этого оператора. Он преобразует элементы, излучаемые источником Observable, извлекая одно именованное свойство из этих элементов и генерируя это свойство вместо них.</target>
        </trans-unit>
        <trans-unit id="8a6307e1784a009488a1fd7f31602a8bdede7cc4" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;repeatWhen&lt;/code&gt;. Rather than buffering and replaying the sequence from the source Observable, it &lt;em&gt;resubscribes&lt;/em&gt; to and mirrors the source Observable, but only conditionally.</source>
          <target state="translated">Также есть оператор &lt;code&gt;repeatWhen&lt;/code&gt; . Вместо того, чтобы буферизовать и воспроизводить последовательность из исходного Observable, он &lt;em&gt;повторно подписывается&lt;/em&gt; и зеркально отражает исходный Observable, но только условно.</target>
        </trans-unit>
        <trans-unit id="92996dc580469547aa517e94605bc5bf1f133e10" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It differs in behavior from &lt;code&gt;takeLast&lt;/code&gt; by emitting its items not individually but collected into a single array of items that is emitted as a single item.</source>
          <target state="translated">Также существует оператор &lt;code&gt;takeLastBuffer&lt;/code&gt; . Он отличается по поведению от &lt;code&gt;takeLast&lt;/code&gt; тем, что испускает свои элементы не индивидуально, а собирает их в единый массив элементов, который генерируется как единый элемент.</target>
        </trans-unit>
        <trans-unit id="e106bef886f7af5b82506fb949433f1cdb132fb9" translate="yes" xml:space="preserve">
          <source>There is also an operator called &lt;code&gt;takeLastBuffer&lt;/code&gt;. It exists in the same set of variants as described above for &lt;code&gt;takeLast&lt;/code&gt;, and only differs in behavior by emitting its items not individually but collected into a single &lt;code&gt;List&lt;/code&gt; of items that is emitted as a single item.</source>
          <target state="translated">Также существует оператор &lt;code&gt;takeLastBuffer&lt;/code&gt; . Он существует в том же наборе вариантов, что и описанный выше для &lt;code&gt;takeLast&lt;/code&gt; , и отличается только поведением тем, что испускает свои элементы не по отдельности, а собирает их в один &lt;code&gt;List&lt;/code&gt; элементов, который создается как один элемент.</target>
        </trans-unit>
        <trans-unit id="d13d40451e716541ebf0c6d731751a04de4ef9d8" translate="yes" xml:space="preserve">
          <source>There is also an operator with which you can delay the subscription to the source Observable: &lt;code&gt;delaySubscription&lt;/code&gt;. It accepts parameters that define the amount of time to delay (a quantity of time, and a &lt;code&gt;TimeUnit&lt;/code&gt; that this quantity is denominated in).</source>
          <target state="translated">Также есть оператор, с помощью которого можно отложить подписку на источник Observable: &lt;code&gt;delaySubscription&lt;/code&gt; . Он принимает параметры, определяющие количество времени для задержки (количество времени и &lt;code&gt;TimeUnit&lt;/code&gt; ,в котором это количество выражается).</target>
        </trans-unit>
        <trans-unit id="57b225db5c327853ba9175d45fd1a4710008118b" translate="yes" xml:space="preserve">
          <source>These Rx operators allow you to compose asynchronous sequences together in a declarative manner with all the efficiency benefits of callbacks but without the drawbacks of nesting callback handlers that are typically associated with asynchronous systems.</source>
          <target state="translated">Эти операторы Rx позволяют составлять асинхронные последовательности декларативным образом со всеми преимуществами эффективности обратных вызовов,но без недостатков вложенных обработчиков обратных вызовов,которые обычно ассоциируются с асинхронными системами.</target>
        </trans-unit>
        <trans-unit id="b342145d78f94ba5bc005eea9d73e6207c97bba6" translate="yes" xml:space="preserve">
          <source>These are found in the following packages:</source>
          <target state="translated">Они находятся в следующих пакетах:</target>
        </trans-unit>
        <trans-unit id="9c99563d62b8dafa8a56d975e28fbd373c39956c" translate="yes" xml:space="preserve">
          <source>These are not part of the core RxJava implementation, but are found as &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;then&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; in the &lt;code&gt;rxjava-joins&lt;/code&gt; module.</source>
          <target state="translated">Они не являются частью основной реализации RxJava, но находятся как &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;then&lt;/code&gt; , и &lt;code&gt;when&lt;/code&gt; в &lt;code&gt;rxjava-joins&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9a600662c2fc82f13668558f5d63c8a1fcdcd74" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but &lt;code&gt;empty&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; optionally take a Scheduler as a parameter, and if you pass them a Scheduler they will issue their termination notifications on that Scheduler.</source>
          <target state="translated">Эти операторы по умолчанию не работают с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; , но &lt;code&gt;empty&lt;/code&gt; и &lt;code&gt;error&lt;/code&gt; необходимости, принимают планировщик в качестве параметра, и если вы передадите им планировщик, они будут выдавать свои уведомления о завершении в этом планировщике.</target>
        </trans-unit>
        <trans-unit id="a0c61cebbcf2a1d3434e4df6af333148712f0bf6" translate="yes" xml:space="preserve">
          <source>These operators do not operate by default on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Эти операторы по умолчанию не работают ни в одном конкретном &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd5a1235b46cc038c2c8dfd4ff72d2c0352c88b" translate="yes" xml:space="preserve">
          <source>These pages include information about some operators that are not part of the core of ReactiveX but are implemented in one or more of language-specific implementations and/or optional modules.</source>
          <target state="translated">Эти страницы содержат информацию о некоторых операторах,не входящих в ядро ReactiveX,но реализованных в одной или нескольких языковых реализациях и/или дополнительных модулях.</target>
        </trans-unit>
        <trans-unit id="5c0b03b39df18d437c443c915a55a790fd23c116" translate="yes" xml:space="preserve">
          <source>These two operators are both available in each of the following distributions:</source>
          <target state="translated">Эти два оператора доступны в каждом из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="bcbafb20f7ea21b3026c1ebc35afb9f862e6a451" translate="yes" xml:space="preserve">
          <source>They each require one of the following distributions:</source>
          <target state="translated">Каждое из них требует одного из следующих распределений:</target>
        </trans-unit>
        <trans-unit id="916223df0a0362f110f17d6ced5cde0a2f3c560d" translate="yes" xml:space="preserve">
          <source>They require one of the following distributions:</source>
          <target state="translated">Они требуют одного из следующих дистрибутивов:</target>
        </trans-unit>
        <trans-unit id="08773d29a7c65ab1b76fc7763b4fa5f4dfb28a6f" translate="yes" xml:space="preserve">
          <source>They require one of the following packages:</source>
          <target state="translated">Им нужен один из следующих пакетов:</target>
        </trans-unit>
        <trans-unit id="238cc3432981781641c15b8b2183f3d63f5d3335" translate="yes" xml:space="preserve">
          <source>They requires one of the following:</source>
          <target state="translated">Они требуют одного из следующих:</target>
        </trans-unit>
        <trans-unit id="44f376b551befd476ffb7da70312237937318ec6" translate="yes" xml:space="preserve">
          <source>This documentation accompanies its explanations with &amp;ldquo;marble diagrams.&amp;rdquo; Here is how marble diagrams represent Observables and transformations of Observables:</source>
          <target state="translated">Эта документация сопровождает свои пояснения &amp;laquo;мраморными диаграммами&amp;raquo;. Вот как мраморные диаграммы представляют наблюдаемые и преобразования наблюдаемых:</target>
        </trans-unit>
        <trans-unit id="5281791692d83f6908a511d623cd74573af6ee17" translate="yes" xml:space="preserve">
          <source>This documentation groups information about &lt;a href=&quot;operators#alphabetical&quot;&gt;the various operators&lt;/a&gt; and examples of their usage into the following pages:</source>
          <target state="translated">В этой документации информация о &lt;a href=&quot;operators#alphabetical&quot;&gt;различных операторах&lt;/a&gt; и примерах их использования сгруппирована на следующих страницах:</target>
        </trans-unit>
        <trans-unit id="d376cbe36ad100032f76fcc1541bba68f850b7f9" translate="yes" xml:space="preserve">
          <source>This first variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">Этот первый вариант &lt;code&gt;merge&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="a5b5cc4b77c771ca16da88c602c7239a8d8f15cf" translate="yes" xml:space="preserve">
          <source>This implementation borrows the confusing nomenclature from Rx.NET, in which &lt;code&gt;onErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable.</source>
          <target state="translated">Эта реализация заимствует запутанную номенклатуру из Rx.NET, в которой &lt;code&gt;onErrorResumeNext&lt;/code&gt; переключается на резервный Observable как при ошибке, так &lt;em&gt;и&lt;/em&gt; при нормальном безошибочном завершении исходного Observable.</target>
        </trans-unit>
        <trans-unit id="ed80ee8261095cde1024407fe495ab29a4c3c56e" translate="yes" xml:space="preserve">
          <source>This implementation introduces a confusing nomenclature, in which in spite of its name &lt;code&gt;OnErrorResumeNext&lt;/code&gt; switches to a back-up Observable both on an error &lt;em&gt;and&lt;/em&gt; on a normal, error-free termination of the source Observable. It is therefore more like a concatenation operator.</source>
          <target state="translated">Эта реализация вводит запутанную номенклатуру, в которой, несмотря на свое название, &lt;code&gt;OnErrorResumeNext&lt;/code&gt; переключается на резервный Observable как при ошибке, так &lt;em&gt;и&lt;/em&gt; при нормальном, безошибочном завершении исходного Observable. Таким образом, он больше похож на оператор конкатенации.</target>
        </trans-unit>
        <trans-unit id="0655f655c3305986ec20a3e6752fc22aaa4b2538" translate="yes" xml:space="preserve">
          <source>This method is useful, for example, when you have an Observable that emits a series of items that themselves have Observable members or are in other ways transformable into Observables, so that you can create a new Observable that emits the complete collection of items emitted by the sub-Observables of these items.</source>
          <target state="translated">Этот метод полезен,например,когда у вас есть Observable,который испускает серию элементов,которые сами по себе являются Observable членами,или иным образом трансформируются в Observables,так что вы можете создать новый Observable,который испускает полную коллекцию элементов,испускаемых SubObservables этих элементов.</target>
        </trans-unit>
        <trans-unit id="a30ad7717749cac98edadad7cd7de1d8efe78cb2" translate="yes" xml:space="preserve">
          <source>This operator also takes an optional third parameter: a function that accepts the arguments from the event handler as parameters and returns an item to be emitted by the resulting Observable in place of the event.</source>
          <target state="translated">Этот оператор также принимает необязательный третий параметр:функцию,которая принимает аргументы обработчика события в качестве параметров и возвращает вместо события элемент,который должен быть передан результирующим Observable.</target>
        </trans-unit>
        <trans-unit id="f5e313c1df6d6f54ad302fc2dedb052cab252e38" translate="yes" xml:space="preserve">
          <source>This operator also takes three additional, optional parameters:</source>
          <target state="translated">Этот оператор также принимает три дополнительных,опциональных параметра:</target>
        </trans-unit>
        <trans-unit id="851f179b5f78b3880ad3289ce9b914d51abc4285" translate="yes" xml:space="preserve">
          <source>This operator also takes two additional, optional parameters:</source>
          <target state="translated">Этот оператор также принимает два дополнительных,опциональных параметра:</target>
        </trans-unit>
        <trans-unit id="fcac799407a98fcba63c160676594897d39befce" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Future&lt;/code&gt; that will return the single item emitted by the source Observable. If the source Observable emits more than one item, the &lt;code&gt;Future&lt;/code&gt; will receive an &lt;code&gt;IllegalArgumentException&lt;/code&gt;; if it completes after emitting no items, the &lt;code&gt;Future&lt;/code&gt; will receive a &lt;code&gt;NoSuchElementException&lt;/code&gt;.</source>
          <target state="translated">Этот оператор преобразует Observable в &lt;code&gt;Future&lt;/code&gt; , который вернет единственный элемент, выданный исходным Observable. Если исходный Observable испускает более одного элемента, &lt;code&gt;Future&lt;/code&gt; получит &lt;code&gt;IllegalArgumentException&lt;/code&gt; ; если он завершится после отсутствия элементов, &lt;code&gt;Future&lt;/code&gt; получит &lt;code&gt;NoSuchElementException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96728cf23a02c28de0a99116e4e6f37ac9437def" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterable&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">Этот оператор преобразует Observable в &lt;code&gt;Iterable&lt;/code&gt; , с помощью которого вы можете перебирать набор элементов, выдаваемых исходным Observable.</target>
        </trans-unit>
        <trans-unit id="051af4f85d777e94bfacdab9a3b5169cc86dfb4d" translate="yes" xml:space="preserve">
          <source>This operator converts an Observable into an &lt;code&gt;Iterator&lt;/code&gt; with which you can iterate over the set of items emitted by the source Observable.</source>
          <target state="translated">Этот оператор преобразует Observable в &lt;code&gt;Iterator&lt;/code&gt; , с помощью которого вы можете перебирать набор элементов, генерируемых исходным Observable.</target>
        </trans-unit>
        <trans-unit id="7773f8dca511285fc6ff6888904509c3878d7c51" translate="yes" xml:space="preserve">
          <source>This operator does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот оператор по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="157b4dc6015159c8ffac986b079921217fd87e4b" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;averageDouble&lt;/code&gt;, &lt;code&gt;averageFloat&lt;/code&gt;, &lt;code&gt;averageInteger&lt;/code&gt;, and &lt;code&gt;averageLong&lt;/code&gt;.</source>
          <target state="translated">Этот оператор отсутствует в ядре RxJava, но является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; , где он реализован с помощью четырех операторов , &lt;code&gt;averageFloat&lt;/code&gt; типа: &lt;code&gt;averageDouble&lt;/code&gt; , averageFloat , &lt;code&gt;averageInteger&lt;/code&gt; и &lt;code&gt;averageLong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abc6aa7fb60aaaf411d1cdedf546c6eadb42a5b8" translate="yes" xml:space="preserve">
          <source>This operator is not in the RxJava core, but is part of the distinct &lt;code&gt;rxjava-math&lt;/code&gt; module, where it is implemented with four type-specific operators: &lt;code&gt;sumDouble&lt;/code&gt;, &lt;code&gt;sumFloat&lt;/code&gt;, &lt;code&gt;sumInteger&lt;/code&gt;, and &lt;code&gt;sumLong&lt;/code&gt;.</source>
          <target state="translated">Этот оператор отсутствует в ядре RxJava, но является частью отдельного &lt;code&gt;rxjava-math&lt;/code&gt; , где он реализован с помощью четырех операторов , &lt;code&gt;sumFloat&lt;/code&gt; типа: &lt;code&gt;sumDouble&lt;/code&gt; , sumFloat , &lt;code&gt;sumInteger&lt;/code&gt; и &lt;code&gt;sumLong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de110854ecb7b4ee552a7ef41d8c72018c80ab1" translate="yes" xml:space="preserve">
          <source>This operator operates by default on the &lt;code&gt;timeout&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can override this by passing in another Scheduler as an optional second parameter.</source>
          <target state="translated">Этот оператор по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; , но вы можете переопределить это, передав другой планировщик в качестве необязательного второго параметра.</target>
        </trans-unit>
        <trans-unit id="02c50ddd466d3ebbb2748eac79e6fbfb4598c90f" translate="yes" xml:space="preserve">
          <source>This operator takes three additional, optional parameters:</source>
          <target state="translated">Этот оператор принимает три дополнительных,опциональных параметра:</target>
        </trans-unit>
        <trans-unit id="3dbabee9b79e9df2145ceeeb98aafe6caecdb79f" translate="yes" xml:space="preserve">
          <source>This operator will fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if the source Observable does not emit any items.</source>
          <target state="translated">Этот оператор завершится ошибкой с &lt;code&gt;IllegalArgumentException&lt;/code&gt; , если исходный Observable не испускает никаких элементов.</target>
        </trans-unit>
        <trans-unit id="b104d679edb25132e93ff79622e9a5c691555507" translate="yes" xml:space="preserve">
          <source>This page explains what the reactive pattern is and what Observables and observers are (and how observers subscribe to Observables). Other pages show how you use &lt;a href=&quot;operators&quot;&gt;the variety of Observable operators&lt;/a&gt; to link Observables together and change their behaviors.</source>
          <target state="translated">На этой странице объясняется, что такое реактивный шаблон и что такое Observables и наблюдатели (и как наблюдатели подписываются на Observables). На других страницах показано, как вы используете &lt;a href=&quot;operators&quot;&gt;различные операторы Observable&lt;/a&gt; для связывания Observable и изменения их поведения.</target>
        </trans-unit>
        <trans-unit id="c116dd880801c77b8119160bb66b54963e21fff6" translate="yes" xml:space="preserve">
          <source>This page first lists what could be considered the &amp;ldquo;core&amp;rdquo; operators in ReactiveX, and links to pages that have more in-depth information on how these operators work and how particular language-specific ReactiveX versions have implemented these operators.</source>
          <target state="translated">На этой странице сначала перечислены операторы, которые можно считать &amp;laquo;основными&amp;raquo; в ReactiveX, а также ссылки на страницы, на которых есть более подробная информация о том, как работают эти операторы и как конкретные языковые версии ReactiveX реализовали эти операторы.</target>
        </trans-unit>
        <trans-unit id="77bb9ef85c54fbff31ff241c29acb1a8e1ec2d12" translate="yes" xml:space="preserve">
          <source>This page summarizes The Observable Contract.</source>
          <target state="translated">На этой странице приведена краткая информация о Контракте с оговорками.</target>
        </trans-unit>
        <trans-unit id="8f1eb87eb26b05c1dd9b754759baaa987adf0fc3" translate="yes" xml:space="preserve">
          <source>This page uses Groovy-like pseudocode for its examples, but there are ReactiveX implementations in many languages.</source>
          <target state="translated">Эта страница использует для своих примеров псевдокод Groovy-подобный,но существуют реализации ReactiveX на многих языках.</target>
        </trans-unit>
        <trans-unit id="b8093fb2efdcee4333d8cd01bcaf5d4c8a8678af" translate="yes" xml:space="preserve">
          <source>This second variant of &lt;code&gt;merge&lt;/code&gt; is found in the following distributions:</source>
          <target state="translated">Этот второй вариант &lt;code&gt;merge&lt;/code&gt; встречается в следующих дистрибутивах:</target>
        </trans-unit>
        <trans-unit id="f5221f3b3887c251e11acd84d5b1946975ecec50" translate="yes" xml:space="preserve">
          <source>This sort of operation is sometimes called &amp;ldquo;accumulate,&amp;rdquo; &amp;ldquo;aggregate,&amp;rdquo; &amp;ldquo;compress,&amp;rdquo; &amp;ldquo;fold,&amp;rdquo; or &amp;ldquo;inject&amp;rdquo; in other contexts.</source>
          <target state="translated">Этот вид операции иногда называется &amp;laquo;накопление&amp;raquo;, &amp;laquo;агрегирование&amp;raquo;, &amp;laquo;сжатие&amp;raquo;, &amp;laquo;сворачивание&amp;raquo; или &amp;laquo;внедрение&amp;raquo; в других контекстах.</target>
        </trans-unit>
        <trans-unit id="edafb359c827bcb10eb8a71786f17d2080d73b14" translate="yes" xml:space="preserve">
          <source>This sort of operator is sometimes called an &amp;ldquo;accumulator&amp;rdquo; in other contexts.</source>
          <target state="translated">Операторы такого типа в других контекстах иногда называют &amp;laquo;аккумулятором&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c2561f854f2cc3c3e7da610a0e22ba37f41c88e2" translate="yes" xml:space="preserve">
          <source>This tree can help you find the ReactiveX Observable operator you&amp;rsquo;re looking for.</source>
          <target state="translated">Это дерево может помочь вам найти нужный оператор ReactiveX Observable.</target>
        </trans-unit>
        <trans-unit id="705b10f8b5e84a3e1368d87690c43d30829c3378" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;TWindowOpening&lt;/code&gt; object and at the same time calls the &lt;code&gt;windowClosingSelector&lt;/code&gt;, passing it that &lt;code&gt;TWindowOpening&lt;/code&gt; object, to generate a closing Observable associated with that window. When that closing Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the associated window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;Window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; открывает окно всякий раз, когда он наблюдает, как &lt;code&gt;windowOpenings&lt;/code&gt; Observable испускает объект &lt;code&gt;TWindowOpening&lt;/code&gt; и в то же время вызывает &lt;code&gt;windowClosingSelector&lt;/code&gt; , передавая ему этот объект &lt;code&gt;TWindowOpening&lt;/code&gt; , чтобы сгенерировать закрывающий Observable, связанный с этим окном. Когда это закрытие Observable испускает объект &lt;code&gt;TWindowClosing&lt;/code&gt; , &lt;code&gt;Window&lt;/code&gt; закрывает связанное окно. Поскольку закрытие открытых в данный момент окон и открытие новых окон - это действия, которые регулируются независимыми Observables, этот вариант &lt;code&gt;Window&lt;/code&gt; может создавать окна, которые перекрываются (дублирование элементов из исходного Observable) или оставляют промежутки (отбрасывание элементов из исходного Observable).</target>
        </trans-unit>
        <trans-unit id="97bf8eec0e5141569863b0c827f33e4e7d535d42" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;windowClosingSelector&lt;/code&gt; function to obtain a second Observable. Whenever this second Observable emits a &lt;code&gt;TWindowClosing&lt;/code&gt; object, &lt;code&gt;Window&lt;/code&gt; closes the currently open window, and immediately opens a new one. It repeats this process until either Observable terminates. In this way, this variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable, until the closing selector observable terminates.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; немедленно открывает свое первое окно и вызывает функцию &lt;code&gt;windowClosingSelector&lt;/code&gt; для получения второго Observable. Всякий раз, когда этот второй Observable испускает объект &lt;code&gt;TWindowClosing&lt;/code&gt; , &lt;code&gt;Window&lt;/code&gt; закрывает текущее открытое окно и немедленно открывает новое. Он повторяет этот процесс до тех пор, пока не завершится любой из Observable. Таким образом, этот вариант &lt;code&gt;Window&lt;/code&gt; испускает серию неперекрывающихся окон, коллективные выбросы которых соответствуют один-к-одному исходному Observable, пока закрывающий селектор Observable не завершится.</target>
        </trans-unit>
        <trans-unit id="98502a842a954982b7ce81f17a6a8c51360051d2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeShift&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timeSpan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timeSpan&lt;/code&gt; and &lt;code&gt;timeShift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; открывает свое первое окно сразу же, а затем открывает новое окно каждый раз &lt;code&gt;timeShift&lt;/code&gt; период времени timeShift (в форме объекта &lt;code&gt;TimeSpan&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; ). Он закрывает текущее открытое окно по &lt;code&gt;timeSpan&lt;/code&gt; периода времени timeSpan с момента открытия этого окна. Он также закроет любое открытое в данный момент окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от исходного Observable. В зависимости от того, как вы устанавливаете &lt;code&gt;timeSpan&lt;/code&gt; и &lt;code&gt;timeShift&lt;/code&gt; , окна, возникающие в результате этой операции, могут перекрываться или иметь промежутки.</target>
        </trans-unit>
        <trans-unit id="4be1faa38714c36860cdde5e7e666e4a6e9464a1" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и немедленно открывает новое всякий раз, когда текущее окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;Window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="a187c3c7d20ee06b8c8d87d6e5adbb59e83be522" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timeSpan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timeSpan&lt;/code&gt; период времени timeSpan (в форме объекта &lt;code&gt;TimeSpan&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; ) или всякий раз, когда открытое в данный момент окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="55396b207982a5418912406d3afd4bff84fde485" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in the form of a &lt;code&gt;TimeSpan&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;IScheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;Window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timespan&lt;/code&gt; времени (в форме объекта &lt;code&gt;TimeSpan&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;IScheduler&lt;/code&gt; &lt;/a&gt; ). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;Window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="e6921e1d3d31550d1a98f0a86ca02bb1cd8c8379" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;Window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Этот вариант &lt;code&gt;Window&lt;/code&gt; сразу открывает свое первое окно. Он открывает новое окно, начиная с каждого элемента &lt;code&gt;skip&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;skip&lt;/code&gt; равно 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно испускает элементы &lt;code&gt;count&lt;/code&gt; или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Если &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; то ведет себя так же, как &lt;code&gt;Window(source,&amp;nbsp;count)&lt;/code&gt; ; если &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; это будет выдавать окна, перекрывающиеся по &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; элементы; если &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; это будет генерировать окна, которые &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; элементы с пропуском подсчета из исходного Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="c860df6d9d7d7bbc4dffd959fc12e6ab3d15a2a4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;debounce&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;debounce&lt;/code&gt; по умолчанию не работает ни с одним конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd2f07d1f74443fcca4dba475d554c45d9fefa68" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; by default runs on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can choose a different Scheduler by passing it in as an optional third parameter to &lt;code&gt;delaySubscription&lt;/code&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;delay&lt;/code&gt; по умолчанию выполняется в &lt;a href=&quot;../scheduler&quot;&gt;планировщике &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете выбрать другой планировщик, передав его в качестве необязательного третьего параметра в &lt;code&gt;delaySubscription&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a735f7a290a0e3c83a8ff7f0b53d700ad552f6" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delay&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;delay&lt;/code&gt; по умолчанию не работает ни в одном конкретном &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="737ad7a4d0393add7f03cd203a8047bab096ef18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;delaySubscription&lt;/code&gt; does not by default run on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;delaySubscription&lt;/code&gt; по умолчанию не работает ни в одном конкретном &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6803b366342fa051633884e5aa522cd6078903e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;sample&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf012d47d4bc079503c714e892ebcb4fd79c0201" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sample&lt;/code&gt; operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;sample&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете дополнительно передать планировщик по вашему выбору в качестве третьего параметра.</target>
        </trans-unit>
        <trans-unit id="409de3ece48bb2e6d1feb6d3bcfc772fcf41dff8" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;skip&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного третьего параметра.</target>
        </trans-unit>
        <trans-unit id="e994cf05c6f2a358611ec5ee6d239a28c7c8c490" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skip&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;skip&lt;/code&gt; по умолчанию не работает ни с одним конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d44643f63e5b34f4e84daa5e287555095a653012" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;skipLast&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного третьего параметра.</target>
        </trans-unit>
        <trans-unit id="653a339a6c160863b57c50e0518e6c234f4a2fbd" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;skipLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;skipLast&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a92f18fffbf6ac36d3ae397e2077eac1256c5a95" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;openings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closings&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an item, &lt;code&gt;sliding&lt;/code&gt; closes that window.</source>
          <target state="translated">Этот вариант &lt;code&gt;sliding&lt;/code&gt; открывает окно всякий раз, когда он наблюдает за &lt;code&gt;openings&lt;/code&gt; Observable испускает объект &lt;code&gt;Opening&lt;/code&gt; и в то же время вызывает &lt;code&gt;closings&lt;/code&gt; для создания закрывающего Observable, связанного с этим окном. Когда это закрытие Observable испускает элемент, &lt;code&gt;sliding&lt;/code&gt; закрывает это окно.</target>
        </trans-unit>
        <trans-unit id="9d7114d84069bab442e1a2baecd16659f4731291" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened or once &lt;code&gt;count&lt;/code&gt; items have been emitted on that window. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;sliding&lt;/code&gt; открывает свое первое окно немедленно, а после этого открывает новое окно каждый период времени с &lt;code&gt;timeshift&lt;/code&gt; (в форме объекта &lt;code&gt;Duration&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Он закрывает в настоящее время открытое окно после &lt;code&gt;timespan&lt;/code&gt; периода времени прошло с тех пор , что окно было открыто или когда - то &lt;code&gt;count&lt;/code&gt; предметов были выброшены на этом окне. Он также закроет любое открытое в данный момент окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от исходного Observable.</target>
        </trans-unit>
        <trans-unit id="48c41e41d48a655cf8b2b53aa6dc1febc83b8551" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (in the form of a &lt;code&gt;Duration&lt;/code&gt; object, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;sliding&lt;/code&gt; открывает свое первое окно немедленно, а после этого открывает новое окно каждый период времени с &lt;code&gt;timeshift&lt;/code&gt; (в форме объекта &lt;code&gt;Duration&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Он закрывает в настоящее время открытое окно после &lt;code&gt;timespan&lt;/code&gt; периода времени прошло с момента открытия этого окна. Он также закроет любое открытое в данный момент окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от исходного Observable.</target>
        </trans-unit>
        <trans-unit id="7c928da076f93edde2602acc469e63d58409880b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;sliding&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;tumbling(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Этот вариант &lt;code&gt;sliding&lt;/code&gt; открывает свое первое окно. Он открывает новое окно, начиная с каждого элемента &lt;code&gt;skip&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;skip&lt;/code&gt; равно 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно испускает элементы &lt;code&gt;count&lt;/code&gt; или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Если &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; это ведет себя так же, как &lt;code&gt;tumbling(count)&lt;/code&gt; ; если &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; это будет выдавать окна, перекрывающиеся по &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; элементы; если &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; это будет генерировать окна, которые &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; элементы с пропуском подсчета из исходного Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="89dff3742ba07b7efcc661354ebd2e40382e8a0b" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;take&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного третьего параметра.</target>
        </trans-unit>
        <trans-unit id="c4faaa677832834fcac1002f1aa24a6e5a6b22a9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;take&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;take&lt;/code&gt; по умолчанию не работает с каким-либо конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="657acbff045486dbea7d27744af10d6c32942c62" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional fourth parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;takeLast&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного четвертого параметра.</target>
        </trans-unit>
        <trans-unit id="72f2d252be7ba01ae12dd933d1af12d7f39d6950" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; by default operates on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you may also pass in a Scheduler of your choosing as an optional third parameter.</source>
          <target state="translated">Этот вариант &lt;code&gt;takeLast&lt;/code&gt; по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы также можете передать планировщик по вашему выбору в качестве необязательного третьего параметра.</target>
        </trans-unit>
        <trans-unit id="042c56433de6cca61a28e4c7ce8ff88898502335" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;takeLast&lt;/code&gt; does not by default operate on any particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;takeLast&lt;/code&gt; по умолчанию не работает ни с одним конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dcedede039a8ce96e34904dd498d9372ef230b55" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;timeout&lt;/code&gt; by default runs on the &lt;code&gt;immediate&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;timeout&lt;/code&gt; по умолчанию запускается в &lt;code&gt;immediate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e86fc9829ce8349d40eba57712fb2a0d949a58" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;tumbling&lt;/code&gt; открывает свое первое окно. Он закрывает текущее открытое окно и немедленно открывает новое всякий раз, когда текущее окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable.</target>
        </trans-unit>
        <trans-unit id="6398043bbc04304d7192b07e90caf700ab6ec7c2" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;tumbling&lt;/code&gt; открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый раз в определенный &lt;code&gt;timespan&lt;/code&gt; времени ( &lt;code&gt;Duration&lt;/code&gt; , необязательно измеряемая в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ) или всякий раз, когда открытое в настоящее время окно выдало &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable.</target>
        </trans-unit>
        <trans-unit id="babbf35991f5d12016aa579a5bae94a4d892870e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (a &lt;code&gt;Duration&lt;/code&gt;, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;tumbling&lt;/code&gt; открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timespan&lt;/code&gt; времени ( &lt;code&gt;Duration&lt;/code&gt; , необязательно измеряемая в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;scheduler&lt;/code&gt; &lt;/a&gt; ). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable.</target>
        </trans-unit>
        <trans-unit id="4eb801fd5fc446e3c5fb9debba43462e7277a734" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;tumbling&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;tumbling&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">Этот вариант &lt;code&gt;tumbling&lt;/code&gt; принимает в качестве параметра второй Observable. Каждый раз, когда этот второй Observable испускает элемент, &lt;code&gt;tumbling&lt;/code&gt; закрывает текущее окно Observable (если есть) и открывает новое.</target>
        </trans-unit>
        <trans-unit id="5f0586c409a4780239731e2c6e0bc0ef9a26ea29" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;windowOpenings&lt;/code&gt; Observable emit an &lt;code&gt;Opening&lt;/code&gt; object and at the same time calls &lt;code&gt;closingSelector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает окно всякий раз, когда он наблюдает, как &lt;code&gt;windowOpenings&lt;/code&gt; Observable испускает объект &lt;code&gt;Opening&lt;/code&gt; и в то же время вызывает &lt;code&gt;closingSelector&lt;/code&gt; для создания закрывающего Observable, связанного с этим окном. Когда это закрытие Observable испускает объект, &lt;code&gt;window&lt;/code&gt; закрывает это окно. Поскольку закрытие открытых в данный момент окон и открытие новых окон являются действиями, которые регулируются независимыми Observable, этот вариант &lt;code&gt;window&lt;/code&gt; может создавать окна, которые перекрываются (дублирование элементов из исходного Observable) или оставляют пробелы (отбрасывание элементов из исходного Observable ).</target>
        </trans-unit>
        <trans-unit id="91f89b25111f858aab5cff61e3d31bded1300441" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens a window whenever it observes the &lt;code&gt;window_openings&lt;/code&gt; Observable emit an item, and at the same time calls &lt;code&gt;closing_selector&lt;/code&gt; to generate a closing Observable associated with that window. When that closing Observable emits an object, &lt;code&gt;window&lt;/code&gt; closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent Observables, this variant of &lt;code&gt;window&lt;/code&gt; may create windows that overlap (duplicating items from the source Observable) or that leave gaps (discarding items from the source Observable).</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает окно всякий раз, когда он наблюдает, как &lt;code&gt;window_openings&lt;/code&gt; Observable испускает элемент, и в то же время вызывает &lt;code&gt;closing_selector&lt;/code&gt; для создания закрывающего Observable, связанного с этим окном. Когда это закрытие Observable испускает объект, &lt;code&gt;window&lt;/code&gt; закрывает это окно. Поскольку закрытие открытых в данный момент окон и открытие новых окон являются действиями, которые регулируются независимыми Observable, этот вариант &lt;code&gt;window&lt;/code&gt; может создавать окна, которые перекрываются (дублирование элементов из исходного Observable) или оставляют пробелы (отбрасывание элементов из исходного Observable ).</target>
        </trans-unit>
        <trans-unit id="5802a2f459856c9c009c204a82bf912f067a1d03" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately and calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a second Observable. When this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the currently open window, immediately opens a new one, and again calls the &lt;code&gt;closing_selector&lt;/code&gt; function to obtain a fresh Observable. It repeats this process until the source Observable terminates. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает свое первое окно и вызывает функцию &lt;code&gt;closing_selector&lt;/code&gt; для получения второго Observable. Когда этот второй Observable испускает элемент, &lt;code&gt;window&lt;/code&gt; закрывает текущее открытое окно, немедленно открывает новое и снова вызывает функцию &lt;code&gt;closing_selector&lt;/code&gt; для получения нового Observable. Он повторяет этот процесс до тех пор, пока исходный Observable не завершится. Таким образом, этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="60b2240495a83527d8abfb8bc8f1f606ce11082c" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; period of time has passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно сразу, а затем открывает новое окно каждый со &lt;code&gt;timeshift&lt;/code&gt; период времени (измеряется в &lt;code&gt;unit&lt;/code&gt; , и , возможно , на определенный &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Он закрывает в настоящее время открытое окно после &lt;code&gt;timespan&lt;/code&gt; периода времени прошло с момента открытия этого окна. Он также закроет любое открытое в данный момент окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от исходного Observable. В зависимости от того, как вы устанавливаете &lt;code&gt;timespan&lt;/code&gt; и &lt;code&gt;timeshift&lt;/code&gt; во времени, окна, возникающие в результате этой операции, могут перекрываться или иметь пробелы.</target>
        </trans-unit>
        <trans-unit id="98af2e59befb4b606ae4a25fd5855154e10487fc" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the Observable that is returned from &lt;code&gt;closingSelector&lt;/code&gt;. In this way, this variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно. Он закрывает текущее открытое окно и немедленно открывает новое каждый раз, когда наблюдает за объектом, испускаемым Observable, возвращаемым из &lt;code&gt;closingSelector&lt;/code&gt; . Таким образом, этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="4ef7ab0b963fc5b8b8684a5afae1268e9e03a08d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно. Он закрывает текущее открытое окно и немедленно открывает новое всякий раз, когда текущее окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="84222676d0cfade4ca7a8b88acdc55ea8a380067" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;) or whenever the currently open window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timespan&lt;/code&gt; времени (измеряется в &lt;code&gt;unit&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ) или всякий раз, когда открытое в данный момент окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="f715198c62a7d5a5035a9d81b75054eaeb4449c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (measured in &lt;code&gt;unit&lt;/code&gt;, and optionally on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timespan&lt;/code&gt; времени (измеряется в &lt;code&gt;unit&lt;/code&gt; и, возможно, в конкретном &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует излучению наблюдаемого источника.</target>
        </trans-unit>
        <trans-unit id="fe556e801e961820cf9915aae7c855117324579e" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; открывает первое окно. Он открывает новое окно, начиная с каждого элемента &lt;code&gt;skip&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;skip&lt;/code&gt; равно 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно испускает элементы &lt;code&gt;count&lt;/code&gt; или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Если &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; то ведет себя так же, как &lt;code&gt;window(source,&amp;nbsp;count)&lt;/code&gt; ; если &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; это будет выдавать окна, перекрывающиеся по &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; элементы; если &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; это будет генерировать окна, которые &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; элементы с пропуском подсчета из исходного Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="4321575a1449c2aff82db3fafcef6ccd5f15b626" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window&lt;/code&gt; takes a second Observable as a parameter. Whenever this second Observable emits an item, &lt;code&gt;window&lt;/code&gt; closes the current Observable window (if any) and opens a new one.</source>
          <target state="translated">Этот вариант &lt;code&gt;window&lt;/code&gt; принимает в качестве параметра второй Observable. Всякий раз, когда этот второй Observable испускает элемент, &lt;code&gt;window&lt;/code&gt; закрывает текущее окно Observable (если есть) и открывает новое.</target>
        </trans-unit>
        <trans-unit id="bae85c1387e45e3514474e9f22e4f754bb1fb7fa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithCount&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;windowWithCount&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и немедленно открывает новое всякий раз, когда текущее окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;windowWithCount&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует исходному Observable.</target>
        </trans-unit>
        <trans-unit id="b0481e8b340ae9dd68d446d8a287e4351ba18f18" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithCount&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;windowWithCount(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Этот вариант &lt;code&gt;windowWithCount&lt;/code&gt; сразу открывает свое первое окно. Он открывает новое окно, начиная с каждого элемента &lt;code&gt;skip&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;skip&lt;/code&gt; равно 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно испускает элементы &lt;code&gt;count&lt;/code&gt; или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Если &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; то ведет себя так же, как &lt;code&gt;windowWithCount(count)&lt;/code&gt; ; если &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; это будет выдавать окна, перекрывающиеся по &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; элементы; если &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; это будет генерировать окна, которые &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; элементы с пропуском подсчета из исходного Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="79476df52b04afcb45a97f5d9a45a69f194d05b3" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately, and thereafter opens a new window every &lt;code&gt;timeshift&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It closes a currently open window after &lt;code&gt;timespan&lt;/code&gt; milliseconds have passed since that window was opened. It will also close any currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. Depending on how you set &lt;code&gt;timespan&lt;/code&gt; and &lt;code&gt;timeshift&lt;/code&gt; the windows that result from this operation may overlap or may have gaps.</source>
          <target state="translated">Этот вариант &lt;code&gt;windowWithTime&lt;/code&gt; открывает свое первое окно немедленно, а после этого открывает новое окно через каждые миллисекунды &lt;code&gt;timeshift&lt;/code&gt; (необязательно измеряемые в конкретном &lt;a href=&quot;../scheduler&quot;&gt;планировщике&lt;/a&gt; ). Он закрывает в настоящее время открытое окно после того, как &lt;code&gt;timespan&lt;/code&gt; прошло миллисекунд с момента открытия этого окна. Он также закроет любое открытое в данный момент окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от исходного Observable. В зависимости от того, как вы устанавливаете &lt;code&gt;timespan&lt;/code&gt; и &lt;code&gt;timeshift&lt;/code&gt; во времени, окна, возникающие в результате этой операции, могут перекрываться или иметь пробелы.</target>
        </trans-unit>
        <trans-unit id="7f022bb9e774776f440984488040ff5dc6603251" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;windowWithTime&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; period of time (in milliseconds, optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;windowWithTime&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;windowWithTime&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;timespan&lt;/code&gt; времени (в миллисекундах, необязательно измеряемых конкретным &lt;a href=&quot;../scheduler&quot;&gt;планировщиком&lt;/a&gt; ). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;windowWithTime&lt;/code&gt; испускает серию неперекрывающихся окон, совокупное излучение которых однозначно соответствует таковым из источника Observable.</target>
        </trans-unit>
        <trans-unit id="e39142cb9f93a3df83e5acda2657507e2deb12aa" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted &lt;code&gt;count&lt;/code&gt; items. It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_count&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window_with_count&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и немедленно открывает новое всякий раз, когда текущее окно генерирует &lt;code&gt;count&lt;/code&gt; элементы. Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window_with_count&lt;/code&gt; испускает серию неперекрывающихся окон, совокупные выбросы которых взаимно однозначно соответствуют таковым из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="25854b53587cc3c28ca12fd6dd37ae3bdb7e4600" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_count&lt;/code&gt; opens its first window immediately. It opens a new window beginning with every &lt;code&gt;skip&lt;/code&gt; item from the source Observable (so, for example, if &lt;code&gt;skip&lt;/code&gt; is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted &lt;code&gt;count&lt;/code&gt; items or if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. If &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; then this behaves the same as &lt;code&gt;window_with_count(count)&lt;/code&gt;; if &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; this will emit windows that overlap by &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; items; if &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; this will emit windows that drop &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; items from the source Observable between every window.</source>
          <target state="translated">Этот вариант &lt;code&gt;window_with_count&lt;/code&gt; сразу открывает свое первое окно. Он открывает новое окно, начинающееся с каждого элемента &lt;code&gt;skip&lt;/code&gt; из исходного Observable (так, например, если &lt;code&gt;skip&lt;/code&gt; равно 3, то открывается новое окно, начиная с каждого третьего элемента). Он закрывает каждое окно, когда это окно испускает элементы &lt;code&gt;count&lt;/code&gt; или если оно получает уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Если &lt;code&gt;skip&amp;nbsp;=&amp;nbsp;count&lt;/code&gt; то ведет себя так же, как &lt;code&gt;window_with_count(count)&lt;/code&gt; ; если &lt;code&gt;skip&amp;nbsp;&amp;lt;&amp;nbsp;count&lt;/code&gt; это будет выдавать окна, перекрывающиеся по &lt;code&gt;count&amp;nbsp;&amp;minus;&amp;nbsp;skip&lt;/code&gt; элементы; если &lt;code&gt;skip&amp;nbsp;&amp;gt;&amp;nbsp;count&lt;/code&gt; это будет генерировать окна, которые &lt;code&gt;skip&amp;nbsp;&amp;minus;&amp;nbsp;count&lt;/code&gt; элементы с пропуском подсчета из исходного Observable между каждым окном.</target>
        </trans-unit>
        <trans-unit id="cc84f2ccad24fdcfc2f3aff1217a66ac4eb92f9d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window after &lt;code&gt;period&lt;/code&gt; amount of time has passed since it was opened, and opens a new window after &lt;code&gt;skip&lt;/code&gt; amount of time has passed since the previous window was opened (both times are Durations, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; may emit windows that overlap or that have gaps, depending on whether &lt;code&gt;skip&lt;/code&gt; is less than or greater than &lt;code&gt;period&lt;/code&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; сразу открывает свое первое окно. Он закрывает открытое в данный момент окно после того, как &lt;code&gt;period&lt;/code&gt; количество времени , которое прошло с момента его открытия, и открывает новое окно после &lt;code&gt;skip&lt;/code&gt; количества времени прошло с тех пор было открыто предыдущее окно (оба раза в Продолжительности, необязательно вычисляется по заданной координации). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; может генерировать окна, которые перекрываются или имеют промежутки, в зависимости от того, меньше ли &lt;code&gt;skip&lt;/code&gt; или больше &lt;code&gt;period&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da96fc736c7bbd3922e8cf82442d11cbd4e9db04" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;period&lt;/code&gt; of time (a Duration, optionally computed by a given Coordination). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; сразу открывает свое первое окно. Он закрывает текущее открытое окно и открывает другое каждый &lt;code&gt;period&lt;/code&gt; времени (Продолжительность, необязательно вычисляемая заданной Координацией). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; испускает серию неперекрывающихся окон, коллективные выбросы которых взаимно однозначно соответствуют таковым из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="98a31bb4d7889c747d26c5c49a2c39000cc2314d" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;window_with_time&lt;/code&gt; opens its first window immediately. It closes the currently open window and opens another one every &lt;code&gt;timespan&lt;/code&gt; milliseconds (optionally measured on a particular &lt;a href=&quot;../scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt;). It will also close the currently open window if it receives an &lt;code&gt;onCompleted&lt;/code&gt; or &lt;code&gt;onError&lt;/code&gt; notification from the source Observable. This variant of &lt;code&gt;window_with_time&lt;/code&gt; emits a series of non-overlapping windows whose collective emissions correspond one-to-one with those of the source Observable.</source>
          <target state="translated">Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; сразу открывает свое первое окно. Он закрывает открытое окно и открывает еще один раз &lt;code&gt;timespan&lt;/code&gt; миллисекунд (необязательно измеренных на определенный &lt;a href=&quot;../scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; ). Он также закроет текущее открытое окно, если получит уведомление &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от источника Observable. Этот вариант &lt;code&gt;window_with_time&lt;/code&gt; испускает серию неперекрывающихся окон, коллективные выбросы которых взаимно однозначно соответствуют таковым из исходного Observable.</target>
        </trans-unit>
        <trans-unit id="167c2d5b150d69824425b44c8ee4f720fa8f197f" translate="yes" xml:space="preserve">
          <source>This variant operates by default on the &lt;code&gt;computation&lt;/code&gt;&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt;, but you can optionally pass in a Scheduler of your choosing as a third parameter.</source>
          <target state="translated">Этот вариант по умолчанию работает с &lt;a href=&quot;../scheduler&quot;&gt;Планировщиком &lt;/a&gt; &lt;code&gt;computation&lt;/code&gt; , но вы можете дополнительно передать Планировщик по вашему выбору в качестве третьего параметра.</target>
        </trans-unit>
        <trans-unit id="913db6dde43b42bba235483e6967719c230885b6" translate="yes" xml:space="preserve">
          <source>This, too, has a &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;-specific version:</source>
          <target state="translated">У этого тоже есть версия для &lt;a href=&quot;scheduler&quot;&gt;Планировщика&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5319f3b89676bc765e966cae99f6cda9b3be1bc1" translate="yes" xml:space="preserve">
          <source>Throw</source>
          <target state="translated">Throw</target>
        </trans-unit>
        <trans-unit id="e0fdbfae633f2d57c9d587ae320cb30eefd7144d" translate="yes" xml:space="preserve">
          <source>Time shifts the observable sequence by dueTime. The relative time intervals between the values are preserved.</source>
          <target state="translated">Время сдвигает наблюдаемую последовательность на время.Сохраняются относительные промежутки времени между значениями.</target>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="translated">TimeInterval</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="c3caddd6872bae63ffdabf37db746583d89bb38d" translate="yes" xml:space="preserve">
          <source>Timeout will cause a Single to abort with an error notification if it does not emit an item in a specified period of time after it is subscribed to. One version allows you to set this time out by means of a number of specified time units:</source>
          <target state="translated">Таймаут приводит к прерыванию действия сингла с уведомлением об ошибке,если он не выпустит элемент в течение определенного периода времени после его подписки.Одна из версий позволяет установить этот тайм-аут в определенное количество единиц времени:</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="19eabc961735d78f12fc7be906ffcb033853cf85" translate="yes" xml:space="preserve">
          <source>Timestamp</source>
          <target state="translated">Timestamp</target>
        </trans-unit>
        <trans-unit id="ae79ea1e9c6391a9ed83a2e18a031b835feec0c9" translate="yes" xml:space="preserve">
          <source>To</source>
          <target state="translated">To</target>
        </trans-unit>
        <trans-unit id="e81ce27655e65ce085099be185ce85b2137f4e73" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its first emission is emitted, use the &lt;code&gt;first&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">Чтобы отфильтровать Observable, чтобы испускалось только его первое излучение, используйте &lt;code&gt;first&lt;/code&gt; оператор без параметров.</target>
        </trans-unit>
        <trans-unit id="677b35ca927e319047d1628f637adc41423b0fc2" translate="yes" xml:space="preserve">
          <source>To filter an Observable so that only its last emission is emitted, use the &lt;code&gt;last&lt;/code&gt; operator with no parameters.</source>
          <target state="translated">Чтобы отфильтровать Observable, чтобы испускалось только его последнее излучение, используйте оператор &lt;code&gt;last&lt;/code&gt; без параметров.</target>
        </trans-unit>
        <trans-unit id="9261d8ddfbd991cfda76aa23a0cd28a0cd4f32c7" translate="yes" xml:space="preserve">
          <source>To retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;first&lt;/code&gt; method with no parameters.</source>
          <target state="translated">Чтобы получить первое излучение из &lt;code&gt;BlockingObservable&lt;/code&gt; , используйте &lt;code&gt;first&lt;/code&gt; метод без параметров.</target>
        </trans-unit>
        <trans-unit id="df8a5a9c1edace12c77d1f92a0f265b88fc37580" translate="yes" xml:space="preserve">
          <source>To retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt;, use the &lt;code&gt;last&lt;/code&gt; method with no parameters.</source>
          <target state="translated">Чтобы получить последнее излучение из &lt;code&gt;BlockingObservable&lt;/code&gt; , используйте &lt;code&gt;last&lt;/code&gt; метод без параметров.</target>
        </trans-unit>
        <trans-unit id="e965628b0ee331ec6b34dd39cc3f096b74728b00" translate="yes" xml:space="preserve">
          <source>To schedule recursive calls, you can use &lt;code&gt;schedule&lt;/code&gt; and then &lt;code&gt;schedule(this)&lt;/code&gt; on the Worker object:</source>
          <target state="translated">Чтобы запланировать рекурсивные вызовы, вы можете использовать &lt;code&gt;schedule&lt;/code&gt; а затем &lt;code&gt;schedule(this)&lt;/code&gt; для объекта Worker:</target>
        </trans-unit>
        <trans-unit id="1cbffae95212baae30862313515c8962b10bea78" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should invoke its observers&amp;rsquo; &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onCompleted&lt;/code&gt;, and &lt;code&gt;onError&lt;/code&gt; methods, use the &lt;code&gt;observeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Чтобы указать, в каком планировщике Observable должен вызывать методы наблюдателей &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; и &lt;code&gt;onError&lt;/code&gt; , используйте оператор &lt;code&gt;observeOn&lt;/code&gt; , передав ему соответствующий &lt;code&gt;Scheduler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf22e1fc7f54c383e5bc0726b6592466baefc6f" translate="yes" xml:space="preserve">
          <source>To specify on which Scheduler the Observable should operate, use the &lt;code&gt;subscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Чтобы указать, с каким планировщиком должен работать Observable, используйте оператор &lt;code&gt;subscribeOn&lt;/code&gt; , передав ему соответствующий &lt;code&gt;Scheduler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f987265c853852ce9a93e90c296aeb2f943f0a" translate="yes" xml:space="preserve">
          <source>To specify which Scheduler observers will use to unsubscribe from an Observable, use the &lt;code&gt;unsubscribeOn&lt;/code&gt; operator, passing it the appropriate &lt;code&gt;Scheduler&lt;/code&gt;.</source>
          <target state="translated">Чтобы указать, какие наблюдатели планировщика будут использовать для отказа от подписки на Observable, используйте оператор &lt;code&gt;unsubscribeOn&lt;/code&gt; , передав ему соответствующий &lt;code&gt;Scheduler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3adbd9b7c134b35abb9c049ce0a350bfd10d09c0" translate="yes" xml:space="preserve">
          <source>To turn an Observable into a &lt;code&gt;BlockingObservable&lt;/code&gt; so that you can use these methods, you can use either the &lt;code&gt;Observable.toBlocking&lt;/code&gt; or &lt;code&gt;BlockingObservable.from&lt;/code&gt; methods.</source>
          <target state="translated">Чтобы превратить Observable в &lt;code&gt;BlockingObservable&lt;/code&gt; , чтобы вы могли использовать эти методы, вы можете использовать методы &lt;code&gt;Observable.toBlocking&lt;/code&gt; или &lt;code&gt;BlockingObservable.from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07edff8c6ab5d2b6ba73b34c78a1792f548b27e1" translate="yes" xml:space="preserve">
          <source>Transforming</source>
          <target state="translated">Transforming</target>
        </trans-unit>
        <trans-unit id="1dd516e9e95628b37e564d8feed261306c719fd5" translate="yes" xml:space="preserve">
          <source>Transforming Observable Items</source>
          <target state="translated">Преобразование наблюдаемых предметов</target>
        </trans-unit>
        <trans-unit id="8fb4f0478f90c2349e672d48265339bc5e89dd8a" translate="yes" xml:space="preserve">
          <source>Transforming Observables</source>
          <target state="translated">Преобразующие наблюдатели</target>
        </trans-unit>
        <trans-unit id="cceb13cc487fca5dfa5ce538df3f2cb18dc1bd3f" translate="yes" xml:space="preserve">
          <source>Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.</source>
          <target state="translated">Преобразовывает наблюдаемую последовательность из наблюдаемых последовательностей в наблюдаемую,производя значения только из самой последней наблюдаемой последовательности.</target>
        </trans-unit>
        <trans-unit id="29c0474e6e05b94d2f3f5aceab38058a341249ef" translate="yes" xml:space="preserve">
          <source>Under development, but not part of the 1.0 release, is the &lt;code&gt;withLatestFrom&lt;/code&gt; operator. It is similar to &lt;code&gt;combineLatest&lt;/code&gt;, but only emits items when the single source Observable emits an item (not when &lt;em&gt;any&lt;/em&gt; of the Observables that are passed to the operator do, as &lt;code&gt;combineLatest&lt;/code&gt; does).</source>
          <target state="translated">Оператор &lt;code&gt;withLatestFrom&lt;/code&gt; находится в стадии разработки, но не является частью версии 1.0 . Он похож на &lt;code&gt;combineLatest&lt;/code&gt; , но генерирует элементы только тогда, когда объект Observable из единственного источника испускает элемент (а не когда &lt;code&gt;combineLatest&lt;/code&gt; делает &lt;em&gt;любой&lt;/em&gt; из Observable, переданных оператору, как это делаетcommonLatest ).</target>
        </trans-unit>
        <trans-unit id="89deecaaba97e73598ad6fd0691e91f89a3e40ac" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;subscribe&lt;/code&gt;, &lt;code&gt;forEach&lt;/code&gt; does not return an object with which you can cancel the subscription. Nor do you have the option of passing a parameter that has this capability. So you should only use this operator if you definitely need to operate on all of the emissions and notifications from the Observable.</source>
          <target state="translated">В отличие от &lt;code&gt;subscribe&lt;/code&gt; , &lt;code&gt;forEach&lt;/code&gt; не возвращает объект, с помощью которого вы можете отменить подписку. У вас также нет возможности передать параметр, который имеет эту возможность. Таким образом, вы должны использовать этот оператор только в том случае, если вам определенно нужно работать со всеми выбросами и уведомлениями из Observable.</target>
        </trans-unit>
        <trans-unit id="834cc0ee6089e541b395509ba562516bcafa78e2" translate="yes" xml:space="preserve">
          <source>Unsubscribe</source>
          <target state="translated">Unsubscribe</target>
        </trans-unit>
        <trans-unit id="0925f1a577d120b3875b4a1d4b2873a36b77c455" translate="yes" xml:space="preserve">
          <source>Unsubscribing</source>
          <target state="translated">Unsubscribing</target>
        </trans-unit>
        <trans-unit id="2c0b5a028cb5b1c2860888c5875c3ebc0d28e8d6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;size&lt;/code&gt; instead if you want to count &lt;em&gt;all&lt;/em&gt; of the items emitted by the source Observable and emit this count as an Integer, or use &lt;code&gt;longCount&lt;/code&gt; to emit it as a Long.</source>
          <target state="translated">Вместо этого используйте &lt;code&gt;length&lt;/code&gt; или &lt;code&gt;size&lt;/code&gt; , если вы хотите подсчитать &lt;em&gt;все&lt;/em&gt; элементы, &lt;code&gt;longCount&lt;/code&gt; исходным Observable, и выдать этот счет как целое число, или используйте longCount, чтобы выдать его как Long.</target>
        </trans-unit>
        <trans-unit id="ab50a163272616dc7b8c326c9fbd42175ec215ad" translate="yes" xml:space="preserve">
          <source>Use that variable and its new value to do something useful.</source>
          <target state="translated">Используйте эту переменную и ее новое значение,чтобы сделать что-то полезное.</target>
        </trans-unit>
        <trans-unit id="c25de2e83e9fceeee022a34e378748baf14ac201" translate="yes" xml:space="preserve">
          <source>Using</source>
          <target state="translated">Using</target>
        </trans-unit>
        <trans-unit id="09635283d6617f91ae3f074496d5e16cd86942ea" translate="yes" xml:space="preserve">
          <source>Using Schedulers</source>
          <target state="translated">Использование Планировщиков</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="fe106a343476b132e8645607f1656889a1e921e3" translate="yes" xml:space="preserve">
          <source>Utility Operators</source>
          <target state="translated">Операторы связи</target>
        </trans-unit>
        <trans-unit id="fbd4e4db25253ae894d708535b43ea5afe51f6bc" translate="yes" xml:space="preserve">
          <source>Variant of distinct that takes a key selector</source>
          <target state="translated">Вариант отличия,для которого нужен селектор ключей.</target>
        </trans-unit>
        <trans-unit id="7cfbea8206dca5542ac656ab9875b461b78d877f" translate="yes" xml:space="preserve">
          <source>Variant of distinctUntilChanged that takes a key selector and the comparer.</source>
          <target state="translated">Вариант distinctUntilChanged,который принимает селектор ключей и сравнитель.</target>
        </trans-unit>
        <trans-unit id="90783bfae1cb49ec27875b8d80bbd99d15acdda2" translate="yes" xml:space="preserve">
          <source>Variants of this variety of the &lt;code&gt;replay&lt;/code&gt; operator permit you to set a maximum buffer size to limit the number of items &lt;code&gt;replay&lt;/code&gt; will buffer and replay to subsequent observers, and/or to establish a moving time window that defines when emitted items become too old to buffer and replay.</source>
          <target state="translated">Варианты этого разнообразия оператора &lt;code&gt;replay&lt;/code&gt; позволяют вам установить максимальный размер буфера, чтобы ограничить количество элементов, которые &lt;code&gt;replay&lt;/code&gt; будет буферизовано и воспроизведено последующими наблюдателями, и / или установить временное окно перемещения, которое определяет, когда испускаемые элементы становятся слишком старыми для буферизации. и переиграть.</target>
        </trans-unit>
        <trans-unit id="21a0bc424bfc99e307f7ea1edb0fa1c727459368" translate="yes" xml:space="preserve">
          <source>Varieties of Scheduler</source>
          <target state="translated">Сорта планировщика</target>
        </trans-unit>
        <trans-unit id="9b1873d552d24b69c5f119a53f0dc296aa04f44e" translate="yes" xml:space="preserve">
          <source>Varieties of Subject</source>
          <target state="translated">Разновидности предмета</target>
        </trans-unit>
        <trans-unit id="71cd61da34b267e141ea188fbd6c4c966ad1f835" translate="yes" xml:space="preserve">
          <source>When a cold Observable is multicast (when it is converted into a connectable Observable and its &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; method is called), it effectively becomes hot and for the purposes of backpressure and flow-control it should be treated as a hot Observable.</source>
          <target state="translated">Когда холодный Observable является многоадресным (когда он конвертируется в подключаемый Observable и вызывается его метод &lt;a href=&quot;connect&quot;&gt;Connect&lt;/a&gt; ), он фактически становится горячим, и для целей противодавления и управления потоком его следует рассматривать как горячий Observable.</target>
        </trans-unit>
        <trans-unit id="fb6cd998aa458f9efba7d561e3e8223e5f062816" translate="yes" xml:space="preserve">
          <source>When an Observable issues an OnError or OnComplete notification to its observers, this ends the subscription. Observers do not need to issue an Unsubscribe notification to end subscriptions that are ended by the Observable in this way.</source>
          <target state="translated">Когда наблюдатель выдает своим наблюдателям уведомление об ошибке или OnComplete,на этом подписка заканчивается.Наблюдателям не нужно отправлять уведомление об отмене подписки,которая заканчивается подпиской Наблюдателя таким образом.</target>
        </trans-unit>
        <trans-unit id="940033d88560c950b008fe5ed51335ed9f76e48b" translate="yes" xml:space="preserve">
          <source>When an observer issues an Unsubscribe notification to an Observable, the Observable will attempt to stop issuing notifications to the observer. It is not guaranteed, however, that the Observable will issue &lt;em&gt;no&lt;/em&gt; notifications to the observer after an observer issues it an Unsubscribe notification.</source>
          <target state="translated">Когда наблюдатель отправляет уведомление об отказе от подписки для Observable, Observable будет пытаться прекратить отправку уведомлений наблюдателю. Однако не гарантируется, что Observable не отправит &lt;em&gt;никаких&lt;/em&gt; уведомлений наблюдателю после того, как наблюдатель отправит ему уведомление об отказе от подписки.</target>
        </trans-unit>
        <trans-unit id="7279bc1e33b61d9f42b615948eb053e0be2afe08" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to a &lt;code&gt;BehaviorSubject&lt;/code&gt;, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).</source>
          <target state="translated">Когда наблюдатель подписывается на &lt;code&gt;BehaviorSubject&lt;/code&gt; , он начинает с испускания самого последнего элемента, отправленного исходным Observable (или начального значения / значения по умолчанию, если оно еще не было отправлено), а затем продолжает испускать любые другие элементы, испущенные позже источником Observable ( с).</target>
        </trans-unit>
        <trans-unit id="3e29ec19f330a8a47c44f3b9ef38cc21aace1333" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. To dispose of the resource, call the &lt;code&gt;dispose&lt;/code&gt; method of the subscription that was returned from the &lt;code&gt;subscribe&lt;/code&gt; call you used to subscribe an observer to the Observable that you modified with &lt;code&gt;using&lt;/code&gt;.</source>
          <target state="translated">Когда наблюдатель подписывается на Observable, возвращенный из &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; будет использовать фабричную функцию Observable для создания Observable, которую наблюдатель будет наблюдать, в то же время используя функцию фабрики ресурсов для создания любого ресурса, который вы спроектировали для этого. Для того, чтобы избавиться от ресурса, вызовите &lt;code&gt;dispose&lt;/code&gt; метод подписки , который был возвращен из &lt;code&gt;subscribe&lt;/code&gt; позвонить вы использовали для подписки наблюдателя к наблюдаемым , что вы модифицированную с &lt;code&gt;using&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf0d21d9cf8853a081099040075ed5d10c739ad" translate="yes" xml:space="preserve">
          <source>When an observer subscribes to the Observable returned from &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt; will use the Observable factory function to create the Observable the observer will observe, while at the same time using the resource factory function to create whichever resource you have designed it to make. When the observer unsubscribes from the Observable, or when the Observable terminates (normally or with an error), &lt;code&gt;using&lt;/code&gt; will call the third function to dispose of the resource it created.</source>
          <target state="translated">Когда наблюдатель подписывается на Observable, возвращенный из &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; будет использовать фабричную функцию Observable для создания Observable, которую наблюдатель будет наблюдать, в то же время используя функцию фабрики ресурсов для создания любого ресурса, который вы спроектировали для этого. Когда наблюдатель отписывается от Observable или когда Observable завершается (обычно или с ошибкой), &lt;code&gt;using&lt;/code&gt; вызовет третью функцию для удаления созданного ресурса.</target>
        </trans-unit>
        <trans-unit id="ec187d7479d038f4317479a80baaa369b7917df2" translate="yes" xml:space="preserve">
          <source>When does an Observable begin emitting its sequence of items? It depends on the Observable. A &amp;ldquo;hot&amp;rdquo; Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A &amp;ldquo;cold&amp;rdquo; Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</source>
          <target state="translated">Когда Observable начинает излучать свою последовательность элементов? Это зависит от наблюдаемого. &amp;laquo;Горячий&amp;raquo; Observable может начать излучать элементы, как только он будет создан, и поэтому любой наблюдатель, который позже подписывается на этот Observable, может начать наблюдать последовательность где-то посередине. &amp;laquo;Холодный&amp;raquo; Observable, с другой стороны, ожидает, пока наблюдатель не подпишется на него, прежде чем он начнет излучать элементы, и поэтому такой наблюдатель гарантированно видит всю последовательность с самого начала.</target>
        </trans-unit>
        <trans-unit id="d1411f6748866de181ec109dedca11bfcb102f81" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into an &lt;code&gt;IList&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TBufferClosing&lt;/code&gt; object, &lt;code&gt;Buffer&lt;/code&gt; emits the current &lt;code&gt;IList&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;IList&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Когда он подписывается на исходный Observable, &lt;code&gt;Buffer(bufferClosingSelector)&lt;/code&gt; начинает собирать свои выбросы в &lt;code&gt;IList&lt;/code&gt; , а также вызывает &lt;code&gt;bufferClosingSelector&lt;/code&gt; для генерации второго Observable. Когда этот второй Observable испускает объект &lt;code&gt;TBufferClosing&lt;/code&gt; , &lt;code&gt;Buffer&lt;/code&gt; испускает текущий &lt;code&gt;IList&lt;/code&gt; и повторяет этот процесс: &lt;code&gt;bufferClosingSelector&lt;/code&gt; нового &lt;code&gt;IList&lt;/code&gt; и вызов bufferClosingSelector для создания нового Observable для мониторинга. Он будет делать это до тех пор, пока исходный Observable не прекратит работу.</target>
        </trans-unit>
        <trans-unit id="f7a36d0dfbacea5b279df50792127d6faaec9446" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a &lt;code&gt;List&lt;/code&gt;, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an &lt;code&gt;TClosing&lt;/code&gt; object, &lt;code&gt;buffer&lt;/code&gt; emits the current &lt;code&gt;List&lt;/code&gt; and repeats this process: beginning a new &lt;code&gt;List&lt;/code&gt; and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Когда он подписывается на исходный Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; начинает собирать свои выбросы в &lt;code&gt;List&lt;/code&gt; , а также вызывает &lt;code&gt;bufferClosingSelector&lt;/code&gt; для генерации второго Observable. Когда этот второй Observable испускает объект &lt;code&gt;TClosing&lt;/code&gt; , &lt;code&gt;buffer&lt;/code&gt; испускает текущий &lt;code&gt;List&lt;/code&gt; и повторяет этот процесс: начало нового &lt;code&gt;List&lt;/code&gt; и вызов &lt;code&gt;bufferClosingSelector&lt;/code&gt; для создания нового Observable для мониторинга. Он будет делать это до тех пор, пока исходный Observable не прекратит работу.</target>
        </trans-unit>
        <trans-unit id="cc62b05b2653ba0fcc8b376464d1a3e50f84f004" translate="yes" xml:space="preserve">
          <source>When it subscribes to the source Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; begins to collect its emissions into a collection, and it also calls &lt;code&gt;bufferClosingSelector&lt;/code&gt; to generate a second Observable. When this second Observable emits an item, &lt;code&gt;buffer&lt;/code&gt; emits the current collection and repeats this process: beginning a new collection and calling &lt;code&gt;bufferClosingSelector&lt;/code&gt; to create a new Observable to monitor. It will do this until the source Observable terminates.</source>
          <target state="translated">Когда он подписывается на исходный Observable, &lt;code&gt;buffer(bufferClosingSelector)&lt;/code&gt; начинает собирать свои выбросы в коллекцию, а также вызывает &lt;code&gt;bufferClosingSelector&lt;/code&gt; для генерации второго Observable. Когда этот второй Observable испускает элемент, &lt;code&gt;buffer&lt;/code&gt; испускает текущую коллекцию и повторяет этот процесс: начало новой коллекции и вызов &lt;code&gt;bufferClosingSelector&lt;/code&gt; для создания нового Observable для мониторинга. Он будет делать это до тех пор, пока исходный Observable не прекратит работу.</target>
        </trans-unit>
        <trans-unit id="ffdd1094f76c4718e1dd27eb3b69f05cf8376978" translate="yes" xml:space="preserve">
          <source>When you pass a number of source Observables to Amb, it will pass through the emissions and notifications of exactly one of these Observables: the first one that sends a notification to Amb, either by emitting an item or sending an &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification. Amb will ignore and discard the emissions and notifications of all of the other source Observables.</source>
          <target state="translated">Когда вы передаете несколько исходных Observables в Amb, он будет проходить через выбросы и уведомления ровно одного из этих Observable: первый, который отправляет уведомление в Amb, либо отправляя элемент, либо отправляя уведомление &lt;code&gt;onError&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; . Amb будет игнорировать и отбрасывать выбросы и уведомления всех других источников Observables.</target>
        </trans-unit>
        <trans-unit id="ed1d5342173ca839fdf8fe9c0ec24de1dc185152" translate="yes" xml:space="preserve">
          <source>When you work with Observables, it can be more convenient if all of the data you mean to work with can be represented as Observables, rather than as a mixture of Observables and other types. This allows you to use a single set of operators to govern the entire lifespan of the data stream.</source>
          <target state="translated">При работе с &quot;Наблюдателями&quot; может быть удобнее,если все данные,с которыми вы имеете в виду работать,могут быть представлены в виде &quot;Наблюдателей&quot;,а не в виде смеси &quot;Наблюдателей&quot; и других типов.Это позволяет использовать единый набор операторов для управления всем жизненным циклом потока данных.</target>
        </trans-unit>
        <trans-unit id="d5d00501ca857ce32d5ad450528deb3276ed4573" translate="yes" xml:space="preserve">
          <source>Which looks something like this:</source>
          <target state="translated">Который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="7f4512b1c261ef620de45b9d8c88794c65d6da35" translate="yes" xml:space="preserve">
          <source>Why Use Observables?</source>
          <target state="translated">Зачем использовать наблюдатели?</target>
        </trans-unit>
        <trans-unit id="fd9d4ee647871a00407b827b39eb57cb188c8e9b" translate="yes" xml:space="preserve">
          <source>Will call a specified function when the source terminates on complete or error.</source>
          <target state="translated">Будет вызывать указанную функцию при завершении работы источника или при ошибке.</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="9f072c045356efae34e3e1a1f0d76733efc29052" translate="yes" xml:space="preserve">
          <source>Window can reduce a sequence of many items to a sequence of fewer windows-of-items, making them more manageable. You could, for example, emit a window of items from a bursty Observable periodically, at a regular interval of time.</source>
          <target state="translated">Окно может уменьшить последовательность множества элементов до последовательности меньшего количества,делая их более управляемыми.Вы можете,например,периодически,с регулярным интервалом времени,испускать окно элементов из лопнувшего &quot;Наблюдаемого&quot;.</target>
        </trans-unit>
        <trans-unit id="aeb46abd228b75a53256f0b9bb6b7b8aa09463a1" translate="yes" xml:space="preserve">
          <source>Window is similar to &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt;, but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an &lt;code&gt;onCompleted&lt;/code&gt; notification.</source>
          <target state="translated">Window похож на &lt;a href=&quot;buffer&quot;&gt;Buffer&lt;/a&gt; , но вместо того, чтобы испускать пакеты элементов из исходного Observable, он излучает Observable, каждый из которых излучает подмножество элементов из исходного Observable, а затем завершается уведомлением &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3aa6c126ba6145f7e4e8238692031491a9fffcfd" translate="yes" xml:space="preserve">
          <source>With these additions, ReactiveX harmonizes the Iterable and Observable types. The only difference between them is the direction in which the data flows. This is very important because now any operation you can perform on an Iterable, you can also perform on an Observable.</source>
          <target state="translated">Благодаря этим дополнениям,ReactiveX гармонизирует тип &quot;изменяемый&quot; и &quot;наблюдаемый&quot;.Единственное различие между ними-это направление движения данных.Это очень важно,потому что теперь любую операцию,которую вы можете выполнить с типом Iterable,вы также можете выполнить с типом Observable.</target>
        </trans-unit>
        <trans-unit id="cffe58ca95400ce8524a59a6adb8339fe927b434" translate="yes" xml:space="preserve">
          <source>Write the predicate function so that it returns &lt;code&gt;true&lt;/code&gt; for those items you want to pass through the filter to the next observer, and &lt;code&gt;false&lt;/code&gt; for those items you want the filter to block and suppress.</source>
          <target state="translated">Напишите функцию предиката так, чтобы она возвращала &lt;code&gt;true&lt;/code&gt; для тех элементов, которые вы хотите передать через фильтр следующему наблюдателю, и &lt;code&gt;false&lt;/code&gt; для тех элементов, которые вы хотите, чтобы фильтр блокировал и подавлял.</target>
        </trans-unit>
        <trans-unit id="7832bd9cbceae7a6fa44c7235cfa89d50900f7e0" translate="yes" xml:space="preserve">
          <source>You can also average not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the average number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">Можно также усреднить не сами элементы,а результаты функции,применяемой к каждому элементу,как на рисунке выше,которая излучает среднее количество сторон на рисунках,излучаемых источником Наблюдаемый.</target>
        </trans-unit>
        <trans-unit id="76e485df2d9c2ed235e91bb2f1f26240a5ef6a11" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;startWith&lt;/code&gt; an Observable, and it will prepend the emissions from that Observable to those of the source Observable to make its own set of emissions. This is a sort of inverted Concat operation.</source>
          <target state="translated">Вы также можете передать &lt;code&gt;startWith&lt;/code&gt; Observable, и он добавит выбросы из этого Observable к выбросам из исходного Observable, чтобы создать свой собственный набор выбросов. Это своего рода перевернутая операция Concat.</target>
        </trans-unit>
        <trans-unit id="76151784c054704dd1e5d91a90200d161d4d2c61" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;first&lt;/code&gt;, in which case it will produce an Observable that emits only the first item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы также можете передать функцию предиката &lt;code&gt;first&lt;/code&gt; , и в этом случае она создаст Observable, который испускает только первый элемент из исходного Observable, который предикат оценивает как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9032178a5997d03df3b49859b578df71837d196d" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to &lt;code&gt;last&lt;/code&gt;, in which case it will produce an Observable that emits only the last item from the source Observable that the predicate evaluates as &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы также можете передать функцию предиката &lt;code&gt;last&lt;/code&gt; , и в этом случае она создаст Observable, который испускает только последний элемент из исходного Observable, который предикат оценивает как &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6227d5c7e14a1af665c31d2c7a7754c2eeacf80" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;first&lt;/code&gt; method to retrieve the first emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">Вы также можете передать функцию предиката &lt;code&gt;first&lt;/code&gt; методу, чтобы получить первое излучение от &lt;code&gt;BlockingObservable&lt;/code&gt; , которое удовлетворяет предикату.</target>
        </trans-unit>
        <trans-unit id="ff1fc46b917a6d39b2182685ef034a301d994df2" translate="yes" xml:space="preserve">
          <source>You can also pass a predicate function to the &lt;code&gt;last&lt;/code&gt; method to retrieve the last emission from a &lt;code&gt;BlockingObservable&lt;/code&gt; that satisfies the predicate.</source>
          <target state="translated">Вы также можете передать функцию предиката &lt;code&gt;last&lt;/code&gt; методу, чтобы получить последнее излучение от &lt;code&gt;BlockingObservable&lt;/code&gt; , которое удовлетворяет предикату.</target>
        </trans-unit>
        <trans-unit id="682f4fb340f16e8f1e5183cc92ab9b56a799d0eb" translate="yes" xml:space="preserve">
          <source>You can also pass an object to &lt;code&gt;findIndex&lt;/code&gt; as an optional second parameter, and that object will be available to the predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">Вы также можете передать объект в &lt;code&gt;findIndex&lt;/code&gt; как необязательный второй параметр, и этот объект будет доступен для функции предиката как &amp;laquo; &lt;code&gt;this&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f12ce04c127fae5f974652acbf7eb4637f72dc0" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fifth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">Вы также можете передать как необязательный пятый параметр, который &lt;code&gt;generate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; будет использовать для создания и выдачи своей последовательности ( по умолчанию он использует &lt;code&gt;currentThread&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="44fdb21ced818c60966c04e7bd356097a2188b4d" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional fourth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; by default).</source>
          <target state="translated">Вы также можете передать в качестве необязательного четвертого параметра, который &lt;code&gt;generate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; будет использовать для создания и &lt;code&gt;CurrentThreadScheduler&lt;/code&gt; своей последовательности ( по умолчанию он использует CurrentThreadScheduler ).</target>
        </trans-unit>
        <trans-unit id="b7cb5ca8203996c413ed3246420ce370e361571c" translate="yes" xml:space="preserve">
          <source>You can also pass in as an optional sixth parameter a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; that &lt;code&gt;generate&lt;/code&gt; will use to create and emit its sequence (it uses &lt;code&gt;currentThread&lt;/code&gt; by default).</source>
          <target state="translated">Вы также можете передать в качестве необязательного шестого параметра, который &lt;code&gt;generate&lt;/code&gt; &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; будет использовать для создания и передачи своей последовательности ( по умолчанию он использует &lt;code&gt;currentThread&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ace5642a3047a0e0c9b280c2c4933542713f93b0" translate="yes" xml:space="preserve">
          <source>You can also pass it between one and three functions; these will be interpreted as follows:</source>
          <target state="translated">Вы также можете передать ее между одной и тремя функциями;они будут интерпретированы следующим образом:</target>
        </trans-unit>
        <trans-unit id="8434b31a397379ba6a2fc9da703aa8991af9359f" translate="yes" xml:space="preserve">
          <source>You can also specify a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt; for the timer to operate on:</source>
          <target state="translated">Вы также можете указать конкретный &lt;a href=&quot;scheduler&quot;&gt;планировщик&lt;/a&gt; для работы таймера:</target>
        </trans-unit>
        <trans-unit id="e502559fdf8b6103a0732d131d6e69a4a29eb47a" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">Можно также суммировать не сами элементы,а результаты функции,применяемой к каждому элементу,как на рисунке выше,которая излучает суммарное количество сторон на рисунках,излучаемых источником Observable.</target>
        </trans-unit>
        <trans-unit id="7247fcf25ac20fbdb5f7aa37835067a9d4093a34" translate="yes" xml:space="preserve">
          <source>You can also sum not the items themselves but the results of a function applied to each item, as in the illustration above, which emits the sum of the number of sides on the figures emitted by the source Observable.</source>
          <target state="translated">Можно также суммировать не сами элементы,а результаты функции,применяемой к каждому элементу,как на рисунке выше,которая излучает сумму количества сторон на рисунках,излучаемых источником Observable.</target>
        </trans-unit>
        <trans-unit id="3b42768d804313cbd5e467001ecd6fd593441e45" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;a version of &lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; that delays your action on the given Scheduler until a certain timespan has passed. The following example schedules &lt;code&gt;someAction&lt;/code&gt; to be performed on &lt;code&gt;someScheduler&lt;/code&gt; after 500ms have passed according to that Scheduler&amp;rsquo;s clock:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/Scheduler.Worker.html#schedule(rx.functions.Action0,%20long,%20java.util.concurrent.TimeUnit)&quot;&gt;версию &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; которая откладывает ваше действие в данном Планировщике до тех пор, пока не пройдет определенный промежуток времени. В следующем примере расписания &lt;code&gt;someAction&lt;/code&gt; должны быть выполнены на &lt;code&gt;someScheduler&lt;/code&gt; после 500ms прошло в соответствии с этим часы планировщика:</target>
        </trans-unit>
        <trans-unit id="cb20d1dc2545e8aebb8070141dcdcdb2b4514b29" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;connect&lt;/code&gt; method to instruct an Observable to begin emitting items (or, to begin generating items that would be emitted) even before any Subscriber has subscribed to it. In this way you can turn a cold Observable into a hot one.</source>
          <target state="translated">Вы также можете использовать метод &lt;code&gt;connect&lt;/code&gt; , чтобы указать Observable начать излучение элементов (или начать создание элементов, которые будут отправлены) еще до того, как на него подписался какой-либо подписчик. Таким образом вы можете превратить холодный Observable в горячий.</target>
        </trans-unit>
        <trans-unit id="b6ca8c83a0cdbbc6138ee98a1555b795c9b81a2f" translate="yes" xml:space="preserve">
          <source>You can combine the output of multiple Observables so that they act like a single Observable, by using the Merge operator.</source>
          <target state="translated">Вы можете объединить вывод нескольких Наблюдателей так,чтобы они действовали как один Наблюдаемый,с помощью оператора Объединить.</target>
        </trans-unit>
        <trans-unit id="f29f94707670ef1f5bcad38186903f0c22c58ad6" translate="yes" xml:space="preserve">
          <source>You can convert a function into an asynchronous function with the &lt;code&gt;toAsync&lt;/code&gt; method. It takes a function, function parameter, and &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as parameters, and returns an asynchronous function that will be invoked on the specified Scheduler. The last two parameters are optional; if you do not specify a Scheduler, the &lt;code&gt;timeout&lt;/code&gt; Scheduler will be used by default.</source>
          <target state="translated">Вы можете преобразовать функцию в асинхронную с &lt;code&gt;toAsync&lt;/code&gt; метода toAsync . Он принимает функцию, параметр функции и &lt;a href=&quot;../scheduler&quot;&gt;планировщик в&lt;/a&gt; качестве параметров и возвращает асинхронную функцию, которая будет вызываться в указанном планировщике. Последние два параметра необязательны; если вы не укажете планировщик, по умолчанию будет использоваться планировщик &lt;code&gt;timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d333d5f990bc05873a5bb431e9c19e5cfaa18ed6" translate="yes" xml:space="preserve">
          <source>You can create an Observable from scratch by using the Create operator. You pass this operator a function that accepts the observer as its parameter. Write this function so that it behaves as an Observable &amp;mdash; by calling the observer&amp;rsquo;s &lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt; methods appropriately.</source>
          <target state="translated">Вы можете создать Observable с нуля, используя оператор Create. Вы передаете этому оператору функцию, которая принимает наблюдателя в качестве параметра. Напишите эту функцию так, чтобы она вела себя как Observable, вызывая методы наблюдателя &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; и &lt;code&gt;onCompleted&lt;/code&gt; соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="ed592ed573016152e1525943e01beed267c2837e" translate="yes" xml:space="preserve">
          <source>You can either pass &lt;code&gt;merge&lt;/code&gt; a set of Observables as individual parameters, or as a single parameter containing an array of those Observables.</source>
          <target state="translated">Вы можете передать &lt;code&gt;merge&lt;/code&gt; набора Observables как отдельных параметров или как один параметр, содержащий массив этих Observables.</target>
        </trans-unit>
        <trans-unit id="0eb38cbaf446930a95ee352d060e3434e8e6cf5a" translate="yes" xml:space="preserve">
          <source>You can emit only the final</source>
          <target state="translated">Вы можете излучать только финальные</target>
        </trans-unit>
        <trans-unit id="92e0c405c5fc1dad5fbf0ff45e76df0f8d71a1b7" translate="yes" xml:space="preserve">
          <source>You can emit only the first</source>
          <target state="translated">Вы можете излучать только первый</target>
        </trans-unit>
        <trans-unit id="0d9ff619b7e4afa4d6d6cf1ea0bbdbec29b9e953" translate="yes" xml:space="preserve">
          <source>You can ignore the final</source>
          <target state="translated">Вы можете проигнорировать финальный</target>
        </trans-unit>
        <trans-unit id="cdf767f10b63dd6612725c17a1c1242d8039a0f1" translate="yes" xml:space="preserve">
          <source>You can ignore the first</source>
          <target state="translated">Вы можете проигнорировать первый</target>
        </trans-unit>
        <trans-unit id="34e3d5ad83cc701c11204debdb3a9bd100dc16ff" translate="yes" xml:space="preserve">
          <source>You can implement your own Observable operators. This page shows you how.</source>
          <target state="translated">Вы можете внедрить своих собственных Наблюдательных операторов.Эта страница показывает вам,как.</target>
        </trans-unit>
        <trans-unit id="a84dee30bbc65f9e86a29ef569240b6c41e82fe7" translate="yes" xml:space="preserve">
          <source>You can optionally pass &lt;code&gt;scan&lt;/code&gt; a seed value as an additional parameter. &lt;code&gt;scan&lt;/code&gt; will pass this seed value to the accumulator function the first time it is called (for the first emission from the source Observable) in place of the result from the missing prior call to the accumulator.</source>
          <target state="translated">При желании вы можете передать &lt;code&gt;scan&lt;/code&gt; начального значения в качестве дополнительного параметра. &lt;code&gt;scan&lt;/code&gt; передаст это начальное значение функции аккумулятора при первом вызове (для первого выброса из источника Observable) вместо результата отсутствия предыдущего вызова аккумулятора.</target>
        </trans-unit>
        <trans-unit id="c8b0aa91f55f3b994e6c69fe1cbb79f3b9e56c6b" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;Merge&lt;/code&gt; an Array of Observables, an Enumerable of Observables, an Observable of Observables, or two individual Observables.</source>
          <target state="translated">Вы можете передать &lt;code&gt;Merge&lt;/code&gt; Array of Observables, Enumerable of Observables, Observable of Observables или два отдельных Observable.</target>
        </trans-unit>
        <trans-unit id="cb8fd78267fbf9d33e89053521ba7ca1d2df2f4d" translate="yes" xml:space="preserve">
          <source>You can pass in a set of 1&amp;ndash;3 individual functions (&lt;code&gt;onNext&lt;/code&gt;, &lt;code&gt;onError&lt;/code&gt;, and &lt;code&gt;onCompleted&lt;/code&gt;) that &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call along with the similarly-named functions of any of its observers.</source>
          <target state="translated">Вы можете передать набор из 1&amp;ndash;3 отдельных функций ( &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onError&lt;/code&gt; и &lt;code&gt;onCompleted&lt;/code&gt; ), которые &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; будут вызывать вместе с одноименными функциями любого из его наблюдателей.</target>
        </trans-unit>
        <trans-unit id="8e5177ba088da12c6ff9c7a019b4a2d5a68fbc0d" translate="yes" xml:space="preserve">
          <source>You can pass it an Observer, in which case &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;tap&lt;/code&gt; will call that Observer&amp;rsquo;s methods as though that Observer had subscribed to the resulting Observable.</source>
          <target state="translated">Вы можете передать ему Observer, и в этом случае &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;tap&lt;/code&gt; вызовет методы этого Observer, как если бы этот Observer подписался на полученный Observable.</target>
        </trans-unit>
        <trans-unit id="c5c5fca5bde9cdb4b3c8839f8708898dbeeef111" translate="yes" xml:space="preserve">
          <source>You can pass the values you want to prepend to the Observable sequence to &lt;code&gt;startWith&lt;/code&gt; either in a single Iterable or as a series of one to nine function parameters.</source>
          <target state="translated">Вы можете передать значения, которые хотите добавить в последовательность Observable для &lt;code&gt;startWith&lt;/code&gt; , либо в виде одного Iterable, либо в виде серии от одного до девяти параметров функции.</target>
        </trans-unit>
        <trans-unit id="d39d86fe689387af19760dd31d8a62bc7e978897" translate="yes" xml:space="preserve">
          <source>You can register callbacks that ReactiveX will call when certain events take place on an Observable, where those callbacks will be called independently from the normal set of notifications associated with an Observable cascade. There are a variety of operators that various ReactiveX implementations have designed to allow for this.</source>
          <target state="translated">Вы можете зарегистрировать обратные вызовы,которые ReactiveX будет вызывать,когда определенные события происходят на Наблюдаемом,где эти вызовы будут вызываться независимо от обычного набора уведомлений,связанных с Наблюдаемым каскадом.Существует множество операторов,которые в различных реализациях ReactiveX были разработаны для этого.</target>
        </trans-unit>
        <trans-unit id="fb2ee0c05762dad6511a1056f9e75b00a134937e" translate="yes" xml:space="preserve">
          <source>You can think of the Observable class as a &amp;ldquo;push&amp;rdquo; equivalent to &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt;, which is a &amp;ldquo;pull.&amp;rdquo; With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive. By contrast, with an Observable the producer pushes values to the consumer whenever values are available. This approach is more flexible, because values can arrive synchronously or asynchronously.</source>
          <target state="translated">Вы можете думать о классе Observable как о &amp;laquo;push&amp;raquo;, эквивалентном &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; , который является &amp;laquo;pull&amp;raquo;. С помощью Iterable потребитель извлекает значения от производителя и блоков потока до тех пор, пока эти значения не появятся. Напротив, с Observable производитель передает значения потребителю всякий раз, когда значения доступны. Этот подход более гибкий, поскольку значения могут поступать синхронно или асинхронно.</target>
        </trans-unit>
        <trans-unit id="0b829fb03322121b2d33f42667731fc2601ff650" translate="yes" xml:space="preserve">
          <source>You can think of the Observable class as a &amp;ldquo;push&amp;rdquo; equivalent to &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt;, which is a &amp;ldquo;pull.&amp;rdquo; With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive. By contrast, with an Observable the producer pushes values to the consumer whenever values are available. This approach is more flexible, because values can arrive synchronously or asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe2c81139a11756e77093b65fd7ac0096d49a51" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes four parameters:</source>
          <target state="translated">Вы можете использовать оператор &lt;code&gt;generate&lt;/code&gt; для создания простых Observables, которые могут генерировать свои следующие выбросы и могут определять, когда прекратить, на основе значения предыдущего выброса. Основная форма &lt;code&gt;generate&lt;/code&gt; принимает четыре параметра:</target>
        </trans-unit>
        <trans-unit id="e60fef6e6f2b9ffc1eea924da1b6d0b36ff75ea1" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generate&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generate&lt;/code&gt; takes three parameters:</source>
          <target state="translated">Вы можете использовать оператор &lt;code&gt;generate&lt;/code&gt; для создания простых Observables, которые могут генерировать свои следующие выбросы и могут определять, когда прекратить, на основе значения предыдущего выброса. Основная форма &lt;code&gt;generate&lt;/code&gt; принимает три параметра:</target>
        </trans-unit>
        <trans-unit id="4f52de916cbfb602ee5bae4de129d633704400d7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">Вы можете использовать оператор &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; для создания простых Observables, которые могут генерировать свои следующие выбросы и могут определять, когда прекратить, на основе значения предыдущего выброса. Базовая форма &lt;code&gt;generateWithAbsoluteTime&lt;/code&gt; принимает пять параметров:</target>
        </trans-unit>
        <trans-unit id="530a4df6e9fe7ac23c4071905c1156e707670988" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;generateWithRelativeTime&lt;/code&gt; operator to create simple Observables that can generate their next emissions, and can determine when to terminate, based on the value of the previous emission. The basic form of &lt;code&gt;generateWithRelativeTime&lt;/code&gt; takes five parameters:</source>
          <target state="translated">Вы можете использовать оператор &lt;code&gt;generateWithRelativeTime&lt;/code&gt; для создания простых Observables, которые могут генерировать свои следующие выбросы и могут определять, когда прекратить, на основе значения предыдущего выброса. Базовая форма &lt;code&gt;generateWithRelativeTime&lt;/code&gt; принимает пять параметров:</target>
        </trans-unit>
        <trans-unit id="3c8e590f92ae7e377643f3cb85ba8d13993cded0" translate="yes" xml:space="preserve">
          <source>You can use the Buffer operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Вы можете использовать буферный оператор для реализации противодавления (то есть для того,чтобы справиться с наблюдателем,который может производить предметы слишком быстро,чтобы его наблюдатель потреблял их).</target>
        </trans-unit>
        <trans-unit id="6a789db16cf992fb1a0e9a788b8fb01c96ea389d" translate="yes" xml:space="preserve">
          <source>You can use the Window operator to implement backpressure (that is, to cope with an Observable that may produce items too quickly for its observer to consume).</source>
          <target state="translated">Вы можете использовать оператор Window для реализации противодавления (т.е.для того,чтобы справиться с наблюдателем,который может производить предметы слишком быстро,чтобы его наблюдатель потреблял их).</target>
        </trans-unit>
        <trans-unit id="140e328532101e1bca4082da61b61af7b7bddb4a" translate="yes" xml:space="preserve">
          <source>You can use this if you need a function that blocks until the completion of an Observable.</source>
          <target state="translated">Вы можете использовать эту функцию,если вам нужна функция,которая блокирует до завершения &quot;Наблюдаемого&quot;.</target>
        </trans-unit>
        <trans-unit id="ec192e441ea90fa4d7c38e5cdb6a09a79315f557" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;skipUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">Вы также можете при желании передать &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; в качестве второго параметра, и таймер будет работать с этим планировщиком ( &lt;code&gt;skipUntilWithTime&lt;/code&gt; по умолчанию использует планировщик &lt;code&gt;timeout&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a97be5d8b2c0e88945dca3a58187eeff3b450946" translate="yes" xml:space="preserve">
          <source>You may also, optionally, pass in a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; as a second parameter, and the timer will operate on that Scheduler (&lt;code&gt;takeUntilWithTime&lt;/code&gt; uses the &lt;code&gt;timeout&lt;/code&gt; Scheduler by default).</source>
          <target state="translated">Вы также можете, при желании, передать &lt;a href=&quot;../scheduler&quot;&gt;планировщик&lt;/a&gt; в качестве второго параметра, и таймер будет работать с этим планировщиком ( &lt;code&gt;takeUntilWithTime&lt;/code&gt; по умолчанию использует планировщик &lt;code&gt;timeout&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ee11d62e29bb47499c0f66688f7c75ce6d51ea7" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;skipWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">При желании вы можете передать второй параметр &lt;code&gt;skipWhile&lt;/code&gt; . Если это так, этот элемент также будет доступен вашей функции-предикату как &amp;laquo; &lt;code&gt;this&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="023d26f660a72a31c63344590bfe54d9962554f4" translate="yes" xml:space="preserve">
          <source>You may optionally pass a second parameter to &lt;code&gt;takeWhile&lt;/code&gt;. If so, that item will also be available to your predicate function as &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">При желании вы можете передать в &lt;code&gt;takeWhile&lt;/code&gt; второй параметр . Если это так, этот элемент также будет доступен вашей функции-предикату как &amp;laquo; &lt;code&gt;this&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9d40c04f503ade2f5884377cd47e2bbce06c8245" translate="yes" xml:space="preserve">
          <source>You may optionally pass in a default value that &lt;code&gt;elementAt&lt;/code&gt; will emit if the source Observable emits no values:</source>
          <target state="translated">При желании вы можете передать значение по умолчанию, &lt;code&gt;elementAt&lt;/code&gt; будет выдавать elementAt , если исходный Observable не передает никаких значений:</target>
        </trans-unit>
        <trans-unit id="6924eecb0342a630593b97c28a087d0a232f2125" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;catch_exception&lt;/code&gt; a set of back-up Observables either as individual function parameters or as a single array of Observables. If it encounters an &lt;code&gt;onError&lt;/code&gt; notification from the source Observable, it will subscribe to and begin mirroring the first of these back-up Observables. If this back-up Observable itself issues an &lt;code&gt;onError&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will swallow it and switch over to the next back-up Observable. If any of these Observables issues an &lt;code&gt;onCompleted&lt;/code&gt; notification, &lt;code&gt;catch_exception&lt;/code&gt; will pass this along and will stop.</source>
          <target state="translated">Вы можете передать &lt;code&gt;catch_exception&lt;/code&gt; набор резервных Observables либо как отдельные параметры функции, либо как единый массив Observables. Если он встречает уведомление &lt;code&gt;onError&lt;/code&gt; от исходного Observable, он подписывается и начинает зеркальное отображение первого из этих резервных Observable. Если этот резервный Observable сам выдает уведомление &lt;code&gt;onError&lt;/code&gt; , &lt;code&gt;catch_exception&lt;/code&gt; проглотит его и переключится на следующий резервный Observable. Если какой-либо из этих Observables выдает уведомление &lt;code&gt;onCompleted&lt;/code&gt; , &lt;code&gt;catch_exception&lt;/code&gt; передаст его и остановится.</target>
        </trans-unit>
        <trans-unit id="b4b837d7135fd3faba51276890ee36e1feca2008" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;on_error_resume_next&lt;/code&gt; a set of back-up Observables either as individual function parameters, as a single array of Observables, or as a factory function that generates Observables. When the source Observable terminates, whether normally or with an error, &lt;code&gt;on_error_resume_next&lt;/code&gt; will subscribe to and begin mirroring the first of these back-up Observables, and then will recursively continue this concatenation process for each additional Observable until there are no more Observables to mirror, at which time it will pass on the &lt;code&gt;onError&lt;/code&gt; or &lt;code&gt;onCompleted&lt;/code&gt; notification from the last of these Observables.</source>
          <target state="translated">Вы можете передать &lt;code&gt;on_error_resume_next&lt;/code&gt; набор резервных Observables либо как отдельные параметры функции, либо как единый массив Observables, либо как фабричную функцию, которая генерирует Observables. Когда исходный Observable завершается нормально или с ошибкой, &lt;code&gt;on_error_resume_next&lt;/code&gt; подписывается и начинает зеркальное отображение первого из этих резервных Observable, а затем рекурсивно продолжает этот процесс конкатенации для каждого дополнительного Observable до тех пор, пока не останется больше Observable для зеркалирования, в это время он передаст уведомление &lt;code&gt;onError&lt;/code&gt; или &lt;code&gt;onCompleted&lt;/code&gt; от последнего из этих Observables.</target>
        </trans-unit>
        <trans-unit id="4a8142ffd2e1b1f1cf04b936490d70f73561a031" translate="yes" xml:space="preserve">
          <source>You may pass &lt;code&gt;rescue_error&lt;/code&gt; either an Observable or a factory action that generates an Observable.</source>
          <target state="translated">Вы можете передать &lt;code&gt;rescue_error&lt;/code&gt; либо Observable, либо фабричное действие, которое генерирует Observable.</target>
        </trans-unit>
        <trans-unit id="aa1f229e508d7ff97c8b29afa6b4e506ae8fad77" translate="yes" xml:space="preserve">
          <source>You may replace the first function parameter (the predicate that evaluates the exception) with a class object representing a variety of exception. If you do this, &lt;code&gt;catch*&lt;/code&gt; will treat it as equivalent to predicate that performs an &lt;code&gt;instance?&lt;/code&gt; check to see if the exception from the &lt;code&gt;onError&lt;/code&gt; notification is an instance of the class object. In other words:</source>
          <target state="translated">Вы можете заменить первый параметр функции (предикат, оценивающий исключение) на объект класса, представляющий различные исключения. Если вы сделаете это, &lt;code&gt;catch*&lt;/code&gt; будет рассматривать это как эквивалент предикату, который выполняет &lt;code&gt;instance?&lt;/code&gt; проверьте, является ли исключение из уведомления &lt;code&gt;onError&lt;/code&gt; экземпляром объекта класса. Другими словами:</target>
        </trans-unit>
        <trans-unit id="fc3c1c1381737d34e9f462554add7c36b53b82e9" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxGroovy:</source>
          <target state="translated">Вы получаете планировщик из фабричных методов , описанных в &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;в &lt;code&gt;Schedulers&lt;/code&gt; классе&lt;/a&gt; . В следующей таблице показаны разновидности планировщика, которые доступны вам с помощью этих методов в RxGroovy:</target>
        </trans-unit>
        <trans-unit id="bf2ca998afcfe4dc5973a75433cef6ddce12e4f3" translate="yes" xml:space="preserve">
          <source>You obtain a Scheduler from the factory methods described in &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;the &lt;code&gt;Schedulers&lt;/code&gt; class&lt;/a&gt;. The following table shows the varieties of Scheduler that are available to you by means of these methods in RxJava:</source>
          <target state="translated">Вы получаете планировщик из фабричных методов , описанных в &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html&quot;&gt;в &lt;code&gt;Schedulers&lt;/code&gt; классе&lt;/a&gt; . В следующей таблице показаны варианты планировщика, которые доступны вам с помощью этих методов в RxJava:</target>
        </trans-unit>
        <trans-unit id="bd39c643b0349c87b3a6306388851ca9feb51b59" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator three parameters:</source>
          <target state="translated">Вы передаете оператору &lt;code&gt;using&lt;/code&gt; три параметра:</target>
        </trans-unit>
        <trans-unit id="945549399624f25bf835814f45b520f97baa16bc" translate="yes" xml:space="preserve">
          <source>You pass the &lt;code&gt;using&lt;/code&gt; operator two parameters:</source>
          <target state="translated">Вы передаете оператору &lt;code&gt;using&lt;/code&gt; два параметра:</target>
        </trans-unit>
        <trans-unit id="1f339160e649a6f3d3ed789c3776e03cdd682087" translate="yes" xml:space="preserve">
          <source>Your operator should check &lt;a href=&quot;observable#unsubscribing&quot;&gt;its Subscriber's &lt;code&gt;isUnsubscribed( )&lt;/code&gt; status&lt;/a&gt; before it emits any item to (or sends any notification to) the Subscriber. Do not waste time generating items that no Subscriber is interested in seeing.</source>
          <target state="translated">Ваш оператор должен проверить &lt;a href=&quot;observable#unsubscribing&quot;&gt;статус &lt;/a&gt;своего подписчика &lt;code&gt;isUnsubscribed( )&lt;/code&gt; перед тем, как он отправит какой-либо элемент (или отправит какое-либо уведомление) подписчику. Не тратьте время на создание элементов, которые не интересны ни одному подписчику.</target>
        </trans-unit>
        <trans-unit id="2de2635fc818fcac53a104f07189e4bb7e893948" translate="yes" xml:space="preserve">
          <source>Your operator should obey the core tenets of the Observable contract:</source>
          <target state="translated">Ваш оператор должен подчиняться основным принципам договора &quot;Наблюдаемый&quot;:</target>
        </trans-unit>
        <trans-unit id="aec742c8cd57ac5fee0ad76b17e91c6d76608cb3" translate="yes" xml:space="preserve">
          <source>Zip</source>
          <target state="translated">Zip</target>
        </trans-unit>
        <trans-unit id="4647f6838148e96f73bbd9c301485a593c564bca" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator should operate</source>
          <target state="translated">&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; , на котором этот оператор должен работать</target>
        </trans-unit>
        <trans-unit id="b493c478a21d579a93d747f7559defc353fe9a6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which you want to run the Node.js callback</source>
          <target state="translated">&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; , на котором вы хотите запустить функцию обратного вызова Node.js</target>
        </trans-unit>
        <trans-unit id="509f3a9a1a12009f0c68350721b996a8bba83a2d" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;Date&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="094b3142a1b3282411e3d1922e3059844391c692" translate="yes" xml:space="preserve">
          <source>a Single passes this method the Throwable that caused the Single to be unable to emit an item</source>
          <target state="translated">Одиночный передает этот метод бросателю,из-за которого одиночный не может выбросить предмет.</target>
        </trans-unit>
        <trans-unit id="f8c375880bc159b6da0439d622dda5c5e82f83b0" translate="yes" xml:space="preserve">
          <source>a Single passes this method the sole item that the Single emits</source>
          <target state="translated">одиночка передает этот метод единственной единице,которую одиночка испускает.</target>
        </trans-unit>
        <trans-unit id="6e746c23a5816efea8653e2074fbc7f27840c058" translate="yes" xml:space="preserve">
          <source>a factory function that creates a disposable resource</source>
          <target state="translated">фабричная функция,которая создает одноразовый ресурс</target>
        </trans-unit>
        <trans-unit id="f9ef51f84c35f84a28720761526b6be0ec85aebe" translate="yes" xml:space="preserve">
          <source>a factory function that creates an Observable</source>
          <target state="translated">фабричная функция,которая создает наблюдаемый</target>
        </trans-unit>
        <trans-unit id="47dfc20e0f1b41b426e0e33d0cd2a5b9688c4e57" translate="yes" xml:space="preserve">
          <source>a function that accepts an item emitted by the source Observable and returns a</source>
          <target state="translated">функция,которая принимает элемент,излучаемый источником Наблюдаемый и возвращает a</target>
        </trans-unit>
        <trans-unit id="2ddd07bf05e2e9d39c05b862f2b8e252591ef85b" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an Observable that emits items from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;groupJoin&lt;/code&gt;</source>
          <target state="translated">функция, которая принимает элемент из первого Observable и Observable, который испускает элементы из второго Observable и возвращает элемент, который должен быть испущен Observable, возвращенным из &lt;code&gt;groupJoin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76f8801e6c5c9954ce73620d55acd7bf849c2a1a" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the first Observable and an item from the second Observable and returns an item to be emitted by the Observable returned from &lt;code&gt;join&lt;/code&gt;</source>
          <target state="translated">функция, которая принимает элемент из первого Observable и элемент из второго Observable и возвращает элемент, который должен быть испущен Observable, возвращенным из &lt;code&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0aff1921b29e2531a19b409ba53bcaa299073931" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the second Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the first Observable</source>
          <target state="translated">функция,которая принимает элемент из второго Наблюдаемого и возвращает Наблюдателя,срок жизни которого определяет продолжительность жизни,в течение которой этот элемент будет сочетаться с элементами из первого Наблюдаемого</target>
        </trans-unit>
        <trans-unit id="2537afc91f615219e473b116dd8fce6e8c1a6ff9" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an Observable whose lifespan governs the duration during which that item will combine with items from the second Observable</source>
          <target state="translated">Функция,которая принимает предмет из источника Наблюдаемый и возвращает Наблюдаемый,срок службы которого определяет продолжительность,в течение которой этот предмет будет сочетаться с предметами из второго Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="0ea0e4f321f3690c79a053a22c1c77290a7e603e" translate="yes" xml:space="preserve">
          <source>a function that accepts an item from the source Observable and returns an item to be emitted in its place by one of the resulting Observables</source>
          <target state="translated">функция,которая принимает элемент из источника Наблюдаемый и возвращает элемент,который должен быть передан на его место одним из получаемых Наблюдателей</target>
        </trans-unit>
        <trans-unit id="2e39dfb6e89ec27b2799ac841058cbe1c8622ded" translate="yes" xml:space="preserve">
          <source>a function that accepts two items (or two keys) and compares them for distinctness, returning &lt;code&gt;false&lt;/code&gt; if they are distinct (an equality function is the default if you do not supply your own function here)</source>
          <target state="translated">функция, которая принимает два элемента (или два ключа) и сравнивает их на предмет различимости, возвращая &lt;code&gt;false&lt;/code&gt; , если они различны (функция равенства используется по умолчанию, если вы не указываете здесь свою собственную функцию)</target>
        </trans-unit>
        <trans-unit id="40c676b1b9cb886b7d849f24b8f8562dc0c7450f" translate="yes" xml:space="preserve">
          <source>a function that disposes of the resource</source>
          <target state="translated">функция,распоряжающаяся ресурсом</target>
        </trans-unit>
        <trans-unit id="f00fad8955c402d31ecc865bacbf29bf7f7b2e49" translate="yes" xml:space="preserve">
          <source>a function that returns the key that determines which Observable to emit</source>
          <target state="translated">функция,которая возвращает ключ,определяющий,какой &quot;Наблюдаемый&quot; излучает</target>
        </trans-unit>
        <trans-unit id="bf1f078c34ead7a76ff3206e489a656d7ecb0e61" translate="yes" xml:space="preserve">
          <source>a function that returns the mutable data structure</source>
          <target state="translated">функция,возвращающая мутирующую структуру данных</target>
        </trans-unit>
        <trans-unit id="d3d2297cca8b40c3332e52315a233f4690aa3594" translate="yes" xml:space="preserve">
          <source>a function that, when given the data structure and an item emitted by the source Observable, modifies the data structure appropriately</source>
          <target state="translated">функция,которая при задании структуры данных и элемента,излучаемого источником Наблюдаемый,соответствующим образом изменяет структуру данных</target>
        </trans-unit>
        <trans-unit id="fdcfa4810783cdbb46bc98763bc28d19271f7ac2" translate="yes" xml:space="preserve">
          <source>a function to generate the next item to test and emit based on the value of the previous item</source>
          <target state="translated">функция для генерации следующего элемента для проверки и излучения на основе значения предыдущего элемента</target>
        </trans-unit>
        <trans-unit id="428d1cdfe3341cf4456bd0ff8a1f09d9b747a991" translate="yes" xml:space="preserve">
          <source>a function to indicate at what time (expressed as a &lt;code&gt;Date&lt;/code&gt;) the generator should emit the the new item</source>
          <target state="translated">функция, указывающая, в какое время (выраженное как &lt;code&gt;Date&lt;/code&gt; ) генератор должен выдать новый элемент</target>
        </trans-unit>
        <trans-unit id="b9b02313f83c7a5de6f60fa4dae062626ee99890" translate="yes" xml:space="preserve">
          <source>a function to indicate how long, in milliseconds, the generator should wait after the emission of the previous item before emitting this item</source>
          <target state="translated">функция,указывающая,как долго,в миллисекундах,генератор должен ждать после излучения предыдущего элемента,прежде чем излучать этот элемент.</target>
        </trans-unit>
        <trans-unit id="9c40d35aa81016b60c5e8f8e5f786a2e228ffcd8" translate="yes" xml:space="preserve">
          <source>a function to test an item to determine whether to emit it (&lt;code&gt;true&lt;/code&gt;) or terminate the Observable (&lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">функция для проверки элемента, чтобы определить, испустить ли его ( &lt;code&gt;true&lt;/code&gt; ) или завершить Observable ( &lt;code&gt;false&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="95323fca49a83a1abac26e79f91ed7eb8a5653bf" translate="yes" xml:space="preserve">
          <source>a function to transform items before emitting them</source>
          <target state="translated">функция преобразования элементов перед их излучением</target>
        </trans-unit>
        <trans-unit id="0456183e34019ad3a80b7ade1f97bbdb2982c441" translate="yes" xml:space="preserve">
          <source>a function used to compare two keys for identity (that is, whether items with two keys should be emitted on the same Observable)</source>
          <target state="translated">функция,используемая для сравнения двух ключей для идентификации (т.е.должны ли предметы с двумя ключами выдаваться на одном и том же Наблюдаемом)</target>
        </trans-unit>
        <trans-unit id="c37f5d4c24ebe19faceff2fa752f48ced17e4bc7" translate="yes" xml:space="preserve">
          <source>a number</source>
          <target state="translated">число</target>
        </trans-unit>
        <trans-unit id="046c38b0c1d8b4e28f9b3036802beb70f5bc27ff" translate="yes" xml:space="preserve">
          <source>a parameter to give to the callback function</source>
          <target state="translated">параметр для передачи функции обратного вызова</target>
        </trans-unit>
        <trans-unit id="1cde721814013cf593ec03ffb7b7d2acbb857196" translate="yes" xml:space="preserve">
          <source>a parameter to pass to the callback function</source>
          <target state="translated">параметр для передачи в функцию обратного вызова</target>
        </trans-unit>
        <trans-unit id="b8f7f3c1eda366392609e11b5761750c26f9eb1b" translate="yes" xml:space="preserve">
          <source>a second argument to pass into the transforming function as additional context information</source>
          <target state="translated">второй аргумент для передачи в преобразующую функцию в качестве дополнительной контекстной информации</target>
        </trans-unit>
        <trans-unit id="64fcf1af137d36f34598932f6ace3ce897fda0d5" translate="yes" xml:space="preserve">
          <source>a tranforming function that takes the return value of the callback function as input and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">преобразующая функция,которая принимает на вход возвращаемое значение функции обратного вызова и возвращает элемент,излучаемый результирующим Наблюдателем</target>
        </trans-unit>
        <trans-unit id="d12ef7e3cdfedafdb8947dc6e3897484b12200cc" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item emitted by the source Observable as its parameter and returns an item to be emitted by the resulting Observable</source>
          <target state="translated">преобразующая функция,которая принимает элемент,излучаемый источником Observable,в качестве своего параметра и возвращает элемент,излучаемый результирующим Observable.</target>
        </trans-unit>
        <trans-unit id="6e7e113e681e606f5e008dfe9116078cb537c060" translate="yes" xml:space="preserve">
          <source>a transforming function that takes an item from the array or iterable as input and produces an item to be emitted by the resulting Observable as output</source>
          <target state="translated">преобразующая функция,которая принимает элемент из массива или итерабельного в качестве входного и производит элемент,который будет излучаться результирующей функцией Observable в качестве выходного значения</target>
        </trans-unit>
        <trans-unit id="ecbebad873608a573c6f88c7adfa7968ec975515" translate="yes" xml:space="preserve">
          <source>a variety of operators that enforce particular flow-control policies</source>
          <target state="translated">различные операторы,которые обеспечивают соблюдение определенных политик по управлению потоками</target>
        </trans-unit>
        <trans-unit id="75896d78bed7aa685002a0be20721209bce14725" translate="yes" xml:space="preserve">
          <source>additional items have been emitted by that Observable.</source>
          <target state="translated">Дополнительные предметы были выброшены этим Наблюдателем.</target>
        </trans-unit>
        <trans-unit id="f5d953a3114e36aab0e1e2506cada2331d1550b2" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock forward by a particular amount of time</source>
          <target state="translated">переводит часы Планировщика вперед на определенное время</target>
        </trans-unit>
        <trans-unit id="8b089b72e7a4725ef2e2624e5e93a0590a197509" translate="yes" xml:space="preserve">
          <source>advances the Scheduler&amp;rsquo;s clock to a particular point in time</source>
          <target state="translated">переводит часы Планировщика на определенный момент времени</target>
        </trans-unit>
        <trans-unit id="6f6ddadc45f67e2f1110937a7473b4d38d8782fb" translate="yes" xml:space="preserve">
          <source>after a specified delay</source>
          <target state="translated">с указанной задержкой</target>
        </trans-unit>
        <trans-unit id="25e01a2edb261f8e4f68662596bb4757a3c6699f" translate="yes" xml:space="preserve">
          <source>allows you create a custom operator</source>
          <target state="translated">позволяет создать индивидуального оператора</target>
        </trans-unit>
        <trans-unit id="eb1c47b9488976a153de840013f1e8555fdd7b89" translate="yes" xml:space="preserve">
          <source>an object that associates those keys with particular Observables</source>
          <target state="translated">объект,который ассоциирует эти ключи с определенными наблюдателями.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="3ab0c50ba1f5993a1e526134cd25d0da452d1ff0" translate="yes" xml:space="preserve">
          <source>and emit a number indicating how many items were in the sequence</source>
          <target state="translated">и выдать число,указывающее,сколько единиц в последовательности.</target>
        </trans-unit>
        <trans-unit id="4a96b1b08e9ed381d5574e8e1f21549df303d3ad" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if &lt;em&gt;all&lt;/em&gt; of the items pass some test</source>
          <target state="translated">и испустить одно логическое значение, указывающее, &lt;em&gt;все&lt;/em&gt; ли элементы проходят некоторый тест</target>
        </trans-unit>
        <trans-unit id="e69d22261ea99b45a17a8dc23bdd2a7509965bc6" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;any&lt;/em&gt; item (that passes some test)</source>
          <target state="translated">и испустить одно логическое значение, указывающее, испускал ли Observable &lt;em&gt;какой-либо&lt;/em&gt; элемент (который проходит некоторый тест)</target>
        </trans-unit>
        <trans-unit id="7baf48599e88aaeeb73e266a7efd0e148448e0f5" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the Observable emitted &lt;em&gt;no&lt;/em&gt; items</source>
          <target state="translated">и испустить одно логическое значение, указывающее, не испускал ли Observable &lt;em&gt;никаких&lt;/em&gt; элементов</target>
        </trans-unit>
        <trans-unit id="0c0325d25cb3794f2e6a745d0c90cae1126fc1cb" translate="yes" xml:space="preserve">
          <source>and emit a single boolean indicating if the sequence is identical to one emitted by a second Observable</source>
          <target state="translated">и испускает один логический сигнал,указывающий,идентична ли последовательность,испускаемая вторым Наблюдателем.</target>
        </trans-unit>
        <trans-unit id="0794b1050db960b48a9d04824c91e65f5e00ebf7" translate="yes" xml:space="preserve">
          <source>and emit the average of all of their values</source>
          <target state="translated">и излучают среднее значение всех их значений</target>
        </trans-unit>
        <trans-unit id="97beebc6577539889da30f39e00f6502491523bf" translate="yes" xml:space="preserve">
          <source>and emit the item with the maximum value</source>
          <target state="translated">и выдать изделие с максимальным значением</target>
        </trans-unit>
        <trans-unit id="00590436e185ea9db814cea817c3ef29f52817d6" translate="yes" xml:space="preserve">
          <source>and emit the item with the minimum value</source>
          <target state="translated">и выпустить изделие с минимальным значением</target>
        </trans-unit>
        <trans-unit id="34f796b1a15e3b1cfec4260445200a01d2745463" translate="yes" xml:space="preserve">
          <source>and emit the sum of all of their values</source>
          <target state="translated">и выдать сумму всех их ценностей</target>
        </trans-unit>
        <trans-unit id="8607e552f2d0c2b275785ec61776399b991f6fd1" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables in whatever order they are received</source>
          <target state="translated">и выбрасывать все предметы из всех Наблюдателей в любом порядке их поступления.</target>
        </trans-unit>
        <trans-unit id="7e5c7dcffd0e52405e8fd447dc388fee40056ad8" translate="yes" xml:space="preserve">
          <source>and emitting all of the items from all of the Observables, one Observable at a time</source>
          <target state="translated">и выбрасывая все предметы из всех Наблюдателей,по одному Наблюдателю за раз.</target>
        </trans-unit>
        <trans-unit id="9b0c7ceb92e8fe98a2db7b7ee8fcfb24c07771ee" translate="yes" xml:space="preserve">
          <source>and emitting the items from only the most-recently emitted of those Observables</source>
          <target state="translated">и выбрасывая предметы только из самых последних из этих Наблюдателей.</target>
        </trans-unit>
        <trans-unit id="378c88957dfb0a305750c2b80287c13f20833b32" translate="yes" xml:space="preserve">
          <source>and then I want to ask it to start</source>
          <target state="translated">а потом я хочу попросить его начать</target>
        </trans-unit>
        <trans-unit id="8be41e709b3249dd05643a847e4cab1c97aa1205" translate="yes" xml:space="preserve">
          <source>and then emits the complete sequence, even to those who subscribe after the sequence has begun</source>
          <target state="translated">а затем излучает полную последовательность,даже тем,кто подписывается после того,как последовательность началась.</target>
        </trans-unit>
        <trans-unit id="7efd76778a88e660bb12fa24328e717c436d5b4b" translate="yes" xml:space="preserve">
          <source>and then only emits the last item in its sequence</source>
          <target state="translated">а затем испускает только последний элемент в своей последовательности.</target>
        </trans-unit>
        <trans-unit id="80e361fe647eb090f7f3e23fe1e78f7661315c15" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</source>
          <target state="translated">применять функцию к каждому элементу,испускаемому наблюдаемым,последовательно,и испускать каждое последующее значение</target>
        </trans-unit>
        <trans-unit id="2aae0a97beec75e49732de3acf9a51a6e3f35b06" translate="yes" xml:space="preserve">
          <source>apply a function to each item emitted by an Observable, sequentially, and emit the final value</source>
          <target state="translated">применять функцию к каждому элементу,испускаемому наблюдаемым,последовательно,и испускать конечное значение</target>
        </trans-unit>
        <trans-unit id="7d752f2c5e9504352a8b5051da82d8c592e4d092" translate="yes" xml:space="preserve">
          <source>asynchronous</source>
          <target state="translated">asynchronous</target>
        </trans-unit>
        <trans-unit id="82d5635631c9b07663bb7d672111045b85db490e" translate="yes" xml:space="preserve">
          <source>at particular intervals of time</source>
          <target state="translated">в определённые промежутки времени</target>
        </trans-unit>
        <trans-unit id="36a05b8e8ae34dcb7426101165fea84e7c64e32e" translate="yes" xml:space="preserve">
          <source>attach a timestamp to each item emitted by an Observable indicating when it was emitted</source>
          <target state="translated">прикрепить временную метку к каждому изделию,высвобожденному Наблюдателем,указывая,когда оно было высвобождено.</target>
        </trans-unit>
        <trans-unit id="a2093fde1186db0585ea62a388b9cb2943526699" translate="yes" xml:space="preserve">
          <source>based on all of the items that preceded them</source>
          <target state="translated">на основе всех пунктов,которые им предшествовали.</target>
        </trans-unit>
        <trans-unit id="09fecbcf0276d272df9099e0daaaa3b7773fd804" translate="yes" xml:space="preserve">
          <source>begins generating items to emit immediately when it is created. Subscribers typically begin observing the sequence of items emitted by a hot Observable from somewhere in the middle of the sequence, beginning with the first item emitted by the Observable subsequent to the establishment of the subscription. Such an Observable emits items at its own pace, and it is up to its observers to keep up. Examples of items emitted by a hot Observable might include mouse &amp;amp; keyboard events, system events, or stock prices.</source>
          <target state="translated">начинает генерировать элементы для отправки сразу после создания. Подписчики обычно начинают наблюдать за последовательностью элементов, отправленных горячим Observable, откуда-то в середине последовательности, начиная с первого элемента, отправляемого Observable после установления подписки. Такой Observable испускает предметы в своем собственном темпе, и его наблюдатели должны следить за ним. Примеры элементов, генерируемых горячим Observable, могут включать события мыши и клавиатуры, системные события или цены на акции.</target>
        </trans-unit>
        <trans-unit id="91742200ee81bc6aadca216cd1711c81b8196c3e" translate="yes" xml:space="preserve">
          <source>below)</source>
          <target state="translated">below)</target>
        </trans-unit>
        <trans-unit id="f59062128d67887221611ec80b08fdc406bd1475" translate="yes" xml:space="preserve">
          <source>but I want it to go away once all of its subscribers unsubscribe</source>
          <target state="translated">но я хочу,чтобы она исчезла,как только все ее подписчики откажутся от подписки.</target>
        </trans-unit>
        <trans-unit id="7d79de2f1adf708e14a324d60741a611cc35ef65" translate="yes" xml:space="preserve">
          <source>by applying an aggregation function to each item in turn and emitting the result</source>
          <target state="translated">путем применения функции агрегирования к каждому элементу по очереди и выдачи результата</target>
        </trans-unit>
        <trans-unit id="2aece502258035de89ea708eb33596dfd03c34cb" translate="yes" xml:space="preserve">
          <source>by attaching a timestamp to them</source>
          <target state="translated">прикрепив к ним временную метку</target>
        </trans-unit>
        <trans-unit id="3e27bc3f4d066d8b7c01b9fe0d22804704709389" translate="yes" xml:space="preserve">
          <source>by attempting to resubscribe to the upstream Observable</source>
          <target state="translated">при попытке переподписаться на &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="6adf44d0eb0023d4304115f3180e433f647a2efc" translate="yes" xml:space="preserve">
          <source>by combining the items from two or more Observables sequentially to come up with new items to emit</source>
          <target state="translated">объединяя элементы из двух или более &quot;Наблюдателей&quot; последовательно,чтобы придумать новые элементы для излучения.</target>
        </trans-unit>
        <trans-unit id="bcd0218297b656000c1ac71599017790bc85c365" translate="yes" xml:space="preserve">
          <source>by delaying my subscription to it for some time after it begins emitting items</source>
          <target state="translated">откладывая мою подписку на него на некоторое время после того,как он начнет испускать элементы.</target>
        </trans-unit>
        <trans-unit id="f13876a8f487096fa7ed90f9de5112faf9f39485" translate="yes" xml:space="preserve">
          <source>by emitting all of the items emitted by corresponding Observables</source>
          <target state="translated">испуская все элементы,испускаемые соответствующими наблюдателями.</target>
        </trans-unit>
        <trans-unit id="1dd53da47c6b8eff8a39ffadc7d377be35e20425" translate="yes" xml:space="preserve">
          <source>by filtering out those that do not match some predicate</source>
          <target state="translated">отфильтровывая те,которые не совпадают с какими-либо предикатами.</target>
        </trans-unit>
        <trans-unit id="d47503a1e21d807bffb852a194a725c2958558e3" translate="yes" xml:space="preserve">
          <source>by means of &lt;code&gt;Pattern&lt;/code&gt; and &lt;code&gt;Plan&lt;/code&gt; intermediaries</source>
          <target state="translated">через посредников &lt;code&gt;Pattern&lt;/code&gt; и &lt;code&gt;Plan&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63d6688bc3922632efdebc442218b0ecad0527ea" translate="yes" xml:space="preserve">
          <source>by only emitting items that are not followed by other items within some duration</source>
          <target state="translated">только излучая предметы,за которыми в течение некоторого времени не следуют другие предметы.</target>
        </trans-unit>
        <trans-unit id="988bc528771482a14d8f05b39fe9e424a0118901" translate="yes" xml:space="preserve">
          <source>by retrieving it from a Future</source>
          <target state="translated">извлекая его из будущего</target>
        </trans-unit>
        <trans-unit id="869bf59133792be52e036bb3d7b589950917bf15" translate="yes" xml:space="preserve">
          <source>by sampling the Observable periodically</source>
          <target state="translated">путем периодической выборки Наблюдаемого</target>
        </trans-unit>
        <trans-unit id="90a1749d56333543d881676b625ec860961f55ef" translate="yes" xml:space="preserve">
          <source>by suppressing items that are duplicates of already-emitted items</source>
          <target state="translated">путем подавления элементов,которые являются дубликатами уже выпущенных элементов.</target>
        </trans-unit>
        <trans-unit id="7af15572c56ca7d62d1cfa5ddac5af0712b1c125" translate="yes" xml:space="preserve">
          <source>by the Observable to the observer</source>
          <target state="translated">наблюдателем</target>
        </trans-unit>
        <trans-unit id="dd78b511d8fcb0430492c6c02e9aa1973bb65655" translate="yes" xml:space="preserve">
          <source>by wrapping them in &lt;code&gt;Notification&lt;/code&gt; objects</source>
          <target state="translated">заключая их в объекты &lt;code&gt;Notification&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19068047789a81691f13158a43b02076c65041df" translate="yes" xml:space="preserve">
          <source>calculates the average of numbers emitted by an Observable and emits this average</source>
          <target state="translated">вычисляет среднее число чисел,испускаемых наблюдателем,и испускает это среднее значение.</target>
        </trans-unit>
        <trans-unit id="87e72635cfd6cb3993ed2975332903fc2b28069d" translate="yes" xml:space="preserve">
          <source>calculates the sum of numbers emitted by an Observable and emits this sum</source>
          <target state="translated">вычисляет сумму чисел,испускаемых наблюдателем,и испускает эту сумму.</target>
        </trans-unit>
        <trans-unit id="ef83875cbdebb3066a5df980de002d8b7230c128" translate="yes" xml:space="preserve">
          <source>cold Observable</source>
          <target state="translated">Холодно Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="6710d8c63778707e72df57fc2aba9fa135efbe94" translate="yes" xml:space="preserve">
          <source>combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable</source>
          <target state="translated">объединять элементы,испускаемые двумя наблюдателями,когда элемент из одного наблюдателя испускается в течение временного окна,определенного в соответствии с элементом,испускаемым другим наблюдателем.</target>
        </trans-unit>
        <trans-unit id="d8a85be857c4b8d572be8a8cd2e6f9d20bae0516" translate="yes" xml:space="preserve">
          <source>combine multiple Observables into one by merging their emissions</source>
          <target state="translated">объединить несколько Наблюдателей в один,объединив их выбросы</target>
        </trans-unit>
        <trans-unit id="d70c4db347b466165449fd0675674217d45894d7" translate="yes" xml:space="preserve">
          <source>combine sets of items emitted by two or more Observables by means of Pattern and Plan intermediaries</source>
          <target state="translated">объединить наборы предметов,испускаемых двумя или более Наблюдателями с помощью посредников &quot;Pattern&quot; и &quot;Plan&quot;.</target>
        </trans-unit>
        <trans-unit id="aa40fbaa4ea0a034c51bceacc20bdceaa6365554" translate="yes" xml:space="preserve">
          <source>combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function</source>
          <target state="translated">объединить излучения нескольких Наблюдателей вместе с помощью определенной функции и испускать отдельные элементы для каждой комбинации на основе результатов этой функции</target>
        </trans-unit>
        <trans-unit id="0737c22d3bfae812339732d14d8c7dbd6dc4e09c" translate="yes" xml:space="preserve">
          <source>complete</source>
          <target state="translated">complete</target>
        </trans-unit>
        <trans-unit id="537bac49fb381519e179be6b0008c6ba0263e54a" translate="yes" xml:space="preserve">
          <source>compose</source>
          <target state="translated">compose</target>
        </trans-unit>
        <trans-unit id="49ba358c3272c2db40fc6ab2c103669678628b68" translate="yes" xml:space="preserve">
          <source>concat</source>
          <target state="translated">concat</target>
        </trans-unit>
        <trans-unit id="d90ad13cbc688a267267cf995a732fd5a221778e" translate="yes" xml:space="preserve">
          <source>concat and concatWith</source>
          <target state="translated">конкат и конкатС</target>
        </trans-unit>
        <trans-unit id="5a528204c79768fa06e40aa1f390858060705983" translate="yes" xml:space="preserve">
          <source>concatWith</source>
          <target state="translated">concatWith</target>
        </trans-unit>
        <trans-unit id="4a87f56a7be04873edc5dab9dfcbea43167dcda6" translate="yes" xml:space="preserve">
          <source>concatenates the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">Конкатенует элементы,выделяемые несколькими Одиночками в качестве наблюдаемых выбросов.</target>
        </trans-unit>
        <trans-unit id="920b046593a982bd8c911c015fbe228693c49096" translate="yes" xml:space="preserve">
          <source>connectable Observable</source>
          <target state="translated">подключаемый Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="e07fc362e1775ed78d4cb3db16f025093e05f2f8" translate="yes" xml:space="preserve">
          <source>containing only the last items emitted</source>
          <target state="translated">содержащий только последние испущенные элементы</target>
        </trans-unit>
        <trans-unit id="855a0fc1d9acb3d7fad5d79757204568eb80f0d4" translate="yes" xml:space="preserve">
          <source>convert an Observable into another object or data structure</source>
          <target state="translated">преобразовать &quot;Наблюдаемый&quot; в другой объект или структуру данных.</target>
        </trans-unit>
        <trans-unit id="d8272ed0eb1bc3fc9a572fe8071362ed69127653" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables</source>
          <target state="translated">Преобразовать Наблюдатель,который испускает Наблюдатели,в единственный Наблюдатель,который испускает элементы,испускаемые самыми свежими из этих Наблюдателей.</target>
        </trans-unit>
        <trans-unit id="e912523a996828d3bf0fbb542911199b9dcd4945" translate="yes" xml:space="preserve">
          <source>convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions</source>
          <target state="translated">преобразовать Наблюдаемое,которое испускает элементы,в Наблюдаемое,которое испускает показания о количестве времени,прошедшего между этими выбросами.</target>
        </trans-unit>
        <trans-unit id="b3b0d4dac76ddef2f79e3a08df1975b9c86b9d98" translate="yes" xml:space="preserve">
          <source>convert an ordinary Observable into a connectable Observable</source>
          <target state="translated">Преобразовать обычный Наблюдаемый в соединяемый Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="36c287e5fcff20eaf16d26dfb5475062c8618c56" translate="yes" xml:space="preserve">
          <source>convert various other objects and data types into Observables</source>
          <target state="translated">преобразовывать различные другие объекты и типы данных в Наблюдатели</target>
        </trans-unit>
        <trans-unit id="f4ca7b1d875550de063360cab8f9cf4978c92d84" translate="yes" xml:space="preserve">
          <source>converts a Future into a Single</source>
          <target state="translated">превращает Будущее в Единое</target>
        </trans-unit>
        <trans-unit id="cb8e1c3f3e599ff85786d96efc6bdfd9903b7f27" translate="yes" xml:space="preserve">
          <source>converts a Single into an Observable that emits the item emitted by the Single and then completes</source>
          <target state="translated">преобразует Одинокого в Наблюдателя,который испускает элемент,испускаемый Одиноким,а затем завершает...</target>
        </trans-unit>
        <trans-unit id="95bc015cb9a9c64e9443baea3c1aaa8ac7f29d16" translate="yes" xml:space="preserve">
          <source>converts a Single that emits a second Single into a Single that emits the item emitted by the second Single</source>
          <target state="translated">преобразует сингл,излучающий второй сингл,в сингл,излучающий предмет,излучаемый вторым синглом.</target>
        </trans-unit>
        <trans-unit id="170368d03dc716d2f7e2d2bf74c31d9d92aa4f43" translate="yes" xml:space="preserve">
          <source>converts a Single that makes an error notification into a Single that emits a specified item</source>
          <target state="translated">преобразует сингл,который делает уведомление об ошибке,в сингл,который испускает определенный элемент</target>
        </trans-unit>
        <trans-unit id="21c864aec311796f6a8ee3738b2863e2059f40bf" translate="yes" xml:space="preserve">
          <source>converts an Observable that emits a single item into a Single that emits that item</source>
          <target state="translated">преобразует Наблюдателя,который испускает один предмет,в Одиночный,который испускает этот предмет.</target>
        </trans-unit>
        <trans-unit id="1888c76c0a8234b805afa72fa84387df9c464cdd" translate="yes" xml:space="preserve">
          <source>conveys an</source>
          <target state="translated">передаёт</target>
        </trans-unit>
        <trans-unit id="cc33275c066e42225c7bd44275e209912fa780f0" translate="yes" xml:space="preserve">
          <source>count the number of items emitted by the source Observable and emit only this value</source>
          <target state="translated">Считать количество элементов,излучаемых источником Наблюдаемый и излучать только это значение</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="fdb38e7814f867156c67f7710cb229b4d10b3201" translate="yes" xml:space="preserve">
          <source>create a Single from scratch by calling subscriber methods explicitly</source>
          <target state="translated">создать сингл с нуля,явно вызывая методы абонентов.</target>
        </trans-unit>
        <trans-unit id="2ae303adc776faa5253a43fb06677635513e17d9" translate="yes" xml:space="preserve">
          <source>create a disposable resource that has the same lifespan as the Observable</source>
          <target state="translated">создать одноразовый ресурс,имеющий тот же срок службы,что и &quot;Наблюдаемый&quot;.</target>
        </trans-unit>
        <trans-unit id="c6a8aff547f069fdb80cd76a7872c7f620a75366" translate="yes" xml:space="preserve">
          <source>create an Observable from scratch by means of a function</source>
          <target state="translated">создать &quot;Наблюдаемый с нуля&quot; с помощью функции</target>
        </trans-unit>
        <trans-unit id="b33eccb560190edb81875010369904b2976a67f7" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item</source>
          <target state="translated">создать Наблюдаемый,который испускает определенный элемент</target>
        </trans-unit>
        <trans-unit id="82295320e101fc0781587bba12bb5acf15af8c48" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item after a given delay</source>
          <target state="translated">создать &quot;Наблюдаемый&quot;,который испускает определенный элемент после заданной задержки.</target>
        </trans-unit>
        <trans-unit id="1e3219e49f0c47c7c71d11d751ede2c8e6c514ac" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular item multiple times</source>
          <target state="translated">создать Наблюдаемый,который испускает определенный элемент несколько раз.</target>
        </trans-unit>
        <trans-unit id="ca0465f5eb874bf38df3fa2364bec78c08742f29" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a particular range of sequential integers</source>
          <target state="translated">создать Наблюдаемый,который излучает определенный диапазон последовательных целых чисел</target>
        </trans-unit>
        <trans-unit id="92ee38dc48832f578e61897964a8273e3909af09" translate="yes" xml:space="preserve">
          <source>create an Observable that emits a sequence of integers spaced by a given time interval</source>
          <target state="translated">создать Наблюдаемый,который испускает последовательность целых чисел,разделенных на заданный интервал времени.</target>
        </trans-unit>
        <trans-unit id="8d4e5b41bfe8dba9a089b2fe7c6570c481c904ad" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and does not terminate</source>
          <target state="translated">создать Наблюдательный,который не испускает никаких предметов и не прекращает работу.</target>
        </trans-unit>
        <trans-unit id="03c73352ceb55a7c10db1ec5d57ebb0ef733141c" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items and terminates with an error</source>
          <target state="translated">создать Наблюдаемый,который не испускает никаких элементов и заканчивается с ошибкой.</target>
        </trans-unit>
        <trans-unit id="32eb01d241a8343531a01127a803a32299028ff2" translate="yes" xml:space="preserve">
          <source>create an Observable that emits no items but terminates normally</source>
          <target state="translated">создать Наблюдаемый,который не испускает никаких элементов,но заканчивается нормально.</target>
        </trans-unit>
        <trans-unit id="b79d1c80846e9d369b49bcd22a30738b8cdee801" translate="yes" xml:space="preserve">
          <source>create an Observable that emits the return value of a function-like directive</source>
          <target state="translated">создать Наблюдаемое,которое излучает возвращаемое значение функциональной директивы</target>
        </trans-unit>
        <trans-unit id="a5561cb95df07e2d89b98437823d320627cdba07" translate="yes" xml:space="preserve">
          <source>creates a new thread for each unit of work</source>
          <target state="translated">создает новую нить для каждой единицы работы</target>
        </trans-unit>
        <trans-unit id="ab464f0252045aaf075411f0f1a6aed0797306c1" translate="yes" xml:space="preserve">
          <source>delay</source>
          <target state="translated">delay</target>
        </trans-unit>
        <trans-unit id="cb329146a0dd0d566b0628744d67936558741ffa" translate="yes" xml:space="preserve">
          <source>description</source>
          <target state="translated">description</target>
        </trans-unit>
        <trans-unit id="0130195fe419912b70a512541e4691345f6674cd" translate="yes" xml:space="preserve">
          <source>determine whether all items emitted by an Observable meet some criteria</source>
          <target state="translated">определить,удовлетворяют ли все предметы,высвобождаемые наблюдателем,некоторым критериям.</target>
        </trans-unit>
        <trans-unit id="ff3cae2ef561f628b8c891daa60ccb56db8aa32f" translate="yes" xml:space="preserve">
          <source>determine whether an Observable emits a particular item or not</source>
          <target state="translated">определить,испускает ли &quot;Наблюдаемый&quot; конкретный предмет или нет.</target>
        </trans-unit>
        <trans-unit id="7509d1ff7d8d151dbcd5969fef9f3f655099c57a" translate="yes" xml:space="preserve">
          <source>determine whether two Observables emit the same sequence of items</source>
          <target state="translated">определить,выделяют ли два Наблюдателя одну и ту же последовательность элементов</target>
        </trans-unit>
        <trans-unit id="a3f45eefb0dd1450098d33b7dcd8b10e899ebd54" translate="yes" xml:space="preserve">
          <source>discard any items emitted by an Observable after a second Observable emits an item or terminates</source>
          <target state="translated">отбрасывать любые предметы,испускаемые наблюдателем после того,как наблюдатель второй раз испускает предмет или прекращает работу</target>
        </trans-unit>
        <trans-unit id="7ef61ce8a5dffd0c260e15eb10d12d5974f6b1e1" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a second Observable emits an item</source>
          <target state="translated">отбрасывать предметы,испускаемые наблюдателем,до тех пор,пока наблюдатель не испустит второй предмет.</target>
        </trans-unit>
        <trans-unit id="3691b3deaeb85a3b9c3076808d8d13e2c9ca15c4" translate="yes" xml:space="preserve">
          <source>discard items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">отбрасывать предметы,излучаемые наблюдателем,до тех пор,пока указанное условие не станет ложным.</target>
        </trans-unit>
        <trans-unit id="a24279f0df1b28b11e1ed236842b46f562322a29" translate="yes" xml:space="preserve">
          <source>discover error</source>
          <target state="translated">обнаружить ошибку</target>
        </trans-unit>
        <trans-unit id="946dc974300f80e10583bc68927d8820e58b6ce8" translate="yes" xml:space="preserve">
          <source>divide an Observable into a set of Observables that each emit a different subset of items from the original Observable</source>
          <target state="translated">разделить Наблюдаемое на набор Наблюдаемых,каждый из которых испускает свой подмножество элементов от первоначального Наблюдаемого</target>
        </trans-unit>
        <trans-unit id="11e6899e09d5b0e21dac51ae558f249603206247" translate="yes" xml:space="preserve">
          <source>do not create the Observable until the observer subscribes, and create a fresh Observable for each observer</source>
          <target state="translated">не создавайте Наблюдателя до тех пор,пока наблюдатель не подпишется,и создайте новый Наблюдатель для каждого наблюдателя.</target>
        </trans-unit>
        <trans-unit id="2332dd1e2b522343e16599f71fb2fde4233ff0ac" translate="yes" xml:space="preserve">
          <source>do not emit any items from an Observable but mirror its termination notification</source>
          <target state="translated">не выбрасывать никаких предметов из Наблюдаемого,но зеркально отобразить уведомление о его прекращении.</target>
        </trans-unit>
        <trans-unit id="b0d186043ed808f44ab3b75ef20a1f576b6d7d31" translate="yes" xml:space="preserve">
          <source>doOnError</source>
          <target state="translated">doOnError</target>
        </trans-unit>
        <trans-unit id="7193c8c35518b2a87f4d4244048219ccdb80780b" translate="yes" xml:space="preserve">
          <source>doOnSuccess</source>
          <target state="translated">doOnSuccess</target>
        </trans-unit>
        <trans-unit id="a56b577350353096fb8dd622bb5aca0c9bec85e9" translate="yes" xml:space="preserve">
          <source>does it divide its work over multiple threads that may return data to the caller in any order?</source>
          <target state="translated">разделяет ли она свою работу на несколько потоков,которые могут возвращать данные вызывающему абоненту в любом порядке?</target>
        </trans-unit>
        <trans-unit id="e9a705a6cefc203dae4d8a9f3133b7eb64ecee9b" translate="yes" xml:space="preserve">
          <source>does it use NIO with an event-loop to do asynchronous network access?</source>
          <target state="translated">использует ли оно NIO с петлей событий для асинхронного доступа к сети?</target>
        </trans-unit>
        <trans-unit id="c61eeb26d4303ae3094656f0c7c99d06a7fd47e5" translate="yes" xml:space="preserve">
          <source>does it use an Actor (or multiple Actors) instead of a thread pool?</source>
          <target state="translated">использует ли он Актер (или несколько Актеров)вместо нитевого пула?</target>
        </trans-unit>
        <trans-unit id="d45843eeab32a602d9af842b03276dd264c86fb3" translate="yes" xml:space="preserve">
          <source>does it use an event-loop to separate the work thread from the callback thread?</source>
          <target state="translated">использует ли он петлю событий,чтобы отделить рабочую нить от обратного вызова?</target>
        </trans-unit>
        <trans-unit id="5fa3c300a8b1aa79b5251cfec9489f85c1fe4ecc" translate="yes" xml:space="preserve">
          <source>does it work asynchronously on a distinct thread?</source>
          <target state="translated">работает ли он асинхронно на отдельной нити?</target>
        </trans-unit>
        <trans-unit id="90c3f6d02b875e5084eb3ab9fe4d1f72abaab63b" translate="yes" xml:space="preserve">
          <source>does it work synchronously on the same thread as the caller?</source>
          <target state="translated">работает ли он синхронно на одной нити с вызывающим абонентом?</target>
        </trans-unit>
        <trans-unit id="710324ca59ab0fb7cedc97294ff18e57250aa3d3" translate="yes" xml:space="preserve">
          <source>element, or a NodeList, jQuery element, Zepto Element, Angular element, Ember.js element, or EventEmitter.</source>
          <target state="translated">элемент,или NodeList,jQuery,Zepto Element,Angular element,Ember.js,или EventEmitter.</target>
        </trans-unit>
        <trans-unit id="543f8528a5a36e0fd63ca3d3b9efd3632fd5f9fe" translate="yes" xml:space="preserve">
          <source>emit a specified sequence of items before beginning to emit the items from the source Observable</source>
          <target state="translated">перед началом излучения от источника излучает заданную последовательность элементов Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="769fc1172fe01d37dc2f7e2713413d7a65503510" translate="yes" xml:space="preserve">
          <source>emit items from the source Observable, or a default item if the source Observable emits nothing</source>
          <target state="translated">испускает элементы из источника Наблюдаемый,или элемент по умолчанию,если источник Наблюдаемый ничего не испускает</target>
        </trans-unit>
        <trans-unit id="a115af0876acd2b5e8fcdc6c52560200a454030f" translate="yes" xml:space="preserve">
          <source>emit only item</source>
          <target state="translated">испускать только вещество</target>
        </trans-unit>
        <trans-unit id="02aaf586c2920f9cf2072e5c133fdd3df98c558a" translate="yes" xml:space="preserve">
          <source>emit only the final</source>
          <target state="translated">испускать только финальный</target>
        </trans-unit>
        <trans-unit id="283d4e16f73e8edadb26e90e4c88dd395606afff" translate="yes" xml:space="preserve">
          <source>emit only the first</source>
          <target state="translated">испускать только первый</target>
        </trans-unit>
        <trans-unit id="c1a6d921096c6a9cea1ec58a1d7915ffd2cb0a6c" translate="yes" xml:space="preserve">
          <source>emit only the first item (or the first item that meets some condition) emitted by an Observable</source>
          <target state="translated">испускает только первый элемент (или первый элемент,удовлетворяющий определенному условию),испускаемый наблюдателем.</target>
        </trans-unit>
        <trans-unit id="f7170ccdd023f5a086caa059f65476d0bdf1f23e" translate="yes" xml:space="preserve">
          <source>emit only the last item (or the last item that meets some condition) emitted by an Observable</source>
          <target state="translated">испускает только последний элемент (или последний элемент,удовлетворяющий определенному условию),испускаемый наблюдателем.</target>
        </trans-unit>
        <trans-unit id="c526ff4f61953d2c1ad9b75959a34d517116b608" translate="yes" xml:space="preserve">
          <source>emit only those items from an Observable that pass a predicate test</source>
          <target state="translated">испускают только те предметы из Наблюдаемого,которые проходят предикатное испытание.</target>
        </trans-unit>
        <trans-unit id="f2e3b63fe53b455567c0ba6e3aace08cba7b101c" translate="yes" xml:space="preserve">
          <source>emit the emissions from two or more Observables without interleaving them</source>
          <target state="translated">выбрасывать выбросы от двух или более Наблюдателей без их чередования</target>
        </trans-unit>
        <trans-unit id="5b3c959fdd976b09cc3b28b3011f1ca1bcdb8853" translate="yes" xml:space="preserve">
          <source>emit the most recent items emitted by an Observable within periodic time intervals</source>
          <target state="translated">выбрасывают самые свежие предметы,излучаемые наблюдаемым в течение периодических промежутков времени.</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="a442b9237df23abb5cc5420387c221e8a2aeccc5" translate="yes" xml:space="preserve">
          <source>emits a particular sequence of items, but can begin emitting this sequence when its observer finds it to be convenient, and at whatever rate the observer desires, without disrupting the integrity of the sequence. For example if you convert a static iterable into an Observable, that Observable will emit the same sequence of items no matter when it is later subscribed to or how frequently those items are observed. Examples of items emitted by a cold Observable might include the results of a database query, file retrieval, or web request.</source>
          <target state="translated">испускает определенную последовательность элементов,но может начать испускать эту последовательность,когда его наблюдатель сочтет это удобным,и с любой скоростью,которую пожелает наблюдатель,не нарушая целостность последовательности.Например,если вы преобразовываете статический итерабельный элемент в наблюдаемый,то этот наблюдатель будет испускать ту же самую последовательность элементов,независимо от того,когда он позднее подпишется на эту последовательность и как часто эти элементы наблюдаются.Примеры элементов,испускаемых &quot;холодным&quot; обозревателем,могут включать результаты запроса к базе данных,поиск файлов или веб-запрос.</target>
        </trans-unit>
        <trans-unit id="9f22b2c00b19a035731d14ad74cd7c6d05921206" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the maximum value</source>
          <target state="translated">выбрасывает элемент из источника Наблюдаемый,имеющий максимальное значение</target>
        </trans-unit>
        <trans-unit id="74d826ddf8287874d3ee8212bbe2a72b20190f91" translate="yes" xml:space="preserve">
          <source>emits the item from the source Observable that had the minimum value</source>
          <target state="translated">выбрасывает изделие из источника Наблюдаемый,имеющий минимальное значение</target>
        </trans-unit>
        <trans-unit id="9665ac3929f268285506b88deec23cb12f0e63bd" translate="yes" xml:space="preserve">
          <source>emitted</source>
          <target state="translated">emitted</target>
        </trans-unit>
        <trans-unit id="88d6618f3561fa3cb57d650ace09305ee6f0d428" translate="yes" xml:space="preserve">
          <source>emitted by an Observable</source>
          <target state="translated">излучаемый наблюдателем</target>
        </trans-unit>
        <trans-unit id="7e4f940b5782633c616f37bc35675c5163ed9a19" translate="yes" xml:space="preserve">
          <source>emitted by the Observable.</source>
          <target state="translated">испускаемый Наблюдателем.</target>
        </trans-unit>
        <trans-unit id="71e9b710ca7e783890b77f938203768b335532b7" translate="yes" xml:space="preserve">
          <source>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</source>
          <target state="translated">обеспечить,чтобы все наблюдатели видели одну и ту же последовательность испускаемых предметов,даже если они подписываются после того,как наблюдатель начал испускать предметы.</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="ccc9d4f948ad94c5bbe07a1feee18738df60b756" translate="yes" xml:space="preserve">
          <source>flatMap</source>
          <target state="translated">flatMap</target>
        </trans-unit>
        <trans-unit id="378ce4f507ad3e73799fb43d9c5ee511ddbf655c" translate="yes" xml:space="preserve">
          <source>flatMapObservable</source>
          <target state="translated">flatMapObservable</target>
        </trans-unit>
        <trans-unit id="4bd229d639cd13fb02a63b1261609ad0439b9c86" translate="yes" xml:space="preserve">
          <source>for each observer that subscribes</source>
          <target state="translated">для каждого наблюдателя,который подписался</target>
        </trans-unit>
        <trans-unit id="6074cf77c3da497067408b6c04f9a98a7d0a3bf9" translate="yes" xml:space="preserve">
          <source>for unit testing; this allows you to manually manipulate the movement of time</source>
          <target state="translated">для юнит-тестирования;это позволяет вручную манипулировать движением времени</target>
        </trans-unit>
        <trans-unit id="746e807e0dba440c42eb9deaeab2869069904a18" translate="yes" xml:space="preserve">
          <source>force an Observable to make serialized calls and to be well-behaved</source>
          <target state="translated">заставлять наблюдаемого делать серийные звонки и вести себя хорошо.</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">from</target>
        </trans-unit>
        <trans-unit id="f1d7632831475751406b7847814481cce36b28fc" translate="yes" xml:space="preserve">
          <source>from a timeout by switching to a backup Observable</source>
          <target state="translated">от таймаута,переключившись на резервный Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="4ab8e53e57dab3b5525830c9e68479df42938a79" translate="yes" xml:space="preserve">
          <source>from an upstream error notification</source>
          <target state="translated">предварительное уведомление об ошибке</target>
        </trans-unit>
        <trans-unit id="7338bb521aa9cdd1bef4a257ca363c0096b6e672" translate="yes" xml:space="preserve">
          <source>from scratch, with custom logic</source>
          <target state="translated">с нуля,с индивидуальной логикой</target>
        </trans-unit>
        <trans-unit id="5a492ec6db38b38bc93bc93c566d523b475eca95" translate="yes" xml:space="preserve">
          <source>given two or more source Observables, emit all of the items from only the first of these Observables to emit an item or notification</source>
          <target state="translated">при наличии двух или более источников Наблюдатели,выбрасывают все элементы только из первого из этих Наблюдателей,чтобы выбросить элемент или уведомление.</target>
        </trans-unit>
        <trans-unit id="230d0d8c960eb6b08fb0602b808641addcc39716" translate="yes" xml:space="preserve">
          <source>happens-before</source>
          <target state="translated">happens-before</target>
        </trans-unit>
        <trans-unit id="51226a41675d8138b62f4eb13f05814105d80981" translate="yes" xml:space="preserve">
          <source>hot Observable</source>
          <target state="translated">горячий Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="762383040ebcbba981d0e6627015750c613068be" translate="yes" xml:space="preserve">
          <source>if a source Observable emits an error, resubscribe to it in the hopes that it will complete without error</source>
          <target state="translated">если источник &quot;Наблюдаемый&quot; выдает ошибку,переподпишитесь на нее в надежде,что она завершится без ошибок.</target>
        </trans-unit>
        <trans-unit id="b7eef0381b59d94b8b2e60cf2c77d995768de18a" translate="yes" xml:space="preserve">
          <source>if a specified period of time elapses without it emitting an item</source>
          <target state="translated">если определенный период времени проходит без его испускания.</target>
        </trans-unit>
        <trans-unit id="c07264c1fd314b3c228343a6b7aa32c253cc1c83" translate="yes" xml:space="preserve">
          <source>if they immediately follow the item they are duplicates of</source>
          <target state="translated">если они немедленно следуют за пунктом,то они являются дубликатами</target>
        </trans-unit>
        <trans-unit id="847acd37db27d351d2cbeb11978036131dab6677" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has completed successfully and that it will be emitting no further items</source>
          <target state="translated">указывает на то,что &quot;Наблюдатель&quot; успешно завершил свою работу и больше не будет выпускать никаких предметов.</target>
        </trans-unit>
        <trans-unit id="59bab5bf8560c12918e09739c3c2a53cf71eee79" translate="yes" xml:space="preserve">
          <source>indicates that the Observable has terminated with a specified error condition and that it will be emitting no further items</source>
          <target state="translated">указывает на то,что &quot;Наблюдатель&quot; завершил работу с заданным условием ошибки и больше не будет испускать никаких элементов.</target>
        </trans-unit>
        <trans-unit id="57c80aa16dbb40cbb50b4685e19ae54bb36188e5" translate="yes" xml:space="preserve">
          <source>indicates that the Observable is ready to accept Request notifications from the observer (see</source>
          <target state="translated">указывает,что Наблюдатель готов принять Запрос уведомления от Наблюдателя (см.</target>
        </trans-unit>
        <trans-unit id="d80a3dc0bd493e47930194898002eecbd9780bcc" translate="yes" xml:space="preserve">
          <source>indicates that the observer is ready to receive notifications from the Observable</source>
          <target state="translated">указывает,что наблюдатель готов получать уведомления от Наблюдателя.</target>
        </trans-unit>
        <trans-unit id="03c2a4397d8fb4d3e801b370f28da5452181212d" translate="yes" xml:space="preserve">
          <source>indicates that the observer no longer wants to receive notifications from the Observable</source>
          <target state="translated">указывает,что наблюдатель больше не хочет получать уведомления от Наблюдателя.</target>
        </trans-unit>
        <trans-unit id="7720d844d06776ca6a9a6e7116dc341d37719b6c" translate="yes" xml:space="preserve">
          <source>indicates that the observer wants no more than a particular number of additional OnNext notifications from the Observable (see</source>
          <target state="translated">указывает на то,что наблюдатель хочет получить от Наблюдателя не более определенного числа дополнительных OnNext-уведомлений (см.</target>
        </trans-unit>
        <trans-unit id="d772411175504239715809db32a049bd5f9a24eb" translate="yes" xml:space="preserve">
          <source>instruct a connectable Observable to begin emitting items to its subscribers</source>
          <target state="translated">инструктировать подключаемого Наблюдательного,чтобы он начал излучать предметы своим абонентам.</target>
        </trans-unit>
        <trans-unit id="3e70b2ffd83c9f25ae3b87ef19a913ca3c280c74" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error</source>
          <target state="translated">указывает наблюдателю начать излучать вторую наблюдаемую последовательность,если он столкнется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="d93ae2066632ae68fa3e9d24a83479d6a6125575" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting a second Observable sequence if it encounters an error or if the source Observable terminates normally</source>
          <target state="translated">указывает наблюдателю начать испускать вторую наблюдаемую последовательность,если он сталкивается с ошибкой или если источник &quot;Наблюдаемый&quot; заканчивается нормально.</target>
        </trans-unit>
        <trans-unit id="c0cd3f6eebd1f6d2d2b9042e39803a1c070a6c65" translate="yes" xml:space="preserve">
          <source>instructs an Observable to begin emitting items from another Observable, or from an Observable returned from an action, if it encounters an error</source>
          <target state="translated">дает указание наблюдателю начать испускать предметы от другого наблюдателя или от наблюдателя,возвращенного в результате действия,если он столкнется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="22e38a48635b45db863e539f2c56ed48d008c816" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by a set of other Observables, one Observable at a time, regardless of whether the source Observable or any subsequent Observable terminates with an error</source>
          <target state="translated">дает указание Наблюдателю объединять предметы,излучаемые набором других Наблюдателей,по одному Наблюдателю за раз,независимо от того,заканчивается ли источник Наблюдаемый или любой последующий Наблюдаемый с ошибкой</target>
        </trans-unit>
        <trans-unit id="488263840997c93e29d532e89e384512092c9225" translate="yes" xml:space="preserve">
          <source>instructs an Observable to concatenate items emitted by another Observable to the sequence emitted by the source Observable, regardless of whether the source Observable terminates normally or with an error</source>
          <target state="translated">Приказывает наблюдателю соединить элементы,излучаемые другим наблюдателем Наблюдается последовательность,излучаемая источником Наблюдается,независимо от того,заканчивается ли источник Наблюдаемый нормально или с ошибкой</target>
        </trans-unit>
        <trans-unit id="97c6213e9fd3b3b94003a1080aa20fcc201250e2" translate="yes" xml:space="preserve">
          <source>instructs an Observable to continue emitting items after it encounters an exception (but not another variety of throwable)</source>
          <target state="translated">дает указание наблюдателю продолжать выбрасывать предметы после того,как он столкнется с исключением (но не с другим вариантом выбрасывания).</target>
        </trans-unit>
        <trans-unit id="ffd411015f886b118c92de6b6395db72b3070d73" translate="yes" xml:space="preserve">
          <source>instructs an Observable to emit a particular item when it encounters an error, and then terminate normally</source>
          <target state="translated">дает указание наблюдателю испускать определенный предмет,когда он сталкивается с ошибкой,а затем прекращает нормальную работу.</target>
        </trans-unit>
        <trans-unit id="4d7e5498f8a1b2653573be7dedf0e0305669acdd" translate="yes" xml:space="preserve">
          <source>instructs an Observable, if it encounters an error, to begin emitting items from a set of other Observables, one Observable at a time, until one of those Observables terminates successfully</source>
          <target state="translated">приказывает наблюдателю,если он столкнется с ошибкой,начать испускать предметы из набора других наблюдателей,по одному наблюдателю за раз,пока один из этих наблюдателей не завершит свою работу успешно.</target>
        </trans-unit>
        <trans-unit id="4b601dbe8a076d8fccff82083667b82ac9cbcaf2" translate="yes" xml:space="preserve">
          <source>instructs the Single to call the subscriber methods on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">указывает Single на вызов методов подписчика в конкретном &lt;a href=&quot;scheduler&quot;&gt;планировщике&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eca0b3496b0773e9004170e5ee17829fa81e2cfc" translate="yes" xml:space="preserve">
          <source>instructs the Single to operate on a particular &lt;a href=&quot;scheduler&quot;&gt;Scheduler&lt;/a&gt;</source>
          <target state="translated">поручает Single работать с конкретным &lt;a href=&quot;scheduler&quot;&gt;планировщиком&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c357df049720e803767baccb0a0919d8ae438720" translate="yes" xml:space="preserve">
          <source>integers starting with &lt;code&gt;1&lt;/code&gt; and converts it, via &lt;code&gt;scan&lt;/code&gt;, into an Observable that emits the first</source>
          <target state="translated">целые числа, начинающиеся с &lt;code&gt;1&lt;/code&gt; , и преобразует их посредством &lt;code&gt;scan&lt;/code&gt; в Observable, который генерирует первый</target>
        </trans-unit>
        <trans-unit id="5c66328e63d2651a8680db012ecb04a1e0c9fb8d" translate="yes" xml:space="preserve">
          <source>into an indicator of the amount of time that lapsed before the emission of the item</source>
          <target state="translated">в показатель времени,которое прошло до выброса данного элемента</target>
        </trans-unit>
        <trans-unit id="6e92086dca618f4ee5c9fb6bfd63624bbdfcf042" translate="yes" xml:space="preserve">
          <source>into one that emits objects of type &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt;, where each such object is stamped with the time at which it was originally emitted.</source>
          <target state="translated">в тот, который испускает объекты типа &lt;code&gt;Timestamped&amp;lt;&lt;i&gt;T&lt;/i&gt;&amp;gt;&lt;/code&gt; , где каждый такой объект помечается временем, в которое он был первоначально создан.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f2ab6d76f77af5073047a5a0bc5e4892cf2ac71b" translate="yes" xml:space="preserve">
          <source>it (this also initiates the actions of the Observable).</source>
          <target state="translated">(это также инициирует действия Наблюдателя).</target>
        </trans-unit>
        <trans-unit id="3a7d9767b1233601ebf8b67495c6dc2ce8b8c2af" translate="yes" xml:space="preserve">
          <source>item</source>
          <target state="translated">item</target>
        </trans-unit>
        <trans-unit id="7316c8b2e74870d9d7e9d30bbc28ecf4cdf945ee" translate="yes" xml:space="preserve">
          <source>items</source>
          <target state="translated">items</target>
        </trans-unit>
        <trans-unit id="54cecc63037672c9d565bd5b413cdb087c5f46ac" translate="yes" xml:space="preserve">
          <source>items before completing, the new, &lt;code&gt;take&lt;/code&gt;-modified Observable will not throw an exception or invoke &lt;code&gt;onError&lt;/code&gt;, but will merely emit this same fewer number of items before it completes.</source>
          <target state="translated">пункты до завершения, новый, &lt;code&gt;take&lt;/code&gt; -modified Наблюдаемые не будет сгенерировано исключение или запускайте &lt;code&gt;onError&lt;/code&gt; , но будет просто излучать этот же меньшее количество элементов до завершения.</target>
        </trans-unit>
        <trans-unit id="5cc703698419188f6748e57d5051172e7578d5ef" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable</source>
          <target state="translated">предметы,выделяемые наблюдателем</target>
        </trans-unit>
        <trans-unit id="281b0dc3c88a6285d1fcc3248e4b72d6d13752fa" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come after, by modifying the Observable with the Skip operator.</source>
          <target state="translated">предметы,испускаемые наблюдателем,и обслуживают только те предметы,которые следуют за ним,путем изменения наблюдаемого с помощью оператора Пропуска.</target>
        </trans-unit>
        <trans-unit id="256cbf4eb14c5d64b17e59041c7002ce9915bf97" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that come before them, by modifying the Observable with the SkipLast operator.</source>
          <target state="translated">предметов,испускаемых наблюдателем,и обслуживать только те предметы,которые перед ними,модифицируя наблюдаемый с помощью оператора SkipLast.</target>
        </trans-unit>
        <trans-unit id="1bcdfca876104995c38c6ca1144b2b6e6f5fa505" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and attend only to those items that precede them, by modifying the Observable with the &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that the mechanism by which this is implemented will delay the emission of any item from the source Observable until</source>
          <target state="translated">элементы, испускаемые Observable, и обслуживают только те элементы, которые им предшествуют, путем изменения Observable с помощью &lt;code&gt;skipLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Обратите внимание, что механизм, с помощью которого это реализовано, будет задерживать выброс любого элемента из источника Observable до тех пор, пока</target>
        </trans-unit>
        <trans-unit id="1ce3138e6873c0e9bb2af30c7b2c8ddfc633bf03" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that come before them, by modifying the Observable with the TakeLast operator.</source>
          <target state="translated">элементы,излучаемые наблюдателем,и игнорируют те элементы,которые перед ними,изменяя наблюдателя с помощью оператора TakeLast.</target>
        </trans-unit>
        <trans-unit id="627d3004856c8c25ed154bf10b211c198e92ed99" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until that Observable completes.</source>
          <target state="translated">элементы, испускаемые Observable, и игнорируют те элементы, которые им предшествуют, путем изменения Observable с помощью &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Обратите внимание, что это задержит передачу любого элемента из источника Observable до завершения этого Observable.</target>
        </trans-unit>
        <trans-unit id="e78d9230f84809bd8259c4cdacd12e1311cbf6b2" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and ignore those items that precede them, by modifying the Observable with the &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; operator. Note that this will delay the emission of any item from the source Observable until the source Observable completes.</source>
          <target state="translated">элементы, испускаемые Observable, и игнорируют те элементы, которые им предшествуют, путем изменения Observable с помощью &lt;code&gt;takeLast(&lt;i&gt;n&lt;/i&gt;)&lt;/code&gt; . Обратите внимание, что это задержит выпуск любого элемента из исходного Observable до завершения исходного Observable.</target>
        </trans-unit>
        <trans-unit id="3bbe910e0e0b20f8e7a00952441aa27949753b14" translate="yes" xml:space="preserve">
          <source>items emitted by an Observable and then complete while ignoring the remainder, by modifying the Observable with the Take operator.</source>
          <target state="translated">элементы,испускаемые наблюдателем,а затем заполняются,игнорируя остальные элементы,путем изменения наблюдаемого с помощью оператора &quot;Забрать&quot;.</target>
        </trans-unit>
        <trans-unit id="8638cd8395daa1b642320bfea0b50152c0b101a3" translate="yes" xml:space="preserve">
          <source>items emitted by the bursty Observable.</source>
          <target state="translated">предметы,испускаемые взрывом Наблюдаемый.</target>
        </trans-unit>
        <trans-unit id="a7b968713a235f777cf138dc3695594bad65a2ed" translate="yes" xml:space="preserve">
          <source>items, which allows the &lt;code&gt;ControlledObservable&lt;/code&gt; to run somewhat ahead of the observer from time to time. &lt;code&gt;windowed(1)&lt;/code&gt; is equivalent to &lt;code&gt;stopAndWait&lt;/code&gt;.</source>
          <target state="translated">items, что позволяет &lt;code&gt;ControlledObservable&lt;/code&gt; время от времени опережать наблюдателя. &lt;code&gt;windowed(1)&lt;/code&gt; эквивалентен &lt;code&gt;stopAndWait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="252b793f4b97747e8725e6d8dc5ba3b8321dc7d6" translate="yes" xml:space="preserve">
          <source>jort.technology</source>
          <target state="translated">jort.technology</target>
        </trans-unit>
        <trans-unit id="d95b79cfc988b3b165ceb830a9c8932d1b52cf18" translate="yes" xml:space="preserve">
          <source>just</source>
          <target state="translated">just</target>
        </trans-unit>
        <trans-unit id="a62f2225bf70bfaccbc7f1ef2a397836717377de" translate="yes" xml:space="preserve">
          <source>key</source>
          <target state="translated">key</target>
        </trans-unit>
        <trans-unit id="0c1beb7946903d44f31f6b86cf15dfddb1b73736" translate="yes" xml:space="preserve">
          <source>make a Connectable Observable behave like an ordinary Observable</source>
          <target state="translated">заставить Connectable Observable вести себя как обычный наблюдатель.</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="79d67b9fd09cde874d173f35b4df9504ff9198eb" translate="yes" xml:space="preserve">
          <source>meant for I/O-bound work such as asynchronous performance of blocking I/O, this scheduler is backed by a thread-pool that will grow as needed; for ordinary computational work, switch to &lt;code&gt;Schedulers.computation( )&lt;/code&gt;; &lt;code&gt;Schedulers.io( )&lt;/code&gt; by default is a &lt;code&gt;CachedThreadScheduler&lt;/code&gt;, which is something like a new thread scheduler with thread caching</source>
          <target state="translated">предназначенный для работы, связанной с вводом-выводом, такой как асинхронная производительность блокирующего ввода-вывода, этот планировщик поддерживается пулом потоков, который будет расти по мере необходимости; для обычной вычислительной работы переключитесь на &lt;code&gt;Schedulers.computation( )&lt;/code&gt; ; &lt;code&gt;Schedulers.io( )&lt;/code&gt; по умолчанию - это &lt;code&gt;CachedThreadScheduler&lt;/code&gt; , что-то вроде нового планировщика потоков с кешированием потоков.</target>
        </trans-unit>
        <trans-unit id="a1b2d933157904f1909eba2778bc1b0bc5b32a0f" translate="yes" xml:space="preserve">
          <source>meant for computational work such as event-loops and callback processing; do not use this scheduler for I/O (use &lt;code&gt;Schedulers.io( )&lt;/code&gt; instead); the number of threads, by default, is equal to the number of processors</source>
          <target state="translated">предназначен для вычислительной работы, такой как циклы событий и обработка обратного вызова; не используйте этот планировщик для ввода-вывода (используйте вместо него &lt;code&gt;Schedulers.io( )&lt;/code&gt; ); количество потоков по умолчанию равно количеству процессоров</target>
        </trans-unit>
        <trans-unit id="14091a9f2461267ee7e02525b4f1f2923f1c9849" translate="yes" xml:space="preserve">
          <source>merge</source>
          <target state="translated">merge</target>
        </trans-unit>
        <trans-unit id="b5a02016a0682c002da94900aa3dd08ee317e771" translate="yes" xml:space="preserve">
          <source>merge and mergeWith</source>
          <target state="translated">слияние и поглощениеС</target>
        </trans-unit>
        <trans-unit id="754ffff9989c69728e41fa3f602dea0149183089" translate="yes" xml:space="preserve">
          <source>mergeWith</source>
          <target state="translated">mergeWith</target>
        </trans-unit>
        <trans-unit id="6d5c675bf8edaff2c66ed7c992b706e5704acdc8" translate="yes" xml:space="preserve">
          <source>merges the items emitted by multiple Singles as Observable emissions</source>
          <target state="translated">объединяет элементы,выделяемые несколькими Одиночками,в качестве наблюдаемых выбросов</target>
        </trans-unit>
        <trans-unit id="1373a31197b556329ac156e7ade9cb2ba85e793d" translate="yes" xml:space="preserve">
          <source>mirror items emitted by an Observable until a specified condition becomes false</source>
          <target state="translated">зеркалировать предметы,излучаемые наблюдателем,до тех пор,пока заданное условие не станет ложным.</target>
        </trans-unit>
        <trans-unit id="69e7a4a6098f21dd74f0e5d1f1183014c08998d2" translate="yes" xml:space="preserve">
          <source>mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items</source>
          <target state="translated">Зеркальное отображение источника Наблюдается,но выдает уведомление об ошибке,если определенный период времени проходит без каких-либо излучаемых элементов</target>
        </trans-unit>
        <trans-unit id="648302e50e59872ed27b6c579097c5a430271379" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this absolute time</source>
          <target state="translated">Зеркала элементов от источника Соблюдается до этого абсолютного времени</target>
        </trans-unit>
        <trans-unit id="1c73d060d2a786fb5a45214e5514f3329b981c55" translate="yes" xml:space="preserve">
          <source>mirrors items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">зеркала от источника Наблюдаемый до тех пор,пока не прошло столько миллисекунд,сколько прошло с тех пор,как Наблюдаемый был подписан на</target>
        </trans-unit>
        <trans-unit id="da434d1b08108bb48efd1b874843206b9adea4d0" translate="yes" xml:space="preserve">
          <source>move the emission of an item from a Single forward in time</source>
          <target state="translated">перенести эмиссию предмета с единичного на единицу вперед по времени.</target>
        </trans-unit>
        <trans-unit id="a94e19af4af9c51d17a33a85b88b9c524903d431" translate="yes" xml:space="preserve">
          <source>multiple items</source>
          <target state="translated">несколько пунктов</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="1b60d2ed7158736cbc1353d72a6dc44a6772147f" translate="yes" xml:space="preserve">
          <source>notifications</source>
          <target state="translated">notifications</target>
        </trans-unit>
        <trans-unit id="d29d85b4e7d22abd97299321615272b226b96438" translate="yes" xml:space="preserve">
          <source>notifications and understands</source>
          <target state="translated">уведомления и понимания</target>
        </trans-unit>
        <trans-unit id="133b33b5c57f2a5dc33401a8b5b7d96bac8376ad" translate="yes" xml:space="preserve">
          <source>notifications.</source>
          <target state="translated">notifications.</target>
        </trans-unit>
        <trans-unit id="560c4dbd7c1a66afc1b71b103a23f7c108007205" translate="yes" xml:space="preserve">
          <source>observeOn</source>
          <target state="translated">observeOn</target>
        </trans-unit>
        <trans-unit id="307527c227ac648bb119bcb457ebb8466e79827c" translate="yes" xml:space="preserve">
          <source>observer</source>
          <target state="translated">observer</target>
        </trans-unit>
        <trans-unit id="cabaf29399c77e9ce3c5ed70182997a660a42de0" translate="yes" xml:space="preserve">
          <source>onCompleted</source>
          <target state="translated">onCompleted</target>
        </trans-unit>
        <trans-unit id="34c18e24d1dfbbb529faba38b503601cb512f20e" translate="yes" xml:space="preserve">
          <source>onError</source>
          <target state="translated">onError</target>
        </trans-unit>
        <trans-unit id="1ec9553944d373e3c5ccee85191a76e3362aa2c2" translate="yes" xml:space="preserve">
          <source>onErrorReturn</source>
          <target state="translated">onErrorReturn</target>
        </trans-unit>
        <trans-unit id="8cffc1eb25befde35dc9a29caa8d3c1b3fdf164c" translate="yes" xml:space="preserve">
          <source>onNext</source>
          <target state="translated">onNext</target>
        </trans-unit>
        <trans-unit id="bc8d0ce7f27d4c43756b40ce541d77416645f7ef" translate="yes" xml:space="preserve">
          <source>onNext, onCompleted, and onError</source>
          <target state="translated">onNext,onCompleteted и onError</target>
        </trans-unit>
        <trans-unit id="df2505265f9a2c8f72075dad202d8fb79cdac569" translate="yes" xml:space="preserve">
          <source>onSuccess</source>
          <target state="translated">onSuccess</target>
        </trans-unit>
        <trans-unit id="b40cdaa970a1b4cc121d9b48173fcaff7e0f15d4" translate="yes" xml:space="preserve">
          <source>one Observable at a time, in the order they are emitted</source>
          <target state="translated">по одному Наблюдаемому за раз,в том порядке,в котором они испускаются.</target>
        </trans-unit>
        <trans-unit id="9499006797e3e9becedebbe4f06adec371d9a167" translate="yes" xml:space="preserve">
          <source>one at a time with a function</source>
          <target state="translated">по одному с функцией</target>
        </trans-unit>
        <trans-unit id="1b0bb14695267c72adf406bf3902f0603344f4e9" translate="yes" xml:space="preserve">
          <source>only emit an item from an Observable if a particular timespan has passed without it emitting another item</source>
          <target state="translated">только если определенное время прошло,и не было выброшено другого предмета.</target>
        </trans-unit>
        <trans-unit id="8f907d09e23699668d1792d557974f49ae533d7c" translate="yes" xml:space="preserve">
          <source>only if its sequence is empty</source>
          <target state="translated">только если его последовательность пуста</target>
        </trans-unit>
        <trans-unit id="5395918d1a7cce46854ed435b45bff5e7397a9a0" translate="yes" xml:space="preserve">
          <source>operate upon the emissions and notifications from an Observable</source>
          <target state="translated">действовать на основе выбросов и уведомлений от Наблюдателя</target>
        </trans-unit>
        <trans-unit id="fe96dd39756ac41b74283a9292652d366d73931f" translate="yes" xml:space="preserve">
          <source>operator</source>
          <target state="translated">operator</target>
        </trans-unit>
        <trans-unit id="2a8c5cef636d11d3f64dcc36efc3ac4b5978eb60" translate="yes" xml:space="preserve">
          <source>operator converts a source Observable into an Observable that emits indications of the amount of time lapsed between consecutive emissions of the source Observable. The first emission from this new Observable indicates the amount of time lapsed between the time when the observer subscribed to the Observable and the time when the source Observable emitted its first item. There is no corresponding emission marking the amount of time lapsed between the last emission of the source Observable and the subsequent call to &lt;code&gt;onCompleted&lt;/code&gt;.</source>
          <target state="translated">Оператор преобразует источник Observable в Observable, который выдает индикацию количества времени, прошедшего между последовательными выбросами источника Observable. Первое излучение этого нового Observable указывает количество времени, прошедшее между моментом, когда наблюдатель подписался на Observable, и временем, когда исходный Observable выпустил свой первый элемент. Нет соответствующей эмиссии, отмечающей количество времени, прошедшего между последней эмиссией источника Observable и последующим вызовом &lt;code&gt;onCompleted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66fc7ee958ea8e350bc6b87518bc06ff7e386c28" translate="yes" xml:space="preserve">
          <source>or sends</source>
          <target state="translated">или отправляет</target>
        </trans-unit>
        <trans-unit id="22e3ca60f9f989b91acea4f38bac56355b1ea1e5" translate="yes" xml:space="preserve">
          <source>otherwise: &lt;code&gt;rx.lite.js&lt;/code&gt; or &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</source>
          <target state="translated">в противном случае: &lt;code&gt;rx.lite.js&lt;/code&gt; или &lt;code&gt;rx.lite.compat.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aebaa77adbf6e1ab8dd65462495edf64837ccf37" translate="yes" xml:space="preserve">
          <source>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</source>
          <target state="translated">периодически собирать предметы,выбрасываемые наблюдателем,в связки и выбрасывать эти связки вместо того,чтобы выбрасывать их по одной.</target>
        </trans-unit>
        <trans-unit id="66566ba8929f0e65118531a524420a0447fc130a" translate="yes" xml:space="preserve">
          <source>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</source>
          <target state="translated">периодически разделять элементы из окна &quot;Наблюдаемый&quot; на &quot;Наблюдаемый&quot; и испускать эти окна вместо того,чтобы испускать элементы по очереди</target>
        </trans-unit>
        <trans-unit id="231e65684158501c2336cbfcb310e00fcb24c73a" translate="yes" xml:space="preserve">
          <source>purpose</source>
          <target state="translated">purpose</target>
        </trans-unit>
        <trans-unit id="4cc45ea2a949b9dd69fb4880e9ac06e94bde81b9" translate="yes" xml:space="preserve">
          <source>queues work to begin on the current thread after any already-queued work</source>
          <target state="translated">очереди для начала работы на текущем потоке после любой уже выполненной работы</target>
        </trans-unit>
        <trans-unit id="9da83891bf1aa57c20a6c75cc2a6001679fd362b" translate="yes" xml:space="preserve">
          <source>recover from an onError notification by continuing the sequence without error</source>
          <target state="translated">восстановление после уведомления об ошибке путем продолжения последовательности без ошибок</target>
        </trans-unit>
        <trans-unit id="029c86507f454275f2dddfe843b1bf03334a3d19" translate="yes" xml:space="preserve">
          <source>register an action to take upon a variety of Observable lifecycle events</source>
          <target state="translated">регистрировать действия в отношении различных наблюдаемых событий жизненного цикла</target>
        </trans-unit>
        <trans-unit id="16529dc63377ab5e64b0efbeca6d2e56779f6316" translate="yes" xml:space="preserve">
          <source>relationship between the notifications.</source>
          <target state="translated">связь между уведомлениями.</target>
        </trans-unit>
        <trans-unit id="38bbe4da48e39e37646b87da88c2ef296e178ab7" translate="yes" xml:space="preserve">
          <source>replaces all &lt;code&gt;onError&lt;/code&gt; notifications from a misbehaving Observable into the emissions from a secondary Observable</source>
          <target state="translated">заменяет все уведомления &lt;code&gt;onError&lt;/code&gt; от некорректного Observable на выбросы от вторичного Observable</target>
        </trans-unit>
        <trans-unit id="3f11990ccf2c77aba0c6c6712860414435d406c7" translate="yes" xml:space="preserve">
          <source>represent both the items emitted and the notifications sent as emitted items, or reverse this process</source>
          <target state="translated">представлять как испускаемые элементы,так и уведомления,отправленные в качестве испускаемых элементов,или обратить этот процесс вспять.</target>
        </trans-unit>
        <trans-unit id="fc9aca251c84d76a6a0d931957efb486d507bcc2" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can prompt an Observable to begin emitting items at a time of your choosing.</source>
          <target state="translated">похож на обычный Наблюдаемый,за исключением того,что он начинает излучать элементы не тогда,когда на него подписан,а только тогда,когда к нему применен оператор Connect.Таким образом,вы можете попросить Наблюдателя начать испускать элементы в выбранное вами время.</target>
        </trans-unit>
        <trans-unit id="fd09d85570e685cf25806e8c97a9cae9bc76d4c3" translate="yes" xml:space="preserve">
          <source>resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when the Connect operator is applied to it. In this way you can wait for all intended observers to subscribe to the Observable before the Observable begins emitting items.</source>
          <target state="translated">похож на обычный Наблюдаемый,за исключением того,что он начинает излучать элементы не тогда,когда на него подписан,а только тогда,когда к нему применен оператор Connect.Таким образом,вы можете дождаться,пока все предполагаемые наблюдатели подпишутся на Наблюдатель,прежде чем Наблюдатель начнет испускать элементы.</target>
        </trans-unit>
        <trans-unit id="97a2a5e27c5d084c0dd5bee32de01ad786ad79e8" translate="yes" xml:space="preserve">
          <source>retrieve data</source>
          <target state="translated">извлекать данные</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="614fab05e39a4e771b71b18872fad9237db48830" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onError</source>
          <target state="translated">возвращает сингл,который также вызывает метод,указанный вами при вызове onError.</target>
        </trans-unit>
        <trans-unit id="2cbcba5aecafd2534b89b0451d26040bd4880f33" translate="yes" xml:space="preserve">
          <source>returns a Single that also calls a method you specify when it calls onSuccess</source>
          <target state="translated">возвращает сингл,который также вызывает метод,указанный вами при вызове onSuccess.</target>
        </trans-unit>
        <trans-unit id="de9f4dcfa7411bbd303b05c9c4d627cf206844d3" translate="yes" xml:space="preserve">
          <source>returns a Single that emits a specified item</source>
          <target state="translated">возвращает сингл,который испускает определенный элемент</target>
        </trans-unit>
        <trans-unit id="789a106c2f647946e92573c3b1777edc55349f0a" translate="yes" xml:space="preserve">
          <source>returns a Single that emits an item that is the result of a function applied to items emitted by two or more other Singles</source>
          <target state="translated">возвращает Одиночный,который испускает элемент,являющийся результатом функции,применяемой к элементам,испускаемым двумя или более другими Одиночками.</target>
        </trans-unit>
        <trans-unit id="19e291b4d133b23269dc04e8ef9d5fe9961d07e2" translate="yes" xml:space="preserve">
          <source>returns a Single that emits the result of a function applied to the item emitted by the source Single</source>
          <target state="translated">возвращает сингл,излучающий результат функции,примененной к элементу,излучаемому источником сингл</target>
        </trans-unit>
        <trans-unit id="ae8c346ab8cb11f2953656ad7208884e7770d344" translate="yes" xml:space="preserve">
          <source>returns a Single that immediately notifies subscribers of an error</source>
          <target state="translated">возвращает сингл,который немедленно уведомляет абонентов об ошибке.</target>
        </trans-unit>
        <trans-unit id="644da51fb0f4c8e691099129ff2c304b9011980b" translate="yes" xml:space="preserve">
          <source>returns a Single that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">возвращает сингл,который является результатом функции,примененной к элементу,излучаемому синглом</target>
        </trans-unit>
        <trans-unit id="9d99fbe394a3cd2d6250690cb04bc2bae5e7789b" translate="yes" xml:space="preserve">
          <source>returns a Single that makes an error notification if the source Single does not emit a value in a specified time period</source>
          <target state="translated">возвращает сингл,который делает уведомление об ошибке,если источник сингл не выдает значение в указанный период времени</target>
        </trans-unit>
        <trans-unit id="ccc187c8d1099bc534bf656707e72f0b93487700" translate="yes" xml:space="preserve">
          <source>returns an Observable that is the result of a function applied to an item emitted by a Single</source>
          <target state="translated">возвращает &quot;Наблюдаемое&quot;,которое является результатом функции,примененной к элементу,излучаемому одиночным</target>
        </trans-unit>
        <trans-unit id="2d2ace357f46b9793f247eb0f1b39b5c06f1c284" translate="yes" xml:space="preserve">
          <source>schedules work as soon as possible on the current thread</source>
          <target state="translated">графики работают как можно быстрее на текущем потоке</target>
        </trans-unit>
        <trans-unit id="e2a05abe2afd449104bbe88995191b2546c2e36e" translate="yes" xml:space="preserve">
          <source>schedules work as though it were occurring at an arbitrary historical time</source>
          <target state="translated">графики работают так,как будто это происходит в произвольное историческое время.</target>
        </trans-unit>
        <trans-unit id="212804707d4553d4a9de98cd16a47586293da44e" translate="yes" xml:space="preserve">
          <source>schedules work by means of a timed callback</source>
          <target state="translated">графики работы посредством синхронизированного обратного вызова</target>
        </trans-unit>
        <trans-unit id="0c6afaa2e04609f1ec3894129ba5ef333342b74b" translate="yes" xml:space="preserve">
          <source>schedules work immediately on the current thread</source>
          <target state="translated">графики работы сразу же работают на текущей нити</target>
        </trans-unit>
        <trans-unit id="6fd22fa59e4504bd3abe47116c75ba5d9520c2e4" translate="yes" xml:space="preserve">
          <source>schedules work to begin immediately in the current thread</source>
          <target state="translated">графики работы начинать немедленно в текущем потоке</target>
        </trans-unit>
        <trans-unit id="ec5b10f224197c50b751cb29d575291de5a89193" translate="yes" xml:space="preserve">
          <source>shift the emissions from an Observable forward in time by a particular amount</source>
          <target state="translated">переносить выбросы из наблюдаемого во времени на определенное количество.</target>
        </trans-unit>
        <trans-unit id="b6974d3c4c90f4bf308b7ceaad732a8411683831" translate="yes" xml:space="preserve">
          <source>single items</source>
          <target state="translated">единичные предметы</target>
        </trans-unit>
        <trans-unit id="4685ae520d469fe19757bc73a43fbb3e23d2eb64" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this absolute time</source>
          <target state="translated">Пропускает элементы из источника Наблюдается до этого абсолютного времени</target>
        </trans-unit>
        <trans-unit id="ec4661659182b1a32546f8ee26df269f5ff633bd" translate="yes" xml:space="preserve">
          <source>skips items from the source Observable until this many milliseconds have passed since the Observable was subscribed to</source>
          <target state="translated">пропускает предметы из источника Наблюдаемый до тех пор,пока не пройдет столько миллисекунд,сколько прошло с тех пор,как Наблюдаемый был подписан на</target>
        </trans-unit>
        <trans-unit id="d722e800457c1e3ff47b9919aacf412d58517e76" translate="yes" xml:space="preserve">
          <source>so that similar items end up on the same Observable</source>
          <target state="translated">чтобы похожие предметы оказались на одном и том же наблюдательном месте.</target>
        </trans-unit>
        <trans-unit id="23f99c77497b013cb84fa93d00cd562cd60bc053" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an Observable will operate</source>
          <target state="translated">укажите Планировщик,на котором будет работать Наблюдатель.</target>
        </trans-unit>
        <trans-unit id="c1af98d719e46cb1c263d1f07f1d142225f032b5" translate="yes" xml:space="preserve">
          <source>specify the Scheduler on which an observer will observe this Observable</source>
          <target state="translated">Укажите Планировщик,на котором наблюдатель будет наблюдать за этим Наблюдателем.</target>
        </trans-unit>
        <trans-unit id="8cc70babc917973e7be2341bdf842422d8559507" translate="yes" xml:space="preserve">
          <source>start any unstarted actions that have been scheduled for a time equal to or earlier than the present time according to the Scheduler&amp;rsquo;s clock</source>
          <target state="translated">запускать любые невыполненные действия, которые были запланированы на время, равное или более раннее, чем настоящее время, по часам Планировщика</target>
        </trans-unit>
        <trans-unit id="d9b4f1177afce043722bb47561fbe3b4f6b4cb6b" translate="yes" xml:space="preserve">
          <source>strategies for coping with Observables that produce items more rapidly than their observers consume them</source>
          <target state="translated">стратегии решения проблем с &quot;Наблюдателями&quot;,которые производят продукцию быстрее,чем их наблюдатели потребляют ее.</target>
        </trans-unit>
        <trans-unit id="22fd962474489207eb05adb7a8bcf49b937562b8" translate="yes" xml:space="preserve">
          <source>subscribe a single function to either the &lt;code&gt;onNext&lt;/code&gt;, the &lt;code&gt;onCompleted&lt;/code&gt;, or &lt;code&gt;onError&lt;/code&gt; notifications from an Observable, with &lt;code&gt;subscribeOnNext&lt;/code&gt;, &lt;code&gt;subscribeOnCompleted&lt;/code&gt;, or &lt;code&gt;subscribeOnError&lt;/code&gt; respectively</source>
          <target state="translated">подписать одну функцию на &lt;code&gt;onNext&lt;/code&gt; , &lt;code&gt;onCompleted&lt;/code&gt; или &lt;code&gt;onError&lt;/code&gt; от Observable с помощью &lt;code&gt;subscribeOnNext&lt;/code&gt; , &lt;code&gt;subscribeOnCompleted&lt;/code&gt; или &lt;code&gt;subscribeOnError&lt;/code&gt; соответственно</target>
        </trans-unit>
        <trans-unit id="e9b287045b72e71494407f32ddc237ffeab5305a" translate="yes" xml:space="preserve">
          <source>subscribe by passing zero to three individual functions, or an object that implements those three functions, into either the &lt;code&gt;subscribe&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; operator (those operators behave identically).</source>
          <target state="translated">subscribe, передав ноль трем отдельным функциям или объекту, реализующему эти три функции, в оператор &lt;code&gt;subscribe&lt;/code&gt; или &lt;code&gt;forEach&lt;/code&gt; (эти операторы ведут себя одинаково).</target>
        </trans-unit>
        <trans-unit id="ec9eb83261701c10244989eda4480cd0bc34282e" translate="yes" xml:space="preserve">
          <source>subscribeOn</source>
          <target state="translated">subscribeOn</target>
        </trans-unit>
        <trans-unit id="2f11a7869397c6279959fc770e96943449c6adc0" translate="yes" xml:space="preserve">
          <source>subscribes</source>
          <target state="translated">subscribes</target>
        </trans-unit>
        <trans-unit id="e45026cdc19b9b8ae7cd208d230ff92042c526de" translate="yes" xml:space="preserve">
          <source>subscribing</source>
          <target state="translated">subscribing</target>
        </trans-unit>
        <trans-unit id="a73cae38ca4e4c1f5ee35e5e1ab9e4023e603395" translate="yes" xml:space="preserve">
          <source>suppress duplicate items emitted by an Observable</source>
          <target state="translated">подавлять дубликаты,излучаемые наблюдателем.</target>
        </trans-unit>
        <trans-unit id="e82088f5062344b73a3c19fab602396d690426d8" translate="yes" xml:space="preserve">
          <source>suppress the final</source>
          <target state="translated">подавить финальный</target>
        </trans-unit>
        <trans-unit id="c3865777c46bf1ae284de15cd7c85a4f6890eb77" translate="yes" xml:space="preserve">
          <source>suppress the first</source>
          <target state="translated">подавить первый</target>
        </trans-unit>
        <trans-unit id="771a09735788ce147033478f20360728d165bee2" translate="yes" xml:space="preserve">
          <source>synchronous</source>
          <target state="translated">synchronous</target>
        </trans-unit>
        <trans-unit id="2e573610264014eeec724ea567a1ed662b27b45c" translate="yes" xml:space="preserve">
          <source>that completes without emitting items</source>
          <target state="translated">который завершается без выброса предметов</target>
        </trans-unit>
        <trans-unit id="6f08197d25304fd5b825dcbe7bf93275b3eb3552" translate="yes" xml:space="preserve">
          <source>that does nothing at all</source>
          <target state="translated">который ничего не делает</target>
        </trans-unit>
        <trans-unit id="137ab2573eaf4b29b027095f579031c127475086" translate="yes" xml:space="preserve">
          <source>that emits a particular item</source>
          <target state="translated">который испускает конкретную вещь</target>
        </trans-unit>
        <trans-unit id="6bf394b782612eca525f4d43bc05228830887d33" translate="yes" xml:space="preserve">
          <source>that emits a sequence of integers</source>
          <target state="translated">который испускает последовательность целых чисел</target>
        </trans-unit>
        <trans-unit id="eaba046ca8704fac01dd6cf9c5c9f14a5b897381" translate="yes" xml:space="preserve">
          <source>that emits a sequence of items repeatedly</source>
          <target state="translated">который многократно испускает последовательность элементов</target>
        </trans-unit>
        <trans-unit id="f1576e1882f41d1921a68f8fa5d3280da8029b02" translate="yes" xml:space="preserve">
          <source>that is</source>
          <target state="translated">то есть</target>
        </trans-unit>
        <trans-unit id="d58317eedc0e0cc19a4dc5d96db7c79390bc0b2a" translate="yes" xml:space="preserve">
          <source>that is, after a second Observable emits an item</source>
          <target state="translated">то есть,после того,как &quot;Наблюдатель&quot; во второй раз испускает предмет.</target>
        </trans-unit>
        <trans-unit id="b4ced51c288fff2a228b4b03d3034f929b53765c" translate="yes" xml:space="preserve">
          <source>that is, after an initial period of time</source>
          <target state="translated">то есть,по прошествии первоначального периода времени</target>
        </trans-unit>
        <trans-unit id="d502ddf269ba3ba29f4b31ede202ce4f248f11c0" translate="yes" xml:space="preserve">
          <source>that is, after the first</source>
          <target state="translated">то есть,после первого</target>
        </trans-unit>
        <trans-unit id="01cc9507a2b962ed7290a559771e31f3dd47508e" translate="yes" xml:space="preserve">
          <source>that is, except items emitted after a second Observable emits an item</source>
          <target state="translated">то есть,за исключением предметов,испускаемых после второго Наблюдательный испускает предмет.</target>
        </trans-unit>
        <trans-unit id="89722a4afc7485cc8282bfed94d1db2a8c8f45ed" translate="yes" xml:space="preserve">
          <source>that is, except items emitted during a period of time before the source completes</source>
          <target state="translated">то есть,за исключением элементов,излучаемых в течение периода времени,предшествующего завершению работы источника.</target>
        </trans-unit>
        <trans-unit id="86b3a5ff44246b1dc9bf253021af4f997751b277" translate="yes" xml:space="preserve">
          <source>that is, except the last</source>
          <target state="translated">то есть,кроме последнего</target>
        </trans-unit>
        <trans-unit id="1c2fb5718217fbc77a780b296d5448ce0bb0e328" translate="yes" xml:space="preserve">
          <source>that is, only item</source>
          <target state="translated">то есть,только пункт</target>
        </trans-unit>
        <trans-unit id="8807128feac25173baec8dcaa137f183e7a46065" translate="yes" xml:space="preserve">
          <source>that is, only the first item</source>
          <target state="translated">то есть,только первый пункт</target>
        </trans-unit>
        <trans-unit id="1d01cf788cdb4ae54d6a0508037ae8d98e426919" translate="yes" xml:space="preserve">
          <source>that is, only the first item&lt;em&gt;s&lt;/em&gt;</source>
          <target state="translated">то есть только первый элемент &lt;em&gt;s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd465f2210bfb7e46979cf54ded4dff6ec1692e2" translate="yes" xml:space="preserve">
          <source>that is, only the last item</source>
          <target state="translated">то есть,только последний пункт</target>
        </trans-unit>
        <trans-unit id="46d9efc58a8899c1bd6830365dfe0851a789a47b" translate="yes" xml:space="preserve">
          <source>that is, only those items after the first items</source>
          <target state="translated">то есть,только те предметы после первых.</target>
        </trans-unit>
        <trans-unit id="3fd810f67e4b6418880cdf9e79b297644e46f98f" translate="yes" xml:space="preserve">
          <source>that is, those items except the last items</source>
          <target state="translated">то есть,те предметы,кроме последних.</target>
        </trans-unit>
        <trans-unit id="7c8e5e79724ffb693a8f10afdcf74a756e2dfb2e" translate="yes" xml:space="preserve">
          <source>that is, until one of those items matches a predicate</source>
          <target state="translated">то есть до тех пор,пока один из этих предметов не совпадет с предикатом.</target>
        </trans-unit>
        <trans-unit id="6c250c837d9328117e7d1fb1c5750a7f1aab95c0" translate="yes" xml:space="preserve">
          <source>that obtains its sequence from a Future</source>
          <target state="translated">который получает свою последовательность из будущего</target>
        </trans-unit>
        <trans-unit id="e6b1daad8550bcc7c6c2ef78b7c5e5eeba2c7ec2" translate="yes" xml:space="preserve">
          <source>that pulls its emissions from a particular &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Iterable&lt;/code&gt;, or something like that</source>
          <target state="translated">который извлекает свои выбросы из определенного &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Iterable&lt;/code&gt; или чего-то в этом роде</target>
        </trans-unit>
        <trans-unit id="5446f7a00c20f00c1e1272456e1e623cd6777342" translate="yes" xml:space="preserve">
          <source>that was returned from a function called at subscribe-time</source>
          <target state="translated">который был возвращен из функции,вызванной в абонентское время.</target>
        </trans-unit>
        <trans-unit id="36ddf980b2667dd715828894e3fc3042cbedc25b" translate="yes" xml:space="preserve">
          <source>that was returned from an &lt;code&gt;Action&lt;/code&gt;, &lt;code&gt;Callable&lt;/code&gt;, &lt;code&gt;Runnable&lt;/code&gt;, or something of that sort, called at subscribe-time</source>
          <target state="translated">который был возвращен из &lt;code&gt;Action&lt;/code&gt; , &lt;code&gt;Callable&lt;/code&gt; , &lt;code&gt;Runnable&lt;/code&gt; или чего-то в этом роде, вызванного во время подписки</target>
        </trans-unit>
        <trans-unit id="4d322a2a1ed8b229ce64a28e0f9a6b07bd805cb7" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; on which this operator will operate</source>
          <target state="translated">&lt;a href=&quot;../scheduler&quot;&gt;Scheduler&lt;/a&gt; , на котором этот оператор будет работать</target>
        </trans-unit>
        <trans-unit id="f54428f31bc9cd665202c66e3529743413a51ebf" translate="yes" xml:space="preserve">
          <source>the Observable from which that item was emitted</source>
          <target state="translated">Наблюдаемый,из которого это изделие было выброшено</target>
        </trans-unit>
        <trans-unit id="45e5c3a5cdeb1e41ae2ba979a9fbbc2879407cb0" translate="yes" xml:space="preserve">
          <source>the Scheduler you want this operator to use</source>
          <target state="translated">Планировщик,который вы хотите,чтобы этот оператор использовал...</target>
        </trans-unit>
        <trans-unit id="619d6ec67e945d9c20afba296213710299061ec9" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that an error has occurred (an Iterable throws an exception if an error takes place during iteration; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onError&lt;/code&gt; method)</source>
          <target state="translated">способность производителя сигнализировать потребителю о том, что произошла ошибка (Iterable выдает исключение, если ошибка происходит во время итерации; Observable вызывает метод &lt;code&gt;onError&lt;/code&gt; своего наблюдателя )</target>
        </trans-unit>
        <trans-unit id="ccf54bc28a9d5977bbe47958144f3f09e7562dd0" translate="yes" xml:space="preserve">
          <source>the ability for the producer to signal to the consumer that there is no more data available (a foreach loop on an Iterable completes and returns normally in such a case; an Observable calls its observer&amp;rsquo;s &lt;code&gt;onCompleted&lt;/code&gt; method)</source>
          <target state="translated">возможность для производителя сигнализировать потребителю, что больше нет доступных данных (цикл foreach в Iterable завершается и в этом случае возвращается нормально; Observable вызывает метод &lt;code&gt;onCompleted&lt;/code&gt; своего наблюдателя )</target>
        </trans-unit>
        <trans-unit id="d36f5da1557da2000be76f162419f2842d8b6a66" translate="yes" xml:space="preserve">
          <source>the age, in milliseconds, at which items in this buffer may be discarded without being emitted to subsequent observers</source>
          <target state="translated">возраст,в миллисекундах,при котором элементы в этом буфере могут быть выброшены,не передаваясь последующим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="a5c4d53c7c902b1b5cc8e185eede65fdb2de0277" translate="yes" xml:space="preserve">
          <source>the default Observable to emit if the key does not associate with any Observables</source>
          <target state="translated">по умолчанию &quot;Наблюдаемый&quot;,если ключ не ассоциируется с какими-либо &quot;Наблюдаемыми&quot;.</target>
        </trans-unit>
        <trans-unit id="1d113d4b461ba7203000f1bb511ee26f86e995a0" translate="yes" xml:space="preserve">
          <source>the emitted item</source>
          <target state="translated">испускаемый элемент</target>
        </trans-unit>
        <trans-unit id="85e12c825e42525a7d38c934221156be2a4c8aad" translate="yes" xml:space="preserve">
          <source>the first item it emitted</source>
          <target state="translated">первый элемент,который он выбросил</target>
        </trans-unit>
        <trans-unit id="be4ce820ddeef4daec91cbf71555e93b8ca55a74" translate="yes" xml:space="preserve">
          <source>the first item to emit</source>
          <target state="translated">первый выброшенный элемент</target>
        </trans-unit>
        <trans-unit id="2fe008fb64922cd4f3a3244147ca04018865ec96" translate="yes" xml:space="preserve">
          <source>the index of that item in the sequence of emitted items</source>
          <target state="translated">индекс этого элемента в последовательности испускаемых элементов</target>
        </trans-unit>
        <trans-unit id="52694b753f3d0d4d183a51c70e89116a83fafd9c" translate="yes" xml:space="preserve">
          <source>the item emitted by the source Observable</source>
          <target state="translated">объект,излучаемый источником Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="f6eb842cfde4474cc55d27b11fda28c9d0974ca2" translate="yes" xml:space="preserve">
          <source>the item from the source Observable to be, or not be, filtered</source>
          <target state="translated">пункт из источника Наблюдается быть отфильтрованным или не быть отфильтрованным</target>
        </trans-unit>
        <trans-unit id="f63828e115c31506deec5330c6cf7da6f1662e64" translate="yes" xml:space="preserve">
          <source>the last item emitted before it completed</source>
          <target state="translated">последний пункт,высвобожденный до его завершения</target>
        </trans-unit>
        <trans-unit id="4cd52010a84449eec942d8a7eb5de34cdaf5ca8d" translate="yes" xml:space="preserve">
          <source>the maximum number of items to buffer and replay to subsequent observers</source>
          <target state="translated">максимальное количество элементов для буферизации и воспроизведения последующим наблюдателям.</target>
        </trans-unit>
        <trans-unit id="f19cdb5df71b1ff17e9df3a1799991559db40ebf" translate="yes" xml:space="preserve">
          <source>the second Observable to combine with the source Observable</source>
          <target state="translated">Второй Наблюдаемый в сочетании с источником Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="825f395e1e2ab0a50e58a2e578f9cda252845ec2" translate="yes" xml:space="preserve">
          <source>the sole item it emitted</source>
          <target state="translated">единственное изделие,которое оно выпустило</target>
        </trans-unit>
        <trans-unit id="c4b48660e367f953c340a09afe02029b181943ea" translate="yes" xml:space="preserve">
          <source>the source Observable</source>
          <target state="translated">Источник Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="626662ed5d32414ca0a11f0bb9a64034f3068433" translate="yes" xml:space="preserve">
          <source>the source Observable itself</source>
          <target state="translated">сам источник Наблюдаемый</target>
        </trans-unit>
        <trans-unit id="f2213513da8d036c5bb0db7e96282e717db28520" translate="yes" xml:space="preserve">
          <source>the source Observable object</source>
          <target state="translated">источник Наблюдаемый объект</target>
        </trans-unit>
        <trans-unit id="02901a674fe43f7fbed3f5d4d20d10d2585b59f3" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item</source>
          <target state="translated">нулевой индекс этого пункта</target>
        </trans-unit>
        <trans-unit id="ff4fd068ef5334d397a2b9b95bad44dfbeb439ec" translate="yes" xml:space="preserve">
          <source>the zero-based index of that item in the sequence of emissions</source>
          <target state="translated">нулевой индекс этого пункта в последовательности выбросов</target>
        </trans-unit>
        <trans-unit id="199a3fba451a63af3f467158fd6bc54160f86199" translate="yes" xml:space="preserve">
          <source>the zero-based index of this item in the source Observable&amp;rsquo;s sequence</source>
          <target state="translated">отсчитываемый от нуля индекс этого элемента в исходной последовательности Observable</target>
        </trans-unit>
        <trans-unit id="c9f0ba0696d964a4bf6f877db29a8efb87a7b004" translate="yes" xml:space="preserve">
          <source>throws &lt;code&gt;Exception&lt;/code&gt;</source>
          <target state="translated">выбрасывает &lt;code&gt;Exception&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8d37cb543750abf8a4e771b12e8265926a1ad7" translate="yes" xml:space="preserve">
          <source>timeInterval</source>
          <target state="translated">timeInterval</target>
        </trans-unit>
        <trans-unit id="56d3c9490be2608ac36f5a4805bfec2f21f7f982" translate="yes" xml:space="preserve">
          <source>timeout</source>
          <target state="translated">timeout</target>
        </trans-unit>
        <trans-unit id="11a572aecafbc0f74cba80722d6c2694c9293479" translate="yes" xml:space="preserve">
          <source>times.</source>
          <target state="translated">times.</target>
        </trans-unit>
        <trans-unit id="918300a03ee028633b64dfc10ce94f1efc51260f" translate="yes" xml:space="preserve">
          <source>to an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d803915a4dc5f4f1acc85a7a1052d8c8f251981" translate="yes" xml:space="preserve">
          <source>to its observers by calling the observers&amp;rsquo; methods.</source>
          <target state="translated">своим наблюдателям, вызывая методы наблюдателей.</target>
        </trans-unit>
        <trans-unit id="21b9896d15067b60a96aa46fce0956d921771516" translate="yes" xml:space="preserve">
          <source>toObservable</source>
          <target state="translated">toObservable</target>
        </trans-unit>
        <trans-unit id="d8603afc294b77cdaeff4436109d5ad84fb688d6" translate="yes" xml:space="preserve">
          <source>toSingle</source>
          <target state="translated">toSingle</target>
        </trans-unit>
        <trans-unit id="5886afa49f59f5bfc349ccddbbe20abdb26c5961" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable by applying a function to each item</source>
          <target state="translated">преобразовывать элементы,излучаемые наблюдателем,путем применения к каждому элементу функции</target>
        </trans-unit>
        <trans-unit id="e7e43a876519041c58cbce9e04a1a2a77efd52b2" translate="yes" xml:space="preserve">
          <source>transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable</source>
          <target state="translated">преобразовать элементы,выделяемые наблюдателем,в наблюдаемые,а затем сгладить выбросы от них в один наблюдаемый элемент</target>
        </trans-unit>
        <trans-unit id="7b55b668d2a03c54e10abf0fd560513c61800ce9" translate="yes" xml:space="preserve">
          <source>uses the specified &lt;code&gt;Executor&lt;/code&gt; as a Scheduler</source>
          <target state="translated">использует указанный &lt;code&gt;Executor&lt;/code&gt; в качестве планировщика</target>
        </trans-unit>
        <trans-unit id="963d96d958581e9e92f9acda78fb37f3bb8bfb40" translate="yes" xml:space="preserve">
          <source>when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function</source>
          <target state="translated">когда элемент испускается одним из двух &quot;Наблюдателей&quot;,объединить последний элемент,испускаемый каждым &quot;Наблюдателем&quot; через указанную функцию и испускать элементы по результатам этой функции</target>
        </trans-unit>
        <trans-unit id="04387f9309cd75011a40ab7c3031310e01c65092" translate="yes" xml:space="preserve">
          <source>when it notifies observers</source>
          <target state="translated">когда он уведомляет наблюдателей</target>
        </trans-unit>
        <trans-unit id="aae0fdc01ec4cc0d21d70383d00a3276d2b7b563" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;any&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">всякий раз, когда &lt;em&gt;какой-либо&lt;/em&gt; из Observables испускает новый элемент</target>
        </trans-unit>
        <trans-unit id="6c2b43179a8c8aafdb4b0d4f3fa3fcebb34c76a6" translate="yes" xml:space="preserve">
          <source>whenever &lt;em&gt;each&lt;/em&gt; of the Observables has emitted a new item</source>
          <target state="translated">всякий раз, когда &lt;em&gt;каждый&lt;/em&gt; из Observables испускает новый элемент</target>
        </trans-unit>
        <trans-unit id="f8e0b9e60ec000d6cd35e093097dfdd7a273c623" translate="yes" xml:space="preserve">
          <source>whenever an item is emitted by one Observable in a window defined by an item emitted by another</source>
          <target state="translated">всякий раз,когда объект испускается одним наблюдателем в окне,определенном объектом,испускаемым другим наблюдателем.</target>
        </trans-unit>
        <trans-unit id="dd83d0039aa92f3974d649a8a17ef435d5ade767" translate="yes" xml:space="preserve">
          <source>which I can then unwrap again with</source>
          <target state="translated">которую я могу снова развернуть</target>
        </trans-unit>
        <trans-unit id="b62562770a1246a8815b67b0d1d644b0e1c1d831" translate="yes" xml:space="preserve">
          <source>which will be used instead of the item itself when comparing two items for distinctness</source>
          <target state="translated">который будет использоваться вместо самого предмета при сравнении двух предметов для отличия.</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
        <trans-unit id="8a5c4039855db169827c66fcbbc8371e8cc25f57" translate="yes" xml:space="preserve">
          <source>zip and zipWith</source>
          <target state="translated">застёжка-молнияС помощью</target>
        </trans-unit>
        <trans-unit id="cb92618013b7da045d179e02a557fe63872457d2" translate="yes" xml:space="preserve">
          <source>zipWith</source>
          <target state="translated">zipWith</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
