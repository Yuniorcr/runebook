<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">Функции отслеживания и контроля исполнения.</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">Функции модуля &lt;code&gt;GHC.Stack&lt;/code&gt; можно использовать для получения текущего стека и его рендеринга.</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">Функции загружаются из MAPI DLL</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">Функции на струнах</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">Функции на типовых буквах</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">Функции,которые могут быть сплавлены компилятором,документируются фразой &quot;Subject to fusion&quot; (подлежит слиянию).</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">Функции,часто используемые при чтении текстовых данных.</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">занятия по фанктору и монаде</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">Функторы,представляющие структуры данных,которые можно перемещать слева направо.</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">К этому оператору &lt;code&gt;let&lt;/code&gt; можно добавить дополнительные привязки , поэтому GHCi указывает, что следующая строка продолжает предыдущую, изменяя приглашение. Обратите внимание , что расположение в сущности, так , чтобы добавить больше привязок к этому &lt;code&gt;let&lt;/code&gt; мы должны выстроить их:</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">Кроме того,любое определение должно удовлетворять следующим требованиям:</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Кроме того, GHC позволяет указать способ записи данных журнала событий (см. &lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; ) с помощью настраиваемого &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">Кроме того,GHC предлагает легкий механизм аннотирования,который можно использовать для аннотирования исходного кода с помощью метаданных,которые можно впоследствии просматривать либо с помощью API компилятора,либо с помощью плагина компилятора.</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">Кроме того,GHCi распечатает результат действия ввода/вывода,если (и только если):</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">Более того,как показано ниже,у Вас могут возникнуть большие проблемы при выполнении программ,скомпилированных с использованием нестабильных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">Кроме того, различные переменные лексического типа обозначают переменные разных типов. Это означает, что каждая сигнатура типа, написанная программистом (включая сигнатуру, содержащую переменные типа со свободной областью видимости), обозначает &lt;em&gt;жесткий&lt;/em&gt; тип; то есть тип полностью известен средству проверки типов, и никакого вывода не требуется.</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">Более того, для каждого конструктора типа существует экземпляр, который позволяет выполнять приведение под конструктор типа. Например, пусть &lt;code&gt;D&lt;/code&gt; будет конструктором прототипа типа ( &lt;code&gt;data&lt;/code&gt; или &lt;code&gt;newtype&lt;/code&gt; ) с тремя аргументами типа, которые имеют роли &lt;code&gt;nominal&lt;/code&gt; , &lt;code&gt;representational&lt;/code&gt; соответственно. &lt;code&gt;phantom&lt;/code&gt; . Затем есть экземпляр формы</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">Кроме того, операции &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; должны соотноситься следующим образом:</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">Кроме того, закрывающий &lt;code&gt;#-}&lt;/code&gt; должен начинаться в столбце справа от открывающего &lt;code&gt;{-#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">Более того, тип &lt;code&gt;t&lt;/code&gt; должен иметь экземпляр &lt;code&gt;Typeable&lt;/code&gt; . Следовательно, следующее незаконно:</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">Кроме того,мы ограничиваем следующие возможности:</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; - ориентированные функции для преобразования &lt;code&gt;Text&lt;/code&gt; несколько распространенных кодировок.</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; - ориентированные функции для преобразования ленивого &lt;code&gt;Text&lt;/code&gt; несколько распространенных кодировок.</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">Будущие версии &lt;code&gt;integer_gmp&lt;/code&gt; могут больше не поддерживать отрицательные значения &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">Ответные файлы в стиле GCC.</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC (в основном) соответствует интерфейсу внешних функций Haskell, определение которого является частью отчета Haskell на &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC (с &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , как всегда) пытается встроить (или &amp;laquo;развернуть&amp;raquo;) функции / значения, которые &amp;laquo;достаточно малы&amp;raquo;, таким образом избегая накладных расходов на вызовы и, возможно, подвергая другие более замечательные оптимизации. GHC имеет набор эвристик, настраиваемых в течение длительного периода времени с использованием множества тестов, которые решают, когда выгодно встроить функцию на ее сайте вызова. Эвристика предназначена для встраивания функций, когда это кажется полезным, но без чрезмерного раздувания кода. Если функция выглядит слишком большой, она не будет встроена, а для функций, размер которых превышает определенный размер, даже не будет экспортировано их определение в файл интерфейса. Некоторые из пороговых значений, которые управляют этими эвристическими решениями, можно изменить с помощью флагов, см. &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-F *: независимые от платформы флаги&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8 может вычислять арифметические выражения, содержащие натуральные числа уровня типа. Такие выражения могут быть построены с использованием семейств типов &lt;code&gt;(+), (*), (^)&lt;/code&gt; для сложения, умножения и возведения в степень. Числа можно сравнивать с помощью &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; , Который возвращает повышенное логическое значение, или &lt;code&gt;(&amp;lt;=)&lt;/code&gt; , который сравнивает числа как ограничение. Например:</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8 расширяет идею полиморфизма видов, объявляя, что типы и виды действительно являются одним и тем же. Ничто в GHC не делает различий между типами и видами. Другой способ думать об этом заключается в том, что тип &lt;code&gt;Bool&lt;/code&gt; и &amp;laquo;продвинутый тип&amp;raquo; &lt;code&gt;Bool&lt;/code&gt; на самом деле идентичны. (Обратите внимание, что термин &lt;code&gt;True&lt;/code&gt; и тип &lt;code&gt;'True&lt;/code&gt; по-прежнему различны, потому что первый может использоваться в выражениях, а второй - в типах.) Отсутствие различия между типами и видами является отличительной чертой языков с зависимой типизацией. Языки с полностью зависимой типизацией также устраняют разницу между выражениями и типами, но сделать это в GHC - это уже история для другого дня.</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2 поддерживает подписи модулей ( файлы &lt;code&gt;hsig&lt;/code&gt; ), которые позволяют писать подпись вместо реализации модуля, откладывая выбор реализации на более поздний момент времени. Эта функция не предназначена для использования без &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Кабала&lt;/a&gt; ; в этой ручной записи основное внимание уделяется синтаксису и семантике подписей.</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC-удлинители:это одобренный способ получить GHC-удлинители.</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">Примечание GHC: чтобы вызвать &lt;code&gt;waitForProcess&lt;/code&gt; , не блокируя все другие потоки в системе, вы должны скомпилировать программу с &lt;code&gt;-threaded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">GHC принимает &lt;strong&gt;отклонение, если есть сомнения&lt;/strong&gt; . Мы видим, насколько это болезненно на практике, и при необходимости попробуем что-нибудь более амбициозное.</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">GHC выделяет небольшой объем локальной памяти потока, когда поток вызывает функцию Haskell через &lt;code&gt;foreign export&lt;/code&gt; . Эта память обычно не освобождается до &lt;code&gt;hs_exit()&lt;/code&gt; ; память кэшируется, поэтому последующие вызовы Haskell выполняются быстро. Однако, если ваше приложение работает долго и постоянно создает новые потоки, вызывающие Haskell, вы, вероятно, захотите освободить эту память в тех потоках, которые завершили вызов функций Haskell. Для этого вызовите &lt;code&gt;hs_thread_done()&lt;/code&gt; из потока, память которого вы хотите освободить.</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC позволяет использовать экзистенциалы и с синтаксисом записей.Например:</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC позволяет давать числовые буквы в десятичной,восьмеричной,шестнадцатеричной,двоичной или плавающей нотации.</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC позволяет автономное &lt;code&gt;deriving&lt;/code&gt; деклараций с помощью &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC позволяет конструкторам типов,классам и переменным типа быть операторами и быть написанным инффиксом,очень похожим на выражения.Точнее:</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC также разрешает применение видимого вида,где пользователи могут объявить аргументы вида,которые должны быть инстанциированы в добро-полиморфных случаях.Его использование параллельно с применением видимого типа на уровне терминов,как указано выше.</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC также поддерживает равенство по &lt;em&gt;типу и неоднородности&lt;/em&gt; , которое связывает два типа потенциально разных видов. Гетерогенное равенство пишется &lt;code&gt;~~&lt;/code&gt; . Вот виды &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;~~&lt;/code&gt; , чтобы лучше понять их разницу:</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC всегда обрабатывает &lt;em&gt;последний&lt;/em&gt; параметр экземпляра ( &lt;code&gt;Foo&lt;/code&gt; в этом примере) как тип, экземпляр которого является производным.</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC применяет к неявным параметрам страшное ограничение мономорфизма (раздел 4.5.5 отчета Хаскелла).Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC предполагает,что исходные файлы являются только ASCII или UTF-8,другие кодировки не распознаются.Однако недействительные последовательности в кодировке UTF-8 будут игнорироваться в комментариях,поэтому можно использовать другие кодировки,такие как Latin-1,при условии,что некомментируемый исходный код является только ASCII.</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC пытается определить, когда потоки зашли в тупик, используя сборщик мусора. Поток, который недоступен (не может быть найден по указателям от живых объектов), должен быть заблокирован, и в этом случае потоку отправляется исключение. Исключение составляют &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; , в зависимости от способа блокировки потока.</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC накапливает огромное количество информации об исходном файле Haskell во время его компиляции. Файлы расширенного интерфейса - это способ сохранить часть этой информации на диске, чтобы внешние инструменты, такие как IDE, могли избежать повторного синтаксического анализа, проверки типов и переименования. Эти файлы содержат</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC вычисляет отпечаток (фактически, хэш MD5) каждого файла интерфейса и каждого объявления в файле интерфейса. Он также хранит в каждом файле интерфейса список отпечатков всего, что он использовал при последней компиляции файла. Если дата изменения исходного файла раньше, чем дата файла &lt;code&gt;.o&lt;/code&gt; (т. Е. Источник не изменился с момента последней компиляции файла), и проверка перекомпиляции включена, GHC подойдет. Он сравнивает отпечатки пальцев на предметах, которые ему нужны на этот раз, с отпечатками на предметах, которые ему понадобились в прошлый раз (взяты из интерфейсного файла компилируемого модуля); если они все одинаковы, он прекращает компиляцию на ранней стадии процесса, говоря: &amp;laquo;Компиляция НЕ требуется&amp;raquo;. Какое красивое зрелище!</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">GHC может быть более агрессивным с кусками кода,если он знает,что они не экспортируются.</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC поставляется с несколькими библиотеками.Они описаны в отдельной документации.</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC поставляется с системой профилирования времени и пространства, так что вы можете ответить на такие вопросы, как &amp;laquo;почему моя программа такая медленная?&amp;raquo; Или &amp;laquo;почему моя программа использует так много памяти?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC медленно компилирует некоторые конструкции программы:</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC полностью игнорирует окружение с плавающей точкой,время выполнения не изменяет и не читает его.</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC создает подкаталог &lt;code&gt;.hpc&lt;/code&gt; в текущем каталоге и помещает &lt;code&gt;.mix&lt;/code&gt; файлы индекса HPC ( .mix ), по одному для каждого скомпилированного модуля. Вам не нужно беспокоиться об этих файлах: они содержат информацию, необходимую инструменту &lt;code&gt;hpc&lt;/code&gt; для создания данных покрытия для скомпилированных модулей после запуска программы.</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">В настоящее время GHC делает любезную проверку перед расширением синонимов (хотя даже это можно было бы изменить).</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">В настоящее время GHC использует очень простой синтаксический алгоритм сопоставления для сопоставления правила LHS с выражением. Он ищет замену, которая делает LHS и выражение синтаксически равными по модулю альфа-преобразования. Если необходимо, шаблон (правило), но не выражение, расширяется. (Это расширение выражения может привести к ошибкам &quot;лени&quot;.) Но не бета-преобразованием (это называется сопоставлением более высокого порядка).</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC устраняет неоднозначность между несколькими &lt;code&gt;COMPLETE&lt;/code&gt; наборами на основе этого объяснения. Чтобы сделать вещи более формальными, когда средство проверки сопоставления с образцом запрашивает набор конструкторов для некоторого конструктора типа данных &lt;code&gt;T&lt;/code&gt; , средство проверки возвращает:</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC снимает ограничение, как только узнает, какой конкретный литерал уровня типа используется в программе. Обратите внимание, что это работает только для &lt;em&gt;литералов,&lt;/em&gt; а не для произвольных выражений типов. Например, ограничение формы &lt;code&gt;KnownNat (a + b)&lt;/code&gt; будет &lt;em&gt;не&lt;/em&gt; быть упрощена &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; вместо этого GHC сохранит ограничение как есть, пока не сможет упростить &lt;code&gt;a + b&lt;/code&gt; до постоянного значения.</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC не позволяет иметь тип данных с контекстом,в котором упоминаются переменные типа,не являющиеся параметрами типа данных.Например:</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">GHC не выполняет разрешение фиксации в выражениях во время синтаксического анализа, как того требует Haskell 98 (но не Haskell 2010). Например, согласно отчету Haskell 98, следующее выражение допустимо:</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">GHC не нужно перезапускать для каждой компиляции, что означает, что он может кэшировать информацию между компиляциями. Компиляция многомодульной программы с помощью &lt;code&gt;ghc --make&lt;/code&gt; может быть в два раза быстрее, чем запуск &lt;code&gt;ghc&lt;/code&gt; отдельно для каждого исходного файла.</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC не реализует полную лень. Когда оптимизация &lt;code&gt;-fno-full-laziness&lt;/code&gt; и -fno-full-laziness не задана, выполняются некоторые преобразования, увеличивающие совместное использование, например, извлечение повторяющихся вычислений из цикла. Это те же преобразования, что и при полностью ленивой реализации, разница в том, что GHC не всегда применяет полную ленивость, поэтому не полагайтесь на нее.</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC гарантирует, что встраивание не может продолжаться вечно: каждая взаимно рекурсивная группа отсекается одним или несколькими &lt;em&gt;прерывателями цикла,&lt;/em&gt; которые никогда не встраиваются (см. &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Секреты встроенного модуля GHC, JFP 12 (4) июль 2002 г.&lt;/a&gt; ). GHC пытается не выбирать функцию с &lt;code&gt;INLINE&lt;/code&gt; в качестве прерывателя цикла, но когда выбора нет, можно выбрать даже функцию INLINE, и в этом случае прагма &lt;code&gt;INLINE&lt;/code&gt; игнорируется. Например, для саморекурсивной функции прерывателем цикла может быть только сама функция, поэтому прагма &lt;code&gt;INLINE&lt;/code&gt; всегда игнорируется.</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC предоставляет пользователям свои внутренние API через встроенный пакет ghc. Он позволяет вам писать программы, которые используют весь драйвер компиляции GHC для программного анализа или компиляции кода Haskell. Кроме того, GHC дает пользователям возможность загружать плагины компилятора во время компиляции - модули, которым разрешено просматривать и изменять внутреннее промежуточное представление GHC, Core. Плагины подходят для таких вещей, как экспериментальная оптимизация или анализ, и предлагают более низкий порог входа для разработки компилятора во многих распространенных случаях.</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC расширяет FFI с дополнительным вызывающему конференц - &lt;code&gt;prim&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC расширяет этот список еще на несколько классов,которые могут быть автоматически выведены:</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC имеет &lt;code&gt;-dynload&lt;/code&gt; связывания -dynload для выбора метода, который используется для поиска разделяемых библиотек во время выполнения. В настоящее время существует два режима:</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC имеет комплексный оптимизатор, поэтому, если вы действительно хотите пойти на это (и у вас есть свободное время), GHC может создавать довольно быстрый код. В качестве альтернативы вариант по умолчанию - скомпилировать как можно быстрее, не прилагая особых усилий для оптимизации сгенерированного кода (хотя GHC, вероятно, не то, что вы бы описали как быстрый компилятор :-).</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC имеет собственный решатель для &lt;code&gt;Typeable&lt;/code&gt; ограничений, которые включают класс Typeable , а рукописные экземпляры запрещены. Это гарантирует, что программист не сможет разрушить систему типов, написав поддельные экземпляры.</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC имеет несколько встроенных функций со специальным поведением.В частности:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">В GHC есть несколько опций, которые выбирают, какие типы сообщений о нефатальных ошибках, также известных как предупреждения, могут быть сгенерированы во время компиляции. Некоторые параметры управляют отдельными предупреждениями, а другие - коллекциями предупреждений. Чтобы отключить отдельное предупреждение &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; , используйте &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; . Чтобы отменить ошибку -Werror, которая превращает все предупреждения в ошибки, используйте &lt;code&gt;-Wwarn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC имеет экспериментальную поддержку &lt;em&gt;прореживания подписи&lt;/em&gt; , которая используется, когда подпись имеет явный список экспорта без экспорта модуля самой подписи. В этом случае список экспорта применяется к окончательному списку экспорта &lt;em&gt;после&lt;/em&gt; слияния, в частности, вы можете ссылаться на объекты, которые не объявлены в теле локального файла &lt;code&gt;hsig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC имеет крайне ненадежную поддержку &lt;em&gt;непредикативного полиморфизма&lt;/em&gt; , включенную с помощью &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; . Если бы это сработало, это означало бы, что вы &lt;em&gt;могли бы&lt;/em&gt; вызывать полиморфную функцию для полиморфного типа и параметризовать структуры данных по полиморфным типам. Например:</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC имеет возможность загружать плагины компилятора во время компиляции. Эта функция аналогична функции, предоставляемой &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt; , и позволяет пользователям писать плагины, которые могут настраивать поведение решателя ограничений, проверять и изменять конвейер компиляции, а также преобразовывать и проверять промежуточный язык GHC, Core. Плагины подходят для экспериментального анализа или оптимизации и не требуют изменения исходного кода GHC для использования.</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC должен связать ваш код с различными библиотеками, в том числе, возможно, с пользовательскими, GHC и системными (например, &lt;code&gt;-lm&lt;/code&gt; math library).</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC состоит из двух основных компонентов: интерактивного интерпретатора Haskell (также известного как GHCi), описанного в &lt;a href=&quot;ghci#ghci&quot;&gt;разделе Использование GHCi&lt;/a&gt; , и пакетного компилятора, описанного в &lt;a href=&quot;using#using-ghc&quot;&gt;разделе Использование GHC&lt;/a&gt; . Фактически, GHC состоит из одной программы, которая просто запускается с разными параметрами для обеспечения либо интерактивной, либо пакетной системы.</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">домашняя страница GHC</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">GHC игнорирует утверждения, когда оптимизация &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; флагом -O . То есть выражения вида &lt;code&gt;assert pred e&lt;/code&gt; будут переписаны на &lt;code&gt;e&lt;/code&gt; . Вы также можете отключить утверждения, используя параметр &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt; . Параметр &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt; позволяет включать утверждения, даже если включена оптимизация.</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC реализует ряд специфичных для GHC расширений для главы FFI отчета Haskell 2010. Эти расширения описаны в &lt;a href=&quot;#ffi-ghcexts&quot;&gt;расширениях GHC к главе FFI&lt;/a&gt; , но учтите, что программы, использующие эти функции, не переносимы. Следовательно, по возможности следует избегать этих функций.</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC реализует упреждающую многозадачность:выполнение нитей чередуется случайным образом.Точнее,поток может быть вытеснен всякий раз,когда он выделяет некоторую память,что,к сожалению,означает,что узкие циклы,которые не выделяются,имеют тенденцию блокировать другие потоки (это,однако,происходит только в патологическом коде в стиле бенчмарка).</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC реализует некоторые основные расширения Haskell для поддержки параллельного и параллельного программирования.Давайте сначала установим терминологию:</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">GHC реализует данный тест консервативно,когда речь идет о функциях типа,или о переменных типа.Например</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC включает в себя множество флагов, которые позволяют запускать произвольные процессы во время компиляции. Одним из таких примеров является &lt;a href=&quot;phases#pre-processor&quot;&gt;настраиваемый&lt;/a&gt; флаг препроцессора . Другой способ - это способность Template Haskell выполнять код Haskell во время компиляции, включая операции ввода-вывода. Safe Haskell &lt;em&gt;не устраняет эту опасность&lt;/em&gt; (хотя Template Haskell является запрещенной функцией).</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC включает поддержку параллельного запуска программ Haskell на симметричном мультипроцессоре с общей памятью (SMP). По умолчанию GHC запускает вашу программу на одном процессоре; если вы хотите, чтобы он работал параллельно, вы должны связать свою программу с &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; и запустить ее с параметром RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; ; см. &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Использование параллелизма SMP&lt;/a&gt; ). Среда выполнения будет планировать выполнение потоков Haskell среди доступных потоков ОС, выполняя столько параллельных потоков, сколько вы указали с помощью параметра &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS.</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC - это большая программа, состоящая из нескольких этапов. Вы можете указать GHC сбрасывать информацию с разных этапов компиляции, используя флаги &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; , перечисленные ниже. Обратите внимание, что некоторые из них, как правило, дают много результатов. Вы можете предотвратить засорение ими стандартного вывода, передав &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC построен на множестве примитивных типов данных и операций; &amp;laquo;Примитивные&amp;raquo; в том смысле, что они не могут быть определены в самом Haskell. Хотя вы действительно можете использовать этот материал для написания быстрого кода, мы, как правило, находим гораздо менее болезненным и более удовлетворительным в долгосрочной перспективе использовать языковые функции и библиотеки более высокого уровня. Если повезет, код, который вы пишете, в любом случае будет оптимизирован для эффективной распакованной версии. А если это не так, мы хотели бы знать об этом.</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC сам по себе является программой Haskell, поэтому, если вам нужно передать параметры непосредственно в систему времени выполнения GHC, вы можете заключить их в &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (см. &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Запуск скомпилированной программы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">GHC на удивление быстр для обычных компиляций без &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC очень осторожно относится к дублированию работы.Например,рассмотрим</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC очень внимательно относится к интерфейсным файлам. Например, если он подхватит нестандартный файл &lt;code&gt;Prelude.hi&lt;/code&gt; , произойдут довольно ужасные вещи. Если вы включите параметр &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude, компилятор почти наверняка умрет, если вы не знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC продолжает пытаться применять правила по мере оптимизации программы.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">В частности,GHC знает о двух пакетных базах данных:</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC позволяет вам изменить параметры RTS по умолчанию для программы во время компиляции, используя флаг &lt;code&gt;-with-rtsopts&lt;/code&gt; ( &lt;a href=&quot;phases#options-linker&quot;&gt;параметры, влияющие на связывание&lt;/a&gt; ). Обычно это используется для того, чтобы дать вашей программе размер кучи и / или стека по умолчанию, превышающий размер по умолчанию. Например, чтобы установить &lt;code&gt;-H128m -K64m&lt;/code&gt; , свяжите с &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">GHC позволяет вам осуществлять элементарный контроль над некоторыми настройками RTS для любой данной программы путем компиляции в &amp;laquo;ловушку&amp;raquo;, которая вызывается системой времени выполнения. RTS содержит определения заглушек для этих хуков, но, написав свою собственную версию и связав ее в командной строке GHC, вы можете изменить значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC снимает это ограничение с помощью языкового расширения &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; . Ограничение, во-первых, довольно глупое, поэтому &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt; подразумевается &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC любит одноконструкторные типы данных:</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC поддерживает свойство, согласно которому тип всех обитаемых типов (в отличие от конструкторов типов или данных уровня типа) сообщает нам представление значений этого типа во время выполнения. Этот тип данных кодирует выбор значения времени выполнения. Обратите внимание, что &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; параметризуется &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; ; именно это мы подразумеваем под тем фактом, что тип типа кодирует представление среды выполнения.</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC не делает абсолютно никаких попыток проверить, что LHS и RHS правила имеют одинаковое значение. В общем, это неразрешимо, и в большинстве интересных случаев это невозможно. Вся ответственность лежит на программисте!</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC не делает попыток убедиться в том,что правила сочетаются или прекращаются.Например:</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC может создавать следующие стандартные DIE в разделе &lt;code&gt;.debug_info&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">GHC больше не включает внешние файлы заголовков при компиляции через C, поэтому эта проверка не выполняется. Это изменение было внесено для совместимости с &lt;a href=&quot;codegens#native-code-gen&quot;&gt;генератором собственного кода&lt;/a&gt; ( &lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt; ) и для строгого соблюдения спецификации FFI, которая требует, чтобы вызовы FFI не подвергались расширению макросов и другим преобразованиям CPP, которые могут применяться при использовании файлов заголовков C. Этот подход также упрощает встраивание внешних вызовов через границы модуля и пакета: нет необходимости в том, чтобы файл заголовка был доступен при компиляции встроенной версии внешнего вызова, поэтому компилятор может встраивать внешние вызовы в любом контексте.</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC обычно импортирует файлы &lt;code&gt;Prelude.hi&lt;/code&gt; для вас. Если вы этого не &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; укажите для него параметр -XNoImplicitPrelude . Идея состоит в том, что затем вы можете импортировать собственный Prelude. (Но не называйте это &lt;code&gt;Prelude&lt;/code&gt; ; пространство имен модуля Haskell плоское, и вы не должны конфликтовать с каким-либо модулем Prelude.)</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">Примечание GHC: &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; будет автоматически закрыт, когда сборщик мусора обнаружит, что программа перестала ссылаться на него. Однако полагаться на это поведение обычно не рекомендуется: сборщик мусора непредсказуем. Если возможно, используйте явное &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; , чтобы закрыть &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ы , когда они больше не нужны. GHC в настоящее время не пытается освободить файловые дескрипторы, когда они закончились, вы несете ответственность за то, чтобы этого не произошло.</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">Примечание GHC: количество возможностей указывается опцией &lt;code&gt;+RTS -N&lt;/code&gt; при запуске программы. Возможности могут быть зафиксированы для реальных ядер процессора с помощью &lt;code&gt;+RTS -qa&lt;/code&gt; , если базовая операционная система поддерживает это, хотя на практике в этом обычно нет необходимости (и в некоторых случаях может фактически снизить производительность - рекомендуется поэкспериментировать).</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">Примечания GHC: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; имеет сильно оптимизированную реализацию в GHC. Он использует закрепленную память в куче со сборкой мусора, поэтому &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; не требует финализатора для освобождения памяти. Настоятельно рекомендуется использовать &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; и связанных функций, а не &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; с финализатором.</target>
        </trans-unit>
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">Примечания GHC: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; имеет сильно оптимизированную реализацию в GHC. Он использует закрепленную память в куче со сборкой мусора, поэтому &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; не требует финализатора для освобождения памяти. Настоятельно рекомендуется использовать &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; и связанных функций, а не &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; с финализатором.</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">Примечания GHC: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; имеет сильно оптимизированную реализацию в GHC. Он использует закрепленную память в куче со сборкой мусора, поэтому &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; не требует финализатора для освобождения памяти. Настоятельно рекомендуется использовать &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; и связанных функций, а не &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; с финализатором.</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">Примечания GHC: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; имеет сильно оптимизированную реализацию в GHC. Он использует закрепленную память в куче со сборкой мусора, как и для mallocForeignPtr. В отличие от mallocForeignPtr, ForeignPtr, созданный с помощью mallocPlainForeignPtr, не содержит финализаторов. Невозможно добавить финализатор к ForeignPtr, созданному с помощью mallocPlainForeignPtr. Это полезно для ForeignPtrs, которые будут жить только внутри Haskell (например, созданных для упакованных строк). Попытки добавить финализатор в ForeignPtr, созданный таким образом, или завершить такой указатель, вызовут исключение.</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вместо этого GHC теперь позволяет вам напрямую указывать тип переменной типа везде, где переменная типа явно привязана, с расширением &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHC теперь позволяет создавать такие экземпляры вместо этого с помощью расширения &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; , поэтому можно написать</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHC теперь поддерживает новый способ координации действий параллельных потоков Haskell, называемый программной транзакционной памятью (STM). Документы по &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM&lt;/a&gt; - отличное введение в то, что такое STM и как его использовать.</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHC предлагает здесь руку помощи, делая все это за вас. Для каждого использования &lt;code&gt;assert&lt;/code&gt; в источнике пользователя:</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHC знает только о пакетах, которые &lt;em&gt;установлены&lt;/em&gt; . Установленные пакеты живут в базах данных пакетов. Дополнительные сведения о базах данных пакетов и о том, как контролировать, какие базы данных пакетов или определенный набор пакетов видны GHC, см. В разделе &lt;a href=&quot;#package-databases&quot;&gt;Базы данных пакетов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHC выполняет неявную количественную оценку следующим образом. На самом внешнем уровне (только) написанных пользователем типов, если и только если нет явного &lt;code&gt;forall&lt;/code&gt; , GHC находит все переменные типа, упомянутые в типе, которые еще не в области видимости, и универсально оценивает их количественно. Например, следующие пары эквивалентны:</target>
        </trans-unit>
        <trans-unit id="e903f8397c8f5bbb60d7d8d13ff6bba05d63b1b1" translate="yes" xml:space="preserve">
          <source>GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt;, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHC пересчитывает зависимости каждый раз при его вызове,поэтому эти зависимости никогда не выходят из синхронизации с источником.</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHC расслабляет это правило двумя способами:</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC сообщает об ошибке, говоря, что тип &lt;code&gt;a&lt;/code&gt; должен быть переменной типа &lt;code&gt;k&lt;/code&gt; , а не &lt;code&gt;Type&lt;/code&gt; . Это потому, что, глядя на подпись типа для всех &lt;code&gt;forall a. Proxy a&lt;/code&gt; , GHC предполагает, &lt;code&gt;a&lt;/code&gt; тип должен быть обобщенным, а не ограничиваться &lt;code&gt;Type&lt;/code&gt; . Затем определение функции отклоняется, поскольку оно более конкретное, чем сигнатура ее типа.</target>
        </trans-unit>
        <trans-unit id="5c1031c0bc27b3b9bb273d87c196ba3e6cd2a9cd" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3372876691ddf4da952bbb863dd592b0bdfda843" translate="yes" xml:space="preserve">
          <source>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC требует использования файлов &lt;code&gt;hs-boot&lt;/code&gt; для вырезания рекурсивных циклов между взаимно рекурсивными модулями, как описано в разделе &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;Как компилировать взаимно рекурсивные модули&lt;/a&gt; . Это скорее неудача, чем ошибка: в отчете Haskell говорится ( &lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;раздел 5.7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC решает ограничения &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; в три этапа:</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC решает ограничения &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; в три этапа:</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHC решает ограничения &lt;code&gt;HasCallStack&lt;/code&gt; в два этапа:</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">Иногда GHC предлагает правильную подгонку под типизированные дыры,которая настраивается несколькими флагами.</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHC поддерживает семейства типов с &lt;em&gt;индексированием по&lt;/em&gt; типу, где семейство совпадает как по типу, так и по типу. GHC &lt;em&gt;не&lt;/em&gt; будет делать вывод об этом поведении без полной подписи типа, предоставленной пользователем, так как это иногда приводит к выводам неглавных типов. В самом деле, мы можем рассматривать индексацию по типу как форму полиморфной рекурсии, когда тип используется в виде, отличном от его самого общего в его собственном определении.</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHC поддерживает &lt;em&gt;переменные типа с лексической областью видимости&lt;/em&gt; , без которых некоторые сигнатуры типов просто невозможно написать. Например:</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC поддерживает &lt;em&gt;перегруженные метки&lt;/em&gt; , форму идентификатора, интерпретация которого может зависеть как от его типа, так и от его буквального текста. Когда расширение &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; включено, перегруженная метка может быть записана с хешем префикса, например &lt;code&gt;#foo&lt;/code&gt; . Тип этого выражения - &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC поддерживает &lt;em&gt;перегруженные строковые литералы&lt;/em&gt; . Обычно строковый литерал имеет тип &lt;code&gt;String&lt;/code&gt; , но с включенными перегруженными строковыми литералами (с &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt; ) строковый литерал имеет тип &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHC поддерживает &lt;em&gt;перегрузку нотации списка&lt;/em&gt; . Напомним обозначения построения списков. В Haskell нотацию списка можно использовать следующими семью способами:</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC поддерживает Concurrent Haskell по умолчанию, не требуя специальной опции или библиотек, скомпилированных определенным образом. Чтобы получить доступ к библиотекам поддержки для Concurrent Haskell, просто импортируйте &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; . Дополнительная информация о Concurrent Haskell представлена ​​в документации к этому модулю.</target>
        </trans-unit>
        <trans-unit id="88817a222e891093a054f7b9fd3592132552247b" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC поддерживает расширение сопоставления &lt;em&gt;шаблонов&lt;/em&gt; , называемое &lt;em&gt;шаблонами взрыва&lt;/em&gt; , написанное &lt;code&gt;!pat&lt;/code&gt; . В Haskell Prime рассматриваются шаблоны взрыва. Описание &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;основных возможностей Haskell&lt;/a&gt; содержит больше обсуждений и примеров, чем приведенный ниже материал.</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHC поддерживает массивы распакованных элементов для нескольких основных типов арифметических элементов, включая &lt;code&gt;Int&lt;/code&gt; и &lt;code&gt;Char&lt;/code&gt; : подробности см. &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;В&lt;/a&gt; библиотеке Data.Array.Unboxed . Эти массивы, вероятно, будут намного быстрее, чем использование стандартных массивов Haskell 98 из библиотеки &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHC поддерживает как параллелизм,так и параллелизм.</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHC поддерживает несколько генераторов внутреннего кода.Это та часть компилятора,которая отвечает за принятие последнего промежуточного представления,используемого GHC (форма,называемая Cmm,простая,C like language)и компиляцию его в исполняемый код.Бэкэнды,поддерживаемые GHC,описаны ниже.</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC поддерживает числовые и строковые литералы на уровне типа, обеспечивая удобный доступ к большому количеству предопределенных констант уровня типа. Числовые литералы относятся к типу &lt;code&gt;Nat&lt;/code&gt; , а строковые литералы - к типу &lt;code&gt;Symbol&lt;/code&gt; . Эта функция включена языковым расширением &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHC поддерживает множество языковых расширений, включая параллелизм, интерфейс внешней функции, исключения, расширения системы типов, такие как классы типов с несколькими параметрами, локальную универсальную и экзистенциальную количественную оценку, функциональные зависимости, переменные типа с ограниченной областью видимости и явные распакованные типы. Все они описаны в &lt;a href=&quot;lang#ghc-language-features&quot;&gt;разделе &amp;laquo;Возможности языка GHC&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHC поддерживает параллельный запуск программ Haskell на SMP (симметричном мультипроцессоре).</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHC поддерживает несколько прагм или инструкций для компилятора, помещенных в исходный код. Прагмы обычно не влияют на смысл программы, но могут повлиять на эффективность сгенерированного кода.</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHC поддерживает компиляцию взаимно рекурсивных модулей.Этот раздел объясняет как.</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHC поддерживает эти языковые варианты:</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC поддерживает три разные роли для параметров типа: номинальную, репрезентативную и фантомную. Если параметр типа имеет номинальную роль, то два разных типа не должны фактически различаться: они должны быть идентичными (после сокращения семейства типов). Если параметр типа имеет репрезентативную роль, тогда два типа должны иметь одинаковое представление. (Если роль первого параметра &lt;code&gt;T&lt;/code&gt; является репрезентативной, тогда &lt;code&gt;T Age Bool c&lt;/code&gt; и &lt;code&gt;T Int Bool c&lt;/code&gt; будут иметь одинаковое представление, потому что &lt;code&gt;Age&lt;/code&gt; и &lt;code&gt;Int&lt;/code&gt; имеют одинаковое представление.) Если параметр типа имеет фантомную роль, тогда нам не нужно дальнейшая информация.</target>
        </trans-unit>
        <trans-unit id="739585d733fbd90b635381ce1f62b05fe70f7220" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHC занимает консервативную позицию:он принимает первые два,но не третий.Правило таково:каждое ограничение в контексте вымышленного экземпляра должно состоять только из переменных типа,без повторов.</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">Затем GHC проверяет покрытие шаблонов,используя каждый из этих наборов.Если любой из этих наборов пройдет проверку на покрытие шаблона без предупреждений,то мы закончили.Если каждый набор выдает хотя бы одно предупреждение,то GHC должен выбрать один из наборов предупреждений в зависимости от того,насколько хороши результаты.Приоритет отдается результатам в этом порядке:</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHC отслеживает различие между переменными &lt;em&gt;предполагаемого&lt;/em&gt; и &lt;em&gt;заданного&lt;/em&gt; типа. Только указанные переменные типа доступны для создания экземпляра с приложением видимого типа. Пример хорошо иллюстрирует это:</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">Раньше GHC имел реализацию универсальных классов, как определено в статье &amp;laquo;Классы производных типов&amp;raquo;, Ральф Хинце и Саймон Пейтон Джонс, Haskell Workshop, Монреаль, сентябрь 2000 г., стр. 94-105. Они были удалены и заменены более общей &lt;a href=&quot;#generic-programming&quot;&gt;поддержкой общего программирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">По умолчанию GHC использует копирующий сборщик мусора. &amp;laquo;Байты, скопированные во время сборки мусора&amp;raquo; сообщает вам, сколько байтов пришлось скопировать во время сборки мусора.</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC использует &lt;a href=&quot;#instance-termination&quot;&gt;Условия Патерсона,&lt;/a&gt; чтобы гарантировать прекращение разрешения экземпляра. Как эти правила изменяются для количественных ограничений? Двумя способами.</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">В версиях GHC до 8.8 были определены недокументированные функции &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; и &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; вместо &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; и &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; . Эти имена устарели.</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC автоматически добавит аннотации &lt;code&gt;SCC&lt;/code&gt; для всех экспортируемых функций, не отмеченных INLINE. Если вам нужен МВЗ для функции INLINE, вам нужно добавить его вручную.</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC автоматически добавит аннотации &lt;code&gt;SCC&lt;/code&gt; для всех привязок верхнего уровня, не отмеченных INLINE. Если вам нужен МВЗ для функции INLINE, вам нужно добавить его вручную.</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">GHC будет жаловаться на это,потому что позже ты можешь добавить.</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">GHC сгенерирует экземпляр,эквивалентный</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHC перепишет его,включив в него также местоположение источника,в котором было сделано это утверждение,</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">GHC успешно скомпилирует этот модуль с помощью &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; , потому что список экспорта по умолчанию будет включать &lt;code&gt;program&lt;/code&gt; а не &lt;code&gt;main&lt;/code&gt; , как обычно требует отчет Haskell.</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">Параметр GHC &lt;code&gt;-main-is&lt;/code&gt; может использоваться для изменения имени точки входа верхнего уровня с &lt;code&gt;main&lt;/code&gt; на любую другую переменную. При компиляции основного модуля и использования &lt;code&gt;-main-is&lt;/code&gt; для переименования точки входа по умолчанию GHC также будет использовать альтернативное имя в списке экспорта по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">Поведение GHC контролируется параметрами, которые по историческим причинам также иногда называют флагами или аргументами командной строки. Параметры можно указать тремя способами:</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">Поведение GHC в первую очередь контролируется флагом режима. Может быть задан только один из этих флагов, но он не обязательно должен быть первым параметром в командной строке. Например,</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">Скомпилированный вывод GHC обычно переходит в &lt;code&gt;.hc&lt;/code&gt; , &lt;code&gt;.o&lt;/code&gt; и т. Д., В зависимости от фазы компиляции последнего запуска. Параметр &lt;code&gt;-o file&lt;/code&gt; перенаправляет вывод последней фазы выполнения в &amp;laquo;файл&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">Поведение GHC по умолчанию таково, что &lt;em&gt;ровно один экземпляр должен соответствовать ограничению, которое он пытается разрешить&lt;/em&gt; . Например, ограничение &lt;code&gt;C Int Bool&lt;/code&gt; соответствует экземплярам (A) и (B) и, следовательно, будет отклонено; в то время как &lt;code&gt;C Int Char&lt;/code&gt; соответствует только (A) и, следовательно, выбран (A).</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">Реализация GHC отличается от определения Haskell 98 в том смысле, что буквенные символы Unicode, которые не являются ни верхним, ни нижним регистром, по-прежнему будут идентифицироваться как буквенные с помощью &lt;code&gt;isAlpha&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">Реализация &lt;code&gt;array&lt;/code&gt; в GHC берет значение слота массива из последней пары (индекс, значение) в списке и не проверяет дубликаты. Причина этого - чистая и простая эффективность.</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">Реализация GHC класса &lt;code&gt;Read&lt;/code&gt; для целочисленных типов принимает шестнадцатеричные и восьмеричные литералы (код в отчете Haskell 98 - нет). Так, например,</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">Реализация mdo-нотации в GHC полностью соответствует оригинальному переводу, описанному в статье &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Рекурсивный do для Haskell&lt;/a&gt; , который, в свою очередь, основан на работе &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt; . Кроме того, GHC расширяет синтаксис, описанный в предыдущем документе, синтаксисом более низкого уровня, помеченным ключевым словом &lt;code&gt;rec&lt;/code&gt; , как мы опишем далее.</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">Инлайнер GHC можно убедить не прерывать, используя стандартный способ кодирования рекурсии через тип данных:</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">Оптимизатор GHC может расходиться, если вы пишете правила перезаписи ( &lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;правила&lt;/a&gt; перезаписи ), которые не завершаются, или (менее удовлетворительно), если вы кодируете рекурсию с помощью типов данных ( &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;ошибки в GHC&lt;/a&gt; ). Чтобы компилятор не попал в бесконечный цикл, оптимизатор выполняет &amp;laquo;счетчик тиков&amp;raquo; и прекращает встраивание и применение правил перезаписи при превышении этого счетчика. Предел установлен как кратный размеру программы, поэтому более крупные программы получают больше тиков. &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; флаг позволяет изменять множитель. По умолчанию 100; числа больше 100 дают больше отметок, а числа меньше 100 дают меньше.</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">Поддержка параллелизма в GHC была улучшена в 6.12.1 в результате множества экспериментов и настройки системы времени выполнения. Нам все еще было бы интересно узнать, насколько хорошо это работает для вас, и мы также заинтересованы в сборе параллельных программ для добавления в наш набор тестов.</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">Система профилирования GHC распределяет затраты по центрам затрат. Стоимость - это просто время или пространство (память), необходимое для оценки выражения. МВЗ - это программные аннотации вокруг выражений; все затраты, понесенные аннотированным выражением, относятся к включающему МВЗ. Кроме того, GHC запомнит стек включающих центров затрат для любого данного выражения во время выполнения и сгенерирует дерево вызовов с атрибуцией затрат.</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">Система профилирования GHC поддерживает &amp;laquo;стеки центров затрат&amp;raquo;: способ увидеть профиль программы Haskell в структуре, подобной графу вызовов. Смотрите &lt;a href=&quot;profiling#profiling&quot;&gt;Профилирование&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">Система времени выполнения GHC имеет встроенную поддержку для сбора информации трассировки стека из запущенной программы Haskell. В настоящее время для этого требуется, чтобы была &lt;code&gt;libdw&lt;/code&gt; библиотека libdw из пакета &lt;code&gt;elfutils&lt;/code&gt; . Конечно, от трассировки будет мало пользы, если отладочная информация не будет доступна в исполняемом файле и его зависимых библиотеках.</target>
        </trans-unit>
        <trans-unit id="34ecd7773e52e6b1108977b176ca3c2b9e8f2456" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">Система времени выполнения GHC реализует совместную многозадачность, при этом переключение контекста потенциально происходит только тогда, когда программа выделяет память. Это означает, что программы, которые не выделяют память, могут никогда не переключать контекст. Это особенно верно для программ, использующих STM, которые могут зайти в тупик после обнаружения несогласованного состояния. См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Выпуск № 367&lt;/a&gt; для дальнейшего обсуждения.</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">Система типов GHC поддерживает явную универсальную квантификацию &lt;em&gt;произвольного ранга&lt;/em&gt; в типах. Например, допустимы все следующие типы:</target>
        </trans-unit>
        <trans-unit id="82fd95c3a56752e08f77eb38c5bdbdcb6be4a696" translate="yes" xml:space="preserve">
          <source>GHC's &lt;code&gt;DataKinds&lt;/code&gt; language extension lifts data constructors, natural numbers, and strings to the type level. This module provides the primitives needed for working with type-level numbers (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; kind) and strings (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt;) kind. It also defines the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; type family, a feature that makes use of type-level strings to support user defined type errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364440218c4abb707fa15b5beedbc3d1c2676890" translate="yes" xml:space="preserve">
          <source>GHC's Ix typeclass implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">Реализация массива GHC.</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">внедрение GHC параллелизма</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">Реализация GHC типа данных &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">GHC по умолчанию больше не зависит от cygwin, а является собственной программой Windows. Он построен с использованием mingw и использует GHC mingw при компиляции исходных текстов Haskell (даже если вы вызываете его из cygwin bash), но здесь важно то, что - как и любая другая обычная программа Windows - ни GHC, ни исполняемые файлы, которые он создает, не знает о предполагаемой иерархии Unix Cygwin. GHC с радостью примет в качестве разделителей пути либо &lt;code&gt;/&lt;/code&gt; , либо &lt;code&gt;\\&lt;/code&gt; , но не знает, где найти &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; или &lt;code&gt;/bin/bash&lt;/code&gt; или тому подобное. Это вызывает массу удовольствия, когда GHC используется внутри Cygwin bash или в сеансах make, запущенных под Cygwin.</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="cb20764f134c9f093388b799d6edb5c287e142c7" translate="yes" xml:space="preserve">
          <source>GHC.Ix</source>
          <target state="translated">GHC.Ix</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="6b49fe46f1283625854f08ffa7ba78c6c9050030" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; - это интерактивная среда GHC, в которой выражения Haskell могут интерактивно оцениваться, а программы могут интерпретироваться. Если вы знакомы с &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt; , то с GHCi вы будете как дома. Однако GHCi также поддерживает интерактивную загрузку скомпилированного кода, а также поддерживает все &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; языковые расширения, которые предоставляет GHC. GHCi также включает интерактивный отладчик (см &lt;a href=&quot;#ghci-debugger&quot;&gt;. Отладчик GHCi&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">GHCi на самом деле принимает утверждения,а не просто выражения в подсказке.Это означает,что вы можете связывать значения и функции с именами и использовать их в будущих выражениях или выражениях.</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCi на самом деле поддерживает &lt;em&gt;два&lt;/em&gt; набора опций:</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCi также может загружать простые объектные файлы ( &lt;code&gt;.o&lt;/code&gt; или &lt;code&gt;.obj&lt;/code&gt; в зависимости от вашей платформы) или статические архивы ( &lt;code&gt;.a&lt;/code&gt; ) из командной строки. Просто добавьте имя объектного файла или библиотеки в командную строку. В Windows GHCi также поддерживает формат &lt;code&gt;big-obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">GHCi может использовать систему профилирования для сбора информации о трассах в стеке при выполнении интерпретированного кода.Чтобы получить доступ к стековым трассам,запустите GHCi вот так:</target>
        </trans-unit>
        <trans-unit id="b50b888b5a01174ea88ffe286c7e481b07e9ce3d" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">Все команды GHCi начинаются с &amp;laquo; &lt;code&gt;:&lt;/code&gt; &amp;raquo; и состоят из одного имени команды, за которым следует ноль или более параметров. Имя команды может быть сокращено с устранением неоднозначности в пользу более часто используемых команд.</target>
        </trans-unit>
        <trans-unit id="cdeb81402d6c2b81eaa4ac1ca68fa6f4bf53dc3f" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi содержит простой отладчик императивного стиля, в котором вы можете остановить текущее вычисление, чтобы проверить значения переменных. Отладчик интегрирован в GHCi и включен по умолчанию: для включения средств отладки не требуются флаги. Есть одно серьезное ограничение: точки останова и пошаговое выполнение доступны только в интерпретируемых модулях; скомпилированный код невидим для отладчика &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCi выполняет больше, чем простую оценку выражения в командной строке. Если вы вводите выражение типа &lt;code&gt;IO a&lt;/code&gt; для некоторого &lt;code&gt;a&lt;/code&gt; , то GHCi &lt;em&gt;выполняет&lt;/em&gt; его как IO-вычисление.</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCi не соблюдает декларацию по &lt;code&gt;default&lt;/code&gt; в модуле, в области действия которого вы находитесь. Вместо этого для выражений, вводимых в командной строке, вы всегда получаете поведение типа по умолчанию; то есть по &lt;code&gt;default(Int,Double)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi загрузил &lt;code&gt;Main&lt;/code&gt; модуль, и приглашение изменилось на &lt;code&gt;*Main&amp;gt;&lt;/code&gt; , чтобы указать, что текущий контекст для выражений, набранных в приглашении, - это только что загруженный модуль &lt;code&gt;Main&lt;/code&gt; (мы объясним, что означает &lt;code&gt;*&lt;/code&gt; , позже в разделе &lt;a href=&quot;#ghci-scope&quot;&gt;Что на самом деле в области в подсказке?&lt;/a&gt; ). Итак, теперь мы можем вводить выражения, включающие функции из &lt;code&gt;Main.hs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e7e52195cfae2c519c03e23e784d7a20ae2e810" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi предоставил привязки для свободных переменных &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; выражения, на котором была размещена точка останова ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; ), и дополнительно привязку для результата выражения ( &lt;code&gt;_result&lt;/code&gt; ). Эти переменные похожи на другие переменные, которые вы можете определить в GHCi; вы можете использовать их в выражениях, которые вы вводите в командной строке, вы можете запрашивать их типы с помощью &lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt; и так далее. Однако есть одно важное отличие: эти переменные могут иметь только частичные типы. Например, если мы попытаемся отобразить значение &lt;code&gt;left&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi интерпретирует всю строку как выражение для оценки.Выражение может не охватывать несколько строк-как только вы нажмете Enter,GHCi попытается его оценить.</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">GHCi вызывается с помощью команды &lt;code&gt;ghci&lt;/code&gt; или &lt;code&gt;ghc --interactive&lt;/code&gt; . Один или несколько модулей или имен файлов также могут быть указаны в командной строке; это дает GHCi команду загрузить указанные модули или имена файлов (и все модули, от которых они зависят), как если бы вы сказали &lt;code&gt;:load modules&lt;/code&gt; в приглашении GHCi (см. &lt;a href=&quot;#ghci-commands&quot;&gt;команды GHCi&lt;/a&gt; ). Например, чтобы запустить GHCi и загрузить программу, самый верхний модуль которой находится в файле &lt;code&gt;Main.hs&lt;/code&gt; , мы могли бы сказать:</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры GHCi могут быть установлены с помощью &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; и unset с помощью &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCi сообщает нам, что среди других привязок &lt;code&gt;f&lt;/code&gt; входит в область видимости. Однако его тип еще полностью не известен, поэтому его нельзя применить ни к каким аргументам. Тем не менее обратите внимание, что тип его первого аргумента такой же, как тип &lt;code&gt;x&lt;/code&gt; , а его тип результата используется совместно с &lt;code&gt;_result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;GHCi&lt;/a&gt; использует Haskeline под капотом. Вы можете настроить его, помимо прочего, для удаления дубликатов из истории GHCi. См .: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Пользовательские настройки Haskeline&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCi завершит имена, попадающие в область видимости; например, если вы запустите GHCi и наберете &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; то GHCi расширит его до &lt;code&gt;Just&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">сбор мусора</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">Для сборки мусора требуется больше памяти, чем фактическое размещение. Фактор зависит от типа используемого алгоритма сборки мусора: основной сборщик мусора в сборщике копирования стандартного поколения обычно требует \ (3L \) байтов памяти, где \ (L \) - это количество текущих данных. Это связано с тем, что по умолчанию (см. &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; RTS -F &amp;laquo;фактор&amp;raquo; ) мы позволяем старому поколению увеличиваться в два раза по сравнению с его размером (\ (2L \)) перед его сбором, и нам дополнительно требуется \ (L \) байтов для копирования живые данные в. При использовании сжимающей коллекции (см. &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; ) это сокращается до \ (2L \), и может быть дополнительно уменьшено путем настройки параметра &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; . Также добавьте размер &lt;code&gt;-A ⟨size⟩&lt;/code&gt; области (см. -A &amp;laquo;размер&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">Общее количество Семафоры</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">Общее сочетание функций</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">Общее совмещение функций</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">Общие определения для методов суперкласса</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Общие сгибы доступны через &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; экземпляр &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb698a6fdef53a2047596be60a1e1ba2d67960a" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">Общие сортировочные службы</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">Общий рендеринг</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">Конечные последовательности общего назначения.</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="588fb85f0da12d2db4af030769a3fe542d141ec2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2828c3cdd240b29b7adddd99ced6ba83ae84c8d8" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61a01cc59f938a5a2397118a9603bef23b0e4c2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">Обобщения функций списка</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">Обобщенные алгебраические типы данных обобщают обычные алгебраические типы данных,позволяя конструкторам иметь более богатые возвращаемые типы.Приведем пример:</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">Обобщенные представления списков - это дальнейшее усовершенствование синтаксического сахара понимания списков, позволяющее выполнять такие операции, как сортировка и группировка, знакомые по SQL. Они полностью описаны в документе &amp;laquo; &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Всеобъемлющие понимания&amp;raquo;: понимания с помощью &amp;laquo;упорядочить по&amp;raquo; и &amp;laquo;группировать по&amp;raquo;&lt;/a&gt; , за исключением того, что используемый нами синтаксис немного отличается от этого документа.</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Обобщения контроля.Исключение</target>
        </trans-unit>
        <trans-unit id="f1955dbc970386d87459b85c65d5689fcd0a3342" translate="yes" xml:space="preserve">
          <source>Generalized abstracted pattern of safe resource acquisition and release in the face of errors. The first action &quot;acquires&quot; some value, which is &quot;released&quot; by the second action at the end. The third action &quot;uses&quot; the value and its result is the result of the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">Обобщенные слепки для видов более высокого порядка</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">Обобщенная форма безопасного для типа кастинга с использованием равенства предложений</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">Обобщенная форма безопасного для типа кастинга с использованием репрезентативного равенства</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">Обобщенные функции</target>
        </trans-unit>
        <trans-unit id="5d04310694030c511391766d6d01208fdf93d744" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">Вообще говоря, когда &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; , GHC пытается определить наиболее общий вид объявления. Во многих случаях (например, в объявлении типа данных) определение имеет правую часть для информирования о выводе типа. Но так бывает не всегда. Рассматривать</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">Как правило, вы можете &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt; прагму SPECIALIZE только для функции, определенной в том же модуле. Однако, если функции &lt;code&gt;f&lt;/code&gt; дается прагма &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; на сайте ее определения, то впоследствии она может быть специализирована путем импорта модулей (см. &lt;a href=&quot;#inlinable-pragma&quot;&gt;Прагму INLINABLE&lt;/a&gt; ). Например</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">Сгенерируй пленительное имя.Случаи таких имен будут разрешаться в соответствии с правилами поиска Хаскелла на месте возникновения.</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">Генерируйте свежее имя,которое не может быть захвачено.</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">Сгенерируйте график зависимостей пакетов в форме, подходящей для ввода для инструментов &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; . Например, чтобы сгенерировать PDF-файл графа зависимостей:</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">Сгенерировать разделяемую библиотеку (в отличие от исполняемого файла).</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">Сгенерировать отдельную статическую библиотеку (в отличие от исполняемого файла).Это полезно при перекрестной компиляции.Библиотека вместе со всеми ее зависимостями попадает в единую статическую библиотеку,с которой может быть скомпонована.</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">Сгенерировать байт-код</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сгенерируйте байт-код вместо объектного кода. Это значение по умолчанию в GHCi. Байт-код в настоящее время можно использовать только в интерактивном интерпретаторе, а не сохранять на диск. Эта опция полезна только для отмены эффекта &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">Сгенерировать код для позиционно-независимого исполняемого файла (при наличии).</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">Сгенерировать код для линковки с динамическими библиотеками</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сгенерируйте код таким образом, чтобы его можно было связать с независимым от позиции исполняемым файлом. В настоящее время это работает в Linux x86 и x86-64. В Windows код, не зависящий от позиции, никогда не используется, поэтому флаг на этой платформе не работает. Чтобы связать окончательный исполняемый файл, используйте &lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">Сгенерировать цветовую отдачу.</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">Создавайте инкапсулированный PostScript, подходящий для включения в документы LaTeX. Обычно график PostScript рисуется в альбомном режиме на участке шириной 9 дюймов и высотой 6 дюймов, и &lt;code&gt;hp2ps&lt;/code&gt; размещает эту область приблизительно по центру листа бумаги формата A4. Этот формат удобен для детального изучения графика, но не подходит для включения в документы LaTeX. Параметр &lt;code&gt;-e&lt;/code&gt; заставляет график рисоваться в портретном режиме, где float указывает ширину в дюймах, миллиметрах или точках (по умолчанию). Полученный файл PostScript соответствует соглашению Encapsulated PostScript (EPS), и его можно включить в документ LaTeX с помощью dvips-конвертера dvi-to-PostScript от &lt;code&gt;dvips&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">Сгенерировать объектный код</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">Сгенерировать объектный код.По умолчанию это не GHCi,и может быть использовано с GHCi,чтобы сгенерировать объектный код,предпочитая байткод.</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">Сгенерировать позиционно-независимый код (код,который можно поместить в разделяемые библиотеки).В настоящее время это работает на Linux x86 и x86-64.На Windows позиционно-независимый код никогда не используется,поэтому на этой платформе флаг не используется.</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">Сгенерировать позиционно-независимый код (при наличии).</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">Генерируется препроцессорами для передачи номеров исходных линий исходного источника.</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">Создает файл &amp;laquo;тегов&amp;raquo; для редакторов в стиле Vi ( &lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt; ) или редакторов в стиле Emacs ( &lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt; ). Если имя файла не указано, используются &lt;code&gt;tags&lt;/code&gt; по умолчанию или &lt;code&gt;TAGS&lt;/code&gt; соответственно. Создаются теги для всех функций, конструкторов и типов в загруженных в данный момент модулях. Для работы этих команд необходимо интерпретировать все модули.</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Формирует основной профиль кучи, в файле &lt;code&gt;prog.hp&lt;/code&gt; . Чтобы создать график профиля кучи, используйте &lt;strong&gt;hp2ps&lt;/strong&gt; (см. &lt;a href=&quot;profiling#hp2ps&quot;&gt;Hp2ps - Отображение профилей кучи в PostScript&lt;/a&gt; ). Базовый профиль кучи разбивается конструктором данных, а другие типы замыканий (функции, преобразователи и т. Д.) Сгруппированы по широким категориям (например, &lt;code&gt;FUN&lt;/code&gt; , &lt;code&gt;THUNK&lt;/code&gt; ). Чтобы получить более подробный профиль, воспользуйтесь полной поддержкой профилирования ( &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; ). Может быть сокращено до &lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">Создает как динамические, так и статические объектные файлы за один запуск GHC. Эта опция функционально эквивалентна запуску GHC дважды, второй раз добавляя &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">Генерирует следующий пример</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">Генерирование и разворачивание ByteStrings</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">Генерирование и развёртывание</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">Общие конструкторские классы</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">Общие случаи</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">Общие операции, определенные в терминах &lt;code&gt;gunfold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">Поддержка универсального программирования в GHC позволяет определять классы с методами, которые не нуждаются в пользовательской спецификации при создании экземпляра: тело метода автоматически выводится GHC. Это похоже на то, что происходит, например, со стандартными классами, такими как &lt;code&gt;Read&lt;/code&gt; и &lt;code&gt;Show&lt;/code&gt; , но теперь для классов, определяемых пользователем.</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">Общий тип представления</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">Общие типы представления</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">Общая поддержка</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">Общие классы типа</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">Получите ленивый БайтСтринг,который завершается NUL-байтом.Возвращаемая строка не содержит байта NUL.Не удается,если она достигает конца входных данных,не найдя NUL.</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">Получите список &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; в переменной $ PATH.</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">Получите список &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; в переменной $ PATH.</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">Получить ссылку на свободную переменную в точке останова.</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">Получите конкретный компонент состояния,используя функцию проекции,входящую в комплект поставки.</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">Получить строковое представление текущего состояния стека исполнения.</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">Получить след текущего состояния стека исполнения.</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">Получите все расширения.</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">Получить значение окружения или значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">Возьми казенную пачку.</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">Получить текущую статистику системы исполнения.</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">Получить состояние от &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; - монады. Обратите внимание, что состояние является локальным для модуля Haskell, в котором выполняется выражение Template Haskell.</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Установите &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; во главе &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">Получите &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; , связанный с заданным значением.</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Установите &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; во главе &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">Получите &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; , связанный с заданным значением.</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">Получите время UT1 местного времени на определенном меридиане (в градусах,положительное-Восток).</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">Получить UTC-времени местного времени в часовом поясе.</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">Получите базовое имя,без расширения и пути.</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">Получите содержимое &lt;code&gt;PATH&lt;/code&gt; среды PATH .</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">Получите текущее &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; по системным часам.</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">Получите текущее время POSIX из системных часов.</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">Получить историю ввода текущей строки.</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">Получить текущий часовой пояс.</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">Получить текущее значение &lt;code&gt;errno&lt;/code&gt; в текущем потоке.</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">Получите размер терминала по умолчанию. Для терминалов с изменяемым размером (например, &lt;code&gt;xterm&lt;/code&gt; ) они могут не соответствовать реальным размерам.</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">Получите имя каталога,поднимитесь на один уровень.</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">Возьмите диск из файловой тропы.</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">Получить эхо-статус рукоятки,подключенной к клемме.</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">Получить расширение файла, без расширения возвращает &lt;code&gt;&quot;&quot;&lt;/code&gt; , в &lt;code&gt;.ext&lt;/code&gt; случае - .ext .</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">Получите имя файла.</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">Получить первый индекс подстроки в другой строке или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если строка не найдена. &lt;code&gt;findSubstring p s&lt;/code&gt; эквивалентен &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">Получите долю дня с полуночи,учитывая время суток.</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">Получите дескриптор текущего окна консоли, используя заголовок окна. См .: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">Возьмите ручку текущего окна консоли.</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">Получите этикетку для данного ключа.</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите этикетку &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите этикетку &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">Получить местное время UT1 на определенном меридиане (в градусах,положительное-Восток).</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">Получить местное время UTC в часовом поясе.</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">Получить местный часовой пояс для заданного времени (меняющийся в соответствии с летними настройками).</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите модуль &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите модуль &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">Получите следующее значение из &lt;code&gt;TBQueue&lt;/code&gt; , не удаляя его, повторяя попытку, если канал пуст.</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">Получите следующее значение из &lt;code&gt;TChan&lt;/code&gt; , не удаляя его, повторяя попытку, если канал пуст.</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">Получите следующее значение из &lt;code&gt;TQueue&lt;/code&gt; , не удаляя его, повторяя попытку, если канал пуст.</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите количество пикосекунд в &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Получите номер недели, начинающейся с понедельника, в году и день недели. Первый понедельник - это первый день недели 1, любые более ранние дни в году - это неделя 0 (как &lt;code&gt;%W&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ). Понедельник - 1, воскресенье - 7 (как &lt;code&gt;%u&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Получите номер недели, начинающейся с воскресенья, в году и день недели. Первое воскресенье - это первый день недели 1, любые более ранние дни в году - это неделя 0 (как &lt;code&gt;%U&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ). Воскресенье - 0, суббота - 6 (как &lt;code&gt;%w&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">Получить права доступа к файлу или каталогу.</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">Получить приоритет фиксированного значения.</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">Получите оставшиеся байты как ленивый БайтСтринг.Обратите внимание,что это может быть дорогостоящей функцией,так как она заставляет читать все входные данные и хранить строку в памяти.</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите секунды в &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите исходный диапазон &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите исходный диапазон &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">Прикрепите след от стека к объекту.</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">Получить строку,соответствующую спецификатору данного формата.</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">Получите системное время, начало эпохи UTC 1970 года, дополнительные секунды игнорируются. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; обычно намного быстрее, чем &lt;code&gt;getCurrentTime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите хвост в &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Получите хвост в &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">Получить время суток с полуночи.Время более 24 часов будет преобразовано в прыжковые секунды.</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">Получить время дня,учитывая долю дня с полуночи.</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">Получить время с полуночи для данного времени суток.</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">Получить общее количество прочитанных байт до этой точки.</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">Получите имя пользователя. См .: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt; , &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">Получить/установить окно переднего плана.</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">Получает описание файла GHC Handle File с данной ОС Handle или POSIX fd.</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">Получает определенную составляющую состояния,используя поставляемую функцию проекции.</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">Получает конструктор для индекса (только алгебраические типы данных)</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">Получает конструкторы алгебраического типа данных</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">Получает тип данных конструктора</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">Получает полевые этикетки конструктора.Список меток возвращается в том же порядке,в котором они были даны в исходной декларации конструктора.</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">Получает фиксацию конструктора</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">Получает индекс конструктора (только алгебраические типы данных)</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">Получает максимальный индекс конструктора алгебраического типа данных</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">Получает модуль конструктора типа:возьмем *.*.*...перед именем</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">Получает публичное представление типа данных.</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">Получает публичное представление строителей</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">Получает строку для конструктора</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">Получает тип конструктора,включая модуль</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">Получает конструктор безоговорочного типа:опустить *.*.*...перед именем</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Придать аргументы модулю расширения; модуль должен быть указан с помощью &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">Придать аргументы модулю расширения; модуль должен быть указан с &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">Дайте явные подписи типа:</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="76d11fa818460b917132ef39c92a210ad06313c6" translate="yes" xml:space="preserve">
          <source>Given a CNF and the address of one its compact blocks, returns the next compact block and its utilized size, or &lt;code&gt;nullAddr#&lt;/code&gt; if the argument was the last compact block in the CNF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">Учитывая компактность и адрес одного из его блоков,возвращает следующий блок и его размер,или #nullAddr,если аргумент был последним блоком в компактности.</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">Учитывая список сегментов пути, разверните &lt;code&gt;.&lt;/code&gt; и &lt;code&gt;..&lt;/code&gt; . Сегменты пути не должны содержать разделителей пути.</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">Получив список строк,объедините их в единую строку с экранированием определенных символов и добавлением новой строки между каждой строкой.Экрапировка выполняется добавлением одного символа обратного слеша перед любым пробелом,одинарной кавычкой,двойной кавычкой или символом обратного слеша,поэтому этот экранирующий символ должен быть удален.Неиспользуемый пробельный символ (в данном случае новая строка)является частью этого &quot;транспортного&quot; формата для указания конца предыдущей строки и начала новой строки.</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">При наличии средств отображения элементов структуры в списки,рассчитывает конкатенцию всех таких списков по порядку.</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">По заданному имени или пути &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; добавляет &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; к запросу и выполняет поиск исполняемых файлов в списке заданных каталогов поиска и возвращает все вхождения.</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">Учитывая параллельное понимание формы:</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">Учитывая синоним шаблона,определение формы</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">Учитывая программу &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; и аргументы &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; возвращает строку, подходящую для вставки в &lt;code&gt;/bin/sh&lt;/code&gt; (в системах Unix) или &lt;code&gt;CMD.EXE&lt;/code&gt; (в Windows).</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">Учитывая массив источника,смещение в массив источника,массив назначения,смещение в массив назначения и ряд элементов для копирования,копируйте элементы из массива источника в массив назначения.Оба массива должны полностью содержать указанные диапазоны,но это не проверяется.В случае,когда массив источника и массив назначения один и тот же,области источника и назначения могут пересекаться.</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">Учитывая массив источника,смещение в массив источника,массив назначения,смещение в массив назначения и ряд элементов для копирования,копируйте элементы из массива источника в массив назначения.Оба массива должны полностью содержать указанные диапазоны,но это не проверяется.Оба массива не должны быть одним и тем же массивом в разных состояниях,но и это не проверяется.</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">Учитывая массив источника,смещение в массив источника,массив назначения,смещение в массив назначения и ряд элементов для копирования,копируйте элементы из массива источника в массив назначения.Массивы источника и назначения могут ссылаться на один и тот же массив.Оба массива должны полностью содержать указанные диапазоны,но это не проверяется.Допускается перекрытие областей,хотя это возможно только в том случае,если в качестве массива источника и приемника используется один и тот же массив.</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">Учитывая исходный массив,смещение в исходный массив и количество элементов для копирования,создайте новый массив с элементами из исходного массива.Предоставляемый массив должен полностью содержать указанный диапазон,но это не проверяется.</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">Учитывая строку объединенных строк, разделите каждую, удалив слой &lt;em&gt;цитирования&lt;/em&gt; и / или &lt;em&gt;экранирования&lt;/em&gt; определенных символов.</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">Учитывая значение типа &lt;code&gt;Right a&lt;/code&gt; , GHC должен выдавать значение типа &lt;code&gt;Right b&lt;/code&gt; . Поскольку аргумент конструктора &lt;code&gt;Right&lt;/code&gt; имеет тип &lt;code&gt;Either Int a&lt;/code&gt; , код рекурсивно вызывает для него &lt;code&gt;fmap&lt;/code&gt; для создания значения типа &lt;code&gt;Either Int b&lt;/code&gt; , которое, в свою очередь, используется для создания окончательного значения типа &lt;code&gt;Right b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">Учитывая год,найдите Пасху по православной христианской традиции.</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">Учитывая год,найдите Пасху по григорианскому методу.</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">Учитывая год,найдите Пасхальное полнолуние по православной христианской традиции.</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">Учитывая год,найдите Пасхаль полнолуние по григорианскому методу.</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">Учитывая произвольный адрес и ограничение выравнивания, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; возвращает следующий более высокий адрес, который удовлетворяет ограничению выравнивания. Ограничение выравнивания &lt;code&gt;x&lt;/code&gt; выполняется любым адресом, делящимся на &lt;code&gt;x&lt;/code&gt; . Эта операция идемпотентна.</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">Учитывая произвольный адрес и ограничение выравнивания, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; возвращает следующий более высокий адрес, который удовлетворяет ограничению выравнивания. Ограничение выравнивания &lt;code&gt;x&lt;/code&gt; выполняется любым адресом, делящимся на &lt;code&gt;x&lt;/code&gt; . Эта операция идемпотентна.</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив и смещение в единицах Int,читайте элемент.Предполагается,что индекс находится в границах.Подразумевается полный барьер памяти.</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив и смещение в единицах Int,запишите элемент.Предполагается,что индекс находится в границах.Подразумевается полный барьер памяти.</target>
        </trans-unit>
        <trans-unit id="92bd8db55a8df2cebbe00df902cea1d4c45498b3" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0feba2d471191afd123d35121507798423702da8" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив,смещение в единицах Int,ожидаемое старое значение и новое значение,выполните атомарное сравнение и обмен,т.е.запишите новое значение,если текущее значение совпадает с предоставленным старым значением.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="abab7f85bdf29364faddd13dc4b78d374fc5dda4" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in machine words, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a4380d626de6e7a7cb655bd3acb03a426c4955" translate="yes" xml:space="preserve">
          <source>Given an array, an offset, the expected old value, and the new value, perform an atomic compare and swap (i.e. write the new value if the current value and the old value are the same pointer). Returns 0 if the swap succeeds and 1 if it fails. Additionally, returns the element at the offset after the operation completes. This means that on a success the new value is returned, and on a failure the actual old value (not the expected one) is returned. Implies a full memory barrier. The use of a pointer equality on a lifted value makes this function harder to use correctly than &lt;code&gt;casIntArray#&lt;/code&gt;. All of the difficulties of using &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; correctly apply to &lt;code&gt;casArray#&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Получить массив,и смещение в единицах Int,и значение в И,атомарно И значение в элементе.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив,и смещение в единицах Int,и значение в NAND,атомарно NAND значение в элементе.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Получить массив,и смещение в единицах Int,и значение в ИЛИ,атомически ИЛИ значение в элементе.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив и смещение в единицах Int,а также значение XOR,атомически XOR-значение для элемента.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Получив массив и смещение в единицах Int,а также значение для добавления,атоматически добавьте значение к элементу.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">Учитывая массив и смещение в единицах Int,а также значение для вычитания,атомарно вычитайте значение для элемента.Возвращает значение элемента перед операцией.Вводит барьер полной памяти.</target>
        </trans-unit>
        <trans-unit id="a30e79c6cce3e1df46121660ce9f45643cc0eeab" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a9ceb938d8f49b5b2ea5c52e2126a50123f314" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e005649850d5d7a3f7b482df99d3f3969f5374d" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71007d72dc6db74da700d9af9cc75f192be2766a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20812dbea90228bd71715ad0ffda8d1cecc9bc0" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8efe4a9e8663db39594eab24695687808cdd1d9" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">Учитывая, что тип &lt;code&gt;Int#&lt;/code&gt; не является &lt;code&gt;Type&lt;/code&gt; , из этого следует, что &lt;code&gt;Maybe Int#&lt;/code&gt; запрещено. Точно так же, поскольку переменные типа имеют тенденцию быть типа &lt;code&gt;Type&lt;/code&gt; (например, в &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; , все переменные типа имеют тип &lt;code&gt;Type&lt;/code&gt; ) полиморфизм не работает с примитивными типами. Если вернуться назад, в этом есть смысл, поскольку полиморфная функция должна манипулировать указателями на свои данные, а большинство примитивных типов распакованы.</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">Учитывая, что это работает с &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; допускается сбой, если вы запрашиваете 0 или меньше повторений, и определение по умолчанию сделает это.</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">Учитывая, что это работает с &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; допускается сбой, если вы запрашиваете 0 или меньше повторений, и определение по умолчанию сделает это.</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">Однако, учитывая информацию о зависимости, которая у нас есть для &lt;code&gt;Collects&lt;/code&gt; , мы можем сделать вывод, что &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; должны быть равны, потому что они оба появляются как второй параметр в ограничении &lt;code&gt;Collects&lt;/code&gt; с тем же первым параметром &lt;code&gt;c&lt;/code&gt; . Следовательно, мы можем вывести более короткий и точный тип для &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">Учитывая пример &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">Учитывая пример &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">Учитывая функциональность, предоставляемую GADT (обобщенные алгебраические типы данных), может показаться, что определение, подобное приведенному выше, должно быть осуществимым. Однако семейства типов - в отличие от GADT - &lt;em&gt;открыты; &lt;/em&gt;т. е. всегда можно добавить новые экземпляры, возможно, в других модулях. Для поддержки сопоставления с образцом в разных экземплярах данных потребуется форма расширяемой конструкции case.</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">Учитывая необходимый максимальный размер и функцию для создания содержимого ByteString, createAndTrim создает &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Генерирующая функция должна возвращать фактический окончательный размер (&amp;lt;= максимальный размер), и результирующий массив байтов повторно привязан к этому размеру.</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">Учитывая имя или путь к исполняемому файлу, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; ищет такой файл в списке определенных системой местоположений, который обычно включает &lt;code&gt;PATH&lt;/code&gt; и, возможно, многое другое. Если он найден, возвращается полный путь к исполняемому файлу. Например, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; обычно дает вам путь к GHC.</target>
        </trans-unit>
        <trans-unit id="779a07f028388c39babdff239bfbe6bdbccb0d49" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a CNF and the address of the root object in the old address space, fix up the internal pointers inside the CNF to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized CNF. It returns the new CNF and the new adjusted root address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">Учитывая указатель на первый блок компакт-диска и адрес корневого объекта в старом адресном пространстве,зафиксируйте внутренние указатели внутри компакт-диска,чтобы учесть другую позицию в памяти,чем когда она была сериализована.Этот метод должен быть вызван ровно один раз после импорта сериализованного компакт-диска,и возвращает новый компакт-диска и новый отрегулированный адрес корня.</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">Ниже приведены примеры хорошо сформированных и некорректных типов:</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">Давать &lt;code&gt;+RTS -?&lt;/code&gt; Параметр RTS option распечатает параметры RTS, фактически доступные в вашей программе (которые различаются в зависимости от того, как вы скомпилировали).</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">ПРАВИЛА для метода класса-плохая идея:</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">Glasgow Haskell - это изменяющаяся система, поэтому в ней обязательно будут ошибки. Если вы его найдете, посетите &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;эту страницу вики,&lt;/a&gt; чтобы узнать, как о нем сообщить.</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">Глобальное имя,связанное за пределами TH AST:Оригинальное имя (только вхождения,не привязки)Нужно пространство имен тоже,чтобы быть уверенным,какое имя мы имеем.</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">Перейдите на &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;домашнюю страницу GHC&lt;/a&gt; и перейдите по ссылке &amp;laquo;скачать&amp;raquo;, чтобы загрузить GHC для своей платформы.</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">Выходя за рамки &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#disambiguate-fields&quot;&gt;Устранение неоднозначности полей записи&lt;/a&gt; ), расширение &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt; позволяет объявлять несколько типов данных с использованием одних и тех же имен полей в одном модуле. Например, это позволяет:</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">Управляет максимальным размером, который GHC позволит разворачивать функции. (У разворачивания есть &amp;laquo;размер&amp;raquo;, который отражает стоимость с точки зрения &amp;laquo;раздутия кода&amp;raquo; расширения (также известного как встраивание), которое разворачивается на сайте вызова. Для большей функции будет назначена большая стоимость.)</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">Алгоритмы графиков</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">Графическое построение</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">Графики Свойства</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">Преобразования графиков</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">григорианский календарь</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">У группы есть разрешение на исполнение.</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">Группа прочитала разрешение.</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">Группа прочитала,написала и выполнила разрешение.</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">У группы есть письменное разрешение.</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Групповые операторы (как с &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">Защита от отрицательных значений результата</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">Защита от нулевых указателей</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">Охранники переводятся с помощью функции &lt;code&gt;guard&lt;/code&gt; , для которой требуется экземпляр &lt;code&gt;MonadPlus&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">Охрана операций ввода-вывода,которые могут провалиться</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Гай Блеллох, Даниэль Феризович и Ихан Сан, &amp;laquo; &lt;em&gt;Просто присоединяйтесь для параллельных упорядоченных множеств&lt;/em&gt; &amp;raquo;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">ХАКЕРСКАЯ ТЕРРИТОРИЯ.ХАКЕРСКАЯ ТЕРРИТОРИЯ.(Тебя предупредили.)</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">Обычно это не то,что ты хочешь делать!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPC отображает оба вида информации двумя основными способами: текстовые отчеты со сводной статистикой ( &lt;code&gt;hpc report&lt;/code&gt; ) и источники с цветной разметкой ( &lt;code&gt;hpc markup&lt;/code&gt; ). Для логического покрытия существует четыре возможных результата для каждого предохранителя, условия или квалификатора: встречаются значения True и False; только True; только False; никогда не оценивался. В выводе hpc-markup выделение желтым фоном указывает на часть программы, которая никогда не оценивалась; зеленый фон указывает на выражение &amp;laquo;всегда истинно&amp;raquo;, а красный фон указывает на выражение &amp;laquo;всегда ложно&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPC не пытается заблокировать файл &lt;code&gt;.tix&lt;/code&gt; , поэтому несколько одновременно работающих двоичных файлов в одном каталоге будут иметь состояние гонки. Во время компиляции невозможно изменить имя &lt;code&gt;.tix&lt;/code&gt; файла .tix ; во время выполнения имя созданного файла &lt;code&gt;.tix&lt;/code&gt; можно изменить с помощью &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; &lt;/a&gt; ; имя файла &lt;code&gt;.tix&lt;/code&gt; также изменится, если вы переименуете двоичный файл. HPC не работает с GHCi.</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">Инструментарий HPC включается с &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt; флага -fhpc :</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML - это класс вещей, которые можно корректно поместить в тег HTML. Таким образом, это может быть один или несколько элементов &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; или , например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML - это класс вещей, которые можно корректно поместить в тег HTML. Таким образом, это может быть один или несколько элементов &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; или , например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML - это класс вещей, которые можно корректно поместить в тег HTML. Таким образом, это может быть один или несколько элементов &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; или , например, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">Обращайтесь с ошибкой.</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">Сделай исключение.</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">Операции по работе с файлами,реализованные с помощью файловых дескрипторов (FD)</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">Свойства обработки</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">Ручка для чтения</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">Дескриптор для использования для &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; использовать существующий &lt;code&gt;stderr&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">Дескриптор для использования для стандартного &lt;code&gt;stdin&lt;/code&gt; (ничего =&amp;gt; использовать существующий стандартный &lt;code&gt;stdin&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">Дескриптор для использования для стандартного &lt;code&gt;stdout&lt;/code&gt; (ничего =&amp;gt; использовать существующий стандартный &lt;code&gt;stdout&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">Ручка,чтобы писать,чтобы</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">Обработчик для вызова,если возникает исключение.</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">Модификаторы типа обработки</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">Работа с жесткими ссылками с помощью Win32 API.[Только NTFS]</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">Обработка сигналов</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">Обработка символической ссылки с помощью Win32 API.[Vista of later и desktop app only].</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">Обработка сигнала &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">Обработка &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; сигнала</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">Обработка сигнала &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Передает буферизованные данные журнала событий автору записи журнала событий. Требуется для настраиваемого &lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">Имя по жесткой ссылке</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">Жёсткие ссылки</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">стеки вызовов HasCallStack</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">Хеширует &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; объект в &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; . Два &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; могут иметь одно и то же значение, хотя на практике это маловероятно. &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; вернулся делает хороший хэш - ключ.</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">У Haskeline есть два способа взаимодействия с пользователем:</target>
        </trans-unit>
        <trans-unit id="5d92a7b159921baa977febb12420c1df0529b818" translate="yes" xml:space="preserve">
          <source>Haskeline's behavior may be modified by editing your &lt;code&gt;~/.haskeline&lt;/code&gt; file. For details, see: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https://github.com/judah/haskeline/wiki/CustomKeyBindings&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010 и Haskell 98 позволяют задавать целочисленные литералы в десятичной, восьмеричной (с префиксом &lt;code&gt;0o&lt;/code&gt; или &lt;code&gt;0O&lt;/code&gt; ) или шестнадцатеричной нотации (с префиксом &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010 и Haskell 98 определяют плавающие литералы с синтаксисом &lt;code&gt;1.2e6&lt;/code&gt; . Эти литералы имеют тип &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">функции Хаскелла 2010</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98 позволяет программисту добавить &amp;laquo; &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; &amp;raquo; в объявление типа данных, чтобы сгенерировать стандартное объявление экземпляра для классов , указанных в &lt;code&gt;deriving&lt;/code&gt; п. В Haskell 98 единственные классы, которые могут появляться в &lt;code&gt;deriving&lt;/code&gt; предложении, - это стандартные классы &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; и &lt;code&gt;Show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98 позволяет программисту добавить в декларацию типа данных производное условие,сгенерировать стандартную декларацию экземпляра для указанного класса.GHC расширяет этот механизм по нескольким осям:</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98 позволяет определить реализацию по умолчанию при объявлении класса:</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98 запрещает типы методов класса упоминать об ограничениях на переменную типа класса,таким образом:</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98 рассматривает все четыре как неоднозначные, но с расширением &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; GHC примет первые два. Правила точно такие же, как и для объявлений экземпляров в Haskell 98, где имена методов в левой части привязок методов в объявлении экземпляра однозначно относятся к методу этого класса (при условии, что они вообще находятся в области видимости). , даже если в области видимости есть другие переменные с тем же именем. Это уменьшает количество полных имен при импорте двух записей из разных модулей, использующих одно и то же имя поля.</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; никогда не использует &quot;6-значную&quot; точность по умолчанию, используемую C printf.</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; печатает экспоненту чисел в электронном формате без лишнего знака плюс и с минимально возможным количеством цифр.</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; обрабатывает спецификатор &quot;точности&quot; как указатель количества цифр после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; по возможности помещает ноль после десятичной точки.</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Хаскелл позволяет задавать типы данных в зависимости от контекста,например</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">компилятор Haskell</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskell определяет операции для чтения и записи символов из файлов и в файлы, представленные значениями типа &lt;code&gt;Handle&lt;/code&gt; . Каждое значение этого типа - &lt;em&gt;дескриптор&lt;/em&gt; : запись, используемая системой времени выполнения Haskell для &lt;em&gt;управления&lt;/em&gt; вводом-выводом с объектами файловой системы. Дескриптор имеет как минимум следующие свойства:</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">Выражения Хаскелла могут быть набраны в подсказке:</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">файл Хаскелла</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">Идентификатор Haskell, например &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;Baz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskell определяет вид каждой переменной типа. Иногда приятно иметь возможность предоставить вид явно в виде (проверенной машиной) документации, так же как хорошо дать сигнатуру типа для функции. В некоторых случаях это необходимо. Например, в своей статье &amp;laquo;Ограниченные типы данных в Haskell&amp;raquo; (Haskell Workshop 1999) Джон Хьюз должен был определить тип данных:</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Лексер Хаскелла:возвращает лексическую строку,а не лексему.</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">У авторов библиотеки Хаскелла есть выбор.Большинство из них должны просто использовать Безопасные умозаключения.Если предположить,что вы избегаете каких-либо опасных функций языка,то ваши модули будут помечены как безопасные.Выводы против явных имеет следующие компромиссы:</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskell предлагает мощную систему типов и разделение чистых и эффективных функций через монаду &lt;code&gt;IO&lt;/code&gt; . Однако в системе типов есть несколько &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; , наиболее очевидной из которых является функция unsafePerformIO :: IO a -&amp;gt; a . Безопасный диалект языка Safe Haskell запрещает использование таких функций. Это может быть полезным ограничением, поскольку оно упрощает анализ кода Haskell и его обоснование. Он также кодифицирует существующую культуру в сообществе Haskell, которая пытается избегать небезопасных функций, если это не является абсолютно необходимым. Таким образом, использование безопасного языка (с помощью флага &lt;code&gt;-XSafe&lt;/code&gt; ) можно рассматривать как способ обеспечения хорошего стиля, аналогично функции &lt;code&gt;-Wall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskell предоставляет индексируемые &lt;em&gt;массивы&lt;/em&gt; , которые можно рассматривать как функции, домены которых изоморфны смежным подмножествам целых чисел. Ограниченные таким образом функции могут быть эффективно реализованы; в частности, программист может разумно ожидать быстрого доступа к компонентам. Чтобы гарантировать возможность такой реализации, массивы обрабатываются как данные, а не как общие функции.</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Представление Haskell для значений &lt;code&gt;errno&lt;/code&gt; . Реализация представлена ​​намеренно, чтобы пользователи могли добавлять свои собственные определения значений &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">Представления значений &lt;code&gt;errno&lt;/code&gt; в Haskell</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Исходные файлы Haskell могут быть названы в командной строке,и они будут загружены точно так же,как и в интерактивном режиме.Выражение оценивается в контексте загруженных модулей.</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskell указывает, что при компиляции модуля &lt;code&gt;M&lt;/code&gt; любое объявление экземпляра в любом модуле &amp;laquo;ниже&amp;raquo; &lt;code&gt;M&lt;/code&gt; является видимым. (Модуль &lt;code&gt;A&lt;/code&gt; находится &amp;laquo;ниже&amp;raquo; &lt;code&gt;M&lt;/code&gt; , если &lt;code&gt;A&lt;/code&gt; импортируется непосредственно &lt;code&gt;M&lt;/code&gt; , или если &lt;code&gt;A&lt;/code&gt; находится ниже модуля, который &lt;code&gt;M&lt;/code&gt; импортирует напрямую.) В принципе, GHC должен поэтому читать файлы интерфейса каждого модуля ниже &lt;code&gt;M&lt;/code&gt; , на всякий случай, если они содержат объявление экземпляра , что имеет значение для &lt;code&gt;M&lt;/code&gt; . На практике это было бы катастрофой, поэтому GHC пытается быть умным.</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">Символ Haskell, например &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">Резьба Хаскелла и резьба операционной системы</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Потоки Haskell могут обмениваться данными через &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; s, своего рода синхронизированную изменяемую переменную (см. &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt; ). Несколько общих абстракций параллелизма могут быть построены из &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , и они предоставляются библиотекой &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; . В GHC потоки также могут взаимодействовать через исключения.</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;FILE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c52c7986de5b1f1002d0a36e02ab2dcd634cb9aa" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79c49075305812472dc2df8b13ecac0efe944296" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f25580ef2a6155308670fc91ba09e1731599c485" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;clock_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be18749c4ec22337441649343d257d0370d5f71d" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий &lt;code&gt;double&lt;/code&gt; тип C.</target>
        </trans-unit>
        <trans-unit id="b2d34f9c0e00a8d1af686c82fb43c8d820dc5922" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип &lt;code&gt;float&lt;/code&gt; C.</target>
        </trans-unit>
        <trans-unit id="1c49950cb050a7da15661bd7e456a284ef08804b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;fpos_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebe2bccc8d0a138a668828ba79fe80867499c2cf" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecaafcc8282e441e1b10f5ce390edc54ce196b7b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;jmp_buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f0b2e804cd5163bf59ec18f25ed125a68b853e7" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4fc6d51b08d08bf0bcba3ee05d06de32a72f6f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий &lt;code&gt;long&lt;/code&gt; тип C.</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7d113d99751c0327aea4d8129f5aed9f4e0a54" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbd3c68fb579759e59f8406834e1d8e6ff601638" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий &lt;code&gt;short&lt;/code&gt; тип C.</target>
        </trans-unit>
        <trans-unit id="5b8524f5a4f304e126b6b8a367dfaecb35880702" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;sig_atomic_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3fa5599c0fc034cd4f240400ef25ab1428a1102" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C со &lt;code&gt;signed char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81af0438927840f3b83280a00faeb91e716cbe5a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="178d1b8d5a62b7a3369b736f6da7852035c7e2ba" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип &lt;code&gt;suseconds_t&lt;/code&gt; C.</target>
        </trans-unit>
        <trans-unit id="fe2ceebfe4035ae5db79a948b4348c1b6a632760" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;time_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ec168e35067e10a3716ba2d1e66444d65a0d79" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;unsigned char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba16416656c8c1c9c85455bf689f834b7cb3e7a3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;unsigned int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61828b7780ff4e1e0e7f03ddf27e366de45f4b08" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;unsigned long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180a5fcc065de54f77fac57594eab1aba819d926" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий &lt;code&gt;unsigned long&lt;/code&gt; тип C.</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388c8c93c58b5915ed0bbd05b942d6bcdbd88ea2" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий &lt;code&gt;unsigned short&lt;/code&gt; тип C.</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d9d916e0cff4b8f444a4bb2b23b5595b6e4e0a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;useconds_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0bee0937b5c01758b70e929129631f1bb26b33" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">Тип Haskell, представляющий тип C &lt;code&gt;wchar_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95906d00942f31be1d4b6bbf300429b06aed957" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">Сигнатуры типов Haskell неявно оцениваются количественно. Когда используется языковая опция &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; , ключевое слово &lt;code&gt;forall&lt;/code&gt; позволяет нам точно сказать, что это означает. Например:</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">В Haskell's &lt;code&gt;Maybe&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; (список), &lt;code&gt;ST&lt;/code&gt; (как строгая, так и ленивая версии), &lt;code&gt;IO&lt;/code&gt; и многие другие монады есть экземпляры &lt;code&gt;MonadFix&lt;/code&gt; . С другой стороны, монада продолжения с сигнатурой &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; не работает.</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">Механизм Haskell по умолчанию ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Отчет Haskell, раздел 4.3.4&lt;/a&gt; ) расширен для охвата строковых литералов, если указан &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt; . В частности:</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">Ограничение мономорфизма Haskell (см. &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Раздел 4.5.5&lt;/a&gt; отчета Haskell) можно полностью отключить с помощью &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt; . Начиная с GHC 7.8.1, ограничение мономорфизма отключено по умолчанию в интерактивных параметрах GHCi (см. &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Раздел Настройка параметров только для интерактивной оценки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Перегрузка Haskell (с использованием классов типов) элегантна, изящна и т. Д., И т. Д., Но это смерть производительности, если ее оставить во внутреннем цикле. Как его раздавить?</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">Хаскелийский интерфейс к memcpy и memmove</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">Пусть компилятор предупредит о дублирующих ограничениях в сигнатуре типа.Например</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">Компилятор должен предупреждать о повторяющихся записях в списках экспорта. Это полезная информация, если вы ведете большие списки экспорта и хотите избежать продолжения экспорта определения после того, как вы удалили (одно) упоминание о нем в списке экспорта.</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">Пусть компилятор предупредит о избыточных ограничениях в сигнатуре типа.В частности:</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">Пусть компилятор предупредит о избыточных ограничениях в сигнатурах типов.</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">Компилятор должен предупреждать, если Prelude импортирован неявно. Это происходит , если либо модуль Prelude явно не импортирован с &lt;code&gt;import ... Prelude ...&lt;/code&gt; линия, или это неявный импорт отключен (либо &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; прагме).</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">Пусть компилятор предупредит,если в исходном файле есть вкладки.</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">Пусть компилятор предупредит/сообщит вам,где в вашем исходнике применено ограничение мономорфизма Хаскелла.При бесшумном применении MR может привести к неожиданному поведению,поэтому может быть полезно иметь явное предупреждение о том,что оно применяется.</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">Попросите компилятор предупредить / проинформировать вас, где в вашем исходном коде срабатывает механизм по умолчанию Haskell для числовых типов. Это полезная информация при преобразовании кода из контекста, который принимает одно значение по умолчанию, в другое, например, 'default default' для Haskell 1.4 привело к тому, что в противном случае неограниченное значение &lt;code&gt;1&lt;/code&gt; было присвоено типу &lt;code&gt;Int&lt;/code&gt; , тогда как Haskell 98 и более поздние версии по умолчанию использовали его как &lt;code&gt;Integer&lt;/code&gt; . Это может привести к различиям в производительности и поведении, поэтому полезно не молчать об этом.</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">Скомпилировав программу для профилирования, вам теперь нужно запустить ее для создания профиля. Например, простой временной профиль можно создать, запустив программу с &lt;code&gt;+RTS -p&lt;/code&gt; (см. &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; ), которая создает файл с именем &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; где &amp;laquo;prog &amp;raquo;- это имя вашей программы (без расширения &lt;code&gt;.exe&lt;/code&gt; , если у вас Windows).</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">Запустив программу,мы можем сгенерировать текстовую сводку покрытия:</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">Сказав это, мы &lt;em&gt;можем&lt;/em&gt; точно задокументировать, что GHC делает в отношении состояния с плавающей запятой, так что, если вам действительно нужно использовать &lt;code&gt;fenv.h&lt;/code&gt; , вы можете сделать это, полностью зная о подводных камнях:</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">Голова и хвост струны сломаны на подложке</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">Фрагментация кучи</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">Функции помощника</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">Helper , чтобы полностью оценить &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; для использования в качестве &lt;code&gt;NFData(rnf)&lt;/code&gt; реализации</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">Helper , чтобы полностью оценить &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; для использования в качестве &lt;code&gt;NFData(rnf)&lt;/code&gt; реализации</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">Helper , чтобы полностью оценить &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; для использования в качестве &lt;code&gt;NFData(rnf)&lt;/code&gt; реализации</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">Помощники для &lt;code&gt;RealFloat&lt;/code&gt; класса RealFloat</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">Помощь в определении функций обёртки</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">Следовательно, исходное выражение должно иметь тип, являющийся экземпляром класса &lt;code&gt;Show&lt;/code&gt; , иначе GHCi пожалуется:</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">Здесь &lt;code&gt;A&lt;/code&gt; импортирует &lt;code&gt;B&lt;/code&gt; , но &lt;code&gt;B&lt;/code&gt; импортирует &lt;code&gt;A&lt;/code&gt; с прагмой &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; , которая нарушает циклическую зависимость. Каждый цикл в графе импорта модуля должен быть прерван импортом &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; ; или, что то же самое, граф импорта модуля должен быть ациклическим, если импорт &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">Здесь &lt;code&gt;a&lt;/code&gt; неоднозначно в определении &lt;code&gt;D&lt;/code&gt; , но позже будет определено как &lt;code&gt;Int&lt;/code&gt; с использованием приложений типов.</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;c&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; - параметры класса, но тип также индексируется по третьему параметру &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">Здесь &lt;code&gt;f1&lt;/code&gt; не использует синонимы паттернов. Для сопоставления с цифровым шаблоном &lt;code&gt;42&lt;/code&gt; &lt;em&gt;требует&lt;/em&gt; , чтобы вызывающего удовлетворять ограничения &lt;code&gt;(Num a, Eq a)&lt;/code&gt; , так что они появляются в &lt;code&gt;f1&lt;/code&gt; &amp;laquo;ы типа. Вызов &lt;code&gt;show&lt;/code&gt; генерирует ограничение &lt;code&gt;(Show b)&lt;/code&gt; , где &lt;code&gt;b&lt;/code&gt; - это переменная экзистенциального типа, связанная сопоставлением с шаблоном на &lt;code&gt;MkT&lt;/code&gt; . Но то же сопоставление с образцом также &lt;em&gt;обеспечивает&lt;/em&gt; ограничение &lt;code&gt;(Show b)&lt;/code&gt; (см. &lt;code&gt;MkT&lt;/code&gt; ), и поэтому все в порядке.</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">Здесь &lt;code&gt;f&lt;/code&gt; является обобщенным, потому что у него нет свободных переменных; и на его связывающую группу не действует ограничение мономорфизма; а значит, &lt;code&gt;f&lt;/code&gt; замкнуто. То же самое относится и к &lt;code&gt;g&lt;/code&gt; , за исключением того, что у него есть одна замкнутая свободная переменная, а именно &lt;code&gt;f&lt;/code&gt; . Аналогично &lt;code&gt;h&lt;/code&gt; закрывается, &lt;em&gt;даже если он не привязан на верхнем уровне&lt;/em&gt; , потому что его единственная свободная переменная &lt;code&gt;f&lt;/code&gt; закрыта. Но &lt;code&gt;k&lt;/code&gt; не является замкнутым, потому что он упоминает &lt;code&gt;x&lt;/code&gt; , который не является замкнутым (потому что он не ограничен let).</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">Здесь &lt;code&gt;f&lt;/code&gt; должен обновлять &lt;code&gt;T&lt;/code&gt; , потому что ни &lt;code&gt;S&lt;/code&gt; , ни &lt;code&gt;U&lt;/code&gt; не имеют обоих полей.</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">Здесь тип &lt;code&gt;h&lt;/code&gt; выглядит неоднозначно в &lt;code&gt;b&lt;/code&gt; , но здесь допустимый вызов:</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">Вот &lt;code&gt;strange&lt;/code&gt; тип &amp;laquo;s неоднозначно, но вызов в &lt;code&gt;foo&lt;/code&gt; в порядке , потому что это приводит к ограничению &lt;code&gt;(D Bool beta)&lt;/code&gt; , который растворим в &lt;code&gt;(D Bool b)&lt;/code&gt; , например.</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">Здесь &lt;code&gt;tag&lt;/code&gt; - это общедоступное поле с хорошо типизированной функцией селектора &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; . &lt;code&gt;self&lt;/code&gt; тип скрыт от внешней стороны; любая попытка применить &lt;code&gt;_this&lt;/code&gt; , &lt;code&gt;_inc&lt;/code&gt; или &lt;code&gt;_display&lt;/code&gt; как функции вызовет ошибку времени компиляции. Другими словами, &lt;em&gt;GHC определяет функцию селектора записей только для полей, тип которых не упоминает о переменных, определяемых количественно&lt;/em&gt; . (В этом примере используется подчеркивание в полях, для которых не будут определены селекторы записей, но это всего лишь стиль программирования; GHC их игнорирует.)</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">Здесь &lt;code&gt;x&lt;/code&gt; и привязка шаблона &lt;code&gt;(y,z)&lt;/code&gt; остаются ленивыми. Причина: нет подходящего момента, чтобы заставить их, до первого использования.</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">Здесь GHC перевел выражение на</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">Здесь GHC не будет разрешать ограничение &lt;code&gt;(C c Int)&lt;/code&gt; из экземпляра верхнего уровня, потому что конкретный вызов &lt;code&gt;g&lt;/code&gt; может создать экземпляры &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; одного и того же типа, что позволит решить ограничение другим способом. Это последнее ограничение в основном предназначено для того, чтобы решатель ограничений был завершен. (Заинтересованные люди могут прочитать &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; в &lt;code&gt;TcInteract&lt;/code&gt; .) Этого легко избежать: в сигнатуре типа избегайте ограничения, которое соответствует экземпляру верхнего уровня. Флаг &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; предупреждает о таких сигнатурах.</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">Вот несколько примеров совместного использования функций пути к &lt;code&gt;filepath&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">Приведем несколько примеров допустимых и противозаконных случаев:</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">Вот несколько примеров того,как работает этот перевод.Первое выражение каждой последовательности-Haskell source,последующие-Core.</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">Вот несколько примеров использования указанного представления. Рассмотрим несколько типов вселенной &lt;code&gt;Type&lt;/code&gt; , закодированных следующим образом:</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">Вот несколько примеров,иллюстрирующих это свойство:</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">Вот некоторые списки экспорта и их значение:</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">Вот еще некоторые детали:</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">Вот некоторые другие важные моменты использования рекурсивной нотации:</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">Вот различия между сгенерированным кодом для &lt;code&gt;Functor&lt;/code&gt; и &lt;code&gt;Foldable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">Ниже приведены различия между сгенерированным кодом в каждом расширении:</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">Вот ключевые определения, все они доступны в &lt;code&gt;GHC.Exts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">Вот основные особенности</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">Здесь следуйте за свойствами:</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">Вот краткое описание синтаксиса этого файла:</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">Вот рекурсивный случай</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">Вот сокращенное представление &lt;code&gt;Tree&lt;/code&gt; с удаленной почти всей метаинформацией, пока сохранены только самые важные аспекты:</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">Вот простой (хотя и надуманный)пример:</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">Вот простой нерекурсивный случай:</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">Вот пример &lt;code&gt;mdo&lt;/code&gt; -expression и его перевод в блоки &lt;code&gt;rec&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">Вот пример программы с парой SCC:</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">Вот пример того, как можно получить &lt;code&gt;Lift&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">Вот пример этого в действии:</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">Приведем пример использования числовых литералов уровня типа для обеспечения безопасного интерфейса с низкоуровневой функцией:</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">Приведем пример использования строковых литералов уровня типа для моделирования простых операций с записями:</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">Вот пример, демонстрирующий использование настраиваемого типа данных &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; с механизмом исключения &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . В примере возникает исключение, если пользователь вводит пустую строку или строку длиной более 5 символов. В противном случае он печатает длину строки.</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">Вот пример, демонстрирующий использование настраиваемого типа данных ошибки с механизмом исключения &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; из &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; . В примере возникает исключение, если пользователь вводит пустую строку или строку длиной более 5 символов. В противном случае он печатает длину строки.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">Вот расширение примера доступа к записи в &lt;a href=&quot;#type-level-literals&quot;&gt;литералах уровня типа,&lt;/a&gt; показывающее, как перегруженную метку можно использовать в качестве селектора записи:</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">Вот что делает этот пример:</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">Здесь &lt;code&gt;Eq [a]&lt;/code&gt; в сигнатуре перекрывается с экземпляром верхнего уровня для &lt;code&gt;Eq [a]&lt;/code&gt; . GHC прилагает некоторые усилия, чтобы использовать первое, но если ему следует использовать второе, тогда у него будет неразрешимое ограничение &lt;code&gt;Eq a&lt;/code&gt; . Лучше всего вместо этого писать:</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">Здесь вызов &lt;code&gt;(==)&lt;/code&gt; заставляет GHC думать, что ограничение &lt;code&gt;(Eq a)&lt;/code&gt; необходимо, поэтому предупреждение не выдается.</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">Здесь определение &lt;code&gt;id&lt;/code&gt; будет отклонено, поскольку переменная типа &lt;code&gt;t&lt;/code&gt; появляется только в приложениях семейства типов и поэтому неоднозначна. Но этот код будет принят, если мы сообщим GHC, что &lt;code&gt;Id&lt;/code&gt; является инъективным, что означает, что можно будет вывести &lt;code&gt;t&lt;/code&gt; на сайтах вызовов по типу аргумента:</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">Здесь подпись в объявлении экземпляра более полиморфна,чем требуется методом инстанцированного класса.</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">Здесь цикл суперкласса завершается, но это не совсем очевидно.</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">Здесь сигнатура типа на выражении может быть протолкнута внутрь,чтобы дать сигнатуру типа для f.Аналогично,и чаще всего,можно дать сигнатуру типа для самой функции:</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">Здесь переменная типа &lt;code&gt;a&lt;/code&gt; не появляется в типе результата любого конструктора. Хотя она универсально определяется типом конструктора, такая переменная типа часто называется &amp;laquo;экзистенциальной&amp;raquo;. Действительно, приведенное выше объявление объявляет точно такой же тип, что и &lt;code&gt;data Foo&lt;/code&gt; в конструкторах &lt;a href=&quot;#existential-quantification&quot;&gt;экзистенциально количественно определяемых данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">Здесь переменная универсального типа &lt;code&gt;a&lt;/code&gt; охватывает определение &lt;code&gt;P&lt;/code&gt; , а экзистенциальная переменная &lt;code&gt;b&lt;/code&gt; - нет. (см. обсуждение Trac # 14998.)</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">Здесь мы не можем вывести пример</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">Здесь нам не нужно указывать сигнатуру типа для &lt;code&gt;w&lt;/code&gt; , потому что это аргумент конструктора &lt;code&gt;T1&lt;/code&gt; , который сообщает GHC все, что ему нужно знать.</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">Здесь мы даем два объявления экземпляра данных, в одном из которых последний параметр равен &lt;code&gt;[v]&lt;/code&gt; , а в &lt;code&gt;Int&lt;/code&gt; - Int . Поскольку вы не можете предоставить какие-либо &lt;em&gt;последующие&lt;/em&gt; экземпляры для &lt;code&gt;(GMap Flob ...)&lt;/code&gt; , эта возможность наиболее полезна, когда свободный индексированный параметр относится к типу с конечным числом альтернатив (в отличие от &lt;code&gt;Type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">Здесь мы использовали параметр &lt;code&gt;-V0&lt;/code&gt; системы времени выполнения, чтобы отключить периодический таймер RTS, который может помешать нашему сеансу отладки. После взлома программы &lt;code&gt;gdb&lt;/code&gt; показывает нам место в нашей исходной программе, соответствующее текущей точке выполнения.</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">Здесь мы используем экземпляр &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">Здесь мы замечаем, что первый бит трассировки стека имеет много неопознанных кадров стека по адресу &lt;code&gt;0x006eb0c0&lt;/code&gt; . Если мы спросим &lt;code&gt;gdb&lt;/code&gt; об этом местоположении, мы обнаружим, что эти фреймы на самом деле являются закрытием обновлений STG,</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">Здесь мы используем &lt;code&gt;calculateLength&lt;/code&gt; , заставляя его передавать результат на &lt;code&gt;print&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">Здесь мы используем &lt;a href=&quot;#class-default-signatures&quot;&gt;подпись&lt;/a&gt; по умолчанию, чтобы указать, что пользователю не нужно предоставлять реализацию для &lt;code&gt;put&lt;/code&gt; , пока существует &lt;code&gt;Generic&lt;/code&gt; экземпляр для типа, который нужно создать. Например , для типа &lt;code&gt;UserTree&lt;/code&gt; пользователь может просто написать:</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">Здесь мы использовали параметр &lt;code&gt;-g&lt;/code&gt; , чтобы сообщить GHC, что он должен добавить отладочную информацию в создаваемый двоичный файл. Существует три уровня отладочного вывода: &lt;code&gt;-g0&lt;/code&gt; (без отладочной информации, по умолчанию), &lt;code&gt;-g1&lt;/code&gt; (достаточно для базовой трассировки), &lt;code&gt;-g2&lt;/code&gt; (или просто &lt;code&gt;-g&lt;/code&gt; для краткости; выдача всего, что знает GHC). Обратите внимание, что эта отладочная информация не влияет на оптимизацию, выполняемую GHC.</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Вот пример команды, которая принимает аргумент. Это повторная реализация &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">Вот эмпирическое правило для принятия решения о том,какую функцию в стиле catch-style использовать:</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">Здесь &lt;code&gt;(!:)&lt;/code&gt; - рекурсивная функция, индексирующая массивы типа &lt;code&gt;Arr e&lt;/code&gt; . Рассмотрим вызов &lt;code&gt;(!:)&lt;/code&gt; в типе &lt;code&gt;(Int,Int)&lt;/code&gt; . Сработает вторая специализация, и будет встроена специализированная функция. Он имеет два вызова &lt;code&gt;(!:)&lt;/code&gt; , оба с типом &lt;code&gt;Int&lt;/code&gt; . Оба эти вызова fire - первая специализация, тело которой также встроено. Результатом является развертывание функции индексации на основе типов.</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">Здесь &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; упаковывает целое число с функцией, &lt;code&gt;even&lt;/code&gt; отображающей целое число в &lt;code&gt;Bool&lt;/code&gt; ; а &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; упаковывает символ с совместимой функцией. Эти две вещи относятся к типу &lt;code&gt;Foo&lt;/code&gt; и могут быть помещены в список.</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">Здесь &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; - это прокси-сервер уровня типа, не имеющий связанных значений.</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">Здесь &lt;code&gt;Adder&lt;/code&gt; - это имя корневого модуля в дереве модулей (как упоминалось выше, должен быть один корневой модуль и, следовательно, одно дерево модулей в DLL). Скомпилируйте все:</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">Здесь &lt;code&gt;C&lt;/code&gt; представляет собой суперкласс &lt;code&gt;D&lt;/code&gt; , но это нормально для операции класса &lt;code&gt;op&lt;/code&gt; из &lt;code&gt;C&lt;/code&gt; говоря &lt;code&gt;D&lt;/code&gt; . (Было бы неправильно, если бы &lt;code&gt;D&lt;/code&gt; был суперклассом &lt;code&gt;C&lt;/code&gt; . )</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">Здесь &lt;code&gt;a&lt;/code&gt; импортируется, а &lt;code&gt;c&lt;/code&gt; привязан к верхнему уровню, поэтому ни один из них не способствует расширению &quot; &lt;code&gt;..&lt;/code&gt; &quot;. Мотивация здесь заключается в том, чтобы читателю было легко понять, до чего же расширяется &amp;laquo; &lt;code&gt;..&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">Здесь &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;g1&lt;/code&gt; являются типами ранга 1 и могут быть записаны в стандартном Haskell (например, &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ). &lt;code&gt;forall&lt;/code&gt; делает явные универсальные квантификации , который неявно добавлен Haskell.</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;f2&lt;/code&gt; строго по &lt;code&gt;x&lt;/code&gt; , но не по &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">Здесь &lt;code&gt;f3&lt;/code&gt; и &lt;code&gt;f4&lt;/code&gt; идентичны; вставка перед шаблоном, который в любом случае требует оценки, ничего не дает.</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;g&lt;/code&gt; имеет неоднозначный тип и отклоняется, но &lt;code&gt;f&lt;/code&gt; подойдет. Привязка для &lt;code&gt;?x&lt;/code&gt; в сайте вызова &lt;code&gt;f&lt;/code&gt; довольно однозначна и фиксирует тип &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">Здесь &lt;code&gt;lookup&lt;/code&gt; объявлен &lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; , но он не может быть специализирован для типа &lt;code&gt;T&lt;/code&gt; на сайте его определения, потому что этот тип еще не существует. Вместо этого клиентский модуль может определить &lt;code&gt;T&lt;/code&gt; , а затем специализировать &lt;code&gt;lookup&lt;/code&gt; по этому типу.</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;m x&lt;/code&gt; зависит от значения &lt;code&gt;x&lt;/code&gt; , созданного первым оператором, поэтому выражение не может быть переведено с помощью &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">Здесь значение типа &lt;code&gt;NumInst a&lt;/code&gt; эквивалентно явному &lt;code&gt;(Num a)&lt;/code&gt; словарю.</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">Здесь, после того, как GHC встроит тело &lt;code&gt;foldl&lt;/code&gt; в сайт вызова, он будет очень агрессивно выполнять специализацию шаблона вызова на &lt;code&gt;foldl_loop&lt;/code&gt; из-за использования &lt;code&gt;SPEC&lt;/code&gt; в аргументе тела цикла. &lt;code&gt;SPEC&lt;/code&gt; от &lt;code&gt;GHC.Types&lt;/code&gt; распознается компилятором.</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">Здесь, хотя правая часть &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; упоминает рода переменную , которая не происходит на стороне левой руки, это приемлемо, поскольку является &lt;em&gt;неявно&lt;/em&gt; связан &lt;code&gt;T&lt;/code&gt; роде шаблон &amp;laquo;ы. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">Здесь очевидно, что попытка использовать тип &lt;code&gt;T Loop&lt;/code&gt; приведет к зацикливанию проверки типов, поскольку его определение повторяется бесконечно. В других случаях вам может потребоваться включить &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; ,&lt;/a&gt; даже если сгенерированный код не помещает проверку типов в цикл. Например:</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">Здесь ни &lt;code&gt;D&lt;/code&gt; , ни &lt;code&gt;T&lt;/code&gt; не объявлены в модуле &lt;code&gt;Orphan&lt;/code&gt; . Мы называем такие модули &amp;laquo;сиротскими модулями&amp;raquo;. GHC идентифицирует &quot;бесхозные&quot; модули и обращается к интерфейсному файлу каждого &quot;сиротского&quot; модуля ниже компилируемого модуля. Обычно это бесполезная работа, но ее невозможно избежать. Поэтому вам следует сделать все возможное, чтобы у вас было как можно меньше сиротских модулей.</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">Здесь только &lt;code&gt;b&lt;/code&gt; является полиморфным по легкомыслию. Переменных с легкомысленно-полиморфным типом нет. И у генератора кода с этим нет проблем. В самом деле, это истинный тип оператора &lt;code&gt;$&lt;/code&gt; GHC , немного более общий, чем версия Haskell 98.</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">Здесь сигнатуры образцов для &lt;code&gt;ys&lt;/code&gt; и &lt;code&gt;zs&lt;/code&gt; в порядке, но сигнатуры для &lt;code&gt;v&lt;/code&gt; нет, потому что &lt;code&gt;b&lt;/code&gt; не входит в область видимости.</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">Здесь сигнатура типа шаблона &lt;code&gt;[t::a]&lt;/code&gt; упоминает переменную лексического типа, которая еще не входит в область видимости. В самом деле, он уже &lt;em&gt;не должен&lt;/em&gt; быть в области видимости, потому что он связан с сопоставлением с образцом. Эффект заключается в том, чтобы ввести его в область видимости, что означает переменную экзистенциально привязанного типа.</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">Здесь количественное ограничение для &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; ведет себя немного как объявление локального экземпляра и делает его типизируемым.</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">Здесь в правой части экземпляра данных упоминается переменная типа &lt;code&gt;d&lt;/code&gt; , которая не встречается в его левой части. Мы не можем допускать такие экземпляры данных, поскольку они могут поставить под угрозу безопасность типов.</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">Здесь тип, связанный &lt;code&gt;MkFoo&lt;/code&gt; , &amp;laquo;ускользает&amp;raquo;, потому что &lt;code&gt;a&lt;/code&gt; является результатом &lt;code&gt;f1&lt;/code&gt; . Один из способов понять, почему это неправильно, - спросить, какой тип у &lt;code&gt;f1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">Здесь подпись типа для &lt;code&gt;forall s. ST s Bool&lt;/code&gt; переносит переменную типа &lt;code&gt;s&lt;/code&gt; в область видимости в аннотированном выражении &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное кодирование &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное кодирование слова &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное кодирование &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное кодирование &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Шестнадцатеричное кодирование &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">шестнадцатеричные числа</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">Скрытые пакеты (те, для которых &lt;code&gt;exposed&lt;/code&gt; флаг &lt;code&gt;False&lt;/code&gt; ) показаны в скобках в списке пакетов.</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">Скрыть все пакеты по умолчанию</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">Скрыть все пакеты для плагинов по умолчанию</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">Скрыть пакет ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">Максимально допустимый приоритет оператора для конструктора &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; (ответ: 9)</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">Максимально допустимый приоритет оператора для конструктора &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; (ответ: 9)</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">Исторически &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; является более безопасной альтернативой идиоме &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">Исторически &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; является более безопасной альтернативой идиоме &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">С другой стороны, наличие &lt;code&gt;Weak ThreadId&lt;/code&gt; не помешает потоку получать исключения &lt;code&gt;BlockedIndefinitely&lt;/code&gt; . По-прежнему можно создать исключение для &lt;code&gt;Weak ThreadId&lt;/code&gt; , но вызывающий должен сначала использовать &lt;code&gt;deRefWeak&lt;/code&gt; , чтобы определить, существует ли еще поток.</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">Главная директория (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">Хост-сендианное,не выровненное декодирование</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">Хост-сендиант,неподписанные писания</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">Двоичные кодировки,специфичные для хоста</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">Час двенадцать</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">час ноль</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">Как резидентность кучи, сообщаемая профилировщиком кучи, соотносится с фактическим размещением в памяти вашей программы при ее запуске? Вы можете увидеть большое несоответствие между резидентностью, сообщаемой профилировщиком кучи, и резидентностью, сообщаемой инструментами в вашей системе (например, &lt;code&gt;ps&lt;/code&gt; или &lt;code&gt;top&lt;/code&gt; в Unix или диспетчером задач в Windows). На это есть несколько причин:</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">Насколько компилятор должен быть готов к встраиванию словарей?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">Насколько компилятор должен быть готов к встроенным функциям?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">Как долго работала программа (процессорное время и прошедшее время настенных часов).</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">Сколько времени заняла уборка мусора (процессорное время и истекшее время настенных часов).</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">Сколько байт в настоящее время в прямом эфире.</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">Сколько байт программа выделила,находясь внутри этого стоимостного центра? Это не включает в себя ассигнования в центрах расходов на детей.</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">Сколько байт читать</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">Сколько байт мы выделили на эту сборку мусора.</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">Сколько байт мы скопировали эту мусорную коллекцию.</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">Сколько возможностей была запущена в программе (например, с использованием опции &lt;code&gt;-N ⟨x⟩&lt;/code&gt; ). Обратите внимание, что количество возможностей может измениться во время выполнения из-за функции &lt;code&gt;setNumCapabilities&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">Сколько ошибок на странице произошло с момента окончания последней уборки мусора.</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">Сколько ошибок произошло при сборе мусора.</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">Сколько &amp;laquo;тиков&amp;raquo; профилировщика прошло за время выполнения программы.</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Сколько кадров стека в данном &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">Сколько тиков выполнялась программа внутри этого центра затрат? Это не включает дочерние центры затрат.</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">Сколько раз входил этот центр затрат?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">Сколько времени между тиками профилировщика.</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">Как определить stderr</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">Как определить stdin</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">Как определить stdout</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">Как обрабатывать знак числового поля. Они являются взаимоисключающими, с приоритетом &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">Однако, если вы используете &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; , тогда GHC вместо этого использует все, что находится в области видимости с именами &lt;code&gt;toList&lt;/code&gt; , &lt;code&gt;fromList&lt;/code&gt; и &lt;code&gt;fromListN&lt;/code&gt; . То есть эти функции могут быть повторно привязаны; cf &lt;a href=&quot;#rebindable-syntax&quot;&gt;Синтаксис с возможностью повторной привязки и неявный импорт Prelude&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">Однако см. &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Тип, класс и другие объявления&lt;/a&gt; для правил перекрытия в GHCi.</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">Однако позаботьтесь о том, чтобы сгенерированные определения все еще находились на входе &lt;code&gt;typeCheckResultAction&lt;/code&gt; . Если вы не позаботитесь о фильтрации входных данных с проверкой типов, поведение вашего инструмента может быть непоследовательным.</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">Однако &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; монады не является:</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Однако использовать Debug.Trace.trace можно, потому что он использует поддержку вывода отладки Windows, а не &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">Однако &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; создает &lt;em&gt;связанный&lt;/em&gt; поток, что необходимо, если вам нужно вызвать сторонние (не Haskell) библиотеки, которые используют локальное состояние потока, например OpenGL (см. &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">Однако &lt;em&gt;вложенные&lt;/em&gt; челки в привязку с образцом let / where ведут себя одинаково со всеми другими формами сопоставления с образцом. Например</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">Однако,помимо этих ограничений,разрешено многое,в том числе и выражения,которые оцениваются не в полной мере! Выражения аннотаций будут вычисляться компилятором точно так же,как и Template Haskell splices.Таким образом,эта аннотация в порядке:</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">Однако, поскольку GHC должен &lt;em&gt;вывести&lt;/em&gt; тип, когда часть типа опущена, он не может использовать полиморфную рекурсию. Такое же ограничение имеет место, когда подпись типа полностью опущена.</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">Однако с помощью простого расширения системы классов типов Haskell мы можем поддерживать динамическое связывание. По сути, мы выражаем использование динамически связанной переменной как ограничение типа. Эти ограничения приводят к типам вида &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; , который говорит, что &amp;laquo;эта функция использует динамически связанную переменную &lt;code&gt;?x&lt;/code&gt; типа &lt;code&gt;t'&lt;/code&gt; &amp;raquo;. Например, следующее выражает тип функции сортировки, неявно параметризуемой функцией сравнения с именем &lt;code&gt;cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">Однако,рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">Однако включение расширения &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; позволяет модулю компилироваться. Подобные ошибки могут возникать с различными расширениями, в том числе:</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">Однако для GADT существует следующее дополнительное ограничение: каждый конструктор, имеющий поле &lt;code&gt;f&lt;/code&gt; , должен иметь один и тот же тип результата (по модулю альфа-преобразования). Следовательно, в приведенном выше примере мы не можем объединить поля &lt;code&gt;num&lt;/code&gt; и &lt;code&gt;arg&lt;/code&gt; в одно имя. Хотя их типы полей являются &lt;code&gt;Term Int&lt;/code&gt; , их функции выбора на самом деле имеют разные типы:</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">Однако для большинства приложений достаточно просто использовать флаги &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">Однако, если &lt;code&gt;CProv&lt;/code&gt; непусто, а &lt;code&gt;CReq&lt;/code&gt; есть, указанная выше сигнатура типа шаблона для &lt;code&gt;P&lt;/code&gt; должна быть указана как</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">Однако, если &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; оканчивается разделителем, к пути добавляются базы данных по умолчанию (т. Е. Базы данных пользователей и глобальных пакетов в указанном порядке). Например, чтобы дополнить обычный набор пакетов собственной базой данных, вы можете сказать (в Unix):</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Однако, если вы хотите взаимодействовать с сторонней библиотекой, которая ожидает, что ваша программа будет использовать пакет потоков, предоставляемый операционной системой, вы можете сделать это, используя &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">Тем не менее, во всех моделей &lt;em&gt;других&lt;/em&gt; , чем шаблон привязки, тип модели подписи может ссылаться на переменную типа, которое не находится в области действия; в этом случае &lt;em&gt;подпись переносит эту переменную типа в область видимости&lt;/em&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">Однако, похоже, что если вы добавите пробел в конец строки, то &lt;code&gt;cpp&lt;/code&gt; (по крайней мере, GNU &lt;code&gt;cpp&lt;/code&gt; и, возможно, другие &lt;code&gt;cpp&lt;/code&gt; s) оставит только пары обратной косой черты и пробела, и разрыв строки будет работать, как ожидалось.</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">Однако можно выполнить некоторую &amp;laquo;обратную&amp;raquo; оценку. Например, вот как мы можем заставить GHC вычислять произвольные логарифмы на уровне типа:</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">Однако пользователю утомительно указывать тип, поэтому GHCi расширяет правила Haskell по умолчанию для типов (раздел 4.3.4 отчета Haskell 2010 Report) следующим образом. Стандартные правила принимают каждую группу ограничений &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; для каждой переменной типа &lt;code&gt;a&lt;/code&gt; и по умолчанию устанавливают переменную типа, если</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">Однако,не все потеряно.Мы все еще можем это сделать:</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">Однако обратите внимание, что разумно иметь модуль &lt;code&gt;Main&lt;/code&gt; в файле с именем &lt;code&gt;foo.hs&lt;/code&gt; , но это работает только потому, что GHC никогда не нужно искать интерфейс для модуля &lt;code&gt;Main&lt;/code&gt; (потому что он никогда не импортируется). Следовательно, можно иметь несколько &lt;code&gt;Main&lt;/code&gt; модулей в отдельных исходных файлах в одном каталоге, и GHC не запутается.</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">Однако,независимо от установки флага,квантификаторы печатаются в этих условиях:</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">Однако, начиная с версии 8.4, это уже не так: GHC &lt;strong&gt;гарантирует,&lt;/strong&gt; что сборка мусора никогда не произойдет во время &lt;code&gt;unsafe&lt;/code&gt; вызова, даже в интерпретаторе байт-кода, а также гарантирует, что &lt;code&gt;unsafe&lt;/code&gt; вызовы будут выполнены в вызывающем потоке.</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">Однако иногда таких призывов не бывает,и в этом случае прагма может оказаться полезной.</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">Однако автономное производное предложение отличается от &lt;code&gt;deriving&lt;/code&gt; предложения по ряду важных аспектов:</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">Однако, начиная с &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; , реализация по умолчанию основана на &lt;code&gt;DefaultSignatures&lt;/code&gt; , что позволяет создавать более точные автоматически производные экземпляры &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; . Если вам нужна ранее использовавшаяся точная &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; реализации метода rnf по умолчанию , используйте</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">Однако обе аксиомы &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; и &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; соответствуют желаемому ограничению &lt;code&gt;C a&lt;/code&gt; . Есть несколько возможных подходов к работе с этими перекрывающимися локальными аксиомами:</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">Однако объявление экземпляра должно по-прежнему соответствовать правилам завершения экземпляра: см. &lt;a href=&quot;#instance-termination&quot;&gt;Правила завершения экземпляра&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">Однако в реальной реализации для сравнения только конца строки используется memcmp,при этом обратного пути нет...</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">Однако второй закон нарушается в присутствии неопределенных операторов,</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">Однако эти два термина, безусловно, связаны. Используя несколько процессоров, можно запускать параллельные потоки параллельно, и это именно то, что делает поддержка параллелизма SMP GHC. Но также можно добиться повышения производительности с помощью параллелизма для программ, которые не используют параллелизм. В этом разделе описывается, как использовать GHC для компиляции и запуска параллельных программ. В &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent и Parallel Haskell&lt;/a&gt; мы описываем особенности языка, которые влияют на параллелизм.</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">Однако неограниченное использование &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; является проблемой, поскольку произвольный модуль может использовать его, чтобы пометить себя как доверенный, но &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; не предлагает никаких гарантий в отношении модуля, в отличие от &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; . Чтобы контролировать использование надежных модулей, рекомендуется использовать флаг &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; . Этот флаг добавляет дополнительное требование к проверке доверия для надежных модулей. Это требует, чтобы надежные модули считались доверенными и разрешалось использовать в &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;скомпилированный код, клиент C, компилирующий код, должен сообщить GHC, что он доверяет пакету, в котором находится надежный модуль. Это, по сути, способ сказать C, в то время как этот пакет содержит надежные модули, которые могут использоваться ненадежными модулями, скомпилированными с помощью &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , Я доверяю автору (ам) этого пакета и верю, что модули предоставляют только безопасный API. Доверие пакета можно изменить в любое время, поэтому, если в пакете обнаружена уязвимость, C может объявить этот пакет ненадежным, чтобы любая будущая компиляция этого пакета завершилась ошибкой. Более подробный обзор этого механизма см. В &lt;a href=&quot;#safe-trust&quot;&gt;разделах Trust и Safe Haskell Modes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">Однако у этого подхода есть несколько проблем. Во-первых, наличие двух обработчиков исключений неэффективно. Однако более серьезная проблема заключается в том, что второй обработчик исключений перехватывает исключения в первом, например, в приведенном выше примере, если &lt;code&gt;handleArith&lt;/code&gt; генерирует &lt;code&gt;IOException&lt;/code&gt; , то второй обработчик исключений перехватывает его.</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Однако есть функции для создания транзакционных переменных, которые всегда можно безопасно вызывать в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . См .: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Однако есть функции для создания транзакционных переменных, которые всегда можно безопасно вызывать в &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . См .: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Однако есть функции для создания транзакционных переменных, которые всегда можно безопасно вызывать в &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . См .: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">Однако это трудно реализовать в некоторых операционных системах, отличных от Unix, поэтому вместо этого для максимальной переносимости мы просто возвращаем конечное имя программы в том виде, в каком она была вызвана. Даже в этом случае между платформами есть некоторые различия: например, в Windows программа, вызываемая как foo, вероятно, на самом деле &lt;code&gt;FOO.EXE&lt;/code&gt; , и именно это будет возвращать &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">Однако это трудно реализовать в некоторых операционных системах, отличных от Unix, поэтому вместо этого для максимальной переносимости мы просто возвращаем конечное имя программы в том виде, в каком она была вызвана. Даже в этом случае между платформами есть некоторые различия: например, в Windows программа, вызываемая как foo, вероятно, на самом деле &lt;code&gt;FOO.EXE&lt;/code&gt; , и именно это будет возвращать &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">Однако это быстро становится утомительным при определении функций с множественными пунктами или группами взаимно рекурсивных функций,потому что полное определение должно быть дано на одной строке,с использованием явных точек с запятой,а не компоновки:</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">Однако это не разрешено, поскольку &lt;code&gt;x&lt;/code&gt; неоднозначно:</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">Тем не менее,экземпляры классов типов экземпляров семейств данных могут быть определены так же,как и любые другие типы данных.Например,можно сказать</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">Однако мы не делаем выводов о типе аргумента для определения типа данных и не имеем возможности отложить выбор до решателя ограничений.Таким образом,следующее является двусмысленным:</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">Однако, если &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; установлен, например, на &lt;code&gt;1&lt;/code&gt; , он дополнительно предложит список подходящих отверстий для уточнения, в этом случае:</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">аббревиатуры Html</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">цвета Html</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">Ошибка ввода/вывода,определяемая программистом.</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">Ошибка ввода/вывода,при которой операция завершилась неудачей из-за того,что один из ее аргументов уже существует.</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">Ошибка ввода/вывода,при которой операция завершилась неудачно из-за отсутствия одного из аргументов.</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">Ошибка ввода/вывода,при которой операция провалилась из-за того,что одним из аргументов является одноразовый ресурс,который уже используется.</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">Ошибка ввода/вывода,при которой операция завершилась неудачно из-за переполнения устройства.</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">Ошибка ввода/вывода,при которой операция не удалась,так как был достигнут конец файла.</target>
        </trans-unit>
        <trans-unit id="82239ba587720ead23fb3ec489cdc8f072db7a33" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e0ff159cdede7a57ee03fa0daa909d8ace6979" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. This happens when, for example, attempting to write to a closed socket or attempting to write to a named pipe that was deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">Ошибка ввода/вывода,если операция не удалась из-за того,что у пользователя не было достаточных привилегий операционной системы для выполнения этой операции.</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">Ошибка ввода/вывода в случае невозможности выполнения операции.</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">ошибки ввода/вывода</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операции ввода-вывода, необходимые для реализации &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;ByteString&lt;/code&gt; вывод с помощью ByteString s</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">Вход/выход с ручками</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">Идентификация группы.</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">Идентификатор владельца.</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">ID устройства,на котором находится этот файл.</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">Функции ввода-вывода для сериализации</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">Типы и функции исключений,связанных с вводом/выводом</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
