<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="5e7e07a35842fb9e4e49f081c6500aa5f24d9520" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексем анализирует натуральное число (положительное целое число). Возвращает значение числа. Число может быть указано в &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; формате . Число анализируется в соответствии с правилами грамматики в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="ace0ef235b44c04e9847cae55d4c39fc3655ea48" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексем анализирует натуральное число (положительное целое число). Возвращает значение числа. Число может быть указано в &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; формате . Число анализируется в соответствии с правилами грамматики в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="5b51da9dfdc6deacb56625f72d3743f1f276426c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">Этот лексемный парсер разбирает один буквальный символ.Возвращает значение буквенного символа.Этот синтаксический анализатор корректно работает с экранирующими последовательностями.Символ литерала анализируется в соответствии с правилами грамматики,определенными в отчете Хаскелла (который достаточно близко соответствует большинству языков программирования).</target>
        </trans-unit>
        <trans-unit id="df49a67e0891da13df2aeac391d3a61690541ebd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексем анализирует целое число (целое число). Этот синтаксический анализатор похож на &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; за исключением того, что он может иметь префикс со знаком (например, &amp;laquo;-&amp;raquo; или &amp;laquo;+&amp;raquo;). Возвращает значение числа. Число может быть указано в &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; формате . Число анализируется в соответствии с правилами грамматики в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="ca0065c43e88f0ea0be37c852f441cefb8de14a7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексем анализирует целое число (целое число). Этот синтаксический анализатор похож на &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; за исключением того, что он может иметь префикс со знаком (например, &amp;laquo;-&amp;raquo; или &amp;laquo;+&amp;raquo;). Возвращает значение числа. Число может быть указано в &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; формате . Число анализируется в соответствии с правилами грамматики в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="bf7d3fe039b607009e325c09fadc027724bbba18" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексемы анализирует либо &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; либо &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; . Возвращает значение числа. Этот синтаксический анализатор имеет дело с любым перекрытием в правилах грамматики для натуральных и плавающих чисел. Число анализируется в соответствии с правилами грамматики, определенными в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="4cc0de1ff1da25f44b1ba64f4600fc6b2f58174a" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">Этот синтаксический анализатор лексемы анализирует либо &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; либо &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; . Возвращает значение числа. Этот синтаксический анализатор имеет дело с любым перекрытием в правилах грамматики для натуральных и плавающих чисел. Число анализируется в соответствии с правилами грамматики, определенными в отчете Haskell.</target>
        </trans-unit>
        <trans-unit id="8b3e538648d90a568eed7b3e4b7980db877318e7" translate="yes" xml:space="preserve">
          <source>This lexer is not completely faithful to the Haskell lexical syntax in the following respects:</source>
          <target state="translated">Этот лексер не полностью соответствует лексическому синтаксису Хаскелла в следующих отношениях:</target>
        </trans-unit>
        <trans-unit id="ba0c905e7229e2d42cfbc9060686e3e8b51c3edc" translate="yes" xml:space="preserve">
          <source>This library defines parser combinators for precedence parsing.</source>
          <target state="translated">Эта библиотека определяет комбинаторы парсеров для разбора прецедентов.</target>
        </trans-unit>
        <trans-unit id="26d58c3f8313372fb9a5712eb67174707d34b82e" translate="yes" xml:space="preserve">
          <source>This library provides facilities for parsing the command-line options in a standalone program. It is essentially a Haskell port of the GNU &lt;code&gt;getopt&lt;/code&gt; library.</source>
          <target state="translated">Эта библиотека предоставляет средства для анализа параметров командной строки в отдельной программе. По сути, это порт Haskell библиотеки GNU &lt;code&gt;getopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd805dfecd7f77257c432c66329c165e81f0fc28" translate="yes" xml:space="preserve">
          <source>This library provides support for &lt;em&gt;strict&lt;/em&gt; state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt;.</source>
          <target state="translated">Эта библиотека обеспечивает поддержку потоков со &lt;em&gt;строгим&lt;/em&gt; состоянием, как описано в статье PLDI '94 Джона Лаанчбери и Саймона Пейтона Джонса. &lt;em&gt;Потоки с ленивым функциональным состоянием&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8126030a0db08f6efcbf327884b71cf1e6318582" translate="yes" xml:space="preserve">
          <source>This limitation is easily subvertible, so please ask if you get stuck on it.</source>
          <target state="translated">Это ограничение легко подрывается,поэтому,пожалуйста,спросите,если вы застряли на нем.</target>
        </trans-unit>
        <trans-unit id="21a515f07e3c656c64c893fcd677dfba412563b8" translate="yes" xml:space="preserve">
          <source>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</source>
          <target state="translated">Этот список может быть легко расширен;если есть функции Prelude,которые вы используете много,которые не включены,пожалуйста,сообщите нам.</target>
        </trans-unit>
        <trans-unit id="c9d77f7a9ab7e1d50b50bd600bb71a7967ecbbfb" translate="yes" xml:space="preserve">
          <source>This list is for GHC users to chat among themselves. If you have a specific question about GHC, please check the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; first.</source>
          <target state="translated">Этот список предназначен для общения пользователей GHC между собой. Если у вас есть конкретный вопрос о GHC, сначала ознакомьтесь с &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29a814259d6babfac9ea76d85ac921a5f02baa19" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of &lt;code&gt;pkgname&lt;/code&gt; that is exposed for module import. It is identical in behavior to the &lt;code&gt;VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">Этот макрос доступен начиная с GHC 8.0. Он определяется для каждого выставленного пакета. Этот макрос расширяется до строки, в которой записывается версия &lt;code&gt;pkgname&lt;/code&gt; , доступная для импорта модуля. По поведению он идентичен &lt;code&gt;VERSION_pkgname&lt;/code&gt; который определяет Кабала.</target>
        </trans-unit>
        <trans-unit id="a74c45d8cbbb98f3219b81a76db9cbe9b302bc7d" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is &lt;code&gt;x.y.z&lt;/code&gt; or later. It is identical in behavior to the &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">Этот макрос доступен начиная с GHC 8.0. Он определяется для каждого выставленного пакета. Этот макрос предоставляется для удобства написания проверки условий CPP, если версия пакета - &lt;code&gt;x.y.z&lt;/code&gt; или более поздняя. Он идентичен по поведению макросам &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; , которые определяет Кабал.</target>
        </trans-unit>
        <trans-unit id="369c31dee13e7ebf7250f99f560cae58a6ec67ab" translate="yes" xml:space="preserve">
          <source>This macro is available starting with GHC 7.10.1.</source>
          <target state="translated">Данный макрос доступен,начиная с GHC 7.10.1.</target>
        </trans-unit>
        <trans-unit id="78b70fd2d98680d3ba8f51b750ceee956a98a51c" translate="yes" xml:space="preserve">
          <source>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version &lt;code&gt;x.y.z.z'&lt;/code&gt; or later.</source>
          <target state="translated">Этот макрос предоставляется для удобства написания условных &lt;code&gt;x.y.z.z'&lt;/code&gt; CPP, проверяющих, является ли используемая версия GHC версией xyzz ' или более поздней.</target>
        </trans-unit>
        <trans-unit id="9ccb8c1a1ef41b359721ee50eeb5b0ffe5456b94" translate="yes" xml:space="preserve">
          <source>This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">Этот макрос устанавливается при предварительной обработке исходного кода Haskell и исходного кода C, включая исходный код C, созданный из модуля Haskell (т.е. &lt;code&gt;.hs&lt;/code&gt; , &lt;code&gt;.lhs&lt;/code&gt; , &lt;code&gt;.c&lt;/code&gt; и &lt;code&gt;.hc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="126816cfbceb17265259c1bfd692cfa851e88117" translate="yes" xml:space="preserve">
          <source>This makes a copy, so does not retain the input string.</source>
          <target state="translated">Это делает копию,поэтому не сохраняет входную строку.</target>
        </trans-unit>
        <trans-unit id="409b9c14a753a56835750678eec0ceed50896009" translate="yes" xml:space="preserve">
          <source>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example here we print the value of the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">Это позволяет удобно печатать значения интересных переменных или выражений внутри функции. Например, здесь мы печатаем значение переменных &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d154b682a58894f927011c8dcf1525090a6bca45" translate="yes" xml:space="preserve">
          <source>This may take real work, but&amp;hellip; There exist piles of massively-tuned library code, and the best thing is not to compete with it, but link with it.</source>
          <target state="translated">Это может потребовать реальной работы, но ... Существуют груды массивно настроенного библиотечного кода, и лучше всего не конкурировать с ним, а связываться с ним.</target>
        </trans-unit>
        <trans-unit id="8e305a9c2249a611331558008a6864ebdcc9df92" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;f&lt;/code&gt; сопоставляет разные исходные ключи с разными результирующими ключами. Эта функция работает лучше, чем &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2f7283b2f57776282bb867fc6a49c83c2f23c8b" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;f&lt;/code&gt; сопоставляет разные исходные ключи с разными результирующими ключами. Эта функция работает лучше, чем &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d65304cb52af71023e15bd45422c06447d534f9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;f&lt;/code&gt; сопоставляет разные исходные ключи с разными результирующими ключами. Эта функция имеет немного лучшую производительность, чем &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f79e70de4e10cc28ee0029d0a6a35c1bbea2e78" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;f&lt;/code&gt; сопоставляет разные исходные ключи с разными результирующими ключами. Эта функция имеет немного лучшую производительность, чем &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2b22c1be27f1ee28d05bb2aade303875940243" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это означает, что &lt;code&gt;f&lt;/code&gt; сопоставляет разные исходные ключи с разными результирующими ключами. Эта функция имеет немного лучшую производительность, чем &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c92fe3388c138613ddb9738050b4232a8c3e292" translate="yes" xml:space="preserve">
          <source>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it &lt;code&gt;safe&lt;/code&gt; and use &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;. Some library functions make such calls internally; their documentation should indicate when this is the case.</source>
          <target state="translated">Это означает, что если вам нужно сделать внешний вызов функции, которая занимает много времени или блокируется бесконечно, вы должны пометить ее как &lt;code&gt;safe&lt;/code&gt; и использовать &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; . Некоторые библиотечные функции делают такие вызовы внутри себя; в их документации должно быть указано, когда это так.</target>
        </trans-unit>
        <trans-unit id="c345f7d8502440fe1972767e0230a2d484f96fc3" translate="yes" xml:space="preserve">
          <source>This means that many operations on sequences are stricter than those on lists. For example,</source>
          <target state="translated">Это означает,что многие операции над последовательностями строже,чем над списками.Например,</target>
        </trans-unit>
        <trans-unit id="512d8c4339c4e152167f7ed6529861156bdd0ce2" translate="yes" xml:space="preserve">
          <source>This means that the usual string syntax can be used, e.g., for &lt;code&gt;ByteString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</source>
          <target state="translated">Это означает, что можно использовать обычный строковый синтаксис, например, для &lt;code&gt;ByteString&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; и других вариантов строковых типов. Строковые литералы очень похожи на целочисленные литералы, т. Е. Их можно использовать как в выражениях, так и в шаблонах. При использовании в шаблоне литерал будет заменен проверкой на равенство, так же, как и целочисленный литерал.</target>
        </trans-unit>
        <trans-unit id="6e84b7b55ab4e53c7918a9eed0f0386ae7086f12" translate="yes" xml:space="preserve">
          <source>This means we're all done. All the builder data has now been written.</source>
          <target state="translated">Это значит,что мы все закончили.Все данные сборщика теперь записаны.</target>
        </trans-unit>
        <trans-unit id="a699a362a2564a3c76496bfcaced4dda0fd71569" translate="yes" xml:space="preserve">
          <source>This mechanism makes use of GHC's efficient built-in generics support.</source>
          <target state="translated">Этот механизм использует эффективную встроенную поддержку дженериков GHC.</target>
        </trans-unit>
        <trans-unit id="ed8ed8da55dd83a0ef130774f673009214846879" translate="yes" xml:space="preserve">
          <source>This method is surprisingly useful. Where both instances exist and are lawful we have the following laws:</source>
          <target state="translated">Этот метод на удивление полезен.Там,где оба случая существуют и являются законными,у нас есть следующие законы:</target>
        </trans-unit>
        <trans-unit id="917ff2b24c3401ef265e4f82c89c8ae89e4dbe83" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; as its default implementation (which ought to be equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; for types which possess a 0th bit).</source>
          <target state="translated">В этом методе в качестве реализации по умолчанию используется &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; (который должен быть эквивалентен &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; для типов, имеющих нулевой бит).</target>
        </trans-unit>
        <trans-unit id="a56c576252b7c2f659be8b6306ca50d283138678" translate="yes" xml:space="preserve">
          <source>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; option can be omitted.</source>
          <target state="translated">Этот режим используется по умолчанию, если в командной строке упоминаются какие-либо исходные файлы Haskell, и в этом случае параметр &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; можно не указывать.</target>
        </trans-unit>
        <trans-unit id="5aa78e5fdb695de8a1ddc90859fa15ef056bc6c5" translate="yes" xml:space="preserve">
          <source>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">Этот режим очень похож на интерактивный режим, за исключением того, что есть одно выражение для оценки, которое указывается в командной строке в качестве аргумента опции &lt;code&gt;-e&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c36679dee1440f17c5d2fe66c1ebdd875fd933fe" translate="yes" xml:space="preserve">
          <source>This module also contains generalisations of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to work with any &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">Этот модуль также содержит обобщения &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; для работы с любым экземпляром &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4d1e1a6706fb58eb88829be1d42c2470d6cd3f3" translate="yes" xml:space="preserve">
          <source>This module can be imported for defining forward compatible &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instances:</source>
          <target state="translated">Этот модуль можно импортировать для определения экземпляров &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; с прямой совместимостью :</target>
        </trans-unit>
        <trans-unit id="288e7f4f57a0ee94cf817604c968d8d8274a39d6" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. &lt;strong&gt;&lt;em&gt;As such, the types presented on this page reflect the&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;platform on which the documentation was generated and may&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;not coincide with the types on your platform.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e27f3d7a593111ec01d1dd70cd801444f3e1d34" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. __/As such the types presented on this page reflect the platform on which the documentation was generated and may not coincide with the types on your platform./__</source>
          <target state="translated">Этот модуль содержит информацию о типах,специфичных для платформы.__/As такие типы,представленные на этой странице,отражают платформу,на которой была сгенерирована документация,и могут не совпадать с типами на вашей платформе./__.</target>
        </trans-unit>
        <trans-unit id="69fea24c1770ed9b0390c085efc99817f8d87553" translate="yes" xml:space="preserve">
          <source>This module contains support for pooled memory management. Under this scheme, (re-)allocations belong to a given pool, and everything in a pool is deallocated when the pool itself is deallocated. This is useful when &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; with its implicit allocation and deallocation is not flexible enough, but explicit uses of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; are too awkward.</source>
          <target state="translated">Этот модуль поддерживает управление объединенной памятью. Согласно этой схеме (пере) выделения принадлежат данному пулу, и все в пуле освобождается, когда освобождается сам пул. Это полезно, когда &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; с ее неявным распределением и освобождением недостаточно гибкая, а явное использование &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; слишком неудобно.</target>
        </trans-unit>
        <trans-unit id="13d5f93e40c79a18376dc00ca5c87434053f0a7f" translate="yes" xml:space="preserve">
          <source>This module currently does not expose functions that require the special properties of fixed-size primitives. They are useful for prefixing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s with their size or for implementing chunked encodings. We will expose the corresponding functions in future releases of this library.</source>
          <target state="translated">Этот модуль в настоящее время не предоставляет функции, требующие специальных свойств примитивов фиксированного размера. Они полезны для префикса &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; с их размером или для реализации кодирования фрагментов. Мы представим соответствующие функции в будущих выпусках этой библиотеки.</target>
        </trans-unit>
        <trans-unit id="5142c08054d9871661f7f0d130cb3d6fdd9407d3" translate="yes" xml:space="preserve">
          <source>This module defines a &quot;Fixed&quot; type for fixed-precision arithmetic. The parameter to &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; is any type that's an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; has a single method that gives the resolution of the &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Этот модуль определяет тип &amp;laquo;Фиксированный&amp;raquo; для арифметики с фиксированной точностью. Параметр &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; - это любой тип, являющийся экземпляром &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; имеет единственный метод, который дает разрешение типа &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c812190315e834b8c95ed3f2997592b7564b3fdf" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">Этот модуль определяет API для написания функций, которые объединяют две карты. Ключевыми функциями являются &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Каждый из них может использоваться с несколькими различными &amp;laquo;тактиками слияния&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="748c4571f3ce28ef125886641fac7bef9890107e" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">Этот модуль определяет API для написания функций, которые объединяют две карты. Ключевыми функциями являются &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Каждый из них может использоваться с несколькими различными &amp;laquo;тактиками слияния&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="75f0e64e356523d1a0c9eb699ad805d54ab82048" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">Этот модуль определяет API для написания функций, которые объединяют две карты. Ключевыми функциями являются &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Каждый из них может использоваться с несколькими различными &amp;laquo;тактиками слияния&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a495bc59840aa160735fbc988dd7aa12e8ba85b8" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">Этот модуль определяет API для написания функций, которые объединяют две карты. Ключевыми функциями являются &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; . Каждый из них может использоваться с несколькими различными &amp;laquo;тактиками слияния&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="af9c5e66541cb60627fc011c4ff85f664b7cc4ed" translate="yes" xml:space="preserve">
          <source>This module defines bitwise operations for signed and unsigned integers. Instances of the class &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; types are available from this module, and instances for explicitly sized integral types are available from the &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; modules.</source>
          <target state="translated">Этот модуль определяет поразрядные операции для целых чисел со знаком и без знака. Экземпляры класса &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; для типов &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; доступны из этого модуля, а экземпляры для целочисленных типов с явно заданным размером доступны из модулей &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; и &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64cded15389022e2237acadfc2c3eed972bdb24d" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="translated">Этот модуль определяет класс &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; , используемый расширением &lt;code&gt;OverloadedRecordFields&lt;/code&gt; . См. &amp;lt; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;Https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; вики-страницу&amp;gt; для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="606c7646766e3b5fdd5c9d30e4081494c51f94fc" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/records/overloaded-record-fields&quot;&gt;https://gitlab.haskell.org/ghc/ghc/wikis/records/overloaded-record-fields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6eb416164cb4715d4e03695cde3fb980e473a9" translate="yes" xml:space="preserve">
          <source>This module defines the basic operations on I/O &quot;handles&quot;. All of the operations defined here are independent of the underlying device.</source>
          <target state="translated">Этот модуль определяет основные операции с &quot;дескрипторами&quot; входов/выходов.Все определенные здесь операции не зависят от базового устройства.</target>
        </trans-unit>
        <trans-unit id="d59bda9eaeaf5c1e3a36e9b88b617c773901fa3b" translate="yes" xml:space="preserve">
          <source>This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor). Compared with monads, this interface lacks the full power of the binding operation &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, but</source>
          <target state="translated">Этот модуль описывает структуру, промежуточную между функтором и монадой (технически, сильный нестрогий моноидальный функтор). По сравнению с монадами, этому интерфейсу не хватает всей мощности операции привязки &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; , но</target>
        </trans-unit>
        <trans-unit id="6da3e730b43c82c0b85f8ebac281848e3fc9fe3b" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">Этот модуль экспортирует точно такой же API, как &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; , за исключением того, что все пути к файлам и строки среды представлены &lt;code&gt;ByteString&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API неявно переводит все пути к файлам и строки окружения , используя кодировку локали, в то время как эта версия API не делает кодирование или декодирование и работает непосредственно в терминах исходных байтов.</target>
        </trans-unit>
        <trans-unit id="432a06fcd12fe64c315d994b347ca09ea56e286d" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae57a29c16b708a5f862b98209ca33ec88b9833b" translate="yes" xml:space="preserve">
          <source>This module exposes the &lt;em&gt;portable&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. See &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; for the &lt;code&gt;integer-gmp&lt;/code&gt;-specific internal representation of &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; as well as optimized GMP-specific operations.</source>
          <target state="translated">Этот модуль предоставляет &lt;em&gt;переносимый &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. См. &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; для внутреннего представления &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; , специфичного для &lt;code&gt;integer-gmp&lt;/code&gt; а также оптимизированных операций, специфичных для GMP.</target>
        </trans-unit>
        <trans-unit id="3a94829165fdca15372f0126fd78a0b495ce0522" translate="yes" xml:space="preserve">
          <source>This module implements permutation parsers. The algorithm used is fairly complex since we push the type system to its limits :-) The algorithm is described in:</source>
          <target state="translated">В этом модуле реализованы парсеры перестановки.Используемый алгоритм достаточно сложен,так как мы подталкиваем систему типов к ее пределу :-)Алгоритм описан в:</target>
        </trans-unit>
        <trans-unit id="c272683515777617630ed062550e54f1e41af5ba" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Этот модуль включает правила перезаписи GHC для оптимизации &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; для функторов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; . В целом эти правила улучшают производительность. Единственным исключением является то, что при использовании &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; удаление ключа, который уже отсутствует, занимает больше времени, чем без правил. Если вы ожидаете, что это будет происходить очень часто, вы можете рассмотреть возможность использования частной копии типа &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96caa6e7405bbcf705758c402e5dc69c91123112" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480d93e68fd6dc10a57cdf9aae6e88c254901353" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Этот модуль включает правила перезаписи GHC для оптимизации &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; для функторов &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; . В целом эти правила улучшают производительность. Единственным исключением является то, что при использовании &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; удаление ключа, который уже отсутствует, занимает больше времени, чем без правил. Если вы ожидаете, что это будет происходить очень часто, вы можете рассмотреть возможность использования частной копии типа &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="824034cfb4513aba4aa1c338187313dac84e67aa" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db164d6a986565222e119d577ff5c229ba8b29b" translate="yes" xml:space="preserve">
          <source>This module includes everything you need to get started writing a parser.</source>
          <target state="translated">Этот модуль включает в себя все необходимое для начала написания парсера.</target>
        </trans-unit>
        <trans-unit id="0e0f68392cbf21d07cf104e09ea0593872ccee43" translate="yes" xml:space="preserve">
          <source>This module is GHC-only and should not be considered portable.</source>
          <target state="translated">Этот модуль предназначен только для работы с GHC и не должен считаться портативным.</target>
        </trans-unit>
        <trans-unit id="84656ba40cd08703f7a3e8f512a38792e056d9c4" translate="yes" xml:space="preserve">
          <source>This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.</source>
          <target state="translated">Этот модуль является внутренним модулем GHC.Он декларирует константы,используемые в реализации натуральных чисел уровня типа.Интерфейс программиста для работы с натуральными числами уровня типа должен быть определен в отдельной библиотеке.</target>
        </trans-unit>
        <trans-unit id="d3afde49cd7420849dc0a50c7430aa7753bf402f" translate="yes" xml:space="preserve">
          <source>This module is considered &lt;strong&gt;internal&lt;/strong&gt;.</source>
          <target state="translated">Этот модуль считается &lt;strong&gt;внутренним&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="32342dd868ac356dff4bac50bb615e44b16dffd8" translate="yes" xml:space="preserve">
          <source>This module is inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">Этот модуль вдохновлен статьей &amp;laquo; &lt;em&gt;Функциональное программирование с перегрузкой и полиморфизмом&lt;/em&gt; высокого &lt;em&gt;порядка&amp;raquo;&lt;/em&gt; , Марк П. Джонс ( &lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt; ) Продвинутая школа функционального программирования, 1995 г.</target>
        </trans-unit>
        <trans-unit id="7096f5bf81e4fc89257ced2d74b5c3eaad60b08c" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="translated">Этот модуль предназначен для импорта с &lt;code&gt;qualified&lt;/code&gt; , чтобы избежать конфликтов имен с функциями &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; , например</target>
        </trans-unit>
        <trans-unit id="eee7efdf6521c2a0678812a45bb80ea8d0fd2ac6" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">Этот модуль предназначен для импорта с &lt;code&gt;qualified&lt;/code&gt; , чтобы избежать конфликтов имен с функциями &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; . например.</target>
        </trans-unit>
        <trans-unit id="10a0983bc8a8704f481851ed07cafa7a10dc5324" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3534379c86106e1fb6aab32dbe9ba4e8065b07" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e00704b6043d91bc0b1a65e596b7ceb43c33c8" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</source>
          <target state="translated">Этот модуль предназначен для импорта квалифицированных,чтобы избежать столкновения имен с функциями Prelude:</target>
        </trans-unit>
        <trans-unit id="c97f8a3f89d9890b95b69a48863882918e86fa8c" translate="yes" xml:space="preserve">
          <source>This module is part of the Foreign Function Interface (FFI) and will usually be imported via the module &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;.</source>
          <target state="translated">Этот модуль является частью интерфейса внешних функций (FFI) и обычно импортируется через модуль &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="461f2e382a01bf00f47b644a6f12f006c2e2728e" translate="yes" xml:space="preserve">
          <source>This module only defines the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad; you probably want to import &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (which exports &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;).</source>
          <target state="translated">Этот модуль определяет только монаду &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; ; вы, вероятно, захотите импортировать &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (который экспортирует &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fcaff35e4331afea7bccc306685504864f4b033e" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; operations until a value depending on them is required.</source>
          <target state="translated">Этот модуль представляет собой интерфейс, идентичный &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; , за исключением того, что монада откладывает оценку операций &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; до тех пор, пока не потребуется значение, зависящее от них.</target>
        </trans-unit>
        <trans-unit id="785b925d63da4b41979c13438250f723b3f36584" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of state operations until a value depending on them is required.</source>
          <target state="translated">Этот модуль представляет собой интерфейс, идентичный &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt; , за исключением того, что монада откладывает оценку операций состояния до тех пор, пока не потребуется значение, зависящее от них.</target>
        </trans-unit>
        <trans-unit id="5d29751e61c6eafcb5fbfdc53fe9336d12c4e225" translate="yes" xml:space="preserve">
          <source>This module provides &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;&lt;em&gt;primitives&lt;/em&gt;, which are lower level building blocks for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. You don't need to go down to this level but it can be slightly faster.</source>
          <target state="translated">Этот модуль предоставляет &lt;em&gt;примитивы &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; , которые являются строительными блоками нижнего уровня для построения &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Вам не нужно спускаться до этого уровня, но это может быть немного быстрее.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e4ed2fc38393aca2df37326ba9f3afba3af1d5c" translate="yes" xml:space="preserve">
          <source>This module provides a low-level API to the line history stored in the &lt;code&gt;InputT&lt;/code&gt; monad transformer.</source>
          <target state="translated">Этот модуль предоставляет низкоуровневый API для истории строк, хранящейся в &lt;code&gt;InputT&lt;/code&gt; монад InputT .</target>
        </trans-unit>
        <trans-unit id="f1d3e88a44dc84dd2e2655daf9dcf215e0055df4" translate="yes" xml:space="preserve">
          <source>This module provides a low-level interface to the C functions of the terminfo library.</source>
          <target state="translated">Этот модуль предоставляет низкоуровневый интерфейс к функциям C библиотеки терминалов.</target>
        </trans-unit>
        <trans-unit id="dcfa8281ead615b485cbc67a44a0d67023dd3214" translate="yes" xml:space="preserve">
          <source>This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module.</source>
          <target state="translated">Этот модуль предоставляет простой интерфейс для выполнения внешних команд. Более сложный, но более мощный интерфейс см. &lt;a href=&quot;system-process&quot;&gt;В&lt;/a&gt; модуле System.Process .</target>
        </trans-unit>
        <trans-unit id="a90fd78951dfe7db7ffb984d132da2184a51611f" translate="yes" xml:space="preserve">
          <source>This module provides a stateful, IO-based interface to Haskeline, which may be easier to integrate into some existing programs or libraries.</source>
          <target state="translated">Этот модуль предоставляет основанный на статистике интерфейс на основе ввода-вывода для Haskeline,который,возможно,будет проще интегрировать в некоторые существующие программы или библиотеки.</target>
        </trans-unit>
        <trans-unit id="7665bb8888c593637beee8ce6f79ca4404cc5473" translate="yes" xml:space="preserve">
          <source>This module provides a version of pretty that allows for annotations to be attached to documents. Annotations are arbitrary pieces of metadata that can be attached to sub-documents.</source>
          <target state="translated">Этот модуль предоставляет версию красивого,которая позволяет прикреплять аннотации к документам.Аннотации-это произвольные фрагменты метаданных,которые могут быть прикреплены к поддокументам.</target>
        </trans-unit>
        <trans-unit id="c1a38449e4b89f12a5a25525a42c36b9312c0f84" translate="yes" xml:space="preserve">
          <source>This module provides access to internal garbage collection and memory usage statistics. These statistics are not available unless a program is run with the &lt;code&gt;-T&lt;/code&gt; RTS flag.</source>
          <target state="translated">Этот модуль обеспечивает доступ к внутренней сборке мусора и статистике использования памяти. Эта статистика недоступна, если программа не запущена с флагом &lt;code&gt;-T&lt;/code&gt; RTS.</target>
        </trans-unit>
        <trans-unit id="9f3add7a2fb1719164d2ace74420d665a5258e75" translate="yes" xml:space="preserve">
          <source>This module provides capabilities for moving the cursor on the terminal.</source>
          <target state="translated">Данный модуль предоставляет возможность перемещения курсора на терминале.</target>
        </trans-unit>
        <trans-unit id="e18030012ebf6800ca52122e711e5ae7b02da7e6" translate="yes" xml:space="preserve">
          <source>This module provides efficient containers-based functions on the list type.</source>
          <target state="translated">Этот модуль обеспечивает эффективные функции на основе контейнеров по типу списка.</target>
        </trans-unit>
        <trans-unit id="1f668197932586f66f5efc5d3fb7ae4c036d630e" translate="yes" xml:space="preserve">
          <source>This module provides overloaded functions, such as &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt;, for fully evaluating data structures (that is, evaluating to &quot;Normal Form&quot;).</source>
          <target state="translated">Этот модуль предоставляет перегруженные функции, такие как &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; , для полной оценки структур данных (т. Е. Оценки в &amp;laquo;нормальной форме&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="582a828ee9bdf70b77d17ebec335ad7850fb4e35" translate="yes" xml:space="preserve">
          <source>This module provides scalable event notification for file descriptors and timeouts.</source>
          <target state="translated">Данный модуль обеспечивает масштабируемое уведомление о событиях для файловых дескрипторов и таймаутов.</target>
        </trans-unit>
        <trans-unit id="854a2eebed7e5e3bcde5ed1dde2b3bcda6e0ef76" translate="yes" xml:space="preserve">
          <source>This module provides support for raising and catching both built-in and user-defined exceptions.</source>
          <target state="translated">Этот модуль обеспечивает поддержку поднятия и улавливания как встроенных,так и определяемых пользователем исключений.</target>
        </trans-unit>
        <trans-unit id="779b1cd1a00e8f21b85e9635dbc10c2617ea3dc3" translate="yes" xml:space="preserve">
          <source>This module provides text encoding/decoding using iconv</source>
          <target state="translated">Этот модуль обеспечивает кодирование/декодирование текста с помощью иконкиv</target>
        </trans-unit>
        <trans-unit id="bd39e9a11c79866d26b9bd27b7ee858d0e154873" translate="yes" xml:space="preserve">
          <source>This module provides the various sorting implementations for &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;. Further notes are available in the file sorting.md (in this directory).</source>
          <target state="translated">Этот модуль предоставляет различные реализации сортировки для &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt; . Дополнительные примечания доступны в файле sorting.md (в этом каталоге).</target>
        </trans-unit>
        <trans-unit id="c752cac235dedd97d14389620cb23346095a0f16" translate="yes" xml:space="preserve">
          <source>This module provides typed pointers to foreign data. It is part of the Foreign Function Interface (FFI) and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">Этот модуль предоставляет типизированные указатели на сторонние данные. Он является частью интерфейса внешних функций (FFI) и обычно импортируется через &lt;a href=&quot;foreign&quot;&gt;внешний&lt;/a&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="8127ca85318ff1824be538551fa1fd1e340e9ab9" translate="yes" xml:space="preserve">
          <source>This module re-exports &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;, which produces XHTML 1.0 Transitional. Use &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt; if you want XHTML 1.0 Strict, and &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt; if you want to produce XHTML 1.0 Frameset.</source>
          <target state="translated">Этот модуль повторно экспортирует &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt; , в результате чего создается XHTML 1.0 Transitional. Используйте &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict,&lt;/a&gt; если вам нужен XHTML 1.0 Strict, и &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset,&lt;/a&gt; если вы хотите создать XHTML 1.0 Frameset.</target>
        </trans-unit>
        <trans-unit id="d8ec7f9f123682eb0cc274e7c52cca0f3a5f423e" translate="yes" xml:space="preserve">
          <source>This module re-exports the value lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API, plus several deprecated value strict functions. Please note that these functions have different strictness properties than those in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;: they only evaluate the result of the combining function. For example, the default value to &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; is only evaluated if the combining function is called and uses it.</source>
          <target state="translated">Этот модуль повторно экспортирует значение lazy API &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; , а также несколько устаревших функций со строгим значением. Обратите внимание, что эти функции имеют другие свойства строгости, чем в &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; : они оценивают только результат функции комбинирования. Например, значение по умолчанию &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; оценивается только в том случае, если функция объединения вызывается и использует ее.</target>
        </trans-unit>
        <trans-unit id="652efe48d7f69bcc3c5490c01c5c8cb0efb0564b" translate="yes" xml:space="preserve">
          <source>This module redefines some of the functions in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; to work for more general monads built on top of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот модуль переопределяет некоторые функции в &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception,&lt;/a&gt; чтобы они работали для более общих монад, построенных на основе &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6ca5d2535d9794227136b6b0c705ce4e24c48c" translate="yes" xml:space="preserve">
          <source>This module satisfies the following strictness property:</source>
          <target state="translated">Этот модуль удовлетворяет следующему свойству строгости:</target>
        </trans-unit>
        <trans-unit id="d8eb2deb7a56d67d9c957df553d23a112baecc39" translate="yes" xml:space="preserve">
          <source>This module should be considered GHC internal.</source>
          <target state="translated">Этот модуль следует считать внутренним GHC.</target>
        </trans-unit>
        <trans-unit id="29e73688c548bf0c2243628b3c05e4e5e0b07e48" translate="yes" xml:space="preserve">
          <source>This module should be used as opposed to the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; module. Both are equivalent though as this module simply re-exports the other.</source>
          <target state="translated">Этот модуль следует использовать &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; модуля HughesPJ . Оба они эквивалентны, поскольку этот модуль просто реэкспортирует другой.</target>
        </trans-unit>
        <trans-unit id="f659376b4585d9e16031991a83545eeadf08cc89" translate="yes" xml:space="preserve">
          <source>This module supplies a 'pure' monad transformer that can be used for mock-testing code that throws exceptions, so long as those exceptions are always thrown with &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:throwM&quot;&gt;throwM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c093cde768913c2b7ff4e222653e852525c2bd9" translate="yes" xml:space="preserve">
          <source>This module supports monads that can throw extensible exceptions. The exceptions are the very same from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, and the operations offered very similar, but here they are not limited to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ad027c5fc678b3f6724e2d8a2c3619f02ad834" translate="yes" xml:space="preserve">
          <source>This modules provides access to the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; constructors and exposes some highly optimized GMP-operations.</source>
          <target state="translated">Эти модули предоставляют доступ к конструкторам &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; и предоставляют некоторые высоко оптимизированные GMP-операции.</target>
        </trans-unit>
        <trans-unit id="1130e146d0ff983a031a0a8522c8725e170d0829" translate="yes" xml:space="preserve">
          <source>This monad transformer adds the ability to fail or throw exceptions to a monad.</source>
          <target state="translated">Этот трансформатор монады добавляет способность проваливать или бросать исключения в монаду.</target>
        </trans-unit>
        <trans-unit id="2a98bbb5afc9600bb6b74cc7f447cb8e1866b15b" translate="yes" xml:space="preserve">
          <source>This monad transformer extends a monad with the ability to throw exceptions.</source>
          <target state="translated">Трансформатор монады расширяет монаду с возможностью бросать исключения.</target>
        </trans-unit>
        <trans-unit id="bba2acb7a712203bd9458987272d1dea78c2f000" translate="yes" xml:space="preserve">
          <source>This monad transformer is similar to both state and writer monad transformers. Thus it can be seen as</source>
          <target state="translated">Этот трансформатор монад похож на трансформаторы как государственных,так и писательских монад.Таким образом,его можно рассматривать как</target>
        </trans-unit>
        <trans-unit id="7f2bb8a9d0620b88f4451a6324781ede4a2121a7" translate="yes" xml:space="preserve">
          <source>This monad transformer provides append-only accumulation during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">Этот преобразователь монад обеспечивает накопление во время вычислений только с добавлением. Для более общего доступа используйте вместо этого &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c53c5e051f564d4139a6d22099093a9506011e0" translate="yes" xml:space="preserve">
          <source>This monad transformer provides only limited access to the output during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">Этот преобразователь монад обеспечивает только ограниченный доступ к выходу во время вычислений. Для более общего доступа используйте вместо этого &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e64b48298e57e04598190a3e73a7a420ac326928" translate="yes" xml:space="preserve">
          <source>This now re-exports &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь это реэкспорт &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48569d17cf06edd49e682678e1dd43b354e7266d" translate="yes" xml:space="preserve">
          <source>This only happens if:</source>
          <target state="translated">Это случится только если:</target>
        </trans-unit>
        <trans-unit id="6c0b5dda6372d83897c8a1df104f5345b0b4220f" translate="yes" xml:space="preserve">
          <source>This only shows the time zone name, or offset if the name is empty.</source>
          <target state="translated">При этом отображается только имя часового пояса или смещение,если имя пустое.</target>
        </trans-unit>
        <trans-unit id="48af544d61c79afa3a39e1cd49eb4f6213f4528d" translate="yes" xml:space="preserve">
          <source>This only stands a chance of working for an encoding which is an ASCII superset, as for security reasons we refuse to escape any bytes smaller than 128. Many encodings of interest are ASCII supersets (in particular, you can assume that the locale encoding is an ASCII superset) but many (such as UTF-16) are not.</source>
          <target state="translated">Это дает шанс работать только для кодировки,которая является ASCII суперсетью,так как по соображениям безопасности мы отказываемся от любых байт меньше 128.Многие кодировки представляют интерес для ASCII суперсетов (в частности,можно предположить,что локальная кодировка является ASCII суперсетью),но многие (такие как UTF-16)таковыми не являются.</target>
        </trans-unit>
        <trans-unit id="a6ecf6dcbeadf01a7014b13f5a368ef88d650353" translate="yes" xml:space="preserve">
          <source>This only works for &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">Это работает только для формата &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; , однобуквенных военных часовых поясов и этих часовых поясов: &amp;laquo;UTC&amp;raquo;, &amp;laquo;UT&amp;raquo;, &amp;laquo;GMT&amp;raquo;, &amp;laquo;EST&amp;raquo;, &amp;laquo;EDT&amp;raquo;, &amp;laquo;CST&amp;raquo;, &amp;laquo;CDT&amp;raquo;, &amp;laquo;MST&amp;raquo;, &amp;laquo;MDT&amp;raquo;, &amp;laquo;PST&amp;raquo;, &amp;laquo;PDT&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d7c1d4016c14da3ba1514123886da29a32443086" translate="yes" xml:space="preserve">
          <source>This only works for a &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">Это работает только для &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; в формате &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; , однобуквенных военных часовых поясов и этих часовых поясов: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot; CDT &amp;raquo;,&amp;laquo; MST &amp;raquo;,&amp;laquo; MDT &amp;raquo;,&amp;laquo; PST &amp;raquo;,&amp;laquo; PDT &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="23816db6dd8bea367310677e3bfbcb17ade64070" translate="yes" xml:space="preserve">
          <source>This operation acquires a unit from the semaphore (i.e. decreases the internal counter) and blocks (via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;) if no units are available (i.e. if the counter is &lt;em&gt;not&lt;/em&gt; positive).</source>
          <target state="translated">Эта операция получает единицу из семафора (т. Е. Уменьшает внутренний счетчик) и блокирует (посредством &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; ), если единицы недоступны (т. Е. Если счетчик &lt;em&gt;не&lt;/em&gt; положительный).</target>
        </trans-unit>
        <trans-unit id="7014f780887d062aecc25cade39318f1f4267c3d" translate="yes" xml:space="preserve">
          <source>This operation adds/releases a unit back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">Эта операция добавляет/отпускает блок обратно в семафор (т.е.увеличивает внутренний счетчик).</target>
        </trans-unit>
        <trans-unit id="bbef804c0feb5706c138bd85cf6a98a3ae663039" translate="yes" xml:space="preserve">
          <source>This operation adds/releases multiple units back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">Эта операция добавляет/удаляет несколько единиц обратно в семафор (т.е.увеличивает внутренний счетчик).</target>
        </trans-unit>
        <trans-unit id="23431b855341eca76cdc24f413dd7563b100983c" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">Эта операция в основном полезна для наборов тестов и / или кода, который напрямую &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="49d93c809fbddf9cf81dbda4c05507ecf14db03e" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">Эта операция в основном полезна для наборов тестов и / или кода, который напрямую &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; значения.</target>
        </trans-unit>
        <trans-unit id="6a3297c146519190d66c5419366b511b5ce250ad" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">Эта операция используется в определении &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; для предотвращения многократного выполнения действия ввода-вывода, что обычно нежелательно.</target>
        </trans-unit>
        <trans-unit id="c2f6053c6fe980d3303ab7779a6c30bf3b23e441" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">Эта операция используется в определении &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; для предотвращения многократного выполнения действия ввода-вывода, что обычно нежелательно.</target>
        </trans-unit>
        <trans-unit id="8ee46adec231f99964d238f6075b76987a604b31" translate="yes" xml:space="preserve">
          <source>This operation may fail with:</source>
          <target state="translated">С этой операцией может произойти сбой:</target>
        </trans-unit>
        <trans-unit id="a481371f0ca2e52248cb4d557f65d6db3c681c94" translate="yes" xml:space="preserve">
          <source>This optimisation isn&amp;rsquo;t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</source>
          <target state="translated">Однако эта оптимизация не всегда полезна (поэтому GHC применяет некоторые эвристики, чтобы решить, когда ее применять). Детали становятся сложными, но простой пример состоит в том, что часто бывает полезно переместить привязки let наружу, чтобы несколько привязок let можно было сгруппировать в более крупную привязку с одним let, эффективно группируя их распределение и помогая сборщику и распределителю мусора.</target>
        </trans-unit>
        <trans-unit id="daf337b821cabcc31b64cb93551eb620a65ef97d" translate="yes" xml:space="preserve">
          <source>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</source>
          <target state="translated">Эти движения по оптимизации позволяют креплениям быть ближе к месту их использования.Преимущество здесь заключается в том,что это может избежать ненужного выделения,если ветка,на которой сейчас находится let,никогда не будет выполнена.Это также позволяет другим передачам оптимизации работать более эффективно,так как они имеют больше информации локально.</target>
        </trans-unit>
        <trans-unit id="7bc0b111503fc7f964b8ba8ae4f63543b67f459b" translate="yes" xml:space="preserve">
          <source>This optimisation specializes recursive functions according to their argument &amp;ldquo;shapes&amp;rdquo;. This is best explained by example so consider:</source>
          <target state="translated">Эта оптимизация специализирует рекурсивные функции в соответствии с их &amp;laquo;формами&amp;raquo; аргументов. Лучше всего это пояснить на примере, поэтому подумайте:</target>
        </trans-unit>
        <trans-unit id="3fa5960caadfa09849470cf6386b6072cc3ffa4f" translate="yes" xml:space="preserve">
          <source>This option affects the processing of RTS control options given either on the command line or via the &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable. There are three possibilities:</source>
          <target state="translated">Этот параметр влияет на обработку параметров управления RTS, заданных либо в командной строке, либо через переменную среды &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; . Есть три возможности:</target>
        </trans-unit>
        <trans-unit id="65f85a6ef1d8626265a37c882bf54d7b55e6bccf" translate="yes" xml:space="preserve">
          <source>This option allows you to set the default RTS options at link-time. For example, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the &lt;code&gt;-rtsopts&lt;/code&gt; option, the user might not have the ability to change RTS options at run-time, in which case &lt;code&gt;-with-rtsopts&lt;/code&gt; would be the &lt;em&gt;only&lt;/em&gt; way to set them.)</source>
          <target state="translated">Эта опция позволяет вам установить параметры RTS по умолчанию во время связывания. Например, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; устанавливает размер кучи по умолчанию равным 128 МБ. Это всегда будет размер кучи по умолчанию для этой программы, если пользователь не изменит его. (В зависимости от настройки параметра &lt;code&gt;-rtsopts&lt;/code&gt; пользователь может не иметь возможности изменять параметры RTS во время выполнения, и в этом случае &lt;code&gt;-with-rtsopts&lt;/code&gt; будет &lt;em&gt;единственным&lt;/em&gt; способом их установить.)</target>
        </trans-unit>
        <trans-unit id="f91f71cb98fa24b36d5d90d1dbeb3041d935c33b" translate="yes" xml:space="preserve">
          <source>This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt;.</source>
          <target state="translated">Этот параметр вызывает выдачу предупреждения всякий раз, когда значение внутренней области имеет то же имя, что и значение внешней области, то есть внутреннее значение затеняет внешнее. Это может поймать орфографические ошибки , которые превращаются в труднодоступном найти ошибки, например, в непреднамеренном захвате того , что бы рекурсивный вызов в &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed96edbbc25b6f1208ec75b666dd489af6409055" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &amp;ldquo;!&amp;rdquo;) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;) to every strict constructor field that fulfils the size restriction.</source>
          <target state="translated">Эта опция вызывает распаковку всех полей конструктора, которые помечены как строгие (т.е. &amp;laquo;!&amp;raquo;) И представление которых меньше или равно размеру указателя. Это эквивалентно добавлению &lt;code&gt;UNPACK&lt;/code&gt; (см. &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;Прагму UNPACK&lt;/a&gt; ) в каждое строгое поле конструктора, удовлетворяющее ограничению размера.</target>
        </trans-unit>
        <trans-unit id="e2cd4133d01d71e89460c606007690e42b1fcee7" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &lt;code&gt;!&lt;/code&gt;) to be unpacked if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma to every strict constructor field (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">Эта опция вызывает распаковку всех полей конструктора, которые помечены как строгие (т.е. &lt;code&gt;!&lt;/code&gt; ), Если это возможно. Это эквивалентно добавлению &lt;code&gt;UNPACK&lt;/code&gt; в каждое поле строгого конструктора (см. &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;Прагму UNPACK&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc09848f730f75b415b16f985abe5f3c3b0d4c17" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">Эта опция приводит к тому, что пакет установки &amp;laquo;pkg&amp;raquo; становится открытым и не доверяет GHC. Эта команда работает аналогично команде &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; ,&lt;/a&gt; но дополнительно устанавливает, что GHC не доверяет выбранным пакетам, независимо от содержимого базы данных пакетов. (см. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e900a6603015890af3c88ede22e351087bcb2f4c" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">Эта опция заставляет GHC предоставлять доступ к установочному пакету &amp;laquo;pkg&amp;raquo; и доверять ему. Эта команда работает аналогично команде &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; ,&lt;/a&gt; но дополнительно устанавливает для выбранных пакетов доверие GHC, независимо от содержимого базы данных пакетов. (см. &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7d9bf3c24fe2f83f01a2a1fe6e2465277d625b8" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt;&lt;code&gt;-hide-all-plugin-packages&lt;/code&gt;&lt;/a&gt; was not specified, then all other versions will become hidden. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">Эта опция заставляет установленный пакет &amp;laquo;pkg&amp;raquo; быть представленным для плагинов, например &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt; . Пакет &amp;laquo;pkg&amp;raquo; может быть указан полностью, указав его номер версии (например, &lt;code&gt;network-1.0&lt;/code&gt; ), или номер версии можно не указывать, если установлена ​​только одна версия пакета. Если установлено несколько версий pkg и не &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt; &lt;code&gt;-hide-all-plugin-packages&lt;/code&gt; &lt;/a&gt; , все остальные версии будут скрыты. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; поддерживает прореживание и переименование, описанное в разделе &amp;laquo;&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt; Прореживание и переименование модулей&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef5788126155cc03138f5109c85138baa08f3cb" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</source>
          <target state="translated">Этот параметр вызывает доступ к установленному пакету &amp;laquo;pkg&amp;raquo;. Пакет &amp;laquo;pkg&amp;raquo; может быть указан полностью, указав его номер версии (например, &lt;code&gt;network-1.0&lt;/code&gt; ), или номер версии может быть опущен, и в этом случае GHC автоматически предоставит последнюю исправную версию из установленных версий пакета.</target>
        </trans-unit>
        <trans-unit id="a0e41ab6d83305de686a095b3332cab6407d1ce0" translate="yes" xml:space="preserve">
          <source>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error. See &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;.</source>
          <target state="translated">Эта опция заставляет среду выполнения распечатывать текущий стек центра затрат при возникновении исключения. Это может быть особенно полезно для отладки местоположения исключений, таких как пресловутая &lt;code&gt;Prelude.head: empty list&lt;/code&gt; . См. &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;Варианты RTS для хакеров, отладчиков и чрезмерно заинтересованных душ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b57872a61028ef8c64baf35e07feb3f3f77cf233" translate="yes" xml:space="preserve">
          <source>This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we&amp;rsquo;ll wait until it grows to 4M before collecting it again.</source>
          <target state="translated">Этот параметр управляет объемом памяти, зарезервированной для более старых поколений (а в случае двухпространственного коллектора, размером области выделения) как фактором количества оперативных данных. Например, если при последнем сборе данных в самом старом поколении было 2M живых данных, то по умолчанию мы будем ждать, пока они вырастут до 4M, прежде чем собирать их снова.</target>
        </trans-unit>
        <trans-unit id="fb38d77df4357efae92d504cd6786c9d8c4e6bf3" translate="yes" xml:space="preserve">
          <source>This option disables RTS suggestions about linking with &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either &lt;code&gt;-rtsopts&lt;/code&gt; or &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt;.</source>
          <target state="translated">Эта опция отключает предложения RTS о связывании с &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt; когда они недоступны. Эти предложения были бы бесполезны, если бы пользователи устанавливали программы Haskell через свои менеджеры пакетов. Если этот параметр включен, эти предложения не появятся. &lt;code&gt;-rtsopts&lt;/code&gt; распространяющим двоичные файлы, рекомендуется строить с помощью -rtsopts или &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956ede657ecee5ab5112379453aca532a83df0ab" translate="yes" xml:space="preserve">
          <source>This option displays the currently installed packages, for each of the databases known to &lt;code&gt;ghc-pkg&lt;/code&gt;. That includes the global database, the user&amp;rsquo;s local database, and any further files specified using the &lt;code&gt;-f&lt;/code&gt; option on the command line.</source>
          <target state="translated">Эта опция отображает установленные в настоящее время пакеты для каждой из баз данных, известных &lt;code&gt;ghc-pkg&lt;/code&gt; . Это включает глобальную базу данных, локальную базу данных пользователя и любые другие файлы, указанные с помощью параметра &lt;code&gt;-f&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="a08204879e3c5670124e4d3fa4df08f09c2c5827" translate="yes" xml:space="preserve">
          <source>This option does not put a &lt;em&gt;limit&lt;/em&gt; on the heap size: the heap may grow beyond the given size as usual.</source>
          <target state="translated">Этот параметр не накладывает &lt;em&gt;ограничения&lt;/em&gt; на размер кучи: куча может вырасти за пределы заданного размера, как обычно.</target>
        </trans-unit>
        <trans-unit id="177e417c340a66f0470d8511743420a60bcc5fbb" translate="yes" xml:space="preserve">
          <source>This option does the opposite of &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell &lt;code&gt;import&lt;/code&gt; directives.</source>
          <target state="translated">Этот параметр действует противоположно &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; : он вызывает скрытие указанного пакета, что означает, что ни один из его модулей не будет доступен для &lt;code&gt;import&lt;/code&gt; директивами импорта Haskell .</target>
        </trans-unit>
        <trans-unit id="1560370f0ba5d1fdfc6dfeeacc2a54b30787c270" translate="yes" xml:space="preserve">
          <source>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using &lt;code&gt;UNPACK&lt;/code&gt; pragmas might be better. An alternative is to use &lt;code&gt;-funbox-strict-fields&lt;/code&gt; to turn on unboxing by default but disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">Этот вариант - своего рода кувалда: иногда он может усугубить ситуацию. Выборочная распаковка полей с помощью &lt;code&gt;UNPACK&lt;/code&gt; может быть лучше. Альтернативой является использование &lt;code&gt;-funbox-strict-fields&lt;/code&gt; , чтобы включить распаковку по умолчанию, но отключить ее для определенных полей конструктора с помощью &lt;code&gt;NOUNPACK&lt;/code&gt; (см. &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;Прагму NOUNPACK&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c07ac232f23724b3889cefd06b22eb4683d2f7a" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. Consider recompiling the objects with &lt;code&gt;-fPIC -fexternal-dynamic-refs&lt;/code&gt; and using the &lt;code&gt;-xp&lt;/code&gt; flag instead. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac262cc50deac3cfae652d65a7a869356b40b86" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">Эта опция предназначена только для решения проблем с распределением памяти. Не используйте, если GHCi не выдает сообщение типа &amp;laquo; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; &amp;raquo;. Если вам нужно использовать эту опцию, чтобы GHCi работал на вашем компьютере, сообщите об ошибке.</target>
        </trans-unit>
        <trans-unit id="1c1ed9c302993c8a254ff902df0dbce38b594005" translate="yes" xml:space="preserve">
          <source>This option is less of a sledgehammer than &lt;code&gt;-funbox-strict-fields&lt;/code&gt;: it should rarely make things worse. If you use &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; to turn on unboxing by default you can disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">Этот параметр менее &lt;code&gt;-funbox-strict-fields&lt;/code&gt; на кувалду, чем -funbox-strict-fields : он редко должен ухудшать ситуацию. Если вы используете &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; для включения распаковки по умолчанию, вы можете отключить ее для определенных полей конструктора с помощью &lt;code&gt;NOUNPACK&lt;/code&gt; (см. &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;Прагму NOUNPACK&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fd49d1f76860f1c44d6c219e62e7f40bc9c2382" translate="yes" xml:space="preserve">
          <source>This option is most often used when creating an executable file, to set the filename of the executable. For example:</source>
          <target state="translated">Эта опция наиболее часто используется при создании исполняемого файла,для установки имени файла исполняемого файла.Например:</target>
        </trans-unit>
        <trans-unit id="2ec4e8819778435da9e1806c3a1ad92e747cbb70" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта опция теперь устарела и &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="267371a5e841319f6a790d155fb592c269a41960" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта опция теперь устарела и &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0235b6cb10974ea14ea0574ec14232194a831212" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эта опция теперь устарела и &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wredundant-constraints&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d62299c9dde524b1ef3bb3933973aa22ff0ff398" translate="yes" xml:space="preserve">
          <source>This option is off by default.</source>
          <target state="translated">По умолчанию эта опция выключена.</target>
        </trans-unit>
        <trans-unit id="4293e9fab7792eac1853c48400535b8a8b77123a" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</source>
          <target state="translated">Эта опция включена по умолчанию и предупреждает,если в объявлении экземпляра отсутствует один или несколько методов,а соответствующее объявление класса не имеет для них объявлений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="aeda602ded05cab94ca86a41b88530e26ba7b489" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever the construction of a labelled field constructor isn&amp;rsquo;t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</source>
          <target state="translated">Этот параметр включен по умолчанию и предупреждает вас, когда создание помеченного конструктора поля не завершено, отсутствуют инициализаторы для одного или нескольких полей. Хотя это не ошибка (отсутствующие поля инициализируются нижними точками), это часто указывает на ошибку программиста.</target>
        </trans-unit>
        <trans-unit id="aa97f50ca584638ac24325128130ef5efe4b2fbf" translate="yes" xml:space="preserve">
          <source>This option is on by default.</source>
          <target state="translated">Эта опция включена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9d2fe70b27b67051a789b82f4eb4f639ee630173" translate="yes" xml:space="preserve">
          <source>This option is on by default. As usual you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">По умолчанию эта опция включена. Как обычно, вы можете подавить его для каждого модуля с помощью &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccde2620c81cc8f927379b68565101df835bced2" translate="yes" xml:space="preserve">
          <source>This option is only useful when running in parallel (&lt;code&gt;-N2&lt;/code&gt; or greater). It allows the processor cores to make better use of the available allocation area, even when cores are allocating at different rates. Without &lt;code&gt;-n&lt;/code&gt;, each core gets a fixed-size allocation area specified by the &lt;code&gt;-A&lt;/code&gt;, and the first core to exhaust its allocation area triggers a GC across all the cores. This can result in a collection happening when the allocation areas of some cores are only partially full, so the purpose of the &lt;code&gt;-n&lt;/code&gt; is to allow cores that are allocating faster to get more of the allocation area. This means less frequent GC, leading a lower GC overhead for the same heap size.</source>
          <target state="translated">Эта опция полезна только при параллельной работе ( &lt;code&gt;-N2&lt;/code&gt; или выше). Это позволяет ядрам процессора лучше использовать доступную область распределения, даже когда ядра выделяются с разной скоростью. Без &lt;code&gt;-n&lt;/code&gt; каждое ядро ​​получает область выделения фиксированного размера, указанную параметром &lt;code&gt;-A&lt;/code&gt; , а первое ядро, исчерпывающее свою область выделения, запускает сборщик мусора для всех ядер. Это может привести к тому, что сбор данных произойдет, когда области выделения некоторых ядер заполнены лишь частично, поэтому цель &lt;code&gt;-n&lt;/code&gt; - позволить ядрам, которые выделяются быстрее, получить больше области выделения. Это означает менее частую сборку мусора, что приводит к снижению накладных расходов на сборку мусора при том же размере кучи.</target>
        </trans-unit>
        <trans-unit id="8d9c254d7b78a3a3ecbc5027783e6457d1d482ef" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">Эта опция, вероятно, используется только для параллельных программ, которые явно планируют потоки на ЦП с &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95f6bdd8b0e33deb9f64ace0ba5f278fa7702c9e" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35434e6bd52920e5c48189b8cfc8e504aad6697" translate="yes" xml:space="preserve">
          <source>This option is there mainly to stop the program eating up all the available memory in the machine if it gets into an infinite loop.</source>
          <target state="translated">Эта возможность существует в основном для того,чтобы остановить программу,съедающую всю доступную память в машине,если она попадает в бесконечный цикл.</target>
        </trans-unit>
        <trans-unit id="57d29d5e7df4da4169fdb64e362ca3677dd89e06" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be a bit noisy, and it doesn&amp;rsquo;t always indicate a bug in the program. However, it&amp;rsquo;s generally considered good practice to cover all the cases in your functions, and it is switched on by &lt;a href=&quot;#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Этот параметр не включен по умолчанию, потому что он может быть немного шумным и не всегда указывает на ошибку в программе. Однако обычно считается хорошей практикой охватить все случаи в ваших функциях, и это включается с помощью &lt;a href=&quot;#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f98751831a4a39977803e9637f7e77e2e14db0e" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be very noisy, and it often doesn&amp;rsquo;t indicate a bug in the program.</source>
          <target state="translated">Этот параметр не включен по умолчанию, потому что он может быть очень шумным и часто не указывает на ошибку в программе.</target>
        </trans-unit>
        <trans-unit id="674da51224e4596bdb3744f26e1f9a1fbcb8b81f" translate="yes" xml:space="preserve">
          <source>This option lists registered packages exposing module ⟨M⟩. Examples:</source>
          <target state="translated">В этой опции перечислены зарегистрированные пакеты с модулем ⟨M⟩.Примеры:</target>
        </trans-unit>
        <trans-unit id="c794703287cedcb0e1c47b116ac501bee05de960" translate="yes" xml:space="preserve">
          <source>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</source>
          <target state="translated">Эта опция может помочь,если оцениваемые выражения верхнего уровня потребляют большое количество пространства,или если требуются повторяющиеся измерения производительности.</target>
        </trans-unit>
        <trans-unit id="b7ff2c217eff8117af9178fc8b3897c5316f401a" translate="yes" xml:space="preserve">
          <source>This option provides a &amp;ldquo;suggested heap size&amp;rdquo; for the garbage collector. Think of &lt;code&gt;-Hsize&lt;/code&gt; as a variable &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-A ⟨size⟩&lt;/code&gt;&lt;/a&gt; option. It says: I want to use at least ⟨size⟩ bytes, so use whatever is left over to increase the &lt;code&gt;-A&lt;/code&gt; value.</source>
          <target state="translated">Эта опция обеспечивает &amp;laquo;рекомендуемый размер кучи&amp;raquo; для сборщика мусора. Подумайте о &lt;code&gt;-Hsize&lt;/code&gt; в качестве переменной &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-A ⟨size⟩&lt;/code&gt; &lt;/a&gt; варианта. Он говорит: я хочу использовать как минимум &amp;laquo;размер&amp;raquo; байтов, поэтому используйте все, что осталось, чтобы увеличить значение &lt;code&gt;-A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8853a9d72e715d15e409a53251078ae18153a456" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">Этот вариант относится к лимитам распределения; подробнее об этом см. &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt; . Когда поток достигает своего предела выделения, RTS генерирует исключение для потока, и поток получает дополнительную квоту выделения до того, как исключение будет снова возбуждено, идея заключается в том, чтобы поток мог выполнять свои обработчики исключений. &lt;code&gt;-xq&lt;/code&gt; контролирует размер этой дополнительной квоты.</target>
        </trans-unit>
        <trans-unit id="5d0cb54597e16fb360f23cd6c09d2b5b66dd5dd4" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea918ac03fd189d0258f1a47317cf8c206c5d32" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (although they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363c890a3de72dcec771b7f4c76b67f54a27050f" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (althought they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">Эти выходные данные показывают, что в контексте текущего сеанса (т. &lt;code&gt;Data.Maybe&lt;/code&gt; области действия &lt;code&gt;Prelude&lt;/code&gt; ) первая группа элементов из Data. Может быть, не входит в область действия (хотя они доступны в полной форме в сеансе GHCi - см. &lt;a href=&quot;#ghci-scope&quot;&gt;Что действительно в области действия в приглашении?&lt;/a&gt; ), тогда как вторая группа элементов входит в область действия (через &lt;code&gt;Prelude&lt;/code&gt; ) и поэтому доступна либо без квалификации, либо с помощью &lt;code&gt;Prelude.&lt;/code&gt; Классификатор.</target>
        </trans-unit>
        <trans-unit id="d32fd0e1a9f5bf7e2d98a725ace2312b41fff634" translate="yes" xml:space="preserve">
          <source>This package provides both strict and lazy &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; types. The strict type is provided by the &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; module, while the lazy type is provided by the &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; module. Internally, the lazy &lt;code&gt;Text&lt;/code&gt; type consists of a list of strict chunks.</source>
          <target state="translated">Этот пакет предоставляет как строгие, так и ленивые типы &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Строгий тип предоставляется модулем &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; , а ленивый тип - модулем &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; . Внутренне тип отложенного &lt;code&gt;Text&lt;/code&gt; состоит из списка строгих фрагментов.</target>
        </trans-unit>
        <trans-unit id="5c301e63fdee476a49263ba8163281e72adf6b96" translate="yes" xml:space="preserve">
          <source>This package uses the term &lt;em&gt;character&lt;/em&gt; to denote Unicode &lt;em&gt;code points&lt;/em&gt;.</source>
          <target state="translated">Этот пакет использует термин &amp;laquo; &lt;em&gt;символ&amp;raquo;&lt;/em&gt; для обозначения &lt;em&gt;кодовых точек&lt;/em&gt; Unicode .</target>
        </trans-unit>
        <trans-unit id="aae5addb116c887a46f27acc513b2117c6d86f14" translate="yes" xml:space="preserve">
          <source>This parameter is reserved. You should pass just &lt;em&gt;nullPtr&lt;/em&gt;.</source>
          <target state="translated">Этот параметр зарезервирован. Вы должны передать только &lt;em&gt;nullPtr&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="15f0fa32e677164a596a3b41ef5acc2c4991ec87" translate="yes" xml:space="preserve">
          <source>This parameter requires to use Windows 7 or later.</source>
          <target state="translated">Этот параметр требует использования Windows 7 или более поздней версии.</target>
        </trans-unit>
        <trans-unit id="2b0fc7a248b7324fafef584b213680e79287e0c9" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот синтаксический анализатор успешно работает только в конце ввода. Это не примитивный синтаксический анализатор, но он определяется с помощью &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b70e45e4186d009ec916862fca7c137404104fc" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот синтаксический анализатор успешно работает только в конце ввода. Это не примитивный синтаксический анализатор, но он определяется с помощью &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dfbf340dce50dc9038b479329f38e8ec299cf61" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот синтаксический анализатор успешно работает только в конце ввода. Это не примитивный синтаксический анализатор, но он определяется с помощью &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9300de657d2872adc67fa41e5ab353e07ce88a2d" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of identifiers. For example &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">Этот синтаксический анализатор должен принимать любые законные хвостовые символы идентификаторов. Например, &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8528eebabb9825d0176f24d442e7c8b026df63e" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">Этот синтаксический анализатор должен принимать любые допустимые хвостовые символы операторов. Обратите внимание, что этот синтаксический анализатор должен быть определен даже в том случае, если язык не поддерживает пользовательские операторы, иначе синтаксический анализатор &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; не будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="00d8c7a0c04c027e82791e73a94a73041f724be2" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">Этот синтаксический анализатор должен принимать любые допустимые хвостовые символы операторов. Обратите внимание, что этот синтаксический анализатор должен быть определен даже в том случае, если язык не поддерживает пользовательские операторы, иначе синтаксический анализатор &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; не будет работать правильно.</target>
        </trans-unit>
        <trans-unit id="d983e2b71ccf1f3a26f0aff85466bf1e651e9beb" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of identifiers. For example &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">Этот парсер должен принимать любые начальные символы идентификаторов. Например, &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b9eeef0a0daf3a30997aca44251904a3bc4ace8" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of operators. For example &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</source>
          <target state="translated">Этот парсер должен принимать любые начальные символы операторов. Например &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9db4088868263aaafdfa869a0f8e2314217323d7" translate="yes" xml:space="preserve">
          <source>This parser succeeds for any character. Returns the parsed character.</source>
          <target state="translated">Этот синтаксический анализатор подходит для любого персонажа.Возвращает обработанный символ.</target>
        </trans-unit>
        <trans-unit id="a306a889dc9a52a42b11381f826b2d7630214d4b" translate="yes" xml:space="preserve">
          <source>This pragma is similar to C&amp;rsquo;s &lt;code&gt;#line&lt;/code&gt; pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</source>
          <target state="translated">Эта прагма похожа на прагму C &lt;code&gt;#line&lt;/code&gt; и в основном предназначена для использования в автоматически сгенерированном коде Haskell. Он позволяет вам указать номер строки и имя файла исходного кода; например</target>
        </trans-unit>
        <trans-unit id="ca88c24656a8d8661c565a0c56d31be0ec21660f" translate="yes" xml:space="preserve">
          <source>This primitive is only available when the underlying GMP library supports it (GMP &amp;gt;= 5). Otherwise, it internally falls back to &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt;, and a warning will be emitted when used.</source>
          <target state="translated">Этот примитив доступен, только если базовая библиотека GMP поддерживает его (GMP&amp;gt; = 5). В противном случае он внутренне возвращается к &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; , и при использовании будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="dceb51efdb1a52e7502aaf8f2f6a2f14168bc8e4" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">Эта проблема влияет не только на GHCi, но и на любую скомпилированную GHC программу, которая хочет улавливать события консоли. См. Модуль &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a497560db9bd41df0e1b95425a2c75d218c8ec8" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c277562015915ae2718208c757d99e3c4a5c2ea5" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">Это дает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; для каждого ключа:</target>
        </trans-unit>
        <trans-unit id="520ac415055f1c0bf4aa6e9c1ae9d27830756102" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d113cd0a06b95adde252febb8a83dc6d268b9573" translate="yes" xml:space="preserve">
          <source>This program will be rejected as ambiguous because GHC will not unify the type variables &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24c8bfbcd524c9aaee115418d115977f5d18a8a" translate="yes" xml:space="preserve">
          <source>This program will be rejected, because &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; does not scope over the definition of &amp;ldquo;&lt;code&gt;g&lt;/code&gt;&amp;rdquo;, so &amp;ldquo;&lt;code&gt;x::a&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;x::forall a. a&lt;/code&gt;&amp;rdquo; by Haskell&amp;rsquo;s usual implicit quantification rules.</source>
          <target state="translated">Эта программа будет отклонена, потому что &amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo; не распространяется на определение &amp;laquo; &lt;code&gt;g&lt;/code&gt; &amp;raquo;, поэтому &amp;laquo; &lt;code&gt;x::a&lt;/code&gt; &amp;raquo; означает &amp;laquo; &lt;code&gt;x::forall a. a&lt;/code&gt; &amp;raquo;обычными правилами неявной количественной оценки Haskell.</target>
        </trans-unit>
        <trans-unit id="d583e97443b28f0723fcc05e1353f50d62ca3ee1" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">Эта программа сделает дамп ядра. Эта проблема с полиморфными ссылками хорошо известна в сообществе ML и не возникает при обычном монадическом использовании ссылок. Нет простого способа сделать это невозможным, если вы используете &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Действительно, можно написать &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Так что будьте осторожны!</target>
        </trans-unit>
        <trans-unit id="39080170230fd9e748e118da55a46cb1b209f144" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">Эта программа сделает дамп ядра. Эта проблема с полиморфными ссылками хорошо известна в сообществе ML и не возникает при обычном монадическом использовании ссылок. Нет простого способа сделать это невозможным, если вы используете &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Действительно, можно написать &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Так что будьте осторожны!</target>
        </trans-unit>
        <trans-unit id="8c3070f1819b5144ee0019a42b9364d5b62ac534" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">Эта программа сделает дамп ядра. Эта проблема с полиморфными ссылками хорошо известна в сообществе ML и не возникает при обычном монадическом использовании ссылок. Нет простого способа сделать это невозможным, если вы используете &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Действительно, можно написать &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Так что будьте осторожны!</target>
        </trans-unit>
        <trans-unit id="8edf15b81edbb17eae494e16b7d0533a271e50da" translate="yes" xml:space="preserve">
          <source>This provides a type-indexed type representation mechanism, similar to that described by,</source>
          <target state="translated">Это обеспечивает механизм представления типа,аналогичный описанному,</target>
        </trans-unit>
        <trans-unit id="77d3447bc17b046a19fec0f3cc3c7ab330fb5b15" translate="yes" xml:space="preserve">
          <source>This reduces the allocation and trimming overhead, as all generated &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s fit into the first buffer and there is no trimming required, if more than 64 bytes and less than 128 bytes are written.</source>
          <target state="translated">Это уменьшает накладные расходы на выделение и обрезку, поскольку все сгенерированные &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; помещаются в первый буфер, и обрезка не требуется, если записано более 64 и менее 128 байтов.</target>
        </trans-unit>
        <trans-unit id="79b2e379cd0f1eaf600da24618a21f3bffdedc96" translate="yes" xml:space="preserve">
          <source>This relative path technique can be used with either of the two &lt;code&gt;-dynload&lt;/code&gt; modes, though it makes most sense with the &lt;code&gt;deploy&lt;/code&gt; mode. The difference is that with the &lt;code&gt;deploy&lt;/code&gt; mode, the above example will end up with an ELF &lt;code&gt;RUNPATH&lt;/code&gt; of just &lt;code&gt;$ORIGIN&lt;/code&gt; while with the &lt;code&gt;sysdep&lt;/code&gt; mode the &lt;code&gt;RUNPATH&lt;/code&gt; will be &lt;code&gt;$ORIGIN&lt;/code&gt; followed by all the library directories of all the packages that the program depends on (e.g. &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages etc.) which are typically absolute paths. The unix tool &lt;code&gt;readelf --dynamic&lt;/code&gt; is handy for inspecting the &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries in ELF shared libraries and executables.</source>
          <target state="translated">Этот метод относительного пути можно использовать с любым из двух режимов &lt;code&gt;-dynload&lt;/code&gt; , хотя он имеет наибольший смысл в режиме &lt;code&gt;deploy&lt;/code&gt; . Разница заключается в том, что с &lt;code&gt;deploy&lt;/code&gt; режимом, приведенный выше пример будет в конечном итоге с ELF &lt;code&gt;RUNPATH&lt;/code&gt; от всего &lt;code&gt;$ORIGIN&lt;/code&gt; в то время как с &lt;code&gt;sysdep&lt;/code&gt; режимом &lt;code&gt;RUNPATH&lt;/code&gt; будет &lt;code&gt;$ORIGIN&lt;/code&gt; следует всем библиотеки каталогов всех пакетов , что программа зависит от ( например, пакеты &lt;code&gt;base&lt;/code&gt; и &lt;code&gt;rts&lt;/code&gt; и т. д.), которые обычно являются абсолютными путями. Инструмент unix &lt;code&gt;readelf --dynamic&lt;/code&gt; удобен для проверки &lt;code&gt;RPATH&lt;/code&gt; / &lt;code&gt;RUNPATH&lt;/code&gt; Записи RUNPATH в разделяемых библиотеках и исполняемых файлах ELF.</target>
        </trans-unit>
        <trans-unit id="370040cae2bc778368a6b92c807c4b5827ecb99e" translate="yes" xml:space="preserve">
          <source>This representation is generated automatically if a &lt;code&gt;deriving Generic&lt;/code&gt; clause is attached to the datatype. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Standalone deriving&lt;/a&gt; can also be used.</source>
          <target state="translated">Это представление создается автоматически, если к типу данных присоединено &lt;code&gt;deriving Generic&lt;/code&gt; предложение Generic . Также можно использовать &lt;a href=&quot;#stand-alone-deriving&quot;&gt;автономное извлечение&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30dd0b304103583a22935853ab5fa131cea21cbe" translate="yes" xml:space="preserve">
          <source>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the &lt;code&gt;Int&lt;/code&gt; type, respectively:</source>
          <target state="translated">Это представление является очень общим, поскольку никакие типы не обрабатываются специальным образом. Однако некоторым функциям может потребоваться специально обрабатывать некоторые известные типы, например следующие две функции собирают все типы аргументов (вложенных) типов стрелок и распознают тип &lt;code&gt;Int&lt;/code&gt; соответственно:</target>
        </trans-unit>
        <trans-unit id="54c505cd157188eeaeea208a88996c170f20c5ef" translate="yes" xml:space="preserve">
          <source>This resembles the wildcards that can be used in &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; have any effect.</source>
          <target state="translated">Это похоже на подстановочные знаки, которые можно использовать в &lt;a href=&quot;#partial-type-signatures&quot;&gt;подписях частичного типа&lt;/a&gt; . Однако есть некоторые отличия. Сообщения об ошибках, сообщающие о предполагаемых типах, не создаются, а расширение &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; не&lt;/a&gt; имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="05658b8ed19f8a18e37b401843f9f1390a5fc067" translate="yes" xml:space="preserve">
          <source>This results in the variable &lt;code&gt;output&lt;/code&gt; taking on the value below:</source>
          <target state="translated">Это приводит к тому, что &lt;code&gt;output&lt;/code&gt; переменная принимает значение, указанное ниже:</target>
        </trans-unit>
        <trans-unit id="faeb3724827d317e7530a6953ccd1a741efde90d" translate="yes" xml:space="preserve">
          <source>This rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab2f281f7fbf2bff47d327fa4cfe489acb61e45" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;#10132&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dae13ecc0c945a796e78580e4456aee9006b862" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue #10132&lt;/a&gt;.</source>
          <target state="translated">Это правило иногда приводит к неожиданным последствиям (см. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Проблему # 10132&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a75e7f4aae139decf4dbddc8f92f07f78b73ed" translate="yes" xml:space="preserve">
          <source>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">Это правило применяется независимо от флагов. Если вам нужен более экзотический контекст, вы можете написать его самостоятельно, используя &lt;a href=&quot;#stand-alone-deriving&quot;&gt;автономный механизм вывода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9ad35ca09458fcaf673d419d014807d6053c2a9" translate="yes" xml:space="preserve">
          <source>This rule will cause the compiler to go into an infinite loop.</source>
          <target state="translated">Это правило приведет компилятор к бесконечному циклу.</target>
        </trans-unit>
        <trans-unit id="2d325df582f925494ea658de7dc04323c3323bae" translate="yes" xml:space="preserve">
          <source>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</source>
          <target state="translated">Это правило работает для любого типа бетона,в том числе и для типа конструкторов с полиморфными типами.Единственное ограничение состоит в том,что если конструктор типа имеет полиморфный вид,то он должен применяться ко всем его видовым параметрам,и эти виды должны быть конкретными (т.е.в них не могут быть упомянуты видовые переменные).</target>
        </trans-unit>
        <trans-unit id="012cf785712f9f58baa44a19777eaca31580d1fc" translate="yes" xml:space="preserve">
          <source>This runs the interpreted code in a separate process (see &lt;a href=&quot;#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;) and runs it in profiling mode to collect call stack information. Note that because we&amp;rsquo;re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The &lt;code&gt;-prof&lt;/code&gt; flag to GHCi only works in conjunction with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;.</source>
          <target state="translated">Это запускает интерпретируемый код в отдельном процессе (см. &lt;a href=&quot;#external-interpreter&quot;&gt;Запуск интерпретатора в отдельном процессе&lt;/a&gt; ) и запускает его в режиме профилирования для сбора информации о стеке вызовов. Обратите внимание: поскольку мы запускаем интерпретируемый код в режиме профилирования, все используемые вами пакеты должны быть скомпилированы для профилирования. &lt;code&gt;-prof&lt;/code&gt; флаг GHCi работает только в сочетании с &lt;code&gt;-fexternal-interpreter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e7a2ad40c566ce0f6643ee923a3e30a05545bee" translate="yes" xml:space="preserve">
          <source>This says that &lt;code&gt;modify (+1)&lt;/code&gt; acts over any Monad that is a member of the &lt;code&gt;MonadState&lt;/code&gt; class, with an &lt;code&gt;Int&lt;/code&gt; state.</source>
          <target state="translated">Это говорит о том, что &lt;code&gt;modify (+1)&lt;/code&gt; действует над любой монадой, которая является членом класса &lt;code&gt;MonadState&lt;/code&gt; с состоянием &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeefc346ad248407772de61eb44c91ebc62b1dff" translate="yes" xml:space="preserve">
          <source>This section defines the layout of these events. The &lt;code&gt;String&lt;/code&gt; type below is defined to be a UTF-8 encoded NUL-terminated string.</source>
          <target state="translated">В этом разделе определяется схема этих событий. Тип &lt;code&gt;String&lt;/code&gt; ниже определен как закодированная в UTF-8 строка с завершающим NUL.</target>
        </trans-unit>
        <trans-unit id="426477ffd0f3109ffb983e296577e866ad83653a" translate="yes" xml:space="preserve">
          <source>This section describes &lt;em&gt;data type promotion&lt;/em&gt;, an extension to the kind system that complements kind polymorphism. It is enabled by &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, and described in more detail in the paper &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;, which appeared at TLDI 2012.</source>
          <target state="translated">В этом разделе описывается &lt;em&gt;продвижение типов данных&lt;/em&gt; , расширение системы &lt;em&gt;типов&lt;/em&gt; , которое дополняет полиморфизм видов. Он включен &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; и более подробно описан в статье &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt; , появившейся на TLDI 2012.</target>
        </trans-unit>
        <trans-unit id="cb974cf5a36706fbeb443061b653e868010df89d" translate="yes" xml:space="preserve">
          <source>This section describes GHC&amp;rsquo;s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC&amp;rsquo;s kind system.</source>
          <target state="translated">В этом разделе описывается система доброжелательности GHC в том виде, в котором она появилась в версии 8.0 и выше. Система kind, описанная здесь, всегда действует, с расширениями или без них, хотя это консервативное расширение по сравнению со стандартным Haskell. Вышеупомянутые расширения просто включают синтаксис и настраивают алгоритм вывода, чтобы позволить пользователям воспользоваться преимуществами дополнительной выразительности системы доброжелательности GHC.</target>
        </trans-unit>
        <trans-unit id="d4d58a26ba3b02f1db1fe2de0ac14aa3d6a048b5" translate="yes" xml:space="preserve">
          <source>This section describes features specific to GHC's implementation of Concurrent Haskell.</source>
          <target state="translated">В этом разделе описаны особенности реализации Concurrent Haskell в GHC.</target>
        </trans-unit>
        <trans-unit id="bdd49ffb73a3731ac6d967fc14496c16e1567101" translate="yes" xml:space="preserve">
          <source>This section describes how to create DLLs to be called from other languages, such as Visual Basic or C++. This is a special case of &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;; we&amp;rsquo;ll deal with the DLL-specific issues that arise below. Here&amp;rsquo;s an example:</source>
          <target state="translated">В этом разделе описывается, как создавать библиотеки DLL, которые будут вызываться из других языков, например Visual Basic или C ++. Это особый случай &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;создания библиотеки Haskell, которую можно вызывать из внешнего кода&lt;/a&gt; ; мы разберемся с проблемами, связанными с DLL, которые возникают ниже. Вот пример:</target>
        </trans-unit>
        <trans-unit id="c716f59912a3ade4c8a600a747406892f16105cd" translate="yes" xml:space="preserve">
          <source>This section describes other program(s) which we distribute, that help with the Great Haskell Programming Task.</source>
          <target state="translated">В этом разделе описаны другие программы,которые мы распространяем и которые помогают в выполнении Великой задачи по хаскелльному программированию.</target>
        </trans-unit>
        <trans-unit id="cd9343002ee7f20ea72481ff97c75ea4a9503720" translate="yes" xml:space="preserve">
          <source>This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</source>
          <target state="translated">В этом разделе описывается,какие файлы ожидает найти GHC,какие файлы он создает,где хранятся эти файлы,и какие опции влияют на это поведение.</target>
        </trans-unit>
        <trans-unit id="f1c1c7aa4c4b76ef9244f133c648760bb4ada19e" translate="yes" xml:space="preserve">
          <source>This section documents GHC&amp;rsquo;s take on various issues that are left undefined or implementation specific in Haskell 98.</source>
          <target state="translated">В этом разделе документируется подход GHC к различным вопросам, которые остаются неопределенными или специфичными для реализации в Haskell 98.</target>
        </trans-unit>
        <trans-unit id="d1b5cee4b5290696273cb8636327d9703229eadc" translate="yes" xml:space="preserve">
          <source>This section documents the encodings of the events emitted to GHC&amp;rsquo;s &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt;. These events can include information about the thread scheduling events, garbage collection statistics, profiling information, user-defined tracing events.</source>
          <target state="translated">В этом разделе описываются кодировки событий, отправляемых в &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;журнал&lt;/a&gt; событий GHC . Эти события могут включать информацию о событиях планирования потоков, статистику сборки мусора, информацию профилирования, определяемые пользователем события трассировки.</target>
        </trans-unit>
        <trans-unit id="b978b97b7476bee1ad03a8af2ae4346819b8abd7" translate="yes" xml:space="preserve">
          <source>This section is a quick-reference for GHC&amp;rsquo;s command-line flags. For each flag, we also list its mode/dynamic status (see &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;), and the flag&amp;rsquo;s opposite (if available).</source>
          <target state="translated">Этот раздел представляет собой краткий справочник по флагам командной строки GHC. Для каждого флага мы также указываем его режим / динамический статус (см. &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Параметры &amp;laquo;Динамический&amp;raquo; и &amp;laquo;Режим&amp;raquo;&lt;/a&gt; ) и противоположный флаг (если доступен).</target>
        </trans-unit>
        <trans-unit id="e5d224e7441e3fb869faddf4a0821bffaff71c9b" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events.</source>
          <target state="translated">Данный раздел предназначен для исполнителей инструментов,потребляющих эти события.</target>
        </trans-unit>
        <trans-unit id="2631d568425721367141e5ca16a0dc349ee46597" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events. GHC ships with a C header file (&lt;code&gt;EventlogFormat.h&lt;/code&gt;) which provides symbolic names for the event type IDs described in this file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4793c1dfb931aabba357e67757e80e8fe4a49b96" translate="yes" xml:space="preserve">
          <source>This section lists Glasgow Haskell infelicities in its implementation of Haskell 98 and Haskell 2010. See also the &amp;ldquo;when things go wrong&amp;rdquo; section (&lt;a href=&quot;gone_wrong#wrong&quot;&gt;What to do when something goes wrong&lt;/a&gt;) for information about crashes, space leaks, and other undesirable phenomena.</source>
          <target state="translated">В этом разделе перечислены недостатки Glasgow Haskell в реализации Haskell 98 и Haskell 2010. См. Также раздел &amp;laquo; &lt;a href=&quot;gone_wrong#wrong&quot;&gt;Когда что-то идет не&lt;/a&gt; так&amp;raquo; ( Что делать, когда что-то идет не так ) для получения информации о сбоях, утечках пространства и других нежелательных явлениях.</target>
        </trans-unit>
        <trans-unit id="9d329579f2386fca40f0668d94a24284cae13ec1" translate="yes" xml:space="preserve">
          <source>This section, and the next one, documents GHC&amp;rsquo;s type-class extensions. There&amp;rsquo;s lots of background in the paper &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Type classes: exploring the design space&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer).</source>
          <target state="translated">Этот и следующий раздел документируют расширения классов типов GHC. В документе &amp;laquo; &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Типовые классы&lt;/a&gt; &amp;raquo; много предыстории : исследование пространства дизайна (Саймон Пейтон Джонс, Марк Джонс, Эрик Мейер).</target>
        </trans-unit>
        <trans-unit id="2b1a90dce5c453c0f69c1639a0cce7223844a1ff" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">Это похоже на обобщение стандартного оператора &lt;code&gt;$&lt;/code&gt; . Однако, если мы подумаем о компиляции этого в работающий код, возникнут проблемы. В частности, когда мы называем &lt;code&gt;bad&lt;/code&gt; , мы должны каким-то образом передать &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;bad&lt;/code&gt; . Насколько велик (то есть сколько бит) &lt;code&gt;x&lt;/code&gt; ? Это указатель? В какой регистр (с плавающей запятой или интегральный) должен входить &lt;code&gt;x&lt;/code&gt; ? Сказать все это невозможно, потому что тип &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;a :: TYPE r1&lt;/code&gt; является легковесным полиморфным. Таким образом, мы запрещаем такие конструкции с помощью следующего простого правила:</target>
        </trans-unit>
        <trans-unit id="36e8a4554348a6c067a922b4fe362601f76eb118" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c863740ea2de0c5a648f81c5a1a438b882986762" translate="yes" xml:space="preserve">
          <source>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</source>
          <target state="translated">Это кажется наиболее интуитивным и прозрачным подходом к разработчику,которому больше не нужно беспокоиться о том,что его код может содержать перекрывающиеся аксиомы или упорядочивать контексты его экземпляра.Но обратное движение в равной степени применимо и к обычному выбору экземпляров (при наличии перекрывающихся экземпляров),так что это гораздо более распространенное изменение,имеющее существенные последствия для механизма вывода типа.</target>
        </trans-unit>
        <trans-unit id="8048706f7c05b6021df5922e0299f8cdba50f03b" translate="yes" xml:space="preserve">
          <source>This should &lt;em&gt;never&lt;/em&gt; be used in combination with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. Think of &lt;code&gt;&lt;a href=&quot;control-monad-catch-pure#t:CatchT&quot;&gt;CatchT&lt;/a&gt;&lt;/code&gt; as an alternative base monad for use with mocking code that solely throws exceptions via &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:throwM&quot;&gt;throwM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bbd3a27d52a3a851dbfdab4b9ab18c81125223" translate="yes" xml:space="preserve">
          <source>This should call &lt;code&gt;error&lt;/code&gt; but actually prints &lt;code&gt;True&lt;/code&gt;. Reason: GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</source>
          <target state="translated">Это должно вызвать &lt;code&gt;error&lt;/code&gt; но на самом деле выводит &lt;code&gt;True&lt;/code&gt; . Причина: GHC eta-расширяет &lt;code&gt;f&lt;/code&gt; до</target>
        </trans-unit>
        <trans-unit id="7ab63a2693cd6c7a45c1f790143037cd6507bc64" translate="yes" xml:space="preserve">
          <source>This should produce a file named &lt;code&gt;fib.dSYM&lt;/code&gt;.</source>
          <target state="translated">Это должно создать файл с именем &lt;code&gt;fib.dSYM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="739e32040ecc4d2911d13031c9ae018167e3429f" translate="yes" xml:space="preserve">
          <source>This should work, as long as your GHCi was built with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; switch, which is the default. Consult whoever supplied your GHCi installation.</source>
          <target state="translated">Это должно работать, если ваш GHCi был построен с переключателем &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , который установлен по умолчанию. Проконсультируйтесь с поставщиком вашей установки GHCi.</target>
        </trans-unit>
        <trans-unit id="58d6ca6d530436d6559c489e7dd370e9564a3d34" translate="yes" xml:space="preserve">
          <source>This simple plugin takes over the execution of Template Haskell code, replacing any expression splice it encounters by &lt;code&gt;0&lt;/code&gt; (at type &lt;code&gt;Int&lt;/code&gt;), and errors out on any other type of splice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689b2645ac8c6757ff69fc4ca6accdc5ec8ea0cb" translate="yes" xml:space="preserve">
          <source>This slightly odd-looking rule instructs GHC to replace &lt;code&gt;genericLookup&lt;/code&gt; by &lt;code&gt;intLookup&lt;/code&gt;&lt;em&gt;whenever the types match&lt;/em&gt;. What is more, this rule does not need to be in the same file as &lt;code&gt;genericLookup&lt;/code&gt;, unlike the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragmas which currently do (so that they have an original definition available to specialise).</source>
          <target state="translated">Это немного странное правило предписывает GHC заменять &lt;code&gt;genericLookup&lt;/code&gt; на &lt;code&gt;intLookup&lt;/code&gt; &lt;em&gt;всякий раз, когда типы совпадают&lt;/em&gt; . Более того, это правило не обязательно должно находиться в том же файле, что и &lt;code&gt;genericLookup&lt;/code&gt; , в отличие от прагм &lt;code&gt;SPECIALIZE&lt;/code&gt; , которые в настоящее время существуют (так что у них есть исходное определение, доступное для специализации).</target>
        </trans-unit>
        <trans-unit id="074a31f4d9e16cb86e220f5f40a063ee59b833fe" translate="yes" xml:space="preserve">
          <source>This stack structure means that the order of &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; flags or &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</source>
          <target state="translated">Эта структура стека означает, что &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt; флагов &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt;-db &amp;laquo;файл&amp;raquo; или GHC_PACKAGE_PATH . Каждый подстек стека должен быть правильно сформирован (пакеты в базах данных наверху стека могут ссылаться на пакеты ниже, но не наоборот).</target>
        </trans-unit>
        <trans-unit id="e66c29e8f81778a2aa9684e85767a00ebb262ce6" translate="yes" xml:space="preserve">
          <source>This statement requires that f have the type forall a. [a] -&amp;gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</source>
          <target state="translated">Этот оператор требует, чтобы f имел тип для всех a. [а] -&amp;gt; [а]. Вы можете увидеть пример его использования в мотивирующем примере, поскольку эта форма используется для применения дубля 5.</target>
        </trans-unit>
        <trans-unit id="61c78a7e665855a92db9c5e9ffaec8226aba79b6" translate="yes" xml:space="preserve">
          <source>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (&amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;\\&quot;&lt;/code&gt;, depending on the system), and ⟨extension⟩ is a source extension (&lt;code&gt;hs&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;) if we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, or ⟨hisuf⟩ otherwise.</source>
          <target state="translated">Эта стратегия заключается в следующем: GHC ведет список каталогов, который называется путем поиска. Для каждого из этих каталогов он пытается добавить &amp;laquo;имя &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; в каталог и проверяет, существует ли файл. Значение &amp;laquo;basename&amp;raquo; - это имя модуля с точками, замененными разделителем каталогов (&amp;laquo; &lt;code&gt;/&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;\\&quot;&lt;/code&gt; , в зависимости от системы), а &amp;laquo;extension&amp;raquo; - это исходное расширение ( &lt;code&gt;hs&lt;/code&gt; , &lt;code&gt;lhs&lt;/code&gt; ), если мы находимся в &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; mode или GHCi, иначе &amp;laquo;hisuf &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="11ed97c596e1d0bcc228efb8114c48f030b93b3b" translate="yes" xml:space="preserve">
          <source>This tells you:</source>
          <target state="translated">Это говорит тебе:</target>
        </trans-unit>
        <trans-unit id="07d8f00faa3ae75b40703b0528f229ea480038a2" translate="yes" xml:space="preserve">
          <source>This thread has exceeded its allocation limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот поток превысил свой предел выделения. Смотрите &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c243ec7e03c31ba25363993635c259a833d99359" translate="yes" xml:space="preserve">
          <source>This translates to:</source>
          <target state="translated">Это значит:</target>
        </trans-unit>
        <trans-unit id="e21f274a51f9949f29f1cc84b56dc845f3250ad2" translate="yes" xml:space="preserve">
          <source>This trick isn&amp;rsquo;t foolproof, because there might be other &lt;code&gt;B&lt;/code&gt; closures in the heap which aren&amp;rsquo;t the retainers we are interested in, but we&amp;rsquo;ve found this to be a useful technique in most cases.</source>
          <target state="translated">Этот трюк не является надежным, потому что в куче могут быть другие &lt;code&gt;B&lt;/code&gt; - замыкания, которые не являются интересующими нас фиксаторами, но мы обнаружили, что это полезный метод в большинстве случаев.</target>
        </trans-unit>
        <trans-unit id="7eedf2bab1365e54cbd4693945639257ad4fb0f2" translate="yes" xml:space="preserve">
          <source>This trivial type constructor serves two purposes:</source>
          <target state="translated">Этот тривиальный тип конструктора служит двум целям:</target>
        </trans-unit>
        <trans-unit id="628155b5f0687904716807bcd6409248a6482468" translate="yes" xml:space="preserve">
          <source>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</source>
          <target state="translated">Этот двухэтапный процесс необходим потому,что GHC не может в настоящее время профилировать,используя одновременно и биографическую информацию,и информацию для сохранения.</target>
        </trans-unit>
        <trans-unit id="da64adf134879e08323ed89e3b1e4948df137364" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level natural numbers.</source>
          <target state="translated">Этот тип представляет собой натуральные числа неизвестного типа.</target>
        </trans-unit>
        <trans-unit id="63e71d7f0b07e2f8017ecf6cb7990bb372b6c369" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level symbols.</source>
          <target state="translated">Этот тип представляет собой символы неизвестного типа.</target>
        </trans-unit>
        <trans-unit id="dc9fd430c3e406e9bfda4395aaf8dea448b92e37" translate="yes" xml:space="preserve">
          <source>This type signature contains a kind error which cannot be deferred.</source>
          <target state="translated">Данный тип сигнатуры содержит ошибку типа,которая не может быть отложена.</target>
        </trans-unit>
        <trans-unit id="d1458226daed690560f642a2591b54664bcd7099" translate="yes" xml:space="preserve">
          <source>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see &lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;).</source>
          <target state="translated">Это использование подчеркивания для подстановочного знака в шаблоне типа в точности похоже на сопоставление с образцом в языке терминов, но несколько отличается от использования подчеркивания в частичной сигнатуре типа (см. &lt;a href=&quot;#type-wildcards&quot;&gt;Подстановочные знаки типа&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="843b161d44b1dbfe532489a8737416458e734625" translate="yes" xml:space="preserve">
          <source>This uses the above tree rendering function, and displays the Html as a tree structure, allowing debugging of what is actually getting produced.</source>
          <target state="translated">При этом используется приведенная выше функция рендеринга дерева,а Html отображается в виде древовидной структуры,позволяя отлаживать то,что на самом деле получается.</target>
        </trans-unit>
        <trans-unit id="115cfdee365c54682223fbca3e4f895eb1f6e102" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Здесь используется тот факт, что &lt;code&gt;let&lt;/code&gt; в Haskell вводит рекурсивные привязки. Мы можем переписать это определение с помощью &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="c1be3ce1530bcdc820d6c90501be79827a35abad" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Здесь используется тот факт, что &lt;code&gt;let&lt;/code&gt; в Haskell вводит рекурсивные привязки. Мы можем переписать это определение с помощью &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7f88835ef04d1f3754243e8cd078d29d91f94c0a" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">Обычно это не проблема, и это позволяет системе времени выполнения GHC эффективно использовать ресурсы потоков ОС. Однако бывают случаи, когда полезно иметь больший контроль над используемым потоком ОС, например, при вызове внешнего кода, который использует локальное состояние потока. Для подобных случаев мы предоставляем &lt;em&gt;связанные потоки&lt;/em&gt; , которые представляют собой потоки Haskell, привязанные к конкретному потоку ОС. Для получения информации о связанных потоках см. Документацию по модулю &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1160e9ee24dc05017fdb7f0fab69b46a37237f1" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fe6c899f31bf735023aed7edade5c845bb20c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; добавляет финализатор, который ожидает среду в дополнение к финализированному указателю. Среда, которая будет передана финализатору, фиксируется вторым аргументом &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73272fcd0ad868eb9d7204167149b902a10e97d9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Этот вариант &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; добавляет финализатор, который ожидает среду в дополнение к финализированному указателю. Среда, которая будет передана финализатору, фиксируется вторым аргументом &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9448bed87d0380afdfc5a0e85ab115284bc4a12f" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; appears at the type level.</source>
          <target state="translated">Этот вариант &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; появляется на уровне типа.</target>
        </trans-unit>
        <trans-unit id="d456ce198372e2f1c13a10638b827f2a19ffc595" translate="yes" xml:space="preserve">
          <source>This version builds its output lazily; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;.</source>
          <target state="translated">Эта версия строит свой вывод лениво; для версии с постоянным пространством с почти таким же интерфейсом см. &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bbca1b395d2fc0bccc520c78f768d92dd9c439e" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly and uses continuation-passing-style to achieve constant space usage. This transformer can be used as a drop-in replacement for &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt;.</source>
          <target state="translated">Эта версия строит свой вывод строго и использует стиль передачи продолжения для достижения постоянного использования пространства. Этот преобразователь можно использовать как замену &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="930ffaae31f052ddd842b0cc0750e75bde4d30d4" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; instead.</source>
          <target state="translated">Эта версия строит свой вывод строго; для ленивой версии с тем же интерфейсом см. &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt; . Несмотря на то, что вывод построен строго, с помощью этого преобразователя невозможно добиться постоянного пространственного поведения: для этого используйте &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="c43334581b0313064f9793791ae64d3cd9cb11bb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта версия &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; более эффективна, потому что в ней отсутствует проверка того, что ввод-вывод выполняется только одним потоком. Следовательно, когда вы используете &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; , существует вероятность того, что действие ввода-вывода может выполняться несколько раз (на многопроцессоре), и поэтому вы должны убедиться, что он каждый раз дает одни и те же результаты. Может даже случиться так, что одно из дублированных действий ввода-вывода выполняется только частично, а затем прерывается посередине без возникновения исключения. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; нельзя безопасно использовать в &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04cd97504e7c7c2b93f2ad23f730e7e0477bfefc" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b59dda432be30bd0d16af2bacfdfe2d0f94c9cd" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта версия &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; более эффективна, потому что в ней отсутствует проверка того, что ввод-вывод выполняется только одним потоком. Следовательно, когда вы используете &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; , существует вероятность того, что действие ввода-вывода может выполняться несколько раз (на многопроцессоре), и поэтому вы должны убедиться, что он каждый раз дает одни и те же результаты. Может даже случиться так, что одно из дублированных действий ввода-вывода выполняется только частично, а затем прерывается посередине без возникновения исключения. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; нельзя безопасно использовать в &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f67494c6dd16fe58429c914e2600fd861b46bc50" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта версия &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; более эффективна, потому что в ней отсутствует проверка того, что ввод-вывод выполняется только одним потоком. Следовательно, когда вы используете &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; , существует вероятность того, что действие ввода-вывода может выполняться несколько раз (на многопроцессоре), и поэтому вы должны убедиться, что он каждый раз дает одни и те же результаты. Может даже случиться так, что одно из дублированных действий ввода-вывода выполняется только частично, а затем прерывается посередине без возникновения исключения. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; нельзя безопасно использовать в &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c8e6fa4d8cd33fa64562f0db26d801a347a4eb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эта версия &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; более эффективна, потому что в ней отсутствует проверка того, что ввод-вывод выполняется только одним потоком. Следовательно, когда вы используете &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; , существует вероятность того, что действие ввода-вывода может выполняться несколько раз (на многопроцессоре), и поэтому вы должны убедиться, что он каждый раз дает одни и те же результаты. Может даже случиться так, что одно из дублированных действий ввода-вывода выполняется только частично, а затем прерывается посередине без возникновения исключения. Следовательно, такие функции, как &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; нельзя безопасно использовать в &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4d88c16a70afcd9d0a8c3fb7463a254c46bdefe" translate="yes" xml:space="preserve">
          <source>This version requires going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, which can be inefficient. However, &lt;code&gt;toIntegralSized&lt;/code&gt; is optimized to allow GHC to statically determine the relative type sizes (as measured by &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt;) and avoid going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for many types. (The implementation uses &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is itself optimized with rules for &lt;code&gt;base&lt;/code&gt; types but may go through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for some type pairs.)</source>
          <target state="translated">Эта версия требует прохождения &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; , что может быть неэффективным. Однако &lt;code&gt;toIntegralSized&lt;/code&gt; оптимизирован, чтобы позволить GHC статически определять относительные размеры типов (измеряемые с помощью &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt; ) и избегать прохождения &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; для многих типов. (В реализации используется &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; , который сам оптимизирован с помощью правил для &lt;code&gt;base&lt;/code&gt; типов, но может проходить через &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; для некоторых пар типов.)</target>
        </trans-unit>
        <trans-unit id="1713051baed32864f550a4d0ea48ed3f725fb1d1" translate="yes" xml:space="preserve">
          <source>This warning allows to detect such uses of &lt;code&gt;*&lt;/code&gt; before the actual breaking change takes place. The recommended fix is to replace &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;Type&lt;/code&gt; imported from &lt;code&gt;Data.Kind&lt;/code&gt;.</source>
          <target state="translated">Это предупреждение позволяет обнаружить такое использование &lt;code&gt;*&lt;/code&gt; до того, как произойдет фактическое критическое изменение. Рекомендуемое исправление заменить &lt;code&gt;*&lt;/code&gt; с &lt;code&gt;Type&lt;/code&gt; импортирован из &lt;code&gt;Data.Kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8dcf8302d1086b7ab10e1c70ed396a42e5a77b9" translate="yes" xml:space="preserve">
          <source>This warning can be addressed by either adding an explicit import list or using a &lt;code&gt;qualified&lt;/code&gt; import.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b29ba7cfb3d2918f39c1441e99d9f4ce1287c2" translate="yes" xml:space="preserve">
          <source>This warning can be turned off with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wno-missing-methods&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Это предупреждение можно отключить с помощью флага &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wno-missing-methods&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f18c523e2627209783834547bda765478c64d4a5" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">Это предупреждение по умолчанию &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; режиме -Wall .</target>
        </trans-unit>
        <trans-unit id="72dcfecc8d5494d290ee1b21677961cb5175c2ed" translate="yes" xml:space="preserve">
          <source>This warning is off by default.</source>
          <target state="translated">Это предупреждение отключено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8e25d5e92b85c829fac2f9477e4538faeeb61aa6" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">По умолчанию это предупреждение отключено. Однако он является частью группы опций &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ab34268e22349a8e7d47871cb222ede5f058bf5" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wno-compat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f45b839bbf6248dce6eb6cd816c8aef78b200f" translate="yes" xml:space="preserve">
          <source>This warning is on by default.</source>
          <target state="translated">Это предупреждение включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="85a4aecbf183fdb5c42584066dc8c58f74eb0df7" translate="yes" xml:space="preserve">
          <source>This warning message:</source>
          <target state="translated">Это предупреждающее сообщение:</target>
        </trans-unit>
        <trans-unit id="f2d8282f3131ab448c2e8fe1cea01afde1138b09" translate="yes" xml:space="preserve">
          <source>This will be translated to:</source>
          <target state="translated">Это будет переведено:</target>
        </trans-unit>
        <trans-unit id="67139a4dd79ac7320ecf17b1941945dc01b22766" translate="yes" xml:space="preserve">
          <source>This will generate a derived instance for &lt;code&gt;(Foo [a])&lt;/code&gt; and &lt;code&gt;(Foo (Maybe a))&lt;/code&gt;, but other types such as &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; will not be an instance of &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">Это создаст производный экземпляр для &lt;code&gt;(Foo [a])&lt;/code&gt; и &lt;code&gt;(Foo (Maybe a))&lt;/code&gt; , но другие типы, такие как &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; , не будут экземпляром &lt;code&gt;Eq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f28dc06b16f7d92df21079a2ca982f57eeedb1" translate="yes" xml:space="preserve">
          <source>This will generate code to the effect of:</source>
          <target state="translated">В результате этого будет сгенерирован код:</target>
        </trans-unit>
        <trans-unit id="c07dbdd03a5f971eb5b11d111347c944fa4be0b3" translate="yes" xml:space="preserve">
          <source>This will generate the derived instance:</source>
          <target state="translated">Это сгенерирует производный экземпляр:</target>
        </trans-unit>
        <trans-unit id="bd17e4450ac723145ea38f572707911ae4592ad5" translate="yes" xml:space="preserve">
          <source>This will not actually evaluate &lt;code&gt;[|1|]&lt;/code&gt;, but instead replace it with the &lt;code&gt;0 :: Int&lt;/code&gt; literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9635805f734d6a6ddee1819b851b9ba1e60653" translate="yes" xml:space="preserve">
          <source>This will sometimes exit with &quot;interrupted&quot; and code 0, because the main thread is given a chance to shut down when the child thread calls safeExit. There is a race to shut down between the main and child threads.</source>
          <target state="translated">Иногда он завершает работу с &quot;прерванным&quot; и кодом 0,так как основной поток получает возможность завершить работу,когда дочерний поток вызывает safeExit.Существует гонка за закрытием между основным и дочерним потоками.</target>
        </trans-unit>
        <trans-unit id="e043ff52775ea24499678e808e45c2c181b6a4d7" translate="yes" xml:space="preserve">
          <source>This will take &lt;code&gt;1 + 1 + 3&lt;/code&gt; words (the &lt;code&gt;ThingId&lt;/code&gt; constructor + unpacked &lt;code&gt;Int&lt;/code&gt; + unpacked &lt;code&gt;ShortByteString&lt;/code&gt;), plus the words for the string data.</source>
          <target state="translated">Это займет &lt;code&gt;1 + 1 + 3&lt;/code&gt; слова ( конструктор &lt;code&gt;ThingId&lt;/code&gt; + распакованный &lt;code&gt;Int&lt;/code&gt; + распакованный &lt;code&gt;ShortByteString&lt;/code&gt; ) плюс слова для строковых данных.</target>
        </trans-unit>
        <trans-unit id="ffb0c676449de8bbdd669f772c381c5dd02a2d1b" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00447b8aa68db10f55c7e645117a8e9f6fffe839" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fc96ce3bb24d77dd77c6af32ec3bc111b921f5" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf6f8f26d3df6178377eb2f4bcb17017279b918" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa41044d20ae1ba84ba01e6410c48a361f0588d" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a6c139763138b599cb7bbf37ebd6c6563d7c63" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это вызовет &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; если дескриптор файла был закрыт, когда этот поток был заблокирован. Чтобы безопасно закрыть файловый дескриптор, который использовался с &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434dd08be079cc0bd5826173db52237398cf0bd7" translate="yes" xml:space="preserve">
          <source>This will yield a list containing every prefix of the word &amp;ldquo;hello&amp;rdquo; written out 5 times:</source>
          <target state="translated">В результате будет получен список, содержащий каждый префикс слова &amp;laquo;привет&amp;raquo;, записанный 5 раз:</target>
        </trans-unit>
        <trans-unit id="5b7edf0cfa8817128eb97357c0b339d3968afe03" translate="yes" xml:space="preserve">
          <source>This works even if the type of the expression is more general, provided it can be &lt;em&gt;instantiated&lt;/em&gt; to &lt;code&gt;IO a&lt;/code&gt;. For example</source>
          <target state="translated">Это работает, даже если тип выражения является более общим, при условии, что его можно &lt;em&gt;создать&lt;/em&gt; для &lt;code&gt;IO a&lt;/code&gt; . Например</target>
        </trans-unit>
        <trans-unit id="8a8c5448116287ce4d1ddb842a2e4bddd7bd26ff" translate="yes" xml:space="preserve">
          <source>This would generate the following instances:</source>
          <target state="translated">Это могло бы привести к следующим случаям:</target>
        </trans-unit>
        <trans-unit id="cb8b2e3b821f17047f04dce70c983fcb5b75e25f" translate="yes" xml:space="preserve">
          <source>Thread stacks (including the main thread&amp;rsquo;s stack) live on the heap. As the stack grows, new stack chunks are added as required; if the stack shrinks again, these extra stack chunks are reclaimed by the garbage collector. The default initial stack size is deliberately small, in order to keep the time and space overhead for thread creation to a minimum, and to make it practical to spawn threads for even tiny pieces of work.</source>
          <target state="translated">Стеки потоков (включая стек основного потока) находятся в куче. По мере роста стека по мере необходимости добавляются новые блоки стека; если стек снова сжимается, эти лишние фрагменты стека возвращаются сборщиком мусора. Начальный размер стека по умолчанию намеренно мал, чтобы свести к минимуму время и пространство для создания потока и сделать практичным создание потоков даже для крошечных частей работы.</target>
        </trans-unit>
        <trans-unit id="afb01736a569cf800957c75c764e7b08e4d42882" translate="yes" xml:space="preserve">
          <source>ThreadDied</source>
          <target state="translated">ThreadDied</target>
        </trans-unit>
        <trans-unit id="b5249abe5125d8129b1f6094e27ca24e5dfd7b53" translate="yes" xml:space="preserve">
          <source>ThreadFinished</source>
          <target state="translated">ThreadFinished</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="cbacd9f0811868fee2692211c0f50253994d843c" translate="yes" xml:space="preserve">
          <source>ThreadId#</source>
          <target state="translated">ThreadId#</target>
        </trans-unit>
        <trans-unit id="210277f1f5be789fa38d99bf66d700f891a72b7b" translate="yes" xml:space="preserve">
          <source>ThreadKilled</source>
          <target state="translated">ThreadKilled</target>
        </trans-unit>
        <trans-unit id="1aacc5025242586267973269d42242e70a03c918" translate="yes" xml:space="preserve">
          <source>ThreadRunning</source>
          <target state="translated">ThreadRunning</target>
        </trans-unit>
        <trans-unit id="03539ff112c319a9993d65dc00b7fc1e80ba7832" translate="yes" xml:space="preserve">
          <source>ThreadStatus</source>
          <target state="translated">ThreadStatus</target>
        </trans-unit>
        <trans-unit id="c415b82d91d35c84fcc4655fc993abc0a3ab34c8" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Потоки, созданные &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; , наследуют &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; от родителя; то есть, чтобы начать нить в &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; состоянии, использование &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . Это особенно полезно, если вам нужно установить обработчик исключений в разветвленном потоке до получения любых асинхронных исключений. Чтобы создать новый поток в немаскированном состоянии, используйте &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca92e3299d152bebbdb5564f0db2b030aafcd93c" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a5f845685a6adcb61487ea721a7c03d396057a" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Потоки, созданные &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; , наследуют &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; от родителя; то есть, чтобы начать нить в &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; состоянии, использование &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . Это особенно полезно, если вам нужно установить обработчик исключений в разветвленном потоке до получения любых асинхронных исключений. Чтобы создать новый поток в немаскированном состоянии, используйте &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ddbb9a27e7d4b8d61317f07ad835b30faeee84" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Потоки, созданные &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; , наследуют &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; от родителя; то есть, чтобы начать нить в &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; состоянии, использование &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; . Это особенно полезно, если вам нужно установить обработчик исключений в разветвленном потоке до получения любых асинхронных исключений. Чтобы создать новый поток в немаскированном состоянии, используйте &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581562d7fdd77f3436334b5a7259e674b4960049" translate="yes" xml:space="preserve">
          <source>Threads with affinity</source>
          <target state="translated">Нитки с родственными связями</target>
        </trans-unit>
        <trans-unit id="1831f9d9a0a484604033e790590c1ca2132ad8fe" translate="yes" xml:space="preserve">
          <source>Three handles are allocated during program initialisation, and are initially open.</source>
          <target state="translated">При инициализации программы выделяются три ручки,которые изначально открываются.</target>
        </trans-unit>
        <trans-unit id="3cfb69dc1eee67ef7ef938e002c1dcccfc372df6" translate="yes" xml:space="preserve">
          <source>Three kinds of buffering are supported: line-buffering, block-buffering or no-buffering. These modes have the following effects. For output, items are written out, or &lt;em&gt;flushed&lt;/em&gt;, from the internal buffer according to the buffer mode:</source>
          <target state="translated">Поддерживаются три вида буферизации: буферизация строк, блочная буферизация или отсутствие буферизации. Эти режимы имеют следующие эффекты. Для вывода элементы записываются или &lt;em&gt;сбрасываются&lt;/em&gt; из внутреннего буфера в соответствии с режимом буфера:</target>
        </trans-unit>
        <trans-unit id="67de4025637fbb0de0ee6f5d57e06c1db2d37ad2" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if decoding fails.</source>
          <target state="translated">Бросьте &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; , если декодирование не удается.</target>
        </trans-unit>
        <trans-unit id="530bb7b54f06bf2237068556f8b41935da4566c0" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if encoding fails.</source>
          <target state="translated">Бросьте &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; , если кодирование не удается.</target>
        </trans-unit>
        <trans-unit id="a88939f2bc16a79d5911956081588d78806af274" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действие возвращается &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86385b37440a2c4d1929356fdf6fd642b72d158" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653f6b091b3b56dbab455fefe64b2589e61e727" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, but retry in case of an interrupted operation.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действие возвращает &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; , но повторить попытку в случае прерывания операции.</target>
        </trans-unit>
        <trans-unit id="34d7cc6341315d979ebf0a280e2812fcea684005" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действие возвращается &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79cea3439c030b18b5417d5220cf8e7402498869" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;, but retries in case of an interrupted operation.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действие возвращает результат &lt;code&gt;-1&lt;/code&gt; , но повторные попытки в случае прерывания операции.</target>
        </trans-unit>
        <trans-unit id="4caf9e3403704122998dcd2e56f9c103bccc209c" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действие возвращает результат &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="036abf121e52aab2f60490c26b79ff2ead7c1e41" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the result value of the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action meets the given predicate.</source>
          <target state="translated">Сгенерировано &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущее значение &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; , если значение результата &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; действия соответствует данному предикату.</target>
        </trans-unit>
        <trans-unit id="64aa8ce5d4c7d3f7f49e076896c60b8c7ef43c89" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Бросок &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; , соответствующий текущему значению &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a07ee5048c29ff28ddf4e5f424d1fa111508ece" translate="yes" xml:space="preserve">
          <source>Throw an error when an illegal sequence is encountered</source>
          <target state="translated">Бросить ошибку при обнаружении незаконной последовательности</target>
        </trans-unit>
        <trans-unit id="4479756108b443a98b7354d085dbc835dc21aeb8" translate="yes" xml:space="preserve">
          <source>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">Выбросить исключение. Исключения могут возникать из чисто функционального кода, но могут быть перехвачены только внутри монады &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="355438224b8f7cd13662d722c3e953c3cab93377" translate="yes" xml:space="preserve">
          <source>Throw an exception. Note that this throws when this action is run in the monad &lt;code&gt;m&lt;/code&gt;, not when it is applied. It is a generalization of &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe9dd6f4bbcbd9abdc92b3911d6713b369a19e14" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">Вызов исключения в &lt;code&gt;STM&lt;/code&gt; прерывает транзакцию и распространяет исключение. Если исключение &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; помощью catchSTM , откатываются только изменения, заключенные в перехвате; изменения, сделанные вне &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; , сохраняются.</target>
        </trans-unit>
        <trans-unit id="2e15244ee40229604b0e667942ba71e6efbddfe9" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">Вызов исключения в &lt;code&gt;STM&lt;/code&gt; прерывает транзакцию и распространяет исключение. Если исключение &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; помощью catchSTM , откатываются только изменения, заключенные в перехвате; изменения, сделанные вне &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; , сохраняются.</target>
        </trans-unit>
        <trans-unit id="62d516dc1db40b86d1546ce065ac2b133fff005a" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">Вызов исключения в &lt;code&gt;STM&lt;/code&gt; прерывает транзакцию и распространяет исключение. Если исключение &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; помощью catchSTM , откатываются только изменения, заключенные в перехвате; изменения, сделанные вне &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; , сохраняются.</target>
        </trans-unit>
        <trans-unit id="3c57924c9d0ac14d868ac4b1686bc50ff51630e3" translate="yes" xml:space="preserve">
          <source>Throwing and catching I/O errors</source>
          <target state="translated">Бросок и перехват ошибок ввода/вывода</target>
        </trans-unit>
        <trans-unit id="7506d1dc91f2739ca014aacfd180c12f7a3cf7ce" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="translated">Выбрасывание исключений</target>
        </trans-unit>
        <trans-unit id="7f06faf78ca599a5c5c8ba7a35902fe72d473ba2" translate="yes" xml:space="preserve">
          <source>Thrown when the program attempts to call &lt;code&gt;atomically&lt;/code&gt;, from the &lt;code&gt;stm&lt;/code&gt; package, inside another call to &lt;code&gt;atomically&lt;/code&gt;.</source>
          <target state="translated">Вызывается, когда программа пытается вызвать &lt;code&gt;atomically&lt;/code&gt; из пакета &lt;code&gt;stm&lt;/code&gt; внутри другого вызова для &lt;code&gt;atomically&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="153488b4e16cb9e06414f6864aee37a111104fae" translate="yes" xml:space="preserve">
          <source>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</source>
          <target state="translated">Выбрасывается,когда исполнительная система обнаруживает,что вычисления гарантированно не завершатся.Обратите внимание,что нет гарантии,что исполнительная система заметит,гарантированно ли завершение какого-либо вычисления.</target>
        </trans-unit>
        <trans-unit id="e18cad06fc314dbe98850c48826dae1e000f1a31" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &amp;laquo;Недопустимая операция&amp;raquo;) , если платформа не обеспечивает &lt;code&gt;ctermid(3)&lt;/code&gt; (используйте &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP охранника для обнаружения наличия).</target>
        </trans-unit>
        <trans-unit id="63e549a9e7a930bc1cd82834decb9a2bd163ce62" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&amp;laquo;неподдерживаемая операция&amp;raquo;), если платформа не предоставляет &lt;code&gt;fdatasync(2)&lt;/code&gt; (используйте &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard для определения доступности).</target>
        </trans-unit>
        <trans-unit id="b4fc88eb1e2da00b43f2c50a60cc44995e0823b9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&amp;laquo;неподдерживаемая операция&amp;raquo;), если платформа не предоставляет &lt;code&gt;fsync(2)&lt;/code&gt; (используйте &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard для определения доступности).</target>
        </trans-unit>
        <trans-unit id="a9d629909206eee0dbcf9f3ef3c94be04cfef1d6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &amp;laquo;Недопустимая операция&amp;raquo;) , если платформа не обеспечивает &lt;code&gt;posix_fallocate(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e500df7fdd7f0b1291a3902735fde41700da58" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ( &amp;laquo;Недопустимая операция&amp;raquo;) , если платформа не обеспечивает &lt;code&gt;tcdrain(3)&lt;/code&gt; (используйте &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP охранника для обнаружения наличия).</target>
        </trans-unit>
        <trans-unit id="9e328518c0ae7f5df305277a12db24a54f0d6efe" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41ac56fe434c624b1c17bcefea186ed1bdc1b6f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e26076fb50ee8c52870cfd73b0440602f666fd" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e34fcbe929eb8dbb817a0cb66109a820af381c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec30f6587d00e8236ddbc556fd0ce8c29324a9f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da37849b4252a8c8814bc0fdc57bbfa1e662b4c6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; when the channel is empty and no other thread holds a reference to the channel.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; , когда канал пуст и никакой другой поток не содержит ссылку на канал.</target>
        </trans-unit>
        <trans-unit id="26e7a0586580fb90b1858fbd0f15fd38c47f7010" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is the empty string or contains an equals sign.</source>
          <target state="translated">Выбрасывает &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;name&lt;/code&gt; является пустой строкой или содержит знак равенства.</target>
        </trans-unit>
        <trans-unit id="88ad0dcfc452814fa2ec2a379a00e78d0cb0ada8" translate="yes" xml:space="preserve">
          <source>Throws a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; if the terminfo database could not be read.</source>
          <target state="translated">Выдает &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; если не удалось прочитать базу данных terminfo.</target>
        </trans-unit>
        <trans-unit id="dc4f4955b1364895c982cfed4f338a952c52b050" translate="yes" xml:space="preserve">
          <source>Throws exceptions into the base monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="cef8354a2187206dae84b0978cfa2cac783fc184" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Таким образом, &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; содержат как минимум столько же элементов, сколько новые строки в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f4111a9574afc73ad4fb9aa2d80eb12106046f" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Таким образом, &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; содержат как минимум столько же элементов, сколько новые строки в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20ffe6f7fbe373d959e03833b11abe8e7b589cd" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Таким образом, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; содержат как минимум столько же элементов, сколько новые строки в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7038c652bd8ef014d4a0872642e6726ba19bc5" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Таким образом, &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; содержат как минимум столько же элементов, сколько новые строки в &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e24cd4910ef566d3177761fb96a3a2e10793cb" translate="yes" xml:space="preserve">
          <source>Thus rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">Таким образом, правило применяется и к объявлениям типов данных. Например, если у нас есть &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (и включен &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ), тогда &lt;code&gt;a&lt;/code&gt; будет присвоен вид &lt;code&gt;k&lt;/code&gt; , где &lt;code&gt;k&lt;/code&gt; - это новая переменная вида. Поскольку &lt;code&gt;k&lt;/code&gt; не был записан пользователем, он будет недоступен для типа application в типе конструктора &lt;code&gt;Proxy&lt;/code&gt; ; будет доступен только &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1b4b67a9b45e5176c700a1accff9ef1d36429d" translate="yes" xml:space="preserve">
          <source>Thus, a common invocation would be:</source>
          <target state="translated">Таким образом,общим вызовом было бы:</target>
        </trans-unit>
        <trans-unit id="10617fc5bcf1b09fbc9f71f965511f582f11805a" translate="yes" xml:space="preserve">
          <source>Thus, if we call &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; we will get a formatted call-stack alongside our string.</source>
          <target state="translated">Таким образом, если мы вызовем &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; , мы получим отформатированный стек вызовов вместе с нашей строкой.</target>
        </trans-unit>
        <trans-unit id="e5c7ac32fac38f64112fb32061b44ba48e48877f" translate="yes" xml:space="preserve">
          <source>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use &lt;code&gt;App&lt;/code&gt; at a variety of kinds:</source>
          <target state="translated">Таким образом, главное преимущество полиморфизма видов заключается в том, что теперь мы можем вывести эти самые общие виды и использовать &lt;code&gt;App&lt;/code&gt; в различных видах:</target>
        </trans-unit>
        <trans-unit id="78f6be9afb4189596518c56574c13c30720db0d1" translate="yes" xml:space="preserve">
          <source>Thus, the instance triggers only when the implicit parameter to &lt;code&gt;UnEx&lt;/code&gt; matches the implicit parameter to &lt;code&gt;MkEx&lt;/code&gt;. Because &lt;code&gt;k&lt;/code&gt; is actually a parameter to &lt;code&gt;UnEx&lt;/code&gt;, the kind is not escaping the existential, and the above code is valid.</source>
          <target state="translated">Таким образом, экземпляр запускается только тогда, когда неявный параметр &lt;code&gt;UnEx&lt;/code&gt; совпадает с неявным параметром &lt;code&gt;MkEx&lt;/code&gt; . Поскольку &lt;code&gt;k&lt;/code&gt; на самом деле является параметром &lt;code&gt;UnEx&lt;/code&gt; , вид не ускользает от экзистенциального, и приведенный выше код действителен.</target>
        </trans-unit>
        <trans-unit id="96728018a51a18d78a6c7c7a21bb29d195c725bd" translate="yes" xml:space="preserve">
          <source>TickyFlags</source>
          <target state="translated">TickyFlags</target>
        </trans-unit>
        <trans-unit id="e426b9f760c1a38c2bacbad2f64c53212cc3ffbf" translate="yes" xml:space="preserve">
          <source>Time as measured by the Earth.</source>
          <target state="translated">Время,измеренное Землей.</target>
        </trans-unit>
        <trans-unit id="de35e180cbf98fcc51757a7d0eeb7aa8703d0daf" translate="yes" xml:space="preserve">
          <source>Time locale.</source>
          <target state="translated">Локальное время.</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">Время суток</target>
        </trans-unit>
        <trans-unit id="311ad74f1246fe76fb5e13a02593b243dfa01e4b" translate="yes" xml:space="preserve">
          <source>Time of day as represented in hour, minute and second (with picoseconds), typically used to express local time of day.</source>
          <target state="translated">Время суток в том виде,в каком оно представлено в часах,минутах и секундах (с пикосекундами),обычно используется для выражения местного времени суток.</target>
        </trans-unit>
        <trans-unit id="674eca31894fe11111cc9e95a912f546b20cfa4c" translate="yes" xml:space="preserve">
          <source>Time of last access in sub-second resolution.</source>
          <target state="translated">Время последнего доступа в субсекундной резолюции.</target>
        </trans-unit>
        <trans-unit id="bf5b7ea4cfe40f929342452c57b6445e307ff98f" translate="yes" xml:space="preserve">
          <source>Time of last access.</source>
          <target state="translated">Время последнего доступа.</target>
        </trans-unit>
        <trans-unit id="dd0e25f4fa1eea55d5c7dc261f690719e80e92b5" translate="yes" xml:space="preserve">
          <source>Time of last modification in sub-second resolution.</source>
          <target state="translated">Время последней модификации субсекундной резолюции.</target>
        </trans-unit>
        <trans-unit id="d3ed1832d868c8126249a2fb407fc69507dfb189" translate="yes" xml:space="preserve">
          <source>Time of last modification.</source>
          <target state="translated">Время последней модификации.</target>
        </trans-unit>
        <trans-unit id="8a1b24f9546d48f74a1fc1f2be79cc16e32ce4b8" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.) in sub-second resolution.</source>
          <target state="translated">Время последнего изменения статуса (т.е.владелец,группа,счетчик ссылок,режим и т.д.)в субсекундном разрешении.</target>
        </trans-unit>
        <trans-unit id="de40af977c44da7ce142082cfbcc26c6ffe0cb65" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.).</source>
          <target state="translated">Время последнего изменения статуса (т.е.владелец,группа,счетчик ссылок,режим и т.д.).</target>
        </trans-unit>
        <trans-unit id="37cc2e4553f3b7c4572077f6ce8dcd7260d2fd48" translate="yes" xml:space="preserve">
          <source>Time values from the RTS, using a fixed resolution of nanoseconds.</source>
          <target state="translated">Временные значения из РТС,с использованием фиксированного разрешения в наносекундах.</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">Временные зоны</target>
        </trans-unit>
        <trans-unit id="3694fd8d8502573c050c12c21dfc64202808f47a" translate="yes" xml:space="preserve">
          <source>TimeExpired</source>
          <target state="translated">TimeExpired</target>
        </trans-unit>
        <trans-unit id="54ca8d2ae2173c38ac3276efe44835c04bf7b464" translate="yes" xml:space="preserve">
          <source>TimeLocale</source>
          <target state="translated">TimeLocale</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="a4208dd784207f8d84ef4fa31bd30bdd2b432c1d" translate="yes" xml:space="preserve">
          <source>TimeZone</source>
          <target state="translated">TimeZone</target>
        </trans-unit>
        <trans-unit id="30a4ddc2d1e47c72524d2ae1195d49334429ec48" translate="yes" xml:space="preserve">
          <source>TimeoutCallback</source>
          <target state="translated">TimeoutCallback</target>
        </trans-unit>
        <trans-unit id="03a9149686779469a820b3f21f5f3096edd2e773" translate="yes" xml:space="preserve">
          <source>TimeoutKey</source>
          <target state="translated">TimeoutKey</target>
        </trans-unit>
        <trans-unit id="554c6dbe0800fb90ce862ee9b17611f1be40e742" translate="yes" xml:space="preserve">
          <source>TimerManager</source>
          <target state="translated">TimerManager</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e0f0bc7f2e5196ca0e12562d2fea3c45abb35a55" translate="yes" xml:space="preserve">
          <source>TitlecaseLetter</source>
          <target state="translated">TitlecaseLetter</target>
        </trans-unit>
        <trans-unit id="2234a4a2c47c8ff0b64637496c3e6c3bfefcacba" translate="yes" xml:space="preserve">
          <source>Tix</source>
          <target state="translated">Tix</target>
        </trans-unit>
        <trans-unit id="a74eb4584cb5c18ee809ed00eb188fdec5bb579c" translate="yes" xml:space="preserve">
          <source>TixModule</source>
          <target state="translated">TixModule</target>
        </trans-unit>
        <trans-unit id="fe0563e640d1279bce1fac48bf8a1b5e02bcb7ab" translate="yes" xml:space="preserve">
          <source>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like &lt;code&gt;pthread_create&lt;/code&gt; or &lt;code&gt;CreateThread&lt;/code&gt;.</source>
          <target state="translated">Для сторонней библиотеки связанный поток будет выглядеть точно так же, как поток обычной операционной системы, созданный с использованием функций ОС, таких как &lt;code&gt;pthread_create&lt;/code&gt; или &lt;code&gt;CreateThread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff80debaf5b64e3919c264f8e4e883f22ace9ad9" translate="yes" xml:space="preserve">
          <source>To abandon the current evaluation, use &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt;&lt;code&gt;:abandon&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы отказаться от текущей оценки, используйте &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt; &lt;code&gt;:abandon&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d87be1eb54b07a48c8e89e1267bd4da7830b639e" translate="yes" xml:space="preserve">
          <source>To accumulate a value without using it on the way, see &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;.</source>
          <target state="translated">Чтобы накапливать значение, не используя его в пути, см. &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e5f8467c41adb6b14b429081219eab2c60a0901" translate="yes" xml:space="preserve">
          <source>To achieve these properties, in the safe language dialect we disable completely the following features:</source>
          <target state="translated">Для достижения этих свойств на безопасном диалекте языка мы полностью отключаем следующие функции:</target>
        </trans-unit>
        <trans-unit id="2aa92551218d14a1f44f24fb7177ce7a2bf713bc" translate="yes" xml:space="preserve">
          <source>To add modules to the scope, use ordinary Haskell &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">Чтобы добавить модули в область видимости, используйте обычный синтаксис &lt;code&gt;import&lt;/code&gt; Haskell :</target>
        </trans-unit>
        <trans-unit id="e2f3886d316e1e619156706746a8dfbb48e79115" translate="yes" xml:space="preserve">
          <source>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in &lt;code&gt;:{&lt;/code&gt; and &lt;code&gt;:}&lt;/code&gt; (each on a single line of its own):</source>
          <target state="translated">Чтобы решить эту проблему, команды GHCi можно разделить на несколько строк, заключив их в &lt;code&gt;:{&lt;/code&gt; и &lt;code&gt;:}&lt;/code&gt; (каждая в отдельной строке):</target>
        </trans-unit>
        <trans-unit id="de30b4286a2929bfdff88d5ee52a322ecb634497" translate="yes" xml:space="preserve">
          <source>To allow for such an instance, we would have to define &lt;code&gt;(:~~:)&lt;/code&gt; as follows:</source>
          <target state="translated">Чтобы разрешить такой экземпляр, нам нужно определить &lt;code&gt;(:~~:)&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="14c677f99c3ebfb083d5ba45347b3df00c07e009" translate="yes" xml:space="preserve">
          <source>To also set the directory in which to run &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">Чтобы также установить каталог, в котором будет запускаться &lt;code&gt;ls&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4ef0b5766dccbebaac045d8e4e6bded46db835a3" translate="yes" xml:space="preserve">
          <source>To always compile everything to object code and never use the interpreter, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;#ghci-obj&quot;&gt;Compiling to object code inside GHCi&lt;/a&gt;).</source>
          <target state="translated">Чтобы всегда компилировать все в объектный код и никогда не использовать интерпретатор, используйте параметр &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#ghci-obj&quot;&gt;Компиляция в объектный код внутри GHCi&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5df8df6d3cdb1b8cf45eb7ff8b8e9438a9330317" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Чтобы избежать дублирования между видами и типами, они определены как одинаковые. Естественно, у вас никогда не будет типа &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; и никогда не будет типа &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; , но многие другие конструкторы являются общими. Обратите внимание, что тип &lt;code&gt;Bool&lt;/code&gt; обозначается &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . Точно так же виды кортежей создаются с помощью &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bbefb7d7331de5a028c9b6fdc70e6d980c4f650" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Чтобы избежать дублирования между видами и типами, они определены как одинаковые. Естественно, у вас никогда не будет типа &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; и никогда не будет типа &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; , но многие другие конструкторы являются общими. Обратите внимание, что тип &lt;code&gt;Bool&lt;/code&gt; обозначается &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; . Точно так же виды кортежей создаются с помощью &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; , а не &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6771efdf3a686f294db18bd2d14bac4e3dba651" translate="yes" xml:space="preserve">
          <source>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: &lt;code&gt;-ohi /dev/null&lt;/code&gt;, for example.</source>
          <target state="translated">Чтобы вообще не создавать интерфейс, вы можете использовать этот параметр для перенаправления интерфейса в битовое ведро: например, &lt;code&gt;-ohi /dev/null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aaccb0bd8d229ee1d19d9e75f8795d4cf2370af" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">Чтобы избежать тонких ошибок кодирования, в написанном от руки коде маршаллинга предпочтительно использовать &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; , а не комбинации &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . Однако в коде маршаллинга, генерируемом инструментами, иногда предпочтительнее использовать последние процедуры.</target>
        </trans-unit>
        <trans-unit id="fa34733b5e19e7e6a87e5c91b392ff0b0780aa0b" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">Чтобы избежать тонких ошибок кодирования, в написанном от руки коде маршаллинга предпочтительно использовать &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; , а не комбинации &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; . Однако в коде маршаллинга, генерируемом инструментами, иногда предпочтительнее использовать последние процедуры.</target>
        </trans-unit>
        <trans-unit id="b35e7282d157dcf47660cd59431c4a8fca882cba" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Чтобы избежать этой проблемы, используйте вместо этого &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93dbcc0e48dafb4a864c6c8fc82578cf9d42f26f" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Чтобы избежать этой проблемы, используйте вместо этого &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d32eef552977a76650b6db7fd84bb68cb4c9bdee" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;&lt;a href=&quot;ghc-exts#v:resizeSmallMutableArray-35-&quot;&gt;resizeSmallMutableArray#&lt;/a&gt;&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; in case a new &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SmallMutableArray-35-&quot;&gt;SmallMutableArray#&lt;/a&gt;&lt;/code&gt; had to be allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c0704d5dd80ea4a49e31c8c21b3410ffa34f67" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;MutableByteArray#&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;MutableByteArray#&lt;/code&gt; in case a new &lt;code&gt;MutableByteArray#&lt;/code&gt; had to be allocated.</source>
          <target state="translated">Чтобы избежать неопределенного поведения, к исходному &lt;code&gt;MutableByteArray#&lt;/code&gt; больше нельзя обращаться после выполнения &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; . Более того, не следует &lt;code&gt;MutableByteArray#&lt;/code&gt; никаких ссылок на старую, чтобы разрешить сборку мусора исходного MutableByteArray # в случае, если необходимо &lt;code&gt;MutableByteArray#&lt;/code&gt; новый MutableByteArray # .</target>
        </trans-unit>
        <trans-unit id="d1d67bfc1538ab33d21305009ebcc630714c1858" translate="yes" xml:space="preserve">
          <source>To be precise, if the class being derived is of the form</source>
          <target state="translated">Если быть точным,то если получаемый класс имеет форму</target>
        </trans-unit>
        <trans-unit id="c0d9f8d6315eb7cbdcbf50a9f874b3aee61aa5d5" translate="yes" xml:space="preserve">
          <source>To be precise, the annotation &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; is well staged if and only if &lt;code&gt;$(e)&lt;/code&gt; would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - &lt;code&gt;$([|1|])&lt;/code&gt; is fine as an annotation, albeit redundant).</source>
          <target state="translated">Чтобы быть точным, аннотация &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; хорошо организована тогда и только тогда, когда &lt;code&gt;$(e)&lt;/code&gt; будет (игнорируя обычные ограничения на типы синтаксиса соединения и обычное ограничение на соединение внутри соединения - &lt;code&gt;$([|1|])&lt;/code&gt; можно использовать как аннотацию, хотя и избыточно).</target>
        </trans-unit>
        <trans-unit id="28876308b2232e888282a46a9f2647185f20da23" translate="yes" xml:space="preserve">
          <source>To build Haskell modules that export a C API into a shared library use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">Чтобы построить модули Haskell, которые экспортируют C API в общую библиотеку, используйте &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="99edfbf2248bb2a627dfdcc360ffdb881b08cb4d" translate="yes" xml:space="preserve">
          <source>To build a simple program and have it use shared libraries for the runtime system and the base libraries use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">Чтобы создать простую программу и использовать общие библиотеки для системы времени выполнения, а базовые библиотеки используйте флаг &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="007ba52a2d8fb965e0b5df4e486442e39607c309" translate="yes" xml:space="preserve">
          <source>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">Чтобы связать синоним шаблона с конструктором типа, мы перечисляем синоним шаблона в списке экспорта модуля, который экспортирует конструктор типа. Например, чтобы связать &lt;code&gt;Zero&lt;/code&gt; с &lt;code&gt;MyNum&lt;/code&gt; , мы могли бы написать следующее:</target>
        </trans-unit>
        <trans-unit id="b5aae458adadd6ea36810e5833a7811c73bd6831" translate="yes" xml:space="preserve">
          <source>To check whether your &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; setting is doing the right thing, &lt;code&gt;ghc-pkg list&lt;/code&gt; will list all the databases in use, in the reverse order they are searched.</source>
          <target state="translated">Чтобы проверить, правильно ли работает ваш параметр &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ,в &lt;code&gt;ghc-pkg list&lt;/code&gt; будут перечислены все используемые базы данных в порядке, обратном их поиску.</target>
        </trans-unit>
        <trans-unit id="d99b230674f283901189e80464c11bff12827985" translate="yes" xml:space="preserve">
          <source>To compile a module which is to be part of a new package, use the &lt;code&gt;-package-name&lt;/code&gt; (to identify the name of the package) and &lt;code&gt;-library-name&lt;/code&gt; (to identify the version and the version hashes of its identities.) options (&lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the &lt;code&gt;.hi&lt;/code&gt; file.</source>
          <target state="translated">Чтобы скомпилировать модуль, который должен быть частью нового пакета, используйте &lt;code&gt;-package-name&lt;/code&gt; (для определения имени пакета) и &lt;code&gt;-library-name&lt;/code&gt; (для определения версии и хэшей версий его идентификаторов.) Options ( &lt;a href=&quot;#using-packages&quot;&gt;Использование пакетов&lt;/a&gt; ). Отказ от использования этих параметров при компиляции пакета, вероятно, приведет к сбою, но вы обнаружите это позже, только когда попытаетесь импортировать модули из пакета. На этом этапе GHC будет жаловаться на то, что имя пакета, которое он ожидал от модуля, не совпадает с именем пакета, хранящимся в файле &lt;code&gt;.hi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12fd6ddf28c5285fa1983ff47d370bb4e33b05da" translate="yes" xml:space="preserve">
          <source>To compile the program, use GHC like this:</source>
          <target state="translated">Чтобы скомпилировать программу,используйте GHC вот так:</target>
        </trans-unit>
        <trans-unit id="485c5e401e6a134f4abe73897df6824e3409a20e" translate="yes" xml:space="preserve">
          <source>To compile these three files, issue the following commands:</source>
          <target state="translated">Чтобы скомпилировать эти три файла,выполните следующие команды:</target>
        </trans-unit>
        <trans-unit id="8a91e9bb879d47c785fc61c253926f7398d2eae9" translate="yes" xml:space="preserve">
          <source>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword. The pragma may be one of: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt;, or &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt;.</source>
          <target state="translated">Чтобы контролировать выбор экземпляра, можно указать поведение перекрытия для отдельных экземпляров с помощью прагмы, написанной сразу после ключевого слова &lt;code&gt;instance&lt;/code&gt; . Прагма может быть одной из: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt; , &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt; или &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc0d1e2f710041d917fa9128128d16f4e0b579c" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt;, use the following:</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; , используйте следующее:</target>
        </trans-unit>
        <trans-unit id="1c0964746ae7b2a2f00992a848001548495aecef" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">Чтобы преобразовать значения &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; в соответствующие функции Haskell, можно определить &lt;em&gt;динамическую&lt;/em&gt; заглушку для конкретного внешнего типа, например</target>
        </trans-unit>
        <trans-unit id="5d067decf6925ff18738730cccec299d546abf35" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">Чтобы преобразовать значения &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; в соответствующие функции Haskell, можно определить &lt;em&gt;динамическую&lt;/em&gt; заглушку для конкретного внешнего типа, например</target>
        </trans-unit>
        <trans-unit id="fea7f792e37393718cca4a9b6921cb08aba10fa5" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">Чтобы преобразовать значения &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; в соответствующие функции Haskell, можно определить &lt;em&gt;динамическую&lt;/em&gt; заглушку для конкретного внешнего типа, например</target>
        </trans-unit>
        <trans-unit id="2acaa5dea000cc74154c0f402c3febbfb83f1a58" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; в соответствующее значение &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , определенное Unicode, или из него , используйте &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; из класса &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; соответственно (или эквивалентно &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="786657e4c88a725db3968f98b13dce85d65db23b" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; в соответствующее значение &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , определенное Unicode, или из него , используйте &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; из класса &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; соответственно (или эквивалентно &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7130a3be670709f03cd81a58cb2b61282e0d6dd" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; в соответствующее значение &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , определенное Unicode, или из него , используйте &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; из класса &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; соответственно (или эквивалентно &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="13a465a9773b015ffc884872ada910d6f797abb7" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для преобразования из &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; используйте &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e3196791a7a1592e7daa80285f0558ede2e0d6d" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1659f84a77c9a2443a59423cc658f61a338f3abe" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для того, чтобы создать &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; без кодирования на всех, используйте &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; . Для того, чтобы остановить дальнейшее кодирование или декодирование на существующую &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; , использовать &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f153e244215130d9c4edb53cdcbba15630d42840" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для того, чтобы создать &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; без кодирования на всех, используйте &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; . Для того, чтобы остановить дальнейшее кодирование или декодирование на существующую &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; , использовать &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1171deb859f0f29f6aacadc46ea52378fb28f5f8" translate="yes" xml:space="preserve">
          <source>To create a pipe from which to read the output of &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">Чтобы создать канал, из которого будет считываться вывод &lt;code&gt;ls&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="96af4537bfd12fadb83763899a123cc096a36017" translate="yes" xml:space="preserve">
          <source>To define the &lt;code&gt;item&lt;/code&gt; parser, we need to lift the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; operations through the &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer.</source>
          <target state="translated">Для определения &lt;code&gt;item&lt;/code&gt; анализатора нам нужно поднять &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; операции через &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; трансформатора.</target>
        </trans-unit>
        <trans-unit id="61b1e6de56b01e5140d8cba3ed36c3acb9b257dc" translate="yes" xml:space="preserve">
          <source>To delete a breakpoint, use the &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt;&lt;code&gt;:delete&lt;/code&gt;&lt;/a&gt; command with the number given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы удалить точку останова, используйте команду &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt; &lt;code&gt;:delete&lt;/code&gt; &lt;/a&gt; с номером, указанным в выходных данных &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ea8e294886bade8bd7cc5b83aa9ec115d1403bbc" translate="yes" xml:space="preserve">
          <source>To delete all breakpoints at once, use &lt;code&gt;:delete *&lt;/code&gt;.</source>
          <target state="translated">Чтобы удалить сразу все точки останова, используйте &lt;code&gt;:delete *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20c69ea8d7a8119ee63218b8c507949aacadde61" translate="yes" xml:space="preserve">
          <source>To derive &lt;code&gt;Eq&lt;/code&gt; in the standard way we would need to have equality between the single component of two &lt;code&gt;MkT&lt;/code&gt; constructors:</source>
          <target state="translated">Чтобы вывести &lt;code&gt;Eq&lt;/code&gt; стандартным способом, нам потребуется равенство между одним компонентом двух конструкторов &lt;code&gt;MkT&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f0219713c4b957a1c6e5e311515abfddd97e7be" translate="yes" xml:space="preserve">
          <source>To disable one or several defined breakpoint, use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command with one or several blank separated numbers given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:. To disable all breakpoints at once, use &lt;code&gt;:disable *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be5e62141d987ac491830af48130b4bb8a0121e" translate="yes" xml:space="preserve">
          <source>To examine one of the steps in the history, use &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Чтобы просмотреть один из шагов в истории, используйте &lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66eef0e4ec6c04a45dd59938c23022bba82ff967" translate="yes" xml:space="preserve">
          <source>To export them on their own, in an export or import specification, you must prefix pattern names with the &lt;code&gt;pattern&lt;/code&gt; keyword, e.g.:</source>
          <target state="translated">Чтобы экспортировать их отдельно, в спецификации экспорта или импорта, вы должны префикс имен &lt;code&gt;pattern&lt;/code&gt; ключевым словом pattern , например:</target>
        </trans-unit>
        <trans-unit id="059e3de99f2d80caf2d89e7201f6c7c557017928" translate="yes" xml:space="preserve">
          <source>To figure out what exactly they do, the least bad way is to grep the rts/ directory in the ghc code for macros like &lt;code&gt;DEBUG(scheduler&lt;/code&gt; or &lt;code&gt;DEBUG_scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373832b60bccf6816963a2a722042fdc637fe0c9" translate="yes" xml:space="preserve">
          <source>To figure out which part of the compiler is badly behaved, the &lt;code&gt;-v2&lt;/code&gt; option is your friend.</source>
          <target state="translated">Чтобы выяснить, какая часть компилятора плохо себя ведет, вам &lt;code&gt;-v2&lt;/code&gt; параметр -v2 .</target>
        </trans-unit>
        <trans-unit id="617e8f413888e2a59390516c4594fefa6467d4c8" translate="yes" xml:space="preserve">
          <source>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use &lt;code&gt;cabal-install&lt;/code&gt;, or download the packages from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; and build and install them as normal.</source>
          <target state="translated">Чтобы решить эту проблему, вам необходимо перекомпилировать сломанные пакеты с учетом новых зависимостей. Самый простой способ сделать это - использовать &lt;code&gt;cabal-install&lt;/code&gt; или загрузить пакеты с &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB,&lt;/a&gt; собрать и установить их как обычно.</target>
        </trans-unit>
        <trans-unit id="d1fadbae3a14577a0f008fefc32f335b95527ef3" translate="yes" xml:space="preserve">
          <source>To further explain this example, the right-hand side of the default type signature for &lt;code&gt;bar&lt;/code&gt; must be something that is alpha-equivalent to &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (where &lt;code&gt;a&lt;/code&gt; is bound by the class itself, and is thus free in the methods&amp;rsquo; type signatures). So this would also be an acceptable default type signature:</source>
          <target state="translated">Чтобы дополнительно объяснить этот пример, правая часть сигнатуры типа по умолчанию для &lt;code&gt;bar&lt;/code&gt; должна быть чем-то, что альфа-эквивалентно &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (где &lt;code&gt;a&lt;/code&gt; привязан к самому классу и, таким образом, свободен в сигнатурах типов методов). Так что это также будет приемлемой сигнатурой типа по умолчанию:</target>
        </trans-unit>
        <trans-unit id="1e54d546d02ad4863886b9ee73d1e131e1c71a9f" translate="yes" xml:space="preserve">
          <source>To gain access to a much larger family of encodings, use the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">Чтобы получить доступ к гораздо большему семейству кодировок, используйте &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;пакет text-icu&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7552595f3e9f52aba2ce1ac4224b4fd08998d77" translate="yes" xml:space="preserve">
          <source>To generate a heap profile from your program:</source>
          <target state="translated">Чтобы сгенерировать профиль кучи из вашей программы:</target>
        </trans-unit>
        <trans-unit id="5c213d8e1ad0bf625f6921a8437f98eeb3f4a1b0" translate="yes" xml:space="preserve">
          <source>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between &lt;code&gt;+RTS ... -RTS&lt;/code&gt; as usual):</source>
          <target state="translated">Чтобы сгенерировать профиль времени и распределения, укажите один из следующих параметров RTS для скомпилированной программы при ее запуске (параметры RTS должны быть заключены между &lt;code&gt;+RTS ... -RTS&lt;/code&gt; как обычно):</target>
        </trans-unit>
        <trans-unit id="34cea9b35b2bfd8b0bd668c0b07e2825a95e1c3d" translate="yes" xml:space="preserve">
          <source>To get a list of the bindings currently in scope, use the &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt;&lt;code&gt;:show bindings&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Чтобы получить список привязок, находящихся в настоящее время в области видимости, используйте команду &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt; &lt;code&gt;:show bindings&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="584aacfb52fdd9de92b4db69f120bc255bd58b9a" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">Чтобы получить более полезную версию класса &lt;code&gt;Collects&lt;/code&gt; , GHC предоставляет механизм, который позволяет программистам указывать зависимости между параметрами многопараметрического класса (для читателей, интересующихся теоретическими основами и предыдущей работой: можно увидеть использование информации о зависимостях и как обобщение предложения о &amp;laquo;классах параметрических типов&amp;raquo;, которое было выдвинуто Ченом, Худаком и Одерски, или как частный случай более поздней концепции Марка Джонса для &amp;laquo;улучшения&amp;raquo; квалифицированных типов. Основные идеи также обсуждаются в более теоретическая и абстрактная установка в рукописи &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, где они обозначены как одна точка в общем пространстве проектирования для систем неявной параметризации). Чтобы начать с абстрактного примера, рассмотрим такое объявление, как:</target>
        </trans-unit>
        <trans-unit id="3b643a5f53fe92a51d4d6cc04833d6658ab9e142" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id32&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd4283dabd7adbbf3b3fa6217759a91e02bf006" translate="yes" xml:space="preserve">
          <source>To get better errors, it is recommended to use #line pragmas when emitting C files, e.g.</source>
          <target state="translated">Чтобы получить лучшие ошибки,рекомендуется использовать #line прагмы,когда испускаются файлы на C,например</target>
        </trans-unit>
        <trans-unit id="c4c508962468a9bf469857dfae6ad15a1e12b86c" translate="yes" xml:space="preserve">
          <source>To get maximum performance when building lazy &lt;code&gt;Text&lt;/code&gt; values using a builder, associate &lt;code&gt;mappend&lt;/code&gt; calls to the right. For example, prefer</source>
          <target state="translated">Чтобы получить максимальную производительность при построении ленивых &lt;code&gt;Text&lt;/code&gt; значений с помощью построителя, &lt;code&gt;mappend&lt;/code&gt; справа вызовы mappend . Например, предпочитать</target>
        </trans-unit>
        <trans-unit id="e54b5b21677328842d1e9a6b9afb2745752f58b5" translate="yes" xml:space="preserve">
          <source>To get the annotations of a single binder, you can use &lt;code&gt;getAnnotations&lt;/code&gt; and specify the proper type. Here&amp;rsquo;s an example that will print out the name of any top-level non-recursive binding with the &lt;code&gt;SomeAnn&lt;/code&gt; annotation:</source>
          <target state="translated">Чтобы получить аннотации одного подшивки, вы можете использовать &lt;code&gt;getAnnotations&lt;/code&gt; и указать правильный тип. Вот пример, который распечатает имя любой нерекурсивной привязки верхнего уровня с аннотацией &lt;code&gt;SomeAnn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="427028b92998e9d2972ad20dfdc92870e2d3c450" translate="yes" xml:space="preserve">
          <source>To help understand the use of these functions, consider the Unicode string &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt;. If encoded as UTF-8, this becomes &lt;code&gt;&quot;hi
 \xe2\x98\x83&quot;&lt;/code&gt;; the final &lt;code&gt;'☃'&lt;/code&gt; is encoded as 3 bytes.</source>
          <target state="translated">Чтобы понять использование этих функций, рассмотрим строку Unicode &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt; . Если кодируется как UTF-8, это становится &lt;code&gt;&quot;hi \xe2\x98\x83&quot;&lt;/code&gt; ; последний &lt;code&gt;'☃'&lt;/code&gt; кодируется как 3 байта.</target>
        </trans-unit>
        <trans-unit id="99872510dc191d4452db56bf22957570e23b92b9" translate="yes" xml:space="preserve">
          <source>To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into &lt;code&gt;Main.hs&lt;/code&gt; and &lt;code&gt;Printf.hs&lt;/code&gt;:</source>
          <target state="translated">Чтобы помочь вам преодолеть барьер уверенности, попробуйте этот скелетный рабочий пример. Сначала вырежьте и вставьте два модуля ниже в &lt;code&gt;Main.hs&lt;/code&gt; и &lt;code&gt;Printf.hs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="48b1aabf0c4a191f672c0b44cca67c4f38a6d577" translate="yes" xml:space="preserve">
          <source>To hopefully illuminate the role of the different data structures, here are the command-line options for a (very simple) compiler, done in two different ways. The difference arises because the type of &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; is parameterized by the type of values derived from flags.</source>
          <target state="translated">Чтобы пролить свет на роль различных структур данных, вот параметры командной строки для (очень простого) компилятора, выполненные двумя разными способами. Разница возникает из-за того, что тип &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; параметризуется типом значений, полученных из флагов.</target>
        </trans-unit>
        <trans-unit id="d8ae72f545b1ce82b2cfe09ab991783beb655542" translate="yes" xml:space="preserve">
          <source>To implement &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findLast&lt;/code&gt; on any &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Для реализации &lt;code&gt;find&lt;/code&gt; или &lt;code&gt;findLast&lt;/code&gt; на любом &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="458751b9fab299d8f4e8789e1128f4827ef9c961" translate="yes" xml:space="preserve">
          <source>To import a qualified module usually you must specify &lt;code&gt;qualified&lt;/code&gt; in prepositive position : &lt;code&gt;import qualified M&lt;/code&gt;. This often leads to a &amp;ldquo;hanging indent&amp;rdquo; (which is automatically inserted by some autoformatters and common in many code bases. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7c52e770ffa8a6b97378d2c5e459f4d2e43a4e" translate="yes" xml:space="preserve">
          <source>To install LLVM and Clang:</source>
          <target state="translated">Для установки LLVM и Clang:</target>
        </trans-unit>
        <trans-unit id="f4755fa59e195e04ee11ff89504edf74eae51201" translate="yes" xml:space="preserve">
          <source>To invoke &lt;code&gt;foo()&lt;/code&gt; from C, just &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; and call &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">Чтобы вызвать &lt;code&gt;foo()&lt;/code&gt; из C, просто &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; и вызовите &lt;code&gt;foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c620f61de0b4e8243389340a761b127a5420c3" translate="yes" xml:space="preserve">
          <source>To learn more about this decision and the design of GHC under the hood please see the &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;paper&lt;/a&gt; introducing this kind system to GHC/Haskell.</source>
          <target state="translated">Чтобы узнать больше об этом решении и о внутренней структуре GHC, пожалуйста, прочтите &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;статью, в которой&lt;/a&gt; описывается такая система в GHC / Haskell.</target>
        </trans-unit>
        <trans-unit id="aae76ecf649e9d0d8a82065b74e94e13fc57f2d4" translate="yes" xml:space="preserve">
          <source>To load a Haskell source file into GHCi, use the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">Чтобы загрузить исходный файл Haskell в GHCi, используйте команду &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="84282ca7b4af31d8f72f41e5b0309bfeef77e8b2" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">Чтобы загрузить пакет &lt;code&gt;foo&lt;/code&gt; , GHCi может загрузить свою библиотеку &lt;code&gt;libHSfoo.a&lt;/code&gt; напрямую, но он также может загрузить пакет в виде одного файла &lt;code&gt;HSfoo.o&lt;/code&gt; , который был предварительно связан. Загрузка файла &lt;code&gt;.o&lt;/code&gt; происходит немного быстрее, но за счет наличия еще одной копии скомпилированного пакета. &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; правило состоит в том, что если модули пакета были скомпилированы с помощью -split-objs, то &lt;code&gt;HSfoo.o&lt;/code&gt; имеет смысл, поскольку это экономит время при загрузке пакета в GHCi. Без &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; не будет большой разницы во времени загрузки между библиотеками &lt;code&gt;.o&lt;/code&gt; и &lt;code&gt;.a&lt;/code&gt; , поэтому лучше сэкономить место на диске и оставить только &lt;code&gt;.a&lt;/code&gt; вокруг. В дистрибутиве GHC мы предоставляем файлы &lt;code&gt;.o&lt;/code&gt; для большинства пакетов, кроме самого пакета GHC.</target>
        </trans-unit>
        <trans-unit id="ab99b40605f7da9e4eebad8eb504404bd0faa1f0" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-sections&quot;&gt;&lt;code&gt;-split-sections&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e3260144403e14ad423568ae3ce8f12c1a164c" translate="yes" xml:space="preserve">
          <source>To make an executable program, the GHC system compiles your code and then links it with a non-trivial runtime system (RTS), which handles storage management, thread scheduling, profiling, and so on.</source>
          <target state="translated">Чтобы сделать исполняемую программу,система GHC компилирует ваш код,а затем связывает его с нетривиальной системой исполнения (RTS),которая обрабатывает управление хранилищем,планирование потоков,профилирование и так далее.</target>
        </trans-unit>
        <trans-unit id="409b50b71b1cf04f14989a6bebb5d1b08c15a045" translate="yes" xml:space="preserve">
          <source>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit &lt;code&gt;import qualified&lt;/code&gt; declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; flag.</source>
          <target state="translated">Чтобы немного упростить жизнь, приглашение GHCi также ведет себя так, как если бы для каждого модуля в каждом пакете и для каждого модуля, загруженного в GHCi в настоящее время, существует неявное объявление, &lt;code&gt;import qualified&lt;/code&gt; для импорта . Это поведение можно отключить с помощью &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3811e1546e787ed220aa8285f2fd305ece22386" translate="yes" xml:space="preserve">
          <source>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; language extension. A deriving strategy can be specified in a deriving clause</source>
          <target state="translated">Чтобы сделать это более надежным, в GHC есть понятие стратегий получения, которые позволяют пользователю явно запрашивать, какой подход использовать при создании экземпляра. Чтобы включить эту функцию, необходимо включить расширение языка &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt; . Стратегия вывода может быть указана в предложении вывода.</target>
        </trans-unit>
        <trans-unit id="b64615441fb8a751e6636d849ab82db0727aa6e0" translate="yes" xml:space="preserve">
          <source>To make use of the profiling system &lt;em&gt;all&lt;/em&gt; modules must be compiled and linked with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option. Any &lt;code&gt;SCC&lt;/code&gt; annotations you&amp;rsquo;ve put in your source will spring to life.</source>
          <target state="translated">Чтобы использовать систему профилирования, &lt;em&gt;все&lt;/em&gt; модули должны быть скомпилированы и связаны с параметром &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; . Любые аннотации &lt;code&gt;SCC&lt;/code&gt; ,которые вы добавили в свой источник, оживут.</target>
        </trans-unit>
        <trans-unit id="cadd792349a4de388974151ed3334973779b0aae" translate="yes" xml:space="preserve">
          <source>To make use of these hidden fields, we need to create some helper functions:</source>
          <target state="translated">Чтобы использовать эти скрытые поля,нам нужно создать некоторые вспомогательные функции:</target>
        </trans-unit>
        <trans-unit id="8a354e65731baf61d210fdcef00d7fcaebe03d2c" translate="yes" xml:space="preserve">
          <source>To provide more control over the compiler&amp;rsquo;s verbosity, the &lt;code&gt;-v&lt;/code&gt; flag takes an optional numeric argument. Specifying &lt;code&gt;-v&lt;/code&gt; on its own is equivalent to &lt;code&gt;-v3&lt;/code&gt;, and the other levels have the following meanings:</source>
          <target state="translated">Чтобы обеспечить больший контроль над подробностью компилятора, флаг &lt;code&gt;-v&lt;/code&gt; принимает необязательный числовой аргумент. Указание &lt;code&gt;-v&lt;/code&gt; &lt;code&gt;-v3&lt;/code&gt; по себе эквивалентно -v3 , а другие уровни имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="e09a1d373d13bfd1fe833239f80a4362b6548f69" translate="yes" xml:space="preserve">
          <source>To recover after an exception and do something else, the best choice is to use one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; family.</source>
          <target state="translated">Чтобы восстановиться после исключения и заняться чем-то другим, лучше всего использовать одну из &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; версий.</target>
        </trans-unit>
        <trans-unit id="14e26ca731fed1a65d734c4805ba32c05da97880" translate="yes" xml:space="preserve">
          <source>To remove an existing directory symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Чтобы удалить существующую символическую ссылку на каталог, используйте &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="902b5e7fc39d15c95b3964399bd08b53ff7a117f" translate="yes" xml:space="preserve">
          <source>To remove an existing file symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Чтобы удалить существующую символическую ссылку на файл, используйте &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb5610465d9a35f189f4445a996d1ae11b587c8" translate="yes" xml:space="preserve">
          <source>To safely use this API you must either extract the list of vertices directly from the graph or first call &lt;code&gt;vertexFromKey k&lt;/code&gt; to check if a vertex corresponds to the key &lt;code&gt;k&lt;/code&gt;. Once it is known that a vertex exists you can use &lt;code&gt;nodeFromVertex&lt;/code&gt; to access the labelled node and adjacent vertices. See below for examples.</source>
          <target state="translated">Чтобы безопасно использовать этот API, вы должны либо извлечь список вершин непосредственно из графа, либо сначала вызвать &lt;code&gt;vertexFromKey k&lt;/code&gt; , чтобы проверить, соответствует ли вершина ключу &lt;code&gt;k&lt;/code&gt; . Как только известно, что вершина существует, вы можете использовать &lt;code&gt;nodeFromVertex&lt;/code&gt; для доступа к помеченному узлу и смежным вершинам. См. Примеры ниже.</target>
        </trans-unit>
        <trans-unit id="a5e1113a1ceca8ac3b9f3aacd5ed4c7c86f2fc6d" translate="yes" xml:space="preserve">
          <source>To see whether you&amp;rsquo;re making good use of all the memory reseverd for the allocation area (&lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;), look at the output of &lt;code&gt;+RTS -S&lt;/code&gt; and check whether the amount of memory allocated between GCs is equal to &lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;. If not, there are two possible remedies: use &lt;code&gt;-n&lt;/code&gt; to set a nursery chunk size, or use &lt;code&gt;-AL&lt;/code&gt; to increase the limit for large objects.</source>
          <target state="translated">Чтобы убедиться, что вы делаете хорошее использование всех reseverd памяти для области выделения ( &lt;code&gt;-A&lt;/code&gt; раза &lt;code&gt;-N&lt;/code&gt; ), вид на выходе &lt;code&gt;+RTS -S&lt;/code&gt; и проверить , является ли объем памяти , выделяемым между ШСОМ равен &lt;code&gt;-A&lt;/code&gt; раз &lt;code&gt;-N&lt;/code&gt; . Если нет, есть два возможных решения: используйте &lt;code&gt;-n&lt;/code&gt; , чтобы установить размер &lt;code&gt;-AL&lt;/code&gt; блока, или используйте -AL, чтобы увеличить предел для больших объектов.</target>
        </trans-unit>
        <trans-unit id="7f2b1743b3c15e52d49c7a46f47317e7b211afa8" translate="yes" xml:space="preserve">
          <source>To see which modules are provided by a package use the &lt;code&gt;ghc-pkg&lt;/code&gt; command (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;):</source>
          <target state="translated">Чтобы узнать, какие модули предоставляются пакетом, используйте команду &lt;code&gt;ghc-pkg&lt;/code&gt; (см. &lt;a href=&quot;#package-management&quot;&gt;Управление&lt;/a&gt; пакетами (команда ghc-pkg) ):</target>
        </trans-unit>
        <trans-unit id="0d20768e5351c559b7b7519dd0d6001dcac049eb" translate="yes" xml:space="preserve">
          <source>To see which packages are currently available, use the &lt;code&gt;ghc-pkg list&lt;/code&gt; command:</source>
          <target state="translated">Чтобы узнать, какие пакеты в настоящее время доступны, используйте команду &lt;code&gt;ghc-pkg list&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a70566dabf5a41f2019632020db79dab54902519" translate="yes" xml:space="preserve">
          <source>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived &lt;code&gt;Functor&lt;/code&gt; instance, let&amp;rsquo;s suppose that a &lt;code&gt;Functor ContraFun1&lt;/code&gt; instance exists. The implementation would look something like this:</source>
          <target state="translated">Чтобы понять, почему тип данных с контравариантным вхождением последнего параметра типа не может иметь производный экземпляр &lt;code&gt;Functor&lt;/code&gt; , предположим, что существует экземпляр &lt;code&gt;Functor ContraFun1&lt;/code&gt; . Реализация будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="1dd1e599c7b99d0ef6415d16c2b63820670b8ef4" translate="yes" xml:space="preserve">
          <source>To serialise a custom type, an instance of Binary for that type is required. For example, suppose we have a data structure:</source>
          <target state="translated">Для сериализации пользовательского типа требуется экземпляр Binary для этого типа.Например,предположим,что у нас есть структура данных:</target>
        </trans-unit>
        <trans-unit id="ec5ac163ebb0f97a307be294a6581754c5f32393" translate="yes" xml:space="preserve">
          <source>To serialise this to a bytestring, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;, which packs the data structure into a binary format, in a lazy bytestring</source>
          <target state="translated">Чтобы сериализовать это в строку байтов, мы используем &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; , которое упаковывает структуру данных в двоичный формат в ленивую строку байтов.</target>
        </trans-unit>
        <trans-unit id="8c4bb74fa2bda9539f0db58684ace13bfcd04704" translate="yes" xml:space="preserve">
          <source>To set a package&amp;rsquo;s trust property in the package database please refer to &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;.</source>
          <target state="translated">Чтобы установить свойство доверия пакета в базе данных пакетов, обратитесь к &lt;a href=&quot;packages#packages&quot;&gt;разделу &amp;laquo;Пакеты&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a25ac21c6d3b62631dd08b42b9fae80c8727be0" translate="yes" xml:space="preserve">
          <source>To skip to the first occurence of a string:</source>
          <target state="translated">Чтобы перейти к первому появлению строки:</target>
        </trans-unit>
        <trans-unit id="edb758d0d6990d34bd2a170aea31bb2ebe72017b" translate="yes" xml:space="preserve">
          <source>To solve such concern, the references provided by this module offer a key that can be used to locate the values on each process. Each process maintains a global table of references which can be looked up with a given key. This table is known as the Static Pointer Table. The reference can then be dereferenced to obtain the value.</source>
          <target state="translated">Для решения этой проблемы в ссылках,предоставляемых данным модулем,предлагается ключ,с помощью которого можно определить местонахождение значений по каждому процессу.Каждый процесс ведет глобальную таблицу ссылок,которую можно просмотреть по заданному ключу.Эта таблица известна как таблица статических указателей.Ссылка может быть разыменована для получения значения.</target>
        </trans-unit>
        <trans-unit id="f9c68944d2e59e0a66846b50f57d32b2ca1f9acb" translate="yes" xml:space="preserve">
          <source>To solve this, GHC provides a single type-level function,</source>
          <target state="translated">Для решения этой проблемы GHC предоставляет функцию одного уровня типа,</target>
        </trans-unit>
        <trans-unit id="bf25b9f1720e9ac7d0d7fdd7aee2f1ed9e0566fe" translate="yes" xml:space="preserve">
          <source>To start with an example, suppose you had a module &lt;code&gt;A&lt;/code&gt; which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</source>
          <target state="translated">Для начала предположим, что у вас есть модуль &lt;code&gt;A&lt;/code&gt; ,в котором используются некоторые строковые операции. Используя обычный импорт модулей, вы сможете выбрать только конкретную реализацию строк:</target>
        </trans-unit>
        <trans-unit id="89c4479e20c71a25f4dfb43028231f4a734bfcce" translate="yes" xml:space="preserve">
          <source>To take the parts of a string before a delimiter:</source>
          <target state="translated">Взять части строки перед разделителем:</target>
        </trans-unit>
        <trans-unit id="e0c0e5556db2e9b3b7a23b8b7d2d49b51aa44349" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">Для программиста Concurrent Haskell не представляет никаких новых языковых конструкций; скорее, он выглядит просто как библиотека &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; . Эта библиотека экспортирует следующие функции:</target>
        </trans-unit>
        <trans-unit id="6bfc70e59567edf696404769885739682f80dcc8" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c62456e79e21d498915acbcba13f52cb41593ec" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23874375ac3170d79af0c71d4f8ee2bec3a32884" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать флаги &lt;code&gt;+RTS&lt;/code&gt; с &lt;code&gt;hs_init()&lt;/code&gt; , нам нужно немного изменить пример. По умолчанию RTS GHC принимает только &amp;laquo;безопасные&amp;raquo; &lt;code&gt;+RTS&lt;/code&gt; флаги RTS (см. &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; ), а &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; времени компоновки -rtsopts [= ⟨none | some | all⟩] отменяет это. Однако &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; не действует, когда используется &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; (и то же самое касается &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; ). Чтобы установить эти параметры, мы должны вызвать специфичный для GHC API вместо &lt;code&gt;hs_init()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58ce08b9cab583ec1630da790acaeb1e4504d015" translate="yes" xml:space="preserve">
          <source>To use an &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt; the RTS API provides the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c832a5995effff9df59220a2bd9f7e56cfb4614f" translate="yes" xml:space="preserve">
          <source>To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">Чтобы использовать расширенное и очень богатое семейство функций для работы с текстом Unicode (включая нормализацию, регулярные выражения, нестандартные кодировки, разрыв текста и языковые стандарты), см. &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;Пакет text-icu&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b96ac2af089bcd3267331bb1501aa1e1d197309c" translate="yes" xml:space="preserve">
          <source>To use relative paths for dependent libraries on Linux and Solaris you can pass a suitable &lt;code&gt;-rpath&lt;/code&gt; flag to the linker:</source>
          <target state="translated">Чтобы использовать относительные пути для зависимых библиотек в Linux и Solaris, вы можете передать &lt;code&gt;-rpath&lt;/code&gt; соответствующий флаг -rpath :</target>
        </trans-unit>
        <trans-unit id="7f309e398fff568b18e392785bde202981de0be5" translate="yes" xml:space="preserve">
          <source>To use this equality in practice, pattern-match on the &lt;code&gt;Coercion a b&lt;/code&gt; to get out the &lt;code&gt;Coercible a b&lt;/code&gt; instance, and then use &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; to apply it.</source>
          <target state="translated">Для использования этого равенства на практике, картина матч на &lt;code&gt;Coercion a b&lt;/code&gt; , чтобы выйти из &lt;code&gt;Coercible a b&lt;/code&gt; экземпляра, а затем использовать &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; , чтобы применить его.</target>
        </trans-unit>
        <trans-unit id="3aa17a9e79c9dcc3ca39fe2b79ee583cccf33fc4" translate="yes" xml:space="preserve">
          <source>To use tracing, evaluate an expression with the &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command. For example, if we set a breakpoint on the base case of &lt;code&gt;qsort&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать трассировку, оцените выражение с помощью команды &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; . Например, если мы установим точку останова в базовом случае &lt;code&gt;qsort&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="efc675a1383ace97e3c2b8987f540eb58b6ceef5" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the documentation of the valid hole fits in the output.</source>
          <target state="translated">Показывает,нужно ли показывать документацию по действительному отверстию,вписывающемуся в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="332b4115b5fb01dc68e2b60acec1f7d2ed0f11c6" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the provenance of the valid hole fits in the output.</source>
          <target state="translated">Переключает,показывать ли происхождение действительного отверстия,вписывается ли оно в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="a7f408bf113ca084f529db4badbce821ff390f15" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type application of the valid hole fits in the output.</source>
          <target state="translated">Показывает,нужно ли показывать применение типа действительного отверстия,вписывающегося в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="2c4d22b7c838a1ecfb6276f53708bb0e679bc1f9" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the additional holes in refinement hole fits.</source>
          <target state="translated">Показывает,нужно ли показывать тип дополнительных отверстий в утонченном отверстии.</target>
        </trans-unit>
        <trans-unit id="04756312abbe3334230e9fe9c79fe06f08cf1ef4" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the valid hole fits in the output.</source>
          <target state="translated">Показывает,нужно ли показывать тип действительного отверстия,вписывающегося в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="f88544b7c345be9bc6286319d7234499cb7a2281" translate="yes" xml:space="preserve">
          <source>Toggles whether to show what type each quantified variable takes in a valid hole fit.</source>
          <target state="translated">Показывает,нужно ли показывать,какой тип каждой квантифицированной переменной соответствует действительному посадке в дыру.</target>
        </trans-unit>
        <trans-unit id="8d4022d64adedc28fae75a3f895c4e8da81cd40c" translate="yes" xml:space="preserve">
          <source>Token pretty-printing function.</source>
          <target state="translated">Функция печати жетонов.</target>
        </trans-unit>
        <trans-unit id="daef2147e79571af8d5a4f376f29fb535295e66d" translate="yes" xml:space="preserve">
          <source>TokenParser</source>
          <target state="translated">TokenParser</target>
        </trans-unit>
        <trans-unit id="de9a588a8ad015eb8d4acc3d2eccb5cd88ff7637" translate="yes" xml:space="preserve">
          <source>Top-level declaration splices break up a source file into &lt;em&gt;declaration groups&lt;/em&gt;. A &lt;em&gt;declaration group&lt;/em&gt; is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</source>
          <target state="translated">Соединения объявлений верхнего уровня разбивают исходный файл на &lt;em&gt;группы объявлений&lt;/em&gt; . Группа &lt;em&gt;объявлений&lt;/em&gt; - это группа объявлений, созданных при объединении объявлений верхнего уровня, плюс те, которые следуют за ним, вплоть до следующего объединения объявлений верхнего уровня, но не включая его. NB только соединения верхнего уровня ограничивают группы объявлений, а не соединения выражений. Первая группа объявлений в модуле включает все определения верхнего уровня, вплоть до первого соединения объявлений верхнего уровня, но не включая его.</target>
        </trans-unit>
        <trans-unit id="64e70a05233381ae9b755ec9cdc13f4a77ee5cb1" translate="yes" xml:space="preserve">
          <source>Total CPU time (at the previous GC)</source>
          <target state="translated">Общее процессорное время (на предыдущем ГХ)</target>
        </trans-unit>
        <trans-unit id="8386f73231e1e92e73f6b519f210511ca9193151" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the GC</source>
          <target state="translated">Общее процессорное время,используемое ГХ</target>
        </trans-unit>
        <trans-unit id="042e7e784ddb44e360a337daa72b2ae8ba023cf1" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the init phase @since 4.12.0.0</source>
          <target state="translated">Общее процессорное время,используемое на этапе init @since 4.12.0.0</target>
        </trans-unit>
        <trans-unit id="d2dd5d438fb3dcc8fdc1f04bf55f6d2c501879d3" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the mutator</source>
          <target state="translated">Общее процессорное время,используемое мутатором</target>
        </trans-unit>
        <trans-unit id="cd8f3ebd1cb51ba0810348d6c47b2fdc351d6519" translate="yes" xml:space="preserve">
          <source>Total amount of data copied during this GC</source>
          <target state="translated">Общий объем данных,скопированных во время этого ГХ</target>
        </trans-unit>
        <trans-unit id="9735e288f821d32fcba71a1a70c14b5cdc350199" translate="yes" xml:space="preserve">
          <source>Total amount of live data in compact regions</source>
          <target state="translated">Общий объем данных в реальном времени в компактных регионах</target>
        </trans-unit>
        <trans-unit id="490b2f80ac8821885d90f86d57b7974bbf2682ad" translate="yes" xml:space="preserve">
          <source>Total amount of live data in large objects</source>
          <target state="translated">Общее количество живых данных в крупных объектах</target>
        </trans-unit>
        <trans-unit id="e6b177b175f265fd062fef05a1277c622c233454" translate="yes" xml:space="preserve">
          <source>Total amount of live data in the heap (incliudes large + compact data). Updated after every GC. Data in uncollected generations (in minor GCs) are considered live.</source>
          <target state="translated">Общий объем данных,находящихся в режиме реального времени в куче (наклон большой+компактные данные).Обновляется после каждого ГХ.Данные в несобранных поколениях (в малых ГХ)считаются живыми.</target>
        </trans-unit>
        <trans-unit id="2439e747cf079533fc119f7f3372deeb2e6b3e0c" translate="yes" xml:space="preserve">
          <source>Total amount of memory in use by the RTS</source>
          <target state="translated">Общий объем используемой памяти RTS</target>
        </trans-unit>
        <trans-unit id="ae1cf3a5225a7fa4703cee57bd8a99cfbdc1fa37" translate="yes" xml:space="preserve">
          <source>Total amount of slop (wasted memory)</source>
          <target state="translated">Общее количество слякотины (пустая память)</target>
        </trans-unit>
        <trans-unit id="381d3d3026564b15b98332086f85db8c9c5116c1" translate="yes" xml:space="preserve">
          <source>Total bytes allocated</source>
          <target state="translated">Общее количество выделенных байт</target>
        </trans-unit>
        <trans-unit id="7ddb5932284e85cdb998a88ee61c45b3fb084550" translate="yes" xml:space="preserve">
          <source>Total elapsed time (at the previous GC)</source>
          <target state="translated">Общее истекшее время (на предыдущем ГК)</target>
        </trans-unit>
        <trans-unit id="5176bda3a891825313e991007cfcf6a2dfe321e1" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the GC</source>
          <target state="translated">Общее истекшее время,использованное ГХ</target>
        </trans-unit>
        <trans-unit id="a76b13b30e1f96d1561f8aba9418764cdf896ec9" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the init phase @since 4.12.0.0</source>
          <target state="translated">Общее истекшее время,использованное фазой init @since 4.12.0.0</target>
        </trans-unit>
        <trans-unit id="f8dffa4e4bface78bbc47de7cc9c4f635615fd39" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the mutator</source>
          <target state="translated">Общее истекшее время,использованное мутатором</target>
        </trans-unit>
        <trans-unit id="c702e8f0d2bf491124a83b3aba7ca49be01b7437" translate="yes" xml:space="preserve">
          <source>Total number of GCs</source>
          <target state="translated">Общее число ГХ</target>
        </trans-unit>
        <trans-unit id="f31fc901ada0fd73f4d6d8746668c45f8b841486" translate="yes" xml:space="preserve">
          <source>Total number of major (oldest generation) GCs</source>
          <target state="translated">Общее количество основных (самого старшего поколения)ГХ</target>
        </trans-unit>
        <trans-unit id="5d0fb43e49fcfea4980958defc073241b65ca7be" translate="yes" xml:space="preserve">
          <source>Total width of the field.</source>
          <target state="translated">Общая ширина поля.</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="26f445c1d8b2f4e101fdf56e72eb92189d409de2" translate="yes" xml:space="preserve">
          <source>Trace exhaustiveness checker</source>
          <target state="translated">Проверка исчерпанности трассировки</target>
        </trans-unit>
        <trans-unit id="8d94ec6e077733db6938cd196aa7260c918b123b" translate="yes" xml:space="preserve">
          <source>Trace interface files</source>
          <target state="translated">Файлы интерфейса трассировки</target>
        </trans-unit>
        <trans-unit id="fdbe7d47032190e46bbad6a5b35e468fcdd74e5e" translate="yes" xml:space="preserve">
          <source>Trace renamer</source>
          <target state="translated">Переименовать трассировку</target>
        </trans-unit>
        <trans-unit id="b6912fb740cfa5def4327273bd86af0baeb5f9b4" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference</source>
          <target state="translated">Отследить время выполнения тип вывода</target>
        </trans-unit>
        <trans-unit id="ea97ebbaf9290aacc9db9230d7d8410a1b17dde1" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference done by various interpreter commands.</source>
          <target state="translated">Трассировка типового вывода,выполняемая различными командами интерпретатора.</target>
        </trans-unit>
        <trans-unit id="918226cc8c88c96d88772b200fb277ce2462c0b2" translate="yes" xml:space="preserve">
          <source>Trace typechecker</source>
          <target state="translated">Тайпчекинговый трассировщик</target>
        </trans-unit>
        <trans-unit id="cac5cce622b33dcb41c89b31f1cab4a7d79e4ee1" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Mix</source>
          <target state="translated">Trace.Hpc.Mix</target>
        </trans-unit>
        <trans-unit id="4dc37d38ccb40ad731bd6b735a3d79a901047644" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Tix</source>
          <target state="translated">Trace.Hpc.Tix</target>
        </trans-unit>
        <trans-unit id="b9911dc4ca5e0e643713d12b25be14491d441daa" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Util</source>
          <target state="translated">Trace.Hpc.Util</target>
        </trans-unit>
        <trans-unit id="0ce5cee6755ef940551826d010c5c2ba3528d3db" translate="yes" xml:space="preserve">
          <source>TraceEventLog</source>
          <target state="translated">TraceEventLog</target>
        </trans-unit>
        <trans-unit id="8255bba6a712a935f53931169349c3bf3667e4e7" translate="yes" xml:space="preserve">
          <source>TraceFlags</source>
          <target state="translated">TraceFlags</target>
        </trans-unit>
        <trans-unit id="f45cd5da920597cccb919c43b85883e95c0eb5ba" translate="yes" xml:space="preserve">
          <source>TraceNone</source>
          <target state="translated">TraceNone</target>
        </trans-unit>
        <trans-unit id="95797df6040c41d1f62d4c30f5d575a3fde2b6e0" translate="yes" xml:space="preserve">
          <source>TraceStderr</source>
          <target state="translated">TraceStderr</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="c5de444a34d8e7310c292d5077a3f9fa1aea9197" translate="yes" xml:space="preserve">
          <source>Traditional expression quotes and splices let us construct ill-typed expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee76b0788bcc9e4d134c6e63c0f905595d53f415" translate="yes" xml:space="preserve">
          <source>Traditional record syntax, such as &lt;code&gt;C {f = x}&lt;/code&gt;, is enabled by default. To disable it, you can use the &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt;&lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">Традиционный синтаксис записи, такой как &lt;code&gt;C {f = x}&lt;/code&gt; , включен по умолчанию. Чтобы отключить его, вы можете использовать расширение &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt; &lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e945a1a9931ffbae11e35d8dc13f62ffcd7e4996" translate="yes" xml:space="preserve">
          <source>TraditionalRecordSyntax</source>
          <target state="translated">TraditionalRecordSyntax</target>
        </trans-unit>
        <trans-unit id="07d54591052808d7665525ab9d03e9a8e6047941" translate="yes" xml:space="preserve">
          <source>Trailing slash functions</source>
          <target state="translated">Функции скользящей косой черты</target>
        </trans-unit>
        <trans-unit id="5a701b108c7ddd010bd4e5e1046abd3e059fbfcd" translate="yes" xml:space="preserve">
          <source>Transactional variables.</source>
          <target state="translated">Транзакционные переменные.</target>
        </trans-unit>
        <trans-unit id="c6bd77f69d4cdf801791ad51b3a5613597cd452f" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте любые исключения, вызванные вычислением, с помощью данной функции (специализация &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aefaf0cd8aa07449321af97629ce4b3770e62358" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте любые исключения, вызванные вычислением, с помощью данной функции (специализация &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4e682fcac2a4512b74e3dc63612d9586743f8e8" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function.</source>
          <target state="translated">Преобразование любых исключений,брошенных вычислением с помощью данной функции.</target>
        </trans-unit>
        <trans-unit id="4578ae8d733586d0310337c8b520cee638a41571" translate="yes" xml:space="preserve">
          <source>Transform comprehensions</source>
          <target state="translated">Трансформационные представления</target>
        </trans-unit>
        <trans-unit id="6d9379f1a17e7f9d27b049266346529304db629e" translate="yes" xml:space="preserve">
          <source>Transform statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Операторы преобразования (как с &lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="34bbbf0593112d8021164739182249451cd348ed" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;MaybeT&lt;/code&gt;.</source>
          <target state="translated">Преобразуйте вычисления в &lt;code&gt;MaybeT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3add4bdcd20865c3718142bc9551385a370674" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;ReaderT&lt;/code&gt;.</source>
          <target state="translated">Преобразуйте вычисления в &lt;code&gt;ReaderT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94f891243caad66af3028997e36082e6d8dd8dc" translate="yes" xml:space="preserve">
          <source>Transform the value returned by a &lt;code&gt;Reader&lt;/code&gt;.</source>
          <target state="translated">Преобразуйте значение, возвращаемое &lt;code&gt;Reader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="529ddea17b3a6fb911dfd08011006b0a6dba6150" translate="yes" xml:space="preserve">
          <source>TransformListComp</source>
          <target state="translated">TransformListComp</target>
        </trans-unit>
        <trans-unit id="28382f411cec0cea1fa0d72a330aaf42ace1a9fe" translate="yes" xml:space="preserve">
          <source>Transformation of at least one immediate subterm does not fail</source>
          <target state="translated">Трансформация хотя бы одного ближайшего субтермина не терпит неудач.</target>
        </trans-unit>
        <trans-unit id="6553c0c77ccd33d074aee1942550fc0f472cd3f4" translate="yes" xml:space="preserve">
          <source>Transformation of one immediate subterm with success</source>
          <target state="translated">Трансформация одного ближайшего субтермина с успехом</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="68c170c0011cf476eed353d994b12887940cfc96" translate="yes" xml:space="preserve">
          <source>Transformer</source>
          <target state="translated">Transformer</target>
        </trans-unit>
        <trans-unit id="bc40fc64b9787d7dac7665e7c80ced3be2f64e6a" translate="yes" xml:space="preserve">
          <source>Transformer class</source>
          <target state="translated">класс трансформатора</target>
        </trans-unit>
        <trans-unit id="12656556988bc57237e887a0b3bd66131be270a9" translate="yes" xml:space="preserve">
          <source>Transforming ByteStrings</source>
          <target state="translated">Трансформирующие байтСтринги</target>
        </trans-unit>
        <trans-unit id="64733f4060672520e5c156055aa404b5a2fff0ad" translate="yes" xml:space="preserve">
          <source>Transforms a parser into one that does the same, but in addition returns the exact characters read. IMPORTANT NOTE: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; gives a runtime error if its first argument is built using any occurrences of readS_to_P.</source>
          <target state="translated">Преобразует синтаксический анализатор в тот, который делает то же самое, но, кроме того, возвращает точные прочитанные символы. ВАЖНОЕ ПРИМЕЧАНИЕ: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; выдает ошибку времени выполнения, если его первый аргумент построен с использованием любых вхождений readS_to_P.</target>
        </trans-unit>
        <trans-unit id="8f321ea579e546977788ec7503fb201f9808151b" translate="yes" xml:space="preserve">
          <source>Transitional module providing the &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; class and primitive instances.</source>
          <target state="translated">Переходный модуль, предоставляющий класс &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; и примитивные экземпляры.</target>
        </trans-unit>
        <trans-unit id="cf6c281c3321c220a2860f225e26547c6663a008" translate="yes" xml:space="preserve">
          <source>Transitivity</source>
          <target state="translated">Transitivity</target>
        </trans-unit>
        <trans-unit id="7bd7baf126db335320e85434af814c47329f4fb9" translate="yes" xml:space="preserve">
          <source>Transitivity of equality</source>
          <target state="translated">Переходность равенства</target>
        </trans-unit>
        <trans-unit id="ee21a36234c54ae6acecacce32dde8221553c2ab" translate="yes" xml:space="preserve">
          <source>Transitivity of representational equality</source>
          <target state="translated">Переходность репрезентативного равенства</target>
        </trans-unit>
        <trans-unit id="e98e003d090d824a54f132e10d2d3a1b2abb08a4" translate="yes" xml:space="preserve">
          <source>TransliterateCodingFailure</source>
          <target state="translated">TransliterateCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dcc95f8a9883fb6fa511276e0d2f0bd822f6472" translate="yes" xml:space="preserve">
          <source>TransmitStart</source>
          <target state="translated">TransmitStart</target>
        </trans-unit>
        <trans-unit id="d2cf87c31932f3da157ec8f3b86b864b9e7f88fd" translate="yes" xml:space="preserve">
          <source>TransmitStop</source>
          <target state="translated">TransmitStop</target>
        </trans-unit>
        <trans-unit id="59ababde52e8e86da31349f66a50ec3bb7819a93" translate="yes" xml:space="preserve">
          <source>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вернитесь на n⟩ шагов в истории. ⟨N⟩ - это единица, если не указано. См. Раздел &amp;laquo; &lt;a href=&quot;#tracing&quot;&gt;Трассировка и история&amp;raquo;,&lt;/a&gt; чтобы узнать больше о возможностях отладки GHCi. Смотрите также: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b795f17232474b10e4eb05eb081a307e9d9dfa5d" translate="yes" xml:space="preserve">
          <source>Traversable</source>
          <target state="translated">Traversable</target>
        </trans-unit>
        <trans-unit id="9c8ab9d8f52e3cebde865983061e92e1572d8906" translate="yes" xml:space="preserve">
          <source>Traversal</source>
          <target state="translated">Traversal</target>
        </trans-unit>
        <trans-unit id="7b1817a217845dfc3e24c8c230b82767b4c56356" translate="yes" xml:space="preserve">
          <source>Traverse from right to left.</source>
          <target state="translated">Траверс справа налево.</target>
        </trans-unit>
        <trans-unit id="977ae6d655ca9f1978129e8ccbfa10a6559b3561" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">Перемещайтесь по записям, ключи которых отсутствуют на другой карте, при необходимости создавая значения для вставки в результат. Это самая мощная тактика &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; , но другие обычно более эффективны.</target>
        </trans-unit>
        <trans-unit id="5e48e3b92b1820252cbfde816e12e1a271b17cb1" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">Перемещайтесь по записям, ключи которых отсутствуют на другой карте, при необходимости создавая значения для вставки в результат. Это самая мощная тактика &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; , но другие обычно более эффективны.</target>
        </trans-unit>
        <trans-unit id="b18e053b42f93b44a5abf294af55c3136c4f408d" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">Перемещайтесь по записям, ключи которых отсутствуют на другой карте, при необходимости создавая значения для вставки в результат. Это самая мощная тактика &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; , но другие обычно более эффективны.</target>
        </trans-unit>
        <trans-unit id="7200db17563eaefb9847d8db2d6e8155f2a4676c" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">Перемещайтесь по записям, ключи которых отсутствуют на другой карте, при необходимости создавая значения для вставки в результат. Это самая мощная тактика &amp;laquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; , но другие обычно более эффективны.</target>
        </trans-unit>
        <trans-unit id="d03af00b13b95140684e72553fba4a01106b42c9" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map.</source>
          <target state="translated">Пройдитесь по записям,ключи которых отсутствуют на другой карте.</target>
        </trans-unit>
        <trans-unit id="30dc152103c6133db322f634f929327d30f349a1" translate="yes" xml:space="preserve">
          <source>Traverses in order of increasing key.</source>
          <target state="translated">Пересекается в порядке возрастания ключа.</target>
        </trans-unit>
        <trans-unit id="7e92b229a11c1c4e925555ecc443d546f7203f39" translate="yes" xml:space="preserve">
          <source>Treat &lt;code&gt;*&lt;/code&gt; as &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">Рассматривать &lt;code&gt;*&lt;/code&gt; как &lt;code&gt;Data.Kind.Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd46d6f300df9c79faeae4e756e06e57fe755cd8" translate="yes" xml:space="preserve">
          <source>Treat the unqualified uses of the &lt;code&gt;*&lt;/code&gt; type operator as nullary and desugar to &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">Считайте неквалифицированное использование оператора типа &lt;code&gt;*&lt;/code&gt; нулевым и не содержащим сахара для &lt;code&gt;Data.Kind.Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f5ff6378a0b48f815677894306b090ee036726" translate="yes" xml:space="preserve">
          <source>Tree</source>
          <target state="translated">Tree</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d6ebaccbb7b2994140dcf46fc8cbd5a71b52292c" translate="yes" xml:space="preserve">
          <source>Trees and Forests</source>
          <target state="translated">Деревья и леса</target>
        </trans-unit>
        <trans-unit id="d1f88855d73f9050543090a479c62b476a835f18" translate="yes" xml:space="preserve">
          <source>Tried to encode a character that could not be represented under the given encoding, or ran out of input in mid-encode.</source>
          <target state="translated">Пытался кодировать символ,который не мог быть представлен в данной кодировке,или у него закончился ввод в среднем кодировке.</target>
        </trans-unit>
        <trans-unit id="dcf41f4658aee61513347d3d72256ba068f1cb3d" translate="yes" xml:space="preserve">
          <source>Tries to find the definition site of the name at the given source-code span, e.g.:</source>
          <target state="translated">Пытается найти место определения имени в заданном диапазоне исходных кодов,например:</target>
        </trans-unit>
        <trans-unit id="6d6761d1d070e2158059fdae1344762916cfe5cd" translate="yes" xml:space="preserve">
          <source>Triggers an immediate major garbage collection.</source>
          <target state="translated">Сразу же запускает крупный сбор мусора.</target>
        </trans-unit>
        <trans-unit id="5211c258ae504b8bbd5a65143e1ffaccbfaf5d21" translate="yes" xml:space="preserve">
          <source>Triggers an immediate minor garbage collection.</source>
          <target state="translated">Спровоцирует немедленную незначительную уборку мусора.</target>
        </trans-unit>
        <trans-unit id="97bfbacf53c224ce01bb87815c2b91e603df8ea4" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions and related functions.</source>
          <target state="translated">Тригонометрические и гиперболические функции и связанные с ними функции.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="6842273367fb0a7314d3db77e80a4246de4d0209" translate="yes" xml:space="preserve">
          <source>True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;compact all the time&quot;</source>
          <target state="translated">True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;все время компактно&quot;</target>
        </trans-unit>
        <trans-unit id="ff0a01862c74c77c6757cf7463f92a3698aca6ec" translate="yes" xml:space="preserve">
          <source>Truncate the destination file and then copy the contents of the source file to the destination file. If the destination file already exists, its attributes shall remain unchanged. Otherwise, its attributes are reset to the defaults.</source>
          <target state="translated">Усечь целевой файл,а затем скопировать содержимое исходного файла в целевой файл.Если целевой файл уже существует,его атрибуты останутся неизменными.В противном случае его атрибуты сбрасываются к значениям по умолчанию.</target>
        </trans-unit>
        <trans-unit id="32877d96f4471ac3d62c45d19e818182f461981a" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b645724bb0724739a37a0f389e05496a29a993a0" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Обрезает &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; до наименее значимого &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4191815c130347968d06550006d8bef069d5483" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Double#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">Усекает значение &lt;code&gt;Double#&lt;/code&gt; до ближайшего &lt;code&gt;Int#&lt;/code&gt; . Результаты не определены, если усечение, если усечение дает значение вне диапазона &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6d495ffdebdce795d559dc7a00814f02a9ed4a" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Float#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">Усекает значение &lt;code&gt;Float#&lt;/code&gt; до ближайшего &lt;code&gt;Int#&lt;/code&gt; . Результаты не определены, если усечение, если усечение дает значение вне диапазона &lt;code&gt;Int#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c24171999adb97c4a8f884ec45a305760feb8353" translate="yes" xml:space="preserve">
          <source>Truncates the file down to the specified length. If the file was larger than the given length before this operation was performed the extra is lost.</source>
          <target state="translated">Усекает файл до заданной длины.Если до выполнения этой операции длина файла была больше заданной,то лишняя утрачивается.</target>
        </trans-unit>
        <trans-unit id="e5062783e7bc3741e7a3f6f2e923c1f2ca0f5891" translate="yes" xml:space="preserve">
          <source>Trust the used plugins and no longer mark the compiled module as unsafe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc4bdf5385df47149206feaa36c849748d83b64" translate="yes" xml:space="preserve">
          <source>Trustworthy</source>
          <target state="translated">Trustworthy</target>
        </trans-unit>
        <trans-unit id="c3d3c6266583689c8044755f6755946b22e2e727" translate="yes" xml:space="preserve">
          <source>Try alternatives in the same order as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Попробуйте альтернативы в том же порядке, что и &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="649615639f9b9c6ba5bc23c5c62fdf483263edda" translate="yes" xml:space="preserve">
          <source>Try downcasting &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; value. Returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if value doesn't fit in &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Попробуйте уменьшить значение &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; до &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; не возвращает, если значение не подходит для &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f32a8bcb3ae56ab6fee54ca560a7075df79e35e" translate="yes" xml:space="preserve">
          <source>Try to use local disks when linking:</source>
          <target state="translated">Попробуйте использовать локальные диски при соединении:</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="0fae6c283b56ecb589a1f52cbd69ed8461516cd4" translate="yes" xml:space="preserve">
          <source>Tuple data constructor</source>
          <target state="translated">Конструктор кортежей данных</target>
        </trans-unit>
        <trans-unit id="fe995f3be3d2ff04b4539a5c33f7f5265c5ec905" translate="yes" xml:space="preserve">
          <source>Tuple type constructor</source>
          <target state="translated">конструктор типа кортежа</target>
        </trans-unit>
        <trans-unit id="f3571e8acb567c55596ec89e11c3c7590fcd1efb" translate="yes" xml:space="preserve">
          <source>Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; treats it as a product of distinct types. In other words, the following code:</source>
          <target state="translated">Типы кортежей. Когда в правой части объявления данных используется &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , DeriveFunctor рассматривает его как продукт различных типов. Другими словами, следующий код:</target>
        </trans-unit>
        <trans-unit id="07bc188bc9976952fc0cc95ef067281f658cb805" translate="yes" xml:space="preserve">
          <source>TupleSections</source>
          <target state="translated">TupleSections</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="0090b6abe499cb5c3a21cf4b91f82b1dc060fb8b" translate="yes" xml:space="preserve">
          <source>Tuples are currently limited to size 100. However, standard instances for tuples (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;) are available &lt;em&gt;only&lt;/em&gt; up to 16-tuples.</source>
          <target state="translated">Размер кортежей в настоящее время ограничен 100. Однако стандартные экземпляры для кортежей ( &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; и &lt;code&gt;Show&lt;/code&gt; ) доступны &lt;em&gt;только&lt;/em&gt; до 16 кортежей.</target>
        </trans-unit>
        <trans-unit id="eb72a46d788e7aaf184a3a1b039183884ebc8ddf" translate="yes" xml:space="preserve">
          <source>Tuples, all of whose component types have kind &lt;code&gt;Constraint&lt;/code&gt;. So for example the type &lt;code&gt;(Show a, Ord a)&lt;/code&gt; is of kind &lt;code&gt;Constraint&lt;/code&gt;.</source>
          <target state="translated">Кортежи, все типы компонентов которых имеют &lt;code&gt;Constraint&lt;/code&gt; вида . Так, например, тип &lt;code&gt;(Show a, Ord a)&lt;/code&gt; относится к типу &lt;code&gt;Constraint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208297b00f068e5585208c000785f0fce4f36c23" translate="yes" xml:space="preserve">
          <source>Tuples, lists, &lt;code&gt;Maybe&lt;/code&gt;, and all the other types from &lt;code&gt;Prelude&lt;/code&gt; continue to have their existing, lazy, semantics.</source>
          <target state="translated">Кортежи, списки, &lt;code&gt;Maybe&lt;/code&gt; и все другие типы из &lt;code&gt;Prelude&lt;/code&gt; продолжают иметь свою существующую ленивую семантику.</target>
        </trans-unit>
        <trans-unit id="253a3d85a1beb3288a473dc352f001b3960133ba" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; &amp;ldquo;update-frame squeezing&amp;rdquo; at garbage-collection time. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">Turn &lt;em&gt;от&lt;/em&gt; &amp;laquo;обновления кадра выдавливания&amp;raquo; во время сборки мусора. (Нет особо веских причин для его отключения, кроме как для обеспечения точности определенных данных, собранных в отношении количества входов преобразователя.)</target>
        </trans-unit>
        <trans-unit id="275633f17b4e4cf83d036cacf3592d3d73e3ed05" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; update frame squeezing on context switch. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ed6208974a650db0bd1f82cc0c70d6411a0c0e" translate="yes" xml:space="preserve">
          <source>Turn a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; into its initial &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">Превратите &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; в его первоначальное действие &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99920f5c3b939caebceea45731d8b9d3427458f2" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell expression, suitable for use in a splice.</source>
          <target state="translated">Превратите значение в выражение Шаблон Хаскелла,подходящее для использования в сплайсе.</target>
        </trans-unit>
        <trans-unit id="37562d7dab36ae171d42f81239370113e8ede575" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell typed expression, suitable for use in a typed splice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c10b159949d028b9e59ba53a57b08c8fed29bf" translate="yes" xml:space="preserve">
          <source>Turn an existing Handle into a file descriptor. This function throws an IOError if the Handle does not reference a file descriptor.</source>
          <target state="translated">Превратите существующий дескриптор ручки в дескриптор файла.Эта функция вызывает IOError,если дескриптор файла не указан.</target>
        </trans-unit>
        <trans-unit id="ff88efd554e6e2bbf0d6b57ed109bd14bff32a19" translate="yes" xml:space="preserve">
          <source>Turn an existing file descriptor into a Handle. This is used by various external libraries to make Handles.</source>
          <target state="translated">Превратите существующий дескриптор файла в дескриптор.Это используется различными внешними библиотеками для создания дескрипторов.</target>
        </trans-unit>
        <trans-unit id="af1ea6cee0d8a6d561bf79d4ae3fe34c934b40bb" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining</source>
          <target state="translated">Выключить предварительную настройку</target>
        </trans-unit>
        <trans-unit id="d635f6906b908f74109d28ae4ecba3d5b4cf43a2" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining.</source>
          <target state="translated">Выключите предварительную настройку.</target>
        </trans-unit>
        <trans-unit id="17471888502443f29d90093ff7b1d13417c48663" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing &lt;code&gt;.o&lt;/code&gt; file in place, if it can be determined that the module does not need to be recompiled.</source>
          <target state="translated">Отключите проверку перекомпиляции (по умолчанию она включена). Проверка перекомпиляции обычно останавливает компиляцию на раннем этапе, оставляя существующий файл &lt;code&gt;.o&lt;/code&gt; на месте, если можно определить, что модуль не нужно перекомпилировать.</target>
        </trans-unit>
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Отключите проверку перекомпиляции. Это подразумевается любой &lt;code&gt;-ddump-X&lt;/code&gt; при компиляции одного файла (т.е. при использовании &lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">Отключите &amp;laquo;взлом состояния&amp;raquo;, при котором любая лямбда с токеном &lt;code&gt;State#&lt;/code&gt; в качестве аргумента считается однократной, поэтому встраивание в нее вещей считается нормальным. Это может улучшить производительность кода монад ввода-вывода и ST, но рискует сократить совместное использование.</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">Выключить оптимизатор по принуждению</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">Выключите оптимизатор по принуждению.</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">Выключите взлом состояния любым лямбда с жетоном состояния в реальном мире в качестве аргумента считается однократным входом.Следовательно,можно встраивать вещи внутрь.</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">Включите &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;нетерпеливую черную дыру&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">Включите анализ ХРП в анализаторе спроса.</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите анализ СЛР в анализаторе спроса. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">Включить контрольно-измерительные приборы покрытия программы Хаскелла</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">Включите специализацию шаблонов вызовов; см. &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Специализацию шаблонов вызовов для программ Haskell&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">Включить отладочную печать (более подробный)</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите полную лень (плавающие привязки наружу). Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">Включите тяжелую внутрипроходную проверку работоспособности в GHC на базовом уровне. (Он проверяет вменяемость GHC, а не вашего.)</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">Включить проверку внутреннего здоровья</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">Включить печать результатов переплета в GHCi</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">Включить профилирование</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">Включить специализацию перегруженных функций,импортируемых из других модулей.</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">Включить специализацию перегруженных функций,независимо от их размера,если имеется возможность разворачивания</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите специализацию перегруженных функций. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">Включите анализ строгости. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; . Подразумевает &lt;code&gt;-fworker-wrapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите преобразование SpecConstr. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите всплывающее преобразование. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Включите преобразование освобожденного случая. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">Включите преобразование освобожденного случая. Это разворачивает рекурсивную функцию один раз в ее собственном RHS, чтобы избежать повторного анализа случаев свободных переменных. Это немного похоже на специализацию &lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt; ( -fspec-constr ), но для свободных переменных, а не аргументов.</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">Включите статическое преобразование аргументов, которое превращает рекурсивную функцию в нерекурсивную с локальным рекурсивным циклом. См. Главу 7 &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;докторской диссертации Андре Сантоса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">Включите преобразование статических аргументов.</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">Включить профилирование по тику-липучке</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Превратите насыщенные саморекурсивные хвостовые вызовы в локальные переходы в сгенерированной сборке. Подразумевается &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Превратите ошибки типа в предупреждения, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;отложив ошибку до времени выполнения&lt;/a&gt; . Подразумевает &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; . См. Также &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">Включение опции, которая включает специальный синтаксис, &lt;em&gt;может&lt;/em&gt; привести к сбою компиляции рабочего кода Haskell 98, возможно, из-за того, что он использует имя переменной, которое стало зарезервированным словом. В этом разделе перечислены синтаксисы, &amp;laquo;украденные&amp;raquo; языковыми расширениями. Мы используем нотацию и нетерминальные имена из лексического синтаксиса Haskell 98 (см. Отчет Haskell 98). Мы перечисляем здесь только синтаксические изменения, которые могут повлиять на существующие рабочие программы (т.е. &amp;laquo;украденный&amp;raquo; синтаксис). Многие из этих расширений также будут включать новый контекстно-свободный синтаксис, но во всех случаях программы, написанные с использованием нового синтаксиса, не будут компилироваться без включенной опции.</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">Чтобы превратить шаблоны в неопровержимые, требуется &lt;code&gt;~(~p)&lt;/code&gt; или &lt;code&gt;(~ ~p)&lt;/code&gt; когда включен &lt;code&gt;Strict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">Превращает простую ссылку на память во внешний объект, связывая финализатор, заданный монадической операцией, со ссылкой. Диспетчер хранилища запустит финализатор в отдельном потоке через некоторое время после отбрасывания последней ссылки на &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; . Нет никакой гарантии оперативности, и фактически нет никакой гарантии, что финализатор в конечном итоге вообще запустится.</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">Превращает простую ссылку на память во внешний объект, связывая финализатор, заданный монадической операцией, со ссылкой. Диспетчер хранилища запустит финализатор в отдельном потоке через некоторое время после отбрасывания последней ссылки на &lt;code&gt;ForeignPtr&lt;/code&gt; . Нет никакой гарантии оперативности, и фактически нет никакой гарантии, что финализатор в конечном итоге вообще запустится.</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Превращает простую ссылку на память во внешний указатель, который может быть связан с финализаторами с помощью &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Превращает простую ссылку на память во внешний указатель, который может быть связан с финализаторами с помощью &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Превращает простую ссылку на память во внешний указатель, который может быть связан с финализаторами с помощью &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">Превращает ссылку в обычную память в иностранный указатель,и связывает финализатор со ссылкой.Финишилизатор будет выполнен после того,как будет сброшена последняя ссылка на посторонний объект.Гарантии оперативности нет,однако финализатор будет выполнен до выхода программы из программы.</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">Отключает все текстовые атрибуты.Эта возможность всегда будет успешной,но она не действует в терминалах,которые не поддерживают текстовые атрибуты.</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">Отключает все предупреждения, включая стандартные и те, которые не включает &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">Включает все параметры предупреждений, указывающих на потенциально подозрительный код. Предупреждения, которые &lt;em&gt;не&lt;/em&gt; активированы &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">Включает режим полужирного начертания перед выводом заданного текста,а затем отключает все атрибуты.</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">Включает каждое предупреждение,поддерживаемое компилятором.</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">Включает режим ожидания перед выводом заданного текста,а затем выключает его.</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">Включает режим подчёркивания перед выводом заданного текста,а затем выключает его.</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">Включает предупреждения,которые будут включены по умолчанию в будущем,но пока остаются выключенными в обычных компиляциях.Это позволяет авторам библиотек стремиться в будущем сделать свой код совместимым,чтобы адаптироваться к новым возможностям еще до того,как они будут выдавать предупреждения.</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">Две опции командной строки управляют тем,читаются ли файлы запуска:</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">Две вещи,на которые нужно обратить внимание:</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">Два типа считаются раздельными,если при всех возможных заменах они не могут сводиться к общему сокращению.</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">Создается два типа сообщений: сообщения, начинающиеся с &lt;code&gt;***&lt;/code&gt; , обозначают начало фазы компиляции, а сообщения, начинающиеся с &lt;code&gt;!!!&lt;/code&gt; отмечают конец прохода и сопровождаются статистикой распределения и времени выполнения.</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">Тип Буквы</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">Аргументы типа можно заменить подчеркиванием ( &lt;code&gt;_&lt;/code&gt; ), если имена аргументов не имеют значения. Это то же самое, что и запись переменных типа с уникальными именами. Неиспользуемые аргументы типа можно заменить или &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; префиксом подчеркивания, чтобы избежать предупреждений, когда включен флаг -Wunused-type-patterns . Применяются те же правила, что и для &lt;a href=&quot;#data-instance-declarations&quot;&gt;объявлений экземпляров данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">Проверка типа позволит определить предполагаемые типы для отверстий.</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">Классы типов для провайдеров ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">Классы типов, которые требуют включения их собственных расширений, например &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#deriving-extra&quot;&gt;Получение экземпляров дополнительных классов (данные и т. Д.)&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">Конструктор типа, применяемый к типу, включающему для всех (если &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt; выключен)</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">Типовые конструкторы</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">Конструкторы типов и классы;Хаскелл пока имеет их в одноименном пространстве.</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">Равенство типов под forall не может быть отложено (например,Trac #14605).</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">Равенство типов</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">Семейства типов появляются в трех вкусах:(1)они могут быть определены как открытые семейства на верхнем уровне,(2)они могут быть определены как закрытые семейства на верхнем уровне,или (3)они могут появляться внутри классов типов (в этом случае они известны как синонимы ассоциированных типов).Семейства типов верхнего уровня являются более общими,так как в них отсутствует требование,чтобы индексы типов совпадали с параметрами класса.Однако,синонимы ассоциированных типов могут привести к более четко структурированному коду и предупреждениям компилятора,если некоторые экземпляры типов были-возможно,случайно-опущены.В дальнейшем мы всегда сначала обсудим общие формы верхнего уровня,а затем рассмотрим дополнительные ограничения,накладываемые на ассоциированные типы.Обратите внимание,что закрытых синонимов ассоциированных типов не существует.</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt; языковым расширением TypeFamilies . Дополнительная информация об использовании семейств типов в GHC доступна на &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;вики-странице Haskell, посвященной семействам типов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">Семейства типов требуют, чтобы мы расширили правила для формы заголовков экземпляров, которые приведены в &lt;a href=&quot;#flexible-instance-head&quot;&gt;упрощенных правилах для заголовков экземпляров&lt;/a&gt; . В частности:</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">Тип семья объявление не имеет правого, но GHC должен еще делать вывод вида для &lt;code&gt;F&lt;/code&gt; . Поскольку ограничений нет, он может вывести &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; , но это кажется &lt;em&gt;слишком&lt;/em&gt; полиморфным. Итак, GHC по умолчанию устанавливает для этих полностью неограниченных переменных &lt;code&gt;Type&lt;/code&gt; и мы получаем &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; . Вы по-прежнему можете объявить &lt;code&gt;F&lt;/code&gt; полиморфным добром, используя подписи вида:</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">Объявления экземпляров семейства типов являются законными только тогда,когда соответствующее объявление семейства находится в сфере действия-точно так же,как экземпляры классов требуют,чтобы объявление класса было видимым.Более того,каждая декларация экземпляра должна соответствовать типу,определяемому его декларацией семейства,а количество параметров типа в декларации экземпляра должно соответствовать количеству параметров типа в декларации семейства.Наконец,правая сторона экземпляра типа должна быть монотипом (т.е.он может не включать foralls),и после расширения всех насыщенных ванильных синонимов типа,синонимов,за исключением синонимов семейства,не может оставаться.</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">Результат семейства типов</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">Введите подпись результата семейства</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">Типовые отверстия в типизированных стыках (см. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Выпуск № 10945&lt;/a&gt; и &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;№ 10946&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="276b31a5f89d022c33dce55c2768f21e907ef802" translate="yes" xml:space="preserve">
          <source>Type lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">Тип устройства , которое может быть использовано для возврата &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (смотрите также &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; ). Стандартные библиотеки обеспечивают создание &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; с помощью файловых операций Posix с дескрипторами файлов (см &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; ) с FD является основным &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; экземпляром.</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">Тип функции,которая будет разобрать символы модификаторов из строки формата.</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">Типовые представления</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">Тип, представляющий &lt;em&gt;необработанные&lt;/em&gt; Naturals произвольной точности</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">Тип,представляющий GMP Limb</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">Тип,представляющий собой целые числа с произвольной точностью без отрицательных значений.</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">Типы сращиваний:в типовых сращиваниях поддерживаются только анонимные подстановочные знаки.Символы подстановки с именами и дополнительными ограничениями не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">Семейства синонимов типа могут отсутствовать (вообще)в заголовке экземпляра.</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Введите синоним для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Введите синоним для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Введите синоним для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Синоним типа &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Введите синоним для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Введите синоним для &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">Синоним типа для кодирования мета-информации для конструкторов</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">Синоним типа для кодирования мета-информации для типов данных</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">Синоним типа для кодирования мета-информации для селекторов записей</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">Синоним типа для кодирования рекурсии (вида &lt;code&gt;Type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">Синонимы типа</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">Синонимы типов похожи на макросы на уровне типов, но Haskell 98 налагает множество правил на объявления отдельных синонимов. С расширением &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt; GHC выполняет проверку достоверности типов &lt;em&gt;только после &lt;/em&gt;раскрытия&lt;em&gt; синонимов типов&lt;/em&gt; . Это означает, что GHC может быть более либеральным в отношении синонимов типов, чем Haskell 98.</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">Подстановочные знаки типа также могут быть названы указанием идентификатора подчеркивания в виде суффикса, то есть &lt;code&gt;_a&lt;/code&gt; . Они называются &lt;em&gt;именованными подстановочными знаками&lt;/em&gt; . Все вхождения одного и того же подстановочного знака в сигнатуре одного типа будут объединены в один и тот же тип. Например:</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">Проверка типа и переименование</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">Ограничения по классу типа и неявным параметрам</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">Введите &quot;и&quot; на уровне типа</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">Уровень типа &amp;laquo;не&amp;raquo;. Семейство инъективных типов, начиная с &lt;code&gt;4.10.0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">Введите уровень &quot;или&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">Типового уровня &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt; . &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">Типовое безопасное литьё</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">Безопасная кастинг,использующая равенство предложений</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">Безопасная кастинг,с использованием репрезентативного равенства</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="40fb2a246a44fdd76a25bc4dee91c9b12c42ad29" translate="yes" xml:space="preserve">
          <source>Typeclass</source>
          <target state="translated">Typeclass</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Класс типов значений, форматируемых &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; . Метод &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; принимает значение и дескриптор формата поля и либо завершается ошибкой из-за неправильного дескриптора, либо в результате выдает &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; . По умолчанию &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; не требует модификаторов: это нормальный случай. Минимальный экземпляр: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">Типизированные выражения splices:поддерживаются те же подстановочные знаки,что и в (нетиповых)выражениях splices.</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">Типовые выражения</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">Типизированные дыры - это функция GHC, которая позволяет использовать в качестве выражений специальные заполнители, записанные с &lt;code&gt;_foo&lt;/code&gt; подчеркиванием (например, &amp;laquo; &lt;code&gt;_&lt;/code&gt; &amp;raquo;, &amp;laquo; _foo &amp;raquo;, &amp;laquo; &lt;code&gt;_bar&lt;/code&gt; &amp;raquo;). Во время компиляции эти дыры будут генерировать сообщение об ошибке, в котором описывается, какой тип ожидается в расположении дыры, информация о происхождении любых переменных свободного типа и список локальных привязок, которые могут помочь заполнить дыру, и привязки в области, соответствующие типу дыры, которая может помочь заполнить дыру реальным кодом. Типизированные отверстия всегда включены в GHC.</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">Типы и функции для UTC и UT1</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">Типы и функции для работы с ошибками кодирования и декодирования текста в Unicode.</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">Типы для ссылки на удаленные объекты в Remote GHCi. Для получения дополнительных сведений см. Примечание [Внешние указатели &lt;em&gt;GHCi&lt;/em&gt; ] в компиляторе &lt;em&gt;ghci&lt;/em&gt; GHCi.hs.</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">Типы для указания,как не удается кодирование/декодирование текста</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">Типы ошибок ввода/вывода</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">Типы и ограничения классов могут быть написаны в виде инффикса.Например</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Типичное использование: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Типичное использование: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">Обычно GHCi показывает только количество модулей, загруженных после команды &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; . С этим флагом GHC также перечислит имена загруженных модулей. Это было поведение по умолчанию до GHC 8.2.1 и может быть полезно для некоторых пользователей инструментов.</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">Обычно этот класс &lt;code&gt;GSerialize&lt;/code&gt; не экспортируется, поскольку имеет смысл иметь экземпляры только для типов представления.</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">Ввод &lt;code&gt;:def&lt;/code&gt; самостоятельно выводит список определенных в данный момент макросов. Попытка переопределить существующее имя команды приводит к ошибке, если &lt;code&gt;:def!&lt;/code&gt; form, и в этом случае старая команда с таким именем автоматически перезаписывается.</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">Ввод: Если ⟨exp⟩ имеет тип ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ и pat⟩ соответствует T2⟩, то весь шаблон представления соответствует T1⟩.</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">форматирование в UNIX-стиле</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">синтаксический анализ</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">переменная окружения USERPROFILE.</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">UTC-это время,измеренное часами,скорректированное для того,чтобы идти в ногу с землей путем добавления или удаления случайных секунд,известных как &quot;високосные секунды&quot;.Эти поправки не предсказуемы и объявляются с уведомлением за шесть месяцев.Таблица этих исправлений не предоставляется,так как любая программа,составленная с ее помощью,через шесть месяцев устареет.</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16 (используется в системах Windows).</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">UTF-16 Кодеки для библиотеки ввода-вывода</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">Суррогатные кодовые точки UTF-16 не включены в набор скалярных значений Unicode, но, к сожалению, признаны Haskell как допустимые значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; . Они не могут быть представлены в &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; . Эта функция переназначает эти кодовые точки на заменяющий символ Юникода (U + FFFD, '') и оставляет другие кодовые точки без изменений.</target>
        </trans-unit>
        <trans-unit id="62cdcaea7e563aff141140dcd64fe723c057ad8d" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32 (компилятор C определяет &lt;code&gt;201605L&lt;/code&gt; ) или</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">UTF-32 Коды для библиотеки ввода-вывода</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">UTF-8 Кодек для библиотеки ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8 кодирует &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8 кодирует &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">Унарное отрицание.</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">Унарное отрицание. Поскольку отрицательный диапазон &lt;code&gt;Int#&lt;/code&gt; расширяется на единицу дальше положительного диапазона, &lt;code&gt;negateInt#&lt;/code&gt; самого отрицательного числа является операцией идентификации. Таким образом, &lt;code&gt;negateInt#&lt;/code&gt; всегда обратный.</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">Конструкторы несвязанных данных, используемые в выражениях, ведут себя точно так же, как указано выше. Однако несвязанные конструкторы данных, используемые в &lt;em&gt;шаблонах,&lt;/em&gt; нельзя отложить и вместо этого остановить компиляцию. (С точки зрения реализации, о них сообщает средство переименования, а не средство проверки типов.)</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">Несвязанные идентификаторы с одним и тем же именем никогда не объединяются,даже в рамках одной и той же функции,а отображаются индивидуально.Например:</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">Неограниченные каналы.</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">Небоксовые массивы</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">Непрерывные массивы.</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">Непоставленные типы представления</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">Конструктор данных некорректной суммы</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">Конструктор типа Unboxed sum</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">Распакованные суммы &amp;laquo;распакованы&amp;raquo; в том смысле, что вместо распределения сумм в куче и представления значений в виде указателей распакованные суммы представлены как их компоненты, как распакованные кортежи. Эти &amp;laquo;компоненты&amp;raquo; зависят от альтернатив типа суммы. Как и распакованные кортежи, распакованные суммы ленивы в своих поднятых компонентах.</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">Непоставленный конструктор данных кортежа</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">Небоксовый конструктор типа кортежа</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">Распакованные кортежи используются для функций, которым необходимо возвращать несколько значений, но они избегают выделения кучи, обычно связанного с использованием полноценных кортежей. Когда возвращается распакованный кортеж, компоненты помещаются непосредственно в регистры или в стек; сам распакованный кортеж не имеет составного представления. Многие из примитивных операций, перечисленных в &lt;code&gt;primops.txt.pp&lt;/code&gt; , возвращают распакованные кортежи. В частности, монады &lt;code&gt;IO&lt;/code&gt; и &lt;code&gt;ST&lt;/code&gt; используют распакованные кортежи, чтобы избежать ненужного выделения во время последовательностей операций.</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">Распакованные кортежи на самом деле не экспортируются &lt;code&gt;GHC.Exts&lt;/code&gt; ; они являются синтаксическим расширением ( &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; ). Распакованный кортеж выглядит так:</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">Некоробочные кортежи могут быть использованы для альтернатив с несколькими значениями полярности.Например:</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">Распакованные типы соответствуют типам &amp;laquo;сырых машин&amp;raquo;, которые вы использовали бы в C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *) и т. Д. &lt;em&gt;Примитивные операции&lt;/em&gt; (PrimOps) с этими типами - это то, что вы можно было ожидать; например, &lt;code&gt;(+#)&lt;/code&gt; - это сложение для &lt;code&gt;Int#&lt;/code&gt; и машинное добавление, которое мы все знаем и любим - обычно это одна инструкция.</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">бесконтрольный доступ</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">неконтролируемая арифметика с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">Неконтролируемое чтение непреложного массива.Может вернуть мусор или упасть при несанкционированном доступе.</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">Неконтролируемая запись мутирующего массива.Может вернуть мусор или упасть при несанкционированном доступе.</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">Отключите список подходящих отверстий,не показывая происхождение или типовые приложения предложений.</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">Неопределите символ в препроцессоре С.</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">Неопределенный макрос ⟨symbol⟩ обычным способом.</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">Отменяет определение определяемой пользователем команды ⟨name⟩ (см . &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; выше).</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">Под &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; &lt;/a&gt; , А &lt;code&gt;*&lt;/code&gt; типов не является оператором , ни даже имени, это специальный синтаксис , который стоит за &lt;code&gt;Data.Kind.Type&lt;/code&gt; . Это означает, что выражение типа &lt;code&gt;Either * Char&lt;/code&gt; анализируется как &lt;code&gt;Either (*) Char&lt;/code&gt; а не &lt;code&gt;(*) Either Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">В GHC 6.10 и более ранних версиях системные библиотеки ввода/вывода /не поддерживают/локально-чувствительный ввод/вывод или преобразование в конце строки.В этих версиях GHC все функции этой библиотеки используют UTF-8.Что это означает на практике?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">В GHC 6.10 и более ранних версиях системные библиотеки ввода/вывода не поддерживают локально-чувствительный ввод/вывод или преобразование в конце строки.В этих версиях GHC все функции этой библиотеки используют UTF-8.Что это означает на практике?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">При GHC правило перезаписи преобразует break (==)в вызов специализированного breakByte:</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">В Mac OS X отладочная информация хранится отдельно от исполняемого файла. После компиляции исполняемого файла вам нужно будет использовать утилиту &lt;code&gt;dsymutil&lt;/code&gt; , чтобы извлечь отладочную информацию и поместить ее в архив отладки,</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">В большинстве случаев,вы не можете использовать автономное получение для создания экземпляра для типа данных,конструкторы которого не все в области видимости.Это связано с тем,что производный экземпляр будет генерировать код,использующий конструкторы за кулисами,что нарушит абстракцию.</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="c982cc09160648fab8b183af5c0c2149ea73000b" translate="yes" xml:space="preserve">
          <source>Underlying untyped Template Haskell expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">Разворачивающийся БайтСтрингс</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">Развертывание конструкторов</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">К сожалению, DWARF недостаточно выразителен, чтобы полностью описать код, создаваемый GHC. Это наиболее очевидно в случае линейной информации, когда GHC вынужден выбирать что-то из множества возможных мест происхождения источников. Это ограничивает полезность информации DWARF с традиционными инструментами статистического профилирования. Для профилирования рекомендуется использовать расширенную отладочную информацию. См. Раздел &amp;laquo; &lt;em&gt;Профилирование&lt;/em&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">К сожалению нет. Мы его еще не реализовали. Пожалуйста, скомпилируйте любые вызывающие ошибку модули вручную, прежде чем загружать их в GHCi.</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">Общие категории Юникода (столбец 2 таблицы UnicodeData)в том порядке,в котором они перечислены в стандарте Юникод (в частности,в Базе данных символов Юникода).</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">Однокодовые римские цифры тоже &quot;числа&quot;:</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">Альтернатива Юникода</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">Символы уникода делятся на буквы,цифры,знаки препинания,символы,разделители (включая пробелы)и другие (включая управляющие символы).</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">кодирование/декодирование Юникода</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">Юникод кодировки</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">Юникод общие категории</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">Однонаправленные синонимы могут использоваться только в контексте шаблона и определяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">Равномерный &lt;code&gt;callCC&lt;/code&gt; операции callCC на новую монаду. Эта версия возвращается к исходной истории вывода при входе в продолжение.</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">Равномерный &lt;code&gt;callCC&lt;/code&gt; операции callCC на новую монаду. Эта версия возвращается в исходное состояние при входе в продолжение.</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">Необитаемый тип данных</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">Уникальный индекс для конструкторов типа данных,отсчитываемый от 1 в порядке их указания в тексте программы.</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">Уникальные предметы</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">Модуль:используется для конструкторов без аргументов</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">Вселенское время</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">Универсальная комбинирующая функция</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">Unix-системы</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">Если не задокументировано обратное:</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="5b45d2b7d96fbef96a9bc758815c76e0e2e71a5f" translate="yes" xml:space="preserve">
          <source>UnliftedNewtypes</source>
          <target state="translated">UnliftedNewtypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; не может использоваться для типов данных, содержащих тип функции с правой стороны.</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; не подразумевает &lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt; . Обоснование этого решения состоит в том, что, в отличие от имен шаблонов на уровне терминов, имена типов часто выбираются специально для целей документации, поэтому использование подчеркивания в именах типов может затруднить чтение документации.</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#typed-holes&quot;&gt;типизированных отверстий&lt;/a&gt; , которые делают программу неполной и генерируют ошибки при их оценке, это не обязательно касается дыр в сигнатурах типов. Средство проверки типов может (в большинстве случаев) проверять привязку с подписью типа или без нее. Сигнатура частичного типа устраняет разрыв между двумя крайностями, программист может выбрать, какие части типа аннотировать, а какие оставить на усмотрение контролера типов.</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">В отличие от &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; , эта опция НЕ приводит к связыванию пакета &amp;laquo;pkg&amp;raquo; с результирующим исполняемым или общим объектом.</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; , эта функция не выполняет декодирование аргументов Unicode; вы получите точные байты, которые были переданы программе ОС. Чтобы интерпретировать аргументы как текст, необходимо применить декодирование Unicode.</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; , это можно использовать для извлечения элемента без его принуждения. Например, чтобы вставить пятый элемент последовательности &lt;code&gt;xs&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; с ключом &lt;code&gt;k&lt;/code&gt; , вы можете использовать</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; типов Par1 и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; не сопоставляются с &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; . Они определяются напрямую следующим образом:</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; относится к строгости, которую компилятор выбирает для поля конструктора данных, которая может отличаться от того, что написано в исходном коде. См. &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; относится к строгости, которую компилятор выбирает для поля конструктора данных, которая может отличаться от того, что написано в исходном коде. См. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; , эта возможность никогда не перестает работать ; он возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , если возможность отсутствует или имеет значение false, и возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">В отличие от &lt;code&gt;INLINE&lt;/code&gt; , можно использовать прагму &lt;code&gt;INLINABLE&lt;/code&gt; для рекурсивной функции. Основная причина сделать это, чтобы в дальнейшем можно было использовать &lt;code&gt;SPECIALISE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">В отличие от C &lt;code&gt;printf(3)&lt;/code&gt; , форматирование этого &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; определяется типом аргумента; форматирование зависит от типа. Типы, форматируемые &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;из коробки&quot;:</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">В отличие от &lt;code&gt;deriving&lt;/code&gt; объявления, прикрепленного к объявлению &lt;code&gt;data&lt;/code&gt; , GHC не ограничивает форму типа данных. Вместо этого GHC просто генерирует соответствующий шаблонный код для указанного класса и проверяет его тип. Если есть ошибка типа, это ваша проблема. (GHC покажет вам код нарушения, если в нем есть ошибка типа.)</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">В отличие от &lt;code&gt;deriving&lt;/code&gt; объявления, прикрепленного к объявлению &lt;code&gt;data&lt;/code&gt; , экземпляр может быть более конкретным, чем тип данных (при условии, что вы также используете &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed правила для контекстов экземпляра&lt;/a&gt; ). Рассмотрим, например,</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">В отличие от объявления типа данных в стиле Haskell-98, переменные типа в заголовке &amp;laquo; &lt;code&gt;data Set a where&lt;/code&gt; &amp;raquo; не имеют области видимости. Действительно, вместо этого можно написать добрую подпись:</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">В отличие от сигнатур выражений и объявлений, сигнатуры шаблонных типов не являются неявно обобщенными. Шаблон в &lt;em&gt;привязке шаблона&lt;/em&gt; может упоминать только те переменные типа, которые уже находятся в области видимости. Например:</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; , экземпляр &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; относится к &lt;code&gt;encode'&lt;/code&gt; , а не к &lt;code&gt;encode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">В отличие от обычных соединений объявления в форме &lt;code&gt;$(...)&lt;/code&gt; , квазиквоты объявления не вызывают разрыва группы объявлений. Смотрите &lt;a href=&quot;#th-syntax&quot;&gt;Синтаксис&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">В отличие от обычных соединений объявлений, квазиквотеры объявлений не вызывают разрыва. Эти квазиквотеры раскрываются перед обработкой остальной части группы объявлений, а генерируемые ими объявления объединяются в окружающую группу объявлений. Следовательно, среда типов, которую видит &lt;code&gt;reify&lt;/code&gt; из квазиквотера объявления, не будет включать ничего из группы объявлений квазиквотера.</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">В отличие от других деклараций,для которых в область применения попадают только декларированные в файле сигнатур объекты,экземпляры из реализации всегда попадают в область применения,даже если они не были декларированы в файле сигнатур.Это означает,что модуль может проводить проверку по сигнатуре,но не по соответствующей реализации.Вы можете избежать подобных ситуаций,никогда не определяя отдельные экземпляры внутри пакета,который имеет подписи.</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">В отличие от других функций удаления,эта функция также будет пытаться удалить файлы,помеченные как файлы,доступные только для чтения,или иным образом не удаляемые из-за прав доступа.В результате,если удаление будет неполным,права или атрибуты на оставшихся файлах могут быть изменены.Если в каталоге имеются жесткие ссылки,то права на все связанные с ними жесткие ссылки могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">В отличие от других функций с похожими именами, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; не использует &lt;code&gt;SearchPath&lt;/code&gt; из Win32 API. Следовательно, поведение этой функции в Windows эквивалентно поведению на платформах, отличных от Windows.</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">В отличие от обычных модулей, определенные объекты сигнатуры включают не только те, которые записаны в локальном файле &lt;code&gt;hsig&lt;/code&gt; , но также и те из унаследованных сигнатур (как следует из флагов &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; ). Эти сущности не рассматриваются в области видимости при проверке типа локального файла &lt;code&gt;hsig&lt;/code&gt; , но доступны для импорта любым модулем или сигнатурой, которая импортирует сигнатуру. Единственным исключением из этого правила является список экспорта, описанный ниже.</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">В отличие от &lt;code&gt;forall&lt;/code&gt; формы, типа переменной &lt;code&gt;a&lt;/code&gt; из &lt;code&gt;f&lt;/code&gt; &amp;laquo;подпись s не над областью видимости &lt;code&gt;f&lt;/code&gt; &amp;raquo; ы уравнение (ы). Переменная типа &lt;code&gt;aa&lt;/code&gt; , связанная с сигнатурой образца, ограничена правой частью уравнения &lt;code&gt;f&lt;/code&gt; . (Следовательно, нет необходимости использовать переменную отдельного типа; использование &lt;code&gt;a&lt;/code&gt; было бы эквивалентно.)</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">В отличие от самого объявления связанного семейства типов,переменные типа экземпляра по умолчанию не зависят от переменных родительского класса.</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">В отличие от определения &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; по умолчанию , он определен для 0 и поэтому должен быть предпочтительным там, где это возможно.</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">В отличие от обычных определений данных, тип результата семейства данных не обязательно должен быть &lt;code&gt;Type&lt;/code&gt; : в качестве альтернативы он может быть переменной вида (с &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ). Однако типы экземпляров данных должны заканчиваться на &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">Маловероятно :-) Еще &lt;code&gt;-dcore-lint&lt;/code&gt; полезная параноидальная опция для GHC - это опция -dcore-lint -dcore-lint; это вызывает проход &amp;laquo;lint&amp;raquo; для проверки ошибок (особенно ошибок типа) после каждого прохода преобразования ядра в ядро. Мы все время работаем с &lt;code&gt;-dcore-lint&lt;/code&gt; ; время компиляции составляет около 5%.</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">Открой семафор.</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">Распакуйте элементы вектора в неоткрытый кортеж.#</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">Поля конструктора распаковки должны использоваться только в сочетании с &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt; , чтобы раскрыть развертки компилятору, чтобы переупаковку можно было удалять как можно чаще. Например:</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">Отключить активный тайм-аут.</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">Незарегистрированная компиляция может быть полезна при переносе GHC на новую машину, поскольку она сокращает необходимые инструменты до &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; , &lt;code&gt;ld&lt;/code&gt; и ничего более, и, кроме того, количество специфичного для платформы кода, которое необходимо написать, чтобы получить незарегистрированную компиляцию. собирается обычно довольно мало.</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">Незарегистрированная компиляция не может быть выбрана во время компиляции;необходимо собрать GHC с соответствующим набором опций.Для получения подробной информации обратитесь к Руководству по сборке GHC.</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">Небезопасный &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; индекса (подстрочного индекса) ByteString , начиная с 0, возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; . Это пропускает проверку границ, что означает, что программист несет сопутствующее обязательство обеспечить проверку границ каким-либо другим способом.</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">Небезопасные операции &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">Небезопасный API только.</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">Небезопасный API.</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">Небезопасные операции ввода-вывода</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">Небезопасное преобразование между &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; . Это не работает, и оно автоматически обрезается до 8-битных символов&amp;gt; '255'. Он предоставляется для удобства построения ByteString.</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">Небезопасный код преобразования</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">Небезопасное преобразование десятичных цифр.</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">Небезопасные функции</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">Небезопасная общая комбинирующая функция</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">Небезопасные низкоуровневые операции</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">небезопасная работа</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">Небезопасное,машинное атомное сравнение и замена элемента в массиве.</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">Небезопасное атомное сравнение на машинном уровне и замена элемента в массиве.</target>
        </trans-unit>
        <trans-unit id="da875dda0af919ad5cb1b82f3bb406408186e93d" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array. See the documentation of &lt;code&gt;casArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">Небезопасно выполняет IO в STM monad.Будьте осторожны:это очень опасная вещь.</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">Отменяет определенные параметры. См &lt;a href=&quot;#ghci-set&quot;&gt;.&lt;/a&gt; Список доступных параметров в командах: set и: seti .</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">Беззнаковые целочисленные типы.</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">Беззнаковые интегральные типы</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">Нестабильные выпуски моментальных снимков называются &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; . где &lt;code&gt;YYYYMMDD&lt;/code&gt; - дата источников, из которых был создан снимок. Например, &lt;code&gt;6.7.20040225&lt;/code&gt; будет снимком HEAD перед созданием ветви &lt;code&gt;6.8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление монады состояния как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление монады состояния как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление монады состояния как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление монады состояния как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление писателя. ( &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWS как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWS как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWS как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWS как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWS как функцию. (Обратное &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление RWST как функцию. (Обратное к &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Разверните вычисление накопления как пару (результат, вывод). (Обратное к &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">Разверните расчеты по накоплению.</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">Расстегнуть последовательность пар.</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">Обновить исходную позицию для данного персонажа. Если символ представляет собой новую строку ('\ n') или возврат каретки ('\ r'), номер строки увеличивается на 1. Если символ представляет собой табуляцию ('t'), номер столбца увеличивается до ближайшего 8 ' -й столбец, т.е. &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; . Во всех остальных случаях столбец увеличивается на 1.</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">Обновить активный таймаут для запуска в заданное количество микросекунд.</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">Используйте &amp;laquo; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &amp;raquo;, чтобы вычислить точное количество байтов, записанных заранее для &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; . В случае &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; будет записывать и сообщать о нулевых записанных байтах, тогда как &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; сообщает об одном байте.</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">Используйте &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; ,&lt;/a&gt; чтобы выбрать программу для использования в качестве препроцессора. При вызове препроцессору cmd⟩ в командной строке передается как минимум три аргумента: первый аргумент - это имя исходного исходного файла, второй - имя файла, содержащего входные данные, а третий - имя файла, в который cmd⟩ должен записывать свой вывод.</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">Используйте &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt; или -ddump-rule-rewrites, чтобы детально увидеть, какие правила запускаются . Если вы добавите &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt; вы получите еще более подробный список.</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">Используйте &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; ,&lt;/a&gt; чтобы увидеть правила, определенные &lt;em&gt;в этом модуле&lt;/em&gt; . Это включает правила, созданные на этапе специализации, но исключает правила, импортированные из других модулей.</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">Используйте &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt; чтобы увидеть, какие правила запускаются . Если вы добавите &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt; вы получите более подробный список.</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; и избегайте прерывания работы. Для этого мы должны знать, какие операции можно прервать. Невозможно узнать для какой-либо данной библиотечной функции, может ли она вызвать внутренне прерываемую операцию; поэтому вместо этого мы приводим ниже список гарантированно непрерываемых операций.</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; . Обычно это не рекомендуется, если только вы не можете гарантировать, что любые прерываемые операции, вызванные во время &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; могут блокироваться только на короткое время. В противном случае &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; - хороший способ завести вашу программу в тупик и не реагировать на прерывания пользователя.</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; , чтобы избежать этой проблемы.</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; чтобы получить поведение &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; чтобы получить поведение &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; из &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">Используйте &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; в качестве прагмы для любой функции &lt;code&gt;foo&lt;/code&gt; , которая вызывает &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Если вызов является встроенным, ввод-вывод может выполняться более одного раза.</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">Используйте &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; в качестве прагмы для любой функции &lt;code&gt;foo&lt;/code&gt; , которая вызывает &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Если вызов является встроенным, ввод-вывод может выполняться более одного раза.</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">Используйте &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; в качестве прагмы для любой функции &lt;code&gt;foo&lt;/code&gt; , которая вызывает &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; . Если вызов является встроенным, ввод-вывод может выполняться более одного раза.</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">Используйте &lt;strong&gt;полосу&lt;/strong&gt; для своих исполняемых файлов.</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">Используйте &lt;a href=&quot;codegens#native-code-gen&quot;&gt;генератор собственного кода&lt;/a&gt; GHC вместо компиляции через LLVM. &lt;code&gt;-fasm&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">Используйте расширенные правила GHCi по умолчанию в обычном модуле.</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">Используйте STM.Поскольку транзакция всегда либо полностью выполнена,либо не выполнена вовсе,то при наличии асинхронных (и,действительно,синхронных)исключений транзакции являются хорошим способом поддержания инвариантов over state.</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">Используйте &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; как &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; свидетельство.</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">Используй большую кучу!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">Используйте алгоритм уплотнения для сбора данных старого поколения.По умолчанию самое старое поколение собирается с помощью алгоритма копирования;эта опция приводит к его уплотнению на месте.Алгоритм уплотнения медленнее,чем алгоритм копирования,но экономия расхода памяти может быть значительной.</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">Используйте более медленный,но лучший алгоритм для ApplicativeDo.</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">Используйте маленькую рамку для названия.</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">Используйте трансформатор специального спроса для селекторов словарей.</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">Используйте трансформатор специального спроса для селекторов словарей.По умолчанию всегда включен.</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">Используйте явно выраженную подпись типа на выражении записи,как в:</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">Использовать цвета в сообщениях об ошибках</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">Используйте текущий каталог для файла истории команд &lt;code&gt;.ghci-history&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">Используйте десятичное представление для значений от &lt;code&gt;0.1&lt;/code&gt; до &lt;code&gt;9,999,999&lt;/code&gt; , в противном случае - экспоненциальное представление.</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте взаимодействие в файловом стиле, считывая ввод с заданного &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babd2ff76089a3d1f8aa9f2a697eb17aef342e31" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">Используйте взаимодействие в стиле файла,читая входные данные из данного файла.</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">Используйте зарубежные экспортные декларации для экспорта функций Haskell,которые вы хотите вызвать извне.Например:</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте это как ограничение ресурса. См. &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте это как ограничение ресурса. См. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте это как ограничение ресурса. См. &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте его как простой механизм профилирования с помощью &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте его как простой механизм профилирования с помощью &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Используйте его как простой механизм профилирования с помощью &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">Используйте балансировку нагрузки в параллельном GC в генерации ⟨gen⟩ и выше.При отсутствии ⟨gen⟩ балансировка нагрузки отключается полностью.</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">Используйте больше памяти:</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">Использование этого типа не поощряется.Обратите внимание на следующую эквивалентность:</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">Используйте параллельные GC в генерации ⟨gen⟩ и выше.Упуская ⟨gen⟩,параллельный GC отключается полностью,возвращаясь к последовательному.</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">Используйте posix setgid для установки идентификатора группы дочерних процессов;ничего не делает на других платформах.</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">Используйте posix setid,чтобы начать новый процесс в новой сессии;ничего не делает на других платформах.</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">Используйте posix setuid для установки идентификатора пользователя дочернего процесса;ничего не делает на других платформах.</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">Используйте предыдущие параметры. По умолчанию график PostScript автоматически масштабируется как по горизонтали, так и по вертикали, чтобы заполнить страницу. Однако при подготовке серии графиков для использования в презентации часто бывает полезно нарисовать новый график, используя тот же масштаб, оттенок и порядок, что и предыдущий. &lt;code&gt;-p&lt;/code&gt; флаг заставляет граф быть нарисован с использованием параметров , определенных при предыдущем запуске &lt;code&gt;hp2ps&lt;/code&gt; на &lt;code&gt;file&lt;/code&gt; . Они извлекаются из &lt;code&gt;file@.aux&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">Использовать статические библиотеки Haskell</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">Используйте примечания со строгостью:</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">По возможности используйте взаимодействие в стиле терминала, даже если &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; и / или &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; не являются терминалами.</target>
        </trans-unit>
        <trans-unit id="6c701d48b2ddc2ad9f38319eaef995257ab48d8b" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">Используйте &lt;a href=&quot;codegens#native-code-gen&quot;&gt;генератор машинного кода&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">Используйте &lt;code&gt;MonadFail.fail&lt;/code&gt; вместо наследства &lt;code&gt;Monad.fail&lt;/code&gt; функцию при desugaring опровержимых шаблонов в &lt;code&gt;do&lt;/code&gt; блоков.</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">Используйте средства привязки ОС, чтобы попытаться привязать потоки ОС к ядрам ЦП.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
