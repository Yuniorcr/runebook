<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; получает три аргумента, он встроен в сайт вызова. Следовательно, вы должны использовать &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; только для определения пользовательских функций комбинирования. Например, вы могли бы определить &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; даны три аргумента, оно встроено в сайт вызова. Чтобы предотвратить чрезмерное встраивание, вы обычно должны использовать &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; для определения ваших пользовательских функций комбинирования.</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; получает три аргумента, он встроен в сайт вызова. Чтобы предотвратить чрезмерное встраивание, обычно следует использовать &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; только для определения пользовательских функций комбинирования.</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; даны три аргумента, оно встроено в сайт вызова. Чтобы предотвратить чрезмерное встраивание, вы обычно должны использовать &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; для определения ваших пользовательских функций комбинирования.</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; получает три аргумента, он встроен в сайт вызова. Чтобы предотвратить чрезмерное встраивание, обычно следует использовать &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; только для определения пользовательских функций комбинирования.</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; получает три аргумента, он встроен в сайт вызова. Следовательно, вы должны использовать &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; только для определения пользовательских функций комбинирования. Например, вы могли бы определить &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;DeriveAnyClass&lt;/code&gt; включен, используйте &lt;code&gt;anyclass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; включен и мы производим новый тип, используйте &lt;code&gt;newytype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">Когда &lt;code&gt;mappend x x = x&lt;/code&gt; , это определение должно быть предпочтительным, потому что оно работает в O (1), а не в O (log n)</target>
        </trans-unit>
        <trans-unit id="385ace8105515b932625b88764546dcae18aded8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">Когда &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; , это определение должно быть предпочтительным, потому что оно работает в O (1), а не в O (log n).</target>
        </trans-unit>
        <trans-unit id="01dfa1f0b575553478bb02cbc1f8d40024bd7518" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">Когда GHC не может найти экземпляр для класса, он отображает короткий список некоторых из известных ему экземпляров. С этим флагом он печатает &lt;em&gt;все известные&lt;/em&gt; ему экземпляры.</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">Когда GHC компилирует модуль (скажем, &lt;code&gt;M.hs&lt;/code&gt; ), который использует &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; &lt;code&gt;foreign export&lt;/code&gt; или внешнего импорта , он генерирует &lt;code&gt;M_stub.h&lt;/code&gt; для использования его программами на языке C.</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">Когда GHC построен в незарегистрированном режиме, будут доступны только генераторы кода LLVM и C. Генератора нативного кода не будет. LLVM обычно предлагает существенное преимущество в производительности по сравнению с серверной частью C в незарегистрированном режиме.</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">Когда GHC используется для компиляции файлов C, GHC добавляет пути включения пакетов и напрямую включает &lt;code&gt;ghcversion.h&lt;/code&gt; . Компилятор будет искать путь к файлу &lt;code&gt;ghcversion.h&lt;/code&gt; из пакета &lt;code&gt;rts&lt;/code&gt; в базе данных пакетов. В некоторых случаях база данных пакетов компилятора не содержит пакета &lt;code&gt;rts&lt;/code&gt; или нужно указать конкретный &lt;code&gt;ghcversions.h&lt;/code&gt; для включения. Этот параметр можно использовать для указания пути к файлу &lt;code&gt;ghcversions.h&lt;/code&gt; , который нужно включить. Это в первую очередь предназначено для использования системой сборки GHC.</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">Когда GHC пытается разрешить, скажем, ограничение &lt;code&gt;C Int Bool&lt;/code&gt; , он пытается сопоставить каждое объявление экземпляра с ограничением, создавая экземпляр заголовка объявления экземпляра. Рассмотрим эти объявления:</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">Когда GHCi останавливается в точке останова и выражение, введенное в подсказке, запускает вторую точку останова, новая точка останова становится &amp;laquo;текущей&amp;raquo;, а старая сохраняется в стеке. Таким образом может быть создано произвольное количество контекстов точек останова. Например:</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">При запуске ГХ все запущенные резьбы мутатора должны быть остановлены и синхронизированы.Период между запуском ГХ и остановкой всех потоков мутатора называется фазой синхронизации ГХ.Если эта фаза занимает много времени (считается,что она длится дольше 1 мс),то это может серьезно повлиять на общую пропускную способность.</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">Когда программа, скомпилированная с помощью GHC, запускается с параметром &lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS, она генерирует файл с именем &lt;code&gt;prog.prof&lt;/code&gt; . В этом случае файл будет содержать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="1f106b54cbaaef2571f93c8d0393bd0f543851ad" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb500e0f063ff278c253fad2463e930413ad240" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">Когда встречается переменная &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; типа &lt;code&gt;a&lt;/code&gt; , как DeriveFunctor, так и &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; будут генерировать &lt;code&gt;f a&lt;/code&gt; для определения &lt;code&gt;fmap&lt;/code&gt; и &lt;code&gt;traverse&lt;/code&gt; , соответственно.</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">Когда точка останова устанавливается в определенной строке и столбце, GHCi выбирает наименьшее подвыражение, охватывающее это место, для установки точки останова. Примечание: GHC считает, что символ TAB имеет ширину 1, где бы он ни встречался; другими словами, он считает символы, а не столбцы. Это соответствует тому, что делают одни редакторы, и не соответствует тому, что делают другие. Лучший совет - вообще избегать символов табуляции в исходном коде (см. &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt; в &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;предупреждениях и проверке &lt;/a&gt;работоспособности ).</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">Когда точка останова устанавливается на конкретной линии,GHCi устанавливает точку останова на крайнем левом подвыражении,которое начинается и заканчивается на этой линии.Если два полных подвыражения начинаются в одном столбце,то выбирается самое длинное.Если в строке нет полного подвыражения,то пикируется самое левое выражение,начинающееся на этой строке,а если нет,то выбирается самое правое выражение,которое частично или полностью покрывает эту строку.</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Когда тип данных &lt;code&gt;T&lt;/code&gt; импортируются со всеми конструкторами, т.е. &lt;code&gt;T(..)&lt;/code&gt; , но был экспортирован отвлеченно, то есть &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">Когда функция , которая вызывает нижележащую функцию POSIX неуспешно, то код ERRNO преобразуется в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; . Чтобы узнать, какие коды ошибок могут быть сгенерированы, обратитесь к документации POSIX для соответствующей функции.</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8e20bccf6e08f777f996c2c39b5d665dcbf299" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">Когда файл hs-boot &lt;code&gt;A.hs-boot&lt;/code&gt; компилируется, он проверяется на предмет ошибок области и типа. Когда его родительский модуль &lt;code&gt;A.hs&lt;/code&gt; компилируется, они сравниваются, и если они несовместимы, выдается сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">Если ключ найден на обеих картах,примените функцию к ключу и значениям и,возможно,используйте результат на объединенной карте.</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">Когда клавиша найдена на обеих картах,примените функцию к клавише и значениям и используйте результат на объединенной карте.</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">Когда клавиша найдена на обеих картах,применить функцию к клавише и значениям,чтобы произвести действие и использовать его результат на объединенной карте.</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">Когда клавиша найдена на обеих картах,применить функцию к клавише и значениям,выполнить полученное действие и,возможно,использовать результат на объединенной карте.</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">Когда модуль, предоставленный компилируемым в данный момент пакетом (т.е. &amp;laquo;домашний&amp;raquo; пакет), импортируется, но не указан явно в командной строке в качестве цели. Полезно для Кабала, чтобы гарантировать, что GHC не подберет модули, не указанные ни в &lt;code&gt;exposed-modules&lt;/code&gt; , ни в &lt;code&gt;other-modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">Когда имя или пакет не найдены в области видимости,сделайте предложения по имени или пакету,который вы могли бы иметь в виду вместо этого.</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">Когда вызов метода определенного типа-класса считается небезопасным из-за перекрытия экземпляров, а компилируемый модуль использует &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; , компиляция завершится ошибкой. Для &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; ограничения не применяются, а для модулей, использующих безопасный вывод, они будут считаться небезопасными.</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">Когда программа компилируется и выполняется, она может использовать функцию &lt;code&gt;getArgs&lt;/code&gt; для доступа к аргументам командной строки. Однако мы не можем просто передать аргументы в &lt;code&gt;main&lt;/code&gt; функцию во время тестирования в ghci, поскольку &lt;code&gt;main&lt;/code&gt; функция не принимает свои аргументы напрямую.</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">Когда программа компилируется и выполняется, она может использовать функцию &lt;code&gt;getArgs&lt;/code&gt; для доступа к аргументам командной строки. Однако мы не можем просто передать аргументы &lt;code&gt;main&lt;/code&gt; функции во время тестирования в ghci, так как &lt;code&gt;main&lt;/code&gt; функция не принимает их напрямую.</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">При передаче строки к этому флагу мы сообщаем информацию обо всех функциях,имя которых разделяет префикс со строкой.</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда тип не имеет конструкторов, производный экземпляр &lt;code&gt;Functor&lt;/code&gt; просто принудительно установит (нижнее) значение аргумента, используя &lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d983aaf2b04606b0ab51075f4a016ac754c84212" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;empty_case#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">Когда встречается тип, синтаксически не эквивалентный &lt;code&gt;a&lt;/code&gt; , но содержащий &lt;code&gt;a&lt;/code&gt; , &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; рекурсивно вызывает для него &lt;code&gt;fmap&lt;/code&gt; . Аналогичным образом &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; будет рекурсивно вызывать &lt;code&gt;foldr&lt;/code&gt; и &lt;code&gt;foldMap&lt;/code&gt; . В зависимости от контекста &lt;code&gt;null&lt;/code&gt; может рекурсивно вызывать &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;all null&lt;/code&gt; . Например, учитывая</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">Когда встречается тип, синтаксически не эквивалентный &lt;code&gt;a&lt;/code&gt; , но содержащий &lt;code&gt;a&lt;/code&gt; , &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; рекурсивно вызывает для него &lt;code&gt;fmap&lt;/code&gt; . Точно так же &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; будет рекурсивно вызывать &lt;code&gt;traverse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">Когда присутствует явный &lt;code&gt;forall&lt;/code&gt; на уровне типа , каждая упомянутая переменная типа / вида теперь также должна быть либо в области видимости, либо связана с &lt;code&gt;forall&lt;/code&gt; . В частности, в отличие от некоторых других мест в Haskell, это означает, что переменные свободного типа не будут неявно связаны. Например:</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">Когда значение привязано в &lt;code&gt;do&lt;/code&gt; -notation, шаблон в левой части &lt;code&gt;&amp;lt;-&lt;/code&gt; может не совпадать. В этом случае этот класс предоставляет функцию для восстановления.</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">При появлении предупреждения отображается специальный предупреждающий флаг,который управляет им.</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">Когда подстановочный символ не инстанцирован на монотип,он будет обобщен,т.е.заменен на переменную свежего типа,например</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">Когда оператор &lt;code&gt;import&lt;/code&gt; скрывает объект, который не экспортируется.</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">Когда связанный экземпляр семейства синонимов данных или типов объявлен в экземпляре класса типа, мы (необязательно) можем удалить ключевое слово &lt;code&gt;instance&lt;/code&gt; в экземпляре семейства:</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">Когда исключение распространяется за пределы основной программы, система Haskell печатает соответствующее значение &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; и выходит из программы.</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">Когда исключение распространяется за пределы основной программы, система Haskell печатает соответствующее значение &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; и выходит из программы.</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">Когда присутствует явный &lt;code&gt;forall&lt;/code&gt; , все упомянутые переменные &lt;em&gt;типа,&lt;/em&gt; которые еще не входят в область видимости, должны быть связаны &lt;code&gt;forall&lt;/code&gt; . При необходимости переменные типа Kind будут неявно связаны, например:</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Когда для &lt;code&gt;CT&lt;/code&gt; определен экземпляр &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; , побитовая операция, определенная классом типа, реализует ту же функцию, что и соответствующая побитовая операция в C для &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">Когда для &lt;code&gt;CT&lt;/code&gt; определен экземпляр &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; , значения &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; совпадают с &lt;code&gt;t_MIN&lt;/code&gt; и &lt;code&gt;t_MAX&lt;/code&gt; в C.</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Когда для &lt;code&gt;CT&lt;/code&gt; определен экземпляр &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; , предикаты, определенные классом типов, реализуют то же отношение, что и соответствующий предикат в C для &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Когда для &lt;code&gt;CT&lt;/code&gt; определен экземпляр &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; , арифметические операции, определенные классом типа, реализуют ту же функцию, что и соответствующие арифметические операции (если они доступны) в C on &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">Когда это применимо, почти всегда лучше использовать &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; вместо этой функции, хотя в некоторых патологических случаях это может быть немного хуже. Например, чтобы сократить список символов, используйте</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">При запросе компиляции исходного файла GHC обычно генерирует два файла:объектный файл и файл интерфейса.</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">При запросе на изменение базы данных &lt;code&gt;ghc-pkg&lt;/code&gt; по умолчанию изменяет глобальную базу данных. Указание &lt;code&gt;--user&lt;/code&gt; заставляет его работать с пользовательской базой данных, или &lt;code&gt;--package-db&lt;/code&gt; может использоваться для работы с другой базой данных полностью. Когда дано несколько из этих опций, крайний правый используется как база данных, на которую нужно действовать.</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">Когда заданы оба флага, &lt;code&gt;-&lt;/code&gt; переопределяет &lt;code&gt;0&lt;/code&gt; , а &lt;code&gt;+&lt;/code&gt; переопределяет пробел. Отрицательный спецификатор ширины в преобразовании &lt;code&gt;*&lt;/code&gt; рассматривается как положительный, но подразумевает левый флаг настройки.</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">Когда нужны переменные типа/типа привязки,необходимо всегда включать оба foralls,хотя если переменные типа/типа привязки не нужны,то вторую можно оставить пустой.Например:</target>
        </trans-unit>
        <trans-unit id="b1946e20d1d1096358555ee194ee179a3632a63b" translate="yes" xml:space="preserve">
          <source>When building a shared library, care must be taken to ensure that the resulting object is named appropriately. In particular, GHC expects the name of a shared object to have the form &lt;code&gt;libHS&amp;lt;unit id&amp;gt;-ghc&amp;lt;ghc
version&amp;gt;.&amp;lt;ext&amp;gt;&lt;/code&gt; where &lt;em&gt;unit id&lt;/em&gt; is the unit ID given during compilation via the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag, &lt;em&gt;ghc version&lt;/em&gt; is the version of GHC that produced/consumes the object and &lt;em&gt;ext&lt;/em&gt; is the host system&amp;rsquo;s usual file extension for shared objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">При сборке пакета как разделяемой библиотеки GHC можно использовать для выполнения этапа компоновки. Это скрывает некоторые детали базового компоновщика и предоставляет общий интерфейс для всех вариантов общих объектов, которые поддерживаются GHC (библиотеки DLL, ELF DSO и dylibs Mac OS). Общий объект должен быть назван определенным образом по двум причинам: (1) имя должно содержать версию компилятора GHC, чтобы не конфликтовали два варианта библиотеки, которые скомпилированы разными версиями GHC и поэтому, скорее всего, несовместимы с Что касается соглашений о вызовах, (2) оно должно отличаться от статического имени, иначе мы не сможем управлять компоновщиком настолько точно, насколько это необходимо для работы флагов &lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; , см. &lt;a href=&quot;phases#options-linker&quot;&gt;Параметры, влияющие на связывание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">При вызове вне &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; или внутри &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; эта функция не действует.</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">При вызове вне &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; или внутри &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; эта функция не действует.</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">При вызове &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt; печатает ⟨n⟩ &lt;sup&gt;й&lt;/sup&gt; к ⟨m⟩ &lt;sup&gt;й&lt;/sup&gt; кандидаты для завершения частичного ввода ⟨string-literal⟩ для домена завершения , обозначенного ⟨type⟩. В настоящее время поддерживается только домен &lt;code&gt;repl&lt;/code&gt; , который обозначает тип завершения, который GHCi будет предоставлять интерактивно при вводе запроса.</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">При вызове &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; создается функция, объединяющая два &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; , такая, что</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">При вызове &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; создается функция, объединяющая два &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; , такая, что</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">При вызове &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; создается функция, объединяющая два &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; , такая, что</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">При вызове &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; создается функция, объединяющая две &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; , такая, что</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">При вызове &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; создается функция, объединяющая две &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; , такая, что</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">При преобразовании регистров в &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; значения не используйте комбинаторы, такие как &lt;code&gt;map toUpper&lt;/code&gt; , чтобы преобразовывать каждый символ строки индивидуально, так как это дает неверные результаты в соответствии с правилами некоторых систем записи. Функции преобразования регистра целой строки из этого модуля, такие как &lt;code&gt;toUpper&lt;/code&gt; , подчиняются правильным правилам преобразования регистра. В результате эти функции могут отображать один входной символ на два или три выходных символа. Примеры см. В документации по каждой функции.</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">При проверке пары уравнений семейства замкнутого типа GHC попыталась унифицировать их RHS. Если они не объединяют эту пару уравнений, это не нарушает аннотацию приемистости. Если RHS могут быть объединены при некоторой замене (возможно, пустой), то либо LHS объединяются при одной и той же замене, либо LHS последнего уравнения включается в более ранние уравнения. Если ни одно из условий не выполнено, GHC сообщает, что семейство типов не является инъективным.</target>
        </trans-unit>
        <trans-unit id="d91afb60853a2bed88378f221146e58bb8e15fde" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;exts/partial_type_signatures#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef74d5ed6e34befd39c28303ea99762b0677ced" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;exts/template_haskell#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">При компиляции кода Template Haskell с &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; нам не нужно сначала компилировать модули без &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Использование Template Haskell с профилированием&lt;/a&gt; ), потому что мы можем запустить профилированный объектный код в интерпретаторе.</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">При компиляции с &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; компилируйте модули ⟨n⟩ параллельно.</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">При создании списка значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; можно использовать для возврата всех &quot;успешных&quot; результатов (если список является результатом &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; будет более подходящим):</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd600bd791dcd533e241e96d62fd9d5b36e1ddda" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">При создании списка значений &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; можно использовать для возврата всех &quot;успешных&quot; результатов (если список является результатом &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , то &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; будет более подходящим):</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">При создании разделяемых объектов для пакетов Haskell,разделяемый объект должен иметь правильное имя,чтобы GHC распознал разделяемый объект при компоновке с данным пакетом.См.раздел &quot;Имена разделяемых объектов&quot;.</target>
        </trans-unit>
        <trans-unit id="5fcbc5f9e865e6ce637e24cd8412c50b45fce7f7" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linking against this package. See &lt;a href=&quot;packages#building-packages&quot;&gt;shared object name mangling&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">При принятии решения о том,является ли это правильной структурой данных,необходимо учитывать:</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">При определении макросов GHCi необходимо помнить о некоторых важных действиях,когда имена могут конфликтовать со встроенными командами,особенно в отношении заполнения табуляции.</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">При разработке встроенных языков, специфичных для предметной области, в Haskell полезно иметь что-то вроде &lt;code&gt;error&lt;/code&gt; на уровне типа. Таким образом, разработчик EDSL может показать ошибку типа, специфичную для DSL, а не стандартную ошибку типа GHC.</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">При обесцвечивании нотации списка с помощью &lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt; GHC использует &lt;code&gt;fromList&lt;/code&gt; (etc) из модуля &lt;code&gt;GHC.Exts&lt;/code&gt; . Для этого вам не нужно импортировать &lt;code&gt;GHC.Exts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">При этом мы (необязательно) можем опустить ключевое слово &amp;laquo; &lt;code&gt;family&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="18b09bd4caf81ecbea6328fe8cec841da926304f" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">При включении GHC печатает сигнатуры типов, используя символы юникода из расширения &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">Когда эта функция включена,GHC также печатает дополнительную информацию из типографского шрифта в предупреждениях.Например:</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">Когда эта функция включена,GHC также печатает тип-синоним расширенных типов в ошибках типа.Например,с синонимами этого типа:</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">Если этот параметр включен, включите дополнительную проверку для заслуживающего доверия модуля &lt;code&gt;M&lt;/code&gt; , требующую, чтобы пакет, в котором находится &lt;code&gt;M&lt;/code&gt; , считался доверенным, чтобы &lt;code&gt;M&lt;/code&gt; считался доверенным.</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При создании кода предполагайте, что объекты, импортированные из другого модуля, могут быть динамически связаны. Этот флаг автоматически включается &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee90095bc1ddd211ce603181ac23bb488b4bede" translate="yes" xml:space="preserve">
          <source>When however the traversed container is empty, the result is always a singleton of the empty container, the function is never evaluated as there are no input values for it to be applied to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b07da55e3e4a468a7f3850c0886d61befe9f38e" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;exts/package_qualified_imports#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">При включении пакетов из нескольких источников вы можете оказаться в ситуации, когда несколько пакетов публикуют модули с одним и тем же именем. Раньше единственным способом отличить эти модули было использование &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;импорта&lt;/a&gt; с указанием пакета . Однако, начиная с GHC 7.10, флаги &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; (и их варианты) были расширены, чтобы позволить пользователю явно контролировать, какие модули пакет добавляет в область действия, по аналогии со списками импорта, которые пользователи могут присоединять к импорту модулей.</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">При вызове внутри &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; эта функция позволяет вызвать замаскированное асинхронное исключение, если оно существует. Это эквивалентно выполнению операции с возможностью прерывания (см. #Interruptible), но не требует фактической блокировки.</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">При вызове с флагом &lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt; среда выполнения выдаст профиль центра затрат в машиночитаемом формате JSON. Объект верхнего уровня этого формата имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">При вызове с флагом &lt;code&gt;-g&lt;/code&gt; GHC выдаст стандартную отладочную информацию &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; . Этот формат используется почти всеми POSIX-совместимыми целями и может использоваться средствами отладки и повышения производительности (например, &lt;code&gt;gdb&lt;/code&gt; , &lt;code&gt;lldb&lt;/code&gt; и &lt;code&gt;perf&lt;/code&gt; ) для понимания структуры программ, скомпилированных с помощью GHC.</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">При запуске, если не &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt; флаг -ignore-dot-ghci , GHCi читает и выполняет команды из следующих файлов в указанном порядке, если они существуют:</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">При проверке типа типа, GHC учитывает только то, что написано в этом типе, когда выясняется, как обобщить тип типа.</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">При компоновке бинарного исполняемого файла перед любыми флагами &lt;code&gt;-l&lt;/code&gt; для библиотек Haskell вставляется флаг &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; после этого -Wl, - no-whole-archive</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">При компоновке бинарного исполняемого файла перед любыми флагами &lt;code&gt;-l&lt;/code&gt; для библиотек Haskell вставляется флаг &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; , а &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; (в OS X флаг &lt;code&gt;-Wl,-all_load&lt;/code&gt; , нет эквивалента для &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; ). Этот флаг также отключает использование &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; ( &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; в OS X).</target>
        </trans-unit>
        <trans-unit id="3818bf88dbd86c201ca5b0d240e8772c4b466f3c" translate="yes" xml:space="preserve">
          <source>When linking a static library (&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt;) GHC links the RTS automatically, you can reverse this behaviour by reversing this flag: &lt;code&gt;-fno-link-rts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408951dfca34cc5b21016977e48bc1e9b23d4168" translate="yes" xml:space="preserve">
          <source>When linking shared libraries (&lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt;) GHC does not automatically link the RTS. This is to allow choosing the RTS flavour (&lt;a href=&quot;#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt;, etc) when linking an executable. However when the shared library is the intended product it is useful to be able to reverse this default. See &lt;a href=&quot;shared_libs#shared-libraries-c-api&quot;&gt;Shared libraries that export a C API&lt;/a&gt; for an usage example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65f758cb8818ccee7542109e759d106e5df490b" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;../phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">При связывании окончательной программы обычно проще всего сделать ссылку с помощью GHC, хотя это не обязательно. Если вы все же используете GHC, не забудьте флаг &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt; , иначе GHC попытается подключиться к модулю &lt;code&gt;Main&lt;/code&gt; Haskell.</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При связывании компоновщик может автоматически удалить все разделы, на которые нет ссылок, и таким образом создать исполняемые файлы меньшего размера. Эффект похож на &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; , но несколько более эффективен - сгенерированные файлы библиотеки примерно на 30% меньше, чем с &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">При балансировке нагрузки мы предпочитаем мигрировать потоки в другую Возможности на том же узле.</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">При загрузке исходных модулей с помощью &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , GHCi обычно ищет любые соответствующие скомпилированные объектные файлы и будет использовать их вместо интерпретации исходного кода, если это возможно. Например, предположим , что мы имеем программу 4-модуль , состоящий из модулей , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; , и &lt;code&gt;D&lt;/code&gt; . Модули &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; импортируют только &lt;code&gt;D&lt;/code&gt; , а &lt;code&gt;A&lt;/code&gt; импортирует как &lt;code&gt;B&lt;/code&gt; ,так и &lt;code&gt;C&lt;/code&gt; : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">Глядя на профиль для выполнения программы,мы часто хотим иметь возможность отметить определенные точки или фазы выполнения и увидеть это визуально в профиле.</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">При сопоставлении GHC не учитывает контекст объявления экземпляра ( &lt;code&gt;context1&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">При объединении объявлений классов мы требуем, чтобы суперклассы и методы точно совпадали; однако &lt;code&gt;MINIMAL&lt;/code&gt; MINIMAL логически объединены вместе, и метод с сигнатурой по умолчанию успешно объединится с другим.</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Когда несколько потоков заблокированы на &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , они пробуждаются в порядке FIFO. Это полезно для обеспечения свойств справедливости абстракций, построенных с использованием &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8276c2b13d74d9733b0f4b7964761949b296cc" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Когда несколько потоков заблокированы на &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , они пробуждаются в порядке FIFO. Это полезно для обеспечения свойств справедливости абстракций, построенных с использованием &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Когда несколько потоков заблокированы на &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; , они пробуждаются в порядке FIFO. Это полезно для обеспечения свойств справедливости абстракций, построенных с использованием &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">Когда не используется раскладка блоков на основе cfg,определяется либо последним прыжком в базовом блоке,либо самым тяжелым исходящим краем блока в cfg.</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">Когда речь идет о перегрузке,результаты могут быть слегка контр-интуитивно понятны:</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c7d10b77d99dca5310fa9f2e2f9dfc8d9db49c" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">При совпадении деталей,для каждой экзистенциальной переменной типа вводится новый,отдельный тип.Эти типы не могут быть унифицированы с другими типами,а также не могут выходить за рамки соответствия деталей.Например,эти фрагменты некорректны:</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">При совпадении шаблонов эти ограничения становятся доступными для разрядки ограничений в теле матча.Например:</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">При сопоставлении с образцом конструкторов данных, взятых из GADT, например, в выражении &lt;code&gt;case&lt;/code&gt; , применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="eed65a0801ab307b876b3214608b9b1af66d76f9" translate="yes" xml:space="preserve">
          <source>When preceded but not followed by whitespace, &lt;code&gt;(@)&lt;/code&gt; is treated as a visible type application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">Когда при построении записи используются подстановочные знаки записи, поле &lt;code&gt;f&lt;/code&gt; инициализируется, только если &lt;code&gt;f&lt;/code&gt; находится в области видимости, и не импортируется или не связывается на верхнем уровне. Например, &lt;code&gt;f&lt;/code&gt; может быть привязан к соответствующему шаблону или let / where-binding. Например</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">При сообщении о печатаемых отверстиях,необходимо также учитывать ограничения на печать,которые находятся в пределах видимости.Пример:</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">Когда профилирование фиксатора запрашивается с &lt;code&gt;-hr&lt;/code&gt; параметра -hr , создается график, который разбивается по набору фиксаторов. Набор фиксаторов отображается как набор стеков центров затрат; поскольку он обычно слишком велик, чтобы поместиться на графике профиля, каждый набор фиксаторов пронумерован и показан на графике сокращенно вместе с его номером, а полный список наборов фиксаторов выгружается в файл &lt;code&gt;prog.prof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">При запуске процесса интерактивной консоли (такого как оболочка, текстовый редактор на основе консоли или ghci) мы обычно хотим, чтобы этому процессу было разрешено обрабатывать прерывания клавиатуры Ctl-C так, как он считает нужным. Например, хотя большинство программ просто завершают работу на Ctl-C, некоторые обрабатывают это специально. Чтобы это произошло, используйте параметр &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; параметрах &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">При установке языковых опций в этом файле обычно желательно использовать &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; ,&lt;/a&gt; а не &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Настройка опций только для интерактивной оценки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">Когда следует использовать логический вывод Safe Haskell, а когда - явный флаг &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; ? Последний случай следует использовать, когда у вас есть жесткие требования к безопасности модуля. Это наиболее полезно для &lt;a href=&quot;#safe-use-cases&quot;&gt;использования Safe Haskell&lt;/a&gt; или Safe Haskell: запуск ненадежного кода. Безопасный вывод предназначен для использования обычными программистами на Haskell. Пользователи, которых, вероятно, не волнует Safe Haskell.</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">При отображении флага,управляющего предупреждением,также показывайте соответствующие флаги групп предупреждения,в которых содержится предупреждение.</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">При решении ограничений старайтесь с усердием решать суперклассы,используя доступные словари.</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">При указании прагмы &lt;code&gt;COMPLETE&lt;/code&gt; типы результатов всех шаблонов должны согласовываться друг с другом. Это проверка работоспособности, поскольку было бы невозможно сопоставить все шаблоны, если бы типы были несовместимыми.</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">При явном &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; типа синонима шаблона с помощью PatSynSigD можно оставить пустыми либо одну из универсалий, экзистенциалы или их контексты.</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">При явном &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; типа синонима шаблона с помощью PatSynSigD можно оставить пустыми либо одну из универсалий, экзистенциалы или их контексты.</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">При остановке в точке останова или пошаговом режиме GHCi связывает переменную &lt;code&gt;_result&lt;/code&gt; со значением текущего активного выражения. Значение &lt;code&gt;_result&lt;/code&gt; , по-видимому, еще не доступно, потому что мы остановили его оценку, но это можно сделать принудительно: если тип известен и отображается, то просто введите &lt;code&gt;_result&lt;/code&gt; в командной строке. Однако есть одно предостережение: оценка &lt;code&gt;_result&lt;/code&gt; , вероятно, вызовет дополнительные точки останова, начиная с точки останова, на которой мы остановились в данный момент (если мы остановились на реальной точке останова, а не из-за &lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt; ). Поэтому, вероятно, будет необходимо выдать &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; немедленно при оценке &lt;code&gt;_result&lt;/code&gt; , В качестве альтернативы вы можете использовать &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; ,&lt;/a&gt; которая игнорирует точки останова.</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">Если при остановке в точке останова вы попытаетесь оценить переменную, которая уже оценивается, вторая оценка зависнет. Причина в том, что GHC знает, что переменная находится в процессе оценки, поэтому новая оценка просто ожидает результата, прежде чем продолжить, но, конечно, этого не произойдет, потому что первая оценка остановлена ​​в точке останова. Control-C может прервать зависшую оценку и вернуться к подсказке.</target>
        </trans-unit>
        <trans-unit id="41f4622c9a9bbe02a9f4c027c4d5d4cd516225b4" translate="yes" xml:space="preserve">
          <source>When surrounded by whitespace on both sides, &lt;code&gt;(@)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">Когда флаг &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; включен, то, является ли модуль доверенным, зависит от того, доверены ли определенные пакеты. Доверие пакетов определяется клиентом C, вызывающим GHC (то есть вами).</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">Когда &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt; флаг -fpackage-trust,&lt;em&gt; модуль M из пакета P пользуется доверием со стороны клиента C&lt;/em&gt; тогда и только тогда, когда:</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">Когда используется &lt;code&gt;*&lt;/code&gt; , GHCi игнорирует любой предварительно скомпилированный объектный код и интерпретирует модуль. Если вы уже загрузили несколько модулей как объектный код и решили, что хотите интерпретировать один из них, вместо повторной загрузки всего набора вы можете использовать &lt;code&gt;:add *M&lt;/code&gt; чтобы указать, что вы хотите интерпретировать &lt;code&gt;M&lt;/code&gt; (обратите внимание, что это может привести к интерпретации других модулей, потому что скомпилированные модули не могут зависеть от интерпретируемых).</target>
        </trans-unit>
        <trans-unit id="aedbc26d9c8b6dfa0d4dad036dcef71afa8bd612" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-haddock&lt;/code&gt; option is enabled, GHC collects documentation comments and associates them with declarations, function arguments, data constructors, and other syntactic elements. Documentation comments in invalid positions are discarded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">Когда расширение &lt;code&gt;GADTSyntax&lt;/code&gt; включено, GHC позволяет вам объявить алгебраический тип данных, явно указав сигнатуры типов конструкторов. Например:</target>
        </trans-unit>
        <trans-unit id="9df18db363cd1745ba8506093666b4dbb4c8cd67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">Когда расширение &lt;code&gt;OverloadedLists&lt;/code&gt; включено, вышеупомянутые семь обозначений удаляются следующим образом:</target>
        </trans-unit>
        <trans-unit id="b88d963a673ec0ba32ba448653b0c170c75e2ae9" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;exts/template_haskell#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;exts/template_haskell#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">Когда тип компилятора проверяет исходный код, соединения &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; и &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-Quasi&lt;/a&gt; будут заменены фрагментами синтаксического дерева, сгенерированными из них. Однако для инструментов, которые работают с исходным кодом, генератор кода обычно более интересен, чем сгенерированный код. По этой причине мы включили &lt;code&gt;spliceRunAction&lt;/code&gt; . Это поле вызывается для каждого выражения перед их оценкой. Тип входных данных проверяется, поэтому для этих фрагментов синтаксического дерева доступна семантическая информация. Если вы вернете другое выражение, вы можете изменить сгенерированный код.</target>
        </trans-unit>
        <trans-unit id="7155c3fb192924591b079e548fd800bda9de1a0b" translate="yes" xml:space="preserve">
          <source>When the demand analysis thinks that the scrutinee does not return (i.e. a bottoming expression)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">Когда для параметра flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt; to установлено значение &lt;code&gt;n&lt;/code&gt; больше &lt;code&gt;0&lt;/code&gt; , GHC предложит список допустимых подгонок отверстий для уточнения, которые являются допустимыми подгонками отверстий, которые требуют до &lt;code&gt;n&lt;/code&gt; уровней дополнительного уточнения. чтобы быть полным, где каждый уровень представляет собой дополнительное отверстие в отверстии, которое требует заполнения. В качестве примера рассмотрим отверстие в</target>
        </trans-unit>
        <trans-unit id="2ede94233945ceef730a5c52baafcf873f723c3a" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">Когда &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt; флаг -Wunused-type-patterns, сообщается о переменных типа, которые упоминаются в шаблонах с левой стороны, но не используются с правой стороны. Переменные, которые встречаются несколько раз в левой части, также считаются использованными. Чтобы подавить предупреждения, неиспользуемые переменные должны быть либо заменены, либо снабжены префиксом подчеркивания. Переменные типа, начинающиеся с символа подчеркивания ( &lt;code&gt;_x&lt;/code&gt; ), в противном случае рассматриваются как переменные обычного типа.</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">Когда последний параметр типа имеет фантомную роль (см. &lt;a href=&quot;#roles&quot;&gt;Роли&lt;/a&gt; ), производный экземпляр &lt;code&gt;Functor&lt;/code&gt; не будет создаваться с использованием обычного алгоритма. Вместо этого будет приведено все значение.</target>
        </trans-unit>
        <trans-unit id="d0534d81c2091ec317265f39796ac46bfc114919" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0e2720d4d44b6279dbfb5714c776d53f456b2a" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt;, the effect in question is to short-circuit the computation on encountering &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd7b3ed9f72374ca75e11634d478bca8f1e358c" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, applying &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; to a list of IO actions, performs each in turn, returning a list of the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">Когда имя аргумента типа объявления данных или экземпляра типа не имеет значения, его можно заменить подчеркиванием ( &lt;code&gt;_&lt;/code&gt; ). Это то же самое, что и запись переменной типа с уникальным именем.</target>
        </trans-unit>
        <trans-unit id="9438e464295e0f808c720323652b4fe168da340b" translate="yes" xml:space="preserve">
          <source>When the operator is always strict in the second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` is generally a better choice than &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. When &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; is called with a strict operator, evaluation cannot begin until the last element is reached, by which point a deep stack of pending function applications may have been built up in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9f4c1ad6996c1901a0ec2fced4b4100819215e" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">Когда программа связана с &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , вы можете одновременно вызывать &lt;code&gt;foreign export&lt;/code&gt; функции из нескольких потоков ОС. Система времени выполнения должна быть инициализирована, как обычно, вызовом &lt;code&gt;hs_init()&lt;/code&gt; , и этот вызов должен завершиться перед вызовом любых &lt;code&gt;foreign export&lt;/code&gt; функций.</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">Когда программа связана с параметром &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;phases#options-linker&quot;&gt;параметры, влияющие на связывание&lt;/a&gt; ), события времени выполнения могут регистрироваться несколькими способами:</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">Когда уровень очистки не установлен,он будет предлагать только действительные предложения по подбору отверстий:</target>
        </trans-unit>
        <trans-unit id="bdff41ed009289d642a16083019ce0168e38ec29" translate="yes" xml:space="preserve">
          <source>When the scrutinee is a GADT and its type rules out some constructors, and others constructors are already handled by the case expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">Когда операторы выражения &lt;code&gt;do&lt;/code&gt; имеют зависимости между собой, и &lt;code&gt;ApplicativeDo&lt;/code&gt; не может вывести тип &lt;code&gt;Applicative&lt;/code&gt; , он использует эвристический алгоритм, чтобы попытаться использовать &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; в максимально возможной степени. Этот алгоритм обычно находит лучшее решение, но в редких сложных случаях он может упустить возможность. Есть алгоритм, который находит оптимальное решение, предоставляется как опция:</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">Когда тип не имеет конструкторов, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; будет извлекать самый ленивый экземпляр, какой только может.</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">Когда параметр типа имеет &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; роль (см. &lt;a href=&quot;#roles&quot;&gt;Роли&lt;/a&gt; ), DeriveFoldable получает тривиальный экземпляр. Например, это объявление:</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">Когда параметр типа имеет &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; роль (см. &amp;laquo; &lt;a href=&quot;#roles&quot;&gt;Роли&amp;raquo;&lt;/a&gt; ), DeriveTraversable принудительно применяет свой аргумент. Например, это объявление:</target>
        </trans-unit>
        <trans-unit id="df5cd675628ff7edd99330931c3924f3651bb0c8" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589660ea440e8fa723f008c0478d09f535adede3" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">Когда пользователь пишет</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">Когда в последовательности операторов есть строгое соответствие шаблону, &lt;code&gt;ApplicativeDo&lt;/code&gt; помещает &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; между этим оператором и следующим за ним. Последовательность может быть преобразована для использования &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; в другом месте, но строгое соответствие шаблону и следующий оператор всегда будут связаны с &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , чтобы сохранить ту же семантику строгости, что и стандартная нотация do. Если вы этого не хотите, просто поставьте &lt;code&gt;~&lt;/code&gt; на сопоставление с шаблоном, чтобы сделать его ленивым.</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">Когда этот флаг включен и &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt; отключен, макет блока ведет себя так же, как в 8.6 и ранее.</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">Когда этот флаг установлен, переменная &lt;code&gt;it&lt;/code&gt; больше не будет устанавливаться в результате ранее вычисленного выражения.</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">Когда эта оптимизация включена,генератор кода превратит все самовосстанавливающиеся насыщенные хвостовые вызовы в локальные прыжки,а не в вызовы функций.</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">Когда этот параметр включен, потоки ОС для возможности \ (i \) привязываются к ядру ЦП \ (i \) с помощью API, предоставляемого ОС для настройки сходства потоков. например, в Linux GHC использует &lt;code&gt;sched_setaffinity()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">Когда задана эта опция, промежуточные значения с плавающей запятой могут иметь &lt;em&gt;большую&lt;/em&gt; точность / диапазон, чем конечный тип. Как правило, это хорошо, но некоторые программы могут полагаться на точную точность / диапазон значений &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; и не должны использовать этот параметр для своей компиляции.</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">Когда это предупреждение включено,проверяются следующие условия:</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">При включении вы можете подавить его для каждого модуля с помощью &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt; . Иногда вы можете специально захотеть, чтобы функция имела более ограниченную подпись, чем это необходимо, возможно, чтобы оставить себе пространство для маневра для изменения реализации без изменения API. В этом случае вы можете подавить предупреждение для каждой функции, используя вызов в мертвой привязке. Например:</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">При проверке типа модуля GHC вызывает &lt;code&gt;tcPluginInit&lt;/code&gt; один раз перед началом решения ограничений. Это позволяет плагину искать вещи в контексте, инициализировать изменяемое состояние или открывать соединение с внешним процессом (например, с внешним решателем SMT). Плагин может возвращать результат любого типа, который ему нравится, и результат будет передан в два других поля.</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">При проверке типа декларации экземпляра для &lt;code&gt;F a&lt;/code&gt; , мы должны проверить , что суперкласс &lt;code&gt;C&lt;/code&gt; из &lt;code&gt;F&lt;/code&gt; имеет место. Таким образом, мы пытаемся вывести ограничение &lt;code&gt;C a&lt;/code&gt; из теории, содержащей:</target>
        </trans-unit>
        <trans-unit id="ec95daf87bcd42f783483d51860a38231b97dbf8" translate="yes" xml:space="preserve">
          <source>When used as a value, &lt;code&gt;MkT1&lt;/code&gt; is given a multiplicity-polymorphic type: &lt;code&gt;MkT1 :: forall {m} a. a %m -&amp;gt; T1 a&lt;/code&gt;. This makes it possible to use &lt;code&gt;MkT1&lt;/code&gt; in higher order functions. The additional multiplicity argument &lt;code&gt;m&lt;/code&gt; is marked as inferred (see &lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so that there is no conflict with visible type application. When displaying types, unless &lt;code&gt;-XLinearTypes&lt;/code&gt; is enabled, multiplicity polymorphic functions are printed as regular functions (see &lt;a href=&quot;#printing-linear-types&quot;&gt;Printing multiplicity-polymorphic types&lt;/a&gt;); therefore constructors appear to have regular function types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199505ee33e09e03773bf8a7300953a302a36417" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">При использовании модуль, импортируемый с ключевым словом safe, должен быть доверенным, иначе произойдет ошибка компиляции. Расширение безопасного импорта включается одним из &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; или &lt;code&gt;-XUnsafe&lt;/code&gt; . Когда &lt;code&gt;-XSafe&lt;/code&gt; флаг -XSafe , ключевое слово &lt;code&gt;safe&lt;/code&gt; разрешено, но бессмысленно, поскольку каждый импорт обрабатывается как безопасный импорт.</target>
        </trans-unit>
        <trans-unit id="1487a7894277e2151eefd4c6ac81aaf61e058adb" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;../utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">При использовании &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; (или других расширений, использующих знаки &lt;code&gt;.hsc&lt;/code&gt; ) в файле .hsc (см. &lt;a href=&quot;utils#hsc2hs&quot;&gt;Написание интерфейсов Haskell для кода C: hsc2hs&lt;/a&gt; ), знаки решетки должны быть удвоены (напишите &lt;code&gt;##foo&lt;/code&gt; вместо &lt;code&gt;#foo&lt;/code&gt; ), чтобы избежать их рассматриваются как директивы &lt;code&gt;hsc2hs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">При использовании &lt;code&gt;-dynamic-too&lt;/code&gt; параметры &lt;code&gt;-dyno&lt;/code&gt; , &lt;code&gt;-dynosuf&lt;/code&gt; и &lt;code&gt;-dynhisuf&lt;/code&gt; являются аналогами &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-osuf&lt;/code&gt; и &lt;code&gt;-hisuf&lt;/code&gt; соответственно, но применяются к динамической компиляции.</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">При использовании &lt;code&gt;capi&lt;/code&gt; также можно импортировать значения, а не функции. Например,</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">При использовании &lt;code&gt;par&lt;/code&gt; общее практическое правило состоит в том, что искровое вычисление должно потребоваться позже, но не слишком рано. Кроме того, искровое вычисление не должно быть слишком маленьким, иначе стоимость параллельного разветвления будет слишком велика по сравнению с полученным параллелизмом. На практике понять эти факторы сложно.</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">При использовании взаимодействия в стиле файлов,новая строка будет прочитана,если она доступна сразу после входного символа.</target>
        </trans-unit>
        <trans-unit id="e3b100300996ccb1d75762df35aa37649891a202" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, consumes a single character from the input which may be non-printable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">При использовании взаимодействия в файловом стиле эти функции возвращают &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , если &lt;code&gt;EOF&lt;/code&gt; встречался до того, как были прочитаны какие-либо символы.</target>
        </trans-unit>
        <trans-unit id="4a4385a77afcebb26e3a91b60eea37d30d0eaa80" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8389a66f0ad124cb25ad8df28bee52913fc4af75" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">При использовании взаимодействия в файловом стиле данная функция отключает эхо при чтении строки ввода.</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">При использовании записей принято записывать шаблон,который связывает переменную с тем же именем,что и поле записи,например:</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">При использовании взаимодействия в стиле терминала,символ будет читаться,не дожидаясь новой строки.</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">При использовании взаимодействия в стиле терминала эти функции не возвращают &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; если пользователь нажал &lt;code&gt;Ctrl-D&lt;/code&gt; , когда введенный текст был пуст.</target>
        </trans-unit>
        <trans-unit id="bd410ab3f115e8c24b1b1823fdc91cadf6703bb8" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6cf8901d69d58a7db8d885c6657768b53b72bb" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">Однако,когда значения передаются между различными процессами,запущенными на разных машинах,адреса больше не нужны,так как каждый процесс может использовать разные адреса для хранения заданного значения.</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">Когда мы визуализируем его позже,мы узнаем,сколько столбцов или строк пролетит эта ячейка,и можем включить правильную команду разворота столбцов/разворота строк.</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">При написании перегруженной метки не должно быть пробелов между знаком решетки и следующим идентификатором. Расширение &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; использует постфиксные знаки решетки ; если оба параметра &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; включены, то &lt;code&gt;x#y&lt;/code&gt; означает &lt;code&gt;x# y&lt;/code&gt; , но если включен только &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt; , это означает &lt;code&gt;x #y&lt;/code&gt; . Расширение &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; создает &lt;code&gt;(#&lt;/code&gt; одну лексему, поэтому, когда &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; включен, вы должны написать пробел между открывающей скобкой и перегруженной меткой. Во избежание путаницы настоятельно рекомендуется ставить пробел перед хешем при использовании &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="2f28f79b3dd940bfa9b2672d60198c0f52c740d0" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1502eef4e2dbb983597804aed463fbf9bc83e3f7" translate="yes" xml:space="preserve">
          <source>When written in non-prefix form, &lt;code&gt;(~)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0f36236024c993c6fded09cd7fee1e5abbb48f" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;exts/primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">Когда вы &lt;em&gt;действительно&lt;/em&gt; отчаянно нуждаетесь в скорости и хотите сразу перейти к &amp;laquo;сырым битам&amp;raquo;. Пожалуйста, см. &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Неупакованные типы&lt;/a&gt; для получения некоторой информации об использовании распакованных типов.</target>
        </trans-unit>
        <trans-unit id="aa3258481b642a9c233d877f43b12650ffee34bb" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;foreign import&lt;/code&gt; функцию ed, которая помечена как &lt;code&gt;safe&lt;/code&gt; (по умолчанию), и программа была связана с использованием &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , тогда вызов будет выполняться одновременно с другими запущенными потоками Haskell. Если программа была связана без &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , тогда другие потоки Haskell будут заблокированы до тех пор, пока вызов не вернется.</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">Когда вы компилируете простой модуль,который содержит Template Haskell splice</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">Когда вы компилируете любой модуль, импортирующий &lt;code&gt;Wibble&lt;/code&gt; , GHC распечатает указанное сообщение.</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">При компиляции любого модуля,который импортирует и использует любую из указанных сущностей,GHC распечатает указанное сообщение.</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">Когда вы определяете абстрактный тип с помощью &lt;code&gt;newtype&lt;/code&gt; , вы можете захотеть, чтобы новый тип наследовал некоторые экземпляры из своего представления. В Haskell 98 вы можете наследовать экземпляры &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; и &lt;code&gt;Bounded&lt;/code&gt; путем их создания, но для любых других классов вы должны написать явное объявление экземпляра. Например, если вы определяете</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">Когда вы загружаете исходный модуль Haskell в GHCi, он обычно конвертируется в байт-код и запускается с помощью интерпретатора. Однако интерпретируемый код также может работать вместе с скомпилированным кодом в GHCi; действительно, обычно при запуске GHCi загружает скомпилированную копию &lt;code&gt;base&lt;/code&gt; пакета, который содержит &lt;code&gt;Prelude&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">Когда вы набираете выражение в строке запроса,GHCi немедленно оценивает и распечатывает результат:</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">Когда вы набираете выражение в подсказке,какие идентификаторы и типы находятся в области видимости? GHCi предоставляет гибкий способ контроля над тем,как именно строится контекст для выражения:</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">При использовании выравнивания деталей привязанные переменные теперь могут иметь полиморфные типы.Например:</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">Если вы хотите получить ресурс, поработать с ним, а затем освободить ресурс, рекомендуется использовать &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; установит необходимый обработчик исключений для освобождения ресурса в случае возникновения исключения во время вычисление. Если возникает исключение, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; повторно вызовет исключение (после выполнения выпуска).</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">Если вы хотите получить ресурс, поработать с ним, а затем освободить ресурс, рекомендуется использовать &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; , потому что &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; установит необходимый обработчик исключений для освобождения ресурса в случае возникновения исключения во время вычисление. Если возникает исключение, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; повторно вызовет исключение (после выполнения выпуска).</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите определить плагин, которому нужна семантическая информация об исходном коде, используйте поле &lt;code&gt;typeCheckResultAction&lt;/code&gt; . Например, если ваш плагин должен решить, ссылаются ли два имени на одно и то же определение, или он должен проверить тип функции, которая использует семантическую информацию. В этом случае вам необходимо получить доступ к переименованной или проверенной версии синтаксического дерева с помощью &lt;code&gt;typeCheckResultAction&lt;/code&gt; или &lt;code&gt;renamedResultAction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">Если вы хотите определить плагин, который использует синтаксическое дерево исходного кода, вы хотите переопределить поле &lt;code&gt;parsedResultAction&lt;/code&gt; . Эта точка доступа позволяет вам получить доступ к информации о лексических токенах и комментариях в исходном коде, а также к исходному синтаксическому дереву скомпилированного модуля.</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">Когда ваша программа Haskell запускается, RTS извлекает аргументы командной строки, заключенные между &lt;code&gt;+RTS&lt;/code&gt; и &lt;code&gt;-RTS&lt;/code&gt; , как свои собственные. Например:</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">Всякий раз , когда выражение (или необязывающее заявление, чтобы быть точными) набрано в командной строке, GHCi неявно связывает свое значение переменного &lt;code&gt;it&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">Всякий раз,когда отсутствует список экспорта и определен экземпляр данных,экспортируется соответствующий конструктор типа семейства данных вместе с новыми конструкторами данных,независимо от того,определено ли семейство данных локально или в другом модуле.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">Где &lt;code&gt;@Int&lt;/code&gt; использует приложение видимого типа (приложение &lt;a href=&quot;#visible-type-application&quot;&gt;видимого типа&lt;/a&gt; ) для создания экземпляра &lt;code&gt;b&lt;/code&gt; в &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; по умолчанию :: forall b. С '=&amp;gt; а -&amp;gt; б -&amp;gt; б . Чтобы приложение этого типа работало, подпись типа по умолчанию для &lt;code&gt;bar&lt;/code&gt; должна иметь тот же порядок переменных типа, что и подпись нестандартного типа! Но &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;C'&lt;/code&gt; обязаны быть одинаковыми (см., Например, пример &lt;code&gt;Enum&lt;/code&gt; выше, который полагается на это).</target>
        </trans-unit>
        <trans-unit id="b024d670d888125fe31e9ca369b232e66906c997" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5a8e5564838fc8779ef3e81fff81e304d2dcad" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convenience function provided in the &lt;code&gt;GHC.Tc.Errors.Hole&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Где &lt;code&gt;v&lt;/code&gt; - это структура данных в двоичном коде. Чтобы восстановить исходные данные, мы используем &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1498debcd36b3f6ddc4c5309c7855ee018a92837" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions in instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">Если GHC разрешает объявления экземпляров расширений, мы разрешаем точно такие же расширения для этой новой формы &lt;code&gt;class&lt;/code&gt; . В частности, с &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; синтаксис становится</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">По возможности приложение должно вместо этого использовать функции из обычных модулей открытого интерфейса, таких как &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt; . Пакеты, расширяющие систему ByteString на низком уровне, должны будут использовать этот модуль.</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">Где найти пользовательские библиотеки&amp;hellip; Добавьте каталог dir⟩ к пути к каталогам библиотек.</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">Где читать/записывать историю в начале и в конце каждого сеанса ввода строки.</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">Где ⟨identifier⟩ называет любую функцию верхнего уровня в интерпретируемом модуле,загруженном в настоящее время в GHCi (могут использоваться квалифицированные имена).Точка останова будет установлена в теле функции,когда она будет полностью применена,но до того,как произойдет какое-либо совпадение по образцу.</target>
        </trans-unit>
        <trans-unit id="30f47faad399154cde4ee06e55aadb6d6a7579b0" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied. If the function has several patterns, then a breakpoint will be set on each of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; - это приложение-функция, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; - это приложение-функция, поднятое над &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; - это приложение-функция, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; - это приложение-функция, поднятое над &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; - это приложение-функция, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; - это приложение-функция, поднятое над &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">В то время как в Haskell, можно думать о &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; как содержащие или получения значений, контравариантным функтор функтор , который можно рассматривать как &lt;em&gt;потребляя&lt;/em&gt; значения.</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">В то время как списки могут быть конечными или бесконечными, последовательности всегда конечны. В результате последовательность получается строгой по длине. Игнорируя эффективность, вы можете представить, что &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; определен</target>
        </trans-unit>
        <trans-unit id="64e17f12cf0a73293ad82b3caa4fe2b94113c0b3" translate="yes" xml:space="preserve">
          <source>Whether a data constructor field is linear or not can be customized using the GADT syntax. Given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d859ca679c3f9519d633fadbe164a6690aa53bfc" translate="yes" xml:space="preserve">
          <source>Whether a fold is recursive, corecursive or short-circuiting can depend on both the method chosen to perform the fold and on the operator passed to that method (which may be implicit, as with the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; method of a monoid instance).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">Нужно ли считать ядра гиперпотоков или нет-вопрос открытый;пожалуйста,не стесняйтесь экспериментировать и дайте нам знать,какие результаты вы найдете.</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">Является ли центр затрат Постоянной Аппликативной Формой (CAF)</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">Идет ли совпадение из исходного набора конструкторов данных или из прагмы &lt;code&gt;COMPLETE&lt;/code&gt; (приоритет первого над вторым)</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">Удержится ли он,зависит от используемой вами версии GHC,платформы,на которой вы работаете,данных,с которыми вы работаете,и кодировок,которые вы используете,так что не забудьте протестировать для себя.</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">Должны ли за этим словом следовать пробел,конечная кавычка и т.д.</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">Настаивать ли на знаке &quot;плюс&quot; для положительных чисел.</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">Отрегулировать ли поле влево или обнулить. Они являются взаимоисключающими, с приоритетом &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">Показывать ли фрагменты оригинального исходного кода</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">Какую прагму &lt;code&gt;COMPLETE&lt;/code&gt; следует использовать при проверке покрытия шаблонов в &lt;code&gt;f&lt;/code&gt; ? Если мы выбираем &lt;code&gt;COMPLETE&lt;/code&gt; набор , который охватывает &lt;code&gt;MkT1&lt;/code&gt; и &lt;code&gt;MkT2&lt;/code&gt; , то &lt;code&gt;f&lt;/code&gt; является исчерпывающим, но если выбрать другой &lt;code&gt;COMPLETE&lt;/code&gt; набор , который охватывает &lt;code&gt;MkT1&lt;/code&gt; и &lt;code&gt;MkT2Internal&lt;/code&gt; , то &lt;code&gt;f&lt;/code&gt; является &lt;em&gt;не&lt;/em&gt; исчерпывающим, поскольку он не соответствует &lt;code&gt;MkT2Internal&lt;/code&gt; . Интуитивно понятный способ решить эту дилемму - признать, что выбор предыдущего набора &lt;code&gt;COMPLETE&lt;/code&gt; дает наименьшее количество непокрытых предложений шаблона и, следовательно, является лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="fbd9610ee671b95cb3c4896a6a1d851665229835" translate="yes" xml:space="preserve">
          <source>Which can, for example, be specialised to number ranges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">Что позволяет нам переписывать наши функции в гораздо более чистом стиле:</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">Какое поколение собирает мусор.</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">Это показывает, что отверстие можно заменить, например, &lt;code&gt;foldl1 _&lt;/code&gt; . Это может помочь пользователям понять, какие варианты у них есть, хотя это не устраняет дыру.</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">Что приведет к следующей ошибке во время компиляции,</target>
        </trans-unit>
        <trans-unit id="32045914aee96128fc2bfd16f50a2982f4ee64c2" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is required for type variables from the top of a class or instance declaration to scope over the /bodies/ of the methods, it is not required for the type variables to scope over the /type signatures/ of the methods. For example, the following will be accepted without explicitly enabling &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; принудительно оценивает все элементы списка:</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">В то время как &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; позволяет использовать кавычки (т. &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; Удобное экранирование многих символов) с помощью соответствующих наборов одинарных или двойных кавычек, escapeArgs не использует механизм цитирования и, таким образом, всегда избегает любых пробелов, кавычек и обратной косой черты.</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">В то время как &lt;code&gt;INLINE&lt;/code&gt; говорит &amp;laquo;пожалуйста, &lt;code&gt;INLINABLE&lt;/code&gt; меня&amp;raquo;, INLINABLE говорит: &amp;laquo;Не стесняйтесь вставлять меня; используйте свое усмотрение &amp;raquo;. Другими словами, выбор остается за GHC, который использует те же правила, что и для функций без прагм. В отличие от &lt;code&gt;INLINE&lt;/code&gt; , это решение принимается на сайте &lt;em&gt;вызова&lt;/em&gt; и, следовательно, будет зависеть от порога встраивания, уровня оптимизации и т. Д.</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">В то время как &lt;code&gt;a + b&lt;/code&gt; анализируется как &lt;code&gt;(+) a b&lt;/code&gt; и становится положением привязки для оператора типа &lt;code&gt;(+)&lt;/code&gt; , &lt;code&gt;a * b&lt;/code&gt; разбирается как &lt;code&gt;a (*) b&lt;/code&gt; и отклоняется.</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">Хотя &lt;code&gt;n&lt;/code&gt; использует &lt;code&gt;k&lt;/code&gt; без его введения и, таким образом, нарушает правило, в настоящее время это принято. Это потому, что &lt;code&gt;k&lt;/code&gt; в &lt;code&gt;n&lt;/code&gt; считается переменной типа, как это происходит в сигнатуре вида. На самом деле грань между переменными типа и переменными типа размыта, как показывает следующий пример:</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">Несмотря на то,что GHC очень хочет встроить функцию,он не делает этого вслепую.Например,если вы пишете</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">Хотя Safe Haskell является расширением, на самом деле он работает в фоновом режиме при каждой компиляции с GHC. Это делается для того, чтобы отслеживать нарушения типов модулей и делать выводы об их безопасности, даже если они явно не используют Safe Haskell. Пожалуйста, обратитесь к разделу &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">В то время как основной вариант использования Safe Haskell - это запуск ненадежного кода, Safe Haskell не предоставляет этого напрямую. Вместо этого Safe Haskell обеспечивает строгую безопасность типов. Без Safe Haskell GHC допускает множество исключений из системы типов, которые могут разрушить любые абстракции. Обеспечивая строгую безопасность типов, Safe Haskell позволяет разработчикам создавать собственные механизмы песочницы на уровне библиотеки для запуска ненадежного кода.</target>
        </trans-unit>
        <trans-unit id="def095ee0284bcac4322f43e6852c970ad41b290" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0727c03f093cd8f954da72e1d96477371ae2259" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;type_families#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">В процессе разработки иногда желательно,чтобы компиляция была успешной,даже если в коде присутствуют типовые ошибки.Рассмотрим следующий случай:</target>
        </trans-unit>
        <trans-unit id="c76bcc0e915bb7788c67f5c0d7c2f5a80c7fcbb7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;../ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91465cfe2041d24f0183967b4edb1cd4e56225f7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">Хотя модули, загруженные в GHCi с помощью команды &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; ,&lt;/a&gt; могут использовать &lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;static&lt;/code&gt; выражения, операторы, введенные в REPL, не могут. Это ограничение GHCi; подробности см. в &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;выпуске № 12356&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">При запуске программы с включенным профилированием GHC поддерживает за кулисами стеки по центру затрат и приписывает любые затраты (выделение памяти и времени)какому бы то ни было текущему стеку по центру затрат на момент возникновения затрат.</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Остановившись на установленной ранее точке останова в строке 2, мы начали новую оценку с помощью &lt;code&gt;:step qsort [1,3]&lt;/code&gt; . Эта новая оценка остановилась после одного шага (при определении &lt;code&gt;qsort&lt;/code&gt; ). Приглашение изменилось, теперь оно имеет префикс &lt;code&gt;...&lt;/code&gt; , чтобы указать, что есть сохраненные точки останова помимо текущей. Чтобы увидеть стек контекстов, используйте &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dc8800b1f9d492207f0fef148c021ca763c0e0d1" translate="yes" xml:space="preserve">
          <source>While the examples below are not necessarily the most optimal definitions of the intended functions, they are all cases in which &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is far more appropriate (as well as more efficient) than the lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">В то время как следующие определения отвергаются:</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">Хотя это флаги, они также соответствуют типам модулей Safe Haskell, которые может иметь модуль. Вы можете думать об их использовании как об объявлении явного контракта (или типа), который должен иметь модуль. Если он недействителен, компиляция завершится неудачно. GHC также определит правильный тип для Safe Haskell, пожалуйста, обратитесь к разделу &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">Хотя эти примеры похожи, ни один из них не может быть успешно скомпилирован. Это связано с тем, что все вхождения последнего параметра типа &lt;code&gt;a&lt;/code&gt; происходят в &lt;em&gt;контравариантных&lt;/em&gt; , а не ковариантных позициях.</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">Несмотря на то,что эти функции имеют стабильное API и вы можете использовать их в приложениях,внимательно рассмотрите задокументированные предварительные условия;неправильное использование может нарушить прозрачность ссылок или еще хуже.</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">Несмотря на то,что это довольно низкий уровень,он предоставляет вам полную гибкость в том,как данные будут выписываться.</target>
        </trans-unit>
        <trans-unit id="e625b4a26a74d86e3769fcae80feac3c80b5c8b0" translate="yes" xml:space="preserve">
          <source>While user-written type or kind variables are specified by default, GHC permits labelling these variables as inferred. By writing the type variable binder in braces as &lt;code&gt;{tyvar}&lt;/code&gt; or &lt;code&gt;{tyvar :: kind}&lt;/code&gt;, the new variable will be classified as inferred, not specified. Doing so gives the programmer control over which variables can be manually instantiated and which can&amp;rsquo;t. Note that the braces do not influence scoping: variables in braces are still brought into scope just the same. Consider for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">В то время как обычный синоним шаблона можно использовать двумя способами, есть семь способов использования &lt;code&gt;Point&lt;/code&gt; . Именно так, как можно использовать обычный конструктор записи.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="df9fef21f52afbea42c2a537cd033c1f3e472e48" translate="yes" xml:space="preserve">
          <source>Whitespace can be inserted, as in &lt;code&gt;- 123&lt;/code&gt;, to force interpretation as two tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">Почему я получил ошибку в ссылке?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">Почему существуют и &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; , и почему GHC предпочитает реализовывать &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; в производных экземплярах &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ? Причина в том, что &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; основан на типе &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; , и хотя &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; упоминается в отчете Haskell 2010, это не очень эффективная структура данных парсера.</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">Почему существуют и &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; , и почему GHC предпочитает реализовывать &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; в производных экземплярах &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ? Причина в том, что &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; основан на типе &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; , и хотя &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; упоминается в отчете Haskell 2010, это не очень эффективная структура данных парсера.</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">Почему существуют и &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; , и почему GHC предпочитает реализовывать &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; в производных экземплярах &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ? Причина в том, что &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; основан на типе &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; , и хотя &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; упоминается в отчете Haskell 2010, это не очень эффективная структура данных парсера.</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">Зачем нам это нужно? Потому что , если внешняя библиотека вызывается из нити , созданной с использованием &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; , он не будет иметь доступ к любым &lt;em&gt;нит локального состояния&lt;/em&gt; - переменным состояний , которые имеют конкретные значения для каждого потока ОС (см POSIX в &lt;code&gt;pthread_key_create&lt;/code&gt; или Win32 в &lt;code&gt;TlsAlloc&lt;/code&gt; ). Поэтому некоторые библиотеки (например, OpenGL) не будут работать из потока, созданного с помощью &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; . Они отлично работают в потоках, созданных с помощью &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; , или при вызове из &lt;code&gt;main&lt;/code&gt; или &lt;code&gt;foreign export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">Зачем нам это делать? Основная причина заключается в том,что RTS,выполняющий интерпретируемый код,может иметь другой оттенок (профилирующий или динамически связанный),чем сам GHC.Так,например:</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">Почему нам нужно запускать скомпилированный код? Что ж, скомпилированный код примерно в 10 раз быстрее, чем интерпретируемый, но для его создания требуется примерно в 2 раза больше времени (возможно, дольше, если включена оптимизация). Так что стоит компилировать те части программы, которые не очень часто меняются, и использовать интерпретатор для активно разрабатываемого кода.</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">Цифры ширины также могут использоваться после любых модификаторов и перед спецификатором (здесь обозначены как &lt;code&gt;z&lt;/code&gt; ), например:</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">Подстановочные знаки, встречающиеся в монотипной (тау) части сигнатуры типа, являются &lt;em&gt;подстановочными знаками типа&lt;/em&gt; (&amp;laquo;тип&amp;raquo; часто опускается, поскольку это &lt;em&gt;тип подстановочного знака&lt;/em&gt; по умолчанию). Подстановочные знаки типа могут быть созданы для любого монотипа, такого как &lt;code&gt;Bool&lt;/code&gt; или &lt;code&gt;Maybe [Bool]&lt;/code&gt; , включая функции и типы более высокого порядка, такие как &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; или &lt;code&gt;Maybe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9658cea5793b3d031fa20c655bb68dd4c32b903a" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;#11197&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">Не будет выдавать никаких выходных данных, несмотря на то, что некорректно набранный термин появляется после правильно напечатанного &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; , См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Выпуск № 11197&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">Будет выдано два предупреждения, потому что &lt;code&gt;Zero&lt;/code&gt; и &lt;code&gt;Succ&lt;/code&gt; не записываются как &lt;code&gt;'Zero&lt;/code&gt; и &lt;code&gt;'Succ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">Программы только с графическим интерфейсом Windows не имеют stdin,stdout или stderr,поэтому использование обычных функций ввода/вывода Haskell приведет к отказу вашей программы с исключением ввода/вывода,например:</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">только для Windows:ссылка на каталог</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Пути Windows не все одинаковы. Каждый из путей имеет разное значение. &lt;code&gt;MAX_PATH&lt;/code&gt; ограничение не является ограничение операционной системы , ни в файловой системе. Это ограничение пространства имен по умолчанию, применяемое Win32 API для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">Windows-системы</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Ошибки, характерные для Windows: эта операция может завершиться ошибкой с параметром &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; если файловая система не поддерживает символические ссылки.</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Ошибки, специфичные для Windows: эта операция может завершиться ошибкой с &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; , если у пользователя нет прав для создания символических ссылок. Он также может завершиться ошибкой с &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; если файловая система не поддерживает символические ссылки.</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; GHC автоматически превращает каждый тип данных в тип, а его конструкторы (значения) в конструкторы типов. Следующие типы</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; типы списков и кортежей Haskell изначально преобразованы в виды и пользуются тем же удобным синтаксисом на уровне типов, хотя и с префиксом в кавычки:</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt; приведенный выше пример можно переписать так:</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; вы можете получить любой другой класс. Компилятор просто сгенерирует объявление экземпляра без явно определенных методов. Это в основном полезно в классах, &lt;a href=&quot;#minimal-pragma&quot;&gt;минимальный набор&lt;/a&gt; которых пуст, и особенно при написании &lt;a href=&quot;#generic-programming&quot;&gt;общих функций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt; вы можете создавать экземпляры класса &lt;code&gt;Data&lt;/code&gt; , определенного в &lt;code&gt;Data.Data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">С &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; , можно получить &lt;code&gt;Foldable&lt;/code&gt; экземпляры для типов данных любезного &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Например, это объявление:</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; вы можете создавать экземпляры класса &lt;code&gt;Foldable&lt;/code&gt; , определенного в &lt;code&gt;Data.Foldable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; можно получить экземпляры &lt;code&gt;Functor&lt;/code&gt; для типов данных типа &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Например, это объявление:</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; вы можете создавать экземпляры класса &lt;code&gt;Functor&lt;/code&gt; , определенного в &lt;code&gt;GHC.Base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt; вы можете создавать экземпляры классов &lt;code&gt;Generic&lt;/code&gt; и &lt;code&gt;Generic1&lt;/code&gt; , определенных в &lt;code&gt;GHC.Generics&lt;/code&gt; . Вы можете использовать их для определения общих функций, как описано в &lt;a href=&quot;#generic-programming&quot;&gt;разделе Общее программирование&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt; вы можете получить экземпляры класса &lt;code&gt;Lift&lt;/code&gt; , определенного в модуле &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; пакета &lt;code&gt;template-haskell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; можно получить экземпляры &lt;code&gt;Traversable&lt;/code&gt; для типов данных типа &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . Например, это объявление:</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; вы можете создавать экземпляры класса &lt;code&gt;Traversable&lt;/code&gt; , определенного в &lt;code&gt;Data.Traversable&lt;/code&gt; . Поскольку экземпляр &lt;code&gt;Traversable&lt;/code&gt; определяет экземпляры &lt;code&gt;Functor&lt;/code&gt; и &lt;code&gt;Foldable&lt;/code&gt; , вы, вероятно, захотите также получить их, поэтому &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt; подразумевает &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">С помощью &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt; вы можете использовать &lt;em&gt;неквалифицированные&lt;/em&gt; имена полей, даже если соответствующий селектор находится только в &lt;em&gt;квалифицированной области.&lt;/em&gt; Например, предполагая тот же модуль &lt;code&gt;M&lt;/code&gt; , что и в нашем предыдущем примере, это допустимо:</target>
        </trans-unit>
        <trans-unit id="99f7c9801f0ef0a07288415240f5ce1502d72261" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-GHCForeignImportPrim&quot;&gt;&lt;code&gt;GHCForeignImportPrim&lt;/code&gt;&lt;/a&gt;, GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3633e2ee9e40b7726e0f89355deb245b14e9f8fc" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, both anomalies are resolved:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; &lt;/a&gt; GHC принимает условные выражения с несколькими ветвями:</target>
        </trans-unit>
        <trans-unit id="9a679f9cc8ac2f8e0bd4d243711194c8b0678482" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;generics#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f1831d8e85cb1a415e324a97c3fdb0f34ffde3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;, we can give the kind of a datatype written in GADT-syntax (see &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d75b9ce3d652c231eb22d06b84771c3d1879c4f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XLinearTypes&lt;/code&gt;, you can write &lt;code&gt;f :: a %1 -&amp;gt; b&lt;/code&gt; to mean that &lt;code&gt;f&lt;/code&gt; is a linear function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. If &lt;a href=&quot;unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; is enabled, the &lt;code&gt;%1 -&amp;gt;&lt;/code&gt; arrow can be written as &lt;code&gt;⊸&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a0296f22c09085434bc8fbe6087bddeed249a7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XRecursiveDo&lt;/code&gt;, &lt;code&gt;rec&lt;/code&gt; and &lt;code&gt;mdo&lt;/code&gt; blocks use &lt;code&gt;M.mfix&lt;/code&gt; and &lt;code&gt;M.return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">С &lt;code&gt;-maxN⟨x⟩&lt;/code&gt; , т.е. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; , среда выполнения выберет не более (x), также ограниченное количеством процессоров в системе. Пропуск (x) является ошибкой, если вам нужен параметр по умолчанию &lt;code&gt;-N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">Для &lt;code&gt;hpc-tracer&lt;/code&gt; это 8 (табуляция означает несколько пробелов).</target>
        </trans-unit>
        <trans-unit id="1f5b790aba3cca991b680469d0ff5aa545bb45ba" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">В GHC представление &lt;code&gt;ByteString&lt;/code&gt; использует &lt;em&gt;закрепленную&lt;/em&gt; память, то есть сборщик мусора не может перемещать его. Обычно это правильно для больших строк, но для небольших строк использование закрепленной памяти может привести к фрагментации кучи, которая тратит пространство. Тип &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; (и тип &lt;code&gt;Text&lt;/code&gt; из &lt;code&gt;text&lt;/code&gt; пакета) используют &lt;em&gt;незакрепленную&lt;/em&gt; память, поэтому они не способствуют фрагментации кучи. Кроме того, с помощью GHC небольшие незакрепленные строки выделяются так же, как и обычные выделения кучи, а не в отдельной закрепленной области.</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">При использовании GHC накладные расходы на память выражаются в словах и байтах (слова-4 и 8 байт на 32-х или 64-х битных машинах соответственно).</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">В тексте Unicode неправильно использовать комбинаторы, такие как &lt;code&gt;map toUpper&lt;/code&gt; для преобразования каждого символа строки по отдельности. Вместо этого используйте функции преобразования регистра целой строки из этого модуля. Для корректности в разных системах письма эти функции могут отображать один входной символ на два или три выходных символа.</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">Если повезет, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; будет неопределенным во всех других реализациях, поддерживающих предварительную обработку в стиле C.</target>
        </trans-unit>
        <trans-unit id="c44ed7fc274ccaa822b5b3ccf3ecc3bf7adbae81" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;#2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">Для функций с зависимым типом это более полезно (см. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Проблему № 2431&lt;/a&gt; ). Например, рассмотрим эти два возможных определения &lt;code&gt;absurd&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ad7584c8bb969b4ca391280d29051d7fd169de9" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;../using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;../using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">С добрым полиморфизмом за кулисами происходит довольно много вещей, которые могут быть невидимы для программиста на Haskell. GHC поддерживает несколько флагов, которые контролируют печать типов в сообщениях об ошибках и в приглашении GHCi. См. &lt;a href=&quot;using#pretty-printing-types&quot;&gt;Обсуждение параметров красивой печати&lt;/a&gt; для получения дополнительной информации. Если вы используете полиморфизм типа и не знаете, почему GHC отклоняет (или принимает) вашу программу, мы рекомендуем вам включить эти флаги, особенно &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">С несколькими модулями в области видимости, особенно с несколькими модулями &lt;code&gt;*&lt;/code&gt; -form, вероятно возникновение конфликтов имен. Haskell указывает, что о конфликтах имен сообщается только при использовании неоднозначного идентификатора, и GHCi ведет себя таким же образом для выражений, вводимых в приглашении.</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">Только для 1 поколения (например, &lt;code&gt;-G1&lt;/code&gt; , см. &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt; ) опция &lt;code&gt;-A&lt;/code&gt; указывает минимальную область выделения, поскольку фактический размер области выделения будет изменен в соответствии с объемом данных в куче (см. &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt; , ниже).</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">За некоторыми исключениями (см. Ниже) файл будет создан безопасно в том смысле, что злоумышленник не сможет заставить openTempFile перезаписать другой файл в файловой системе, используя ваши учетные данные, путем размещения символических ссылок (в Unix) в месте, где временный файл должен быть создан. В Unix для предотвращения этой атаки используются флаги &lt;code&gt;O_CREAT&lt;/code&gt; и &lt;code&gt;O_EXCL&lt;/code&gt; , но обратите внимание, что &lt;code&gt;O_EXCL&lt;/code&gt; иногда не поддерживается в файловых системах NFS, поэтому, если вы полагаетесь на такое поведение, лучше всего использовать только локальные файловые системы.</target>
        </trans-unit>
        <trans-unit id="79bbc92aef03765c41804036c58a84e7a3f0d5ed" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt; GHC поддерживает обозначение стрелок, описанное во втором из этих документов, переводя его с помощью комбинаторов из модуля &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; . Ниже приводится краткое введение в обозначения; в этом не будет особого смысла, если вы не прочитаете статью Хьюза.</target>
        </trans-unit>
        <trans-unit id="6b570873f02bd59cb3d75af7817ea6c7ba50ea43" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; &lt;/a&gt; GHC становится более либеральным в том, что он принимает в качестве ограничений в вашей программе. Если быть точным, с этим флагом любой &lt;em&gt;тип &lt;/em&gt; &lt;code&gt;Constraint&lt;/code&gt; нового типа может использоваться как ограничение. У следующих вещей есть &lt;code&gt;Constraint&lt;/code&gt; вида :</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt; GHC позволяет объявлять тип данных без конструкторов.</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt; GHC позволяет уточнять объявления импорта по имени пакета, из которого модуль предназначен для импорта. Например:</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#universal-quantification&quot;&gt;переменные типа с лексической областью видимости&lt;/a&gt; ) можно объявлять аргументы типа где-нибудь, кроме начала типа. Например, у нас может быть &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; а затем произнесите &lt;code&gt;pair @Bool True @Char&lt;/code&gt; которая будет иметь тип &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">С расширением &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt; главы экземпляров могут использовать синонимы типов. Как всегда, использование синонима типа - это просто сокращение для записи правой части определения синонима типа. Например:</target>
        </trans-unit>
        <trans-unit id="35ffad7832c6db23930e6f76ac2898fcc34375fa" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;scoped_type_variables#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">С помощью языковых флагов &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; GHC расширяет синтаксис объявления импорта, принимая необязательное ключевое слово &lt;code&gt;safe&lt;/code&gt; после ключевого слова &lt;code&gt;import&lt;/code&gt; . Эта функция является частью расширения Safe Haskell GHC. Например:</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">С параметром &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; GHC может автоматически создавать экземпляры класса &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; . Например, учитывая декларацию</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;T&lt;/code&gt; мы могли связать &lt;code&gt;k&lt;/code&gt; &lt;em&gt;после &lt;/em&gt; &lt;code&gt;a&lt;/code&gt; ; это не нарушит проблемы зависимости. Однако это нарушило бы наш общий принцип, и поэтому &lt;code&gt;k&lt;/code&gt; на первом месте.</target>
        </trans-unit>
        <trans-unit id="f729b214bbb92dbc7e8b7e039b0ea25bb3f02fc3" translate="yes" xml:space="preserve">
          <source>With the List monad, &quot;empty&quot; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt;, while with &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. With &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; we have an &lt;em&gt;empty&lt;/em&gt; case for each value of &lt;strong&gt;&lt;code&gt;e&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">С объявлением &lt;code&gt;(:~~:)&lt;/code&gt; выше, он становится добрым для &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; . Таким образом, тип &lt;code&gt;(:~~:) a&lt;/code&gt; имеет вид &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; для некоторого &lt;code&gt;k2&lt;/code&gt; . GHC не может затем &lt;em&gt;регенерировать&lt;/em&gt; этот вид, чтобы стать для &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; желаемый. Таким образом, экземпляр отклоняется как недоброжелательный.</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">С помощью расширения, которое добавляет своего &lt;a href=&quot;#constraint-kind&quot;&gt;рода ограничения&lt;/a&gt; , вы можете писать более экзотические определения суперклассов. В этом случае проверка цикла суперкласса еще более либеральна. Например, это нормально:</target>
        </trans-unit>
        <trans-unit id="8e20b822830d40ffde03919521d0e6cff6321840" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;constraint_kind#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these cases. For example, this is OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">С целью в виде , чтобы сделать &lt;code&gt;encode&lt;/code&gt; работу на &lt;code&gt;Tree&lt;/code&gt; и других типах данных, мы определим экземпляры для конструкторов типа представления &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">С улучшенным видом &lt;code&gt;Vec&lt;/code&gt; такие вещи, как &lt;code&gt;Vec Int Char&lt;/code&gt; , теперь не подходят, и GHC сообщит об ошибке.</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">С расширением языка &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; &lt;/a&gt; GHC снимает все ограничения на суперклассы. Если там действительно &lt;em&gt;есть&lt;/em&gt; петля, GHC будет только расширить его конечную глубину.</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">Когда это расширение включено, &lt;code&gt;static&lt;/code&gt; больше не является допустимым идентификатором.</target>
        </trans-unit>
        <trans-unit id="c483494822eddb06511b9c2103f30e5e7e71ff07" translate="yes" xml:space="preserve">
          <source>With this flag GHC generates a default alternative with &lt;code&gt;error&lt;/code&gt; in these cases. This is helpful when debugging demand analysis or type checker bugs which can sometimes manifest as segmentation faults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">При включенном флаге мы используем последнюю инструкцию прыжка блоками.Без этого флага старый алгоритм также использует самый тяжелый исходящий край.</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">В этой форме оператора group f требуется просто иметь тип для &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; , который будет использоваться для непосредственной группировки понимания до сих пор. Пример этой формы выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">С помощью этого макроса, определенного в вашем файле &lt;code&gt;.ghci&lt;/code&gt; , вы можете использовать &lt;code&gt;:source file&lt;/code&gt; для чтения команд GHCi из &lt;code&gt;file&lt;/code&gt; . Вы можете найти (и внести свой вклад! -) другие предложения для файлов &lt;code&gt;.ghci&lt;/code&gt; на этой вики-странице Haskell: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb160564b2f5fdfa9c709441f91b64c92758b306" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b653d1a2bfaa93b0073e542432ee5c0e412c45" translate="yes" xml:space="preserve">
          <source>With typed expressions, the type error occurs when &lt;em&gt;constructing&lt;/em&gt; the Template Haskell expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">С порезами зигзага.</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">В разумных пределах больше памяти для кучи означает меньшую сборку мусора для GHC, что означает меньшее время компиляции. Если вы используете параметр &lt;code&gt;-Rghc-timing&lt;/code&gt; , вы получите отчет сборщика мусора. (Опять же, вы можете использовать опцию cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; , чтобы отправить статистику GC прямо в стандартную ошибку.)</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">В этом модуле многие функции создают &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; из одного или нескольких значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; . Эти функции заменят значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , которые не являются допустимыми скалярными значениями Unicode, на заменяющий символ &quot;&quot; (U + FFFD). Функции, выполняющие эту проверку и замену, задокументированы фразой &amp;laquo;Выполняет замену недопустимых скалярных значений&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="7908234217d5fcd634ff01a732e900f1963d7319" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2664af2a1458216f4637034b8ac10a76e4c6e6e" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">В этом модуле многие функции создают &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; из одного или нескольких значений &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; . Эти функции заменят значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; , которые не являются допустимыми скалярными значениями Unicode, на заменяющий символ &quot;&quot; (U + FFFD). Функции, выполняющие эту проверку и замену, задокументированы фразой &amp;laquo;Выполняет замену недопустимых скалярных значений&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d2e478e972382d28cdc4d59b0f5b4e6ab5fe13da" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600646925b44db293829cf7151e09bea6f08885a" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">Без &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt; обновление, в котором упоминается &lt;code&gt;foo&lt;/code&gt; , всегда будет неоднозначным, если все эти определения были в области действия. Когда расширение включено, есть несколько вариантов устранения неоднозначности обновлений:</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">Без &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; GHC отказывается делать обобщения по переменным вида. Таким образом, он по умолчанию устанавливает для переменных &lt;code&gt;Type&lt;/code&gt; значение Тип, когда это возможно; когда это невозможно, выдается ошибка.</target>
        </trans-unit>
        <trans-unit id="2a9c3c68ec886ab1a40dbb182885c56e2b6ca831" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;#11679&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">Без &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt; это анализируется как понимание списка. В &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; &lt;/a&gt; это обрабатывается как квази-цитата; однако этот синтаксический анализ завершится неудачно из-за отсутствия закрытия &lt;code&gt;|]&lt;/code&gt; . См. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Выпуск № 11679&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">Без опции &lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt; ваши &lt;code&gt;SCC&lt;/code&gt; игнорируются; так что вы можете скомпилировать &lt;code&gt;SCC&lt;/code&gt; - загруженный код, не меняя его.</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">Без всяких аргументов,отображает текущий набор опций,которые применяются к выражениям и командам,набранным в подсказке.</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">Не поднимая пальца, параметр &lt;code&gt;?cmp&lt;/code&gt; также становится параметром &lt;code&gt;least&lt;/code&gt; . При использовании явных параметров по умолчанию параметры всегда должны передаваться явно. При использовании неявных параметров по умолчанию они всегда распространяются.</target>
        </trans-unit>
        <trans-unit id="55d043b366c8c5411ad6e6a869f14d78a5f201f3" translate="yes" xml:space="preserve">
          <source>Without newtypes &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; f&lt;/code&gt; equals precomposing with &lt;code&gt;f&lt;/code&gt; (= &lt;code&gt;(. f)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">Без &lt;code&gt;MINIMAL&lt;/code&gt; MINIMAL предупреждение не было бы создано для экземпляра, который не реализует ни один из методов.</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">Без &lt;code&gt;forall b&lt;/code&gt; переменная типа &lt;code&gt;b&lt;/code&gt; была бы количественно оценена по всему объявлению экземпляра, что не является тем, что предполагается.</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">Без префикса &lt;code&gt;pattern&lt;/code&gt; &lt;code&gt;Zero&lt;/code&gt; будет интерпретироваться как конструктор типа в списке экспорта.</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">Свидетель для распакованного значения &lt;code&gt;Proxy#&lt;/code&gt; , которое не имеет представления во время выполнения.</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">Следите за разрушением:</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">Завершение слов</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="70a7003c530361b27dbad2666f3119f63d7aa52c" translate="yes" xml:space="preserve">
          <source>Word32Rep</source>
          <target state="translated">Word32Rep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
        <trans-unit id="6df564da800ea9db332a4e4f70ac3b7baee68108" translate="yes" xml:space="preserve">
          <source>Word64X8#</source>
          <target state="translated">Word64X8#</target>
        </trans-unit>
        <trans-unit id="7d4f09dfc217ef6de83fd0a7817a34a9c524f5f8" translate="yes" xml:space="preserve">
          <source>Word8</source>
          <target state="translated">Word8</target>
        </trans-unit>
        <trans-unit id="1026530b7f2b7d11ceed950f769ae8af9db41c6d" translate="yes" xml:space="preserve">
          <source>Word8#</source>
          <target state="translated">Word8#</target>
        </trans-unit>
        <trans-unit id="46fa1330e06c95858d3c751456971104c43240e6" translate="yes" xml:space="preserve">
          <source>Word8ElemRep</source>
          <target state="translated">Word8ElemRep</target>
        </trans-unit>
        <trans-unit id="bb25378aca5d0bf9417565eddafe0c9955fced88" translate="yes" xml:space="preserve">
          <source>Word8Rep</source>
          <target state="translated">Word8Rep</target>
        </trans-unit>
        <trans-unit id="6d9c171610680a48a7e1adce25e5ef2175c1786b" translate="yes" xml:space="preserve">
          <source>Word8X16#</source>
          <target state="translated">Word8X16#</target>
        </trans-unit>
        <trans-unit id="7d2b3864aa2a328b268de16ec90a676d025166df" translate="yes" xml:space="preserve">
          <source>Word8X32#</source>
          <target state="translated">Word8X32#</target>
        </trans-unit>
        <trans-unit id="420bed9409614065e79233ee278151c88a99c07c" translate="yes" xml:space="preserve">
          <source>Word8X64#</source>
          <target state="translated">Word8X64#</target>
        </trans-unit>
        <trans-unit id="84c6a57a62c9a723bc4c3a3bbe6ffc9a885219d9" translate="yes" xml:space="preserve">
          <source>WordPtr</source>
          <target state="translated">WordPtr</target>
        </trans-unit>
        <trans-unit id="68dc8baeafc9a279622fb5e31be3ed83d95357da" translate="yes" xml:space="preserve">
          <source>WordRep</source>
          <target state="translated">WordRep</target>
        </trans-unit>
        <trans-unit id="7ba9e8f41622b0ccfc835a4f2140ab6eea7b7e9b" translate="yes" xml:space="preserve">
          <source>Work left-to-right through the input list of type variables, with a cursor.</source>
          <target state="translated">Работайте слева направо через входной список переменных типа,с помощью курсора.</target>
        </trans-unit>
        <trans-unit id="bc1c455e1b31ed1393785a6cdc3045bbb118f243" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обходной путь, чтобы мы могли получить &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;ошибки&lt;/a&gt; экземпляра Haskell 98 .</target>
        </trans-unit>
        <trans-unit id="9c02809968c5a04b4bf0b6d24112481a63ca6dca" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b99ada0b9847a43772d5b421ac47cdacf3632e" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab49cd9ef02b20b8f0a395f52a3bac5f961ae20" translate="yes" xml:space="preserve">
          <source>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove &lt;em&gt;all&lt;/em&gt; value lambdas.</source>
          <target state="translated">Worker-wrapper удаляет неиспользуемые аргументы, но обычно мы не удаляем их все, чтобы не превратить закрытие функции в преобразователь, что, возможно, приведет к утечке пространства и / или нарушению встраивания. Этот флаг позволяет исполнителю / оболочке удалить &lt;em&gt;все&lt;/em&gt; лямбда-выражения значений.</target>
        </trans-unit>
        <trans-unit id="61f4d4dd918269bf5a5ff69500737f2e3c652d80" translate="yes" xml:space="preserve">
          <source>Working with equality</source>
          <target state="translated">Работать на равноправной основе</target>
        </trans-unit>
        <trans-unit id="b7851eadac070ddfea609696fdeb164b7899ebe8" translate="yes" xml:space="preserve">
          <source>Would result in a generated &lt;code&gt;Functor&lt;/code&gt; instance like so:</source>
          <target state="translated">Результатом будет сгенерированный экземпляр &lt;code&gt;Functor&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="6ee562876821329b8991ff4daaadbf4f98ef9b98" translate="yes" xml:space="preserve">
          <source>Wrap a BCO in a &lt;code&gt;AP_UPD&lt;/code&gt; thunk which will be updated with the value of the BCO when evaluated.</source>
          <target state="translated">Оберните BCO в &lt;code&gt;AP_UPD&lt;/code&gt; который будет обновлен значением BCO при оценке.</target>
        </trans-unit>
        <trans-unit id="16397dd6317efa9c9836ee42453758565f8d25ed" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">Оберните вычисление &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода для тайм-аута и возврата &lt;code&gt;Nothing&lt;/code&gt; , если результат не будет доступен в течение &lt;code&gt;n&lt;/code&gt; микросекунд (1/10 &lt;code&gt;1/10^6&lt;/code&gt; секунд). Если результат доступен до истечения тайм-аута, возвращается &lt;code&gt;Just a&lt;/code&gt; . Отрицательный интервал тайм-аута означает &amp;laquo;ждать бесконечно&amp;raquo;. При указании длинных тайм-аутов будьте осторожны, чтобы не превышать &lt;code&gt;maxBound :: Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="298bd3ed150b3f0eda86e3bd26b9d517dfc0dc76" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0379570077ecabca08995c42a34f4a46b3ee2ced" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769d436eab4aa870cf748d72592199f75a9fdf28" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">Оберните вычисление &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; вывода для тайм-аута и возврата &lt;code&gt;Nothing&lt;/code&gt; , если результат не будет доступен в течение &lt;code&gt;n&lt;/code&gt; микросекунд (1/10 &lt;code&gt;1/10^6&lt;/code&gt; секунд). Если результат доступен до истечения тайм-аута, возвращается &lt;code&gt;Just a&lt;/code&gt; . Отрицательный интервал тайм-аута означает &amp;laquo;ждать бесконечно&amp;raquo;. При указании длинных тайм-аутов будьте осторожны, чтобы не превышать &lt;code&gt;maxBound :: Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="052e52e2ec601e51ff67cce14d06f664e23dd732" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;&quot;...&quot;&lt;/code&gt;</source>
          <target state="translated">Обернуть документ в &lt;code&gt;&quot;...&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2463a3964a6d5f90893a0cb4a83e415f58109e" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;'...'&lt;/code&gt;</source>
          <target state="translated">Обернуть документ в &lt;code&gt;'...'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e11d85c98f81ceac1c15ffeb3554f6ef50d942c9" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;(...)&lt;/code&gt;</source>
          <target state="translated">Обернуть документ в &lt;code&gt;(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fefcdd75b8d3ceac5767fa9ddb3485c2fae7387b" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;[...]&lt;/code&gt;</source>
          <target state="translated">Обернуть документ в &lt;code&gt;[...]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d9a81e67b5bd2bc5cede4830f07d4ee5769499a" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;{...}&lt;/code&gt;</source>
          <target state="translated">Обернуть документ в &lt;code&gt;{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5150dc051fd47e830d39a1a10a0d5cede823b6b" translate="yes" xml:space="preserve">
          <source>WrapArrow</source>
          <target state="translated">WrapArrow</target>
        </trans-unit>
        <trans-unit id="c92147ea0c2b0677b7c09751757b19d07bd7b17c" translate="yes" xml:space="preserve">
          <source>WrapMonad</source>
          <target state="translated">WrapMonad</target>
        </trans-unit>
        <trans-unit id="4069d5a8b2d61fc44c53d1d69a1603e75124fe55" translate="yes" xml:space="preserve">
          <source>WrapMonoid</source>
          <target state="translated">WrapMonoid</target>
        </trans-unit>
        <trans-unit id="f72344941ecf4dbf3a6b05f7d128cba499a51fde" translate="yes" xml:space="preserve">
          <source>WrappedArrow</source>
          <target state="translated">WrappedArrow</target>
        </trans-unit>
        <trans-unit id="5424268dd193f61b9e7843ef4109dc2a12bac7a6" translate="yes" xml:space="preserve">
          <source>WrappedMonad</source>
          <target state="translated">WrappedMonad</target>
        </trans-unit>
        <trans-unit id="459140ee141c9d01be26238b973ae1046e530be2" translate="yes" xml:space="preserve">
          <source>WrappedMonoid</source>
          <target state="translated">WrappedMonoid</target>
        </trans-unit>
        <trans-unit id="6f21817c0f554ef006f52930cf8b3fb843bafa13" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; with faster implementation for GHC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb18f208c8e09b8e152ee97be9d763608b85aabc" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">Обертка &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; с более быстрой реализацией для GHC</target>
        </trans-unit>
        <trans-unit id="f5bae4c947473ab2febca5eb61bfa9da65f60ac7" translate="yes" xml:space="preserve">
          <source>Wrapping an IO action that can throw an error &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">Завершение действия ввода-вывода, которое может вызвать ошибку &lt;code&gt;e&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d27d9e2d3a2ad251d4892a773947e707db18720" translate="yes" xml:space="preserve">
          <source>Wrapping documents in delimiters</source>
          <target state="translated">Упаковка документов в разделители</target>
        </trans-unit>
        <trans-unit id="48606f4bb9cb6f76c6d45f0aae55cb4f7a999651" translate="yes" xml:space="preserve">
          <source>Write 31-bit character; offset in 4-byte words.</source>
          <target state="translated">Запишите 31-битный символ;смещение в 4-байтных словах.</target>
        </trans-unit>
        <trans-unit id="132823a14fa0074e9c3549c122a220890e54d9b3" translate="yes" xml:space="preserve">
          <source>Write 8-bit character; offset in bytes.</source>
          <target state="translated">Запишите 8-битный символ;смещение в байтах.</target>
        </trans-unit>
        <trans-unit id="6cfb95525e855d3c2fb90f553acacc9ffd9b1afe" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">Записать &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; в буфер</target>
        </trans-unit>
        <trans-unit id="0296abfbf70a590c6ce425e8d54f6de5c2d195a0" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30ef0a4dea3adbd954b944a856f0d73077a7fef" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">Напишите файл &lt;code&gt;.tix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2384eda70bde5fbafcdce06c7083ad1f34fba13d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">Запишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; , используя кодировку локали.</target>
        </trans-unit>
        <trans-unit id="641fdc517a3a148a3426445c3e2501afc543647f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; в формате IEEE-754 с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="19f5831180b0536c875f7fde0710ba2f6b629a3f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; в формате IEEE-754 с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="993b7cc9e4c74d2721eedc685664742cc7c82795" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; в собственном формате в формате IEEE-754 с порядком байтов на хосте.</target>
        </trans-unit>
        <trans-unit id="025b69c4396276807676b294d74b3b70f46bef94" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; в формате IEEE-754 с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="2300f23523bc1b33ccbbebf657381c02dd05c86c" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; в формате IEEE-754 с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="9a6e3e08979b85f7f159802afa8ee51f8a4eedd1" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">Напишите &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; в собственном формате в формате IEEE-754 с порядком байтов на хосте.</target>
        </trans-unit>
        <trans-unit id="100ddab2dd798658dd4fbb44584d4757dded426e" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cb939ce09480dcfa16a616504013b186c6decd" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ec2c319cd8c0e2c3a0c3951b37ec1585cee156" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545e766b627e659fd52bff3acf015eb9994ae5c5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65b44a7ea8883932f7651be10c9246fc522dca8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead3e3f2656945a589c0165356d2eb079e613140" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2feadbf9adb1a358b7e0093340ebf583af8879d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde29449d3f0108ac52954edaff927f556465b38" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9ab35d2642c9b5be7308adfb540fe471522384" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb93655e29d96d133136c01dc591f84e22055de5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c67f5d3071082cd12eed2b10946f5237ea28fd6" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cad8d95d64d25782658d6f8b5c3b46df8c39dd8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b24d9d9e097aac96beae3883a886f722fde4c0" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6238f387e14de2e21a90134fdf8ba25fdaaeefb7" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed5c3f805685b995398b8616a908c0066ad70a" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">Записать &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; в файл.</target>
        </trans-unit>
        <trans-unit id="ca463eab69a5fff98e0ab2e75dce7ed014b9ab1b" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">Записать &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; в файл.</target>
        </trans-unit>
        <trans-unit id="3ad21d75c6a544747e2e36fcec12a87a1aebe727" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">Записать &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; в файл.</target>
        </trans-unit>
        <trans-unit id="a8e6f690eb143ffdbea5335db0be7244660876a2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">Записать &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; в файл.</target>
        </trans-unit>
        <trans-unit id="244e830bbe30fb0c3258c35cfc26647f07415c80" translate="yes" xml:space="preserve">
          <source>Write a ByteString to a handle, appending a newline byte</source>
          <target state="translated">Напишите ByteString на ручку,добавляя байт новой строки.</target>
        </trans-unit>
        <trans-unit id="a70a82a5347cdeed11b696c9567115f30a6a5296" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout</source>
          <target state="translated">Написать байтСтринг в stdout</target>
        </trans-unit>
        <trans-unit id="e8ad66b8476a9e49cc072f07250605c906e95e94" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout, appending a newline byte</source>
          <target state="translated">Напишите ByteString в stdout,добавив байт новой строки.</target>
        </trans-unit>
        <trans-unit id="c0c3cc8f4573e40e62c43e8422d4118f97ea3fea" translate="yes" xml:space="preserve">
          <source>Write a Int16 in big endian format</source>
          <target state="translated">Написать Int16 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="9d73a70f9f179a81035be58cee26e559014c575a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in little endian format</source>
          <target state="translated">Напишите Int16 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="7d8b2b4323c44fde9919abbfb9988c387020100a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Int16 в порядке родного хозяина и эндианстве хозяина.2 байта будут написаны,не выровненные.</target>
        </trans-unit>
        <trans-unit id="fb3123d3e54a5bdf6aa5b4391bbf7b28df79fb37" translate="yes" xml:space="preserve">
          <source>Write a Int32 in big endian format</source>
          <target state="translated">Написать Int32 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="7e919ad40c1b9ea38485684cbf74d8a9568b9af7" translate="yes" xml:space="preserve">
          <source>Write a Int32 in little endian format</source>
          <target state="translated">Напишите Int32 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="c8c3c578503e8e7468915f61ff1fa6751340cce3" translate="yes" xml:space="preserve">
          <source>Write a Int32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Int32 в порядке родного хозяина и эндианстве хозяина.Будет записано 4 байта без выравнивания.</target>
        </trans-unit>
        <trans-unit id="b4e181d3a02580a355986a71c12d4507242968cf" translate="yes" xml:space="preserve">
          <source>Write a Int64 in big endian format</source>
          <target state="translated">Написать Int64 в большом эндийском формате</target>
        </trans-unit>
        <trans-unit id="6a15b266b9877bbd729c40ccb87aa3db359c9f58" translate="yes" xml:space="preserve">
          <source>Write a Int64 in little endian format</source>
          <target state="translated">Напишите Int64 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="001b75a9a615fe6648502bcfe94fd2920ba86af5" translate="yes" xml:space="preserve">
          <source>Write a Int64 in native host order. On a 32 bit machine we write two host order Int32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Int64 в порядке &quot;родного&quot; хоста.На 32-битной машине мы пишем два хоста в порядке Int32,в большом эндиане.Будет записано 8 байт без выравнивания.</target>
        </trans-unit>
        <trans-unit id="50fde014dba0a50360d764d6c2704238d9a9cb90" translate="yes" xml:space="preserve">
          <source>Write a String using UTF-8 encoding.</source>
          <target state="translated">Напишите строку,используя кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="ca1a04969f07426c1e00b1b3766e301003971851" translate="yes" xml:space="preserve">
          <source>Write a Unicode string to the user's standard output.</source>
          <target state="translated">Запишите строку Юникода в стандартный вывод пользователя.</target>
        </trans-unit>
        <trans-unit id="de13c62099cbcafc759fb5510fbb414e0c611d13" translate="yes" xml:space="preserve">
          <source>Write a Word16 in big endian format</source>
          <target state="translated">Напишите Word16 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="1d3480abbd86fc7688fd650a23916c935ed2b876" translate="yes" xml:space="preserve">
          <source>Write a Word16 in little endian format</source>
          <target state="translated">Напишите Word16 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="374953a98335b9e84fa5e0a4c035b46b2a892799" translate="yes" xml:space="preserve">
          <source>Write a Word16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Word16 в порядке родного хозяина и эндианства хозяина.2 байта будут написаны,не выровненные.</target>
        </trans-unit>
        <trans-unit id="b1d543a7902bc6e8e15046b66cf37db05811d00c" translate="yes" xml:space="preserve">
          <source>Write a Word32 in big endian format</source>
          <target state="translated">Напишите Word32 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="426bab66f99e758605e62a76ce97b5ce1321c0e7" translate="yes" xml:space="preserve">
          <source>Write a Word32 in little endian format</source>
          <target state="translated">Напишите Word32 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="22533b04aaf4738c420c7810c743da18ca10d4e0" translate="yes" xml:space="preserve">
          <source>Write a Word32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Word32 в порядке родного хозяина и эндианства хозяина.Будет написано 4 байта,без выравнивания.</target>
        </trans-unit>
        <trans-unit id="d00bd933478ce30ee3627449becbce383505e676" translate="yes" xml:space="preserve">
          <source>Write a Word64 in big endian format</source>
          <target state="translated">Написать Word64 в большом эндийском формате</target>
        </trans-unit>
        <trans-unit id="1ccded859c25705e9ae2dccba946964f2b4b599e" translate="yes" xml:space="preserve">
          <source>Write a Word64 in little endian format</source>
          <target state="translated">Напишите Word64 в формате little endian</target>
        </trans-unit>
        <trans-unit id="fe8b5771af7a4fe3ab30f772b71da7013250ca90" translate="yes" xml:space="preserve">
          <source>Write a Word64 in native host order. On a 32 bit machine we write two host order Word32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">Напишите Word64 в порядке родного хоста.На 32-битной машине мы пишем два хоста в порядке Word32s,в большом эндийском.Будет записано 8 байт,без выравнивания.</target>
        </trans-unit>
        <trans-unit id="d084d0a0a3ee70356c669bbf84781436e439ab8d" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">Запишите символ в массив по заданному смещению. Возвращает количество &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="841f4e3a7f9355477f1154322e4d479f881e0fd9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead19630563db8c3d93106011641efd62bcf10e9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824db4935989674b3e285858238d002d124cd8b6" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Запишите символ на стандартное устройство вывода (то же, что и &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7382100d9830a823b89994904abbed419d0ca6e4" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d825454d2db1c3d3f226a28bb4ebdfec603097" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Запишите символ на стандартное устройство вывода (то же, что и &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="955d70d1572c0c0ab9646927bdac5ea547ae35f8" translate="yes" xml:space="preserve">
          <source>Write a character using UTF-8 encoding.</source>
          <target state="translated">Запишите символ в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="0a40d25653018769760da200e171fb69042b97ba" translate="yes" xml:space="preserve">
          <source>Write a floating point value to a &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите значение с плавающей запятой в &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f0e537457e84f16fbaa39fa0827e8c740824c36" translate="yes" xml:space="preserve">
          <source>Write a lazy ByteString efficiently, simply appending the lazy ByteString chunks to the output buffer</source>
          <target state="translated">Написать ленивый ByteString эффективно,просто добавляя ленивые ByteString куски в выходной буфер</target>
        </trans-unit>
        <trans-unit id="4a5a6f538364d52e8d401c4fc9299b67f51eb2c1" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">Запишите список сохраняемых элементов во вновь выделенную последовательную последовательность сохраняемых значений (как &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; , но для нескольких элементов).</target>
        </trans-unit>
        <trans-unit id="cdf3a3bd7d79bb717fec0614e932a3f554e7d129" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker</source>
          <target state="translated">Записать список хранимых элементов во вновь выделенную последовательную последовательность хранимых значений,где конец фиксируется заданным маркером конца</target>
        </trans-unit>
        <trans-unit id="46dde6be964e98cc511af24b16c6e57e81e0249e" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ded1b880637c536601d5622865a8ac5bee12d73f" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b15bee858199106a92ca21868dcf92516cce78a" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfd1ae109907abef00a2e666c2fb353f397524eb" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0bbd3fd99a0c8ca169dc0a0800f474e5f53bf14" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a779d08a6f4043a50272816a75acd9ee4cacd4c" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Записать новое значение в &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20f4593948df5a33a2e433f875c4b3f08e697cff" translate="yes" xml:space="preserve">
          <source>Write a string the end of a file.</source>
          <target state="translated">Запишите строку в конец файла.</target>
        </trans-unit>
        <trans-unit id="c180f2e1d927a73773a56afa0d7e8518dedba44e" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">Запишите строку в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; , за которой следует перевод строки.</target>
        </trans-unit>
        <trans-unit id="f7e8eefc7a202ba520c173df9a961b393fa4acc7" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Напишите строку в стандартный &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f730ea108860688ef12de2017ea9ad535914f4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0c99c259a0bae8a5de169024806ed9278e047" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfa6ba6c0cf344b0e6e3107b4b376c5c61df5aa" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cbb856cec403b79eb6afecd39da04f2c3b3bb4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7142ba8529e9f3798882070ee18b16fa9830450d" translate="yes" xml:space="preserve">
          <source>Write a string to a file. The file is truncated to zero length before writing begins.</source>
          <target state="translated">Запишите строку в файл.Перед началом записи файл усекается до нулевой длины.</target>
        </trans-unit>
        <trans-unit id="1c2990ff65d290d7bbb87a7564d0e4e76c8f8255" translate="yes" xml:space="preserve">
          <source>Write a string to a handle, followed by a newline.</source>
          <target state="translated">Запишите строку на рукоятку,а затем новую строку.</target>
        </trans-unit>
        <trans-unit id="bd7a02731ecdcdf45341edba546df5ac23933c67" translate="yes" xml:space="preserve">
          <source>Write a string to a handle.</source>
          <target state="translated">Напишите строку на ручку.</target>
        </trans-unit>
        <trans-unit id="ece9511f02a82892ce27b96dda3476e25a7fbdb9" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Запишите строку на стандартное устройство вывода (то же, что и &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f865cedd38348737be2e60d87bff870c9a8dd6d6" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa575f023b590cb0185153c4e3bb7bcdf3ca8ca" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Запишите строку на стандартное устройство вывода (то же, что и &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ddf3308755406ffab4fefd34e1c0f532c36bfca" translate="yes" xml:space="preserve">
          <source>Write a string to the user's standard output, followed by a newline.</source>
          <target state="translated">Запишите строку в стандартный вывод пользователя,а затем новую строку.</target>
        </trans-unit>
        <trans-unit id="d649865e90fcbff9ffe50b1a59105ee5172bcad2" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Напишите значение &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bb0e77531d8dd5855a5dee42f98bdfb66dea502" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;; blocks if the queue is full.</source>
          <target state="translated">Записать значение в &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; ; блокируется, если очередь заполнена.</target>
        </trans-unit>
        <trans-unit id="9b880d3a6f95fb0643f6f8cb86d9febe4b457c2d" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите значение в &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="502f2a89fe6ab954ea36d4a5f5ae4da0588aaadf" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите значение в &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b003c4b3a259d538a4ba6bcb5c8dd4f54a8c348a" translate="yes" xml:space="preserve">
          <source>Write a value to a memory area regarded as an array of values of the same kind. The following equality holds:</source>
          <target state="translated">Записать значение в область памяти,рассматриваемую как массив однотипных значений.Равенство имеет следующее значение:</target>
        </trans-unit>
        <trans-unit id="2278658d6c531603ea71643e435890480712f25e" translate="yes" xml:space="preserve">
          <source>Write a value to a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">Запишите значение в ячейку памяти,заданное базовым адресом и смещением.Равенство имеет следующее значение:</target>
        </trans-unit>
        <trans-unit id="d2bcb5f72dff224c65e70a09f3049dbb8677df2f" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">Запишите вектор в заданный индекс мутируемого массива скаляров;смещение-в скалярных элементах.</target>
        </trans-unit>
        <trans-unit id="47fbcdcf5427d81f8e800b2a3be52a9b2780f1f2" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array.</source>
          <target state="translated">Запись вектора в указанный индекс мутируемого массива.</target>
        </trans-unit>
        <trans-unit id="2cbdaab506338b440edffc79752d43d3b372babf" translate="yes" xml:space="preserve">
          <source>Write an Int16 in big endian format</source>
          <target state="translated">Написать Int16 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="a4e76ca260148b04e485fd2b3ab9435bef6ca68d" translate="yes" xml:space="preserve">
          <source>Write an Int16 in little endian format</source>
          <target state="translated">Напишите Int16 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="04d7dd93d431136691244f8a8060c6f710b4c9c7" translate="yes" xml:space="preserve">
          <source>Write an Int32 in big endian format</source>
          <target state="translated">Написать Int32 в большом эндийском формате.</target>
        </trans-unit>
        <trans-unit id="ac3eecde6710e67b4fbd62fe5faea7085564b9e9" translate="yes" xml:space="preserve">
          <source>Write an Int32 in little endian format</source>
          <target state="translated">Напишите Int32 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="4ecb73c918eeb208591574c27bf43973ceabac8a" translate="yes" xml:space="preserve">
          <source>Write an Int64 in big endian format</source>
          <target state="translated">Написать Int64 в большом эндийском формате</target>
        </trans-unit>
        <trans-unit id="062b3fd33b7744aa05c8b488aac57bd5719de134" translate="yes" xml:space="preserve">
          <source>Write an Int64 in little endian format</source>
          <target state="translated">Напишите Int64 в маленьком эндийском формате.</target>
        </trans-unit>
        <trans-unit id="f3475a216b60f541f9561999947a42033537d47f" translate="yes" xml:space="preserve">
          <source>Write an element in a mutable array</source>
          <target state="translated">Запись элемента в мутирующий массив</target>
        </trans-unit>
        <trans-unit id="3a6dc8d047fec7b46b0233f24f9a28adcd679e26" translate="yes" xml:space="preserve">
          <source>Write an entire list of items to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Написать весь список элементов в &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9599a175165c39f1f29ddd9bb8c7e18497bf06b" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;MutVar#&lt;/code&gt;.</source>
          <target state="translated">Напишите содержимое &lt;code&gt;MutVar#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842c4baf59de10dbe1f4228d4e89548eb6cfad90" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;TVar#&lt;/code&gt;.</source>
          <target state="translated">Напишите содержимое &lt;code&gt;TVar#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3de1d04f7bf6af5e972546fb7777d6bafc52d88" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">Записать данные из памяти в &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; . Это в точности эквивалентно функции &lt;code&gt;write&lt;/code&gt; POSIX .</target>
        </trans-unit>
        <trans-unit id="3589adf6c850b011d135abac8239e99774d7263d" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d30b89159dbe8adf88a13bf3ed9d62236eb08e2" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15fb50864a59ead622c1afb8db98eae0916f34" translate="yes" xml:space="preserve">
          <source>Write file in UTF-8 encoding. Parent directory will be created if missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7773c80499d5b3f15854fd0b2e72f86ef50f9e8" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите данное сообщение об ошибке в &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; и завершите с помощью &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1dcba72b258ea0ed5115b0f30bfb1d0dcb08793" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4355c147f16522d41a43d5a06119aedec6f7144b" translate="yes" xml:space="preserve">
          <source>Write output from main C-\- pipeline passes to files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96bdb27f817c3c1baec26eb6ded0edc44bb3c99" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите данное значение в указанную ячейку памяти. Могут применяться ограничения по выравниванию; посмотреть &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77655bd9fbe731998656fdcf621486c02b0a375a" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите данное значение в указанную ячейку памяти. Могут применяться ограничения по выравниванию; посмотреть &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babfd98df4815040b9b8feaf92e4a373432b470f" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory</source>
          <target state="translated">Запись последовательных элементов списка в память</target>
        </trans-unit>
        <trans-unit id="c13f0a2faae8bb31701cafde84fa1d469581a021" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory and terminate them with the given marker element</source>
          <target state="translated">Записать последовательные элементы списка в память и завершить их заданным элементом маркера</target>
        </trans-unit>
        <trans-unit id="3e02cf61d4db014ee685a86394e5a58900284ddf" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes starting at a given offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfb3401061c515a5bf897d647437c6e727895e8" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes.</source>
          <target state="translated">Запишите указанное количество байт.</target>
        </trans-unit>
        <trans-unit id="7948630f19859069bae4a14e2c76f2c7020b9d2a" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите полученное значение в &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8756d20514051c6080e747e02c7172e182a101af" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите полученное значение в &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f27a7a93b6c3f65c763bd60036589804bd7bf721" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите полученное значение в &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155f12112f4379352bcdee8335e8ff9abd964e75" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the standard output device.</source>
          <target state="translated">Запишите клеммный выход на стандартное выходное устройство.</target>
        </trans-unit>
        <trans-unit id="2ffb13840f565fd761a331ddc6dc0237d509420b" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Запишите вывод терминала в терминал или файл, управляемый данным &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd750e768a4d8f40411b104e6eddf083a4f201a" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354772ef04e9b2d16c5fe14016464a4e279a0ec7" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bab7a81286ec426207ad20332db127f5e40c79b" translate="yes" xml:space="preserve">
          <source>Write to specified index of mutable array.</source>
          <target state="translated">Запись в указанный индекс мутируемого массива.</target>
        </trans-unit>
        <trans-unit id="8062d7bf97a30b717d53fc3dbe2d6e2c50919458" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking starting at a given offset. Returns the actual number of bytes written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa64ad5644001c4c4dc3bee878a933e8c8aac0e" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking. Returns the actual number of bytes written.</source>
          <target state="translated">Записывайте до заданного количества байт без блокировки.Возвращает фактическое количество записанных байтов.</target>
        </trans-unit>
        <trans-unit id="74120aff54b3ed793ccfa34d37318c6efb458636" translate="yes" xml:space="preserve">
          <source>Write vector; offset in bytes.</source>
          <target state="translated">Вектор записи;смещение в байтах.</target>
        </trans-unit>
        <trans-unit id="fd96182628831a4dab0848bbbb0a8a86256945c3" translate="yes" xml:space="preserve">
          <source>Write vector; offset in scalar elements.</source>
          <target state="translated">Записать вектор;смещение в скалярных элементах.</target>
        </trans-unit>
        <trans-unit id="e1f97fa6627971c9b0e683428fd5abfab1ecbdb9" translate="yes" xml:space="preserve">
          <source>Write? (False = read-only)</source>
          <target state="translated">Писать? (False=только для чтения)</target>
        </trans-unit>
        <trans-unit id="09c7377b67eee34defdc1dd0804c879b090650d2" translate="yes" xml:space="preserve">
          <source>WriteBuffer</source>
          <target state="translated">WriteBuffer</target>
        </trans-unit>
        <trans-unit id="3082b1ffe24322eee941ed215c852cffc7410d42" translate="yes" xml:space="preserve">
          <source>WriteHandle</source>
          <target state="translated">WriteHandle</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="60841bf1ad2d01720515c6eb9b3efbeb2e0f7656" translate="yes" xml:space="preserve">
          <source>WriteMode</source>
          <target state="translated">WriteMode</target>
        </trans-unit>
        <trans-unit id="f5ca54e8210ce7deaf5fa1129a91a1f50f08386a" translate="yes" xml:space="preserve">
          <source>WriteOnly</source>
          <target state="translated">WriteOnly</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="a8f135f9c50f7fe5f7a287362386d791fee8800a" translate="yes" xml:space="preserve">
          <source>Writer operations</source>
          <target state="translated">Работа со сценарием</target>
        </trans-unit>
        <trans-unit id="a123ab5d3541d6386c9d34765c7348e78d2bb09e" translate="yes" xml:space="preserve">
          <source>WriterT</source>
          <target state="translated">WriterT</target>
        </trans-unit>
        <trans-unit id="1cccc800c778fc7aea514948aa922ecafd4399e9" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пишет массив &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; к указанной &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30a3e22fd6539c1c9d94fc5b04d15e2c9f7e725" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff69c85320ce63f18bed336a41ffa3b0d101a7b3" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b97a0aaa412174782d8ac6874c3f7cc18e81e9" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">Записывает файлы расширенного интерфейса вдоль обычных файлов интерфейса.Как и обычные файлы интерфейсов,GHC имеет проверку на перекомпиляцию,чтобы обнаружить устаревшие или отсутствующие файлы расширенного интерфейса.</target>
        </trans-unit>
        <trans-unit id="f8ed5cefe0e622b3e54c1d44f041cf244581a4d3" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongside regular interface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e584f7c39c3d0e184b912ee7be64b91cc4f0e227" translate="yes" xml:space="preserve">
          <source>Writes the line history to the given file. If there is an error when writing the file, it will be ignored.</source>
          <target state="translated">Записывает историю строк в данный файл.Если при записи файла будет допущена ошибка,то она будет проигнорирована.</target>
        </trans-unit>
        <trans-unit id="82675cd0bc2b58173645fe62ed090db0c903a0d8" translate="yes" xml:space="preserve">
          <source>XdgCache</source>
          <target state="translated">XdgCache</target>
        </trans-unit>
        <trans-unit id="a09516bd6fa5e0d22f97cc882d59eced3f611c61" translate="yes" xml:space="preserve">
          <source>XdgConfig</source>
          <target state="translated">XdgConfig</target>
        </trans-unit>
        <trans-unit id="513936143f60ff489cea943b4d3cf5ff7ec804be" translate="yes" xml:space="preserve">
          <source>XdgConfigDirs</source>
          <target state="translated">XdgConfigDirs</target>
        </trans-unit>
        <trans-unit id="b55b13216c4a49a521787620dab302740b661e55" translate="yes" xml:space="preserve">
          <source>XdgData</source>
          <target state="translated">XdgData</target>
        </trans-unit>
        <trans-unit id="5c87de6a1cfa7e4af282e624345c841e7d8bd0bb" translate="yes" xml:space="preserve">
          <source>XdgDataDirs</source>
          <target state="translated">XdgDataDirs</target>
        </trans-unit>
        <trans-unit id="1fbbfb2eaf00935b6eaff85397e2d3159b40fac3" translate="yes" xml:space="preserve">
          <source>XdgDirectory</source>
          <target state="translated">XdgDirectory</target>
        </trans-unit>
        <trans-unit id="2a60deb694d7c793f949c28507f268cafab38ce5" translate="yes" xml:space="preserve">
          <source>XdgDirectoryList</source>
          <target state="translated">XdgDirectoryList</target>
        </trans-unit>
        <trans-unit id="14824d205a044c81fdecf7f246ad054ed0648b74" translate="yes" xml:space="preserve">
          <source>Year and day format</source>
          <target state="translated">Формат года и дня</target>
        </trans-unit>
        <trans-unit id="ed289f57da895ead697dd2c01857ff65cfc7ea93" translate="yes" xml:space="preserve">
          <source>Year.</source>
          <target state="translated">Year.</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="520497482bb4d7526496e8edb3018d95cee38510" translate="yes" xml:space="preserve">
          <source>Yes (Explicit)</source>
          <target state="translated">Да (ясно выражается)</target>
        </trans-unit>
        <trans-unit id="90c557a6b48e6bc7ef30b6f2d5fb9c703c39cf2f" translate="yes" xml:space="preserve">
          <source>Yes (Inferred)</source>
          <target state="translated">Да (Предполагается)</target>
        </trans-unit>
        <trans-unit id="86200a8547bb15fb3a4cf8bb1368b37de64fb317" translate="yes" xml:space="preserve">
          <source>Yield &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the given &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; value is valid on the system. This implies that the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; is also system dependent as it is only defined for valid values of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выход &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , если данная &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; значение действует в системе. Это означает, что экземпляр &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; также зависит от системы, поскольку он определен только для допустимых значений &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f384c9380a1584c25f0df9644ddfab42bb5794c" translate="yes" xml:space="preserve">
          <source>Yield a &lt;em&gt;non-empty&lt;/em&gt; strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Выход в &lt;em&gt;непустой&lt;/em&gt; строгой &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="711685e6ca2af214ee9e0c03ff3f6e2991b1fffe" translate="yes" xml:space="preserve">
          <source>Yield not to its blasphemous call! Flee traveller! Flee or you will be corrupted and devoured!</source>
          <target state="translated">Не поддавайся его богохульному призыву! Путешественник в бегах! Спасайся или ты будешь испорчен и съеден!</target>
        </trans-unit>
        <trans-unit id="a5cc7a47f6c353cbfbd096e4097551052e651002" translate="yes" xml:space="preserve">
          <source>You can add a module to the scope (via &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt;) only if either (a) it is loaded, or (b) it is a module from a package that GHCi knows about. Using &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt; to try bring into scope a non-loaded module may result in the message &lt;code&gt;module M is not loaded&lt;/code&gt;.</source>
          <target state="translated">Вы можете добавить модуль в область видимости (через &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;import&lt;/code&gt; ), только если (а) он загружен, или (б) это модуль из пакета, о котором знает GHCi. Использование &lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; или &lt;code&gt;import&lt;/code&gt; для попытки ввести в область видимости незагруженного модуля может привести к тому, что &lt;code&gt;module M is not loaded&lt;/code&gt; сообщений M не загружен .</target>
        </trans-unit>
        <trans-unit id="269b166a8fb9660360ed22bb6ffd6ad1f5dbf714" translate="yes" xml:space="preserve">
          <source>You can add explicit phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; pragma, just like on an &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma; if you do so, the same phase is used for the rewrite rule and the INLINE control of the specialised function.</source>
          <target state="translated">Вы можете добавить явное управление фазой ( &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt; ) в прагму &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; , как и в прагму &lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; ; если вы это сделаете, для правила перезаписи и элемента управления INLINE специализированной функции используется одна и та же фаза.</target>
        </trans-unit>
        <trans-unit id="76b4dc225411289e9acdbfffaafe383a16ca2930" translate="yes" xml:space="preserve">
          <source>You can add phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to the RULE generated by a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, just as you can if you write a &lt;code&gt;RULE&lt;/code&gt; directly. For example:</source>
          <target state="translated">Вы можете добавить фазовый контроль ( &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt; ) к ПРАВИЛУ, сгенерированному &lt;code&gt;SPECIALIZE&lt;/code&gt; , точно так же, как если бы вы написали &lt;code&gt;RULE&lt;/code&gt; напрямую. Например:</target>
        </trans-unit>
        <trans-unit id="d19396807b5bb813f8f10443b8f102685ebd9a78" translate="yes" xml:space="preserve">
          <source>You can also define functions at the prompt:</source>
          <target state="translated">Вы также можете определить функции с помощью подсказки:</target>
        </trans-unit>
        <trans-unit id="9f2d6d5ccc9f9a9d9f25489b257a5154dc96e794" translate="yes" xml:space="preserve">
          <source>You can also get this in a more future-proof, machine readable format, with &lt;code&gt;-t --machine-readable&lt;/code&gt;:</source>
          <target state="translated">Вы также можете получить это в более перспективном, машиночитаемом формате с &lt;code&gt;-t --machine-readable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a5b15205797af6957ff9cf5c81b6dc586582e3e9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="translated">Вместо этого вы также можете использовать автономное объявление производного объекта (см. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Автономные производные объявления&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="57941d0a16c36578ea47401b7ab5a6add62861a9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf82ec7c5c55deb1e4326a6cd0200b4cd6f00276" translate="yes" xml:space="preserve">
          <source>You can annotate modules with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;module&lt;/code&gt; keyword. For example:</source>
          <target state="translated">Вы можете аннотировать модули с помощью прагмы &lt;code&gt;ANN&lt;/code&gt; , используя ключевое слово &lt;code&gt;module&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="bd200064406d69a57200444728341c157a15f8d7" translate="yes" xml:space="preserve">
          <source>You can annotate types with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;type&lt;/code&gt; keyword. For example:</source>
          <target state="translated">Вы можете аннотировать типы с помощью прагмы &lt;code&gt;ANN&lt;/code&gt; , используя ключевое слово &lt;code&gt;type&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="190d499d4f768a4e6267637fa569282ca6b46254" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a forall type:</source>
          <target state="translated">Вы можете применить синоним типа к типу forall:</target>
        </trans-unit>
        <trans-unit id="9c64d81db37258386a1e4b81a293b2b44f3418af" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a partially applied type synonym:</source>
          <target state="translated">К частично применяемому синониму типа можно применить синоним типа:</target>
        </trans-unit>
        <trans-unit id="7ff9739eba78b0ef326aef750e441b5f886825f8" translate="yes" xml:space="preserve">
          <source>You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations:</source>
          <target state="translated">К функции,классу,типу или конструктору данных можно прикрепить предупреждение со следующими декларациями верхнего уровня:</target>
        </trans-unit>
        <trans-unit id="f496445edbfd2209c4adb64a23b8653fa9374d16" translate="yes" xml:space="preserve">
          <source>You can build Haskell code into a shared library and make a package to be used by other Haskell programs. The easiest way is using Cabal, simply configure the Cabal package with the &lt;code&gt;--enable-shared&lt;/code&gt; flag.</source>
          <target state="translated">Вы можете встроить код Haskell в общую библиотеку и сделать пакет, который будет использоваться другими программами Haskell. Самый простой способ - использовать Cabal, просто настройте пакет Cabal с флагом &lt;code&gt;--enable-shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f62a92315cdce6616bfcedb52e44f10633e662" translate="yes" xml:space="preserve">
          <source>You can change the messages printed when the runtime system &amp;ldquo;blows up,&amp;rdquo; e.g., on stack overflow. The hooks for these are as follows:</source>
          <target state="translated">Вы можете изменить сообщения, выводимые при &amp;laquo;взрыве&amp;raquo; исполняющей системы, например, при переполнении стека. Крючки для них следующие:</target>
        </trans-unit>
        <trans-unit id="0d971c05fa641eaafca23d1a4589109ee786b1b8" translate="yes" xml:space="preserve">
          <source>You can check if your GHC is unregisterised by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Вы можете проверить, не зарегистрирован ли ваш GHC, вызвав &lt;code&gt;ghc --info&lt;/code&gt; (см. &lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ddf7fef2dbc32cef483b738d74cadfca1ba8b1a" translate="yes" xml:space="preserve">
          <source>You can control GHC&amp;rsquo;s package database stack using the following options:</source>
          <target state="translated">Вы можете управлять стеком базы данных пакетов GHC, используя следующие параметры:</target>
        </trans-unit>
        <trans-unit id="9ad73c7ee3619d8e3b374d0e125dd12d41cec6bc" translate="yes" xml:space="preserve">
          <source>You can define a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; by either defining &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; or by defining both &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы можете определить &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; , определив &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; или определив и &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53d888cce5d1295c1df726fcad67480174d570f2" translate="yes" xml:space="preserve">
          <source>You can disable specific classes, or enable/disable all classes at once:</source>
          <target state="translated">Вы можете отключить определенные классы или включить/выключить все классы сразу:</target>
        </trans-unit>
        <trans-unit id="2fbcd80b12cae4ea9adddbab75b6d400e890e23d" translate="yes" xml:space="preserve">
          <source>You can even implement traverse using foldTree:</source>
          <target state="translated">Вы даже можете реализовать траверс с помощью foldTree:</target>
        </trans-unit>
        <trans-unit id="a260428745d36797e89aab007cfe35565db63b20" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="translated">Вы можете получить &lt;code&gt;happy&lt;/code&gt; от &lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;Happy Homepage&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c27857069203c5dd912883a5866ed1ec720c2ef7" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26072251a75edc8b05b0ea7a052c2c2aab0d70e9" translate="yes" xml:space="preserve">
          <source>You can have an unboxed tuple in a pattern binding, thus</source>
          <target state="translated">Вы можете иметь незакрепленный кортеж в переплетении шаблонов,так что</target>
        </trans-unit>
        <trans-unit id="e9c31fd3f547dd66812622d105b2e524f835762e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">Однако вы можете использовать &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; , а также &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; для создания бесконечных ленивых байтовых строк.</target>
        </trans-unit>
        <trans-unit id="20f45eef250ed5478e99a9bcb99d2a343f22a32e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">Однако вы можете использовать &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; , а также &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; для создания бесконечных ленивых байтовых строк.</target>
        </trans-unit>
        <trans-unit id="7e461b7e374bf4b1ebdad57b113f09b1939fc459" translate="yes" xml:space="preserve">
          <source>You can identify an orphan module by looking in its interface file, &lt;code&gt;M.hi&lt;/code&gt;, using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;a href=&quot;using#modes&quot;&gt;mode&lt;/a&gt;. If there is a &lt;code&gt;[orphan module]&lt;/code&gt; on the first line, GHC considers it an orphan module.</source>
          <target state="translated">Вы можете определить модуль сироту, глядя в файле интерфейса, &lt;code&gt;M.hi&lt;/code&gt; , используя &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;a href=&quot;using#modes&quot;&gt;режим&lt;/a&gt; . Если в первой строке есть &lt;code&gt;[orphan module]&lt;/code&gt; , GHC считает его бесхозным модулем.</target>
        </trans-unit>
        <trans-unit id="38974e60b1eeba7a0c51ba486dac9a8715f3e4cb" translate="yes" xml:space="preserve">
          <source>You can include instance declarations as in Haskell; just omit the &amp;ldquo;where&amp;rdquo; part. An instance declaration need not be implemented directly; if an instance can be derived based on instances in the environment, it is considered implemented. For example, the following signature:</source>
          <target state="translated">Вы можете включать объявления экземпляров, как в Haskell; просто опустите часть &amp;laquo;где&amp;raquo;. Объявление экземпляра не обязательно реализовывать напрямую; если экземпляр может быть получен на основе экземпляров в среде, он считается реализованным. Например, следующая подпись:</target>
        </trans-unit>
        <trans-unit id="883238e8f9c1b291d24a7f3127451079919bd8ed" translate="yes" xml:space="preserve">
          <source>You can include instance declarations just as in Haskell; but omit the &amp;ldquo;where&amp;rdquo; part.</source>
          <target state="translated">Вы можете включать объявления экземпляров, как в Haskell; но опустите часть &amp;laquo;где&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dbe26650bd87158ad61fd3785ea8839ebbef7ad8" translate="yes" xml:space="preserve">
          <source>You can look at particular regions of your profile simply by loading a copy of the &lt;code&gt;.hp&lt;/code&gt; file into a text editor and deleting the unwanted samples. The resulting &lt;code&gt;.hp&lt;/code&gt; file can be run through &lt;code&gt;hp2ps&lt;/code&gt; and viewed or printed.</source>
          <target state="translated">Вы можете просмотреть определенные области своего профиля, просто загрузив копию файла &lt;code&gt;.hp&lt;/code&gt; в текстовый редактор и удалив ненужные образцы. Полученный файл &lt;code&gt;.hp&lt;/code&gt; можно запустить через &lt;code&gt;hp2ps&lt;/code&gt; и просмотреть или распечатать.</target>
        </trans-unit>
        <trans-unit id="0c84e4d34de9122e33e533828fb9f8724a21faac" translate="yes" xml:space="preserve">
          <source>You can make &lt;code&gt;stdin&lt;/code&gt; reset itself after every evaluation by giving GHCi the command &lt;code&gt;:set +r&lt;/code&gt;. This works because &lt;code&gt;stdin&lt;/code&gt; is just a top-level expression that can be reverted to its unevaluated state in the same way as any other top-level expression (CAF).</source>
          <target state="translated">Вы можете сбросить стандартный &lt;code&gt;stdin&lt;/code&gt; после каждой оценки, дав GHCi команду &lt;code&gt;:set +r&lt;/code&gt; . Это работает, потому что &lt;code&gt;stdin&lt;/code&gt; - это просто выражение верхнего уровня, которое можно вернуть в неоцененное состояние так же, как и любое другое выражение верхнего уровня (CAF).</target>
        </trans-unit>
        <trans-unit id="e642c86265941a9874870fbd23a160343b970a77" translate="yes" xml:space="preserve">
          <source>You can make GHC diverge by using &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; on an ordinarily-recursive function.</source>
          <target state="translated">Вы можете заставить GHC расходиться, используя &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; для обычно рекурсивной функции.</target>
        </trans-unit>
        <trans-unit id="d1af34bbd7e2122f7192f46d93908d24a763ec3d" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell 2010 and GHC by:</source>
          <target state="translated">Вы можете сделать код,который работает как с Haskell 2010,так и с GHC:</target>
        </trans-unit>
        <trans-unit id="410bc62782311c49772c6565c53d200146f4a94c" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell98/Haskell2010 and GHC by:</source>
          <target state="translated">Вы можете сделать код,который работает как с Haskell98/Haskell2010,так и с GHC:</target>
        </trans-unit>
        <trans-unit id="acfc22cad2a308c7de056289b725564bbb1e0277" translate="yes" xml:space="preserve">
          <source>You can omit any combination of arguments to the tuple, as in the following</source>
          <target state="translated">Вы можете опустить любую комбинацию аргументов в кортеж,как в следующих случаях</target>
        </trans-unit>
        <trans-unit id="4451b727c18bc51073a4d56eb70e8515e899636b" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="translated">Вы можете присоединяться только к сущностям, объявленным на верхнем уровне в компилируемом модуле, и вы можете использовать только неквалифицированные имена в списке сущностей. Имя с заглавной буквы, например &lt;code&gt;T&lt;/code&gt; , относится &lt;em&gt;либо&lt;/em&gt; к конструктору типа &lt;code&gt;T&lt;/code&gt; ,&lt;em&gt;либо&lt;/em&gt; к конструктору данных &lt;code&gt;T&lt;/code&gt; , либо к обоим, если оба находятся в области видимости. Если оба находятся в области видимости, в настоящее время нет возможности указать один без другого (cf fixities &lt;a href=&quot;#infix-tycons&quot;&gt;конструкторы типов&lt;/a&gt; Infix , классы и переменные типа ).</target>
        </trans-unit>
        <trans-unit id="8e643fb8989b6abc3ab3ad51c09cde6dbbb32996" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f886d18b90cb7daa351868e61fa0d9da62761871" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module &lt;em&gt;that is not part of a mutually-recursive group of modules that includes the module currently being compiled&lt;/em&gt;. Furthermore, all of the modules of the mutually-recursive group must be reachable by non-SOURCE imports from the module where the splice is to be run.</source>
          <target state="translated">Вы можете запустить функцию во время компиляции, только если она импортирована из другого модуля, &lt;em&gt;который не является частью взаимно-рекурсивной группы модулей, включающей модуль, который компилируется в данный момент&lt;/em&gt; . Кроме того, все модули взаимно-рекурсивной группы должны быть доступны для импорта без ИСТОЧНИКА из модуля, в котором будет выполняться монтаж.</target>
        </trans-unit>
        <trans-unit id="2006128483b352bda9f0e5cd0d687c4c8519ed68" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module. That is, you can&amp;rsquo;t define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it&amp;rsquo;s hard to implement.)</source>
          <target state="translated">Вы можете запустить функцию во время компиляции, только если она импортирована из другого модуля. То есть вы не можете определить функцию в модуле и вызвать ее из соединения в том же модуле. (В этом есть смысл, но это сложно реализовать.)</target>
        </trans-unit>
        <trans-unit id="0f32acc6c773313553a7cd09864edd18e6cff35d" translate="yes" xml:space="preserve">
          <source>You can package up a complete Haskell program as a DLL, to be called by some external (usually non-Haskell) program. This is usually used to implement plugins and the like, and is described below.</source>
          <target state="translated">Вы можете упаковать полную программу Haskell в виде DLL,которая будет вызвана какой-нибудь внешней (обычно не-Haskell)программой.Обычно это используется для реализации плагинов и т.п.,и описано ниже.</target>
        </trans-unit>
        <trans-unit id="8f1f2284e872267e26710c33db91da1ce9d66612" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="translated">О &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;том, как все это работает,&lt;/a&gt; вы можете прочитать в комментарии GHC.</target>
        </trans-unit>
        <trans-unit id="2b48804fb365ae68472ebab1f616e9dd08d1939a" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3199ab54d6438266dcddd5dc087118e34b7a0e2d" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9702340c88d3c9a130465b064633bbe3ada3fe" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">Вы можете читать это так же, как обычную &lt;code&gt;do&lt;/code&gt; - нотацию, но с командами вместо монадических выражений. Первая строка отправляет значение &lt;code&gt;x+1&lt;/code&gt; в качестве ввода для стрелки &lt;code&gt;f&lt;/code&gt; и сопоставляет его вывод с &lt;code&gt;y&lt;/code&gt; . В следующей строке вывод отбрасывается. Стрелка &lt;code&gt;returnA&lt;/code&gt; определена в модуле &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; как &lt;code&gt;arr id&lt;/code&gt; . Приведенный выше пример рассматривается как сокращение для</target>
        </trans-unit>
        <trans-unit id="e35a1b51b1f66368a4527f3e02178b039c453864" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e72e813532509ba13800f35b2a255158378cdcd" translate="yes" xml:space="preserve">
          <source>You can safely replace all the import declarations in &lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; with those found in its respective &lt;code&gt;.imports&lt;/code&gt; file. Why would you want to do that? Because the &amp;ldquo;minimal&amp;rdquo; imports (a) import everything explicitly, by name, and (b) import nothing that is not required. It can be quite painful to maintain this property by hand, so this flag is intended to reduce the labour.</source>
          <target state="translated">Вы можете безопасно заменить все объявления импорта в &lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; объявлениями из соответствующего файла &lt;code&gt;.imports&lt;/code&gt; . Почему вы хотите это сделать? Поскольку &amp;laquo;минимальный&amp;raquo; импорт (а) импортирует все явно, по имени и (б) не импортирует ничего, что не требуется. Поддерживать это свойство вручную может быть довольно болезненно, поэтому этот флажок предназначен для уменьшения трудозатрат.</target>
        </trans-unit>
        <trans-unit id="4cd2c20dc8038404cfcf2cb0390b2cee882280b8" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2311eafd5220e927965cb0ade033a0464e40e05e" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;3&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d11ab0fd694aaac48c2e11aa4e207640df0eae3" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">Вы можете сохранить &lt;code&gt;Main.hs&lt;/code&gt; где угодно, но если вы сохраните его где-нибудь, кроме текущего каталога &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3],&lt;/a&gt; тогда нам нужно будет перейти в правильный каталог в GHCi:</target>
        </trans-unit>
        <trans-unit id="6d1cddce0e95133d2f0c91e06c39268e36da2d8c" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee71858b230e5297e34b408df25cee981faf2858" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вы можете подавить предупреждения с помощью флага &lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b5b508f9d570be456fe99f9c95ddc6eecec794" translate="yes" xml:space="preserve">
          <source>You can turn each Haskell package into a DLL, so that multiple Haskell executables using the same packages can share the DLL files. (As opposed to linking the libraries statically, which in effect creates a new copy of the RTS and all libraries for each executable produced.)</source>
          <target state="translated">Вы можете превратить каждый пакет Haskell в DLL,чтобы несколько исполняемых файлов Haskell,использующих одни и те же пакеты,могли совместно использовать файлы DLL.(В отличие от статического связывания библиотек,которое,по сути,создает новую копию RTS и всех библиотек для каждого создаваемого исполняемого файла).</target>
        </trans-unit>
        <trans-unit id="6a0144c3e2ac0c6bb9606a34c0cd2ffa74b49390" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; to obtain integer/word timestamps. For example:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; для получения временных меток целых чисел или слов. Например:</target>
        </trans-unit>
        <trans-unit id="fbf78f5184b54413fec2edf8ed7eaa43cd191246" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a &lt;code&gt;data instance&lt;/code&gt; or &lt;code&gt;newtype instance&lt;/code&gt; declaration.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;deriving&lt;/code&gt; предложение для &lt;code&gt;data instance&lt;/code&gt; или объявления экземпляра &lt;code&gt;newtype instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aac8ca00f383844bd9a5a98bae02690f26dd140" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a GADT-style data type declaration. For example, these two declarations are equivalent</source>
          <target state="translated">Вы можете использовать &lt;code&gt;deriving&lt;/code&gt; предложение в объявлении типа данных в стиле GADT. Например, эти два объявления эквивалентны</target>
        </trans-unit>
        <trans-unit id="b44303f497b7577f2a1611533f1079fe99f952ce" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243f575d20a545ebc20c87833a714937518039c5" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать внешнюю функцию main, если инициализируете RTS вручную и передаете &lt;code&gt;-no-hs-main&lt;/code&gt; . См. Также &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Использование собственного main ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e680225c09eb0b9138a98df5d3c63c9df7449b8c" translate="yes" xml:space="preserve">
          <source>You can use record syntax on a GADT-style data type declaration:</source>
          <target state="translated">Синтаксис записи можно использовать при объявлении типа данных в стиле GADT:</target>
        </trans-unit>
        <trans-unit id="fa6a1ff9acc225bb23ca386352cd635b7095181d" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;exts/rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409585b916d348cb201d92711807df5aad400581" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="translated">Вы можете использовать переименование для предоставления альтернативной прелюдии, например &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt; вместо &lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;синтаксиса Rebindable и неявного&lt;/a&gt; расширения импорта Prelude .</target>
        </trans-unit>
        <trans-unit id="34cd599ca69b1635630c1789384078026b1631bc" translate="yes" xml:space="preserve">
          <source>You can use strictness annotations, in the obvious places in the constructor type:</source>
          <target state="translated">Можно использовать примечания к строчности,в очевидных местах типа конструктора:</target>
        </trans-unit>
        <trans-unit id="ed972027c3bec7c1eb51e6a5766ee6c2d7ade065" translate="yes" xml:space="preserve">
          <source>You can work on an entire module thus:</source>
          <target state="translated">Таким образом,Вы можете работать над целым модулем:</target>
        </trans-unit>
        <trans-unit id="bf48999c2bd9335885a5b2d5518e8a1da408a898" translate="yes" xml:space="preserve">
          <source>You can wrap a series of foreign function calls that rely on thread-local state with &lt;code&gt;runInBoundThread&lt;/code&gt; so that you can use them without knowing whether the current thread is &lt;em&gt;bound&lt;/em&gt;.</source>
          <target state="translated">Вы можете обернуть серию вызовов внешних функций, которые зависят от локального состояния &lt;code&gt;runInBoundThread&lt;/code&gt; с помощью runInBoundThread, чтобы вы могли использовать их, не зная, &lt;em&gt;привязан&lt;/em&gt; ли текущий поток .</target>
        </trans-unit>
        <trans-unit id="01f309884997472a9a1052740889026ae8bf67aa" translate="yes" xml:space="preserve">
          <source>You can write a &lt;code&gt;forall&lt;/code&gt; (including overloading) in a type synonym, thus:</source>
          <target state="translated">Вы можете написать &lt;code&gt;forall&lt;/code&gt; (включая перегрузку) в синоним типа, таким образом:</target>
        </trans-unit>
        <trans-unit id="4c8f6089007a930f61ef159774cdb1a472069313" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t have an implicit parameter in the context of a class or instance declaration. For example, both these declarations are illegal:</source>
          <target state="translated">У вас не может быть неявного параметра в контексте объявления класса или экземпляра. Например, оба этих объявления являются незаконными:</target>
        </trans-unit>
        <trans-unit id="4de126d4c7a597b1d236ebb25b9bb6637ffa49d2" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t pattern-match on an existentially quantified constructor in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; group of bindings. So this is illegal:</source>
          <target state="translated">Вы не можете сопоставить шаблон для экзистенциально количественно определяемого конструктора в &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;where&lt;/code&gt; группе привязок. Итак, это незаконно:</target>
        </trans-unit>
        <trans-unit id="c72ea2d044d7e8facee1aae8ded417fac4a31d3f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use &lt;code&gt;deriving&lt;/code&gt; to define instances of a data type with existentially quantified data constructors. Reason: in most cases it would not make sense. For example:;</source>
          <target state="translated">Вы не можете использовать &lt;code&gt;deriving&lt;/code&gt; для определения экземпляров типа данных с помощью конструкторов данных с количественной оценкой существования. Причина: в большинстве случаев это не имеет смысла. Например:;</target>
        </trans-unit>
        <trans-unit id="f58bc414fc59408f4615033fa5f4af7c26c36eb5" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use existential quantification for &lt;code&gt;newtype&lt;/code&gt; declarations. So this is illegal:</source>
          <target state="translated">Вы не можете использовать количественную оценку существования для объявлений &lt;code&gt;newtype&lt;/code&gt; . Итак, это незаконно:</target>
        </trans-unit>
        <trans-unit id="3b5cdddee5d2f5aa4dc4f653d99b00c57d60b7ea" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;recursive&lt;/em&gt; binding.</source>
          <target state="translated">Невозможно связать переменную с распакованным типом в &lt;em&gt;рекурсивной&lt;/em&gt; привязке.</target>
        </trans-unit>
        <trans-unit id="8fc0d15dc8ae90bf550f66d4910d3cffc3b11e0a" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;top-level&lt;/em&gt; binding.</source>
          <target state="translated">Невозможно связать переменную с распакованным типом в привязке &lt;em&gt;верхнего уровня&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2b1b59bb7b1256234d2e287ed8419a725eea98b4" translate="yes" xml:space="preserve">
          <source>You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:</source>
          <target state="translated">Нельзя определить новый тип,тип представления (тип аргумента конструктора данных)которого является необъявленным типом.Таким образом,это противозаконно:</target>
        </trans-unit>
        <trans-unit id="53d57a9a763d91b8c3c30f9e88b44d16989b4ef8" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;deriving&lt;/code&gt; on a data type declaration; write an &lt;code&gt;instance&lt;/code&gt; declaration instead.</source>
          <target state="translated">Вы не можете использовать &lt;code&gt;deriving&lt;/code&gt; для объявления типа данных; вместо этого напишите объявление &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c32b374e885a0b6d9cb00079f7e8613d4b04f29" translate="yes" xml:space="preserve">
          <source>You cannot use a &lt;code&gt;deriving&lt;/code&gt; clause for a GADT; only for an ordinary data type.</source>
          <target state="translated">Вы не можете использовать &lt;code&gt;deriving&lt;/code&gt; предложение для GADT; только для обычного типа данных.</target>
        </trans-unit>
        <trans-unit id="30dbefdf45ec49645c5f83a96844f0e523320cd0" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;lsquo;s data constructors, you have to list it separately.</source>
          <target state="translated">Вы не можете написать &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; т. Е. Спецификации субкомпонентов не могут быть вложенными. Чтобы указать &lt;code&gt;GMap&lt;/code&gt; конструкторов данных &amp;laquo;s, вы должны перечислить его отдельно.</target>
        </trans-unit>
        <trans-unit id="504d8482be9fb213017caf5dad95956603bd628a" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;rsquo;s data constructors, you have to list it separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801821aa8abcdb27ec906dde72beecfda446438f" translate="yes" xml:space="preserve">
          <source>You construct values of types &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; by applying the constructor to suitable values, just as usual. For example,</source>
          <target state="translated">Вы &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; значения типов T1, MonadT, Swizzle, как обычно , применяя конструктор к подходящим значениям. Например,</target>
        </trans-unit>
        <trans-unit id="35e2c1cf685c898a2ffd48135532e04038f5cd4e" translate="yes" xml:space="preserve">
          <source>You could also refactor to a left-fold, to decode in a more streaming fashion, and get the following decoder. It will start to return data without knowing that it can decode all input.</source>
          <target state="translated">Вы также можете рефракционировать в левую сторону,чтобы декодировать в более потоковом режиме,и получить следующий декодер.Он начнет возвращать данные,не зная,что может декодировать все входные данные.</target>
        </trans-unit>
        <trans-unit id="71ec1076802c7edea768f5f032750297cd230b60" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to write a &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">Вам не нужно писать &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672d8bd48c35b0238c3a6248aa09088d6f74bcfe" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to give a type signature if the lambda bound variable is a constructor argument. Here is an example we saw earlier:</source>
          <target state="translated">Вам не нужно указывать сигнатуру типа, если связанная лямбда-переменная является аргументом конструктора. Вот пример, который мы видели ранее:</target>
        </trans-unit>
        <trans-unit id="e18c34733b256b9593b5ee6ff19c7fc0070729c9" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use &lt;code&gt;-fprof-auto&lt;/code&gt; for interpreted modules, annotations are automatically added at a granularity fine enough to distinguish individual call sites. However, you won&amp;rsquo;t see any call stack information for compiled code unless it was compiled with &lt;code&gt;-fprof-auto&lt;/code&gt; or has explicit &lt;code&gt;SCC&lt;/code&gt; annotations (see &lt;a href=&quot;profiling#scc-pragma&quot;&gt;Inserting cost centres by hand&lt;/a&gt;).</source>
          <target state="translated">Вам не нужно использовать &lt;code&gt;-fprof-auto&lt;/code&gt; для интерпретируемых модулей, аннотации автоматически добавляются с достаточной степенью детализации, чтобы различать отдельные сайты вызовов. Однако вы не увидите никакой информации о стеке вызовов для скомпилированного кода, если он не был скомпилирован с помощью &lt;code&gt;-fprof-auto&lt;/code&gt; или не имеет явных аннотаций &lt;code&gt;SCC&lt;/code&gt; (см. &lt;a href=&quot;profiling#scc-pragma&quot;&gt;Вставка центров затрат вручную&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31b23007442846d8966d8b9c7845ac06100f1b24" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt;</source>
          <target state="translated">Вы получаете &lt;code&gt;:type 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ece0b208425f5c34d6d99b2faf1ff3266b3af5" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro, not the builtin.</source>
          <target state="translated">Вы получите &lt;code&gt;:type 3&lt;/code&gt; с вашим определенным макросом, а не со встроенным.</target>
        </trans-unit>
        <trans-unit id="55bf28bc378f0c361c15d24c0484d765d31cbd6c" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro.</source>
          <target state="translated">Вы получите &lt;code&gt;:type 3&lt;/code&gt; с вашим определенным макросом.</target>
        </trans-unit>
        <trans-unit id="351ad6e5432243b3e78e9a641aceba23d847888a" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and a macro &lt;code&gt;:type&lt;/code&gt;, and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">У вас есть макрос &lt;code&gt;:time&lt;/code&gt; и макрос &lt;code&gt;:type&lt;/code&gt; и введите &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b967e14a3b2c88438d391b51a97e44abc37b8a3" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">У вас есть макрос &lt;code&gt;:time&lt;/code&gt; и введите &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e64bb8bb775010f86695f2cafd801d4cc29f97f" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:type&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">У вас есть макрос &lt;code&gt;:type&lt;/code&gt; и введите &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c5292c5b2bc0c1ca9d4ca9e4d5b25bbd9e291c2" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;code&gt;pattern&lt;/code&gt; keyword in an import/export specification to import or export an ordinary data constructor. For example:</source>
          <target state="translated">Вы также можете использовать ключевое слово &lt;code&gt;pattern&lt;/code&gt; в спецификации импорта / экспорта для импорта или экспорта обычного конструктора данных. Например:</target>
        </trans-unit>
        <trans-unit id="f8581425af0954edf998e6f74b1289f4b2aad7a8" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74a8315c09d21b66a862d09b6cf623f9312b66e" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences: - the exponent begins with &lt;code&gt;p&lt;/code&gt; instead of &lt;code&gt;e&lt;/code&gt; - the exponent is written in base &lt;code&gt;10&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16) - the base of the exponent is &lt;code&gt;2&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">Вы также можете написать явную экспоненту, которая похожа на показатель в десятичной системе счисления со следующими отличиями: - показатель степени начинается с &lt;code&gt;p&lt;/code&gt; вместо &lt;code&gt;e&lt;/code&gt; - показатель степени записывается с основанием &lt;code&gt;10&lt;/code&gt; ( &lt;strong&gt;не&lt;/strong&gt; 16) - основанием показателя степени является &lt;code&gt;2&lt;/code&gt; (а &lt;strong&gt;не&lt;/strong&gt; 16).</target>
        </trans-unit>
        <trans-unit id="fd00758a07ccd8e4012b39a3ffcc36b497dde263" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;../using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8707d0873e271cfc9458fd1a9219b507929f88d1" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="translated">Вы можете связать распакованные переменные в привязке шаблона (нерекурсивной, не верхнего уровня), но вы должны сделать любое такое соответствие шаблону строгим. (В противном случае &lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt; &lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt; &lt;/a&gt; предупреждение -Wunbanged-strict-patterns .) Например, вместо:</target>
        </trans-unit>
        <trans-unit id="e5864b6382b64fb2ddff9a22e3cb269048cd1a65" translate="yes" xml:space="preserve">
          <source>You may not mix implicit-parameter bindings with ordinary bindings in a single &lt;code&gt;let&lt;/code&gt; expression; use two nested &lt;code&gt;let&lt;/code&gt;s instead. (In the case of &lt;code&gt;where&lt;/code&gt; you are stuck, since you can&amp;rsquo;t nest &lt;code&gt;where&lt;/code&gt; clauses.)</source>
          <target state="translated">Нельзя смешивать привязки неявных параметров с обычными привязками в одном выражении &lt;code&gt;let&lt;/code&gt; ; вместо этого используйте два вложенных &lt;code&gt;let&lt;/code&gt; . (В случае, &lt;code&gt;where&lt;/code&gt; вы застряли, поскольку вы не можете вкладывать предложения &lt;code&gt;where&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8a15b835542506de56c4f0581f50dc84443c25f1" translate="yes" xml:space="preserve">
          <source>You may omit the &lt;code&gt;$(...)&lt;/code&gt; in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice. For example, you can write</source>
          <target state="translated">Вы можете опустить &lt;code&gt;$(...)&lt;/code&gt; в объединении объявления верхнего уровня. Простое написание выражения (а не объявления) подразумевает склейку. Например, вы можете написать</target>
        </trans-unit>
        <trans-unit id="2a2636e1eccaa733c43b723cac9f02b969f1c6f5" translate="yes" xml:space="preserve">
          <source>You may put multiple implicit-parameter bindings in a single binding group; but they are &lt;em&gt;not&lt;/em&gt; treated as a mutually recursive group (as ordinary &lt;code&gt;let&lt;/code&gt; bindings are). Instead they are treated as a non-recursive group, simultaneously binding all the implicit parameter. The bindings are not nested, and may be re-ordered without changing the meaning of the program. For example, consider:</source>
          <target state="translated">Вы можете поместить несколько привязок неявных параметров в одну группу привязки; но они &lt;em&gt;не&lt;/em&gt; рассматриваются как взаимно рекурсивная группа (как обычные привязки &lt;code&gt;let&lt;/code&gt; ). Вместо этого они рассматриваются как нерекурсивная группа, одновременно связывающая все неявные параметры. Привязки не вложены друг в друга и могут быть переупорядочены без изменения смысла программы. Например, рассмотрим:</target>
        </trans-unit>
        <trans-unit id="69c2bcd249a51f493b6d8defcfa352db2fe97573" translate="yes" xml:space="preserve">
          <source>You may specify an explicit &lt;em&gt;pattern signature&lt;/em&gt;, as we did for &lt;code&gt;ExNumPat&lt;/code&gt; above, to specify the type of a pattern, just as you can for a function. As usual, the type signature can be less polymorphic than the inferred type. For example</source>
          <target state="translated">Вы можете указать явную &lt;em&gt;сигнатуру шаблона&lt;/em&gt; , как мы сделали для &lt;code&gt;ExNumPat&lt;/code&gt; выше, чтобы указать тип шаблона, так же, как вы можете для функции. Как обычно, сигнатура типа может быть менее полиморфной, чем предполагаемый тип. Например</target>
        </trans-unit>
        <trans-unit id="e235042667b9c56eb4698542652a4ffe747fce1f" translate="yes" xml:space="preserve">
          <source>You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the &lt;code&gt;ghc&lt;/code&gt; has wired into it. For example, you might want to try a different assembler. The following options allow you to change the external program used for a given compilation phase:</source>
          <target state="translated">Вы можете указать, что на одной из фаз системы компиляции будет использоваться другая программа вместо того, что &lt;code&gt;ghc&lt;/code&gt; подключил к ней. Например, вы можете попробовать другой ассемблер. Следующие параметры позволяют вам изменить внешнюю программу, используемую на данном этапе компиляции:</target>
        </trans-unit>
        <trans-unit id="ffee81bdfe61682f0576300599ea43f154d0f848" translate="yes" xml:space="preserve">
          <source>You may want to enable this warning on a clean build or enable &lt;a href=&quot;separate_compilation#ghc-flag--fforce-recomp&quot;&gt;&lt;code&gt;-fforce-recomp&lt;/code&gt;&lt;/a&gt; in order to get reliable results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c11ae553a6507ead096463536fbbb081dce0652" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="translated">Вы можете писать программы, которые используют экзотические виды ограничений в контекстах и ​​суперклассах экземпляров, но для этого вы должны использовать &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; ,&lt;/a&gt; чтобы сигнализировать, что вы не возражаете, если проверка типов не завершится.</target>
        </trans-unit>
        <trans-unit id="b5ea20c910ec7f1464378418d006e17f6554a38c" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ac328de126bafdb81fd66142c9606ef9f2bba1" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="translated">Вы также можете взглянуть на &lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt; , более продвинутый набор инструментов (не распространяемый с GHC) для отображения профилей кучи.</target>
        </trans-unit>
        <trans-unit id="1b7c142259a42674ab1afa84950577edf68dc848" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;https://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1723e9eaca2c46aa402d493c6d51826bd13e2dec" translate="yes" xml:space="preserve">
          <source>You might find it useful to use Haskell&amp;rsquo;s &lt;code&gt;seq&lt;/code&gt; function to evaluate individual thunks rather than evaluating the whole expression with &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">Возможно, вам будет полезно использовать функцию &lt;code&gt;seq&lt;/code&gt; в Haskell для оценки отдельных преобразователей, а не для оценки всего выражения с помощью &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8b2b2c5879599e9fb9784f8ece7db05367147809" translate="yes" xml:space="preserve">
          <source>You might want to use this if you are you have a type class method which returns a constrained type. For example, a type class where one of the methods implements a traversal.</source>
          <target state="translated">Возможно,вы захотите использовать этот метод,если у вас есть метод класса типа,который возвращает ограниченный тип.Например,класс типа,в котором один из методов реализует обход.</target>
        </trans-unit>
        <trans-unit id="7ca17a83d89102130bc3fbe2303f1ff784f0cd26" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;http://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">Вы должны установить LLVM и иметь доступный LLVM в вашем &lt;code&gt;PATH&lt;/code&gt; , чтобы генератор кода LLVM работал. В частности, GHC должна иметь возможность вызывать инструменты &lt;code&gt;opt&lt;/code&gt; и &lt;code&gt;llc&lt;/code&gt; . Во-вторых, если вы используете Mac OS X с LLVM 3.0 или выше, вам также понадобится &lt;a href=&quot;http://clang.llvm.org&quot;&gt;компилятор&lt;/a&gt; компилятора Clang C, доступный в вашем &lt;code&gt;PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7bbe7f9ceeb8533c080ff75b9bb78ac5f1bcaf6" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;https://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7848640f49a2013635063f5f2a65c426e3adec48" translate="yes" xml:space="preserve">
          <source>You need this when using &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Это понадобится вам при использовании &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e3e8cd42cf48f666040b93e9cb7bcb77de13e8f" translate="yes" xml:space="preserve">
          <source>You need to build an &amp;ldquo;installed package info&amp;rdquo; file for passing to &lt;code&gt;ghc-pkg&lt;/code&gt; when installing your package. The contents of this file are described in &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: a package specification&lt;/a&gt;.</source>
          <target state="translated">Вам необходимо создать файл с информацией об установленном пакете для передачи в &lt;code&gt;ghc-pkg&lt;/code&gt; при установке вашего пакета. Содержимое этого файла описано в &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: спецификация пакета&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecae143bd200467151fc11557c8e8ff56f5c8728" translate="yes" xml:space="preserve">
          <source>You only need to enable this extension if the language you&amp;rsquo;re using is Haskell 98, in which a data type must have at least one constructor. Haskell 2010 relaxed this rule to allow data types with no constructors, and thus &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; is enabled by default when the language is Haskell 2010.</source>
          <target state="translated">Вам нужно включить это расширение только в том случае, если вы используете язык Haskell 98, в котором тип данных должен иметь хотя бы один конструктор. Haskell 2010 ослабил это правило, чтобы разрешить типы данных без конструкторов, и поэтому &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt; включен по умолчанию, если языком является Haskell 2010.</target>
        </trans-unit>
        <trans-unit id="fe3141ce96bc3bee7e55f9e3720a5ac4bb5237b4" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;../packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e8c6e9c630a979645ea222c79a82dcdd527d41" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="translated">Вероятно, вам не нужно использовать эту функцию, она была добавлена ​​в основном для того, чтобы мы могли создавать обратно совместимые версии пакетов при изменении API. В общем случае это может привести к хрупким зависимостям: модули иногда перемещаются из одного пакета в другой, что приводит к прерыванию импорта, квалифицированного для данного пакета. См. Также &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Прореживание и переименование модулей,&lt;/a&gt; чтобы узнать об альтернативном способе устранения неоднозначности между именами модулей.</target>
        </trans-unit>
        <trans-unit id="06a8acb7bef4875c53862bd963dfb3bee4782074" translate="yes" xml:space="preserve">
          <source>You should be careful with your installation function, because the list of passes you give back isn&amp;rsquo;t questioned or double checked by GHC at the time of this writing. An installation function like the following:</source>
          <target state="translated">Вы должны быть осторожны с функцией установки, потому что список возвращаемых вами пропусков не подвергается сомнению и не проверяется дважды GHC на момент написания этой статьи. Функция установки, подобная следующей:</target>
        </trans-unit>
        <trans-unit id="c8fb8a0845765453a3b51653e072b1e3775e368f" translate="yes" xml:space="preserve">
          <source>You should not use this module unless you are determined to monkey with the internals, as the functions here do just about nothing to preserve data invariants. You have been warned!</source>
          <target state="translated">Вы не должны использовать этот модуль,если только не настроены на обезьяну с внутренними элементами,так как функции здесь практически ничего не делают для сохранения инвариантов данных.Вы были предупреждены!</target>
        </trans-unit>
        <trans-unit id="e9580720487f8d0a617fa4e79bebc3170cc9fb48" translate="yes" xml:space="preserve">
          <source>You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren&amp;rsquo;t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we&amp;rsquo;ll explain shortly).</source>
          <target state="translated">You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren&amp;rsquo;t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we&amp;rsquo;ll explain shortly).</target>
        </trans-unit>
        <trans-unit id="c015ba62398898e9130e51965530b85d77f20111" translate="yes" xml:space="preserve">
          <source>You will eventually need all the values stored.</source>
          <target state="translated">В конце концов,вам понадобятся все сохраненные значения.</target>
        </trans-unit>
        <trans-unit id="f1f3422827e73aced4dc67f6bd9053292d8032b6" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="translated">Вы могли бы подумать, что определение &lt;code&gt;g&lt;/code&gt; определенно будет проверено типом! Ведь &lt;code&gt;f&lt;/code&gt; имеет точно такой же тип, и &lt;code&gt;g=f&lt;/code&gt; . Но на самом деле создается экземпляр типа &lt;code&gt;f&lt;/code&gt; , и созданные экземпляры ограничений решаются относительно ограничений, связанных сигнатурой &lt;code&gt;g&lt;/code&gt; . Итак, в случае неоднозначного типа решение не удастся. Например, рассмотрим более раннее определение &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3bacaebd47954a76b1781e22db7949543ec0e3fb" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82f52f22d9821ac7862aa36528ae6d83fd3c82d" translate="yes" xml:space="preserve">
          <source>Your GHC must have been built with &lt;code&gt;libdw&lt;/code&gt; support for this to work.</source>
          <target state="translated">Чтобы это &lt;code&gt;libdw&lt;/code&gt; ваш GHC должен быть построен с поддержкой libdw .</target>
        </trans-unit>
        <trans-unit id="9519d527689c73f17e39c0b9add443cee365e48f" translate="yes" xml:space="preserve">
          <source>Your code should just work as before when &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is enabled, provided you use conventional &lt;code&gt;Applicative&lt;/code&gt; instances. However, if you define a &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation, then it will likely get turned into an infinite loop by GHC. For example, if you do this:</source>
          <target state="translated">Ваш код должен работать, как и раньше, когда &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt; включен, при условии, что вы используете обычные экземпляры &lt;code&gt;Applicative&lt;/code&gt; . Однако, если вы определяете экземпляр &lt;code&gt;Functor&lt;/code&gt; или &lt;code&gt;Applicative&lt;/code&gt; с использованием do-notation, GHC, скорее всего, превратит его в бесконечный цикл. Например, если вы сделаете это:</target>
        </trans-unit>
        <trans-unit id="a1183986a9ffb1b2af584571ceb4a326e3d27e31" translate="yes" xml:space="preserve">
          <source>Z NOTATION LEFT IMAGE BRACKET</source>
          <target state="translated">ЛЕВАЯ СКОБКА С ОБОЗНАЧЕНИЕМ Z</target>
        </trans-unit>
        <trans-unit id="0c83924bcb1f702fbc698e5e6e9f9116245051fc" translate="yes" xml:space="preserve">
          <source>Z NOTATION RIGHT IMAGE BRACKET</source>
          <target state="translated">КРОНШТЕЙН ИЗОБРАЖЕНИЯ С ПРАВОЙ НОТАЦИЕЙ</target>
        </trans-unit>
        <trans-unit id="9ee13b9d7e56ee129a6f6f181a2acc60f3e30fdb" translate="yes" xml:space="preserve">
          <source>Zero and plus:</source>
          <target state="translated">Ноль и плюс:</target>
        </trans-unit>
        <trans-unit id="e033898555382f2650b269ecbde512101722e511" translate="yes" xml:space="preserve">
          <source>Zero is represented by an empty error and the plus operation executes its second argument if the first fails.</source>
          <target state="translated">Ноль представляет собой пустую ошибку,а операция плюс выполняет свой второй аргумент,если первый не удается.</target>
        </trans-unit>
        <trans-unit id="89ce708b7ebe149f5f5bb556542ed3a714814ce1" translate="yes" xml:space="preserve">
          <source>Zero or more.</source>
          <target state="translated">Ноль или больше.</target>
        </trans-unit>
        <trans-unit id="4f2b9ff1bc4646cc78797dbbfc4b21df6589cf65" translate="yes" xml:space="preserve">
          <source>ZeroPad</source>
          <target state="translated">ZeroPad</target>
        </trans-unit>
        <trans-unit id="2700bd76f0516df842fd9e4abb85f8429575d4af" translate="yes" xml:space="preserve">
          <source>ZigZagMode</source>
          <target state="translated">ZigZagMode</target>
        </trans-unit>
        <trans-unit id="e3c3091702d0663b55dd13e13b164ff519e2737a" translate="yes" xml:space="preserve">
          <source>ZipList</source>
          <target state="translated">ZipList</target>
        </trans-unit>
        <trans-unit id="281d4deef155f3f504d99a312a022a397d572373" translate="yes" xml:space="preserve">
          <source>Zipping</source>
          <target state="translated">Zipping</target>
        </trans-unit>
        <trans-unit id="933679db226a72e96000d73f1c7a880b6ddef5ad" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping</source>
          <target state="translated">Застёгивание и распаковка</target>
        </trans-unit>
        <trans-unit id="005dee8618c3540289989daf3c2e77debf4a260b" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping ByteStrings</source>
          <target state="translated">Застежка-молния и распаковка ByteStrings</target>
        </trans-unit>
        <trans-unit id="30dc05c3a24d302f5746bde459be8a25f4a06e2d" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping lists</source>
          <target state="translated">Списки застежек и распаковок</target>
        </trans-unit>
        <trans-unit id="07d080af9fb55da8f84a8c1fcaee4852c64bdb52" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping streams</source>
          <target state="translated">Потоки застежки-молнии и распаковки</target>
        </trans-unit>
        <trans-unit id="aa0ede24e19b5ea08adf33939b19f9036f4d61de" translate="yes" xml:space="preserve">
          <source>Zips and unzip</source>
          <target state="translated">Застёжки-молнии</target>
        </trans-unit>
        <trans-unit id="826ebf2b3d9d03b6187eb018e001d37252118a80" translate="yes" xml:space="preserve">
          <source>Zl: Separator, Line</source>
          <target state="translated">Зл:Сепаратор,линия</target>
        </trans-unit>
        <trans-unit id="0f9a135b374272cc3038eb482b2ccf2620a381ea" translate="yes" xml:space="preserve">
          <source>ZonedTime</source>
          <target state="translated">ZonedTime</target>
        </trans-unit>
        <trans-unit id="53df64e0f183ed18f2af00a3cd4b1e5f59e3ad75" translate="yes" xml:space="preserve">
          <source>Zp: Separator, Paragraph</source>
          <target state="translated">Зп:Разделитель,параграф</target>
        </trans-unit>
        <trans-unit id="b8543845a37a3bc5a76a7d50c4861b4a9b6ca581" translate="yes" xml:space="preserve">
          <source>Zs: Separator, Space</source>
          <target state="translated">Zs:Разделитель,Пространство</target>
        </trans-unit>
        <trans-unit id="aa9593b61dbfb1017fac300f13e25e0141bedc4f" translate="yes" xml:space="preserve">
          <source>[ The actual default definitions employ coercions to optimise out &lt;code&gt;&lt;a href=&quot;data-monoid#v:getSum&quot;&gt;getSum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:getProduct&quot;&gt;getProduct&lt;/a&gt;&lt;/code&gt;. ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9b7c0478a525885fdc0372f59486ef9c26b349" translate="yes" xml:space="preserve">
          <source>[ This is an experimental feature enabled by the new &lt;code&gt;-fexternal-interpreter&lt;/code&gt; flag that was introduced in GHC 8.0.1. It is currently not supported on Windows.]</source>
          <target state="translated">[Это экспериментальная функция, &lt;code&gt;-fexternal-interpreter&lt;/code&gt; благодаря новому флагу -fexternal-интерпретатор, который был представлен в GHC 8.0.1. В настоящее время он не поддерживается в Windows.]</target>
        </trans-unit>
        <trans-unit id="b46e3a168f06b4470b490118d55d7d684c597c5e" translate="yes" xml:space="preserve">
          <source>[1]  &quot;When You Should Use Lists in Haskell (Mostly, You Should Not)&quot;, by Johannes Waldmann, in arxiv.org, Programming Languages (cs.PL), at &lt;a href=&quot;https://arxiv.org/abs/1808.08329&quot;&gt;https://arxiv.org/abs/1808.08329&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82fefb5adab12e07a72eba03b70468034e9d703" translate="yes" xml:space="preserve">
          <source>[1] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c999771beade54662d4e2bdc8fc42d7c91f4c1a5" translate="yes" xml:space="preserve">
          <source>[2] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694e63c79a81e63a6094fc98085f24b5441b445d" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61777ed6df2c833c2e7f429e9f96972b755bfa6" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th-syntax#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3d9a8e3d2cb9184eb7776e15ffceb7ac844db5" translate="yes" xml:space="preserve">
          <source>[AssocDataTypes2005]</source>
          <target state="translated">[AssocDataTypes2005]</target>
        </trans-unit>
        <trans-unit id="3149026df86df09307a54a32b5ebc7072dbf3911" translate="yes" xml:space="preserve">
          <source>[AssocTypeSyn2005]</source>
          <target state="translated">[AssocTypeSyn2005]</target>
        </trans-unit>
        <trans-unit id="27ff8c3223896183bde17540d1a603485152df8f" translate="yes" xml:space="preserve">
          <source>[Example: &lt;code&gt;-n4m&lt;/code&gt; ] When set to a non-zero value, this option divides the allocation area (&lt;code&gt;-A&lt;/code&gt; value) into chunks of the specified size. During execution, when a processor exhausts its current chunk, it is given another chunk from the pool until the pool is exhausted, at which point a collection is triggered.</source>
          <target state="translated">[Пример: &lt;code&gt;-n4m&lt;/code&gt; ] Если задано ненулевое значение, эта опция делит область выделения ( значение &lt;code&gt;-A&lt;/code&gt; ) на фрагменты указанного размера. Во время выполнения, когда процессор исчерпывает свой текущий фрагмент, ему предоставляется еще один фрагмент из пула, пока пул не будет исчерпан, после чего запускается сборка.</target>
        </trans-unit>
        <trans-unit id="fd9c35275c0e496e473d959fc136a682ad3086d9" translate="yes" xml:space="preserve">
          <source>[Generics2010]</source>
          <target state="translated">[Generics2010]</target>
        </trans-unit>
        <trans-unit id="2163465089d2b153e0b8b61b46434eae8e1fe466" translate="yes" xml:space="preserve">
          <source>[Jones1999]</source>
          <target state="translated">[Jones1999]</target>
        </trans-unit>
        <trans-unit id="0c12f0c3c0a3e1aa6318a2e1ca646ed6212245b2" translate="yes" xml:space="preserve">
          <source>[Jones2000]</source>
          <target state="translated">[Jones2000]</target>
        </trans-unit>
        <trans-unit id="5f40289190bf70086cf4ad6fbc3348c060199dc3" translate="yes" xml:space="preserve">
          <source>[Lewis2000]</source>
          <target state="translated">[Lewis2000]</target>
        </trans-unit>
        <trans-unit id="c15f78a0d8a349e988dcf4bdf728980c9aa85b77" translate="yes" xml:space="preserve">
          <source>[TypeFamilies2008]</source>
          <target state="translated">[TypeFamilies2008]</target>
        </trans-unit>
        <trans-unit id="b5891f87311c40fc7e2feb2ed9e6cc0bd4955f76" translate="yes" xml:space="preserve">
          <source>[Vista and later only] The RTS calls the Win32 function &lt;code&gt;CancelSynchronousIo&lt;/code&gt;, which will cause a blocking I/O operation to return with the error &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">[Только для Vista и более поздних &lt;code&gt;CancelSynchronousIo&lt;/code&gt; ] RTS вызывает функцию Win32 CancelSynchronousIo , которая вызывает возврат операции блокирующего ввода-вывода с ошибкой &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e646f03d1dbd0ea6ebb7f3338bf711149839b070" translate="yes" xml:space="preserve">
          <source>[this is the default setting] Enable only the &amp;ldquo;safe&amp;rdquo; RTS options: (Currently only &lt;code&gt;-?&lt;/code&gt; and &lt;code&gt;--info&lt;/code&gt;.) Any other RTS options on the command line or in the &lt;code&gt;GHCRTS&lt;/code&gt; environment variable causes the program with to abort with an error message.</source>
          <target state="translated">[это настройка по умолчанию] Включить только &amp;laquo;безопасные&amp;raquo; параметры RTS: (В настоящее время только &lt;code&gt;-?&lt;/code&gt; и &lt;code&gt;--info&lt;/code&gt; .) Любые другие параметры RTS в командной строке или в &lt;code&gt;GHCRTS&lt;/code&gt; среды GHCRTS приводят к прерыванию программы с ошибкой сообщение.</target>
        </trans-unit>
        <trans-unit id="34cbcaa3ebb2e1b02bbd040476f4a4192d9188e6" translate="yes" xml:space="preserve">
          <source>\( O(1) \). A singleton sequence.</source>
          <target state="translated">\ (О (1) \). Одноэлементная последовательность.</target>
        </trans-unit>
        <trans-unit id="3b0d6be93c20b18b6a203f57ca8cdd843632dbbc" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the left end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\ (О (1) \). Добавьте элемент в левый конец последовательности. Мнемоника: треугольник с единственным элементом на заостренном конце.</target>
        </trans-unit>
        <trans-unit id="e29f0dd89cf4b98d9f9940c595b922a5dd21f994" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the right end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\ (О (1) \). Добавьте элемент в правый конец последовательности. Мнемоника: треугольник с единственным элементом на заостренном конце.</target>
        </trans-unit>
        <trans-unit id="e2f5fbbdc003ed6b6112958c18acd9b5bad4a569" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the left end of a sequence.</source>
          <target state="translated">\ (О (1) \). Проанализируйте левый конец последовательности.</target>
        </trans-unit>
        <trans-unit id="f32019dd1c2a2c3b992da628e1dbb8fca3a9a405" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the right end of a sequence.</source>
          <target state="translated">\ (О (1) \). Проанализируйте правый конец последовательности.</target>
        </trans-unit>
        <trans-unit id="7b89d619c376ded4ba8029ab80cbbe273480461c" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Is this the empty sequence?</source>
          <target state="translated">\ (О (1) \). Это пустая последовательность?</target>
        </trans-unit>
        <trans-unit id="4043cdf48e14bbc7bef8e182dfe108b0e21704e2" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The empty sequence.</source>
          <target state="translated">\ (О (1) \). Пустая последовательность.</target>
        </trans-unit>
        <trans-unit id="789a94c6e45150494a843083839c99ddbbcbcb8b" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The number of elements in the sequence.</source>
          <target state="translated">\ (О (1) \). Количество элементов в последовательности.</target>
        </trans-unit>
        <trans-unit id="9c9b70cf9a1b94d641385e597a06a4220c6c9d1d" translate="yes" xml:space="preserve">
          <source>\( O(\log n) \). &lt;code&gt;replicate n x&lt;/code&gt; is a sequence consisting of &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ журнал п) \). &lt;code&gt;replicate n x&lt;/code&gt; - это последовательность, состоящая из &lt;code&gt;n&lt;/code&gt; копий &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546ea35cf6dc085674954ee6937f092065e639a0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;xs&lt;/code&gt; at the index &lt;code&gt;i&lt;/code&gt;, shifting the rest of the sequence over.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; вставляет &lt;code&gt;x&lt;/code&gt; в &lt;code&gt;xs&lt;/code&gt; по индексу &lt;code&gt;i&lt;/code&gt; , сдвигая оставшуюся часть последовательности.</target>
        </trans-unit>
        <trans-unit id="0fe577d234433675e32729fdf0c2bc4f8e4d33da" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). A flipped, infix version of &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Перевернутая инфиксная версия &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1d705d397309f0a39429659216e4009c9399c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Delete the element of a sequence at a given index. Return the original sequence if the index is out of range.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Удалить элемент последовательности по заданному индексу. Вернуть исходную последовательность, если индекс вне допустимого диапазона.</target>
        </trans-unit>
        <trans-unit id="5bf003bead51d54a782a3e3daf5bde07395d33e1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Elements of a sequence after the first &lt;code&gt;i&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; yields the whole sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the empty sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Элементы последовательности после первого &lt;code&gt;i&lt;/code&gt; . Если &lt;code&gt;i&lt;/code&gt; отрицательно, &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; дает всю последовательность. Если последовательность содержит менее &lt;code&gt;i&lt;/code&gt; элементов, возвращается пустая последовательность.</target>
        </trans-unit>
        <trans-unit id="ca211904aa96b1bd11aefb66842881538beef91d" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Replace the element at the specified position. If the position is out of range, the original sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Заменить элемент в указанной позиции. Если позиция вне допустимого диапазона, возвращается исходная последовательность.</target>
        </trans-unit>
        <trans-unit id="d2ebe26c5fed5338d546b09c50f90bdfc79c5c59" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Split a sequence at a given position. &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Разделите последовательность в заданной позиции. &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9982ecf4ad26d9bf2a275e1e35fdb06d9eb20b1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Элемент в указанной позиции, отсчет от 0. Если указанная позиция отрицательна или равна длине последовательности, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4d4d2f3cb4b284e3cbd0d7773d4efed269d4097" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977efb39460c8fb1285fbb4a0ae2081214a7c664" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532d131357cc364ae609f962dfa852c5ecc94891" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. The argument should thus be a non-negative integer less than the size of the sequence. If the position is out of range, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; fails with an error.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Элемент в указанной позиции, отсчет от 0. Таким образом, аргумент должен быть неотрицательным целым числом меньше размера последовательности. Если позиция выходит за пределы допустимого диапазона, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; не выполняется с ошибкой.</target>
        </trans-unit>
        <trans-unit id="31957683248c73c401120fd6ad1cf601736552c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The first &lt;code&gt;i&lt;/code&gt; elements of a sequence. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; yields the empty sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the whole sequence is returned.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Первые &lt;code&gt;i&lt;/code&gt; элементов последовательности. Если &lt;code&gt;i&lt;/code&gt; отрицательно, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; возвращает пустую последовательность. Если последовательность содержит менее &lt;code&gt;i&lt;/code&gt; элементов, возвращается вся последовательность.</target>
        </trans-unit>
        <trans-unit id="3751741ea558f6d0bac38a7743eebeac69c91050" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; can lead to poor performance and even memory leaks, because it does not force the new value before installing it in the sequence. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; should usually be preferred.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Обновите элемент в указанной позиции. Если позиция вне допустимого диапазона, возвращается исходная последовательность. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; может привести к снижению производительности и даже утечке памяти, поскольку он не принудительно устанавливает новое значение перед его установкой в ​​последовательности. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; обычно предпочтительнее.</target>
        </trans-unit>
        <trans-unit id="899c0369d8a46c9994ff0ff3c2c10f46f7406360" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. The new value is forced before it is installed in the sequence.</source>
          <target state="translated">\ (O (\ log (\ min (i, ni))) \). Обновите элемент в указанной позиции. Если позиция вне допустимого диапазона, возвращается исходная последовательность. Новое значение принудительно вводится перед установкой в ​​последовательности.</target>
        </trans-unit>
        <trans-unit id="040c9f3a0d532171b25aefd9fcca6a4a01b60888" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(n_1,n_2))) \). Concatenate two sequences.</source>
          <target state="translated">\ (O (\ log (\ min (n_1, n_2))) \). Соедините две последовательности.</target>
        </trans-unit>
        <trans-unit id="06b9733d915a81dc3c5e947c773106d127b1fbcf" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two sequences and returns a sequence of corresponding pairs. If one input is short, excess elements are discarded from the right end of the longer sequence.</source>
          <target state="translated">\ (O (\ min (n_1, n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; принимает две последовательности и возвращает последовательность соответствующих пар. Если один вход короткий, лишние элементы отбрасываются из правого конца более длинной последовательности.</target>
        </trans-unit>
        <trans-unit id="b0d0c309376140b35e15a12bd8a45bdb90c7b61c" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalizes &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;zipWith (+)&lt;/code&gt; is applied to two sequences to take the sequence of corresponding sums.</source>
          <target state="translated">\ (O (\ min (n_1, n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; обобщает &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; , используя функцию, указанную в качестве первого аргумента, вместо функции кортежа. Например, &lt;code&gt;zipWith (+)&lt;/code&gt; применяется к двум последовательностям, чтобы получить последовательность соответствующих сумм.</target>
        </trans-unit>
        <trans-unit id="dbdb161425b4bae8703cd60a4996961e056d4753" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; takes three sequences and returns a sequence of triples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; принимает три последовательности и возвращает последовательность троек, аналогичную &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3b48ecc1f93c5a7b9927fe5999f5b74e5ec5b7" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; takes a function which combines three elements, as well as three sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет три элемента, а также три последовательности, и возвращает последовательность их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa10a5a78855dcba7d813e3ee6a207f58661c276" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; takes four sequences and returns a sequence of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3, n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; принимает четыре последовательности и возвращает последовательность четверок, аналогичную &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4390799dddf20a6343ea9646879bb16e7f084e8e" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; takes a function which combines four elements, as well as four sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (\ min (n_1, n_2, n_3, n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; принимает функцию, которая объединяет четыре элемента, а также четыре последовательности, и возвращает последовательность их точечных комбинаций, аналогично &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="854a5f214f7aa4910183ce26158e2621a9a01034" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the breakpoint index. &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that &lt;em&gt;do not satisfy&lt;/em&gt;&lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - индекс точки останова. &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt; , примененный к предикату &lt;code&gt;p&lt;/code&gt; и последовательности &lt;code&gt;xs&lt;/code&gt; , возвращает пару, первый элемент которой является самым длинным префиксом (возможно, пустым) из &lt;code&gt;xs&lt;/code&gt; элементов, которые &lt;em&gt;не удовлетворяют &lt;/em&gt; &lt;code&gt;p&lt;/code&gt; , а второй элемент является остатком последовательности.</target>
        </trans-unit>
        <trans-unit id="fb6c136646637ba26b9e4d03ff183d0f2f7f4e9e" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина префикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; возвращает суффикс, оставшийся после &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf309903f09bc7649ddc265c0f3450f702cefc0" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина префикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt; , примененный к предикату &lt;code&gt;p&lt;/code&gt; и последовательности &lt;code&gt;xs&lt;/code&gt; , возвращает пару, первый элемент которой является самым длинным префиксом (возможно, пустым) из &lt;code&gt;xs&lt;/code&gt; элементов, удовлетворяющих &lt;code&gt;p&lt;/code&gt; , а второй элемент является остатком последовательности.</target>
        </trans-unit>
        <trans-unit id="8a5eca9907659b3a43380501559c0f8bf072c551" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина префикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt; , примененный к предикату &lt;code&gt;p&lt;/code&gt; и последовательности &lt;code&gt;xs&lt;/code&gt; , возвращает самый длинный префикс (возможно, пустой) из &lt;code&gt;xs&lt;/code&gt; элементов, удовлетворяющих &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2527991eb02d123ae97e3053f7be92eb76670670" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; returns the prefix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина суффикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; возвращает префикс, оставшийся после &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca86e7d1bc6e9440039fd89da4b54ce4dc1b17ba" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose &lt;em&gt;first&lt;/em&gt; element is the longest &lt;em&gt;suffix&lt;/em&gt; (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина суффикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt; , примененный к предикату &lt;code&gt;p&lt;/code&gt; и последовательности &lt;code&gt;xs&lt;/code&gt; , возвращает пару, &lt;em&gt;первый&lt;/em&gt; элемент которой является самым длинным &lt;em&gt;суффиксом&lt;/em&gt; (возможно, пустым) из &lt;code&gt;xs&lt;/code&gt; элементов, удовлетворяющих &lt;code&gt;p&lt;/code&gt; , а второй элемент является остатком последовательности.</target>
        </trans-unit>
        <trans-unit id="bcfc88e467626c77e9e30a0a96b1b1973c08c4cc" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest suffix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\ (O (i) \), где \ (i \) - длина суффикса. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt; , примененный к предикату &lt;code&gt;p&lt;/code&gt; и последовательности &lt;code&gt;xs&lt;/code&gt; , возвращает самый длинный суффикс (возможно, пустой) из &lt;code&gt;xs&lt;/code&gt; элементов, удовлетворяющих &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89864ca7ad3a975e47d1ac468095d918264767d7" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (п \ журнал d) \). Функция &lt;code&gt;nubOrd&lt;/code&gt; удаляет повторяющиеся элементы из списка. В частности, он сохраняет только первое вхождение каждого элемента. При внутреннем использовании &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; он имеет лучшую асимптотику, чем стандартная функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77dbb7bcdeacb5504a0ef6cf2f5ee72db2c1bd02" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7af8c8ab480cb010c335014cc56785e2da88b4" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe404a925ef3c49842338c60efd96b745d6f3be" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; по естественному порядку его элементов. Сорт стабильный. Если стабильность не требуется, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; может быть немного быстрее.</target>
        </trans-unit>
        <trans-unit id="1098d943b88eab1e390e5ed0bde58e02fe11a30b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; в соответствии с указанным компаратором. Сорт стабильный. Если стабильность не требуется, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; может быть немного быстрее.</target>
        </trans-unit>
        <trans-unit id="783b6fa9efe8b0aacee689453492ec1f64175be9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , сравнивая результаты ключевой функции, примененной к каждому элементу. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , но имеет преимущество в производительности, заключающееся в том, что &lt;code&gt;f&lt;/code&gt; оценивается только один раз для каждого элемента во входном списке. Это называется парадигмой &amp;laquo;украсить-отсортировать-не декорировать&amp;raquo; или преобразованием Шварца.</target>
        </trans-unit>
        <trans-unit id="dd5b729298fbee668ec8a880b8bbf7694c81ab2d" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f12595eeba36c0d952411979b5ac60fb59e8cd3" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76919fecc6589c311cc2f157b3a6e318f7753a16" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; по естественному порядку его элементов, но сортировка нестабильна. Этот алгоритм часто быстрее и использует меньше памяти, чем &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9085dac0a56339479accab8408ea49a6a539f2cb" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , сравнивая результаты ключевой функции, примененной к каждому элементу. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , но имеет преимущество в производительности, заключающееся в том, что &lt;code&gt;f&lt;/code&gt; оценивается только один раз для каждого элемента во входном списке. Это называется парадигмой &amp;laquo;украсить-отсортировать-не декорировать&amp;raquo; или преобразованием Шварца.</target>
        </trans-unit>
        <trans-unit id="7a75f512d7ba326f341d19f6a0cb353e820eb396" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5073f42496be1bb6dc8bed64e2b8570c51821663" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20373e1ed680ebc14f4b07924b5b470cc33402e5" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; по естественному порядку его элементов. Сорт стабильный. Если стабильность не требуется, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; может быть немного быстрее.</target>
        </trans-unit>
        <trans-unit id="0eccdd8235b36a805ffa872f4e21e6f3de43dfa9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; в соответствии с указанным компаратором. Сорт стабильный. Если стабильность не требуется, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; может быть немного быстрее.</target>
        </trans-unit>
        <trans-unit id="72a13ba7d54627091e4ede4aa6ae6a602d067ef1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , сравнивая результаты ключевой функции, примененной к каждому элементу. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , но имеет преимущество в производительности, заключающееся в том, что &lt;code&gt;f&lt;/code&gt; оценивается только один раз для каждого элемента во входном списке. Это называется парадигмой &amp;laquo;украсить-отсортировать-не декорировать&amp;raquo; или преобразованием Шварца.</target>
        </trans-unit>
        <trans-unit id="7753c3a048f9c8faf7bca750396f1ef7c209569b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd7d8c0ce3dcaffab36282e02bea41b69b9bbb6" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7788d5dd9362fea81aef704f1b25c424829d973e" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; по естественному порядку его элементов, но сортировка нестабильна. Этот алгоритм часто быстрее и использует меньше памяти, чем &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923bbcdf6473777345bf3471e264e87c7325e7e1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\ (O (п \ журнал п) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; сортирует указанный &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , сравнивая результаты ключевой функции, примененной к каждому элементу. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; , но имеет преимущество в производительности, заключающееся в том, что &lt;code&gt;f&lt;/code&gt; оценивается только один раз для каждого элемента во входном списке. Это называется парадигмой &amp;laquo;украсить-отсортировать-не декорировать&amp;raquo; или преобразованием Шварца.</target>
        </trans-unit>
        <trans-unit id="1626966051459fb3709cd1435e0670a0dbe0a5a9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe625859b24c94134c8d7ccfa867fdcaa9306fe9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c993d7ee2b9e07347303a1bfa6fbe29b0033e24" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (п \ журнал п) \). Обобщение &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; берет произвольный компаратор и сортирует указанную последовательность. Сорт нестабильный. Этот алгоритм часто быстрее и использует меньше памяти, чем &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c91e61a22ccef5e854b0115e7bae5f82a0d4e39" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (O (п \ журнал п) \). Обобщение &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; берет произвольный компаратор и сортирует указанную последовательность. Сорт нестабильный. Этот алгоритм часто быстрее и использует меньше памяти, чем &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="930890d550afe6b5871128789424f2ee5f748526" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\ (O (п \ мин (d, W)) \). Функция &lt;code&gt;nubInt&lt;/code&gt; удаляет повторяющиеся значения &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; из списка. В частности, он сохраняет только первое вхождение каждого элемента. Благодаря внутреннему использованию &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; он достигает лучшей асимптотики, чем стандартная функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a5d9655deddf9d1b59afeca8f46744a66f38b7" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cb6746a4d9c74a95424cc23d6dbc2098128a81" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603349967cf31a7e7a62cb16fea5e3004150cc9a" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Constructs a sequence by repeated application of a function to a seed value.</source>
          <target state="translated">\ (О (п) \). Создает последовательность путем повторного применения функции к начальному значению.</target>
        </trans-unit>
        <trans-unit id="e68f82855a00f85773c90f1119ff0dc9a7c9916f" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Convert a given sequence length and a function representing that sequence into a sequence.</source>
          <target state="translated">\ (О (п) \). Преобразуйте заданную длину последовательности и функцию, представляющую эту последовательность, в последовательность.</target>
        </trans-unit>
        <trans-unit id="28abf92fc465e3c6920cbdd18d990aa00bd50bda" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence consisting of the elements of an &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;. Note that the resulting sequence elements may be evaluated lazily (as on GHC), so you must force the entire structure to be sure that the original array can be garbage-collected.</source>
          <target state="translated">\ (О (п) \). Создайте последовательность, состоящую из элементов &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; . Обратите внимание, что результирующие элементы последовательности могут оцениваться лениво (как в GHC), поэтому вы должны заставить всю структуру быть уверенным, что исходный массив может быть собран с помощью сборщика мусора.</target>
        </trans-unit>
        <trans-unit id="c7cdb9801d2d28c4375010fb1f7c0579b09caa2d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\ (О (п) \). Создайте последовательность из конечного списка элементов. Для всех экземпляров класса &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; , включая &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; , есть функция &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; в противоположном направлении .</target>
        </trans-unit>
        <trans-unit id="69a0fce5498890ae28d63d4fde0c7bd1e787e9c0" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf550315a531f6071acc08c1ba13bc0c5e64675" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbfa82306b38fbfc581f7b62fe7f6936fc85d5d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Intersperse an element between the elements of a sequence.</source>
          <target state="translated">\ (О (п) \). Перемежайте элемент между элементами последовательности.</target>
        </trans-unit>
        <trans-unit id="eb33857f95e6abd9b8e92b965742544d371251b4" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all prefixes of this sequence, shortest first. For example,</source>
          <target state="translated">\ (О (п) \). Возвращает последовательность всех префиксов этой последовательности, сначала самый короткий. Например,</target>
        </trans-unit>
        <trans-unit id="e9bb88e43721f0ad090dd3079c9ab2d4f7f5e33e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all suffixes of this sequence, longest first. For example,</source>
          <target state="translated">\ (О (п) \). Возвращает последовательность всех суффиксов этой последовательности, начиная с самого длинного. Например,</target>
        </trans-unit>
        <trans-unit id="d22fb3ce0a67f04fdebb29f7e29e9664003f24cc" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns a sequence of those elements which satisfy the predicate.</source>
          <target state="translated">\ (О (п) \). Функция &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; принимает предикат &lt;code&gt;p&lt;/code&gt; и последовательность &lt;code&gt;xs&lt;/code&gt; и возвращает последовательность тех элементов, которые удовлетворяют этому предикату.</target>
        </trans-unit>
        <trans-unit id="95c6f2c5a83a628e74aa5f06545408e2cd588fd6" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns sequences of those elements which do and do not satisfy the predicate.</source>
          <target state="translated">\ (О (п) \). Функция &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; принимает предикат &lt;code&gt;p&lt;/code&gt; и последовательность &lt;code&gt;xs&lt;/code&gt; и возвращает последовательности тех элементов, которые удовлетворяют и не удовлетворяют предикату.</target>
        </trans-unit>
        <trans-unit id="7d2552d02625413aa29e21b7cef52458a7ad4167" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The reverse of a sequence.</source>
          <target state="translated">\ (О (п) \). Обратная последовательность.</target>
        </trans-unit>
        <trans-unit id="ef7cfa6738484ccd222c60ae3aef6fc4d639c58e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Unzip a sequence using a function to divide elements.</source>
          <target state="translated">\ (О (п) \). Разархивируйте последовательность, используя функцию разделения элементов.</target>
        </trans-unit>
        <trans-unit id="652ee9de3d79897676915fbdfd5346a4ef2470da" translate="yes" xml:space="preserve">
          <source>\(IY\) is strictly more specific than \(IX\). That is, \(IY\) is a substitution instance of \(IX\) but not vice versa.</source>
          <target state="translated">\ (IY \) строго более конкретен, чем \ (IX \). То есть \ (IY \) является экземпляром подстановки \ (IX \), но не наоборот.</target>
        </trans-unit>
        <trans-unit id="b689d73e7c786fd5b31eb51ed9d31a3f7d6ae37b" translate="yes" xml:space="preserve">
          <source>\(O \Bigl(\bigl(\frac{n}{c}\bigr) \log c\Bigr)\). &lt;code&gt;chunksOf c xs&lt;/code&gt; splits &lt;code&gt;xs&lt;/code&gt; into chunks of size &lt;code&gt;c&amp;gt;0&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; does not divide the length of &lt;code&gt;xs&lt;/code&gt; evenly, then the last element of the result will be short.</source>
          <target state="translated">\ (O \ Bigl (\ bigl (\ frac {n} {c} \ bigr) \ log c \ Bigr) \). &lt;code&gt;chunksOf c xs&lt;/code&gt; разбивает &lt;code&gt;xs&lt;/code&gt; на куски размером &lt;code&gt;c&amp;gt;0&lt;/code&gt; . Если &lt;code&gt;c&lt;/code&gt; не делит длину &lt;code&gt;xs&lt;/code&gt; равномерно, то последний элемент результата будет коротким.</target>
        </trans-unit>
        <trans-unit id="582a393b8e576e364ea06e27da19c1588e6f8fa7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031813834a74b1dadaec56e6fd8ae694a9b009cf" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail. If the list is empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. If the list is non-empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the head of the list and &lt;code&gt;xs&lt;/code&gt; its tail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad354cd8847968b00b2b70d0ab031f10259ac4d8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the elements after the head of a list, which must be non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb01ec6468606d885dd9ee1c8060cd2be83385b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the first element of a list, which must be non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b99888890a9c61dd2423c0ab81f2913922b24e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Test whether a list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c4b8cbae0dd17a08092f0d631dbb1998ec6523" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67a45507675d41829f2b315a401c8f71a813ba2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e54d598cbb71de41da91f7c2ee3be9de7f3103" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9bc9e758cd9d84ebcae85def1963ef78822338" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebddb5be372b47ae03039407756f373048cb2ddd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a04ba10cd7908bfb667e9ea8808bd65a186093" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a317122ad351fffdc3f91dc27c4644052432abf1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1591ed7412a271f839bdf25abc39810689968bd2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4ecf185edfdacf5466e47eba17bbdec5f87190" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c24a0e28dddfc47b013aacfbb632c946442d755" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab086509cd1f632f082e54529945572cafe588de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac827704abebb27add5429489113d21367e8bfa1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f307d8b1e0cbd32bcd450346ba66a44e4cb712a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43d2bc79af9c74b11d5e44b6386300c12ecd9b3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e393f1d74c3927aa5f45e840a9f08cfdf3cfffc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca3c12a6796ceba3445b06c35f1a3f5c6f0bdf7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9021cb823ed71b0f14dc8ecbf8e7fc05cf8940a1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adb610253a7c2ed82688fbab8e80176006f21f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363f4a1f18a4283de44396530ea1ae5638a488ee" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad67b949b37d25627cdf55c54ccc28a0b18567f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fc4e9ba5783a6561249c23c87c89bbdb31dca1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5573e311cfeaf9565286d9c2c3ea1988551e9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef21d250819db26eff216f0d416504ce30f4d30b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6c9ed9451170ea35359a7d1abb01920f6807cc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ed9eb12b027cf32babe2f5b1df3b8c66e3fd04" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0d2e7ca10638ff9734b38f34a11aa2706ee7e8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028c33c05faa97f80685730c0582c0602808e0c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf23c9e5c94b7f7d3b25a474b88633b73cc229b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c8e824def72775699108b83220d760c359dce3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ebc9c133e22bbd087ec267e56895f09fc21ffd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0016bd28f59bebbb241b023933026728dd4c00b7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce62be98b53d014c12224d990af1d700ef199e55" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b943958809b42bfecfe0570ab9ec6e1dc3b210" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c1c326018743c7d31c528075aa75b47a2ea8c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5e4a2474b3ec55663d6f011ffa981e2950b3c8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8ec2f642139908ce10723399ba124eaef8630f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fced33cc5c7b33d9d71684d52fad9722dc973b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6a174a1fd7221b3347d6f920afe8052f48daf8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2073b0a706335a98075522476b3b9b33b077aa11" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e535e383ef8d15b37f8a06cec03c61d0469b34" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210e580acacdb0184aa961211ec74d91837f67af" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fd84173341456035d6e7513a533417a0d6d1aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3f84a77af8df2ddd26982298943d6341e5377e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4d9f0623e9570eb88dd1d9b4c211b4b2a418a2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125c699b4c4f75c430387e65f7edcfe006396c73" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee3b77945129051b6be71096733cdf6305efae4" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d986caef25fcce8ec2fbfa2e3a0dc59c42f1882" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cae18e658efc58958ff752caf95f4308ba98c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169fb686f6e4e8af8e1766f55d01ce7bff250ede" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1eac2b935737890f86bee44cbce323a7636c44" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57897d060a78a4637753c44270190af6d990e750" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b018f59eeaa79636b5769a631d82b5b1cfd829" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2acc454a4bbccf0272c11eb7a8ea8fe3b08cbb6f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4f342a6627b5c5e3e98b06ab0d9bb701b238aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9d169c8174c14ebced68d4109e796cf850ccf6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4564c9defe3967981e219d81f0960c41a9d299c1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d8c52726c50668f1a0c6fc1fc17ef37152c05a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4c73b94535ef776519822b6d1a94333ed597de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38f78dbd3a76f77afefcc5ac584b11d4b2b52ad" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88254de4abf9ef851c7036af3d32cd744fb783fe" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Extract the last element of a list, which must be finite and non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d17220655fadec151f041d329764528e84ba57c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Return all the elements of a list except the last one. The list must be non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6453dae020a15d9ae6ff6028cbacc37e5d836953" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6555cf65a2feeb7c26015cc9026f888f6cd0644" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917fcf0e2a1ba80687d4acabf5ac686a2bcfe6f5" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851047afd0fd3689ecaf18a31831e92a21a0f13c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a281bf3f4c0834f6462b7a209190891fab7531" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c53e4d9aadaf482e021157b28390aed21001b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253d3601e9ddce99694b8e80d2efd924994b0ebb" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0327046849d2c8bb0ea7e3a381fcc45f6e8524" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c871ded24319659125b4444ddec10e6a07b4af41" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ab7824a137d7c905554cd420e9b3f5e69e2fd9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f4251118a59d07862ecb1c293d53b091b0483a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089b1c7aab36fe1e2dc84b70dbf2369dbbad67fa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d892a0ba8f3f07fab0bf412e6f60b4b7f33b99e6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed48ec637b0d47680fd76b60e08867ddcbbad74a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6f80a34a9798cafc6a5db96cc57ba4c4db59c2" translate="yes" xml:space="preserve">
          <source>^</source>
          <target state="translated">^</target>
        </trans-unit>
        <trans-unit id="600e600a68a149108f159e39fce17366d56fc4e6" translate="yes" xml:space="preserve">
          <source>_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ = ' &lt;a href=&quot;data-bool#v:False&quot;&gt;Ложь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81245c14fa4af0f8aca817f3aac71e3856bb2e1a" translate="yes" xml:space="preserve">
          <source>_open_osfhandle</source>
          <target state="translated">_open_osfhandle</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="8022fc62249fb25428a03d36552b9662db865b9c" translate="yes" xml:space="preserve">
          <source>a 32-bit floating point number</source>
          <target state="translated">32-битное число с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="25484eb33e4ca7fa03af08f774aeade1c4ee2d63" translate="yes" xml:space="preserve">
          <source>a 64-bit floating point number</source>
          <target state="translated">64-битное число с плавающей точкой</target>
        </trans-unit>
        <trans-unit id="495a1fe000be6a5008ec4d1eb84e2a1d5d084889" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = a</source>
          <target state="translated">а &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = a</target>
        </trans-unit>
        <trans-unit id="1048dece3526da535f415f1622b9e7f4b2a0f838" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">а &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; =' &lt;a href=&quot;data-bool#v:True&quot;&gt;верно&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8d742293ecc54e41ac09b51fa2b2c86cd8c0847" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; a = a</source>
          <target state="translated">а &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;а = а</target>
        </trans-unit>
        <trans-unit id="dfc3eece5d5fbbfb2557fdd2f1a0de5ec1613686" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; ' &lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; =' &lt;a href=&quot;data-bool#v:False&quot;&gt;Ложь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01ba601786bc77082f70fd3b2a119e6f137598d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = a</source>
          <target state="translated">a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; ' &lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = a</target>
        </trans-unit>
        <trans-unit id="db482d5c52f88bf9c927868acddf21f43b80bd3f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; a = a</source>
          <target state="translated">а &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; а = а</target>
        </trans-unit>
        <trans-unit id="46a1e8ea1de968dcf4615a18bb4b53b696036bd4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Ограниченный&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="2784769421385712bd50e00b7541bc81e814f56a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="f867947542827acc0d2ea8e0082554ae2d9a293e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;Прочитать&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="abf8e156382601d33ab4309b568c53d2699611e4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Ограниченный&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="0375fef85fb75ec4eaea1233da0a84c6a11f70eb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Ограниченный&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="04456549f2a5abfaa433721a9e4d30e8a18a7b88" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Ограниченный&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="a89d1de959bd2ba9abd9673e63ea6a45b095b5bd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="5ce73f6cfcb9fe04f1a9c2ebf0e845f07785c1c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="027733db5bec3026113257962749176c09fed167" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="36b1d286e77dd08402089dc786c5d6751384d91a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;Прочитать&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="16c734ad064a036a3668c749c7ed15b1c82c32e7" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Прочитать&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="8e9dc88d9d6b9dc3f6810c3cb75f9b31968412fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Прочитать&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="b047af46bc432fe3a62a3c51785c13516dfb1285" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Прочитать&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;: ~~:&lt;/a&gt; b)</target>
        </trans-unit>
        <trans-unit id="66da0a7f93a9faeeee0de1ce9988147838ae30bc" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a = ' &lt;a href=&quot;data-bool#v:True&quot;&gt;Верно&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e53f9d6aefd63368970fd8b1c03f48b2146d52ae" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-124-&quot;&gt;:|&lt;/a&gt; [a] infixr 5</source>
          <target state="translated">а &lt;a id=&quot;v::-124-&quot;&gt;: | &lt;/a&gt;[а] инфикс 5</target>
        </trans-unit>
        <trans-unit id="c09b5ca0ab45efbf368c8f883aaeb643f25da75f" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-60-&quot;&gt;:&amp;lt;&lt;/a&gt; (&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a) infixr 5</source>
          <target state="translated">a &lt;a id=&quot;v::-60-&quot;&gt;: &amp;lt;&lt;/a&gt; ( &lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a) infixr 5</target>
        </trans-unit>
        <trans-unit id="4366d8309e6c4a93d2e6f9fac58abf7190d747db" translate="yes" xml:space="preserve">
          <source>a SIMD vector type</source>
          <target state="translated">векторный тип SIMD</target>
        </trans-unit>
        <trans-unit id="2c60a8948409326587e2d80c0533c0b2ba526f53" translate="yes" xml:space="preserve">
          <source>a buffer (whose length may be zero).</source>
          <target state="translated">буфер (длина которого может быть равна нулю).</target>
        </trans-unit>
        <trans-unit id="6aba5037454fcbe2497a45a925a7bf0909281177" translate="yes" xml:space="preserve">
          <source>a constant function, returning the lowest and highest values the exponent may assume</source>
          <target state="translated">постоянная функция,возвращающая наименьшее и наибольшее значения,которые может принять экспонент</target>
        </trans-unit>
        <trans-unit id="5b9c7de41a1536a2cf821f605e86c2793f6bd4c5" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">постоянная функция, возвращающая количество цифр &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; в мантиссе</target>
        </trans-unit>
        <trans-unit id="cde248066dbb28c999a2778ce818e55f0128d213" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">постоянная функция, возвращающая количество цифр &lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; в мантиссе</target>
        </trans-unit>
        <trans-unit id="a633e2dd8b55ec1e8c7eb858ebb8fa756f27e31c" translate="yes" xml:space="preserve">
          <source>a constant function, returning the radix of the representation (often &lt;code&gt;2&lt;/code&gt;)</source>
          <target state="translated">постоянная функция, возвращающая основание системы счисления (часто &lt;code&gt;2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2d112c21b644b5118250a8a70b2538ed21ba15e3" translate="yes" xml:space="preserve">
          <source>a decoding error, if the input begins with an invalid byte sequence in this Handle's encoding.</source>
          <target state="translated">ошибка декодирования,если вход начинается с некорректной последовательности байт в кодировке данного Хэндла.</target>
        </trans-unit>
        <trans-unit id="13d51f2874011f80c0fda1c8dd64f87141fd6f14" translate="yes" xml:space="preserve">
          <source>a default value</source>
          <target state="translated">значение по умолчанию</target>
        </trans-unit>
        <trans-unit id="efc6e377ad13780bc21173cedd26de2bc7744fdb" translate="yes" xml:space="preserve">
          <source>a function converting a valid digit character to an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">функция, преобразующая действительный цифровой символ в &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64e5fba578c7d1891365516501058a16fc9e7609" translate="yes" xml:space="preserve">
          <source>a function that can show unsigned values</source>
          <target state="translated">функция,которая может показывать неподписанные значения</target>
        </trans-unit>
        <trans-unit id="4ad166b7834c36795a4fe596e5997879628c7a69" translate="yes" xml:space="preserve">
          <source>a handler for errors in the inner computation</source>
          <target state="translated">обработчик ошибок во внутренних вычислениях</target>
        </trans-unit>
        <trans-unit id="c3c5aa9d0619cb64fabfcd8bc2312b400a6ca3c8" translate="yes" xml:space="preserve">
          <source>a handler for exceptions in the inner computation</source>
          <target state="translated">обработчик исключений во внутреннем вычислении</target>
        </trans-unit>
        <trans-unit id="e9b3db5689251b32a019d1c409373cee04ec49ff" translate="yes" xml:space="preserve">
          <source>a list of &lt;em&gt;associations&lt;/em&gt; of the form (&lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;). Typically, this list will be expressed as a comprehension. An association &lt;code&gt;(i, x)&lt;/code&gt; defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">список &lt;em&gt;ассоциаций&lt;/em&gt; формы ( &lt;em&gt;индекс&lt;/em&gt; , &lt;em&gt;значение&lt;/em&gt; ). Обычно этот список выражается в виде понимания. Ассоциация &lt;code&gt;(i, x)&lt;/code&gt; определяет значение массива с индексом &lt;code&gt;i&lt;/code&gt; как &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1838769c938ccda3c38c195704df00e6f8f9cac3" translate="yes" xml:space="preserve">
          <source>a list of declarations at top level; the spliced expression must have type &lt;code&gt;Q [Dec]&lt;/code&gt;</source>
          <target state="translated">список объявлений на верхнем уровне; склеенное выражение должно иметь тип &lt;code&gt;Q [Dec]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c84a8e03c639e4b99b736533f6ce0d75c3d436cc" translate="yes" xml:space="preserve">
          <source>a nested BCO</source>
          <target state="translated">вложенный BCO</target>
        </trans-unit>
        <trans-unit id="dacf656c29af63ede7d5a66eb4c195cb7d68d27c" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the first map is passed to &lt;code&gt;only1&lt;/code&gt; and the output is added to the result;</source>
          <target state="translated">непустое поддерево, присутствующее только в первой карте, передается в &lt;code&gt;only1&lt;/code&gt; , и вывод добавляется к результату;</target>
        </trans-unit>
        <trans-unit id="9431cc2ffae3083c6fd4eb94123849e01bcd09de" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the second map is passed to &lt;code&gt;only2&lt;/code&gt; and the output is added to the result.</source>
          <target state="translated">непустое поддерево, присутствующее только во второй карте, передается в &lt;code&gt;only2&lt;/code&gt; , и вывод добавляется к результату.</target>
        </trans-unit>
        <trans-unit id="b079c712d0fda010c398b8b4fc564c5d93d60fd1" translate="yes" xml:space="preserve">
          <source>a pair of &lt;em&gt;bounds&lt;/em&gt;, each of the index type of the array. These bounds are the lowest and highest indices in the array, in that order. For example, a one-origin vector of length &lt;code&gt;10&lt;/code&gt; has bounds &lt;code&gt;(1,10)&lt;/code&gt;, and a one-origin &lt;code&gt;10&lt;/code&gt; by &lt;code&gt;10&lt;/code&gt; matrix has bounds &lt;code&gt;((1,1),(10,10))&lt;/code&gt;.</source>
          <target state="translated">пара &lt;em&gt;границ&lt;/em&gt; , каждая из типов индекса массива. Эти границы являются самым низким и самым высоким индексами в массиве в указанном порядке. Например, вектор с одним началом длины &lt;code&gt;10&lt;/code&gt; имеет границы &lt;code&gt;(1,10)&lt;/code&gt; , а матрица с одним началом &lt;code&gt;10&lt;/code&gt; на &lt;code&gt;10&lt;/code&gt; имеет границы &lt;code&gt;((1,1),(10,10))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8e826714a73899830f6ab608075ff579906dbb" translate="yes" xml:space="preserve">
          <source>a pattern; the spliced pattern must have type &lt;code&gt;Q Pat&lt;/code&gt;</source>
          <target state="translated">шаблон; шаблон сращивания должен иметь тип &lt;code&gt;Q Pat&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="684672734eb2f9a021c25216014476296b90b11e" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73059a8046b1c205b18c2f7d1b925674ed55a915" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;ByteString&lt;/code&gt;</source>
          <target state="translated">уже существующие блоки данных, представленные строгой &lt;code&gt;ByteString&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12724a459ab10a8829360de4d06541b3e47dba30" translate="yes" xml:space="preserve">
          <source>a predicate distinguishing valid digits in this base</source>
          <target state="translated">предикат,различающий действительные цифры в этой базе.</target>
        </trans-unit>
        <trans-unit id="c68f4a2495d7173548e9a09cb2324b41dff54f59" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path</source>
          <target state="translated">относительный путь,который прилагается к пути</target>
        </trans-unit>
        <trans-unit id="8fed21137ffe5d0c7090ea916a8c3a6106462526" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path; if empty, the base path is returned</source>
          <target state="translated">относительный путь,который добавляется к пути;если он пустой,возвращается базовый путь</target>
        </trans-unit>
        <trans-unit id="02e6f3d317a5b730213d444073c4a9d995df7da7" translate="yes" xml:space="preserve">
          <source>a restricted append-only version of a state monad transformer or</source>
          <target state="translated">ограниченная версия только для приложений государственного монотрансформатора или</target>
        </trans-unit>
        <trans-unit id="00cd8647e896b38e11fdde37050fe414990bbb27" translate="yes" xml:space="preserve">
          <source>a simplified AST</source>
          <target state="translated">упрощённый АСТ</target>
        </trans-unit>
        <trans-unit id="0f5ca64142ff0bb325d5429f5831baee94016b9b" translate="yes" xml:space="preserve">
          <source>a standard &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instance may be defined as</source>
          <target state="translated">стандартный экземпляр &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; может быть определен как</target>
        </trans-unit>
        <trans-unit id="af4e0527aa2daaff6ce8c67a4930a298ed4dbc12" translate="yes" xml:space="preserve">
          <source>a string describing the &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, e.g. the file path for a file. Used in error messages.</source>
          <target state="translated">строка , описывающая &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; , например , путь к файлу для файла. Используется в сообщениях об ошибках.</target>
        </trans-unit>
        <trans-unit id="32ae1817dace426c93d098fe2524e0f3abe3aa1a" translate="yes" xml:space="preserve">
          <source>a string literal denoting a common prefix to be added to the returned completion candidates.</source>
          <target state="translated">строковый литерал,обозначающий общий префикс,который будет добавлен к возвращаемым кандидатам на заполнение.</target>
        </trans-unit>
        <trans-unit id="654558a0452dc0b9f151efdec13bb4d9e7dd1b7f" translate="yes" xml:space="preserve">
          <source>a string that can be passed to &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; to create an equivalent &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">строка, которую можно передать в &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; для создания эквивалентного &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b85621828f70ac37a526068e8083c87be9c3be28" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//IGNORE&lt;/code&gt;, e.g. &lt;code&gt;UTF-8//IGNORE&lt;/code&gt;, will cause all illegal sequences on input to be ignored, and on output will drop all code points that have no representation in the target encoding.</source>
          <target state="translated">суффикс &lt;code&gt;//IGNORE&lt;/code&gt; , например &lt;code&gt;UTF-8//IGNORE&lt;/code&gt; , приведет к игнорированию всех недопустимых последовательностей на входе, а на выходе удалит все кодовые точки, которые не представлены в целевой кодировке.</target>
        </trans-unit>
        <trans-unit id="c776055d334ae6a629010d30b766a23c8aa3fde8" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//ROUNDTRIP&lt;/code&gt; will use a PEP383-style escape mechanism to represent any invalid bytes in the input as Unicode codepoints (specifically, as lone surrogates, which are normally invalid in UTF-32). Upon output, these special codepoints are detected and turned back into the corresponding original byte.</source>
          <target state="translated">суффикс &lt;code&gt;//ROUNDTRIP&lt;/code&gt; будет использовать механизм перехода в стиле PEP383 для представления любых недопустимых байтов во входных данных как кодовых точек Unicode (в частности, как одиночные суррогаты, которые обычно недопустимы в UTF-32). После вывода эти специальные кодовые точки обнаруживаются и возвращаются в соответствующий исходный байт.</target>
        </trans-unit>
        <trans-unit id="8e864fd0038b9dc298144ef97f622ae11f451d8b" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//TRANSLIT&lt;/code&gt; will choose a replacement character for illegal sequences or code points.</source>
          <target state="translated">суффикс &lt;code&gt;//TRANSLIT&lt;/code&gt; выберет символ замены для недопустимых последовательностей или кодовых точек.</target>
        </trans-unit>
        <trans-unit id="3397cb671916c002d3ff115ddde37cc1a14cdaba" translate="yes" xml:space="preserve">
          <source>a suitable instance would be</source>
          <target state="translated">подходящим случаем было бы</target>
        </trans-unit>
        <trans-unit id="db956082ebbae6d6af67d17e3acdaaae903feef0" translate="yes" xml:space="preserve">
          <source>a suitable instance would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80c6eecdcbcce1a1bc8b7bef1f178ffa9e415f5" translate="yes" xml:space="preserve">
          <source>a type variable that names the result of a type family. Syntax: &lt;code&gt;= tyvar&lt;/code&gt; or &lt;code&gt;= (tyvar :: kind)&lt;/code&gt;. The type variable must be fresh.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
